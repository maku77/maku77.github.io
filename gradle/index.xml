<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gradle on 天才まくまくノート</title><link>https://maku77.github.io/gradle/</link><description>Recent content in Gradle on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 26 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/gradle/index.xml" rel="self" type="application/rss+xml"/><item><title>Gradle のプロパティを環境変数 (ORG_GRADLE_PROJECT) で定義する</title><link>https://maku77.github.io/p/2uxzo7h/</link><pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2uxzo7h/</guid><description>環境変数で Gradle プロジェクトのプロパティを設定する OS の環境変数として ORG_GRADLE_PROJECT_ というプレフィックスで始まる変数を定義しておくと、Gradle のビルドスクリプト内から、プロジェクトのプロパティとして参照できるようになります。 ユーザごとに異なる値（ユーザ ID やパスワード）を設定したいときに便利です。 下記の例では、Maven サーバ用のアクセス情報を示すプロパティ（MAVEN_USERNAME など）を設定しています。
~/.bash_profile export ORG_GRADLE_PROJECT_MAVEN_URL=http://repo.mycompany.com/maven2 export ORG_GRADLE_PROJECT_MAVEN_USERNAME=xxx export ORG_GRADLE_PROJECT_MAVEN_PASSWORD=yyy あとは、下記のようにビルドスクリプトの中から簡単に参照することができます。
build.gradle repositories { maven { credentials { username MAVEN_USERNAME password MAVEN_PASSWORD } url MAVEN_URL } } プロパティが設定されているかどうか確認する 定義されていないプロパティを参照しようとするとエラーが発生します。 プロジェクトのプロパティが定義されているかどうかを調べるには、以下のように project.has メソッドを使用します（project. は省略可能です）。
if (!project.has(&amp;#39;MAVEN_USERNAME&amp;#39;)) { println &amp;#39;ORG_GRADLE_PROJECT_MAVEN_USERNAME is not set&amp;#39; } 環境変数 ORG_GRADLE_PROJECT_xxx で定義された値も、プロジェクトのプロパティとして参照できるようになるため、上記のようにして定義されているかどうかを確認することができます。
参考 ORG_GRADLE_PROJECT プレフィックスの環境変数について (The Build Environment - Gradle User Guide) Maven リポジトリの Credential 設定 (Dependency Management - Gradle User Guide)</description></item><item><title>Groovy でパスワードなどをユーザに入力させる (readPassword)</title><link>https://maku77.github.io/p/yxha7mn/</link><pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yxha7mn/</guid><description>キーボードからのパスワード入力 Groovy を使用してユーザにパスワードを入力させるには、java.io.Console オブジェクトの readPassword メソッドを使用します。
sample.groovy def password = System.console().readPassword(&amp;#39;Password? &amp;#39;) println password 実行結果 $ groovy sample.groovy Password? （キーボードから abcabc と入力） abcabc</description></item><item><title>Groovy のクロージャ</title><link>https://maku77.github.io/p/b962btg/</link><pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/b962btg/</guid><description>クロージャの定義 Groovy におけるクロージャは、{ と } で囲まれた無名のコードブロックであり、通常のメソッドと同様にパラメータを受け取ったり、戻り値を返したりすることができます。 また、クロージャは変数への代入や、メソッドのパラメータとして渡すことが可能です。
下記は、渡されたパラメータを二乗するだけのクロージャの定義例です。 ここでは、定義したクロージャを square という名前の変数に代入し、後からメソッド呼び出しのように実行しています。
Closure square = { it * it } println square(3) 上記のように、クロージャに渡されるパラメータがひとつだけの場合は、デフォルトで it という名前で参照することができます（パラメータが渡されずに呼び出された場合、it の値は null になります）。 複数のパラメータを渡したい場合などは、下記のように定義します。
Closure add = { a, b -&amp;gt; a + b } println add(1, 2) クロージャの利用例 クロージャは、コレクションに格納された要素に対する処理を記述する際などに使用されます。 次の例では、リストオブジェクトの each メソッドに対してクロージャを渡しています。
list = [1, 2, 3] list.each() { println it * 2 } Groovy ベースのビルドツールである Gradle では、コンフィギュレーションブロックの記述でクロージャが活用されています。 下記は、Gradle ビルドスクリプトの抜粋です。
dependencies { compile project(&amp;#39;:mylib&amp;#39;) } まるで設定ファイルの独自構文のような記述ですが、Groovy の処理系から見れば、実は dependencies というメソッドにクロージャを 1 つ渡しているだけです。</description></item><item><title>Gradle でディレクトリ内のファイルを ZIP 圧縮する</title><link>https://maku77.github.io/p/p6bu2pa/</link><pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/p6bu2pa/</guid><description>Gradle のタスクとして、ZIP アーカイブを作成するサンプルです。
task createArchive(type: Zip) { from &amp;#39;docs/&amp;#39; archiveName &amp;#39;docs.zip&amp;#39; } 上記で定義した createArchive タスクを実行すると、docs ディレクトリ内のファイルをまとめた docs.zip アーカイブファイルを作成できます。
$ gradlew createArchive</description></item><item><title>Gradle によるビルドのボトルネックを探す（プロファイリング） (--profile)</title><link>https://maku77.github.io/p/ofoencn/</link><pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ofoencn/</guid><description>gradle コマンドを実行するときに、--profile オプションを追加して実行すると、ビルド中の各処理でどの程度時間がかかっているかのプロファイリング結果を出力してくれます。 プロファイリング結果は、build/reports/profile ディレクトリ以下に次のような HTML ファイルとして出力されます。
図: build/reports/profile/profile-2016-09-09-11-44-54.html Gradle によるビルドがあまりにも遅いと感じたら、このプロファイリング機能を使ってボトルネックを探るとよいです。</description></item><item><title>Gradle プラグインを作成する (2) JAR へのパッケージング</title><link>https://maku77.github.io/p/dyas9zg/</link><pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dyas9zg/</guid><description>配布可能な Gradle プラグインを作成する Gradle の独自プラグインを作成したら、最終的に JAR ファイルにパッケージングすることで、他のプロジェクトにも配布できるようになります。
配布用の Gradle プラグインをビルドするときにも Gradle を利用することができます。 プラグイン作成用のプロジェクトのディレクトリ構成は下記のような感じになります。 ここでは、com.mycompany.greeting という ID のプラグインを作成することとします（作成したプラグインは、apply plugin: 'com.mycompany.greeting' という形で適用できるようになります）。
GreetingPlugin +-- build.gradle +-- src/main/ +-- groovy/com/mycompany/greeting/GreetingPlugin.groovy +-- resources/META-INF/gradle-plugins/com.mycompany.greeting.properties 実装に使用する言語は Java でも構わないのですが、ここでは Groovy を使用しています。 ここからは、それぞれのファイルの内容を見ていきます。
ビルドスクリプト (build.gradle) ビルドスクリプトでは、プラグインの実装で Gradle パッケージを参照するための設定と、実装言語として Groovy を使用するための設定を行います。
build.gradle apply plugin: &amp;#39;groovy&amp;#39; dependencies { compile gradleApi() // org.gradle パッケージを使用するため compile localGroovy() // Groovy SDK を使用するため } プラグイン本体 (GreetingPlugin.groovy) この Groovy スクリプトで、Gradle プラグイン本体の実装を行います。 Plugin インタフェースを実装することで、このプラグインが適用されたときに実行される処理を定義します（ここでは、適用先のプロジェクトに hello タスクを追加しています）。</description></item><item><title>Gradle プラグインを作成する (1) Plugin クラスの基本</title><link>https://maku77.github.io/p/negnqwf/</link><pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/negnqwf/</guid><description>Gradle プラグイン作成の初歩 独自の Gradle プラグインを作成すると、下記のように各プロジェクトでプラグインを適用するだけで、そのプラグインが提供しているタスクを使えるようになります。
apply plugin: MyPlugin プラグインの実体は org.gradle.api.Plugin インタフェースを実装したクラスです。 上記のようにプラグインを適用すると、Plugin#apply() メソッドが呼び出されるため、例えば、その中でタスクを動的に追加するといった実装を行います。
下記の例では、MyPlugin というプラグイン実装を行っており、プラグインを適用したプロジェクトに対して動的に hello というタスクを追加しています。 単純化のためにプラグインの実装と、それ使用するコード (apply plugin: MyPlugin) を同じビルドスクリプト内に記述しています。
build.gradle // 独自プラグインの適用 apply plugin: MyPlugin // 独自プラグイン MyPlugin の実装 class MyPlugin implements Plugin&amp;lt;Project&amp;gt; { // プラグインを適用した時に呼び出される void apply(Project project) { println &amp;#39;MyPlugin has been applied!&amp;#39; // プラグインを適用したプロジェクトに hello タスクを追加 project.task(&amp;#39;hello&amp;#39;) &amp;lt;&amp;lt; { println &amp;#39;Hello MyPlugin!&amp;#39; } } } プラグインによって自動的に追加された hello タスクを実行してみます。
実行例 $ gradle -q hello MyPlugin has been applied!</description></item><item><title>Gradle で独自の Maven リポジトリを使用する</title><link>https://maku77.github.io/p/tmkh8p6/</link><pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tmkh8p6/</guid><description>Maven リポジトリの指定方法の基本 Gradle はライブラリの依存関係などを処理するために、インターネット上の Maven リポジトリである JCenter や Maven Central などを簡単に利用できるようになっています。 どのリポジトリを使用するかは repositories ブロックで下記のように指定します。
build.gradle repositories { jcenter() // Maven リポジトリとして JCenter を使用する mavenCentral() // Maven リポジトリとして Maven Central を使用する } ローカルリポジトリを指定する ローカルディレクトリに Maven リポジトリを作成して、ビルド時にそこからライブラリを引っ張ってくるようにすることもできます。 ローカルの Maven リポジトリを参照するためには、repository ブロックで mavenLocal() を実行します。
build.gradle repositories { jcenter() // Maven リポジトリとして JCenter を使用する mavenLocal() // Maven リポジトリとしてローカルディレクトリを使用する } デフォルトでは、下記のディレクトリがローカルの Maven リポジトリとして参照されます。
Linux/MacOSX の場合: $HOME/.m2 Windows の場合: %UserProfile%\.m2 リポジトリとするディレクトリを変更したい場合は、下記のように設定します。
repositories { maven { url &amp;#39;.</description></item><item><title>Gradle のプロジェクトとタスクとアクションを理解する</title><link>https://maku77.github.io/p/yqpxbpa/</link><pubDate>Fri, 29 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yqpxbpa/</guid><description>Gradle によるビルドは、少なくとも 1 つ以上の 「プロジェクト」 から構成されます。 プロジェクトは 1 つ以上の 「タスク」 を含み、タスク単位でビルド処理を実行できるようになっています。 各プロジェクトには build.gradle というビルドスクリプトを配置し、その中でタスクを定義していきます。
ビルド構成 +-- Project (build.gradle) | +-- Task | | +-- Action | | +-- Action | +-- Task | +-- Action | +-- Action +-- Project (build.gradle) +-- Project (build.gradle) +-- ... Gradle にはプラグインの仕組みがあり、複数のプロジェクトで再利用可能なタスクをプラグインの形で配布することができるようになっています。 インターネット上で公開されているプラグインを利用すれば、自分のプロジェクトに便利なタスクを簡単に組み込んでいくことができます（静的解析用のタスクや、デプロイ用のタスクなどを簡単に追加できる）。 タスク間に依存関係 (Dependency) を設定しておくことで、あるタスクを実行する前に先行して実行しなければいけないタスクを自動的に実行するように制御できます。
各タスクは、実行ブロックの単位である 「アクション」 を 1 つ以上含んでいます。 タスクを実行すると、それらのアクションが順番に実行されていくことになります。
プロジェクト、タスク、アクションは、Gradle の処理系内部では、それぞれ Project オブジェクト、Task オブジェクト、Action オブジェクトとしてインスタンス化されます。 ビルドスクリプトを記述していく上で、このようなオブジェクトが作成されていることを意識することが必要になってきます。</description></item><item><title>Gradle で PMD による静的解析を実行する</title><link>https://maku77.github.io/p/pz9gz3h/</link><pubDate>Mon, 14 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pz9gz3h/</guid><description>PMD プラグインの基本 Gradle には標準の静的解析プラグインとして、PMD が組み込まれています。 PMD でソースコードを解析すると、潜在的な不具合や、複雑度が高く将来的に負債になりそうなコードを検出することができます。 よい設計やコーディングができているかが一目瞭然になりますので、すべての Java プロジェクトに採用したいところです。
Gradle - PMD Plugin PMD PMD と似たような静的解析ツールに FindBugs がありますが、FindBugs がコンパイル後のクラスコードに対する解析であるのに対し、PMD はコンパイル前のソースコードを解析します。 無駄なコードはコンパイルの段階で最適化されて削除されてしまうことがあるため、このような無駄なコードを発見するためには、PMD で解析することが必要になります。 また、本家の PMD はコードクローンの発見などの機能 (CPD: Copy/Paste Detector) も備えていますが、Gradle の PMD プラグインはまだ CPD の直接サポートはされていないようです (2015-09-14)。
PMD の設定 PMD による静的解析を実施するには、下記のような感じで pmd プラグインを読み込んで設定します。
build.gradle apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;pmd&amp;#39; repositories { mavenCentral() } // PMD のコンフィギュレーション pmd { toolVersion &amp;#39;5.3.3&amp;#39; // 使用する PMD のバージョン ignoreFailures = true // PMD で警告が出てもビルドエラーにしない consoleOutput = true // コンソールにも解析結果を出力 ruleSets = [ // 適用する PMD ルール（プロジェクトごとに要調整） &amp;#39;java-basic&amp;#39;, // good practices which should be followed &amp;#39;java-braces&amp;#39;, // regarding the use and placement of braces &amp;#39;java-clone&amp;#39;, // questionable usages of the clone() method &amp;#39;java-codesize&amp;#39;, // problems related to code size or complexity &amp;#39;java-design&amp;#39;, // flag suboptimal code implementations &amp;#39;java-empty&amp;#39;, // empty statements of any kind &amp;#39;java-finalizers&amp;#39;, // problems that can occur with finalizers &amp;#39;java-imports&amp;#39;, // problems that can occur with import statements &amp;#39;java-strictexception&amp;#39;, // strict guidelines about throwing and catching exceptions &amp;#39;java-strings&amp;#39;, // manipulation of the String, StringBuffer, or StringBuilder instances &amp;#39;java-sunsecure&amp;#39;, // check the security guidelines from Sun &amp;#39;java-typeresolution&amp;#39;, // rules which resolve java Class files for comparison &amp;#39;java-unnecessary&amp;#39;, // find useless or unnecessary code &amp;#39;java-unusedcode&amp;#39; // find unused or ineffective code ] } PMD プラグインによって、pmdMain や pmdTest などのタスクが定義されます。 これらのタスクは、check タスクに依存するタスクとして定義されるので、check タスクを定義する java プラグインも読み込んでおく必要があります。</description></item><item><title>Gradle デーモンを使って gradle コマンドを高速化する (org.gradle.daemon)</title><link>https://maku77.github.io/p/szhzejv/</link><pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/szhzejv/</guid><description>Gradle デーモンの立ち上げ gradle コマンドを実行すると、デフォルトでは毎回 Java のバーチャルマシンを起動するため、下記のような簡単なタスクを実行するだけでも 2、3 秒の実行時間がかかってしまいます。
build.gradle task hello &amp;lt;&amp;lt; { println &amp;#39;Hello&amp;#39; } 実行結果 $ gradle hello :hello Hello BUILD SUCCESSFUL Total time: 2.353 secs gradle コマンドを実行するときに、--daemon オプションを付けるようにすると、Gradle のプロセスを常駐させ（デーモン化）、そのプロセスを毎回のビルドで使いまわすようになります。 初回はデーモンの立ち上げのために時間がかかりますが、2 度目からのビルドは高速に実行することができます。 下記の実行例を見ると、1 秒以内に処理できていることがわかります。
実行結果（--daemonオプションあり） $ gradle --daemon hello :hello Hello BUILD SUCCESSFUL Total time: 0.905 secs ちなみに、常駐している Gradle のプロセスは、3 時間使用されないと自動的に終了します。 下記のように明示的に停止することもできます。
$ gradle --stop Stopping daemon(s). Gradle daemon stopped. Gradle デーモンをデフォルトで有効にする gradle コマンドに毎回 --daemon オプションを付けるのが面倒な場合は、Gradle の設定ファイル (gradle.properties) でデーモンを常に有効にすることができます。</description></item><item><title>Groovy でクラスを定義する</title><link>https://maku77.github.io/p/j5bvcq9/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/j5bvcq9/</guid><description>クラスを定義する Groovy では、クラスやメソッドの可視性はデフォルトで public になります。 下記の Book クラスは title と authors フィールドを持っており、両方とも外部から参照できます。
sample.groovy class Book { def title def authors = [] def getLabel() { title + &amp;#39;, &amp;#39; + authors } String toString() { getLabel() } } def book = new Book() book.title = &amp;#39;Title1&amp;#39; book.authors &amp;lt;&amp;lt; &amp;#39;Author1&amp;#39; &amp;lt;&amp;lt; &amp;#39;Author2&amp;#39; &amp;lt;&amp;lt; &amp;#39;Author3&amp;#39; println book 実行例 $ groovy sample.groovy Title1, [Author1, Author2, Author3] 上記の例では、book.title というプロパティに直接アクセスしているかのように見えますが、内部的には、自動的に生成された book.getTitle() という getter メソッドが呼び出されています。 同様に、book.setTitle() という setter メソッドも自動的に生成されています。</description></item><item><title>Groovy でマップ (Map) を扱う</title><link>https://maku77.github.io/p/ohhdpvf/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ohhdpvf/</guid><description>Groovy の Map の基本 Groovy の Map インスタンスは、List インスタンスと同様に [ と ] を使用して定義することができます。 ただし、各要素はコロン (:) で区切って、キーと値を指定します。 内部的には、java.util.LinkedHashMap インスタンスが生成されています。
def map = [xxx:100, yyy:200, zzz:300] assert map.getClass() == java.util.LinkedHashMap assert map.size() == 3 assert map.xxx == 100 assert map[&amp;#39;xxx&amp;#39;] == 100 Map の要素を列挙する Map の要素は、List の要素と同様に each メソッドを使ってイテレートすることができます。
map.each { key, val -&amp;gt; println key + &amp;#39;:&amp;#39; + val } 空の Map インスタンスを生成する 空の Map インスタンスを生成するときは、ちょっと特殊ですが下記のように記述する必要があります。
def map = [:] // 空の Map 真ん中のコロン : を省略してしまうと、List オブジェクトの生成とみなされてしまいます。</description></item><item><title>Groovy でメソッドを定義する</title><link>https://maku77.github.io/p/6qzzzry/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qzzzry/</guid><description>下記のサンプルでは、2 つの変数を足し合わせる add メソッドを定義しています。
sample.groovy // メソッドの定義 def add(a, b) { a + b } // メソッドの呼び出し def val = add(100, 200) println val Groovy では、他の多くのスクリプト言語と同様に、メソッド内で最後に評価された式の値がそのまま戻り値となるので、return キーワードを省略することができます。 また、パラメータの型や、戻り値の型も明示する必要はありません（最初に def とだけ書けばよい）。
次のように型を明示することもできます。
int add(int a, int b) { a + b } 戻り値がないことを明示したいのであれば、Java と同様に void と定義することもできます。 戻り値の型が void のメソッドの戻り値を強引に取得しようとすると、null が返されます。
void greet(String name) { println &amp;#39;Hello, &amp;#39; + name } def val = greet(&amp;#39;Jack&amp;#39;) println val //=&amp;gt; null メソッド呼び出し時のパラメータを囲む括弧は、次のように省略することができます。
def val = add 100, 200 ただし、パラメータを 1 つも持たない場合は、呼び出し時の括弧を省略することはできません。</description></item><item><title>Groovy でリスト (List) を扱う</title><link>https://maku77.github.io/p/z9qmfd4/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z9qmfd4/</guid><description>Groovy のリストの基本 Groovy では、[1, 2, 3] といった構文を使用して、簡単に List インスタンスを生成することができます。 内部的には java.util.ArrayList のインスタンスが生成されます。 下記の例では、3 つの要素を持つ List インスタンスを生成しています。
def list = [100, &amp;#39;AAA&amp;#39;, 0.25] assert list.getClass() == java.util.ArrayList assert list.size() == 3 assert list[0] == 100 リストへの要素の追加 リストの末尾に要素を追加する場合、&amp;lt;&amp;lt; というショートカット記法を使用することができます。
def list = [] list &amp;lt;&amp;lt; 100 list &amp;lt;&amp;lt; 200 list &amp;lt;&amp;lt; 300 println list //=&amp;gt; [100, 200, 300] これは、下記のように add メソッドを呼び出すのと同等の動作をします。
def list = [] list.add 100 list.add 200 list.add 300 println list //=&amp;gt; [100, 200, 300] あまり違いはないように見えますが、&amp;lt;&amp;lt; を使った方が可読性は若干上がるようです。 また、&amp;lt;&amp;lt; を使うことにより、下記のように連続して要素を追加することが可能です。</description></item><item><title>Groovy で文字列リテラルを扱う</title><link>https://maku77.github.io/p/v8m6rme/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v8m6rme/</guid><description>文字列リテラルと GStrings Groovy の文字列リテラルは、シングルクォート (') あるいは、ダブルクォート (&amp;quot;) で囲んで表現します。 ダブルクォートで囲んだ文字列リテラルは、$ で始まる変数が展開されます。 このような変数を含む文字列を GStrings (Groovy Strings) と呼びます。
sample.groovy def name = &amp;#39;Britney&amp;#39; println &amp;#39;Hello $name&amp;#39; println &amp;#34;Hello $name&amp;#34; 実行結果 Hello $name Hello Britney 文字列の中の式 ${式} という構文を使用すると、文字列の中で任意の式を実行することができます。
sample.groovy def name = &amp;#39;mickey&amp;#39; println &amp;#34;Hello ${name.capitalize()}&amp;#34; 実行結果 Hello Mickey ヒアドキュメント 3 連続のクォーテーションマーク（''' あるいは &amp;quot;&amp;quot;&amp;quot;）で文字列を囲むことによって、複数行にまたがる文字列リテラル（ヒアドキュメント）を定義することができます。 通常の文字列リテラルと同様に、ダブルクォート (&amp;quot;) で囲んだ場合だけ、$ で始まる変数が展開されます。
def html = &amp;#34;&amp;#34;&amp;#34;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;$title&amp;lt;/title&amp;gt; &amp;lt;head&amp;gt; &amp;lt;body&amp;gt; $body &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;&amp;#34;&amp;#34;&amp;#34;</description></item><item><title>Groovy で assert を使用する</title><link>https://maku77.github.io/p/m9veity/</link><pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m9veity/</guid><description>Groovy では、デフォルトで assert が使用できるようになっています。
sample.groovy def num = 100 assert num.getClass() == java.lang.Integer def str = &amp;#39;Hello&amp;#39; assert str.getClass() == java.lang.Integer 上記のスクリプトを実行すると、2 つ目の assert で fail して、下記のように詳細な情報が表示されます。 分かりやすいですね！
$ groovy sample.groovy Assertion failed: assert str.getClass() == java.lang.Integer | | | | | false | class java.lang.String Hello at sample.run(sample.groovy:5)</description></item><item><title>Groovy と Java の違い</title><link>https://maku77.github.io/p/som2e4k/</link><pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/som2e4k/</guid><description>Groovy は Java と異なり、下記のような特徴を持っています。
行末のセミコロンは省略できる クラス、コンストラクタ、メソッドはデフォルトで public となる return の記述は省略できる（最後に評価された式が戻り値となる） getter/setter メソッドが自動的に作られる（obj.prop のようにアクセスすれば obj.getProp や setProp が呼び出される） == によるオブジェクトの比較は、自動的に equals による比較となる（しかも null チェックの必要はない） assert は常に有効（Java の場合は -ea or --enable-assertion オプションの指定が必要） 変数の型や、メソッドの戻り値の型は def としておけば、自動で判別してくれる コレクション（List や Map）の扱いがシンプルで Python や Ruby に近い構文で記述できる</description></item><item><title>Gradle 実行時の 3 つのフェーズ (initialization, configuration, execution)</title><link>https://maku77.github.io/p/o7yqmcx/</link><pubDate>Sun, 08 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o7yqmcx/</guid><description>3 つのフェーズ Gradle によるビルドを実行するとき、内部では下記のような 3 つのフェーズに分けてビルドが実行されていきます。
Initialization フェーズ Configuration フェーズ Execution フェーズ (1) Initialization フェーズ マルチプロジェクトにおけるプロジェクトの依存関係が解決され、プロジェクトのビルド順序が決められるフェーズです。 サブプロジェクトの構成は、トップレベルのディレクトリに置かれる settings.gradle ファイルで定義されます（Gradle の内部では、このファイルを基に Settings オブジェクトが生成されています）。
settings.gradle include &amp;#39;subproject1&amp;#39; include &amp;#39;subproject2&amp;#39; また、プロジェクトごとに Gradle 内部で Project インスタンスが生成されています（マルチプロジェクトなビルド構成であれば、複数の Project インスタンスが生成されます）。 プロジェクトの依存関係は、各プロジェクトの dependencies ブロック内で定義されます。
dependencies { compile project(&amp;#39;:subproject&amp;#39;) ... } (2) Configuration フェーズ すべてのプロジェクトの build.gradle が処理され、すべてのタスクの依存関係を認識するフェーズです。 タスクの依存関係は、下記のように dependsOn プロパティで指定されます。
task task2(dependsOn: task1) &amp;lt;&amp;lt; { println &amp;#39;Hello task2&amp;#39; } 上記の例では依存タスクを task1 というオブジェクトで指定していますが、'task1' のように、文字列でタスク名を指定することもできます。 文字列でタスク名を指定することにより、その時点でまだ定義されていないタスクを指定することができます。 Configuration フェーズでは、すべてのタスク定義を走査するため、最終的にはすべての依存関係が問題なく解決されます（逆に、Configuration フェーズ終了時に未解決なタスクがあるとエラーになります）。
Gradle の処理系内部では、依存グラフ (dependency graph) が生成されています。</description></item><item><title>Gradle のプロキシを設定する (gradle.properties)</title><link>https://maku77.github.io/p/5x6qgkx/</link><pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5x6qgkx/</guid><description>gradle コマンド実行時に Maven リポジトリにアクセスしたり、Gradle Wrapper をインストールするためのアーカイブをダウンロードしたりする際にネットワークアクセスが発生します。 これらのアクセスをプロキシ経由で行う必要がある場合は、gradle.properties ファイルにプロキシの設定を記述します。
用途 設定ファイル プロジェクトごとの設定 &amp;lt;project&amp;gt;/gradle.properties ユーザごとの設定 (macOS/Linux) $HOME/.gradle/gradle.properties ユーザごとの設定 (Windows) %USERPROFILE%/.gradle/gradle.properties 以下のように設定します。
gradle.properties systemProp.http.proxyHost=&amp;lt;ホスト&amp;gt; systemProp.http.proxyPort=&amp;lt;ポート番号&amp;gt; systemProp.http.proxyUser=&amp;lt;ユーザ&amp;gt; systemProp.http.proxyPassword=&amp;lt;パスワード&amp;gt; systemProp.https.proxyHost=&amp;lt;ホスト&amp;gt; systemProp.https.proxyPort=&amp;lt;ポート番号&amp;gt; systemProp.https.proxyUser=&amp;lt;ユーザ&amp;gt; systemProp.https.proxyPassword=&amp;lt;パスワード&amp;gt; 設定例 systemProp.http.proxyHost=proxy.example.com systemProp.http.proxyPort=8080 systemProp.https.proxyHost=proxy.example.com systemProp.https.proxyPort=8080</description></item><item><title>Gradle をインストールする (macOS/Windows)</title><link>https://maku77.github.io/p/6qdfg4d/</link><pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qdfg4d/</guid><description>macOS への Gradle インストール ここでは、GVM (Groovy enVironment Manager) を使って gradle コマンドをインストールします。 GVM を使うと、複数バージョンの Gradle を管理することができます。
GVM のインストール
$ curl -s get.gvmtool.net | bash GVM で gradle のインストール
$ gvm install gradle 動作確認
$ gradle --version Windows への Gradle インストール https://gradle.org/install/ から gradle-1.12-bin.zip などをダウンロードして、適当なディレクトリに配置します。 gradle コマンドを実行するには、java コマンドを実行できるようになっている必要があります。 任意のバージョンの java コマンドを使用するには、JAVA_HOME 環境変数を設定しておきます。
C:\&amp;gt; set JAVA_HOME=C:\Program Files\Java\jdk1.8.0_05 （binまでは含めないことに注意） gradle コマンドを任意のディレクトリから実行できるように、PATH を通しておきます。
C:\&amp;gt; set PATH=%PATH%;C:\app\gradle-1.12\bin 実行テスト C:\&amp;gt; gradle -v ------------------------------------------------------------ Gradle 1.12 ------------------------------------------------------------ Build time: 2014-04-29 09:24:31 UTC Build number: none Revision: a831fa866d46cbee94e61a09af15f9dd95987421 Groovy: 1.</description></item><item><title>Gradle をインストールする (macOS/Windows)</title><link>https://maku77.github.io/p/6qdfg4d/</link><pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qdfg4d/</guid><description>macOS への Gradle インストール ここでは、GVM (Groovy enVironment Manager) を使って gradle コマンドをインストールします。 GVM を使うと、複数バージョンの Gradle を管理することができます。
GVM のインストール
$ curl -s get.gvmtool.net | bash GVM で gradle のインストール
$ gvm install gradle 動作確認
$ gradle --version Windows への Gradle インストール https://www.gradle.org/downloads から gradle-1.12-bin.zip などをダウンロードして、適当なディレクトリに配置します。 gradle コマンドを実行するには、java コマンドを実行できるようになっている必要があります。 任意のバージョンの java コマンドを使用するには、JAVA_HOME 環境変数を設定しておきます。
C:\&amp;gt; set JAVA_HOME=C:\Program Files\Java\jdk1.8.0_05 （binまでは含めないことに注意） gradle コマンドを任意のディレクトリから実行できるように、PATH を通しておきます。
C:\&amp;gt; set PATH=%PATH%;C:\app\gradle-1.12\bin 実行テスト C:\&amp;gt; gradle -v ------------------------------------------------------------ Gradle 1.12 ------------------------------------------------------------ Build time: 2014-04-29 09:24:31 UTC Build number: none Revision: a831fa866d46cbee94e61a09af15f9dd95987421 Groovy: 1.</description></item></channel></rss>