<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Gradle on 天才まくまくノート</title><link>https://maku77.github.io/gradle/</link><description>Recent content in Gradle on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 26 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/gradle/index.xml" rel="self" type="application/rss+xml"/><item><title>Gradle Wrapper スクリプト (gradlew) をサブプロジェクトから簡単に呼び出せるようにする</title><link>https://maku77.github.io/p/je3xamc/</link><pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/je3xamc/</guid><description>Gradle Wrapper Wrapper (gradleww) とは Gradle Wrapper Wrapper (gradleww) を使用すると、サブプロジェクト（サブディレクトリ）で作業しているときに、プロジェクトのルートにおいてある gradlew を簡単に呼び出すことができるようになります。
例えば、通常はサブプロジェクトで作業しているときは、gradlew コマンドを実行するときにこんな感じで実行することになります。
$ ../../gradlew assembleDebug gradlew の代わりに gradleww コマンドを実行するようにすれば、次のように簡単に呼び出すことができます（内部で自動的に上位ディレクトリの gradlew を実行してくれます）。
$ gradleww assembleDebug Gradle Wrapper (gradlew) をさらにラップしたコマンドのため、Gradle Wrapper Wrapper (gradleww) と呼んでいます。
Gradlew Wrapper Wrapper (gradleww) のインストール Gradle Wrapper Wrapper（gradleww コマンド）は、RubyGems パッケージとして配布されているため、Ruby 環境がインストールされていれば、下記のように簡単にインストールすることができます。
$ gem install gradleww</description></item><item><title>Gradle のプロパティを環境変数 (ORG_GRADLE_PROJECT) で定義する</title><link>https://maku77.github.io/p/2uxzo7h/</link><pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2uxzo7h/</guid><description>環境変数で Gradle プロジェクトのプロパティを設定する OS の環境変数として ORG_GRADLE_PROJECT_ というプレフィックスで始まる変数を定義しておくと、Gradle のビルドスクリプト内から、プロジェクトのプロパティとして参照できるようになります。 ユーザごとに異なる値（ユーザ ID やパスワード）を設定したいときに便利です。 下記の例では、Maven サーバ用のアクセス情報を示すプロパティ（MAVEN_USERNAME など）を設定しています。
~/.bash_profile export ORG_GRADLE_PROJECT_MAVEN_URL=http://repo.mycompany.com/maven2 export ORG_GRADLE_PROJECT_MAVEN_USERNAME=xxx export ORG_GRADLE_PROJECT_MAVEN_PASSWORD=yyy あとは、下記のようにビルドスクリプトの中から簡単に参照することができます。
build.gradle repositories { maven { credentials { username MAVEN_USERNAME password MAVEN_PASSWORD } url MAVEN_URL } } プロパティが設定されているかどうか確認する 定義されていないプロパティを参照しようとするとエラーが発生します。 プロジェクトのプロパティが定義されているかどうかを調べるには、以下のように project.has メソッドを使用します（project. は省略可能です）。
if (!project.has(&amp;#39;MAVEN_USERNAME&amp;#39;)) { println &amp;#39;ORG_GRADLE_PROJECT_MAVEN_USERNAME is not set&amp;#39; } 環境変数 ORG_GRADLE_PROJECT_xxx で定義された値も、プロジェクトのプロパティとして参照できるようになるため、上記のようにして定義されているかどうかを確認することができます。
参考 ORG_GRADLE_PROJECT プレフィックスの環境変数について (The Build Environment - Gradle User Guide) Maven リポジトリの Credential 設定 (Dependency Management - Gradle User Guide)</description></item><item><title>Groovy でパスワードなどをユーザに入力させる (readPassword)</title><link>https://maku77.github.io/p/yxha7mn/</link><pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yxha7mn/</guid><description>キーボードからのパスワード入力 Groovy を使用してユーザにパスワードを入力させるには、java.io.Console オブジェクトの readPassword メソッドを使用します。
sample.groovy def password = System.console().readPassword(&amp;#39;Password? &amp;#39;) println password 実行結果 $ groovy sample.groovy Password? （キーボードから abcabc と入力） abcabc</description></item><item><title>Groovy のクロージャ</title><link>https://maku77.github.io/p/b962btg/</link><pubDate>Thu, 13 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/b962btg/</guid><description>クロージャの定義 Groovy におけるクロージャは、{ と } で囲まれた無名のコードブロックであり、通常のメソッドと同様にパラメータを受け取ったり、戻り値を返したりすることができます。 また、クロージャは変数への代入や、メソッドのパラメータとして渡すことが可能です。
下記は、渡されたパラメータを二乗するだけのクロージャの定義例です。 ここでは、定義したクロージャを square という名前の変数に代入し、後からメソッド呼び出しのように実行しています。
Closure square = { it * it } println square(3) 上記のように、クロージャに渡されるパラメータがひとつだけの場合は、デフォルトで it という名前で参照することができます（パラメータが渡されずに呼び出された場合、it の値は null になります）。 複数のパラメータを渡したい場合などは、下記のように定義します。
Closure add = { a, b -&amp;gt; a + b } println add(1, 2) クロージャの利用例 クロージャは、コレクションに格納された要素に対する処理を記述する際などに使用されます。 次の例では、リストオブジェクトの each メソッドに対してクロージャを渡しています。
list = [1, 2, 3] list.each() { println it * 2 } Groovy ベースのビルドツールである Gradle では、コンフィギュレーションブロックの記述でクロージャが活用されています。 下記は、Gradle ビルドスクリプトの抜粋です。
dependencies { compile project(&amp;#39;:mylib&amp;#39;) } まるで設定ファイルの独自構文のような記述ですが、Groovy の処理系から見れば、実は dependencies というメソッドにクロージャを 1 つ渡しているだけです。</description></item><item><title>Gradle でディレクトリ内のファイルを ZIP 圧縮する (type: Zip)</title><link>https://maku77.github.io/p/p6bu2pa/</link><pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/p6bu2pa/</guid><description>Gradle でディレクトリ内のファイルを ZIP 圧縮するには、次のように Zip 型のタスクを定義します。
task createArchive(type: Zip) { from &amp;#39;docs/&amp;#39; archiveName &amp;#39;docs.zip&amp;#39; } このように定義した createArchive タスクを実行すると、docs ディレクトリ内のファイルをまとめた docs.zip アーカイブファイルを作成できます。
$ gradlew createArchive</description></item><item><title>Gradle によるビルドのボトルネックを探す（プロファイリング） (--profile)</title><link>https://maku77.github.io/p/ofoencn/</link><pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ofoencn/</guid><description>gradle コマンドを実行するときに、--profile オプションを追加して実行すると、ビルド中の各処理でどの程度時間がかかっているかのプロファイリング結果を出力してくれます。 プロファイリング結果は、build/reports/profile ディレクトリ以下に次のような HTML ファイルとして出力されます。
図: build/reports/profile/profile-2016-09-09-11-44-54.html Gradle によるビルドがあまりにも遅いと感じたら、このプロファイリング機能を使ってボトルネックを探るとよいです。</description></item><item><title>Gradle プラグインを作成する (2) JAR へのパッケージング</title><link>https://maku77.github.io/p/dyas9zg/</link><pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dyas9zg/</guid><description>配布可能な Gradle プラグインを作成する Gradle の独自プラグインを作成したら、最終的に JAR ファイルにパッケージングすることで、他のプロジェクトにも配布できるようになります。
配布用の Gradle プラグインをビルドするときにも Gradle を利用することができます。 プラグイン作成用のプロジェクトのディレクトリ構成は下記のような感じになります。 ここでは、com.mycompany.greeting という ID のプラグインを作成することとします（作成したプラグインは、apply plugin: 'com.mycompany.greeting' という形で適用できるようになります）。
GreetingPlugin +-- build.gradle +-- src/main/ +-- groovy/com/mycompany/greeting/GreetingPlugin.groovy +-- resources/META-INF/gradle-plugins/com.mycompany.greeting.properties 実装に使用する言語は Java でも構わないのですが、ここでは Groovy を使用しています。 ここからは、それぞれのファイルの内容を見ていきます。
ビルドスクリプト (build.gradle) ビルドスクリプトでは、プラグインの実装で Gradle パッケージを参照するための設定と、実装言語として Groovy を使用するための設定を行います。
build.gradle apply plugin: &amp;#39;groovy&amp;#39; dependencies { compile gradleApi() // org.gradle パッケージを使用するため compile localGroovy() // Groovy SDK を使用するため } プラグイン本体 (GreetingPlugin.groovy) この Groovy スクリプトで、Gradle プラグイン本体の実装を行います。 Plugin インタフェースを実装することで、このプラグインが適用されたときに実行される処理を定義します（ここでは、適用先のプロジェクトに hello タスクを追加しています）。</description></item><item><title>Gradle プラグインを作成する (1) Plugin クラスの基本</title><link>https://maku77.github.io/p/negnqwf/</link><pubDate>Tue, 16 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/negnqwf/</guid><description>Gradle プラグイン作成の初歩 独自の Gradle プラグインを作成すると、下記のように各プロジェクトでプラグインを適用するだけで、そのプラグインが提供しているタスクを使えるようになります。
apply plugin: MyPlugin プラグインの実体は org.gradle.api.Plugin インタフェースを実装したクラスです。 上記のようにプラグインを適用すると、Plugin#apply() メソッドが呼び出されるため、例えば、その中でタスクを動的に追加するといった実装を行います。
下記の例では、MyPlugin というプラグイン実装を行っており、プラグインを適用したプロジェクトに対して動的に hello というタスクを追加しています。 単純化のためにプラグインの実装と、それ使用するコード (apply plugin: MyPlugin) を同じビルドスクリプト内に記述しています。
build.gradle // 独自プラグインの適用 apply plugin: MyPlugin // 独自プラグイン MyPlugin の実装 class MyPlugin implements Plugin&amp;lt;Project&amp;gt; { // プラグインを適用した時に呼び出される void apply(Project project) { println &amp;#39;MyPlugin has been applied!&amp;#39; // プラグインを適用したプロジェクトに hello タスクを追加 project.task(&amp;#39;hello&amp;#39;) &amp;lt;&amp;lt; { println &amp;#39;Hello MyPlugin!&amp;#39; } } } プラグインによって自動的に追加された hello タスクを実行してみます。
実行例 $ gradle -q hello MyPlugin has been applied!</description></item><item><title>Gradle で独自の Maven リポジトリを使用する</title><link>https://maku77.github.io/p/tmkh8p6/</link><pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tmkh8p6/</guid><description>Maven リポジトリの指定方法の基本 Gradle はライブラリの依存関係などを処理するために、インターネット上の Maven リポジトリである JCenter や Maven Central などを簡単に利用できるようになっています。 どのリポジトリを使用するかは repositories ブロックで下記のように指定します。
build.gradle repositories { jcenter() // Maven リポジトリとして JCenter を使用する mavenCentral() // Maven リポジトリとして Maven Central を使用する } ローカルリポジトリを指定する ローカルディレクトリに Maven リポジトリを作成して、ビルド時にそこからライブラリを引っ張ってくるようにすることもできます。 ローカルの Maven リポジトリを参照するためには、repository ブロックで mavenLocal() を実行します。
build.gradle repositories { jcenter() // Maven リポジトリとして JCenter を使用する mavenLocal() // Maven リポジトリとしてローカルディレクトリを使用する } デフォルトでは、下記のディレクトリがローカルの Maven リポジトリとして参照されます。
Linux/MacOSX の場合: $HOME/.m2 Windows の場合: %UserProfile%\.m2 リポジトリとするディレクトリを変更したい場合は、下記のように設定します。
repositories { maven { url &amp;#39;.</description></item><item><title>Gradle のプロジェクトとタスクとアクションを理解する</title><link>https://maku77.github.io/p/yqpxbpa/</link><pubDate>Fri, 29 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yqpxbpa/</guid><description>Gradle によるビルドは、少なくとも 1 つ以上の 「プロジェクト」 から構成されます。 プロジェクトは 1 つ以上の 「タスク」 を含み、タスク単位でビルド処理を実行できるようになっています。 各プロジェクトには build.gradle というビルドスクリプトを配置し、その中でタスクを定義していきます。
ビルド構成 +-- Project (build.gradle) | +-- Task | | +-- Action | | +-- Action | +-- Task | +-- Action | +-- Action +-- Project (build.gradle) +-- Project (build.gradle) +-- ... Gradle にはプラグインの仕組みがあり、複数のプロジェクトで再利用可能なタスクをプラグインの形で配布することができるようになっています。 インターネット上で公開されているプラグインを利用すれば、自分のプロジェクトに便利なタスクを簡単に組み込んでいくことができます（静的解析用のタスクや、デプロイ用のタスクなどを簡単に追加できる）。 タスク間に依存関係 (Dependency) を設定しておくことで、あるタスクを実行する前に先行して実行しなければいけないタスクを自動的に実行するように制御できます。
各タスクは、実行ブロックの単位である 「アクション」 を 1 つ以上含んでいます。 タスクを実行すると、それらのアクションが順番に実行されていくことになります。
プロジェクト、タスク、アクションは、Gradle の処理系内部では、それぞれ Project オブジェクト、Task オブジェクト、Action オブジェクトとしてインスタンス化されます。 ビルドスクリプトを記述していく上で、このようなオブジェクトが作成されていることを意識することが必要になってきます。</description></item><item><title>Gradle でプロパティファイル (.properties) を読み込む</title><link>https://maku77.github.io/p/quhymp7/</link><pubDate>Thu, 12 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/quhymp7/</guid><description>独自のプロパティファイルを参照する Gradle ビルドスクリプトで Properties クラスを利用すると、任意の .properties ファイルを簡単に読み込むことができます。 例えば、次のような sample.properties をプロジェクトのルートディレクトに置いて、これを読み込んでみます。
sample.properties key1=value1 key2=value2 下記ビルドスクリプトの loadProperties メソッドでは、指定した .properties ファイルを読み込んでオブジェクトとして返しています。
build.gradle /** * Reads properties from the specified .properties file. */ def loadProperties(filename) { def props = new Properties() file(filename).withInputStream { props.load(it) } return props } task hello &amp;lt;&amp;lt; { def props = loadProperties(&amp;#34;$rootDir/sample.properties&amp;#34;) println &amp;#34;props.key1 = ${props.key1}&amp;#34; println &amp;#34;props.key2 = ${props.key2}&amp;#34; } 実行結果 $ gradle -q hello props.key1 = value1 props.key2 = value2 読み込んだプロパティ設定を、プロジェクト全体から参照できるようにしたいときは、次のようにプロジェクトの ext プロパティに設定してしまえば OK です。</description></item><item><title>Gradle で JUnit のカバレッジレポートを生成する (JaCoCo)</title><link>https://maku77.github.io/p/tesecus/</link><pubDate>Fri, 25 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tesecus/</guid><description>JaCoCo Plugin を使用すると、JUnit などによるユニットテスト結果のカバレッジレポートを生成することができます。 カバレッジレポートは、そのままブラウザで見ることのできる HTML 形式や、Jenkins などの CI サーバで扱う exec データなどの形式で出力できます。
Gradle JaCoCo Plugin 図: HTML 形式の JaCoCo カバレッジレポートの例 下記は jacoco というタスクを定義する例です。
build.gradle apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;jacoco&amp;#39; repositories { mavenCentral() } dependencies { testCompile &amp;#39;junit:junit:4.+&amp;#39; } jacoco { toolVersion = &amp;#34;0.7.+&amp;#34; // reportsDir = file(&amp;#34;$buildDir/reports/jacoco&amp;#34;) } task jacoco(type: JacocoReport, dependsOn: &amp;#39;test&amp;#39;) { sourceSets sourceSets.main executionData = files(tasks.jacocoTestReport.executionData) reports { html.enabled = true xml.enabled = true csv.enabled = true } } カバレッジレポートを生成するには、ユニットテストの結果が必要なので、jacoco タスクは test タスクに依存するように定義しています。 テストカバレッジを生成するには、下記のように実行します。</description></item><item><title>Gradle で JUnit によるユニットテストを実行する</title><link>https://maku77.github.io/p/x6f9r2o/</link><pubDate>Thu, 24 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x6f9r2o/</guid><description>JUnit の設定とテストコードの作成 Java プロジェクトにおいて JUnit を使ったユニットテストコードを記述するには、build.gradle スクリプトに下記のように JUnit 用の設定を行っておきます。
build.gradle apply plugin: &amp;#39;java&amp;#39; repositories { mavenCentral() } dependencies { testCompile &amp;#39;junit:junit:4.+&amp;#39; } テスト対象のプロダクトコードとそのテストコードは、下記のようなディレクトリ構成で配置します。
src/main/java/com/example/Sample.java &amp;hellip; プロダクトコード src/test/java/com/example/SampleTest.java &amp;hellip; テストコード Sample.java（実装例） package com.example; public class Sample { public static int add(int a, int b) { return a + b; } } SampleTest.java（実装例） package com.example; import org.junit.Test; import static org.junit.Assert.*; public class SampleTest { @Test public void testAdd() { assertEquals(3, Sample.add(1, 2)); } } ちなみに、JUnit 4.</description></item><item><title>Gradle でユニットテストの結果をコンソールに詳しく表示する</title><link>https://maku77.github.io/p/8ot95rq/</link><pubDate>Thu, 24 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8ot95rq/</guid><description>Gradle でのユニットテストの実行結果が失敗の場合、デフォルトでは下記のようなそっけない表示しかしてくれません。
$ gradle test ... com.example.LargeTest &amp;gt; testAdd FAILED java.lang.AssertionError at SampleTest.java:9 2 tests completed, 1 failed build/reports/tests 以下に生成されるテストレポートを見れば、その内容を確認できますが、コンソール上でもう少し詳しい結果を確認したい場合は、-i オプションを指定してログレベルを INFO に設定して test タスクを実行します。
$ gradle test -i ... com.example.SampleTest &amp;gt; testAdd FAILED java.lang.AssertionError: expected:&amp;lt;4&amp;gt; but was:&amp;lt;3&amp;gt; at org.junit.Assert.fail(Assert.java:88) at org.junit.Assert.failNotEquals(Assert.java:834) at org.junit.Assert.assertEquals(Assert.java:645) at org.junit.Assert.assertEquals(Assert.java:631) at com.example.SampleTest.testAdd(SampleTest.java:9) 1 test completed, 1 failed ... ただし、INFO レベルでログを出力すると、余計な出力が多く出てしまって見づらくなります。 build.gradle スクリプトの中で、下記のように exceptionFormat を指定しておくと、上記のような例外部分だけを詳しく表示してくれるようになります（この場合 -i オプションを付けて test タスクを実行する必要はありません）。
test { testLogging { exceptionFormat &amp;#39;full&amp;#39; } } デフォルトではメソッドごとのテスト経過は表示されませんが、テスト経過をコンソール上で詳しく確認したい場合は、下記のように events 設定を行います。</description></item><item><title>Gradle でユニットテストを並列実行する (test.forkEvery, test.maxParallelForks)</title><link>https://maku77.github.io/p/pxkr6wv/</link><pubDate>Thu, 24 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pxkr6wv/</guid><description>Gradle によるユニットテスト実行は、デフォルトではシーケンシャルに 1 つずつ行われていきます。 テストクラス数が多くなった場合は、並列実行することによって全体のテストにかかる時間を減らすことができます。
test.forkEvery と test.maxParallelForks でテスト実行用のプロセスをどう fork するかを制御することができます。
test.forkEvery &amp;hellip; 何個のクラスごとにテストプロセスを fork するか（どのくらい積極的に並列化するか） test.maxParallelForks &amp;hellip; 最大何個のテストプロセスを fork するか（最大並列実行数） 下記の例では、「CPU数−1」個まで同時実行することと、クラス 4 つごとにプロセスを fork することを指定しています。 例えば、クラスが 10 個あれば、3 つのプロセスが作成されます（1 つのプロセスで 4 クラスまで担当するから）。
build.gradle test { int cpus = Runtime.runtime.availableProcessors() maxParallelForks = cpus &amp;gt; 1 ? cpus - 1 : 1 forkEvery = 4 }</description></item><item><title>JUnit の代わりに TestNG を使ってユニットテストを実行する</title><link>https://maku77.github.io/p/84xtqff/</link><pubDate>Thu, 24 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/84xtqff/</guid><description>JUnit の代わりに TestNG（テスティング） を使ってユニットテストを記述したい場合は、build.gradle スクリプトを下記のように書き換えます。
build.gradle apply plugin: &amp;#39;java&amp;#39; repositories { mavenCentral() } dependencies { testCompile &amp;#39;org.testng:testng:6.+&amp;#39; } test.useTestNG() ディレクトリ構成や、test タスクで実行できるところは JUnit を使う場合と変わりありません。 最後に test.useTestNG() の呼び出しが必要なことに注意してください。</description></item><item><title>Gradle で PMD による静的解析を実行する</title><link>https://maku77.github.io/p/pz9gz3h/</link><pubDate>Mon, 14 Sep 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pz9gz3h/</guid><description>PMD プラグインの基本 Gradle には標準の静的解析プラグインとして、PMD が組み込まれています。 PMD でソースコードを解析すると、潜在的な不具合や、複雑度が高く将来的に負債になりそうなコードを検出することができます。 よい設計やコーディングができているかが一目瞭然になりますので、すべての Java プロジェクトに採用したいところです。
Gradle - PMD Plugin PMD PMD と似たような静的解析ツールに FindBugs がありますが、FindBugs がコンパイル後のクラスコードに対する解析であるのに対し、PMD はコンパイル前のソースコードを解析します。 無駄なコードはコンパイルの段階で最適化されて削除されてしまうことがあるため、このような無駄なコードを発見するためには、PMD で解析することが必要になります。 また、本家の PMD はコードクローンの発見などの機能 (CPD: Copy/Paste Detector) も備えていますが、Gradle の PMD プラグインはまだ CPD の直接サポートはされていないようです (2015-09-14)。
PMD の設定 PMD による静的解析を実施するには、下記のような感じで pmd プラグインを読み込んで設定します。
build.gradle apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;pmd&amp;#39; repositories { mavenCentral() } // PMD のコンフィギュレーション pmd { toolVersion &amp;#39;5.3.3&amp;#39; // 使用する PMD のバージョン ignoreFailures = true // PMD で警告が出てもビルドエラーにしない consoleOutput = true // コンソールにも解析結果を出力 ruleSets = [ // 適用する PMD ルール（プロジェクトごとに要調整） &amp;#39;java-basic&amp;#39;, // good practices which should be followed &amp;#39;java-braces&amp;#39;, // regarding the use and placement of braces &amp;#39;java-clone&amp;#39;, // questionable usages of the clone() method &amp;#39;java-codesize&amp;#39;, // problems related to code size or complexity &amp;#39;java-design&amp;#39;, // flag suboptimal code implementations &amp;#39;java-empty&amp;#39;, // empty statements of any kind &amp;#39;java-finalizers&amp;#39;, // problems that can occur with finalizers &amp;#39;java-imports&amp;#39;, // problems that can occur with import statements &amp;#39;java-strictexception&amp;#39;, // strict guidelines about throwing and catching exceptions &amp;#39;java-strings&amp;#39;, // manipulation of the String, StringBuffer, or StringBuilder instances &amp;#39;java-sunsecure&amp;#39;, // check the security guidelines from Sun &amp;#39;java-typeresolution&amp;#39;, // rules which resolve java Class files for comparison &amp;#39;java-unnecessary&amp;#39;, // find useless or unnecessary code &amp;#39;java-unusedcode&amp;#39; // find unused or ineffective code ] } PMD プラグインによって、pmdMain や pmdTest などのタスクが定義されます。 これらのタスクは、check タスクに依存するタスクとして定義されるので、check タスクを定義する java プラグインも読み込んでおく必要があります。</description></item><item><title>Gradle で Checkstyle による静的解析を実行する</title><link>https://maku77.github.io/p/em3rtg6/</link><pubDate>Mon, 10 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/em3rtg6/</guid><description>Checkstyle プラグインの基本 Gradle には標準の静的解析プラグインとして、Checkstyle、PMD、CodeNarc、FindBugs、JDepend などが組み込まれています。
Gradle - Checkstyle Plugin Checkstyle による静的解析を実施するには、下記のように checkstyle プラグインを読み込みます。
build.gradle apply plugin: &amp;#39;java&amp;#39; apply plugin: &amp;#39;checkstyle&amp;#39; repositories { mavenCentral() } checkstyle { toolVersion &amp;#39;6.7&amp;#39; } checkstyle プラグインを適用することによって、checkstyleMain や checkstyleTest などのタスクが定義されます。 これらのタスクは、check タスクに依存するタスクとして定義されるので、check タスクを定義する java プラグインも読み込んでおく必要があります。 また、Checkstyle はバージョンアップごとに微妙に互換性がなくなるので、上記のように checkstyle コンフィギュレーションで、使用する Checkstyle のバージョンを指定しておくのがよいでしょう。
Checkstyle プラグインは、デフォルトで Checkstyle の設定ファイルとして ${projectDir}/config/checkstyle/checkstyle.xml を読み込むので、まずはここにプロジェクトで使用する Checkstyle の設定を置いておく必要があります。
デフォルトの構成に従うと、こんな感じのディレクトリ構成になります。
+-- build.gradle +-- config/ | +-- checkstyle/ | +-- checkstyle.xml （Checkstyle の設定ファイル） +-- src/ +-- main/ +-- java/ +-- com/ +-- example/ +-- Main.</description></item><item><title>Gradle のマルチプロジェクトで依存関係を扱う (dependencies, compile)</title><link>https://maku77.github.io/p/hg9n9wd/</link><pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hg9n9wd/</guid><description>マルチプロジェクトビルドにおいて、別のサブプロジェクトが生成するクラスへの依存があることを示したい場合は、dependencies ブロックで依存先のプロジェクトを指定します。 例えば、下記のように、2 つのサブプロジェクト (myapp と mylib) で構成されているとします。
プロジェクト構成 root/ +-- build.gradle +-- settings.gradle +-- myapp/ | +-- src/main/java/Main.java +-- mylib/ +-- src/main/java/MyLib.java settings.gradle include &amp;#39;myapp&amp;#39; include &amp;#39;mylib&amp;#39; プロジェクト myapp は、プロジェクト mylib が提供するクラスを参照して実装されています。
myapp/src/main/java/Main.java public class Main { public static void main(String... args) { System.out.println(MyLib.add(100, 200)); } } mylib/src/main/java/MyLib.java public class MyLib { public static int add(int a, int b) { return a + b; } } このように Java のビルドにプロジェクト間の依存関係がある場合は、dependencies ブロック内の compile コンフィギュレーションに対して依存先のプロジェクトを指定します。</description></item><item><title>Gradle で Javadoc API ドキュメントを出力する</title><link>https://maku77.github.io/p/sj6sc4d/</link><pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sj6sc4d/</guid><description>javadoc タスクを使えるようにする Gradle で java プラグインをロードすると、自動的に javadoc タスクが定義されます。
build.gradle apply plugin: &amp;#39;java&amp;#39; 下記のように実行すると、src/main/java 以下の Java ソースコードに記述された Javadoc コメントを元に、build/docs/javadocs に API ドキュメントが生成されます。
$ gradle javadoc javadoc タスクをカスタマイズする javadoc タスクをプロジェクトに合わせてカスタマイズしたい場合は、下記のように Javadoc 型の新しいタスクを定義します。
build.gradle apply plugin: &amp;#39;java&amp;#39; task myJavadoc(type: Javadoc) { group = &amp;#39;Sample&amp;#39; description = &amp;#39;Generates API documents.&amp;#39; source = sourceSets.main.allJava } タスク定義時に type: Javadoc と指定することで、Configuration クロージャの中で参照されるオブジェクト（Closure delegate）が、Task オブジェクトから Javadoc オブジェクトに変わります。 Configuration クロージャ内で Javadoc オブジェクトのメソッドを呼び出すことで、タスクをカスタマイズできるようになっています。 source プロパティの指定は必須であることに注意してください（指定しないと何も生成されません）。
Javadoc 用に新しいタスクを定義するのではなく、既存の javadoc タスクを上書きしてしまいたい場合は、下記のように overwrite オプションを指定します。</description></item><item><title>Gradle によるマルチプロジェクトの基本 (settings.gradle)</title><link>https://maku77.github.io/p/3g9gimf/</link><pubDate>Mon, 27 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3g9gimf/</guid><description>マルチプロジェクトを構成する Gradle では複数のサブプロジェクトを作成し、それらを連携させてビルドすることができます。 サブプロジェクトの構成は、settings.gradle ファイルで記述します。 例えば、下記の設定では、2 つのサブプロジェクト (subproject1, subproject2) から構成されることを示しています。 ここでサブプロジェクトを include する順番は、タスクの実行順序には何も影響を与えません。
settings.gradle rootProject.name = &amp;#39;rootproject&amp;#39; include &amp;#39;subproject1&amp;#39; include &amp;#39;subproject2&amp;#39; Gradle にデフォルトで用意されている projects タスクを実行することで、現在のプロジェクト構成を調べることができます。
$ gradle -q projects ------------------------------------------------------------ Root project ------------------------------------------------------------ Root project &amp;#39;rootproject&amp;#39; +--- Project &amp;#39;:subproject1&amp;#39; \--- Project &amp;#39;:subproject2&amp;#39; ... サブプロジェクトごとに build.gradle を持つ構成 settings.gradle の include メソッドで指定したサブプロジェクト名は、サブプロジェクトを格納するディレクトリ名に対応しています。 サブプロジェクトの各ディレクトリには、そのプロジェクト用のビルドスクリプト (build.gradle) を格納しておくことができます。
マルチプロジェクトのディレクトリ構成 root/ +-- build.gradle +-- settings.gradle +-- subprojects1/ | +-- build.gradle +-- subprojects2/ +-- build.gradle build.gradle（ルート） task hello &amp;lt;&amp;lt; { println &amp;#39;Hello&amp;#39; } subprojects1/build.</description></item><item><title>Gradle のタスクに説明を付け、グルーピングする</title><link>https://maku77.github.io/p/kgwpdtz/</link><pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kgwpdtz/</guid><description>Gradle のタスクを定義するときに group パラメータを指定すると、複数のタスクをグルーピングすることができます。 また、description パラメータを指定すると、タスクに説明文を設定することができます。 これらの設定を行うことで、gradle tasks でタスクを一覧表示したときに、グルーピングされたタスクと説明が表示されるようになります。
下記の例では、hello1 タスクと hello2 タスクを MyGroup にグルーピングし、それぞれのタスクに説明文を設定しています。
build.gradle task hello1(group: &amp;#39;MyGroup&amp;#39;, description: &amp;#39;Description for hello1.&amp;#39;) { doLast { println &amp;#39;Hello 1&amp;#39; } } task hello2(group: &amp;#39;MyGroup&amp;#39;, description: &amp;#39;Description for hello2.&amp;#39;) { doLast { println &amp;#39;Hello 2&amp;#39; } } タスクの Configuration クロージャ内で Task オブジェクトのメソッド (group, description) を呼び出すことでも設定できます。
task hello1 { group &amp;#39;MyGroup&amp;#39; description &amp;#39;Description for hello1.&amp;#39; doLast { println &amp;#39;Hello 1&amp;#39; } } task hello2 { group &amp;#39;MyGroup&amp;#39; description &amp;#39;Description for hello2.</description></item><item><title>既存の Gradle タスクにアクションを追加する (doLast, doFirst)</title><link>https://maku77.github.io/p/6q9wkjm/</link><pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6q9wkjm/</guid><description>Gradle の既存のタスクには、自由にアクションを追加していくことができます。 この仕組みにより、サードパーティ製のタスクに対して、前処理や後処理を追加することができます。 タスク内のアクションは、内部的にアクションリストとして保持されており、Task#doLast メソッドや Task#doFirst メソッドを使用して、先頭、あるいは末尾にアクションを追加できます。
アクションを末尾に追加する (doLast) 下記の例では、既存タスク hello のアクションリストの末尾にアクションを追加しています。
build.gradle // タスクの定義 task hello { doLast { println &amp;#39;Hello!&amp;#39; } } // アクションリストの末尾にアクションを追加 hello.doLast { println &amp;#39;Added to last 1&amp;#39; } hello.doLast { println &amp;#39;Added to last 2&amp;#39; } 実行結果 $ gradle -q hello Hello! Added to last 1 Added to last 2 アクションを先頭に追加する (doFirst) 下記の例では、既存タスクのアクションリストの先頭にアクションを追加しています。
build.gradle // タスクの定義 task hello { doLast { println &amp;#39;Hello!&amp;#39; } } // アクションリストの先頭にアクションを追加 hello.</description></item><item><title>Gradle Wrapper スクリプト (gradlew) を作成する</title><link>https://maku77.github.io/p/m7u5dgp/</link><pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m7u5dgp/</guid><description>Gradle Wrapper とは Gradle Wrapper スクリプト (gradlew) を作成しておくと、Gradle の実行環境をインストールしていない環境でも gradle コマンドを実行するのと同様のビルドを行えるようになります。 Gradle Wrapper は、実際には下記のようなスクリプトファイルです。
gradlew &amp;hellip; Linux 用のシェルスクリプト gradlew.bat &amp;hellip; Windows 用のバッチファイル プロジェクトに gradlew が用意されている場合は、gradle コマンドの代わりにそちらを使えば OK です。例えば、build タスクを実行したい場合は、下記のように実行します。
gradle コマンドの代わりに gradlew コマンドを使用 $ gradlew build 仕組みは単純で、Gradle がインストールされていない環境で gradlew コマンドを実行すると、最初に Gradle の実行環境がインストールされてビルドが実行されるようになっています。 Gradle の実行環境の実体は ~/.gradle/wrapper/dists/gradle-1.12-bin といったディレクトリにインストールされ、次回の gradlew コマンド実行時には、そこにあるファイルが使用されるようになります（この動きを特に意識する必要はありません）。
Gradle Wrapper の作成 Gradle Wrapper のスクリプトファイル、およびその実行に必要なライブラリ群は、下記のコマンドで生成することができます。
$ gradle wrapper これだけでも十分なのですが、下記のように wrapper タスクのコンフィギュレーションを定義しておくことで、どのバージョンの Gradle 相当の Gradle Wrapper を作成するかを指定することができます（他にもいろいろな設定を行うことができます。詳しくは Wrapper の DSL ドキュメント を参照してください）。</description></item><item><title>Gradle デーモンを使って gradle コマンドを高速化する (org.gradle.daemon)</title><link>https://maku77.github.io/p/szhzejv/</link><pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/szhzejv/</guid><description>Gradle デーモンの立ち上げ gradle コマンドを実行すると、デフォルトでは毎回 Java のバーチャルマシンを起動するため、下記のような簡単なタスクを実行するだけでも 2、3 秒の実行時間がかかってしまいます。
build.gradle task hello &amp;lt;&amp;lt; { println &amp;#39;Hello&amp;#39; } 実行結果 $ gradle hello :hello Hello BUILD SUCCESSFUL Total time: 2.353 secs gradle コマンドを実行するときに、--daemon オプションを付けるようにすると、Gradle のプロセスを常駐させ（デーモン化）、そのプロセスを毎回のビルドで使いまわすようになります。 初回はデーモンの立ち上げのために時間がかかりますが、2 度目からのビルドは高速に実行することができます。 下記の実行例を見ると、1 秒以内に処理できていることがわかります。
実行結果（--daemonオプションあり） $ gradle --daemon hello :hello Hello BUILD SUCCESSFUL Total time: 0.905 secs ちなみに、常駐している Gradle のプロセスは、3 時間使用されないと自動的に終了します。 下記のように明示的に停止することもできます。
$ gradle --stop Stopping daemon(s). Gradle daemon stopped. Gradle デーモンをデフォルトで有効にする gradle コマンドに毎回 --daemon オプションを付けるのが面倒な場合は、Gradle の設定ファイル (gradle.properties) でデーモンを常に有効にすることができます。</description></item><item><title>Gradle で実行可能な JAR ファイルを作成する</title><link>https://maku77.github.io/p/5iacmi7/</link><pubDate>Fri, 10 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5iacmi7/</guid><description>Gradle の java プラグインを使用して、実行可能な JAR ファイルを作成してみます。 ここでは、下記のような簡単な Hello World アプリケーションをビルドします。
src/main/java/com/example/Main.java package com.example; public class Main { public static void main(String... args) { System.out.println(&amp;#34;Hello&amp;#34;); } } JAR ファイルを特別なパラメータなしで実行できるようにするには、JAR ファイルにアーカイブする Manifest ファイルでエントリポイントとなる Main クラスを指定しておく必要があります。 ビルドスクリプト内で下記のように記述しておくと、com.example.Main をエントリポイントとするような Manifest ファイルを生成してくれるようになります。
build.gradle apply plugin: &amp;#39;java&amp;#39; version = 1.0 jar { manifest { attributes &amp;#39;Main-Class&amp;#39;: &amp;#39;com.example.Main&amp;#39; } } ビルドします。
$ gradle build ... BUILD SUCCESSFUL Total time: 1.063 secs 作成された JAR ファイルは、下記のように実行できるようになっているはずです。
$ java -jar build/libs/sample-1.</description></item><item><title>Gradle でタスクの依存関係を表現する</title><link>https://maku77.github.io/p/sifxuig/</link><pubDate>Thu, 09 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sifxuig/</guid><description>タスク間に依存関係を設定する org.gradle.api.Task オブジェクトの dependsOn メソッド を使用することで、タスク間に依存関係を持たせることができます。
方法1）タスク定義時の引数で依存定義する タスク定義時の dependsOn 引数（厳密にはマップキー）でタスク間の依存関係を設定することができます。 次の例では、hello1 タスクに依存する hello2 タスクを定義しています。
build.gradle task hello1 { doLast { println &amp;#39;Hello 1&amp;#39; } } task hello2(dependsOn: hello1) { doLast { println &amp;#39;Hello 2&amp;#39; } } hello2 タスクを実行するときに、先に hello1 タスクが実行されるようになります。
$ gradle -q hello2 Hello 1 Hello 2 方法2）Configure クロージャ内で依存定義する タスク定義時の Configure クロージャ内で dependsOn メソッドを呼び出して依存関係を指定することができます。
task hello1 { doLast { println &amp;#39;Hello 1&amp;#39; } } task hello2 { dependsOn hello1 doLast { println &amp;#39;Hello 2&amp;#39; } } 方法3）タスク定義後に依存を追加する すでに定義済みのタスク（Task オブジェクト）の dependsOn メソッドを呼び出すことで、後付けで依存関係を追加することができます。</description></item><item><title>Gradle で Java プロジェクトをビルドするときのディレクトリ構成を変更する (sourceSets, buildDir)</title><link>https://maku77.github.io/p/odjj8e7/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/odjj8e7/</guid><description>java プラグインは、プロジェクトのディレクトリ構成が次のようになっていると想定しています。 これは、Gradle のソースセットの設定（インプットファイルの置き場所の設定）がデフォルトでこのようになっているからです。
Java ソースコード: src/main/java および src/test/java 出力先のディレクトリ: build このソースセットの設定を変更するとこで、プロジェクトの都合に合わせたディレクトリ構成に変更できます。 例えば、製品用の Java ソースコードを src ディレクトリ、テスト用の Java ソースコードを test ディレクトリ、出力先を out ディレクトリに変更するには以下のように設定します。
build.gradle apply plugin: &amp;#39;java&amp;#39; sourceSets { main { java { srcDirs = [&amp;#39;src&amp;#39;] } } test { java { srcDirs = [&amp;#39;test&amp;#39;] } } } buildDir = &amp;#39;out&amp;#39; こう書くこともできます。
apply plugin: &amp;#39;java&amp;#39; sourceSets.main.java.srcDirs = [&amp;#39;src&amp;#39;] sourceSets.test.java.srcDirs = [&amp;#39;test&amp;#39;] buildDir = &amp;#39;out&amp;#39; この設定により、下記のようなパスに置かれた Java ソースコードがコンパイルされるようになります。
src/com/example/Main.java 正確には、srcDirs メソッドは、ディレクトリを変更するのではなく追加 します。 なので、もともとの src/main/java ディレクトリ以下に置かれている Java ソースコードは、相変わらずコンパイルの対象になります。</description></item><item><title>Groovy でクラスを定義する</title><link>https://maku77.github.io/p/j5bvcq9/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/j5bvcq9/</guid><description>クラスを定義する Groovy では、クラスやメソッドの可視性はデフォルトで public になります。 下記の Book クラスは title と authors フィールドを持っており、両方とも外部から参照できます。
sample.groovy class Book { def title def authors = [] def getLabel() { title + &amp;#39;, &amp;#39; + authors } String toString() { getLabel() } } def book = new Book() book.title = &amp;#39;Title1&amp;#39; book.authors &amp;lt;&amp;lt; &amp;#39;Author1&amp;#39; &amp;lt;&amp;lt; &amp;#39;Author2&amp;#39; &amp;lt;&amp;lt; &amp;#39;Author3&amp;#39; println book 実行例 $ groovy sample.groovy Title1, [Author1, Author2, Author3] 上記の例では、book.title というプロパティに直接アクセスしているかのように見えますが、内部的には、自動的に生成された book.getTitle() という getter メソッドが呼び出されています。 同様に、book.setTitle() という setter メソッドも自動的に生成されています。</description></item><item><title>Groovy でマップ (Map) を扱う</title><link>https://maku77.github.io/p/ohhdpvf/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ohhdpvf/</guid><description>Groovy の Map の基本 Groovy の Map インスタンスは、List インスタンスと同様に [ と ] を使用して定義することができます。 ただし、各要素はコロン (:) で区切って、キーと値を指定します。 内部的には、java.util.LinkedHashMap インスタンスが生成されています。
def map = [xxx:100, yyy:200, zzz:300] assert map.getClass() == java.util.LinkedHashMap assert map.size() == 3 assert map.xxx == 100 assert map[&amp;#39;xxx&amp;#39;] == 100 Map の要素を列挙する Map の要素は、List の要素と同様に each メソッドを使ってイテレートすることができます。
map.each { key, val -&amp;gt; println key + &amp;#39;:&amp;#39; + val } 空の Map インスタンスを生成する 空の Map インスタンスを生成するときは、ちょっと特殊ですが下記のように記述する必要があります。
def map = [:] // 空の Map 真ん中のコロン : を省略してしまうと、List オブジェクトの生成とみなされてしまいます。</description></item><item><title>Groovy でメソッドを定義する</title><link>https://maku77.github.io/p/6qzzzry/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qzzzry/</guid><description>下記のサンプルでは、2 つの変数を足し合わせる add メソッドを定義しています。
sample.groovy // メソッドの定義 def add(a, b) { a + b } // メソッドの呼び出し def val = add(100, 200) println val Groovy では、他の多くのスクリプト言語と同様に、メソッド内で最後に評価された式の値がそのまま戻り値となるので、return キーワードを省略することができます。 また、パラメータの型や、戻り値の型も明示する必要はありません（最初に def とだけ書けばよい）。
次のように型を明示することもできます。
int add(int a, int b) { a + b } 戻り値がないことを明示したいのであれば、Java と同様に void と定義することもできます。 戻り値の型が void のメソッドの戻り値を強引に取得しようとすると、null が返されます。
void greet(String name) { println &amp;#39;Hello, &amp;#39; + name } def val = greet(&amp;#39;Jack&amp;#39;) println val //=&amp;gt; null メソッド呼び出し時のパラメータを囲む括弧は、次のように省略することができます。
def val = add 100, 200 ただし、パラメータを 1 つも持たない場合は、呼び出し時の括弧を省略することはできません。</description></item><item><title>Groovy でリスト (List) を扱う</title><link>https://maku77.github.io/p/z9qmfd4/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z9qmfd4/</guid><description>Groovy のリストの基本 Groovy では、[1, 2, 3] といった構文を使用して、簡単に List インスタンスを生成することができます。 内部的には java.util.ArrayList のインスタンスが生成されます。 下記の例では、3 つの要素を持つ List インスタンスを生成しています。
def list = [100, &amp;#39;AAA&amp;#39;, 0.25] assert list.getClass() == java.util.ArrayList assert list.size() == 3 assert list[0] == 100 リストへの要素の追加 リストの末尾に要素を追加する場合、&amp;lt;&amp;lt; というショートカット記法を使用することができます。
def list = [] list &amp;lt;&amp;lt; 100 list &amp;lt;&amp;lt; 200 list &amp;lt;&amp;lt; 300 println list //=&amp;gt; [100, 200, 300] これは、下記のように add メソッドを呼び出すのと同等の動作をします。
def list = [] list.add 100 list.add 200 list.add 300 println list //=&amp;gt; [100, 200, 300] あまり違いはないように見えますが、&amp;lt;&amp;lt; を使った方が可読性は若干上がるようです。 また、&amp;lt;&amp;lt; を使うことにより、下記のように連続して要素を追加することが可能です。</description></item><item><title>Groovy で文字列リテラルを扱う</title><link>https://maku77.github.io/p/v8m6rme/</link><pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v8m6rme/</guid><description>文字列リテラルと GStrings Groovy の文字列リテラルは、シングルクォート (') あるいは、ダブルクォート (&amp;quot;) で囲んで表現します。 ダブルクォートで囲んだ文字列リテラルは、$ で始まる変数が展開されます。 このような変数を含む文字列を GStrings (Groovy Strings) と呼びます。
sample.groovy def name = &amp;#39;Britney&amp;#39; println &amp;#39;Hello $name&amp;#39; println &amp;#34;Hello $name&amp;#34; 実行結果 Hello $name Hello Britney 文字列の中の式 ${式} という構文を使用すると、文字列の中で任意の式を実行することができます。
sample.groovy def name = &amp;#39;mickey&amp;#39; println &amp;#34;Hello ${name.capitalize()}&amp;#34; 実行結果 Hello Mickey ヒアドキュメント 3 連続のクォーテーションマーク（''' あるいは &amp;quot;&amp;quot;&amp;quot;）で文字列を囲むことによって、複数行にまたがる文字列リテラル（ヒアドキュメント）を定義することができます。 通常の文字列リテラルと同様に、ダブルクォート (&amp;quot;) で囲んだ場合だけ、$ で始まる変数が展開されます。
def html = &amp;#34;&amp;#34;&amp;#34;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;$title&amp;lt;/title&amp;gt; &amp;lt;head&amp;gt; &amp;lt;body&amp;gt; $body &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;&amp;#34;&amp;#34;&amp;#34;</description></item><item><title>Groovy で assert を使用する</title><link>https://maku77.github.io/p/m9veity/</link><pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m9veity/</guid><description>Groovy では、デフォルトで assert が使用できるようになっています。
sample.groovy def num = 100 assert num.getClass() == java.lang.Integer def str = &amp;#39;Hello&amp;#39; assert str.getClass() == java.lang.Integer 上記のスクリプトを実行すると、2 つ目の assert で fail して、下記のように詳細な情報が表示されます。 分かりやすいですね！
$ groovy sample.groovy Assertion failed: assert str.getClass() == java.lang.Integer | | | | | false | class java.lang.String Hello at sample.run(sample.groovy:5)</description></item><item><title>Groovy と Java の違い</title><link>https://maku77.github.io/p/som2e4k/</link><pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/som2e4k/</guid><description>Groovy は Java と異なり、下記のような特徴を持っています。
行末のセミコロンは省略できる クラス、コンストラクタ、メソッドはデフォルトで public となる return の記述は省略できる（最後に評価された式が戻り値となる） getter/setter メソッドが自動的に作られる（obj.prop のようにアクセスすれば obj.getProp や setProp が呼び出される） == によるオブジェクトの比較は、自動的に equals による比較となる（しかも null チェックの必要はない） assert は常に有効（Java の場合は -ea または --enable-assertion オプションの指定が必要） 変数の型や、メソッドの戻り値の型は def としておけば、自動で判別してくれる コレクション（List や Map）の扱いがシンプルで、Python や Ruby に近い構文で記述できる</description></item><item><title>Gradle でファイルをコピー、リネームするためのタスクを作成する (type: Copy)</title><link>https://maku77.github.io/p/q6ducqz/</link><pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q6ducqz/</guid><description>Gradle のビルドスクリプトで Copy 型のタスクを定義すると、ファイルのコピーや移動を簡単に行うことができます。
ファイルコピーの基本 次の hello タスクは、ディレクトリ from/dir 以下のファイルを再帰的にコピーします。 from/dir 以下のディレクトリ階層は保たれます。 コピー先のディレクトリ to/dir が存在しない場合は、自動的に作成されます。
task hello(type: Copy) { from &amp;#39;from/dir&amp;#39; into &amp;#39;to/dir&amp;#39; } コピーする対象を絞り込む Copy タスクにおいて、include や exclude でファイル名のパターンを指定することで、コピーするファイルを絞り込むことができます。
拡張子が .txt のファイルをすべてコピー task hello(type: Copy) { from &amp;#39;from/dir&amp;#39; into &amp;#39;to/dir&amp;#39; include &amp;#39;**/*.txt&amp;#39; } 拡張子が .bk ではないファイルをすべてコピー task hello(type: Copy) { from &amp;#39;from/dir&amp;#39; into &amp;#39;to/dir&amp;#39; exclude &amp;#39;**/*.bk&amp;#39; } 複数のディレクトリからファイルをコピーする コピー元のディレクトリを複数指定して、一つのディレクトリにコピーすることもできます。 下記の例では、from1 ディレクトリと from2 ディレクトリ内のファイルを to ディレクトリにコピーしています。
task hello(type: Copy) { from &amp;#39;from1&amp;#39; from &amp;#39;from2&amp;#39; into &amp;#39;to&amp;#39; } ただし、この方法だと、複数のコピー元に同じファイル名のファイルがあると、ファイルが上書きコピーされてしまいます（ツリー構造が異なれば大丈夫です）。 下記のようにすると、コピー先にディレクトリを作って、その中にファイルをコピーすることができます。 from のパラメータを括弧で囲むことに注意してください。</description></item><item><title>Gradle のテンプレート機能を使ってファイルを生成する</title><link>https://maku77.github.io/p/ijynhet/</link><pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ijynhet/</guid><description>Groovy の SimpleTemplateEngine クラスの機能を使用することで、ファイルコピー時にファイル内の文字列を置換することができます。 例えば、入力ファイルとして、下記のようなテンプレートファイルを用意しておきます。
input/build.properties version=${version} buildDate=${buildDate.format(&amp;#34;yyyyMMdd&amp;#39;T&amp;#39;HHmmss&amp;#34;)} ${string} という部分が動的に置換される部分です。 そこにどんな値を格納するかは、Copy 型タスクの expand() メソッドで指定します。
build.gradle task hello(type: Copy) { from &amp;#39;input&amp;#39; include &amp;#39;build.properties&amp;#39; into &amp;#39;output&amp;#39; expand([ version: &amp;#39;1.0.0&amp;#39;, buildDate: new Date() ]) } 上記のタスクを実行すると、下記のようなファイルが出力されます。
output/build.properties version=1.0.0 buildDate=20150630T224515</description></item><item><title>Gradle タスクの一覧を表示する (gradle tasks)</title><link>https://maku77.github.io/p/qoaky8w/</link><pubDate>Tue, 17 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qoaky8w/</guid><description>Gradle で実行可能なタスクの一覧は tasks タスクを走らせることで確認できます。
$ gradle -q tasks ------------------------------------------------------------ All tasks runnable from root project ------------------------------------------------------------ Build Setup tasks ----------------- init - Initializes a new Gradle build. [incubating] wrapper - Generates Gradle wrapper files. [incubating] Help tasks ---------- dependencies - Displays all dependencies declared in root project &amp;#39;gradle&amp;#39;. dependencyInsight - Displays the insight into a specific dependency in root project &amp;#39;gradle&amp;#39;. help - Displays a help message projects - Displays the sub-projects of root project &amp;#39;gradle&amp;#39;.</description></item><item><title>Gradle のタスクを定義する</title><link>https://maku77.github.io/p/a88r2ua/</link><pubDate>Tue, 17 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/a88r2ua/</guid><description>gradle コマンドを実行すると、カレントディレクトリにある build.gradle ビルドスクリプト（レシピ）を読み込み、そこに定義されているタスクを実行します。 下記は、hello というタスクを定義する例で、Excecution フェーズで Hello World と表示するように指定しています。
build.gradle task hello { doLast { println &amp;#39;Hello World&amp;#39; } } 具体的には、hello という名前の Task オブジェクト を作成し、Task#doLast() メソッドでタスクのアクションリストの末尾にアクションを追加する、ということをしています。 このように定義したタスクを実行するには、gradle コマンドの引数でタスク名を指定します。
$ gradle hello :hello Hello World BUILD SUCCESSFUL Total time: 2.527 secs コロンから始まる :hello という行が、hello タスクを実行していることを示しています。 gradle コマンドを実行するときに、-q あるいは --quiet オプションを指定すると、エラー以外のログ出力を抑制できます。
$ gradle -q hello Hello World ☝️ （コラム）leftShift は deprecated Gradle 4.x までは、タスクの Configuration クロージャ内に doLast アクションを定義する代わりに、次のようなショートカット記法が使えました。
task hello &amp;lt;&amp;lt; { println &amp;#39;Hello World&amp;#39; } Gradle 5.</description></item><item><title>Gradle で Java プロジェクトをビルドする</title><link>https://maku77.github.io/p/bvinwfk/</link><pubDate>Sun, 08 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bvinwfk/</guid><description>Java プラグインを適用すると、Java のプロジェクトをビルドするためのタスクが定義されます。
Java Plugin の説明 build.gradle apply plugin: &amp;#39;java&amp;#39; Java プロジェクトのディレクトリ構成 Java プラグインはデフォルトで、以下のようなディレクトリ構造でソースコードが格納されていることを期待して動作します。
src/main/java &amp;hellip; 製品用の Java ソースコード src/main/resources &amp;hellip; 製品用のリソースファイル src/test/java &amp;hellip; ユニットテスト用の Java ソースコード src/test/resources &amp;hellip; ユニットテスト用のリソースファイル 例えば、com.example.Main クラスのソースコードは下記のようなパスに格納します（build.gradle ファイルがあるディレクトリからの相対パスです）。
src/main/java/com/example/Main.java package com.example; public class Main { public static void main(String... args) { System.out.println(&amp;#34;Hello&amp;#34;); } } java プラグインを使ったビルドとプログラムの実行 Java プラグインが提供する build タスクを実行することにより、Java プロジェクトのビルドを行うことができます。
$ gradle build ... BUILD SUCCESSFUL ビルドが成功すると、build ディレクトリに生成物が出力されます。 例えば、クラスファイルは build/classes/main や build/classes/test ディレクトリ以下に出力されます。 このディレクトリにクラスパスを通せば、Java プログラムを実行することができます。</description></item><item><title>Gradle でデフォルトタスクを指定する (defaultTasks)</title><link>https://maku77.github.io/p/zfc37zt/</link><pubDate>Sun, 08 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zfc37zt/</guid><description>gradle コマンドではパラメータとしてタスク名を指定するのですが、パラメータを省略した場合に実行する デフォルトタスク を指定しておくこともできます。 下記のサンプルでは、hello タスクをデフォルトタスクとして指定しています。
build.gradle defaultTasks &amp;#39;hello&amp;#39; task hello { doLast { println &amp;#39;Hello World&amp;#39; } } 実行結果 $ gradle -q # gradle -q hello と同じ結果になる Hello World デフォルトタスクはカンマで区切って、複数指定することができます。 デフォルトタスクを複数指定した場合、指定した順番に実行されます。
build.gradle defaultTasks &amp;#39;hello1&amp;#39;, &amp;#39;hello2&amp;#39; task hello1 { doLast { println &amp;#39;Hello1&amp;#39; } } task hello2 { doLast { println &amp;#39;Hello2&amp;#39; } } 実行結果 $ gradle -q # gradle -q hello1 hello2 と同じ結果になる Hello1 Hello2</description></item><item><title>Gradle 実行時の 3 つのフェーズ (initialization, configuration, execution)</title><link>https://maku77.github.io/p/o7yqmcx/</link><pubDate>Sun, 08 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o7yqmcx/</guid><description>3 つのフェーズ Gradle によるビルドを実行するとき、内部では下記のような 3 つのフェーズに分けてビルドが実行されていきます。
Initialization フェーズ Configuration フェーズ Execution フェーズ (1) Initialization フェーズ マルチプロジェクトにおけるプロジェクトの依存関係が解決され、プロジェクトのビルド順序が決められるフェーズです。 サブプロジェクトの構成は、トップレベルのディレクトリに置かれる settings.gradle ファイルで定義されます（Gradle の内部では、このファイルを基に Settings オブジェクトが生成されています）。
settings.gradle include &amp;#39;subproject1&amp;#39; include &amp;#39;subproject2&amp;#39; また、プロジェクトごとに Gradle 内部で Project インスタンスが生成されています（マルチプロジェクトなビルド構成であれば、複数の Project インスタンスが生成されます）。 プロジェクトの依存関係は、各プロジェクトの dependencies ブロック内で定義されます。
dependencies { compile project(&amp;#39;:subproject&amp;#39;) ... } (2) Configuration フェーズ すべてのプロジェクトの build.gradle が処理され、すべてのタスクの依存関係を認識するフェーズです。 タスクの依存関係は、下記のように dependsOn プロパティで指定されます。
task task2(dependsOn: task1) &amp;lt;&amp;lt; { println &amp;#39;Hello task2&amp;#39; } 上記の例では依存タスクを task1 というオブジェクトで指定していますが、'task1' のように、文字列でタスク名を指定することもできます。 文字列でタスク名を指定することにより、その時点でまだ定義されていないタスクを指定することができます。 Configuration フェーズでは、すべてのタスク定義を走査するため、最終的にはすべての依存関係が問題なく解決されます（逆に、Configuration フェーズ終了時に未解決なタスクがあるとエラーになります）。
Gradle の処理系内部では、依存グラフ (dependency graph) が生成されています。</description></item><item><title>Gradle のプロキシを設定する (gradle.properties)</title><link>https://maku77.github.io/p/5x6qgkx/</link><pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5x6qgkx/</guid><description>gradle コマンド実行時に Maven リポジトリにアクセスしたり、Gradle Wrapper をインストールするためのアーカイブをダウンロードしたりする際にネットワークアクセスが発生します。 これらのアクセスをプロキシ経由で行う必要がある場合は、gradle.properties ファイルにプロキシの設定を記述します。
用途 設定ファイル プロジェクトごとの設定 &amp;lt;project&amp;gt;/gradle.properties ユーザごとの設定 (macOS/Linux) $HOME/.gradle/gradle.properties ユーザごとの設定 (Windows) %USERPROFILE%/.gradle/gradle.properties 以下のように設定します。
gradle.properties systemProp.http.proxyHost=&amp;lt;ホスト&amp;gt; systemProp.http.proxyPort=&amp;lt;ポート番号&amp;gt; systemProp.http.proxyUser=&amp;lt;ユーザ&amp;gt; systemProp.http.proxyPassword=&amp;lt;パスワード&amp;gt; systemProp.https.proxyHost=&amp;lt;ホスト&amp;gt; systemProp.https.proxyPort=&amp;lt;ポート番号&amp;gt; systemProp.https.proxyUser=&amp;lt;ユーザ&amp;gt; systemProp.https.proxyPassword=&amp;lt;パスワード&amp;gt; 設定例 systemProp.http.proxyHost=proxy.example.com systemProp.http.proxyPort=8080 systemProp.https.proxyHost=proxy.example.com systemProp.https.proxyPort=8080</description></item><item><title>Gradle をインストールする (macOS/Windows)</title><link>https://maku77.github.io/p/6qdfg4d/</link><pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qdfg4d/</guid><description>macOS への Gradle インストール ここでは、GVM (Groovy enVironment Manager) を使って gradle コマンドをインストールします。 GVM を使うと、複数バージョンの Gradle を管理することができます。
GVM のインストール
$ curl -s get.gvmtool.net | bash GVM で gradle のインストール
$ gvm install gradle 動作確認
$ gradle --version Windows への Gradle インストール https://gradle.org/install/ から gradle-1.12-bin.zip などをダウンロードして、適当なディレクトリに配置します。 gradle コマンドを実行するには、java コマンドを実行できるようになっている必要があります。 任意のバージョンの java コマンドを使用するには、JAVA_HOME 環境変数を設定しておきます。
C:\&amp;gt; set JAVA_HOME=C:\Program Files\Java\jdk1.8.0_05 （binまでは含めないことに注意） gradle コマンドを任意のディレクトリから実行できるように、PATH を通しておきます。
C:\&amp;gt; set PATH=%PATH%;C:\app\gradle-1.12\bin 実行テスト C:\&amp;gt; gradle -v ------------------------------------------------------------ Gradle 1.12 ------------------------------------------------------------ Build time: 2014-04-29 09:24:31 UTC Build number: none Revision: a831fa866d46cbee94e61a09af15f9dd95987421 Groovy: 1.</description></item><item><title>Gradle をインストールする (macOS/Windows)</title><link>https://maku77.github.io/p/6qdfg4d/</link><pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qdfg4d/</guid><description>macOS への Gradle インストール ここでは、GVM (Groovy enVironment Manager) を使って gradle コマンドをインストールします。 GVM を使うと、複数バージョンの Gradle を管理することができます。
GVM のインストール
$ curl -s get.gvmtool.net | bash GVM で gradle のインストール
$ gvm install gradle 動作確認
$ gradle --version Windows への Gradle インストール https://www.gradle.org/downloads から gradle-1.12-bin.zip などをダウンロードして、適当なディレクトリに配置します。 gradle コマンドを実行するには、java コマンドを実行できるようになっている必要があります。 任意のバージョンの java コマンドを使用するには、JAVA_HOME 環境変数を設定しておきます。
C:\&amp;gt; set JAVA_HOME=C:\Program Files\Java\jdk1.8.0_05 （binまでは含めないことに注意） gradle コマンドを任意のディレクトリから実行できるように、PATH を通しておきます。
C:\&amp;gt; set PATH=%PATH%;C:\app\gradle-1.12\bin 実行テスト C:\&amp;gt; gradle -v ------------------------------------------------------------ Gradle 1.12 ------------------------------------------------------------ Build time: 2014-04-29 09:24:31 UTC Build number: none Revision: a831fa866d46cbee94e61a09af15f9dd95987421 Groovy: 1.</description></item></channel></rss>