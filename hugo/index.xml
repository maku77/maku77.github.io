<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hugo on 天才まくまくノート</title><link>https://maku77.github.io/hugo/</link><description>Recent content in Hugo on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 25 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/hugo/index.xml" rel="self" type="application/rss+xml"/><item><title>Hugo で使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates)</title><link>https://maku77.github.io/p/st6fpz9/</link><pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/st6fpz9/</guid><description>Hugo で四苦八苦しながらテンプレートを開発していると、いつのまにか使われていないテンプレート（.html ファイル）が量産されていたりします。 Hugo サイトのビルド時に、未使用のテンプレートを検出するには、次のように --printUnusedTemplates オプションを付けて実行します。
$ hugo --printUnusedTemplates Start building sites … ...(省略)... WARN 2023/04/25 00:27:35 Template _default/section.backup.html is unused, source file /Users/maku/mysite/themes/maku/layouts/_default/section.backup.html WARN 2023/04/25 00:27:35 Template partials/debug/link-path.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/debug/link-path.html WARN 2023/04/25 00:27:35 Template partials/pager.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/pager.html WARN 2023/04/25 00:27:35 Template partials/top-menu.back.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/top-menu.back.html WARN 2023/04/25 00:27:35 Template shortcodes/anchor.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/anchor.html WARN 2023/04/25 00:27:35 Template shortcodes/mermaid.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/mermaid.</description></item><item><title>Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する</title><link>https://maku77.github.io/p/bqar8o6/</link><pubDate>Sat, 01 Apr 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bqar8o6/</guid><description>Hugo Modules とは Hugo Modules の仕組みを使うと、異なるディレクトリに配置されたファイル群をまとめて、1 つの Hugo サイトを構成することができます。 Hugo Module の実体は、Hugo サイト用のファイルが格納されたディレクトリです。 Hugo Module は、ローカル PC 上のディレクトリであってもよいし、GitHub リポジトリ内のディレクトリであっても構いません（通常は GitHub で管理することになるでしょう）。
graph RL subgraph my-hugo-module-1 mod1("Hugo Module") end subgraph my-hugo-module-2 mod2("Hugo Module") end subgraph my-hugo-site mod1_imported("Hugo Module") mod2_imported("Hugo Module") end mod1 -- import --> mod1_imported mod2 -- import --> mod2_imported classDef classMod fill:#36f,color:white,stroke:none class mod1,mod2,mod1_imported,mod2_imported classMod この仕組みは、一見すると、Hugo テーマを Git サブモジュールとして取り込むのと同じように見えますが、Hugo Modules はより柔軟で、コンテンツを含むほとんどのファイルをインポートできます。 現状、下記の 7 つのディレクトリに格納されるファイルを、Hugo Module からインポートすることができます。
archetypes &amp;hellip; 複数サイトでコンテンツ作成用テンプレート (.</description></item><item><title>Hugo で新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo)</title><link>https://maku77.github.io/p/oj3izfu/</link><pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oj3izfu/</guid><description>既存の Web ページの URL を変更した場合は、古い URL にアクセスしたときに自動的に新しい URL にリダイレクトされるようにしておくと親切です。 ここでは、2 種類のリダイレクト方法を説明します。
aliases を使う方法 &amp;hellip; 同じ Hugo サイト内でリダイレクトする redirectTo を使う方法（独自） &amp;hellip; 別のサイトへリダイレクトする aliases を使う方法 同一の Hugo サイト内でページの URL を変更した場合は、新しいページのフロントマターに aliases プロパティを追加し、以前の URL を列挙しておきます。 古いページの Markdown ファイルは削除します。
content/new-page/_index.md --- title: &amp;#34;新しい URL のページ&amp;#34; date: &amp;#34;2022-08-17&amp;#34; aliases: - /old-page - /old-page2 - /old-page3 --- 本文... 上記のように記述しておくと、古いページの URL (https://examle.com/old-page) にアクセスしたときに、新しいページの URL (https://example.com/new-page) にリダイレクトしてくれます。 この仕組みは単純で、aliases に列挙した URL に対応するように、Hugo が次のような内容のファイルを出力しています。
public/old-page/index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja-jp&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;https://example.</description></item><item><title>Hugo で Markdown (.md) ファイルを VS Code で開くリンクを表示する</title><link>https://maku77.github.io/p/9hkprvx/</link><pubDate>Sat, 04 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9hkprvx/</guid><description>VS Code で開くリンク 下記の Hugo テンプレートコードは、現在のページの生成元になった Markdown (.md) ファイルを VS Code で開くリンクを表示します（ローカルサーバーでの実行中のみ）。
{{- if .Site.IsServer }} {{- with .File }} &amp;lt;a href=&amp;#34;vscode://file/{{ .Filename }}&amp;#34;&amp;gt;✎ VS Code で開く&amp;lt;/a&amp;gt; {{- end }} {{- end }} 仕組み VS Code (Visual Studio Code) をインストールすると、ブラウザのアドレス欄に vscode://path&amp;lt;ファイルのフルパス&amp;gt; という特殊なアドレスを入力することで、ローカル PC 内のファイルを VS Code で開くことができるようになります。 例えば、/Users/maku/hugo-site/content/page.md というファイルを開きたいときは次のようなアドレスを入力します。
Linux や macOS の場合 vscode://file/Users/maku/hugo-site/content/page.md Windows の場合 vscode://file/C:\Users\maku\hugo-site\content\page.md Markdown ファイルのパス情報は File 変数で参照できる ので、それを利用して a 要素を出力してやれば、リンクのクリックだけで VS Code を開くことができるようになります。</description></item><item><title>Hugo の記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する</title><link>https://maku77.github.io/p/3adgjnq/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3adgjnq/</guid><description>js.Build の基本 Hugo Pipes のひとつである js.Build を使用すると、TypeScript ファイル (.ts) のビルドを行うことができます。
下記のショートコードは、記事ページにバンドルした .ts ファイルを .js ファイルにトランスパイルし、script 要素として出力する例です。
layouts/shortcodes/script.html {{- $src := .Get &amp;#34;src&amp;#34; -}} {{- $res := .Page.Resources.GetMatch $src -}} {{- $built := $res | js.Build -}} &amp;lt;script src=&amp;#34;{{ $built.RelPermalink }}&amp;#34; defer&amp;gt;&amp;lt;/script&amp;gt; このショートコードを使う記事ページ (.md) と TypeScript ファイル (.ts) は、次のような感じで content ディレクトリ以下の任意のディレクトリに配置します。
content/ sample-page/ index.md hello.ts ページバンドルの形にするため、記事ページは index.md というファイル名で作成し、同じディレクトリに .ts ファイルを配置することに注意してください。
content/sample-page/index.md --- title: &amp;#34;サンプルページ&amp;#34; --- {{&amp;lt; script src=&amp;#34;hello.ts&amp;#34; &amp;gt;}} content/sample-page/hello.ts alert(&amp;#39;Hello!&amp;#39;) assets ディレクトリに配置した ts ファイルを参照する 前述の例では、ページバンドルした .</description></item><item><title>Hugo のセクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight)</title><link>https://maku77.github.io/p/9gjnqtw/</link><pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9gjnqtw/</guid><description>.Pages のデフォルトソート順序 Hugo のセクションページのテンプレート内で .Pages 変数を参照すると、子セクションや子ページの一覧を取得できますが、その一覧はデフォルトで次のような情報をもとにソートされています（参考: Lists of Content in Hugo - Order Content）。
Weight ページのフロントマターで weight: 1 のように書いておくと、ページに重み付けできます。 より小さな値の weight を持っているページの方が先に表示されます。 weight を持たないページ（あるいは weight: 0 のページ）は、いかなる weight を持つページよりも後ろに表示されます。 Date ページのフロントマターで、date: &amp;quot;2022-05-20&amp;quot; のように記述しておくと、そのページの作成日として認識されます。 より新しいページが先に表示されます。 LinkTitle / Title ページのタイトルで昇順ソートされます。 フロントマターに linkTitle が指定されていればその値でソートされ、なければ title の値でソートされます。 FilePath .md ファイルのフルパスで昇順ソートされます。 具体的のどのような実装になっているかは、下記 Hugo ソースコードの DefaultPageSort 関数あたりを見ると分かります。
参考: hugo/pages_sort.go ソート方法をカスタマイズする .Pages 変数でページの一覧を取得するときに .Pages.ByTitle のように指定すると、ページタイトルでソートされた結果を取得できます。 他にもいろいろな参照方法があります。
参照方法 意味 .Pages.ByWeight フロントマターの weight の小さい順。ただし、weight: 0 は指定なしとみなされる .Pages.ByTitle タイトル (title) 順 .</description></item><item><title>Hugo でクリックで開閉する accordion ショートコードを作成する</title><link>https://maku77.github.io/p/w5gs4ep/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w5gs4ep/</guid><description>図: accordion ショートコードによる開閉表示 ブログ記事内の補足的な説明テキストなどは、デフォルトでは非表示にしておいて、必要なときにクリックで開閉できるようにしておくとスッキリします。 このような UI コンポーネントは、アコーディオン (accordion) と呼ばれることが多いので、ここでは accordion という名前のショートコードとして作成してみます。 accordion ショートコードは次のように使うことを想定しています。
Markdown 内での使用例 {{% accordion title=&amp;#34;もっと詳しく&amp;#34; %}} この本文はデフォルトでは隠されていて、クリックで見えるようになります。 - サンプルコード - 補足説明 などに使うと便利です。 {{% /accordion %}} ☝️ ワンポイント 本文のテキストを Markdown コードとして処理するためには、ショートコード名を &amp;lt; と &amp;gt; ではなく、上記のように % で囲む必要があります。 下記は、accordion ショートコードの実装例です。 クリックによる HTML 要素の表示／非表示の切り替えは、input 要素の状態による CSS の切り替えテクニック を利用しています。 label 要素と input 要素を結びつける ID には、Hugo の関数でランダムに生成した文字列 を使用しています。
layouts/shortcodes/accordion.html {{- $title := .Get &amp;#34;title&amp;#34; | default &amp;#34;例&amp;#34; }} {{- $rand := delimit (seq 9 | shuffle) &amp;#34;&amp;#34; }} &amp;lt;div class=&amp;#34;xAccordion&amp;#34;&amp;gt; &amp;lt;label class=&amp;#34;xAccordion_title&amp;#34; for=&amp;#34;id-{{ $rand }}&amp;#34;&amp;gt;{{ $title }}&amp;lt;/label&amp;gt; &amp;lt;input id=&amp;#34;id-{{ $rand }}&amp;#34; type=&amp;#34;checkbox&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;xAccordion_body&amp;#34;&amp;gt; {{ .</description></item><item><title>Hugo のテンプレートやショートコードでランダムな文字列を生成する</title><link>https://maku77.github.io/p/9qexh2q/</link><pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9qexh2q/</guid><description>次の random ショートコードは、1 〜 9 の数値をランダムに並び替えた 9 桁の数値文字列を生成します。
layouts/shortcodes/random.html {{ $random1 := delimit (seq 9 | shuffle) &amp;#34;&amp;#34; }} {{ $random2 := delimit (shuffle (split &amp;#34;123456789&amp;#34; &amp;#34;&amp;#34; )) &amp;#34;&amp;#34; }} &amp;lt;p&amp;gt;random1 = {{ $random1 }}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;random2 = {{ $random2 }}&amp;lt;/p&amp;gt; content/page1.md（使用例） --- title: &amp;#34;ページタイトル&amp;#34; --- {{&amp;lt; random &amp;gt;}} レンダリング結果 &amp;lt;p&amp;gt;random1 = 816257394&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;random2 = 234976851&amp;lt;/p&amp;gt; 上記の例では、2 種類の生成方法を示していますが、どちらも次のような手順でランダムな文字列を生成しています。
1 〜 9 の連番からなる配列を生成（seq 9 あるいは split &amp;quot;123456789&amp;quot; &amp;quot;&amp;quot; の部分） shuffle 関数 で配列要素をシャッフル delimit 関数 で配列要素を 1 つの文字列に結合 配列要素を結合する関数に delimit という名前が付けられていますが、多くの言語では join とか concatenate という名前が一般的ですね。 この関数名にはちょっと戸惑うかも（＾＾；</description></item><item><title>Hugo で SVG ファイルをインラインで埋め込む svg ショートコードを作成する</title><link>https://maku77.github.io/p/kyn8rcv/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kyn8rcv/</guid><description>Hugo で SVG ファイルを表示するには、Markdown の画像ファイル用構文や、Hugo 組み込みの figure ショートコード などを使用します。
![サンプル画像](sample.svg) {{&amp;lt; figure src=&amp;#34;sample.svg&amp;#34; caption=&amp;#34;サンプル画像&amp;#34; &amp;gt;}} この方法で SVG ファイルを表示すると、次のような img タグで外部ファイルを参照するような HTML が出力されます。
&amp;lt;img src=&amp;#34;sample.svg&amp;#34;&amp;gt; これは、PNG ファイルや JPG ファイルと同様に外部ファイルを画像として表示する方法なので、SVG ファイル内にテキストが含まれていたとしても、そのテキストを検索することはできません。 SVG ファイルの内容をインラインで svg 要素として埋め込むようにすれば、SVG ファイルの内容をブラウザの検索機能などで検索できるようになります。
次の svg ショートコードは、指定された SVG ファイルをインラインで HTML に埋め込みます。 ポイントは、Hugo の readFile 関数でファイルの中身を読み込んで、その場に出力するところです。
layouts/shortcodes/svg.html {{- $src := .Get &amp;#34;src&amp;#34; }} {{- $title := .Get &amp;#34;title&amp;#34; }} {{- /* md ファイルからの相対パスで svg ファイル名を指定できるように */}} {{- $svgFile := path.Join (path.Dir .</description></item><item><title>Hugo でショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode)</title><link>https://maku77.github.io/p/3j6qate/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3j6qate/</guid><description>.HasShortcode 関数 外部の JavaScript ファイルを利用して動作するショートコードを作成すると、Web サイトの表現力を大きく向上させることができます。 例えば、次のようなショートコードが考えられます。
独自の構文でコードを記述すると UML 図を出力してくれる mermaid ショートコード（mermaid.js などを利用） TeX 構文でコードを記述すると数式を出力してくれる math ショートコード（MathJax.js などを利用） このとき悩ましいのが、どのようにして次のような script 要素を出力するかです。
&amp;lt;script src=&amp;#34;for-shortcode.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; すべてのページにこのようなコードを出力してしまうと、この JavaScript が必要ないページでもファイルの読み込みが発生してしまいます。 こういった拡張が増えてくると、大量の JavaScript ファイルが読み込まれることになり、重い Web サイトになってしまいます。
このような場合の救世主が Page.HasShortcode 関数です。
参考: Hugo - Create Your Own Shortcodes - Checking for Existence ページテンプレート内で、
{{ if .HasShortcode &amp;#34;my-shortcode&amp;#34; }} ... {{ end }} といった記述をしておくと、Markdown ファイル内で my-shortcode ショートコードを使用している場合のみ出力を行うことができます。
実装例 例えば、ベーステンプレートの body 要素の末尾に次のように記述しておけば、Markdown ファイル内で mermaid ショートコードを使用している場合のみ、mermaid.js の読み込みと初期化処理を実行することができます。
layouts/_default/baseof.html（抜粋） ... {{- if .</description></item><item><title>mermaid.js で Hugo の Markdown 記事に UML 図を埋め込む</title><link>https://maku77.github.io/p/xg3n7qa/</link><pubDate>Tue, 13 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xg3n7qa/</guid><description>mermaid.js とは mermaid.js を使うと、独自構文のテキストから UML 図などを生成することができます。 JavaScript で動的に SVG を生成することができるので、Markdown ファイルに図を埋め込みたい場合によく使われています。
Azure DevOps Wiki や GitHub、Gitlab などでも標準サポートされており、Markdown で図を扱うときのデファクトスタンダードになるかもしれません。 UML 図の表現力という点では PlantUML の方が上ですが、そのあたりは改善されていくと思います。
Hugo は現時点 (v0.76.4) では、mermaid.js を標準サポートしていないので、ここでは Hugo に mermaid.js を組み込む方法を説明します。
mermaid.js の仕組み mermaid.js は、次のような mermaid クラスが付けられた HTML 要素の内容を読み取り、そこに変換後の図 (SVG) を挿入します。 この例の場合は、div 要素の内容が SVG に置き換わります。
&amp;lt;div class=&amp;#34;mermaid&amp;#34;&amp;gt; graph LR A --- B B--&amp;gt;C[あいうえお] B--&amp;gt;D(かきくけこ) &amp;lt;/div&amp;gt; HTML の body 要素の末尾あたりで、次のように mermaid.js の読み込みと初期化を行います。
... &amp;lt;script src=&amp;#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;mermaid.initialize({startOnLoad: true});&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; これだけで、Web ブラウザでページを開いたときに、SVG に変換された図が表示されます。</description></item><item><title>Hugo でページリスト（記事一覧）に列挙されないページを作る (_build.list)</title><link>https://maku77.github.io/p/4ziyhxe/</link><pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ziyhxe/</guid><description>Hugo 0.65.0 で、ビルド時の振る舞いを制御するためのフロントマター用プロパティ (_build) が導入されました。 記事ページのフロントマターで、_build.list プロパティを false に設定しておくと、.Pages、.RegularPages、.Sections などで返されるページリストに、そのページが含まれなくなります。
_build: # Whether to add it to any of the page collections. # Note that the page can still be found with .Site.GetPage. list: true # Whether to render it. render: true # Whether to publish its resources. These will still be published on demand, # but enabling this can be useful if the originals (e.g. images) are # never used.</description></item><item><title>Hugo で JSON-LD 形式のパンくずリストを出力する（SEO 対策）</title><link>https://maku77.github.io/p/5fzgwdt/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5fzgwdt/</guid><description>JSON-LD 形式の構造化データを HTML 内に含めておくと、Google の検索結果にページの階層構造が表示されるようになります。 この構造化データは、あくまで Google などの検索エンジンに記事の階層を伝えるためのもの であり、記事内に表示するためのパンくずリストではないことに注意してください。 画面表示用のパンくずリストを出力したいときは、下記の記事を参考にしてください。
参考: Hugo でパンくずリストを表示する パンくずリストのフォーマット JSON-LD 形式でパンくずリストを作成するときに、どのような内容で出力すればよいかは、 Google のパンくずリストの説明ページ に分かりやすく書かれています。
例えば、ある「記事ページ」が次のような階層で配置されているとします。
ホーム ＞ カテゴリA ＞ カテゴリB ＞ 記事ページ これを JSON-LD で表現するには、下記のようなコードを head 要素や body 要素の中に記述します。 特に理由がなければ、少しでもパフォーマンスを考慮して body 要素の最後に記述するのがよいでしょう。
&amp;lt;script type=&amp;#34;application/ld+json&amp;#34;&amp;gt; { &amp;#34;@context&amp;#34;: &amp;#34;https://schema.org&amp;#34;, &amp;#34;@type&amp;#34;: &amp;#34;BreadcrumbList&amp;#34;, &amp;#34;itemListElement&amp;#34;: [{ &amp;#34;@type&amp;#34;: &amp;#34;ListItem&amp;#34;, &amp;#34;position&amp;#34;: 1, &amp;#34;name&amp;#34;: &amp;#34;サイト名&amp;#34;, &amp;#34;item&amp;#34;: &amp;#34;https://example.com/&amp;#34; },{ &amp;#34;@type&amp;#34;: &amp;#34;ListItem&amp;#34;, &amp;#34;position&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;カテゴリA&amp;#34;, &amp;#34;item&amp;#34;: &amp;#34;https://example.com/category-a&amp;#34; },{ &amp;#34;@type&amp;#34;: &amp;#34;ListItem&amp;#34;, &amp;#34;position&amp;#34;: 3, &amp;#34;name&amp;#34;: &amp;#34;カテゴリB&amp;#34;, &amp;#34;item&amp;#34;: &amp;#34;https://example.</description></item><item><title>Hugo でページの階層構造を取得する関数を作成する (get-hierarchy)</title><link>https://maku77.github.io/p/v9t62ux/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v9t62ux/</guid><description>何を作るか？ Hugo の記事ページは、次のような感じで、セクション機能を使って階層化することができます。
ホーム ＞ セクション1 ＞ セクション2 ＞ ページタイトル ここでは、上記のような階層構造をスライス（配列）で取得する 関数を作成 してみます。 ページの階層構造を取得できると、パンくずリストなどを簡単に出力できるようになります。
階層構造を取得する関数 関数はパーシャルテンプレートの形で作るので、layouts/partials の下に .html ファイルを作成します。 ここでは、関数であることを明確にするために、さらに function という名前のディレクトリを作ってその下に格納することにします。 関数名（テンプレート名）は get-hierarchy とします。
layouts/partials/function/get-hierarchy.html {{ $hierarchy := slice . }} {{ if .Parent }} {{ $parentHierarchy := partial &amp;#34;function/get-hierarchy&amp;#34; .Parent }} {{ if $parentHierarchy }} {{ $hierarchy = $parentHierarchy | append $hierarchy }} {{ end }} {{ end }} {{ return $hierarchy }} この関数は、任意のテンプレートファイルから次のように呼び出します。
{{ $hierarchy := partial &amp;#34;function/get-hierarchy&amp;#34; .</description></item><item><title>Hugo のショートコードをエスケープ処理してそのまま表示する</title><link>https://maku77.github.io/p/9tg2m7q/</link><pubDate>Thu, 07 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9tg2m7q/</guid><description>Hugo で作成した記事（.md ファイル）内でショートコードの使い方を説明するときなど、ショートコードのタグそのものを文章中に表示させたいことがあります。 そのまま記述するとショートコードとして処理されてしまうので、次のようにエスケープ処理して記述する必要があります。
Markdown ファイル内での書き方 出力結果 {{&amp;lt;/* my-shortcode */&amp;gt;}} {{&amp;lt; my-shortcode &amp;gt;}} {{%/* my-shortcode */%}} {{% my-shortcode %}} ショートコード名の部分 (my-shortcode) を C/C++ や Java のコメント風に囲めば OK です。 コードブロックの中でも同様にエスケープ処理できます。</description></item><item><title>Hugo の記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout)</title><link>https://maku77.github.io/p/m2n8rbu/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m2n8rbu/</guid><description>フロントマターでのレイアウト指定 Hugo では、記事ファイル (.md) のレンダリングにどのレイアウトファイルを使用するかは、content ディレクトリ以下にどのようなパスで .md ファイルを配置したかによって決まります。 ほとんどのページではこれで十分なのですが、あるページだけ特殊なレイアウトを使用したい ことがあります。 例えば、検索ページや、新着記事リストのページなどです。 このような場合は、Markdown ファイルのフロントマターで、type プロパティや layout プロパティを指定することで、使用するレイアウトファイルを制御することができます。
type プロパティ コンテントタイプを指定します。デフォルトでは、content ディレクトリ以下のディレクトリ名が使われます（参考: Content Types | Hugo）。 layout プロパティ レイアウト名を指定します。デフォルトでは、ページの種類によって section.html（セクションテンプレート）や single.html（シングルページテンプレート）が使用されます。 これらの値の組み合わせによって、そのページをレンダリングするときに使用するレイアウトファイル（テンプレート）が次のように決まります。
layouts/&amp;lt;タイプ名&amp;gt;/&amp;lt;レイアウト名&amp;gt;.html 実際には、すべてのコンテントタイプで共通のレイアウトファイルを使えばよいことが多く、そのようなケースでは layouts/_default/single.html といったレイアウトファイルを配置します（タイプ名として _default 指定されたかのように振る舞います）。 複数のレイアウトファイルが存在する場合に、どのレイアウトファイルが選択されるかのルールは下記を参照してください。
参考: レイアウト用のテンプレートの種類を理解する 通常、コンテントタイプとレイアウトファイル名は、ディレクトリ構造と Markdown ファイル名によって決まるようになっています。 例えば、次のような感じです。
Markdown フィイル名 コンテントタイプ レイアウトファイル content/foo/_index.md foo section.html や list.html content/foo/page1.md foo single.html content/bar/page2.md bar single.html content/foo/bar/page3.md foo single.html フロントマターで type と layout を指定することにより、これらのルールを無視して、強制的に使用するレイアウトファイルを変更することができます。 例を見た方が分かりやすいので、ここでは、「新着一覧」のページをサンプルとして作ってみます。
☝️ ワンポイント 記事の一覧を表示するくらいであれば、通常はショートコードで出力してしまった方が簡単です。 ここでは、特定のページだけレイアウトを大きく変更する必要があると想定しています 使用するレイアウトファイルを指定する例 下記のテンプレートでは、更新日時が新しい順に、5 件分の記事をリスト表示しています。 このレイアウトは、「新着一覧」のページでしか使わない 特殊なレイアウト なので、レイアウトファイル自体も layouts/special/latest.</description></item><item><title>Hugo でサーチエンジン用に sitemap.xml や robots.txt ファイルを配置する</title><link>https://maku77.github.io/p/qr4eox7/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qr4eox7/</guid><description>サーチエンジンに対して、インデックス登録させたいページを伝えるには、Web サイトに sitemap.xml や robots.txt というファイルを配置します。 Google の検索結果に影響するため、正しく理解して配置しましょう。
sitemap.xml と robots.txt の概要 Web サイトのルートに sitemap.xml や robots.txt を置くと、下記のようなヒント情報を Google などの検索エンジンに伝えることができます。
sitemap.xml &amp;hellip; サイト内のページ一覧情報を記述します。検索エンジンは、サイト全体をクロールしなくても、この情報でページのインデックス情報を作成できるようになります。ページごとに更新日時 (YYYY-MM-DD) や優先度 (0.0〜1.0) を指定できます。 robots.txt &amp;hellip; クロールしなくてもよいディレクトリやファイルを指定します。上記の sitemap.xml の URL を指定することもできます。 もちろん、これらのファイルを用意したところで、どこまで反映されるかは検索エンジン側の実装によりますが、SEO 対策として少しでもヒントとなる情報を与えておくのが望ましいでしょう。
sitemap.xml を作成する sitemap.xml ファイルには、Google などの検索エンジンにインデックス登録してもらいたいページの一覧を記述します。
sitemap.xml のデフォルト出力 Hugo はデフォルトで Web サイトのルートに、Sitemap protocol に基づいた sitemap.xml ファイルを出力するようになっています。 下記はデフォルト設定で出力される sitemap.xml の例です。
sitemap.xml &amp;lt;urlset xmlns=&amp;#34;http://www.sitemaps.org/schemas/sitemap/0.9&amp;#34; xmlns:xhtml=&amp;#34;http://www.w3.org/1999/xhtml&amp;#34;&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://example.com/page1/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2020-04-26T00:00:00+00:00&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;https://example.com/page2/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2020-04-25T00:00:00+00:00&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;/urlset&amp;gt; この出力は、Hugo にデフォルトで組み込まれている sitemap.xml テンプレートによって生成されています。 デフォルトのテンプレート定義は下記を見ると分かります。</description></item><item><title>Hugo のテンプレートの中で絵文字を使用する (emojify)</title><link>https://maku77.github.io/p/88e7tiz/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/88e7tiz/</guid><description>emojify 関数の概要 Hugo のテンプレートファイルの中で emojify 関数 を使用すると、GitHub や Slack などで使える有名どころの絵文字 (emoticons) を出力することができます。 使えるアイコンのリストは下記サイトで確認できます。
🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp;amp; more 例えば、:smile: アイコンを表示したければ、任意のテンプレートファイルの中で次のように記述します。
{{ emojify &amp;#34;:smile:&amp;#34; }} emojify 関数の使用例 下記の例では、Hugo をサーバーモードで起動しているときに、ローカルファイルのパスをアイコン付きで表示します。
layouts/_default/single.html（抜粋） {{ if .Site.IsServer }} {{ emojify &amp;#34;:memo:&amp;#34; }}{{ .File.Filename }} {{ end }} 図: 表示結果</description></item><item><title>Hugo のパーシャルテンプレートから値を返す（関数化）(return)</title><link>https://maku77.github.io/p/4anjern/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4anjern/</guid><description>パーシャルテンプレートを関数として使用する Hugo v.0.55 以降のパーシャルテンプレートでは、テキストを出力する代わりに、値を return できるようになっています（参考: Returning a value from a Partial ｜ Hugo）。 この機能をうまく使うと、テンプレート内の共通処理をくくり出して、コードをスッキリさせることができます（通常のプログラミング言語の関数と同じイメージ）。
例えば、次の my-add-100 パーシャルテンプレートは、引数で受け取った値に 100 を足した値を返します。 パーシャルテンプレートの呼び出し時に渡された引数は、コンテキスト (.) として参照できます。
layouts/partials/functions/my-add-100.html {{ $ret := add 100 . }} {{ return $ret }} ここでは、関数風に呼び出せるパーシャルテンプレートであることを示すために、functions というディレクトリ以下に HTML ファイルを保存していますが、このあたりは自由です。 呼び出し側のテンプレートからは、次のように関数のように呼び出して、戻り値を受け取ることができます。
layouts/_default/single.html（抜粋） {{ $ret := partial &amp;#34;functions/my-add-100&amp;#34; 50 }} 戻り値: &amp;lt;b&amp;gt;{{ $ret }}&amp;lt;/b&amp;gt; レンダリング結果は次のようになります。
戻り値: &amp;lt;b&amp;gt;150&amp;lt;/b&amp;gt; パーシャルテンプレートに複数の値（引数）を渡す パーシャルテンプレートに複数の値を渡すには、辞書オブジェクト（キー＆バリュー）の形で値を渡します。 次のパーシャンテンプレート (my-add) は、2 つの数値を受け取り、それらを足し合わせた結果を返します。 ここでは、辞書のキー名として val1 と val2 を使用することを想定していますが、キー名は何でも構いません。 下記のように、パーシャルテンプレートの先頭で辞書キーを参照して変数に代入するようにしておくと、このパーシャルテンプレートがどのような辞書キーを期待しているのかが分かりやすくなります。
layouts/partials/functions/my-add.html {{ $v1 := .</description></item><item><title>Hugo でページ内リンク（アンカー）を張る</title><link>https://maku77.github.io/p/kmv4bjr/</link><pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kmv4bjr/</guid><description>ページ内リンクを張ることで、ワンクリックでページ内の任意の位置へジャンプできるようになります。
ヘッダ要素 (h2, h3, h4) へのジャンプ 自動的に割り振られる id 属性を使用する Hugo はデフォルトで、ヘッダ要素（h2 などの見出し）に id 属性を付けてくれます。 例えば、次のようなヘッダがあったとすると、
Link to me ---- 生成される h2 要素には、次のように自動的に id 属性が設定されます（スペースは - に置き換えられます）。
&amp;lt;h2 id=&amp;#34;link-to-me&amp;#34;&amp;gt;Link to me&amp;lt;/h2&amp;gt; よって、このヘッダ要素には、次のような内部リンクを張ることができます。
[Link to me へジャンプ](#link-to-me) もちろん、他のページのヘッダ要素へのリンクを張ることもできます。
[Link to me へジャンプ](/posts/pagename/#link-to-me) ヘッダ要素に独自の id 属性を設定する ヘッダ要素に自動的に割り振られる id 属性を使用することの欠点は、アルファベットや数字以外の文字が削除されてしまうことです。 また、見出しを変更すると id 属性の値も変わってしまうので、リンク切れのリスクも高まります。
例えば、次のような見出しがあったとすると、
OGP とは ---- 出力される HTML は次のようになります。
&amp;lt;h2 id=&amp;#34;ogp-&amp;#34;&amp;gt;OGP とは&amp;lt;/h2&amp;gt; 日本語の「とは」の部分が無視され、分かりにくい ID になってしまっています。 このような不完全な ID が割り当てられるのが嫌な場合は、次のようにして独自の ID を設定することができます。
OGP とは {#what-is-ogp} ---- 出力される HTML は次のようになります。</description></item><item><title>Hugo で「このページを編集 (Edit this page)」のリンクを表示する</title><link>https://maku77.github.io/p/vit4ckt/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vit4ckt/</guid><description>GitHub の編集ページ GitHub には簡易的なエディタ機能があり、ウェブサイト上で Markdown ファイルを直接編集できるようになっています。 Hugo サイトのコンテンツを GitHub で管理しているのであれば、GitHub の編集ページにリンクを張っておくと便利かもしれません。 この編集ページを使用すれば、Git コマンドに不慣れな人でも手軽に Markdown ファイルを修正することができます。
例えば、https://github.com/yourname/website/ といった GitHub リポジトリで Hugo のサイトコンテンツを管理している場合、トップページの Markdown ファイルを編集するための URL は次のようになります。
https://github.com/yourname/website/edit/master/content/_index.md ここでは、Hugo で生成する各ページに、上記のような編集ページへのリンクを出力することを考えてみます。
編集ページへのリンクを出力する まず、GitHub リポジトリのベース URL は、Hugo の設定ファイルに、独自パラメータ editBaseURL として定義することにしましょう。
hugo.toml baseURL = &amp;#34;https://example.com&amp;#34; languageCode = &amp;#34;ja-jp&amp;#34; title = &amp;#34;私のウェブサイト&amp;#34; [params] editBaseURL = &amp;#34;https://github.com/yourname/website/edit/master/content&amp;#34; 次に、編集ページへのリンクを出力するためのパーシャルテンプレートを作成します。
layouts/partials/edit-this-page.html {{ if $.Site.Params.editBaseURL }} {{- $filepath := replace .File.Path &amp;#34;\\&amp;#34; &amp;#34;/&amp;#34; -}} {{- $url := printf &amp;#34;%s/%s&amp;#34; $.Site.Params.editBaseURL $filepath -}} &amp;lt;a href=&amp;#34;{{ $url }}&amp;#34;&amp;gt;Edit this page&amp;lt;/a&amp;gt; {{- end }} このテンプレートでは次のようなことを行っています。</description></item><item><title>hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする</title><link>https://maku77.github.io/p/2ycmvbn/</link><pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2ycmvbn/</guid><description>Hugo は、各種クラウド (Azure Storage, Google Cloud Storage, AWS S3) 上のストレージにデプロイするためのコマンドを標準で搭載しています。
hugo deploy コマンドとは 静的なウェブサイトをホスティングするために、次のような有名どころのストレージサービスを使用している人は多いと思います。
Microsoft の Azure Storage (BLOB Storage) Google の GSC (Google Cloud Storage) Amazon の AWS S3 Hugo が搭載している hugo deploy コマンドを使用すると、プロジェクトの設定ファイル (hugo.toml) に記述されたデプロイ設定に基づき、これらのサービスへのデプロイを行えるようになります。 もちろん、各種ストレージサービス用の CLI（コマンドラインツール）を使ってもデプロイすることはできるのですが、hugo deploy を使うことでデプロイ方法が単純化（統一化）され、余計なコマンドラインツールをインストールしなくてもデプロイを実行できるという利点があります。
ここでは、Azure のストレージコンテナ（BLOB ストレージ）に Hugo で生成した Web コンテンツをデプロイする方法を説明します。
Azure のストレージコンテナにデプロイする hugo deploy の設定 Azure Storage は、簡単に静的な Web サイトをホスティングする機能を提供しています。 ここでは詳細な手順は記載しませんが、下記サイトのように、(1) ストレージアカウントの作成、(2) 静的な Web サイトを有効化、という 1 分くらいの手順で Web サイトを立ち上げることができます。 利用料金も、小規模なサイトであれば月額 100 円もかからないくらいリーズナブルです。</description></item><item><title>Hugo サイトで SNS（Twitter や Facebook）用の表示設定を行う (OGP: Open Graph Protocol)</title><link>https://maku77.github.io/p/w7r8p6m/</link><pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w7r8p6m/</guid><description>Web ページに OGP (Open Graph Protocol) に基づいたメタ情報を記述しておくと、SNS アプリで URL をシェアしたときに表示される内容をカスタマイズできます。
図: OGP 設定によるリンク表示の例 Open Graph のメタ情報として、どのような HTML タグを記述すればよいかは、下記のサイトを参考にしてください。
参考: Facebook や Twitter でシェアするときに画像や説明文が表示されるようにする (OGP: Open Graph Protocol) Open Graph タグを出力するためのパーシャルテンプレート ここでは、Hugo のパーシャルテンプレートで Open Graph タグを出力するようにしてみます。
layouts/partials/head/ogp.html &amp;lt;meta property=&amp;#34;og:site_name&amp;#34; content=&amp;#34;{{ .Site.Title }}&amp;#34; /&amp;gt; &amp;lt;meta property=&amp;#34;og:title&amp;#34; content=&amp;#34;{{ .Title }}&amp;#34; /&amp;gt; &amp;lt;meta property=&amp;#34;og:type&amp;#34; content=&amp;#34;website&amp;#34; /&amp;gt; &amp;lt;meta property=&amp;#34;og:url&amp;#34; content=&amp;#34;{{ .Permalink }}&amp;#34; /&amp;gt; &amp;lt;meta property=&amp;#34;og:locale&amp;#34; content=&amp;#34;ja_JP&amp;#34; /&amp;gt; {{- if .Params.image }} {{- $imageRes := .Resources.GetMatch .</description></item><item><title>Hugo で大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing)</title><link>https://maku77.github.io/p/mxhzgwd/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mxhzgwd/</guid><description>Image Processing 機能とは Hugo の Image Processing 機能 を使用すると、ページにバンドル した 1 枚の画像ファイルを加工し、サムネイル画像などを自動的に生成することができます。
例えば、デジカメで撮影した写真をウェブサイト上に掲載する場合、直接画像を貼り付けるとサイズが大きいため、小さなサムネイル画像からのリンクを用意することが多いと思います。 このような場合に、Image Processing 機能を使用すれば、サムネイル画像を手動で作成する手間をなくすことができます。
Image Processing の使用例 ここでは、下記のように、books セクションページ内に sample.png というリソースが含まれているとします。
content/ books/ _index.md sample.png Image Processing の機能を使って画像の変換を行うには、Page Resources のオブジェクト を取得する必要があります（Page 変数ではないので注意）。 このオブジェクトは、Page 変数 の次のようなプロパティ、およびメソッドを使って取得することができます。
.Resources（バンドルされたすべてのリソースを参照する） .Resources.ByType（指定した種類のリソースだけ取り出す） 例: $resources := .Resources.ByType &amp;quot;image&amp;quot; .Resources.Match（ファイル名のパターンに一致するリソースだけ取り出す） 例: $resources := .Resources.Match &amp;quot;sample.png&amp;quot; 例: $resources := .Resources.Match &amp;quot;**.png&amp;quot; 例: $resources := .Resources.Match &amp;quot;images/**.png&amp;quot; これらのメソッドは Markdown ファイル内から直接呼び出すことはできないので、実際にはショートコードやテンプレートファイルから利用することになります。
例えば、次のようなショートコードを作成しておけば、元の画像ファイルがどのようなサイズであっても、強制的に 150x150 のサイズのサムネイル画像を生成して表示してくれます。
layouts/shortcodes/thumbnail.html {{- $src := .</description></item><item><title>Hugo で Markdown ファイルに記述した HTML コードが削除されてしまう場合</title><link>https://maku77.github.io/p/mju5eox/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mju5eox/</guid><description>Goldmark 化による弊害 Hugo v0.60.0 から Markdown パーサーとして Goldmark が採用され、Markdown の解釈が微妙に変わっています。
Now CommonMark Compliant! - Hugo 例えば、今までは .md ファイル内に記述した HTML コードはそのまま出力されていたのに、デフォルトで取り除かれるようになっています。 これまでに作成した記事で HTML タグを使用している場合はちょっと困ってしまいます。
Markdown ファイル内に HTML コードを記述できるようにする .md ファイルに記述した HTML コードを、これまで通り出力できるようにするには、Hugo の設定ファイルで次のように指定します。
hugo.toml（TOML フォーマットの場合） [markup.goldmark.renderer] unsafe = true hugo.yaml（YAML フォーマットの場合） markup: goldmark: renderer: unsafe: true もちろん、使用する Markdown パーサー自体を旧来の BlackFriday に設定するという方法もあります。
[markup] defaultMarkdownHandler = &amp;#34;blackfriday&amp;#34; ただ、Goldmark の方が高速に動作するようなので、前向きに Goldmark に乗り換えることを考えた方がよいでしょう。</description></item><item><title>Hugo でドラフト指定したセクションが公開されてしまう場合</title><link>https://maku77.github.io/p/ynv4ago/</link><pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ynv4ago/</guid><description>Hugo のトラブルシューティングです（v0.62.0 で確認）。
ドラフトセクションが公開されてしまう問題 Hugo では、記事ページのフロントマターに、
draft: true という感じでドラフト指定を行なっておくと、hugo コマンドでページ生成するときに -D オプションを付けない限り、そのページは出力されなくなります。 しかし、セクションページに関しては、上記のように指定していても、必ず出力されてしまいます（v0.57 くらいからこんな振る舞いになってしまったような・・・）。
例えば、下記のようにトップレベルのセクションを一覧表示しようとすると、ドラフトのセクションまで出力されてしまいます。
&amp;lt;ul&amp;gt; {{ range .Site.Sections }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; このあたりの振る舞いは下記で議論されていて、
Improve _index.md vs draft · Issue #6312 · gohugoio/hugo · GitHub 作者の bep 氏 (Bjørn Erik Pedersen) によると、下記の回答がすべてを表しているようです。
The original purpose of draft did not include section pages &amp;ndash; as that was not a thing back then. （当初はドラフト機能はセクションページを対象にすることを考えていなかった）
セクションをドラフトとしてマークできるようにした場合、その下にぶらさがるページはどう振舞うべきなんだ（一時的にそのセクション自体が存在しないものとしてセクション外に出すの？）とか、仕様が複雑になってしまうのであまり振る舞いを変えたくないという事情があるみたいです。</description></item><item><title>Hugo でGoogle カスタム検索を設置して記事を検索できるようにする</title><link>https://maku77.github.io/p/n4o7o6m/</link><pubDate>Sun, 10 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/n4o7o6m/</guid><description>Google カスタム検索エンジンによる検索フォームを Hugo のサイトに設置することで、簡単にサイト内の記事を検索することができるようになります。
Google カスタム検索エンジンに自分のサイトを登録する まず、Google カスタム検索エンジンを適用する Web サイトは、インターネット上に公開されている必要があります。 プライベートな Hugo サーバーを使用する場合に検索機能を付けたい場合は、自己完結する全文検索の仕組み を導入する必要があります。 ここでは、すでにインターネット上に公開されている Web サーバーがあるという前提で話を進めます。
カスタム検索エンジンの登録は下記のサイトから行えます。
Google カスタム検索エンジン 追加 ボタンを押して、自分の Web サイトのアドレスを入力するだけで登録は完了します。
検索ページを表示する Web サイトをカスタム検索エンジンに登録すると、Google のサーバ上に、カスタム検索用のページが作成されます。 カスタム検索のコントロールパネル から、登録した検索エンジンを選択し、公開 URL の欄を確認してみてください。 下記のようなアドレスが生成されているはずです（下記アドレスの cx パラメータ部分は適当です）。
https://cse.google.com/cse?cx=207539779230035260336:1pkduco3un7 あとは、Markdown ファイルの中から、次のようにリンクを張ってやれば、即席のカスタム検索サイトの完成です。
[サイト内検索](https://cse.google.com/cse?cx=207539779230035260336:1pkduco3un7) 図: 表示例 Hugo のページ内に検索フォームと検索結果を表示する 上記のやり方では、Google のサーバ上に生成された検索ページへただジャンプするだけでした。 ここでは、Hugo の記事ページ内に検索フォームと、検索結果を表示できるようにしてみます。
まず、カスタム検索のサイトから、ページ埋め込み用の HTML コードを取得します。
図: カスタム検索用の HTML コードを生成 カスタム検索のコントロールパネル から、登録した検索エンジンを選択する デザイン のタブから、全幅 のデザインを選択する 保存してコードを取得する ボタンを押す 上記のようにポチポチ入力していくと、下記のようなコードが取得できるはずです（バージョンにより変更される可能性があります）。
&amp;lt;script async src=&amp;#34;https://cse.google.com/cse.js?cx=207539779230035260336:1pkduco3un7&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div class=&amp;#34;gcse-search&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 後は、このコードを、任意の記事ページの Markdown ファイル内にコピペするだけです。</description></item><item><title>Python で Markdown ファイルのフロントマターの記述が正しいかチェックする</title><link>https://maku77.github.io/p/bes7iu7/</link><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bes7iu7/</guid><description>下記の Python スクリプト (check-front-matter.py) は、Markdown ファイルに記載された YAML フロントマターの内容が正しいかどうかを調べるサンプルスクリプトです。 確認内容は、validate() 関数の中に記載されていますので、用途に応じてこの内容を書き換えてください。 下記のサンプルコードでは、フロントマターに title と date が記載されているかをチェックしています。
使い方 PyYAML というライブラリを使用しているので、下記のようにインストールしておく必要があります。
PyYAML のインストール $ pip install pyyaml 次のように実行すると、カレントディレクトリ以下の全ての Markdown ファイル (.md) の内容を検証できます。
$ python check-front-matter.py content/title3.md: Missing title or date content/title4.md: Missing title or date content/title5.md: Missing title or date この例では、3 つの Markdown ファイルのフロントマターが正しく記述されていないことが検出されています。
サンプルスクリプト check-front-matter.py #!/usr/bin/env python3 import yaml class YamlFrontMatter: &amp;#34;&amp;#34;&amp;#34;YAML ファイルからフロントマターを取得するクラスです。&amp;#34;&amp;#34;&amp;#34; def __init__(self, filename): self.filename = filename def load_frontmatter(self): &amp;#34;&amp;#34;&amp;#34; Markdown ファイルのフロントマターを読みこんで、 Python のオブジェクトとして返します。 &amp;#34;&amp;#34;&amp;#34; with open(self.</description></item><item><title>Hugo でサイト構造を変えてもページの URL が変わらないようにする (Permalink)</title><link>https://maku77.github.io/p/u9r9p7n/</link><pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/u9r9p7n/</guid><description>各ページの URL は変わってはいけない Hugo によって出力される HTML ファイルのパスは、デフォルトでは content ディレクトリ以下のセクション構成（ディレクトリ構成）やファイル名によって決定されます。 サイトの規模が小さいうちはこれでもよいのですが、Markdown ファイル数が増えてくると、ディレクトリ構造を変えたり、ファイル名を整理したくなってきます。 それによってページの URL がころころ変わってしまうと、せっかくリンクを張ってくれたサイトがあっても、すべてリンク切れになってしまいます。
このようなリンク切れを起こさないようにするのが パーマリンク (permalink) という考え方で、各ページに不変の ID を割り当てて URL が変わらないようにします。 例えば、Amazon の各商品のページは 10 桁の ISBN-10 という ID でアクセスできるようになっています。
https://www.amazon.co.jp/dp/4592146980/ Hugo でも、各ページにこのような ID ベースの URL を割り当てることができます。
不変の URL を割り当てた例 https://&amp;lt;your-hugo-site&amp;gt;/p/abc1234/ Hugo で出力するページに固定の URL を割り当てる Markdown ファイルのフロントマターに url プロパティを設定すると、そのページの URL を固定することができます。
--- title: &amp;#34;ページタイトル&amp;#34; url: &amp;#34;p/abc1234/&amp;#34; date: &amp;#34;2019-10-20&amp;#34; --- 例えば、上記のようなフロントマターを記述しておくと、そのページには必ず https://ドメイン名/p/abc1234/ というアドレスでアクセスできるようになります。 一階層目のパスは別の用途で使用する可能性があるため、ここでは p という階層を掘って、permalink 化した記事を格納するようにしています（Amazon の dp と同様です）。 このようにすることで、Markdown ファイルのファイル名や記事タイトル、ディレクトリ構成を変えても、最終的な URL を変化させずに済みます。</description></item><item><title>Hugo で画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle)</title><link>https://maku77.github.io/p/9n8p6n4/</link><pubDate>Sat, 19 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9n8p6n4/</guid><description>ページバンドルとは 初期の頃の Hugo では、画像ファイルは static ディレクトリに置いて、記事ファイル (Markdown) と別々のディレクトリで管理するという方法がとられていました。
content/ _index.md page1.md page2.md page3.md static/ image1.png image2.png image3.png しかし、これでは Markdown ファイルと画像ファイルをバラバラに管理しないといけないというユーザーの不満が出て、現状は content ディレクトリ以下に一緒に配置できるようになっています。 この仕組みを ページバンドル (Page Bundle) と言います。
参考: Page Bundles - Hugo ページバンドルは、その名のとおり、各ページにバンドルする形で画像ファイル（リソース）を保持するという考え方です。 ページバンドルを作成するには、content ディレクトリ以下に _index.md あるいは index.md を含むディレクトリを作成し、そのディレクトリ内に一緒に画像ファイルなどのリソースファイルを格納します（画像ファイル以外のファイルでも OK）。 つまり、バンドルされた画像ファイルを表示したいページは、_index.md あるいは index.md というファイル名のコンテンツでなければいけません。
Page Bundle には、Branch Bundle と Leaf Bundle の 2 種類があり、_index.md を含むディレクトリは Branch Bundle となり、index.md を含むディレクトリは Leaf Bundle となります。
content/ branch/ ← Branch Bundle _index.md image1.png data/ image2.</description></item><item><title>Hugo サイトの favicon.ico をサイトのルートに配置する (static)</title><link>https://maku77.github.io/p/vu7hr2b/</link><pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vu7hr2b/</guid><description>Hugo によって生成した Web サイトのルート階層に favicon.ico を配置するには、static ディレクトリに favicon.ico ファイルをそのまま置いておけば OK です。
website/ +-- content/ +-- layouts/ +-- static/ +-- favicon.ico static ディレクトリ以下に置いたファイル群は、その階層構造を保ったまま出力ディレクトリへコピーされます。
favicon の詳細については下記を参考にしてください。
Web サイトに favicon を設定する</description></item><item><title>Hugo でドラフトページの一覧を簡単に確認できるようにする</title><link>https://maku77.github.io/p/qpcvfzi/</link><pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qpcvfzi/</guid><description>やりたいこと Hugo では、作成途中の記事ページをドラフトとしてマークしておくと、デフォルトで非公開扱いになるので、気軽に記事を書き始めることができます。 ただ、ドラフトページがたくさん溜まってくると、自分が中途半端に書き始めた記事が散らばって分かりにくくなってしまいます。 そこで、ここでは下記のような仕組みを実装して、Hugo のドラフト機能をより便利に使用できるようにします。
図: ドラフト一覧のページへ移動するボタン ドラフトの一覧ページに飛ぶための ドラフト記事一覧ボタン をサイドバー上に表示する（上図） ドラフトの一覧ページでは、最終更新日 や タグ情報 も一緒に表示する 上記は ローカルでの作業中のみ表示する こととする（具体的には hugo server で実行中のみ） ドラフト記事一覧のページにジャンプするボタンを配置する ドラフトページへジャンプするためのボタンは、レイアウトファイルから簡単に配置できるように、パーシャルファイルとして作成します。 個人的に、ローカルでしか有効にしないコードは、下記のように debug ディレクトリの下に入れるようにしています。 そして、全体のコードを if .Site.IsServer の条件で囲むことで、ローカルサーバーで起動しているときのみ出力されるようにしています。
layouts/partials/debug/draft-button.html {{- if .Site.IsServer -}} &amp;lt;style&amp;gt; .xDraftButton { display: block; text-align: center; width: 100%; font-weight: bolder; color: white !important; background: blue; padding: 0.3em 0.5em; border-radius: 0.5em; } &amp;lt;/style&amp;gt; &amp;lt;a href=&amp;#34;/drafts/&amp;#34; class=&amp;#34;xDraftButton&amp;#34;&amp;gt;ドラフト記事一覧&amp;lt;/a&amp;gt; {{- end }} 簡単に言えば、このパーシャルは、https://example.com/drafts/ といった URL へのリンクを出力しているだけです。 上記では style 要素も含めてしまっていますが、みなさんはちゃんと CSS ファイルでスタイル定義するようにしてください。</description></item><item><title>Hugo で各ページに目次を表示する (.TableOfContents)</title><link>https://maku77.github.io/p/x9tbr8o/</link><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x9tbr8o/</guid><description>Hugo 組み込みのページ変数 .TableOfContents を使用すると、各ページに簡単に目次を表示することができます。
Hugo の目次機能 各ページの Markdown ファイル (.md) には、## や ---- を使ったセクション（h2 要素として出力される）を記述していると思います。 Hugo は、これらの セクション名から自動的に目次 (Table of Contents) を出力する機能 を搭載しています。 下記は、自動的に出力した目次の例です。
図: Hugo で自動生成された目次 テンプレートの記述方法（v0.59以前） 目次を自動的に出力するには、テンプレートファイル内で .TableOfContents というページ変数を参照します。
layouts/_default/single.html（抜粋） {{- with .TableOfContents }} &amp;lt;aside class=&amp;#34;xToc&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;xToc_title&amp;#34;&amp;gt;目次&amp;lt;/div&amp;gt; {{ . }} &amp;lt;/aside&amp;gt; {{- end }} ここでは、目次情報がないときに何も表示しないように、with で分岐処理を行っています（2019-12-26 追記: v0.60.0 以降は出力内容が変わったため、このように分岐処理を行えなくなりました。次のセクションを参照してください）。
Hugo が自動的に生成する .TableOfContents の値は、ul 要素と li 要素によって構成されています。 出力された HTML の内容を見て、スタイルシート (CSS) の調整をするとよいでしょう。 下記は CSS の記述例です。
.xToc { font-size: smaller; border-radius: 0.</description></item><item><title>Hugo でページタイトルに自動でセクションプレフィックスを付ける</title><link>https://maku77.github.io/p/dunigdz/</link><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dunigdz/</guid><description>Hugo で多くのコンテンツを作成する場合、記事の種類ごとにセクション（ディレクトリ）に分けて管理することになります。 このような場合、各ページのタイトルに対して、セクションのタイトルを自動で付加できれば、ページタイトルの管理が楽になります。
何をするか？ 例えば、次のようなセクション構造で記事を管理しているとします。
contents/ +-- _index.md (home page) +-- section1/ | +-- _index.md (section page) | +-- page1.md (single page) | +-- page2.md (single page) | +-- page3.md (single page) +-- section2/ +-- _index.md (section page) +-- ... 各ディレクトリにある _index.md は、セクションページのコンテンツファイルとして使用されます。 このファイルのフロントマターには、下記のようにセクションのタイトルを記述することができます。
contents/section1/_index.md --- title: &amp;#34;セクション1&amp;#34; date: &amp;#34;2019-05-17&amp;#34; --- セクションページの本文… このセクションタイトルは、セクションページ（このケースでは https://example.com/section1/）にアクセスしたときに使用されるものですが、同じセクションに所属する記事ページのタイトルのプレフィックスにも自動で付加できると便利です。
例えば、section1 に所属する記事ページとして下記のようなコンテンツがあるとします。
contents/section1/page.md --- title: &amp;#34;タイトル1&amp;#34; date: &amp;#34;2019-05-17&amp;#34; --- ページの本文… このように記述されているときに、表示するタイトルを タイトル1 ではなく、セクション1: タイトル1 のようにしたいということです。 このように、セクションタイトルを付加することで、あるページを単独で表示したときに、どのような階層に配置された記事なのかが分かりやすくなります。</description></item><item><title>Hugo でソースコードをハイライト表示する (highlight)</title><link>https://maku77.github.io/p/gxk6qat/</link><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gxk6qat/</guid><description>Pygments によるコードハイライト Hugo の設定ファイル config.toml の中で、下記のように設定しておくと、Pygments によるコードブロックのハイライト機能を有効にすることができます。
pygmentsCodeFences = true 例えば、Java のソースコードであれば、Markdown ファイルの中で、下記のように言語名 (java) を指定してコードブロックを記述するだけで、その言語に特化したハイライト表示を行ってくれます。
```java public class Main { public static void main(String... args) { System.out.println(&amp;#34;Hello&amp;#34;); } } ``` 図: ハイライト表示例 highlight ショートコードによるコードハイライト Hugo の組み込みショートコードとして highlight が用意されています。 このショートコードを使用すると、pyghmentsCodeFences を使う方法よりも高度なコードハイライトを行えます。 例えば、下記のように、行番号を表示したり、特定の行を強調表示することができます。
{{&amp;lt; highlight java &amp;#34;linenos=table, hl_lines=3&amp;#34; &amp;gt;}} public class Main { public static void main(String... args) { System.out.println(&amp;#34;Hello&amp;#34;); } } {{&amp;lt; /highlight &amp;gt;}} 図: ハイライト表示例 色々なオプションが用意されているので、詳しくは下記の Hugo ドキュメントを参照してください。
Hugo - Syntax Highlighting キャプションを付けられる独自のショートコードを作成する ソースコードの表示をキャプション付きでマークアップする場合は、HTML では下記のように figure、figcaption タグを使って記述します。</description></item><item><title>Hugo でリンクをページからの相対パスで出力するようにする (relativeurls)</title><link>https://maku77.github.io/p/32n9scv/</link><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/32n9scv/</guid><description>サイト内のページへのリンクを /sec1/sec2/ のように記述しておくと、デフォルトではそのまま /sec1/sec2/ へのリンクとして出力されます（つまり、baseURL からの相対パスになります）。
Hugo の設定ファイル config.toml（あるいは config.yaml）で relativeurls = true という設定を追加しておくと、各リンクが現在のページからの相対パスで出力されるようになります。
config.toml の例 baseURL = &amp;#34;https://example.com/&amp;#34; relativeurls = true languageCode = &amp;#34;ja-jp&amp;#34; title = &amp;#34;サンプル Web サイト&amp;#34; 例えば、/content/posts/sample.md というコンテンツファイル内に /about/ というリンクを記載しておくと、出力されるリンクのパスは ../about/ になります。</description></item><item><title>Hugo で参照するデータファイルをショートコードのパラメータで切り替える</title><link>https://maku77.github.io/p/jbi9ojq/</link><pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jbi9ojq/</guid><description>下記の記事では、data ディレクトリの基本的な使い方を説明しています。
全ページから参照できるデータを用意する（data ディレクトリ） ここではもう少し踏み込んで、ショートコードを使って、パラメータで指定した名前のデータファイルを読み込めるようにしてみます。
まず、サンプルデータとして下記のようなデータファイルを用意します。 ファミコンのゲームタイトルの一覧です。
data/games/nes.yaml （データファイル） - title: ドンキーコング date: 1983-07-15 maker: 任天堂 - title: ドンキーコングJR. date: 1983-07-15 maker: 任天堂 - title: ポパイ date: 1983-07-15 maker: 任天堂 次に、このデータファイルを使って、HTML の table として出力するショートコードを作成します。
layouts/shortcodes/games.html （ショートコード） &amp;lt;table&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;発売日&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;タイトル&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;メーカー&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; {{- range .Site.Data.games.nes }} &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{{ .date }}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{{ .title }}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;{{ .maker }}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; {{- end }} &amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; コンテンツページから、次のように使用することができます。
content/ref/nes-games.md --- title: &amp;#34;ファミコンのゲームタイトル一覧&amp;#34; --- {{% games %}} 上記のショートコードは、data/games/nes.yaml という決まったデータファイルを読み込むようにしていますが、下記のようにすれば、パラメータで指定した YAML ファイルを読み込めるようになります。 こうすることで、例えば、スーパーファミコンのタイトルリストを別の YAML ファイルで作成しておき、同じショートコードを使ってテーブル出力できるようになります。</description></item><item><title>Hugo で Markdown ファイルに本文が記述されていない場合だけ特別な出力をする</title><link>https://maku77.github.io/p/7m6n4j2/</link><pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7m6n4j2/</guid><description>例えば、あるページの Markdown ファイルが下記のようにフロントマターだけの記述になっていると、
--- title: &amp;#34;ページタイトル&amp;#34; date: &amp;#34;2018-11-02&amp;#34; --- テンプレートから Page 変数の {{ .Content }} を参照したときの値は空っぽ になります。 このような場合だけ別の出力をしたい場合は、下記のように場合分け処理を記述します。
layouts/_default/single.html（抜粋） {{ with .Content }} {{ . }} {{ else }} &amp;lt;b&amp;gt;本文が記述されていません。&amp;lt;/b&amp;gt; {{ end }} このような分岐出力は、セクションページ（_index.md）などで活用できると思います。 例えば、次のようにセクションテンプレートを記述しておけば、セクションページに本文が記述されている場合はその内容を表示し、本文が記述されていない場合はそのセクション直下のページリストを表示できます。
layouts/_default/section.html（抜粋） {{- with .Content }} {{ . }} {{- else }} &amp;lt;ul class=&amp;#34;pageList&amp;#34;&amp;gt; {{/* カレントセクション直下のセクション */}} {{- range .Sections }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; /&amp;lt;/li&amp;gt; {{- end -}} {{/* カレントセクション直下の記事ページ */}} {{- range .</description></item><item><title>Hugo に全文検索（インクリメンタルサーチ）の機能を付ける</title><link>https://maku77.github.io/p/p4n5m3i/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/p4n5m3i/</guid><description>ここでは、Hugo サイトに全文検索の機能を付ける方法を説明します。 全文検索を実現する方法としては、Google カスタム検索を導入する方法もありますが、Google カスタム検索は、インターネット上に公開する Web サイトにしか適用できません。 ここで紹介する JavaScript を利用した全文検索は、ローカルで運用する Web サイトでも利用できますし、インクリメンタルサーチも実現することができます（実際のサイトの例）。
図: 全文検索＋インクリメンタルサーチの完成イメージ 大まかに、下記のようなコードを含む HTML ファイルを出力できれば、サイト内の全文検索を実現することができます。
検索用 JavaScript データ (const data = [...]) 検索用 HTML フォーム (&amp;lt;input&amp;gt;) 検索用 JavaScript 関数 (function search() {...}) ここでは、全文検索のためのページとして search という名前のページ (content/search.md) を作成することにします（URL としては http://localhost:1313/search/ という形でアクセスすることになります）。 すでに search という名前のページを作成している場合は適宜変更してください。
☝️ 2023-05-04 追記 以前の実装では、検索用データ (search/data.js) と検索用ページ (search/index.html) を分けて出力していましたが、検索用ページに統合するように変更しました。 Hugo がバージョンアップして、出力ファイルに livereload 用の script タグを自動挿入するようになり、正しい data.js ファイルとして出力できなくなってしまったからです。 コンテンツファイル (content/search.md) の作成 まず、全文検索用のページを出力するためのコンテンツファイルを作成しておきます。
content/search.md --- title: &amp;#34;サイト内全文検索&amp;#34; layout: search _build: { list: false } --- フロントマターの layout プロパティで search という名前のテンプレートを使うことを指定しておきます。 ついでに、_build プロパティで、このページをリスト系ページの一覧に列挙しないようにしておきます（参考: 記事一覧に列挙されないページを作る）。</description></item><item><title>Hugo で Sass (SASS/SCSS) スタイルシートを使用する</title><link>https://maku77.github.io/p/k7jv7hs/</link><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k7jv7hs/</guid><description>Hugo 0.46 で Sass (SASS/SCSS) がサポートされました。 これを使うと、スタイルシートを効率的に記述できるようになります。&amp;quot;
Sass とは Sass (SASS/SCSS) は CSS のプリプロセッサで、これを利用すると、柔軟な変数の仕組みや、入れ子構造を用いたスタイルシート記述が可能になります。
Sass: Syntactically Awesome Style Sheets Sass の記述フォーマットとしては、古い SASS 記法（拡張子 .sass）と、新しい SCSS 記法（拡張子 .scss）がありますが、現在は CSS のフォーマットと互換性のある SCSS 記法が主流になっています。 最新の CSS では、ネイティブに変数の仕組みなどをサポートしていますが、ブラウザの対応状況もまだまだなので、しばらくは Sass が使われ続けるでしょう。
Hugo で Sass を使用する Hugo で Sass を使用する方法は、下記の本家ドキュメントに記述されています。
Hugo Pipes ＞ SASS/SCSS Hugo Pipes ＞ Hugo Pipes Introduction 大まかな手順は次の通りです。
ルートの assets ディレクトリ以下に .scss ファイルを配置する。 テンプレート内でパイプコマンドを利用して .scss ファイルを .css に変換し、変換後の .css ファイル名を link 要素で指定する。 1. assets ディレクトリに .</description></item><item><title>Hugo のページ内に Tex 形式の数式を埋め込めるようにする (MathJax)</title><link>https://maku77.github.io/p/dsfzi4n/</link><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsfzi4n/</guid><description>Hugo のテンプレートで MathJax という Javascript ライブラリを組み込むと、記事内に Tex 形式の数式を埋め込むことができるようになります。
参考: MathJax with Hugo MathJax を有効にする まず、すべてのページで次のようにして MathJax.js を読み込む必要があります。
&amp;lt;script src=&amp;#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; フッター用のパーシャルテンプレート（layouts/partials/footer.html など）を用意しているのであれば、その中に記述しておくのがよいでしょう。
CDN で提供されている最新の MathJax.js のアドレスは、cdnjs.com のサイトで MathJax と入力するか、MathJax のサイト で調べることができます。
ページ内に数式を記述する あとは、Markdown ファイル内で $$数式$$ というフォーマットで記述すれば、きれいな数式が表示されます。
Markdown ファイル内の記述例 $$F(x) = \sum_{n=1}^{N} \frac{1}{N}$$ 図: 表示例 インライン形式で数式を記述できるようにする 通常の文章の中にインライン形式で数式を埋め込むには、MathJax.js の設定を行っておく必要があります。 MathJax.js を読み込む HTML コードと一緒に、次のようなコードを追加してください。
テンプレート抜粋（layouts/partials/footer.html など） &amp;lt;script type=&amp;#34;text/x-mathjax-config&amp;#34;&amp;gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[&amp;#39;$&amp;#39;,&amp;#39;$&amp;#39;]] } }); &amp;lt;/script&amp;gt; 上記のように設定しておくと、文章の中に $数式$ というフォーマットで、数式をインラインで埋め込めるようになります。
Markdown ファイル内の記述 次の数式は $F(x) = \sum_{n=1}^{N} \frac{1}{N}$ 文章内に埋め込まれます。 図: 表示例</description></item><item><title>Hugo で Markdown (.md) ファイルのパス情報を取得する</title><link>https://maku77.github.io/p/8env4bi/</link><pubDate>Thu, 14 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8env4bi/</guid><description>Hugo のテンプレートファイル内で、File 変数を参照すると、記事ページのもとになった Markdown ファイルのパス情報を取得することができます。 File 変数の一覧は下記のページで参照できます。
File Variables｜Hugo File 変数の使用例 テンプレートファイルに下記のようなコードを追加すれば、File 変数の内容を簡単に確認できます。
layouts/_default/baseof.html（抜粋） &amp;lt;pre&amp;gt; .File.Filename = {{ .File.Filename }} .File.Path = {{ .File.Path }} .File.Dir = {{ .File.Dir }} .File.LogicalName = {{ .File.LogicalName }} .File.BaseFileName = {{ .File.BaseFileName }} .File.Extension = {{ .File.Extension }} &amp;lt;/pre&amp;gt; 例えば、C:\Users\maku\website\content\diary\2018.md から生成されたページ (diary/2018.html) にアクセスすると、以下のようなパス情報を取得することができます。
.File.Filename = C:\Users\maku\website\content\diary\2018.md .File.Path = diary\2018.md .File.Dir = diary\ .File.LogicalName = 2018.md .File.BaseFileName = 2018 .File.Extension = md Hugo サーバ動作させているときに Markdown ファイルのパスを表示する テンプレート内に下記のように記述しておけば、Hugo のローカルサーバで Web サイトをホスティングしている場合のみ、ローカル PC 内の Markdown ファイルのパスを表示することができます。</description></item><item><title>Hugo でファイルが存在する場合のみ処理するコードを記述する (fileExists)</title><link>https://maku77.github.io/p/q4o6n4k/</link><pubDate>Mon, 11 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q4o6n4k/</guid><description>Hugo のテンプレートの中で、fileExists 関数を使用すると、指定したファイルが存在する時のみ有効になる処理を記述することができます。 例えば、次のようにすると、static ディレクトリに画像ファイル (img/site-logo.png) が存在する場合のみ、その画像を表示する img 要素を出力します。
{{ if (fileExists &amp;#34;static/assets/img/site-logo.png&amp;#34;) }} &amp;lt;img src=&amp;#34;{{ &amp;#34;assets/img/site-logo.png&amp;#34; | absURL }}&amp;#34;&amp;gt; {{ end }} 参考: fileExists｜Hugo</description></item><item><title>Hugo のページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする</title><link>https://maku77.github.io/p/8ogzaxd/</link><pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8ogzaxd/</guid><description>Hugo には Pagenator という標準のページャー機能が備わっており、比較的簡単にページャー機能を組み込むことができます（参考: Pagination｜Hugo）。
ページャーの基本 ページャーとは、Google の検索結果のページなどで表示される、下記のようなものです。
図: ページャーの例 あるカテゴリに属する記事のリストを表示するときや、数日分の日記をまとめて表示するようなケースでは、1 ページが長くなりすぎないように、ページャーを導入することを検討するのがよいでしょう。
Hugo でページャーを導入すると、デフォルトでは /page/1、/page/2、/page/3 といった URL で、それぞれのグループ（複数の記事をまとめたページ）を表示するためのページにアクセスできるようになります（page というパスは、Hugo のコンフィグファイルの PaginatePath で変更できます）。
図: ページャーによる切り替え Hugo のページャー機能は、ホームページとリスト系ページ（セクションページや、タクソノミーリスト）のみで有効です。 つまり、ホームページテンプレート (layouts/index.html) や、リストテンプレート (layouts/_default/list.html) などに適用することになります。
ホームページテンプレートに適用すれば、それぞれのグループを表示するためのページには、次のようなアドレスでアクセスできるようになります。
https://example.com/page/1 （https://example.com/ のエイリアス） https://example.com/page/2 https://example.com/page/3 セクションテンプレートに適用した場合は、次のようなアドレスでアクセスできるようになります。
https://example.com/&amp;lt;SECTION&amp;gt;/page/1 （https://example.com/&amp;lt;SECTION&amp;gt;/ のエイリアス） https://example.com/&amp;lt;SECTION&amp;gt;/page/2 https://example.com/&amp;lt;SECTION&amp;gt;/page/3 ここでのポイントは、上記のようなファイル群は、1 つのホームページテンプレート（あるいはセクションテンプレート）から自動的に生成されるということです。 つまり、複数のページとして出力されてはいるものの、ページャー部分以外のコンテンツは同じになります。 後述するように、テンプレート内で .Pagenator にアクセスすると、Hugo は自動的にこれらのファイルを出力するようになります。
ちなみに、単独のページを出力するためのシングルページテンプレート (layouts/_default/single.html) ではページャー機能は使えないので、代わりに、ページ切り替え用の「次のページ」、「前のページ」といったリンク を表示しておくのがよいでしょう。
ページャーを導入する 組み込みの pagination テンプレートを使用する 1 グループごとの記事のリストは、.Pagenator.Pages で参照することができるようになっているので、これを range を使って列挙すれば OK です。 デフォルトでは 10 記事ごとがグルーピングされていますが、このサイズは Hugo のコンフィグファイルの Paginate で変更できます。 肝心のページ切り替え部分は、Hugo 組み込みのテンプレート _internal/pagination.</description></item><item><title>Hugo で Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics)</title><link>https://maku77.github.io/p/zxk6pat/</link><pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zxk6pat/</guid><description>Google Analytics を使用すると、Web サイトのアクセス情報を多角的に分析できるようになります。 ここでは、Hugo で作成する Web サイトに、簡単に Google Analytics 用のコードを埋め込めるようにしてみます。
トラッキング ID をコンフィグファイルで設定する まずは、Google Analytics の管理画面から、「プロパティの追加」を実行し、分析したい Web サイトのアドレスを追加しておきます（Google Analytics のアカウントを持っていない場合は、先にアカウントから作成しておく必要があります）。 そのとき発行されるトラッキング ID（UA-12345678-1 のような ID）が、その Web サイトへのアクセスを判別するための識別情報となります。 この ID は、Web サイトごとに別のものを使用するので、Hugo のコンフィグファイルで設定するのがよいでしょう。
Hugo には、コンフィグファイル用のパラメータとして、あらかじめ googleAnalytics というパラメータが用意されています。 下記のような感じで、Google Analytics のサイトで発行したトラッキング ID を設定しましょう。
config.toml baseURL = &amp;#34;https://example.com/&amp;#34; languageCode = &amp;#34;ja-jp&amp;#34; title = &amp;#34;まく日記&amp;#34; theme = &amp;#34;maku&amp;#34; googleAnalytics = &amp;#34;UA-12345678-1&amp;#34; 上記のように設定すると、テンプレートファイルの中から、.Site.GoogleAnalytics でトラッキング ID を参照できるようになります。
トラッキングコード (JS) を自動で埋め込むようにする Google Analytics を有効にするには、各ページの head 要素の先頭に、次のような トラッキングコード を埋め込む必要があります（参考: gtag.</description></item><item><title>Hugo でコンフィグファイルに設定した情報を参照する</title><link>https://maku77.github.io/p/5m9tdwg/</link><pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5m9tdwg/</guid><description>コンフィグファイルの基本 Hugo サイトの全般的な設定は、ルートディレクトリに置いた下記のいずれかのコンフィグファイルで行います（最初に見つかったものが採用されます）。
config.toml （TOMLフォーマットで記述） config.yaml （YAMLフォーマットで記述） config.json （JSONフォーマットで記述） config.toml の記述例 baseURL = &amp;#34;https://example.com/&amp;#34; languageCode = &amp;#34;ja-jp&amp;#34; title = &amp;#34;まく日記&amp;#34; themesDir = &amp;#34;../hugo_themes&amp;#34; theme = &amp;#34;maku&amp;#34; 設定可能なパラメータや、それぞれのデフォルト値は下記に一覧があります。
Configure Hugo｜Hugo 設定値を参照する Hugo が定義しているパラメータを参照する コンフィグファイルで設定したパラメータは、テンプレートファイル内から、.Site 変数を使って参照することができます。 例えば、config.toml ファイルの中で設定した title や baseURL パラメータの値は次のようにして参照することができます。
このサイトのタイトルは &amp;lt;b&amp;gt;{{ $.Site.Title }}&amp;lt;/b&amp;gt; です。 このサイトのベースアドレスは &amp;lt;b&amp;gt;{{ $.Site.BaseURL }}&amp;lt;/b&amp;gt; です。 パラメータ名の先頭は、大文字になっていることに注意してください（.Site.title ではなく .Site.Title が正しい）。 それぞれの設定値が、どのようなプロパティ名で参照できるようになっているかは、下記の Site 変数の一覧を見るとわかります。
Site Variables｜Hugo パラメータが設定されているかどうかで処理を分岐させたい場合は、例えば次のように記述しておけばよいでしょう。 ここでは、googleAnalytics というパラメータで、Google Analytics 用のトラッキング ID が設定されているかどうかをチェックしています。
{{ with $.Site.GoogleAnalytics }} Google Analytics のトラッキング ID は &amp;lt;b&amp;gt;{{ .</description></item><item><title>Hugo サーバーで記事の変更内容が反映されない場合</title><link>https://maku77.github.io/p/taxh3m7/</link><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/taxh3m7/</guid><description>Hugo サーバーを立ち上げて記事の更新をしていると、Web ブラウザをリロードしても変更内容が反映されないことがあります（特に layouts や partials など、共有して使う部分など）。
ページのビルドに成功しているのに変更内容が反映されない場合は、Hugo サーバーのキャッシュを疑ってみるとよいかもしれません。 hugo server コマンドを実行するときに、--ignoreCache オプションをつけると、キャッシュを使わずにレンダリングされます。
$ hugo server --ignoreCache</description></item><item><title>Hugo で最近更新された記事（新着記事）のリストを表示する</title><link>https://maku77.github.io/p/pocxi4n/</link><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pocxi4n/</guid><description>新しく作成した記事を列挙する 下記のテンプレートコードは、日付（フロントマターの date フィールドの値）の新しい順に、 5 件分のリンクを表示します。
作成日 (date) 順に 5 件のリンクを表示する &amp;lt;h2&amp;gt;新着記事&amp;lt;/h2&amp;gt; &amp;lt;ul&amp;gt; {{ range first 5 .Site.RegularPages.ByDate.Reverse }} &amp;lt;li&amp;gt; &amp;lt;b&amp;gt;&amp;lt;a href=&amp;#34;{{.RelPermalink}}&amp;#34;&amp;gt;{{.Title}}&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt; &amp;lt;time&amp;gt;{{.Date.Format &amp;#34;2006-01-02&amp;#34;}}&amp;lt;/time&amp;gt; &amp;lt;/li&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; .Site.RegularPages.ByDate.Reverse という部分で、サイト内の全ページを日付の逆順に列挙することを示しています（インデックス系のページも列挙したい場合は .RegularPages の部分を .Pages に変更してください）。 first 5 は、その中の最初の 5 件を取り出すという命令です。
.Date.Format による日時フォーマットの指定方法は、こちらの Go 言語の記事 を参考にしてください。
更新日 (lastmod) の新しい順に列挙する date ではなく lastmod を使う 上記の例では、記事の作成日（date フィールド）を基準にして最新記事を列挙しましたが、更新日時（lastmod フィールド）を基準に最新記事を列挙することもできます。
次のようにコードを置き換えるだけで OK です。
.Date → .Lastmod .ByDate → .ByLastmod 最終更新日 (lastmod) 順に 5 件のリンクを表示する &amp;lt;h2&amp;gt;最近更新された記事&amp;lt;/h2&amp;gt; &amp;lt;ul&amp;gt; {{ range first 5 .</description></item><item><title>Hugo で次のページ、前のページへのリンクを表示する</title><link>https://maku77.github.io/p/sc9t737/</link><pubDate>Sun, 22 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sc9t737/</guid><description>ページ変数の .NextInSection や .PrevInSection を使用すると、同じセクション内の次のページ、前のページを参照することができます。
同じ階層にある「前のページ」「次のページ」へのリンクを表示する 下記のテンプレートコードは、前のページへのリンクと、次のページへのリンクを表示するシンプルな例です。
テンプレートコード（抜粋） {{ with .PrevInSection }} &amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .LinkTitle }}&amp;lt;/a&amp;gt; {{ end }} {{ with .NextInSection }} &amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .LinkTitle }}&amp;lt;/a&amp;gt; {{ end }} Page 変数の .PrevInSection や .NextInSection には、同じセクション内にある通常ページ (regular page) の内、前のエントリと次のエントリにあたるページ が格納されています。 これらの変数は、通常ページ (regular page) でしか有効でないことに注意してください（つまり、シングルページレイアウトで使用します）。 セクションページなどで参照すると、nil が返されます。
☝️ .Title ではなく .LinkTitle を出力する リンクのタイトルをなるべく短く表示するため、.Title ではなく .LinkTitle を参照していることに注意してください。 こうしておくと、ページのフロントマターで linkTitle プロパティが設定されている場合に、title プロパティよりも優先的に参照されるようになります。 体裁を整えるのであれば、前のページへのリンクは左寄せ、次のページへのリンクは右寄せで表示するとよいでしょう。 表示イメージとしては次のような感じです。
≪前のページへ 次のページへ≫ さらに、コードは prev-next パーシャルテンプレートとして、使い回しがきくようにしておきましょう。 下記は完成版のパーシャルテンプレートです。</description></item><item><title>Hugo で全ページから参照できるデータを用意する（data ディレクトリ）</title><link>https://maku77.github.io/p/5ru4kte/</link><pubDate>Sun, 08 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5ru4kte/</guid><description>Hugo プロジェクトの data ディレクトリに YAML、JSON、TOML、CSV などの形式でデータファイルを作成しておくと、すべてのページから自由に参照できるようになります。
データファイルを作成する data ディレクトリに置くデータファイルは、下記のいずれかのフォーマットで作成します。
YAML フォーマット JSON フォーマット TOML フォーマット CSV フォーマット ここでは英単語の辞書データを YAML 形式のファイル data/words.yaml として作成してみましょう（拡張子は .yaml でも .yml でも構いません）。 data ディレクトリは、サイトのルートディレクトリに作成します（content ディレクトリや layouts ディレクトリと同じ階層に data ディレクトリを置きます）。
data/words.yaml - en: apple jp: りんご - en: banana jp: バナナ - en: grape jp: ぶどう ☝️ ワンポイント Hugo 0.37 より前のバージョンには YAML 処理の不具合があり、上記のようにルートレベルに配列データを記述することができませんでした。 hugo version コマンドでバージョンを確認し、必要があれば 最新の Hugo に更新 しましょう。 あるいは、JSON ファイルとして作成するのであればこんな感じです。
data/words.json [ { &amp;#34;en&amp;#34; : &amp;#34;apple&amp;#34;, &amp;#34;jp&amp;#34; : &amp;#34;りんご&amp;#34; }, { &amp;#34;en&amp;#34; : &amp;#34;banana&amp;#34;, &amp;#34;jp&amp;#34; : &amp;#34;バナナ&amp;#34; }, { &amp;#34;en&amp;#34; : &amp;#34;grape&amp;#34;, &amp;#34;jp&amp;#34; : &amp;#34;ぶどう&amp;#34; } ] できれば、よりシンプルに記述できる YAML 形式を使いたいですね。</description></item><item><title>Hugo のローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する</title><link>https://maku77.github.io/p/jbr6kzd/</link><pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jbr6kzd/</guid><description>自分の作業用備忘録としてはメモとして残したいけれど、インターネット上には公開したくない内容に関しては、Hugo をローカルサーバーとして動作させているときだけ出力するようなショートコードを作成しておくと便利です。
private ショートコードを作成する そのショートコードが、Hugo のローカルサーバ上 (hugo server) で使用されたかを判別するには、Site 変数の .Site.IsServer を参照します。
layouts/shortcodes/private.html {{ if .Site.IsServer }} ローカルサーバで動作しています。 {{ end }} あとは、.Inner 変数で、渡されたテキストを参照することができるので、たとえば次のように実装すればよいでしょう。
layouts/shortcodes/private.html {{ if .Site.IsServer }} &amp;lt;div class=&amp;#34;private&amp;#34;&amp;gt;{{ .Inner }}&amp;lt;/div&amp;gt; {{ end }} ここでは、出力する div 要素に private というクラスを割り当てています。 下記は private クラスに適用するスタイルシートの例です（赤系の色で強調表示するようにしています）。
.private { background: #fee; color: #f11; padding: 0.5em; border: solid 1px #f11; } .private::before { content: &amp;#34;Private メモ&amp;#34;; display: block; font-weight: bolder; } 使用方法 作成した private ショートコードは、記事ファイルの中で次のように利用します。</description></item><item><title>Hugo でサイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示）</title><link>https://maku77.github.io/p/7o7ymst/</link><pubDate>Tue, 23 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7o7ymst/</guid><description>サイドバーメニューに、サイトの階層構造に応じたリンクを表示しておくと、サイト内の様々なページに簡単に移動できるようになります。
サイドバーでのページツリー表示のイメージ サイト全体のページ一覧をツリー構造で表示する方法は、下記のページで紹介しています。
サイト内の全ページの一覧をセクションの階層構造に従って表示する しかし、上記のページで説明している方法でツリー表示すると、すべてのページが展開された状態で表示されてしまうため、サイドバーに表示するツリーとしてはちょっと情報量が多すぎます。 ここでは、もう少しコンパクトに表示されるように、現在のページの上位ノードだけを展開したツリーを表示するようにしてみます。
イメージとしては次のような感じで、表示中のページ（ここでは page1）の上位のセクションだけを展開したツリーを表示することを考えます。
- sec1/ - sec2/ - sec2-1/ - sec2-2/ - page1 （表示中のページ） - page2 - sec2-2-1/ - sec2-2-2/ - sec2-3/ - sec3/ - sec4/ このようなツリーをサイドバーなどに表示しておくことで、ユーザが今、サイト全体でどの位置の記事を読んでいるかを簡単に把握できるようになります（パンくずリストなども同様の効果がありますが、ツリー表示の方が、より全体を把握しやすいといえます）。
展開すべきノードを知る 自分自身のページが所属するセクションだけを展開したツリーを表示するには、テンプレートコード内で、セクションの親子関係を（先祖まで含めて）把握する必要があります。 そのために、Page オブジェクトの以下のようなメソッドを利用することができます（参考: Hugo - Section Variables and Methods）。 Hugo 本家のマニュアルページでは、.InSection や .IsAncestor、.IsDescendant メソッドは、Section 変数 の Methods として記述されていますが、通常ページを含む Page オブジェクトのメソッドとして参照することができます。
$p1.InSection $p2 $p1 と $p2 が同一のセクションに所属していれば true（$p1 = $p2 の場合も true）。 それ以外は false。
(Whether the given page is in the current section.</description></item><item><title>Hugo で各種ページの .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧</title><link>https://maku77.github.io/p/co8p6n4/</link><pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/co8p6n4/</guid><description>Hugo のテンプレートで、ページの種類によって条件分岐するコードを記述するには、レンダリング時のコンテキストにおいて、.Kind の値や .IsPage などの値がどう変化するかを知っておく必要があります。
ページ種類 .RelPermalink の例 .Section .Type .Kind .IsHome .IsNode .IsPage .IsSection ホームページ / nil page home true true false false セクションページ（第 1 階層） /sec1/ sec1 sec1 section false true false true セクションページ（第 2 階層） /sec1/sec2/ sec1 sec1 section false true false true タクソノミーターム /tags/ tags tags taxonomy ※ false true false false タクソノミーリスト /tags/xxx/ tags tags term ※ false true false false 404 ページ nil nil page 404 false true false false 記事ページ（第 1 階層） /mypage/ nil page page false false true false 記事ページ（第 2 階層） /sec1/mypage/ sec1 sec1 page false false true false 記事ページ（第 3 階層） /sec1/sec2/mypage/ sec1 sec1 page false false true false ☝️ ※ taxonomy と term という名前 Hugo v0.</description></item><item><title>Hugo のベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html)</title><link>https://maku77.github.io/p/bbxj5pa/</link><pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bbxj5pa/</guid><description>ベーステンプレートの仕組み Hugo のベーステンプレート機能を利用すると、各種テンプレートの親テンプレートのようなものを作成することができます。 ベーステンプレートを作成することで、すべてのページの HTML 構成を統一することができ、個々のテンプレートの見通しもよくなります。
Hugo では、リストテンプレートやシングルページテンプレートなど、用途によって別々のテンプレートファイルを用意することになっています。 でも、HTML 全体の大まかな構成は共通した部分が多いはずです。 例えば、どのページでも HTML は次のような構成になっているはずです。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja&amp;#34;&amp;gt; &amp;lt;html&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; ... &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; ... &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Hugo のベーステンプレート機能を使用すると、上記のような全体の構成をベーステンプレート (baseof.html) として作成し、その中の部分的なブロックだけを通常のテンプレート（リストテンプレートやシングルページテンプレート）で定義した内容で置き換えるということができます。
図: ベーステンプレートの仕組み Hugo のベーステンプレート機能は、Go のテンプレートライブラリの block template という仕組みを使用しており、block で定義した部分を、define で定義した内容で置き換えるという動作をします。 上の図を見ると分かりやすいと思いますが、ベーステンプレート (baseof.html) を用意すると、基本的にすべてのページがベーステンプレートを利用してレンダリングされるようになり、その中の部分的なブロック（上記では main という名前のブロック）が子テンプレートで定義した内容で置き換えられます。 このとき、どの子テンプレートが使用されるかは、ベーステンプレートの仕組みを使用しない場合と同様で、表示するページの種類によって決まります。 例えば、ホームページやセクションページなどのレンダリングには list.html が使用され、個々の記事ページのレンダリングには single.html が使用されます。
具体的なベーステンプレートの利用例 下記はベーステンプレートの具体的な記述例です。 main 要素以下のメインコンテンツを block template の機能で置き換えるようにしています。
layouts/_default/baseof.html（ベーステンプレート） &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;{{ .Site.LanguageCode }}&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.</description></item><item><title>Hugo でサイト内の全ページの一覧をセクションの階層構造に従って表示する</title><link>https://maku77.github.io/p/xuwd7tn/</link><pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xuwd7tn/</guid><description>現在の階層のページ一覧を出力するテンプレートを再帰的に呼び出すようにすると、サイト内の全てのセクションとページを、ツリー構造で表示することができます。 すべてのページのリンクが出力されるので、サイトマップの出力に使用したり、ホームページ用のテンプレートに利用するとよいでしょう。
ツリー出力の基本 下記は、サイト内のすべてのページをツリー形式で表示するサンプルテンプレートです。 セクション変数の .Pages を参照すると、そのセクションに含まれるサブセクションや通常ページを取得することができるので、それを range でループ処理しています。 部分テンプレート hierarchy を定義し、これをホームページ (.Site.Home) から再帰的に呼び出すことで全ページのツリー構造を出力しています。
layouts/index.html（抜粋） &amp;lt;h2&amp;gt;全ページのリスト&amp;lt;/h2&amp;gt; {{- define &amp;#34;hierarchy&amp;#34; }} &amp;lt;ul&amp;gt; {{- range .Pages }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{- if .IsSection }}{{ template &amp;#34;hierarchy&amp;#34; . }}{{ end }} {{- end }} &amp;lt;/ul&amp;gt; {{- end }} {{ template &amp;#34;hierarchy&amp;#34; .Site.Home }} 出力結果のイメージ（実際には各項目がリンクになります） * タイトル A * セクション 1 * セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * タイトル B * タイトル C * セクション 2 * セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B ここでは、hierarchy のパラメータとして .</description></item><item><title>Hugo でパンくずリストを表示する</title><link>https://maku77.github.io/p/vemn3c4/</link><pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vemn3c4/</guid><description>パンくずリストは、親ページに素早くジャンプするための次のようなリンクです。
ホーム &amp;gt; セクション1 &amp;gt; セクション2 &amp;gt; ページタイトル ここでは、Hugo のテンプレート機能を使って、パンくずリストを出力する方法を説明します。
パンくずリストを表示するためのテンプレート 下記は、パンくずリストを出力するための breadcrumb テンプレートの定義です（Hugo 本家で紹介されているコードを参考にしています）。
{{- define &amp;#34;breadcrumb&amp;#34; }} {{- if .node.Parent }} {{- template &amp;#34;breadcrumb&amp;#34; (dict &amp;#34;node&amp;#34; .node.Parent &amp;#34;start&amp;#34; .start) }} {{- else if not .node.IsHome }} {{- template &amp;#34;breadcrumb&amp;#34; (dict &amp;#34;node&amp;#34; .node.Site.Home &amp;#34;start&amp;#34; .start) }} {{- end }} {{- if eq .node .start }} &amp;lt;li&amp;gt;{{ .node.LinkTitle }} {{- else }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .node.Permalink }}&amp;#34;&amp;gt;{{ .node.LinkTitle }}&amp;lt;/a&amp;gt; {{- end }} {{- end }} 実際にパンくずリストを出力したい部分で下記のように呼び出します。</description></item><item><title>Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき）</title><link>https://maku77.github.io/p/pkww45p/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pkww45p/</guid><description>Hugo のテンプレートファイル内で define を使用すると、部分的なテンプレートを定義することができ、別の場所から関数のように呼び出すことができます。
define による部分テンプレート定義の基本 Hugo のテンプレート定義は、基本は layouts ディレクトリ内に置いたテンプレートファイル（HTML ファイル）単位で行うのですが、そのテンプレートファイルの中で、define アクションを使用することで、入れ子でテンプレート定義を行うことができます。 テンプレートファイル内で使える関数定義のようなもの だと思うと分かりやすいです。
次の例では、define を使用して、showParentSection というテンプレートを定義しています。
showParentSection テンプレートを定義する {{/* セクションの一覧を出力します */}} {{ define &amp;#34;showParentSection&amp;#34; }} &amp;lt;h2&amp;gt;セクション一覧&amp;lt;/h2&amp;gt; &amp;lt;ul&amp;gt; {{- range .Site.Sections }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{- end }} &amp;lt;/ul&amp;gt; {{ end }} define で定義したテンプレートを呼び出すには、template 関数を使用します。
{{ template &amp;#34;showParentSection&amp;#34; . }} 2 番目のパラメータで渡した値が、部分テンプレート側のドットコンテキスト (.) として参照できるようになります。 多くの場合は、上記のようにドット (.) を指定し、Page オブジェクトを参照できるようにします。
複数のパラメータを受け取る部分テンプレートを定義する template 関数を使って部分テンプレートを呼び出すときは、引数に . を指定して Page オブジェクトを渡すことが多いのですが、単純な文字列や数値をパラメータとして渡すこともできます。 次の例では、パラメータで渡された名前を使って挨拶文を出力する greet テンプレートを定義しています。</description></item><item><title>Hugo で記事ページに付けられたターム一覧（タグ一覧）を表示する</title><link>https://maku77.github.io/p/topd7uy/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/topd7uy/</guid><description>シングルページテンプレートにおいて、その記事ページに付けられたタグの一覧を表示するようにしておくと、関連する記事（同じタグの付けられた記事）を探しやすくなります。
タクソノミーターム（タグやカテゴリ）は、各ページの front matter 部分で定義するので、ページ変数 (.Params) 経由でその情報を取得することができます。 次のパーシャルテンプレートは、記事ページに付けられたタグの情報を取得し、リスト形式で出力します。
layouts/partials/tags-in-page.html &amp;lt;ul class=&amp;#34;tags&amp;#34;&amp;gt; {{- range .Params.tags -}} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ &amp;#34;/tags/&amp;#34; | relLangURL }}{{ . | urlize }}&amp;#34;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; {{- end -}} &amp;lt;/ul&amp;gt; タグが設定されていない場合に、先頭の ul 要素ごと出力しないようにするには、ちょっとだけ変えて下記のようにします。
{{ with .Params.tags }} &amp;lt;ul class=&amp;#34;tags&amp;#34;&amp;gt; {{- range . -}} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ &amp;#34;/tags/&amp;#34; | relLangURL }}{{ . | urlize }}&amp;#34;&amp;gt;{{ . }}&amp;lt;/a&amp;gt; {{- end -}} &amp;lt;/ul&amp;gt; {{ end }} 上記のパーシャルテンプレートを使用するときは、シングルページテンプレート内で次のように記述します。
layouts/_default/single.html {{ partial &amp;#34;tags-in-page&amp;#34; . }} デフォルトでは、li 要素は単純な箇条書きのリスト形式で表示されてしまいます。 次のようなスタイルを定義しておくと、それっぽく横並びで表示されてよい感じになります。</description></item><item><title>Hugo で記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする</title><link>https://maku77.github.io/p/5v7o2xp/</link><pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5v7o2xp/</guid><description>Hugo の仕組みでは、1 つのタクソノミーに割り当てられるタームの数を制限することはできません。 ここでは、複数のタームを割り当ててしまった場合に、エラー表示を行う方法を紹介します。
１つの記事ページに複数のタグを付けるのはよくあることですが、Web サイトのポリシーによっては、1 つの記事に付けられるカテゴリーは 1 つまでに制限したい、ということがあるかもしれません。 Hugo のデフォルトの仕組みでは、そのような制限はできないのですが、複数のカテゴリが付けられた記事を表示したときに、ログとページ上にメッセージを表示することはできます。
下記のシングルページテンプレートでは、categories タクソノミーに 2 つ以上の値（ターム）が設定されている場合に警告メッセージを出力しています。 errorf 関数を使ってテキスト出力を行うことで、画面上への出力と同時に、コンソール上にもエラーメッセージを出力することができます。
layouts/_default/single.html（抜粋） {{ if .Params.categories }} {{ if gt (len .Params.categories) 1 }} &amp;lt;b&amp;gt;{{ errorf &amp;#34;カテゴリが 1 つ以上設定されています！&amp;#34; }}&amp;lt;/b&amp;gt; {{ end }} {{ end }} ☝️ ワンポイント len .Params.categories を実行するときに、.Params.categories が存在しないと nil dereference のエラーが発生してしまいます。 そのため、最初に if .Params.categories という存在チェックを入れています。 例えば、記事ページの先頭のフロントマターで、下記のように複数のカテゴリを割り当てるような記述をすると、上記の警告メッセージが表示されます。
content/sample-page.md --- title: &amp;#34;サンプルページ&amp;#34; categories: [&amp;#34;カテゴリ1&amp;#34;, &amp;#34;カテゴリ2&amp;#34;] --- サンプルページの本文。</description></item><item><title>Hugo でサイト全体のターム一覧（タグ一覧）を表示する</title><link>https://maku77.github.io/p/tfk4tdg/</link><pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tfk4tdg/</guid><description>Web サイトのサイドバーなどに、タクソノミータームの一覧（つまりタグの一覧、タグクラウドなど）を表示しておくと、同じ系統の記事に素早くアクセスできて便利です。 ここでは、タクソノミーとして Hugo デフォルトの tags と categories が定義されていることを前提とします。
特定のタクソノミーのターム一覧を表示（タグの一覧を表示する） ここでは、tags タクソノミーに含まれているターム一覧を表示する例を示します（つまりタグの一覧です）。 多くのサイトでは、使用するタクソノミーの数は限られている（デフォルトの tags や categories で間に合うことが多い）ので、この使い方が一番多いかもしれません。
テンプレートの実装 &amp;lt;h3&amp;gt;タグ一覧&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; {{- range $termName, $entries := .Site.Taxonomies.tags }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ &amp;#34;/tags/&amp;#34; | relLangURL }}{{ $termName | urlize }}&amp;#34;&amp;gt;{{ $termName }}&amp;lt;/a&amp;gt; ({{ $entries.Count }}) {{- end }} &amp;lt;/ul&amp;gt; 出力結果 &amp;lt;h3&amp;gt;タグ一覧&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;/tags/%E3%82%BF%E3%82%B01&amp;#34;&amp;gt;タグ1&amp;lt;/a&amp;gt; (5) &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;/tags/%E3%82%BF%E3%82%B02&amp;#34;&amp;gt;タグ2&amp;lt;/a&amp;gt; (10) &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;/tags/%E3%82%BF%E3%82%B03&amp;#34;&amp;gt;タグ3&amp;lt;/a&amp;gt; (15) &amp;lt;/ul&amp;gt; 各リンクの後ろには、そのタグを含むページの数を表示しています。
ページ数の多い順に列挙するには次のようにします。
テンプレートの実装 &amp;lt;h3&amp;gt;タグ一覧&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; {{- range .Site.Taxonomies.tags.ByCount }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ &amp;#34;/tags/&amp;#34; | relLangURL }}{{ .</description></item><item><title>Hugo でタクソノミー関連のテンプレートを定義する</title><link>https://maku77.github.io/p/aqchnnq/</link><pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/aqchnnq/</guid><description>あるタクソノミーに所属するタームの一覧（例えばタグの一覧）などを表示するページは Hugo によって自動的に生成されます。 ただし、そのためのレイアウト（テンプレート）ファイルをあらかじめ作成しておく必要があります。
タクソノミー関連の２種類のテンプレート タクソノミー関連のテンプレートには、大きく分けて下記の２種類があります。
タクソノミー・ターム・テンプレート (Taxonomy Terms Template) あるタクソノミーに含まれているタームの一覧を表示するためのレイアウトです。 https://example.com/tags/ といった URL にアクセスしたときに使用されます。 タクソノミー・リスト・テンプレート (Taxonomy List Template) あるタームが付加されているページの一覧を表示するためのレイアウトです。 https://example.com/tags/mytag/ といった URL にアクセスしたときに使用されます。 以下、それぞれのテンプレートをどのように作成するかを説明していきます。
タクソノミー・ターム・テンプレートを作成する タクソノミー・ターム・テンプレートは、あるタクソノミーに所属するタームの一覧 を表示するときに使用されるテンプレートです。 例えば、tags というタクソノミーが定義されている時、このテンプレートによって https://example.com/tags/ という URL でアクセスできるタグ一覧ページが生成されます。
下記のテンプレートファイルのうち、最初に見つかったファイルがタクソノミー・ターム・テンプレートとして使用されます。
/layouts/taxonomy/&amp;lt;単数系のタクソノミー名&amp;gt;.terms.html /layouts/_default/terms.html /themes/&amp;lt;テーマ名&amp;gt;/layouts/taxonomy/&amp;lt;単数系のタクソノミー名&amp;gt;.terms.html /themes/&amp;lt;テーマ名&amp;gt;/layouts/_default/terms.html 全てのタクソノミーで共通のレイアウトを使用するのであれば、まずは layouts/_default/terms.html を作成しておけばよいでしょう。
下記のサンプルテンプレートは、対象のタクソノミーに所属するタームの一覧を表示します。
layouts/_default/terms.html（抜粋） &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; {{- $plural := .Data.Plural }} {{- range $index, $term := .Data.Terms.Alphabetical }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ $.Site.LanguagePrefix }}/{{ $plural }}/{{ $term.Name | urlize }}&amp;#34;&amp;gt;{{ $term.</description></item><item><title>Hugo のタクソノミー機能の基本（タグやカテゴリなど）</title><link>https://maku77.github.io/p/mtfmaxr/</link><pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mtfmaxr/</guid><description>タクソノミーとターム Hugo では、多くのブログツールや CMS ツールと同様に、各ページに「タグ」や「カテゴリ」といった付加情報を付けてグルーピング（分類）することができます。 このグルーピング（分類）のことを タクソノミー (taxonomy) と呼んでいます。
タクソノミー (taxonomy) グルーピング（分類）のための項目名。 例えば、「タグ」や「カテゴリ」といった分類名自体がタクソノミーです。 Hugo は、デフォルトで tags と categories というタクソノミーが定義しています。 ターム (term) タクソノミーに割り当てる具体的な値。 例えば、あるページのタグとして、「経済」と「日本」という値を割り当てたとすると、「経済」と「日本」のことをタームと呼びます。 タグの一覧ページで表示される個々のタグ名がタームです。 コンテンツ（ページ）にタクソノミー・タームを割り当てる コンテンツにタクソノミーを割り当てるには、記事先頭のフロントマター部分に、タクソノミー名とそこに割り当てるターム配列を記述します。 次の例では、tags: と categories: というところでタクソノミーの設定を行なっています。
content/page.md --- title: &amp;#34;記事のタイトル&amp;#34; date: &amp;#34;2017-12-31&amp;#34; tags: [&amp;#34;タグ1&amp;#34;, &amp;#34;タグ2&amp;#34;] categories: [&amp;#34;カテゴリ1&amp;#34;, &amp;#34;カテゴリ2&amp;#34;] --- この記事では、`tags` タクソノミーとして「タグ1」「タグ2」というターム、 `categories` タクソノミーとして「カテゴリ1」「カテゴリ2」というタームを割り当てています。 Hugo のデフォルトのタクソノミーとして、tags と categories が用意されています。 上記ではそれぞれのタクソノミーに タグ1 や カテゴリ1 といったタームを設定しています。
それぞれのタクソノミーの使い方は自由ですが、 どのタクソノミーにも複数のタームを割り当てることができます。 逆に、「1 つのカテゴリには 1 つのページしか所属できない」という設定はできません。 そのような場合は、単純にフロントマターで categories に割り当てるタームを 1 つだけにする、といった運用でカバーします（それよりは、セクションの機能（ディレクトリ階層）で分けた方がよいですね）。 参考までに、1 つのページに複数のカテゴリを割り当ててしまった場合にエラー表示する方法を こちらで紹介しています。</description></item><item><title>Hugo でセクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages)</title><link>https://maku77.github.io/p/4sxmnfi/</link><pubDate>Sat, 30 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4sxmnfi/</guid><description>Home ページ直下の記事ページ ＝ セクションを持たないページ ホームページを示す Page オブジェクトの RegularPages プロパティを参照すると、content ディレクトリ直下に置かれた通常ページの一覧 を取得することができます。 つまり、どのセクションにも所属していない記事ページの一覧です。
&amp;lt;h3&amp;gt;セクションを持たない記事ページ一覧（タイトル順）&amp;lt;/h3&amp;gt; &amp;lt;ol&amp;gt; {{ range .Site.Home.RegularPages.ByTitle }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{ end }} &amp;lt;/ol&amp;gt; さらに first 関数を組み合わせて使用すれば、最初の 5 件のみに絞り込んで表示することができます。
&amp;lt;h2&amp;gt;セクションを持たない記事ページ一覧（最初の５件）&amp;lt;/h2&amp;gt; &amp;lt;ol&amp;gt; {{ range first 5 .Site.Home.RegularPages.ByTitle }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{ end }} &amp;lt;/ol&amp;gt; （コラム）Hugo v0.58.0 より前のバージョンでのやり方 Hugo v0.58.0 より前のバージョンでは、ホームページの Page オブジェクトの .RegularPages が、サイト全体の記事ページを返してしまっていたので、別の方法でセクションに所属していない記事ページを取得する必要がありました。 例えば、$.Site.RegularPages で取得したサイト内の記事ページの一覧（Page 配列）を、where 関数を使ってフィルタすることで、目的の記事ページだけに絞り込んでいました。
&amp;lt;h3&amp;gt;セクションを持たない記事ページ一覧（タイトル順）&amp;lt;/h3&amp;gt; &amp;lt;ol&amp;gt; {{ range (where $.</description></item><item><title>Hugo でサイトのヘッダーとフッターをパーシャルファイルに分離する</title><link>https://maku77.github.io/p/wvi3n7q/</link><pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wvi3n7q/</guid><description>パーシャルテンプレートでページ構成を分割する サイト内で共通のヘッダー部分とフッター部分を Hugo の パーシャルテンプレートファイル として作成しておくと、全てのテンプレートから参照できるため、テンプレートの記述をシンプルにすることができます。 Hugo のテンプレート構成では、下記のような感じでテンプレート前半部分と後半部分をまるごとパーシャルファイルで構成してしまうのが一般的のようです。
図: ヘッダーとフッターをパーシャルテンプレート化 上記ではリストテンプレート (list.html) の例を示していますが、ホームページテンプレート (layouts/index.html) や、セクションテンプレート (layouts/_default/section.html)、シングルページテンプレート (layouts/_default/single.html) などを記述する際も同様に構成します。 つまり、パーシャルファイルとして作成する header.html や footer.html は、どのテンプレートファイルからでも使用できるように、汎用的な記述をしておく必要があります。
layouts/partials/header.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;{{ .Site.LanguageCode }}&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width,initial-scale=1.0&amp;#34;&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/assets/css/main.css&amp;#34;&amp;gt; &amp;lt;title&amp;gt;{{ if not .IsHome }}{{ .Title }} | {{ end }}{{ .Site.Title }}&amp;lt;/title&amp;gt; {{ partial &amp;#34;header-favicon&amp;#34; . }} &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; layouts/partials/footer.html &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 上記のようなパーシャルテンプレートは、各レイアウト用のテンプレートから次のように使用します。
layouts/_default/list.html {{ partial &amp;#34;header&amp;#34; . }} &amp;lt;main id=&amp;#34;main&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{ .</description></item><item><title>Hugo でサイト内の全セクションの一覧を表示する (.Site.Sections)</title><link>https://maku77.github.io/p/vczuozw/</link><pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vczuozw/</guid><description>.Site.Sections を参照すると、サイト内のすべてのセクションページを示す Page 配列を取得することができます。
layouts/index.html &amp;lt;h3&amp;gt;全セクションのリスト&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; {{ range .Site.Sections }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; ここで参照できるセクションページは、第一階層に存在するセクションのみであることに注意してください。 下のようなコンテンツ構造だとすると、.Site.Sections に含まれるのは、★のついたセクションページのみです。
content/ +-- dir1/_index.md ★ | +-- dir1-1/_index.md | +-- dir1-2/_index.md +-- dir2/_index.md ★ +-- dir2-1/_index.md +-- dir2-2/_index.md</description></item><item><title>Hugo でサイト内の全ページの一覧を表示する (.Site.Pages)</title><link>https://maku77.github.io/p/sgrjpfu/</link><pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sgrjpfu/</guid><description>.Site.Pages を参照すると、サイト内のすべてのページを示す Page 配列を取得することができます。 下記はホームページテンプレート内で、サイト内のすべてのページのリンクを表示する例です。
layouts/index.html &amp;lt;h3&amp;gt;全ページのリスト&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; {{ range .Site.Pages }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; .Site.Pages はデフォルトで、日時 (.Date) の一番新しいものから昇順に並べられた Page 配列を返します。
☝️ ワンポイント .Site.Pages は、現在選択中の言語内でのページ一覧を返します。 全言語を含むページ一覧を取得したいときは、代わりに .Site.AllPages を参照してください。</description></item><item><title>Hugo でホームページの Page オブジェクトを取得する</title><link>https://maku77.github.io/p/ffr2bku/</link><pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ffr2bku/</guid><description>Hugo テンプレートの中で、ホームページを表す Page オブジェクトを取得するには次のようにします。
{{ $home := .Site.Home }} {{ printf &amp;#34;%#v&amp;#34; $home }} 公式ドキュメントの .Site 変数のページには書いてないのですが、上記のように簡単にホームページの Page オブジェクトを取得できるみたいです。 2 行目では、取得した Page オブジェクトの内容を出力して確認しています。
GetPage 関数を使用して、Kind パラメータに &amp;quot;home&amp;quot; を指定するというのもありです。
{{ $home := .Site.GetPage &amp;#34;home&amp;#34; }} {{ printf &amp;#34;%v&amp;#34; (eq $home .Site.Home) }} {{/* true になるはず */}} このような取得方法を知るまでは、次のような感じでものすごく面倒な書き方してました。。。
{{ $home := index (where .Site.Pages &amp;#34;URL&amp;#34; &amp;#34;==&amp;#34; &amp;#34;/&amp;#34;) 0 }} まず、where 関数を使い、全ページ (.Site.Pages) 中で URL が / であるものの Page オブジェクトの配列を取得しています。 実際にはホームページは 1 つだけなのですが、where は Page オブジェクトの配列を返すので、index 関数を使って 1 番目の要素だけを取り出しています。 なんて非効率的な（＾＾；</description></item><item><title>Hugo テンプレートで数値によるループ処理を行う (range, seq)</title><link>https://maku77.github.io/p/8vm6xqm/</link><pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8vm6xqm/</guid><description>Hugo のテンプレート内では、Go 言語のような for を使用した数値ループは記述できません。 代わりに range を使用します。
次の例では、seq 関数 を使用して 1 から 5 の数値シーケンスを作成し、それらを range を使ってループ処理しています。
テンプレート内での記述例 &amp;lt;ul&amp;gt; {{ range $val := seq 5 }} &amp;lt;li&amp;gt;{{ $val }} {{ end }} &amp;lt;/ul&amp;gt; 出力結果 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;1 &amp;lt;li&amp;gt;2 &amp;lt;li&amp;gt;3 &amp;lt;li&amp;gt;4 &amp;lt;li&amp;gt;5 &amp;lt;/ul&amp;gt; 戻り値を 2 つの変数で受け取れば、0 始まりのインデックスも同時に得ることができます。
テンプレート内での記述例 &amp;lt;ul&amp;gt; {{ range $index, $val := seq 5 }} &amp;lt;li&amp;gt;{{ $index }} : {{ $val }} {{ end }} &amp;lt;/ul&amp;gt; 出力結果 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;0 : 1 &amp;lt;li&amp;gt;1 : 2 &amp;lt;li&amp;gt;2 : 3 &amp;lt;li&amp;gt;3 : 4 &amp;lt;li&amp;gt;4 : 5 &amp;lt;/ul&amp;gt;</description></item><item><title>Hugo で同一セクション内のページ／セクションの一覧を表示する</title><link>https://maku77.github.io/p/pgub54h/</link><pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pgub54h/</guid><description>そのセクション内のページ一覧を取得する (.Pages、.RegularPages) リストテンプレートやセクションテンプレートの中で、.Pages を参照すると、そのセクション（やタクソノミー）直下の記事ページ (regular page) とセクションページ (list page) の一覧を Page オブジェクトの配列として取得することができます。
layouts/_default/section.html &amp;lt;h3&amp;gt;セクションに含まれる記事ページ（あるいはセクションページ）の一覧&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; {{ range .Pages }} &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; 記事ページ (regular page) のみを列挙したい場合は、.Pages の部分を .RegularPages に変更してください。 逆に、セクションページ (list page) のみを列挙したい場合は、.Pages の部分を Sections に変更してください。
.Pages &amp;hellip; セクションページと記事ページの一覧 .RegularPages &amp;hellip; 記事ページの一覧 .Sections &amp;hellip; セクションページの一覧 上記のようなテンプレートは、タクソノミーテンプレート（タグの一覧ページ）でも同様に使用することができます。
ただし、.Pages や .RegularPages は、リスト系のページから参照することが想定されているため、シングルページテンプレート内で参照すると、サイズ 0 の配列 が返されることに注意してください。 そのため、基本的には上記のコードはリスト系のテンプレートでのみ使用することができます。
シングルページテンプレートからも、同一セクション内のページの一覧を取得したい場合は、まず .CurrentSection でカレントセクションを示す Page オブジェクトを取得するとよいでしょう（下記参照)。
同一セクション内のページ一覧を取得する (.CurrentSection.Pages) 下記のテンプレートコードは、現在の記事ページ（あるいはセクションページ）が所属するセクションの直下のページ（記事ページおよびセクションページ）の一覧を表示します。
例えば、ホームページを含むトップレベルの階層に置いた記事で実行された場合は、第一階層にあるセクションおよび記事ページの一覧が表示されます。 何らかのセクション内の記事で実行された場合は、その記事が所属するセクション内のサブセクションおよび記事ページの一覧が表示されます。</description></item><item><title>Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range)</title><link>https://maku77.github.io/p/yhqogz6/</link><pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yhqogz6/</guid><description>Hugo テンプレート内で辞書変数を定義すると、キーと値のマップ情報を管理することができます。
マップを定義する (dict) dict 関数 のパラメータに、キーと値のペアを並べていくと、マップ変数を作成することができます。 下記の例では、3 つのキー＆値を持つマップを定義して、その内容を出力しています。
テンプレート内でのマップ定義例 {{ $d := dict &amp;#34;key1&amp;#34; 100 &amp;#34;key2&amp;#34; 200 &amp;#34;key3&amp;#34; 300 }} {{ printf &amp;#34;%#v&amp;#34; $d }} 実行結果 map[string]interface {}{&amp;#34;key1&amp;#34;:100, &amp;#34;key2&amp;#34;:200, &amp;#34;key3&amp;#34;:300} ☝️ ワンポイント 関数名が dict なので、「辞書」と訳したほうがよいのかもしれませんが、内部的には Go の map オブジェクトなので、ここでは「マップ」と呼ぶことにします。 Go のテンプレート内で使用できる文法は、Go 言語の文法とは異なっています。 Go 言語でマップを定義する ときは map を使用しますが、Hugo のテンプレート内でマップ（辞書）を定義するときは dict 関数を使用しなければいけないことに注意してください。 マップの要素を参照する (index) マップ変数の後ろに、ドットで繋げてキー名を指定すると、そのキーに対応する要素の値を参照することができます（存在しないキーを指定した場合は何も出力されません）。
テンプレート内での記述例 {{ $d := dict &amp;#34;key1&amp;#34; 100 &amp;#34;key2&amp;#34; 200 &amp;#34;key3&amp;#34; 300 }} &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;{{ $d.key1 }} &amp;lt;li&amp;gt;{{ $d.</description></item><item><title>Hugo テンプレート内で変数を扱う</title><link>https://maku77.github.io/p/y39gzkc/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y39gzkc/</guid><description>Hugo テンプレート内で変数を定義するときは、変数名のプレフィックスとして $ を付けます。
変数定義の基本 Hugo テンプレート内で変数を定義するには、下記のような構文を使用します。 = ではなくて、:= を使用することに注意してください。
{{ $変数名 := 初期値 }} 上記の構文から分かるように、独自の変数を定義する場合は、変数名のプレフィックスとして $ を付けます。
☝️ ワンポイント より正確に言うと、上記のように $ で始まるようにアクションを記述すると、それが変数定義のためのアクションだと見なされるということです。 次の例では、数値変数 $x と、文字列変数 $y を定義し、それらの値を出力しています。 変数定義のアクションを実行しただけでは、その変数の値は出力されないので、変数出力のためのアクションを続けて記述しています（下の例では {{ $x }} や {{ $y }} という部分）。
テンプレート内での記述例 {{ $x := 100 }} &amp;lt;p&amp;gt;{{ $x }}&amp;lt;/p&amp;gt; {{ $y := &amp;#34;Hello&amp;#34; }} &amp;lt;p&amp;gt;{{ $y }}&amp;lt;/p&amp;gt; 出力結果 &amp;lt;p&amp;gt;100&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Hello&amp;lt;/p&amp;gt; 処理結果を変数に格納する ある値をパイプで関数に渡して、処理を行った結果を変数に格納する、といったこともできます。 次の例では、文字列 maku を printf 関数に渡し、その結果をさらに printf 関数に渡しています。 変数 $x には、その最終的な結果が格納されます。
テンプレート内での記述例 {{ $x := &amp;#34;maku&amp;#34; | printf &amp;#34;Hello %s.</description></item><item><title>Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range)</title><link>https://maku77.github.io/p/7bvjywy/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7bvjywy/</guid><description>Hugo テンプレートの中で slice 関数を使用すると、渡されたパラメータ群から新しいスライス（配列）を作成することができます。
配列（スライス）を定義する (slice) Hugo テンプレートでは、新しくスライス（配列）を定義するための構文は用意されていないため、そのような場合はスライス（配列）を戻り値として返す slice 関数 を使用する必要があります。 下記の例では、slice 関数に 3 つのパラメータを渡し、それらの要素からなるスライスを生成しています。
テンプレート内での記述例 {{ $arr := slice &amp;#34;AAA&amp;#34; &amp;#34;BBB&amp;#34; &amp;#34;CCC&amp;#34; }} {{ printf &amp;#34;%#v&amp;#34; $arr }} 実行結果 []interface {}{&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;} ☝️ ワンポイント Go のテンプレート内で使用できる文法は、Go 言語の文法とは異なっています。 スライスを定義するときに、Go 言語と同じ構文で、$arr := []string{&amp;quot;AAA&amp;quot;, &amp;quot;BBB&amp;quot;, &amp;quot;CCC&amp;quot;} と記述することはできないことに注意してください。 配列（スライス）の要素を参照する (index) インデックス番号指定で配列（スライス）内の要素を参照するには、index 関数 を使用します。 この書き方は、慣れるまでは若干わかりにくいかもしれません。
テンプレート内での記述例 {{ $arr := slice &amp;#34;AAA&amp;#34; &amp;#34;BBB&amp;#34; &amp;#34;CCC&amp;#34; }} &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;{{ index $arr 0 }} &amp;lt;li&amp;gt;{{ index $arr 1 }} &amp;lt;li&amp;gt;{{ index $arr 2 }} &amp;lt;/ul&amp;gt; 実行結果 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;AAA &amp;lt;li&amp;gt;BBB &amp;lt;li&amp;gt;CCC &amp;lt;/ul&amp;gt; 配列（スライス）をループで処理する (range) 配列の全要素をループで処理したい場合は、range を使って以下のように記述します。</description></item><item><title>Hugo テンプレート内にコメントを記述する</title><link>https://maku77.github.io/p/5zwytgx/</link><pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5zwytgx/</guid><description>Hugo のテンプレートファイル内では、C/C++ や Java に似た形式（/* と */）でコメントを記述することができます。 コメントとして記述した部分は、HTML ファイルに出力するときに削除されます。
{{/* a comment */}} 複数行にまたがるコメントを記述することもできます。
{{/* comment comment comment */}}</description></item><item><title>Hugo テンプレート内で if や with で分岐処理する</title><link>https://maku77.github.io/p/ewoqwrk/</link><pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ewoqwrk/</guid><description>Hugo テンプレートの中で、if アクションや with アクションを使用することで、分岐処理を行うことができます。
if による分岐処理 if の構文 Hugo のテンプレート内で分岐処理を行うには、下記のように if ~ end を使用します。 必要に応じて、else や else if を挟むことができます。
{{ if ● }} ... {{ end }} {{ if ● }} ... {{ else }} ... {{ end }} {{ if ● }} ... {{ else if ▲ }} ... {{ end }} {{ if ● }} ... {{ else if ▲ }} ... {{ else }} ... {{ end }} {{ と }} で囲まれた部分は、Go のテンプレートでは アクション と呼ばれている部分で、基本的に 1 つのアクションだけを記述することができます（関数をパイプで結んだりすることはできる）。 if による条件式を記述する部分と、end でブロックを閉じる部分は、上記のように分けて記述する必要があるため、若干まわりくどくなってしまうケースがあるかもしれませんが、そこは我慢するしかありません。</description></item><item><title>Hugo でセクションの階層構造を取得する (.CurrentSection、.Parent、.Sections)</title><link>https://maku77.github.io/p/8vrj4ui/</link><pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8vrj4ui/</guid><description>Hugo のテンプレートファイル内から参照できる .Parent や .Sections といった Page 変数を参照すると、親セクションの情報や、子セクションの情報を取得することができます。 セクション系の情報を取得するための Page 変数 には下記のようなものがあります。
.CurrentSection 自分自身が所属するセクションの情報。自分自身がセクションページであったり、ホームページである場合は、自分自身のページの情報。型は Page オブジェクト。通常の記事ページ、ホームページ、セクションページ以外では nil になります（例えば、タクソノミーリストのページでは nil になります）。 .Parent 自分自身がセクションページの場合、親セクションの情報。自分自身が通常ページの場合、自分が所属するセクションの情報。型は Page オブジェクト。 .Sections 自分自身のセクションが含む子セクションの配列（ホームページテンプレート、あるいは、セクションテンプレートのみで意味を持つ）。型は Page オブジェクトの配列。 レイアウトファイル内で、これらのセクション情報を参照することで、階層構造に応じたナビゲーション用リンクを自動で生成 したりすることができるようになります。 ここでは、下記のような階層構造のコンテンツを用意して、それぞれのページで参照できるセクション情報がどのように変化するかを見てみましょう。
contents/ +-- _index.md (home page) +-- dir1/ | +-- _index.md (section page) | +-- page.md (single page) | +-- dir1-1/ | | +-- _index.md (section page) | | +-- page.md (single page) | +-- dir1-2/ | +-- _index.md (section page) | +-- page.</description></item><item><title>Hugo のセクションテンプレート (section.html) の中でセクションのタイトルを表示する</title><link>https://maku77.github.io/p/mn4ji9o/</link><pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mn4ji9o/</guid><description>セクションテンプレートの中では、.Title や .Section を利用してセクションページ用のタイトルを生成することができます。 それぞれの変数の違いについて説明します。
セクションテンプレートとは セクションテンプレート（あるいはセクションページテンプレート）は、content ディレクトリ内の各セクションのインデックスファイル (_index.md) をレンダリングするときに使用されるテンプレートファイルです。
ディレクトリ構成の例 content/ +-- mysection1/ | +-- _index.md ★このファイルや、 | +-- page1.md | +-- page2.md +-- mysection2/ +-- _index.md ★このファイルに適用されるレイアウトです +-- page1.md +-- page2.md どのようなファイルがセクションテンプレートとして使用されるかは、本家サイトの下記ページに詳しく説明されています。
Section Template Lookup Order すべてのセクションで共通のテンプレートを使用したいのであれば、まずは下記のようなパスにテンプレートファイルを用意するのがよいでしょう。
/layouts/_default/section.html （セクション専用のテンプレート）
/layouts/_default/list.html （セクション以外にも様々なリスト系ページで使われるテンプレート） ＜ テーマとしてテンプレートファイルを提供したいときは、テーマディレクトリの下に同じ構成でファイルを作成すれば OK です。
/themes/&amp;lt;テーマ名&amp;gt;/layouts/_default/section.html
/themes/&amp;lt;テーマ名&amp;gt;/layouts/_default/list.html
list.html の方は、ホームページ（ルートの _index.md）や、タグやカテゴリーのインデックスページなどにも使用されます。 セクションのインデックスページとしてのみ適用したいテンプレートであれば、section.html という名前で作成しましょう。
セクションテンプレートから .Title を参照する セクションテンプレート layouts/_default/section.html（存在しない場合は list.html）の中で {{ .Title }} と記述すると、そのセクションの _index.md ファイルのフロントマターに定義した title の情報が参照されます。 これはすなわち「セクションページのタイトル」として使用できるものです。
☝️ ワンポイント シングルページテンプレート layouts/_default/single.</description></item><item><title>Hugo のレイアウト用テンプレートの種類を理解する</title><link>https://maku77.github.io/p/zg4n7q9/</link><pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zg4n7q9/</guid><description>Hugo では様々なタイプのテンプレートファイルを用意することができ、コンテンツファイルのパスに応じて、どのテンプレートファイルを使ってレンダリングされるかが決定されます。
Hugo のテンプレートファイル Hugo で Web サイトを作成する場合、コンテンツファイルとして Markdown ファイルを作成していきます。 この Markdown ファイルが HTML の形にレンダリングされるとき、テンプレートファイル が使用されます。 Hugo のテンプレートの仕組みを理解することは、Hugo を使いこなすキモとなります。 ここでは、どのような種類のテンプレートファイルが、どのようなコンテンツに対して適用されてレンダリングされるのかを把握しましょう。
ここでは、下記のようなコンテンツ階層があるものとして説明していきます。
コンテンツのディレクトリ階層 content/ +-- _index.md （ホームページ） +-- page1.md （通常のページ） +-- page2.md （通常のページ） +-- section1/ | +-- _index.md （セクションのインデックスページ ＝ セクションページ） | +-- pagel-1.md （通常のページ） | +-- page1-2.md （通常のページ） +-- section2/ +-- _index.md （セクションのインデックスページ ＝ セクションページ） +-- page2-1.md （通常のページ） +-- page2-2.md （通常のページ） ホームページテンプレート (Homepage Template) Homepage Template 最上位の _index.md をレンダリングするときは、ホームページテンプレート が使用されます。</description></item><item><title>複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir)</title><link>https://maku77.github.io/p/4m7gqfx/</link><pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4m7gqfx/</guid><description>ローカル PC 上でいくつもの Hugo サイトを作成していて、さらに共通したテーマも同時に作成している場合は、同一のテーマディレクトリを参照して開発できると便利です。
複数の Hugo プロジェクトから、同一のテーマを参照するには、下記のような方法があります。
GitHub などにテーマ用のリポジトリを作成して、そのリポジトリを複数の Hugo プロジェクトに clone する。 各 Hugo プロジェクトの themes ディレクトリを、共通のテーマディレクトリへのシンボリックリンクへ置き換える。 設定ファイル (config.toml) で、共通のテーマディレクトリを参照するように設定する。 1 番目の方法は王道ですが、Git を介して各サイトのテーマを同一に保つのは、開発段階ではちょっと手間がかかって面倒かもしれません。 そんなときオススメなのは 2 番目と 3 番目の方法です。
シンボリックリンクで共通のテーマディレクトリを参照する Linux や macOS などのようにシンボリックリンクを作成できる OS では、共通のテーマディレクトリをシンボリックリンクで参照してしまうのがお手軽です。 例えば、下記のように共通で使用するテーマディレクトリ (hugo_themes) と、参照元となる３つの Hugo プロジェクト (site1、site2、site3) があるとします。
- hugo_themes/ （共通のテーマディレクトリ） +-- mytheme/ +-- archetypes/ +-- layouts/ +-- static/ +-- ... - site1/ （Hugo サイト 1） - site2/ （Hugo サイト 2） - site3/ （Hugo サイト 3） 各 Hugo プロジェクト内の themes ディレクトリを、hugo_themes へのシンボリックリンクに置き換えてしまえば、すべてのサイトから同じテーマディレクトリを参照できます。</description></item><item><title>複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる</title><link>https://maku77.github.io/p/yg4o9rb/</link><pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yg4o9rb/</guid><description>Hugo サーバーの複数起動について 複数のサイトを Hugo で運用しているケースでは、ひとつのコマンドプロンプトから同時にサーバー起動できると便利です。
ここでは、下記のようにホームディレクトリ以下に複数の Hugo プロジェクトが存在するとします。
C:/website/site1 C:/website/site2 C:/website/site3 各 Hugo プロジェクトに対して Hugo サーバーを起動するには、例えば次のように実行していきます。
ポート番号を指定して Hugo サーバーを複数起動する C:\&amp;gt; hugo server -p 50001 -s C:/website/site1 C:\&amp;gt; hugo server -p 50002 -s C:/website/site2 C:\&amp;gt; hugo server -p 50003 -s C:/website/site3 参考: カレントディレクトリを気にせずに hugo コマンドを実行する 参考: ポート番号を指定して Hugo サーバーを起動する ただし、上記のようにすると、1 つのサーバープロセスが 1 つのコマンドプロンプトを占有するため、複数の Hugo サーバーを起動しているときに複数のコマンドプロンプトを開いたままにしなければいけません。
1 つのターミナルで複数の Hugo サーバーを起動する Windows の場合 Windows の start コマンドを使用すると、バックグラウンドで hugo コマンドを実行することができるので、追加でコマンドプロンプトを開くことなしに複数の Hugo サーバーを起動することができます。 例えば、下記のバッチファイルは、３つの Hugo サーバーをバックグラウンドで起動します。</description></item><item><title>Hugo のセクション機能の基本（記事を階層化する）</title><link>https://maku77.github.io/p/8ihz7es/</link><pubDate>Wed, 04 Oct 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8ihz7es/</guid><description>Hugo では、記事ファイルをディレクトリ内に格納するだけで、その名前の セクション に所属する記事として扱うことができます。 この機能は、記事を物理的な階層構造で管理するために使用することができます。
セクションの基本 Hugo の記事ファイル（.md ファイル）は、content ディレクトリに格納していきますが、content ディレクトリの下にさらにディレクトリを作成して、そこに格納することもできます。 例えば、次のように author というサブディレクトリを作成して、その下に .md ファイルを配置することができます。
/content/author/maku.md このようなディレクトリ階層を作成すると、maku.md という記事は、author という セクションに所属する記事 として扱われるようになります。 セクションはディレクトリ階層で表現されるため、1 つの記事は、1 つのセクションにしか所属できません。
セクション名は、記事のテンプレート内から {{ .Section }} で参照することができます（Page オブジェクトのプロパティ）。 個々の記事のレイアウトは、single.html というテンプレートファイル (single page template) によって行われるため、まずはこのテンプレートファイルを作成しましょう。
layouts/_default/single.html &amp;lt;h1&amp;gt;{{ .Title }}&amp;lt;/h1&amp;gt; セクション名: {{ with .Section }}{{ . }}{{ else }}なし{{ end }} &amp;lt;main&amp;gt; {{ .Content }} &amp;lt;/main&amp;gt; ☝️ ワンポイント ここで使用している with という構文は、if の拡張構文です。 指定した値が存在する場合、シンプルに {{ . }} でその値を参照できます。 上記のテンプレートファイルの例では、.Section が存在する場合だけその値を表示し、存在しない場合は「なし」と表示するようにしています。 記事ファイル (.</description></item><item><title>Hugo のショートコードの中からフロントマターのパラメータを参照する ($.Page.Params)</title><link>https://maku77.github.io/p/t4sdxi3/</link><pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/t4sdxi3/</guid><description>Hugo のショートコードの中で $.Page.Params を参照すると、コンテンツファイルのフロントマターに記述したパラメータにアクセスすることができます。 下記の hello ショートコードは、コンテンツファイル (.md) のフロントマターに記述された title パラメータと date パラメータの値を表示します。
layouts/shortcodes/title-and-date.html {{ $.Page.Params.title }}&amp;lt;br&amp;gt; {{ $.Page.Params.date | dateFormat &amp;#34;Mon, 02 Jan 2006&amp;#34; }} ☝️ ワンポイント 時刻情報は dateFormat 関数に渡すことで、任意のフォーマットで出力することができます。 パイプで渡すのではなく、関数の第 2 パラメータとして次のように渡すこともできます。
{{ dateFormat &amp;#34;Mon, 02 Jan 2006&amp;#34; $.Page.Params.date }} Go 言語の時刻の扱いに関しては こちらを参照 してください。
作成した title-and-date ショートコードは、コンテンツファイルの中から次のように使用します。
content/page1.md --- title: &amp;#34;ページタイトル&amp;#34; date: &amp;#34;2017-10-02&amp;#34; --- {{&amp;lt; title-and-date &amp;gt;}} 上記のショートコードの部分は、HTML ファイル出力時に次のように展開されます。
Page1 Title&amp;lt;br&amp;gt; Mon, 02 Oct 2017</description></item><item><title>Hugo のショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params)</title><link>https://maku77.github.io/p/53patex/</link><pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/53patex/</guid><description>Hugo のショートコードの中で $.Site.Params を参照すると、設定ファイル (config.toml) の params セクションに記述した情報を取得することができます。 例えば、設定ファイルに下記のように記述されていたとします。
config.toml baseURL = &amp;#34;http://example.org/&amp;#34; languageCode = &amp;#34;ja-jp&amp;#34; title = &amp;#34;わたしのブログ&amp;#34; theme = &amp;#34;my-theme&amp;#34; [params] subtitle = &amp;#34;Hugo を使って日記を書いています&amp;#34; authors = [ &amp;#34;Maku&amp;#34;, &amp;#34;Ponyo&amp;#34; ] 上記の params セクションに記述した設定値は、ショートコードの中から $.Site.Params.&amp;lt;パラメータ名&amp;gt; で参照することができます。 下記の site-info ショートコードは、サイトのタイトルとサブタイトル、筆者情報を表示するショートコードの実装例です。
layouts/shortcodes/site-info.html &amp;lt;div class=&amp;#34;title&amp;#34;&amp;gt;{{ $.Site.Title }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;subtitle&amp;#34;&amp;gt;{{ $.Site.Params.subtitle }}&amp;lt;/div&amp;gt; &amp;lt;ul&amp;gt; {{ range $.Site.Params.authors }} &amp;lt;li&amp;gt;{{- . -}}&amp;lt;/li&amp;gt; {{ end }} &amp;lt;/ul&amp;gt; ☝️ ワンポイント 上記のコードの中で、{{- . -}} と書いてある部分は、ループ処理で取り出した著者の名前を出力することを示しています。 {{ . }} と記述する代わりに、前後にハイフンを入れておくことで、出力時に前後の余計なスペースを取り除いてくれます。 コンテンツファイル (.</description></item><item><title>Hugo で独自のショートコードを作成する</title><link>https://maku77.github.io/p/ttfyk5o/</link><pubDate>Fri, 29 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ttfyk5o/</guid><description>Hugo で独自のショートコードを作成すると、定型の HTML コードを記事内に簡単に埋め込めるようになります。
ショートコード作成の基本 ショートコードは、layouts/shortcodes ディレクトリ内に .html 拡張子のファイルとして作成します。
layouts/shortcodes/my-shortcode.html This is my first short code. ファイル名から拡張子を除いたものが、ショートコード名となります。 上記の例の場合、my-shortcode というショートコードを作成したことになります。 記事（Markdown ファイル）の中から、下記のように呼び出すと、上記の内容がそこに展開されます。
content/page1.md --- title: &amp;#34;ページタイトル&amp;#34; --- {{&amp;lt; my-shortcode &amp;gt;}} ショートコードにパラメータを渡す (.Get) 単純なパラメータ ショートコード呼び出し時に、パラメータを渡すことができます。 下記の例では、２つのパラメータ red、32px を渡しています。
{{&amp;lt; my-shortcode red 32px &amp;gt;}} 渡されたパラメータは、ショートコードの中で {{ .Get インデックス番号 }} のように参照することができます。
layouts/shortcodes/my-shortcode.html &amp;lt;div style=&amp;#34;color:{{ .Get 0 }}; font-size:{{ .Get 1 }};&amp;#34;&amp;gt; This is my first short code. &amp;lt;/div&amp;gt; 名前付きパラメータ 上記の例では、参照するパラメータをインデックス番号 (0, 1, 2, &amp;hellip;) で指定していますが、2 つ以上のパラメータを持つショートコードを作成するときは、名前付きパラメータ の仕組みを使うと分かりやすくなります。</description></item><item><title>Hugo のショートコードで本文内に HTML スニペットを埋め込む</title><link>https://maku77.github.io/p/tsfzj4n/</link><pubDate>Fri, 29 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tsfzj4n/</guid><description>記事の中に定型のコード（YouTube 動画表示用 HTML など）を埋め込みたいときは、Hugo のショートコード (Shortcode) の機能を使用すると便利です。
ショートコードの基本 Hugo は基本的にマークダウン形式で記事を記述していくのですが、マークダウンの表現力には限界があるので、ときには HTML を直接記述したくなることがあります。 しかし、毎回同じような HTML を記述するのでは、マークダウン形式を使用する意味がなくなってしまいます。 このような場合に、HTML 部分をショートコードとして外部ファイルに保存しておくと、記事の中に簡単にその HTML を埋め込めるようになります。
☝️ ワンポイント ショートコードは記事（コンテンツファイル）の中から呼び出すことができますが、テンプレートファイルの中からは呼び出せないことに注意してください。 テンプレートの中から同様のことを行いたい場合は、パーシャルテンプレートの仕組みを使用します。 Hugo には、いくつかの組み込みのショートコードが用意されています。 例えば、下記は Youtube の動画や、Instagram の投稿を埋め込むためのショートコードの使い方の例です。
例: Youtube 動画を記事内に埋め込む {{&amp;lt; youtube w7Ft2ymGmfc &amp;gt;}} {{&amp;lt; youtube id=&amp;#34;w7Ft2ymGmfc&amp;#34; autoplay=&amp;#34;true&amp;#34; &amp;gt;}} 例: Instagram の投稿を記事内に埋め込む {{&amp;lt; instagram BWNjjyYFxVx &amp;gt;}} 例: ツイートを記事内に埋め込む {{&amp;lt; tweet 877500564405444608 &amp;gt;}} ショートコードの呼び出し方 記事内からショートコードを呼び出すには、下記のような構文を使用します。
{{&amp;lt; shortcode-name param1 param2 &amp;gt;}} 名前付きのパラメータを使用する場合は、param1=&amp;quot;value1&amp;quot; のように記述します。
{{&amp;lt; shortcode-name param1=&amp;#34;value1&amp;#34; param2=&amp;#34;value2&amp;#34; &amp;gt;}} HTML タグのように、開始タグと終了タグで内部テキストを囲むこともできます (paired shortcode)。</description></item><item><title>Hugo で独自のテーマを作成する</title><link>https://maku77.github.io/p/s4qbuez/</link><pubDate>Sun, 10 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s4qbuez/</guid><description>独自テーマの新規作成 Hugo には、ネット上に公開されているテンプレートがたくさんありますが、思い通りのデザインをするときは、自分でテーマを作成することになります。 テーマを作成するときは、まずは下記のコマンドで雛形を出力します。
$ hugo new theme &amp;lt;テーマ名&amp;gt; 例えば下記のように実行すると、themes/my-theme ディレクトリが生成されます。
$ hugo new theme my-theme 生成されるファイル群は下記のようになっていて、ディレクトリ構成はバッチシできていますが、ファイル内の記述はほとんど空っぽです。 このファイル群をベースにして、テンプレートを作成していきます。
独自テーマの雛形 themes/my-theme/ ├── LICENSE.md （MIT ライセンス） ├── archetypes/ │ └── default.md （ほぼ空っぽ） ├── layouts/ │ ├── 404.html （空っぽ） │ ├── _default/ │ │ ├── list.html （空っぽ） │ │ └── single.html （空っぽ） │ ├── index.html （空っぽ） │ └── partials/ │ ├── footer.html （空っぽ） │ └── header.html （空っぽ） ├── static/ │ ├── css/ │ └── js/ └── theme.</description></item><item><title>Hugo で日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage)</title><link>https://maku77.github.io/p/rqcwgyj/</link><pubDate>Tue, 29 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rqcwgyj/</guid><description>Hugo の記事一覧ページでは、記事の先頭部分を特定の単語数 (70 words) だけサマリー表示するようになっています。 ただし、このワードカウントはデフォルトでは英語などの単語数をベースに計算されているので、日本語などでは正しくカウントされずに、長大なサマリーが表示されてしまいます。
日本語の文字数を正しく数えて、短いサマリーを表示できるようにするには、設定ファイルで下記のように hasCJKLanguage を true に設定します。
config.toml の場合 hasCJKLanguage = true config.yaml の場合 hasCJKLanguage: true これで、Hugo 内部の .Summary や .WordCount が日本語で正しく動作するようになり、短いサマリー文章が表示されるようになります。
各ページごとに設定を行いたい場合は、下記のようにフロントマターで、isCJKLanguage を true に設定します。
--- title: &amp;#34;記事のタイトル&amp;#34; date: &amp;#34;2017-08-29&amp;#34; isCJKLanguage: true --- 記事の本文 設定ファイルでは hasCJKLanguage を設定し、Markdown ファイルのフロントマターでは isCJKLanguage を設定することに注意してください。</description></item><item><title>Hugo で特定の記事を常にリスト上方に表示する（weight プロパティ）</title><link>https://maku77.github.io/p/utmg42x/</link><pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/utmg42x/</guid><description>Hugo で記事（コンテンツ）の一覧を表示しようとすると、通常は記事の作成日時順に表示されます。 一覧ページで特定の記事を最初に表示したい場合は、記事のフロントマターの weight プロパティで、記事の重要度（整数値）を設定します。
記事のヘッダ (Front matter) の記述例 --- title: &amp;#34;重要な記事&amp;#34; date: &amp;#34;2017-08-28&amp;#34; weight: 1 --- ...本文... weight プロパティに設定した値は、小さいほど重要度が高いと認識されます。 つまり、weight 値を 1 にすると、重要な記事として上の方に表示されます。 2 はその次、3 はさらにその次、というように、昇順に表示されます。 0 は特別で、weight 値を指定していないのと同じ意味になります。
weight 値には、実はマイナスの値も設定することができるため、-99999 といった値を設定しておくと、1 や 2 と設定したものよりも上位に表示されます（優先度がものすごく高いと見なされる）。
weight 値の設定されていない（あるいは weight: 0 に設定した）通常の記事は、どのような weight 値を持つ記事よりも優先度が低いと見なされませます（後ろに表示されます）。</description></item><item><title>Hugo で記事を作成する</title><link>https://maku77.github.io/p/q7sdwgy/</link><pubDate>Fri, 25 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q7sdwgy/</guid><description>記事ファイルを作成する Hugo で公開する Web サイトの記事は、content ディレクトリに Markdown ファイルとして作成します（例: sample.md）。 記事ファイルは、空っぽのテキストファイルから作成していくこともできますが、hugo new コマンドを使用することで、記事のひな形ファイル (archetypes/default.md) をベースにして Markdown ファイルを自動生成することができます。
記事ファイル（Markdown ファイル）を作成 $ hugo new sample.md /Users/maku/my_site/content/sample.md created 上記のように実行すると、content ディレクトリ内に sample.md ファイルが作成されます。 作成されたファイルの先頭部分には、下記のような Front matter というヘッダが記述されています。 このヘッダが、archetypes/default.md をもとにして自動生成されたものです。
content/sample.md --- title: &amp;#34;Sample&amp;#34; date: 2017-08-25T22:55:55+09:00 draft: true --- あとは、タイトル (title) を適切なものに書き換え、Front matter ヘッダ以降に記事の本文を記述していきます。 公開できるレベルまで記述できたら、ヘッダ部分の draft: true の行を削除します。
Archetypes ここで、ベースとなっている archetypes/default.md を覗いてみましょう。
archetypes/default.md --- title: {{ replace .TranslationBaseName &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; date: {{ .</description></item><item><title>Hugo のテーマを設定する</title><link>https://maku77.github.io/p/h2cku5d/</link><pubDate>Fri, 25 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/h2cku5d/</guid><description>テーマをダウンロードする Hugo で Web サイトを生成するときは、外観のベースとなる テーマ を設定する必要があります。 テーマを設定せずに hugo コマンドで Web サイトを出力しても、真っ白なページが表示されてしまうだけです。 テーマは自分で作成することもできますが、Hugo Themes というサイトに、有志の人によって作られたテーマが公開されていますので、まずはここからダウンロードして使ってみるのがよいでしょう。 使用方法はテーマごとに少しずつことなるので、詳細はそれぞれのテーマの説明 (README.md) を読んでください。
テーマの ZIP ファイルをダウンロードする方法 例えば、下記の bootstrap4-blog というテーマがよさそうであれば、Download ボタンを押します。
通常は、GitHub のサイトに飛ぶので、Clone or download のボタンを押してテーマをダウンロードしてください。
ダウンロードしたテーマは、プロジェクトの themes ディレクトリに配置します。 このケースでは、themes/bootstrap4-blog ディレクトリとして配置します。
テーマを Git で取得する方法 テーマは GitHub 上で管理されていますので、Git コマンドが使える環境であれば、下記のように git clone してしまうのが簡単です（もちろん先にリポジトリの URL は調べておく必要はありますが）。
$ git clone https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/bootstrap4-blog もし、自分のサイトを Git 管理しているのであれば、次のようにテーマを Git サブモジュール として取り込んでしまうがよいです。 Git サブモジュールのコマンド (git submodule) はちょっと難しいですが、テーマをサブモジュールとして管理すれば、テーマ側の更新を適宜反映できるようになります。
# テーマをサブモジュールとして取り込む $ git submodule add https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/bootstrap4-blog # テーマ側の更新を取り込むとき $ git submodule update --remote --recursive （必要に応じて）テーマごとのセットアップ テーマによっては、外部コンポーネントに依存していて、初期設定が必要なものもあります。 上記の bootstrap4-blog テーマでは、下記のように関連モジュールをインストールしてくださいと説明がありますので、その通りに実行しておきます。</description></item><item><title>カレントディレクトリを気にせずに hugo コマンドを実行する</title><link>https://maku77.github.io/p/wdyk5n7/</link><pubDate>Fri, 25 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wdyk5n7/</guid><description>hugo コマンドを実行するときに、-s (--source) オプションを使用することで、ソースディレクトリのパスを指定して起動することができます。
例: ~/mysite 以下のソースコードを使って Hugo サーバーを起動する $ hugo server -s ~/mysite 例: ~/mysite 以下の記事を新規作成する $ hugo new sample.md -s ~/mysite 上記の例では、-s ~/mysite というソースディレクトリの指定を末尾に持ってきましたが、hugo の直後に指定しても動作するようです。 これを利用して、下記のようなコマンドエイリアスを作成しておけば、どのディレクトリからでもすぐに記事作成を始められて便利です。
~/.bash_profile alias hugo-mysite=hugo -s ~/mysite 例えば、下記のように使用することができます。
$ hugo-mysite new sample.md # 記事の作成 $ hugo-mysite server # Hugo サーバーを起動 $ hugo-mysite # サイトをビルド（~/mysite/public に出力）</description></item><item><title>ポート番号を指定して Hugo サーバーを起動する</title><link>https://maku77.github.io/p/jj7rcvf/</link><pubDate>Fri, 25 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jj7rcvf/</guid><description>Hugo サーバーを hugo server コマンドで起動すると、デフォルトでは 1313 ポートを使用する Web サーバが立ち上がります。 ただし、複数の Hugo サーバーを同時に立ち上げようとすると、2 つめ以降の Hugo サーバーにはランダムなポート番号が割り当てられます（おそらく Private ports である 49152～65535 の範囲のポート番号が使用されます）。
任意のポート番号を使うように指定するには、下記のように -p (--port) オプションを使用します。
例: ポート番号 51234 で Hugo サーバーを立ち上げる $ hugo server -p 51234 たくさんの Hugo サーバーを同時に起動するようなケースでは、それぞれのサイトでどのポート番号を使用するかを決めておくとよいでしょう。
例: 3 つの Hugo サーバーを同時に立ち上げる $ hugo server -p 50001 -s ~/mysite1 $ hugo server -p 50002 -s ~/mysite2 $ hugo server -p 50003 -s ~/mysite3 上記のように立ち上げた Web サイトは、それぞれ下記のようなアドレスでアクセスできるようになります。
http://localhost:50001/ http://localhost:50002/ http://localhost:50003/</description></item><item><title>Hugo でドラフトページを作成する</title><link>https://maku77.github.io/p/m2oatdw/</link><pubDate>Thu, 24 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m2oatdw/</guid><description>ドラフト記事 Hugo のドラフト機能は、未完成の記事ファイルを一時的にほかの記事と同じ場所に保存しておくための機能です。 ページの Front matter 部分に、draft: true という記述があると、そのページはドラフトとして扱われます。
YAML 形式の場合 --- draft: true --- 本文 TOML 形式の場合 +++ draft = true +++ 本文 ドラフトとして作成された記事は、デフォルトでは HTML ファイルとして出力されません。 ドラフト記事も出力するようにするには、hugo コマンドに -D (--buildDrafts) オプションを指定します。
ドラフト記事を出力 $ hugo -D # サイトを生成する場合 $ hugo server -D # サーバーを立ち上げる場合 public ディレクトリに出力されたドラフト記事に注意 hugo コマンドは、デフォルトで public ディレクトリに HTML ファイルなどを出力しますが、このとき、public ディレクトリ内に既に存在するドラフト記事を削除することはありません。
$ hugo -D # ここでドラフト記事も含めて生成される $ hugo # 次にドラフトモード OFF で生成しても、既存のドラフト記事が削除されない Web サイトを公開するときは、ドラフト記事が間違ってアップロードされないように気を付けてください。 記事のアップロード前は、public ディレクトリを削除してから hugo コマンドで再生成すると安全です。</description></item><item><title>Hugo で新規の Web サイトを作成する</title><link>https://maku77.github.io/p/bt5enw6/</link><pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bt5enw6/</guid><description>ここでは、Hugo を使用して、新しく Web サイトを構築するための手順を示します。
図: Hugo で生成したサイトの例 サイトのスケルトンを生成する まずは Hugo をインストールして、hugo コマンドを使用できる状態にしてください。 下記のように hugo new site コマンドを使用して、Web サイトのひな型を作成することができます。
新しい Web サイト (my_site) を作成する $ hugo new site my_site Congratulations! Your new Hugo site is created in C:\Users\maku\my_site. Just a few more steps and you&amp;#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/, or create your own with the &amp;#34;hugo new theme &amp;lt;THEMENAME&amp;gt;&amp;#34; command.</description></item><item><title>Hugo とは／Hugo をインストールする</title><link>https://maku77.github.io/p/r8ufyk5/</link><pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r8ufyk5/</guid><description>Hugo とは Hugo (https://gohugo.io/) Hugo は Jekyll や Middleman と同様の静的サイトジェネレータです。 Markdown 形式などで記述したコンテンツから、HTML ファイルを作成してくれます。
Hugo は Google の Go 言語 で作成されており、他のサイトジェネレータに比べて 動作が非常に速い という特徴を持っています（それに比べて Jekyll は特に遅いですね ^^;）。 公式サイトでも動作の高速さをアピールしており、今後もその方針は変わらなさそうなので安心です。
また、インストールに関しても、他の（Ruby 製や Python 製の）サイトジェネレータは、さまざまな外部モジュールをインストールしなければいけないので時間がかかったりすることがありますが、Hugo であれば一瞬で終わります。 例えば、Windows の実行環境を構築する場合も、hugo.exe という１ファイルを置くだけで終わります。 LiveReload などの機能もデフォルトで組み込まれており、立ち上げまでの導入が非常にシンプルです。
Hugo のインストール Mac OS の場合 Mac の場合は、Homebrew (brew) で簡単に Hugo をインストール できます。
$ brew install hugo すでに Hugo がインストールされている状態で、Hugo を最新バージョンに更新 したいときは次のようにします。
$ brew upgrade hugo 現在インストールされている Hugo のバージョン は次のように確認できます。
$ hugo version Windows の場合 Windows の場合は、Hugo の Releases ページから zip アーカイブ（hugo_extended_0.</description></item></channel></rss>