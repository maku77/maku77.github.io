<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PIC めもめも（PIC アセンブラ） on 天才まくまくノート</title><link>https://maku77.github.io/p/48ipjkq/</link><description>Recent content in PIC めもめも（PIC アセンブラ） on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 01 Aug 2002 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/p/48ipjkq/index.xml" rel="self" type="application/rss+xml"/><item><title>３軸加速度センサの入力を 200Hz でサンプリング＆シリアル通信するサンプルプログラム ─ PIC めもめも</title><link>https://maku77.github.io/p/w6pogd4/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w6pogd4/</guid><description>３軸加速度センサの入力を 200Hz で A/D 変換し、シリアルポートから 9600bps で 1byte ずつ送信（5msec ごとに 0x00, Ax, Ay, Az の計 4 byte を送信）するサンプルコードです。 最初にデリミタのための 0x00 を送信するようにしているので、0x00, Ax, Ay, Az の 4 byte が 5msec ごとにまとめて送信されます。
;============================================================================== ; ; File : ad_200hz.asm ; Author: Masatoshi OHTA ; Update: 2002/11/18 ; ; デバイス : PIC16F873 ; 通信スピード : 9600bps ; データ長 : 8bit ; ストップビット: 1bit ; フロー制御 : なし ; ;============================================================================== LIST P=PIC16F873 INCLUDE &amp;#34;P16F873.INC&amp;#34; __CONFIG _HS_OSC &amp;amp; _WDT_OFF ;ウォッチドッグ・タイマ OFF ;============================================================================== ; 変数定義 ;============================================================================== CBLOCK H&amp;#39;20&amp;#39; w_temp ; variable used for context saving status_temp ; variable used for context saving temp ; wait_count ; 遅延サブルーチン用の変数 ENDC ;============================================================================== ; エントリ・ポイント ;============================================================================== ORG 0 goto Start ORG 4 goto Interrupt ;============================================================================== ; メインルーチン ;============================================================================== Start bsf STATUS, RP0 ; Bank1 に切り替え ;[TRISA] 入出力ポートの設定 movlw B&amp;#39;00000111&amp;#39; ; RA0, RA1, RA2 は入力(センサから) movwf TRISA ; ;[ADCON1] アナログ入力にするポート、左詰右詰を決定 movlw B&amp;#39;00000010&amp;#39; ; 左詰、AN0～AN4 全部アナログ入力 movwf ADCON1 ;[TRISC] USART 用入出力ポートの設定 bcf TRISC, 6 ; PortC&amp;lt;6&amp;gt; (TX) is an output ; bsf TRISC, 7 ; PortC&amp;lt;7&amp;gt; (RX) is an input ;[TXSTA] USART 送信ステータスの設定 movlw B&amp;#39;00100000&amp;#39; ; Async mode movwf TXSTA ; ;[SPBRG]USART ボーレートの設定 movlw 0FH ;9600bps 10MHz BRGH=0(低速) movwf SPBRG bcf STATUS, RP0 ; Bank0 に戻す ;[RCSTA] USART 受信ステータスの設定 movlw B&amp;#39;10010000&amp;#39; ; movwf RCSTA ; ;[ADCON0] AD 変換クロックを指定。AD 変換を有効に movlw B&amp;#39;10000001&amp;#39; ; Fosc/32, CH0, ADON=1 movwf ADCON0 ;CCP1 のコンペアモード（SpecialEventTrigger）による割り込みの設定 ;SetupTimer1 movlw B&amp;#39;00000001&amp;#39; movwf T1CON ;SetupCCP1 movlw B&amp;#39;00001011&amp;#39; movwf CCP1CON ;SetCCP1Counter movlw H&amp;#39;30&amp;#39; ; 0x61A8 = 25000 Count (10msec - 100Hz) movwf CCPR1H ; 0x30D4 = 12500 Count ( 5msec - 200Hz) movlw H&amp;#39;D4&amp;#39; movwf CCPR1L ;割り込み許可 bsf STATUS, RP0 ;Go to Bank1 bsf PIE1, CCP1IE ;CCP1 割り込みイネーブル bcf STATUS, RP0 ;Back to Bank0 bsf INTCON, PEIE ;周辺機能割り込みイネーブル (CCP1は周辺機能) bsf INTCON, GIE ;全体の割り込みイネーブル ;****************************************************************************** ; Idle Loop ;****************************************************************************** MainLoop ;Nothing to do.</description></item><item><title>A/D 変換を実行する ─ PIC めもめも</title><link>https://maku77.github.io/p/izgbusm/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/izgbusm/</guid><description>A/D 変換モジュール PIC16F873/876 (28ピン)、PIC16F874/877 (40ピン) などには A/D 変換モジュールが付いています。 28 ピンモジュールには 5 入力、40 ピンモジュールには 8 入力あります。 5 入力全部使えば、3 軸加速度センサと 2 軸ジャイロセンサの出力を 1 つの PIC で A/D 変換することができます（入力が多いほど A/D 変換に時間はかかります）。
A/D 変換モジュールには次の 4 つのレジスタがあります。
A/D 変換制御レジスタ 0 ･･･ ADCON0 A/D 変換制御レジスタ 1 ･･･ ADCON1 A/D 変換結果 High レジスタ ･･･ ADRESH A/D 変換結果 Low レジスタ ･･･ ADRESL A/D 変換制御用レジスタ ─ ADCON0 レジスタの構成 ADCON0 レジスタ (1Fh : Bank0) は、クロック、チャンネルの指定、A/D 変換開始などに使用します。
ADCS1(7) ADCS0(6) CHS2(5) CHS1(4) CHS0(3) GO/DONE(2) ─(1) ADON(0) ADCS1(7) ～ ADCS0(6): AD 変換クロックセレクトビット 00 ･･･ Fosc/2 01 ･･･ Fosc/8 10 ･･･ Fosc/32 11 ･･･ FRC (RC 発振) CHS2(5) ～ CHS0(3): アナログチャネルセレクトビット 000 ･･･ channel 0, (RA0/AN0) 001 ･･･ channel 1, (RA1/AN1) 010 ･･･ channel 2, (RA2/AN2) 011 ･･･ channel 3, (RA3/AN3) 100 ･･･ channel 4, (RA5/AN4) 101 ･･･ channel 5, (RE0/AN5) (※ 28pin デバイスにはありません) 110 ･･･ channel 6, (RE1/AN6) (※ 28pin デバイスにはありません) 111 ･･･ channel 7, (RE2/AN7) (※ 28pin デバイスにはありません) A/D 変換は 1 度に 1 つのポートからの入力に対してしか行なえないので、この 3 bit でどのポートからの入力を変換するか切り替えます。</description></item><item><title>C 言語 → アセンブラ言語 ─ PIC めもめも</title><link>https://maku77.github.io/p/pzazwmj/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pzazwmj/</guid><description>様々な C 言語のコードを PIC アセンブラ言語に変換するためのメモです。
代入 VAR = 100 MOVLW D&amp;#39;100&amp;#39; MOVF VAR, F VAR1 = VAR2 MOVF VAR2, W MOVWF VAR1 VAR++ INCF VAR, F VAR += 100 MOVLW D&amp;#39;100&amp;#39; ADDWF VAR, F VAR1 += VAR2 MOVF VAR2, W ADDWF VAR1, F ループ for (i = 100; i &amp;gt; 0; i&amp;ndash;) MOVLW D&amp;#39;100&amp;#39; ;100 回ループ MOVWF i LOOP ... DECFSZ i, F GOTO LOOP IF 分岐 if (w == 100) SUBLW 100 ; 100 - w -&amp;gt; w BTFSC STATUS, Z ; w == 100 でなかったらスキップ GOTO W_IS_100 GOTO W_IS_NOT_100 W_IS_100 .</description></item><item><title>CCP (Compare/Capture/PWM) モジュール ─ PIC めもめも</title><link>https://maku77.github.io/p/gx3mib3/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gx3mib3/</guid><description>CCP モジュールのモード CCP モジュールには 3 つのモードがあり、それぞれの用途によって使い分けて使用することができます。
コンペア・モード タイマ 1 のカウントがある値になったときに、何らかのアクションを行います。タイマ 1 の設定をクロック同期モードにしておく必要があります。タイマ 1 を正確なインターバルタイマとして利用できるようになります。 キャプチャー・モード CCP1 (あるいは CCP2) ピンからの入力を元にして、タイマ 1 のカウントを CCPR1H、CCPR1L レジスタ（あるいは CCPR2H、CCPR2L レジスタ）にコピーします。 パルス幅変調モード (PWM: Pulse Width Modulation) 周期的なパルスを発生させ外部機器を操作します。Duty の指定によりパルス幅を調整できます。 コンペア・モードの 4 つのアクション CCP モジュールをコンペア・モードで動作させると、タイマ 1 のカウンタ TMR1L、TMR1H が レジスタ CCPRxL、CCPRxH で指定した値と等しくなったときに、何らかのアクションを行います（CCP モジュールが 2 つある場合、x に 1 または 2 が入ります）。
TMR1L, TMR1H (タイマ 1 のカウンタ) ↓ 常に比較 → 一致したならアクション発生（アクションは 4 パターンから選択） ↑ CCPRxL, CCPRxH (ユーザが自由に設定する) どんなアクションを行なうかは、CCPxCON&amp;lt;CCPxM0&amp;gt; ～ &amp;lt;CCPxM3&amp;gt; で指定します。</description></item><item><title>MPLAB によるプロジェクト作成 ─ PIC めもめも</title><link>https://maku77.github.io/p/fyzm2ts/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fyzm2ts/</guid><description>MPLAB の設定（デベロップメント・モードの設定） MPLAB を起動し、次のように設定します。
「Options」 → 「Development Mode」 → 「Tools」タブ &amp;ldquo;Development Mode&amp;rdquo; で MPLAB-SIM Simulator にチェック &amp;ldquo;Processor&amp;rdquo; を使用するデバイスに変更 新規プロジェクトの作成 「Project」 → 「New Project」 &amp;ldquo;File Name&amp;rdquo; にプロジェクト名 (例えば test.prj) を入力 &amp;ldquo;Directories&amp;rdquo; には空白を含まないパス (例えば D:\PIC_ASM\test) を選択して「OK」 「OK」 ボタンを押すと、Edit Project ダイアログが開きます。
新規ソースの追加（Edit Project ダイアログ） &amp;ldquo;Development Mode&amp;rdquo; が MPLAB-SIM、正しいデバイス名になっているか確認 &amp;ldquo;Project Files&amp;rdquo; の 「Add Node」 ボタンをクリック ASM ファイル名 (例えば test.asm) を入力して 「OK」 &amp;ldquo;Project Files&amp;rdquo; の test [.hex] を選択して 「Node Properties&amp;hellip;」 ボタンをクリック Hex Format ･･･ INHX8M Warning level ･･･ all Case sensitivity … OFF (大文字と小文字を区別しない) Tab size ･･･ 4（タブ使わないかもしれないけどいちおう） 「OK」 この作業では、実際に test.</description></item><item><title>MPLAB のインストール ─ PIC めもめも</title><link>https://maku77.github.io/p/iwkdah6/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/iwkdah6/</guid><description>MPLAB のダウンロード Microchip Technology https://www.microchip.com/ (English) https://www.microchip.co.jp/ (Japanese) MPLAB ダウンロード https://www.microchip.co.jp/tool.htm MPLAB のインストール Mp57full.exe などを実行します。 ほとんどデフォルトのまま Next ボタンで進んでいけば OK です（「Linker script Location」では Install files to MPLAB\Lkr sub directory を選択した方がよいかも）。 Windows を再起動してインストール完了！ 関連ドキュメントへのリンク MPLAB チュートリアル MPLAB チュートリアル (29 Pages) MPLAB プロジェクト・チュートリアル (33 Pages) PIC データシート PIC16F83/4 データシート (912KB) PIC16F873/4/6/7 データシート (1.75MB) その他 MPLAB、MPASM、PICStart Plus を使ったセミナー実習テキスト (1,839KB) （ソースコード）</description></item><item><title>MPLAB-SIM Software Simulator によるデバッグ ─ PIC めもめも</title><link>https://maku77.github.io/p/5n5vokj/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5n5vokj/</guid><description>MPLAB-SIM Software Simulator を使うと、ブレークポイントやトレース機能などを用いてプログラムのデバッグを行なうことができます。
Absolute List Absolute List 表示では、記述したアセンブラソースとアセンブル後の機械語を照らし合わせて表示することができます。
「Window」 → 「Absolute Listing」 このコードは、デバッグを進めていくうちに次のように色が付いて作業の目安になるので、デバッグ中はずっと表示しておくとよいです。
ブレークポイント &amp;hellip; 赤色 トレース範囲 &amp;hellip; 緑色 ブレークポイント ＆ トレース範囲 &amp;hellip; マゼンタ File Register Window File Register Window の表示 「Window」 → 「File Registers」 File Register Window では、SFC (Special Function Register) やユーザ定義の変数の現在の値を確認したり変更したりすることができます。
レジスタ内容の変更 File Register Window で変更したい範囲を選択 「右クリック」 → 「Fill Register(s)」 ブレークポイントの設定 Absolute List を表示 ブレークポイントを設定したい行で右クリック → 「Break Point(s)」 （あるいは、「Debug」 → 「Break Settings&amp;hellip;」）
トレースポイントの設定 Absolute List を表示 トレースポイントを設定したい行で右クリック → 「Trace Point(s)」 （あるいは、「Debug」 → 「Trace Settings&amp;hellip;」）</description></item><item><title>PIC アセンブラ (PIC16Fxxx) 命令セット ─ PIC めもめも</title><link>https://maku77.github.io/p/no9voj9/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/no9voj9/</guid><description>PIC16Fxxx 命令セット (14bit) カテゴリニモニック意味コード 加算・減算 ADDWF f, d W + f → d Add W and f 00 0111 dfff ffff SUBWF f, d f - W → d Subtract W from f 00 0010 dfff ffff ADDLW k W + k → W Add literal and W 11 111x kkkk kkkk SUBLW kk - W → W Subtract W from literal 11 110x kkkk kkkk 論理演算 ANDWF f, d W AND f → d AND W with f 00 0101 dfff ffff IORWF f, d W OR f → d Inclusive OR W with f 00 0100 dfff ffff XORWF f, d W XOR f → d Exclusive OR W with f 00 0110 dfff ffff ANDLW k W AND k → W And literal with W 11 1001 kkkk kkkk IORLW k W OR k → W Inclusive OR literal with W 11 1000 kkkk kkkk XORLW k W XOR k → W Exclusive OR literal with W 11 1010 kkkk kkkk COMF f, d f → d Complement f 00 1001 dfff ffff 移動 MOVF f, d f → d Move f 00 1000 dfff ffff MOVWF f W → f Move W to f 00 0000 1fff ffff MOVLW k k → W Move litaral to W 11 00xx kkkk kkkk クリア CLRF f 0 → f Clear f 00 0001 1fff ffff CLRW W 0 → W Clear W 00 0001 0xxx xxxx インクリメントデクリメント DECF f, d f - 1 → d Decrement f 00 0011 dfff ffff INCF f, d f + 1 → d Increment f 00 1010 dfff ffff DECFSZ f, d f - 1 → dSkip if result = 0 Decrement f, Skip if 0 00 1011 dfff ffff INCFSZ f, d f + 1 → dSkip if result = 0 Increment f, Skip if 0 00 1111 dfff ffff ビット操作 BCF f, b 0 → f[b] Bit Clear f 01 00bb bfff ffff BSF f, b 1 → f[b] Bit set f 01 01bb bfff ffff スキップ BTFSC f, b Skip if f[b] = 0 Bit Test f, Skip if Clear 01 10bb bfff ffff BTFSS f, b Skip if f[b] = 1 Bit Test f, Skip if Set 01 11bb bfff ffff シフト RLF f, d f[n] → d[n+1] f[7] → C → d[0] Rotate Left f through Carry(左巡回シフト) 00 1101 dfff ffff RRF f, d f[n] → d[n-1] f[0] → c → d[7] Rotate Right f through Carry(右巡回シフト) 00 1100 dfff ffff SWAPF f, d f[0:3] → d[4:7] f[4:7] → d[0:3] Swap nibbles in f(上位ビット ⇔ 下位ビット) 00 1110 dfff ffff ジャンプ GOTO k Go to address 10 1kkk kkkk kkkk CALL k Call subroutine 10 0kkk kkkk kkkk RETFIE Return from interrupt 00 0000 0000 1001 RETLW k Return with literal in W 11 01xx kkkk kkkk RETURN Return from Subroutine 00 0000 0000 1000 その他 CLRWDT Clear Watchdog Timer 00 0000 0110 0100 NOP No Operation 00 0000 0xx0 0000 SLEEP Go into standby mode 00 0000 0110 0011 OPCODE フィールドの説明 FieldSizeDescription f7 ワーキングレジスタのアドレス (0x00 ～ 0x7F) W─ ワーキングレジスタ（アキュムレータ） b3 8 ビットファイルレジスタ内のビットアドレス k8/11 リテラル、定数またはラベル (0 ～ 255) or (-128 ～ 127) or (アスキーコード 'A' とか) x─ 無効 (0 or 1) アセンブラは x=0 としてコードを生成します。</description></item><item><title>RA0 の出力を ON/OFF するサンプルプログラム ─ PIC めもめも</title><link>https://maku77.github.io/p/hjocz3n/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hjocz3n/</guid><description>;============================================================================== ; ; File : ra0_test.asm ; Author: Masatoshi OHTA ; Update: 2000-08-20 ; ;============================================================================== LIST P=PIC16F84 INCLUDE &amp;#34;P16F84.INC&amp;#34; __CONFIG _WDT_OFF ; ウォッチドッグ・タイマ OFF ; ;****************************************************************************** ; Entry Point ;****************************************************************************** ORG 0 clrf PCLATH goto Start ;****************************************************************************** ; Main Routine ;****************************************************************************** Start ;**** Set I/O Mode SetIoMode bsf STATUS, RP0 ; Bank1 に切り替え clrf TRISA ; PORTA をすべて出力モードに bcf STATUS, RP0 ; Bank0 に戻す ;**** RA0 を ON/OFF MainLoop bsf PORTA, 0 ; RA0 を High に nop bcf PORTA, 0 ; RA0 を Low に nop goto MainLoop ;****************************************************************************** ; Directive &amp;#39;End of Program&amp;#39; ;****************************************************************************** END</description></item><item><title>USART によるシリアル通信 ─ PIC めもめも</title><link>https://maku77.github.io/p/fewejde/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fewejde/</guid><description>USART 用の送受信ピン TRISC&amp;lt;6, 7&amp;gt; の設定 USART (Universal Synchronous Asynchronous Receiver Transmitter) は次のモードで構成できます。
非同期（全二重） 同期 ─ マスター（半二重） 同期 ─ スレーブ（半二重） USART による通信は TX (送信)、RX (受信) ピンを使用します（TX を出力ピン、 RX を受信ピンに設定します）。 TRISC&amp;lt;6&amp;gt; が RC6/TX/CK、TRISC&amp;lt;7&amp;gt; が RC7/RX/DT の入出力設定ビットなので、これらの値を次のようにセットします。
TX, RX の入出力モードの設定 (TX=出力, RX=入力) INIT_TX_TR BSF STATUS, RP0 ; set bank1 BCF TRISC, 6 ; PortC&amp;amp;lt;6&amp;amp;gt; (TX) is an output BSF TRISC, 7 ; PortC&amp;amp;lt;7&amp;amp;gt; (RX) is an input BCF STATUS, RP0 ; set bank0 TRISC&amp;lt;6&amp;gt; をクリアして、 TRISC&amp;lt;7&amp;gt; をセットするだけですね。</description></item><item><title>その他、用語メモ、未分類メモ ─ PIC めもめも</title><link>https://maku77.github.io/p/52s4tfc/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/52s4tfc/</guid><description>発振モード MODE BIT DESCRIPTION FREQ RANGE LP 00 低電力／水晶発振(Low Power Crystal) 200kHz 以下 XT 01 水晶／セラミック発振(Crystal／Resonator) 4MHz 以下 HS 10 高周波水晶／セラミック発振(High Speed Crystal／Resonator) 4MHz ～ 20MHz RC 11 RC 発振(Resister／Capacitor) 1MHz 以下 リセット回路 MCLR に電源をつないでおけば、とりあえずは動作しますが、周辺回路の電源が安定するまで遅延して 4.5V の入力があるべきです。 リセット用の IC にはミツミの PST600C などがあります。
MAX232 MAX232 ･･･ 1μF のコンデンサを使う MAX232A ･･･ 0.1μF ADM232AAN ･･･ 0.1μF 命令長の違う 3 シリーズ ベースライン・シリーズ ･･･ 12ビット命令 (12C5xx, 16C5xx) ミッドレンジ・シリーズ ･･･ 14ビット命令 ハイエンド・シリーズ ･･･ 16ビット命令 (17Cxxx, 18Cxxx) 一番使われている PIC16Fxxx などはミッドレンジ・シリーズにあたります。</description></item><item><title>タイマ 0 を使用する ─ PIC めもめも</title><link>https://maku77.github.io/p/cnutuna/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cnutuna/</guid><description>タイマ 0 による割り込みの仕組み タイマ 0 では、8bit の TMR0 レジスタをタイマ 0 用のクロック (後述) でインクリメントしていき、オーバフローを意図的に起こすことによって割り込みを実現しています。 TMR0 レジスタにあらかじめ値をセットしておくことによって、割り込み時間を調整することができます。 ただし、TMR0 レジスタは 8bit しかないので、それだけでは最大 256 カウントしかすることができません。 そこで、プリスケーラという 8bit のカウンタを別に用意し、このカウンタが指定した値（2, 4, 8, 16, 32, 64, 128, 256 のいずれか）になった時にはじめて TMR0 レジスタをインクリメントすることにより、65536 (8bit + 8bit) までのカウントを実現しています。 プリスケーラカウンタを使うには、OPTION_REG&amp;lt;PSA(3)&amp;gt; ビットを 0 に設定します。 プリスケーラのスケール値を設定するには、OPTION_REG&amp;lt;PS0(0)&amp;gt; ～ &amp;lt;PS2(2)&amp;gt; で次のように指定します。
タイマ 0 のプリスケーラのスケール設定 OPTION_REG
&amp;lt;PS2(2)&amp;gt;OPTION_REG
&amp;lt;PS1(1)&amp;gt;OPTION_REG
&amp;lt;PS0(0)&amp;gt; スケール 000 1:2 (256 * 2 = 512カウントまで) 001 1:4 (256 * 4 = 1024カウントまで) 010 1:8 (256 * 8 = 2048カウントまで) 011 1:16 (256 * 16 = 4096カウントまで) 100 1:32 (256 * 32 = 8192カウントまで) 101 1:64 (256 * 64 = 16384カウントまで) 110 1:128 (256 * 128 = 32768カウントまで) 111 1:256 (256 * 256 = 65536カウントまで) ※ タイマ 0 ではプリスケーラカウンタをプログラムから参照することはできません。 参照可能なのは TMR0 レジスタ (256 段階) のみになります。</description></item><item><title>タイマ 1 を使用する ─ PIC めもめも</title><link>https://maku77.github.io/p/ecozpj9/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ecozpj9/</guid><description>タイマ 1 はミッドレンジシリーズの PIC16F84 などで使用することができます。 タイマ 1 を使用することにより、より正確なインターバルタイマとして機能させることができます。
T1CON レジスタの構成 T1CON レジスタ (10h : Bank0) ─
(7) ─
(6) T1CKPS1
(5) T1CKPS0
(4) T1OSCEN
(3) T1SYNC
(2) TMR1CS
(1) TMR1ON
(0) T1CKPS1 (5) ～ T1CKPS0 (4): タイマ 1 入力クロックプリスケール選択ビット 00 ･･･ 1:1 プリスケール値 01 ･･･ 1:2 プリスケール値 10 ･･･ 1:4 プリスケール値 11 ･･･ 1:8 プリスケール値 T1OSCEN (3): タイマ 1 オシレータイネーブルコントロールビット 0 ･･･ オシレータを停止させる。オシレータインバータと帰還抵抗をオフにして消費電流を抑えます。 1 ･･･ オシレータを動作させる。 T1SYNC (2): タイマ 1 外部クロック入力同期コントロールビット If TMR1CS = 1 0 ･･･ 外部クロック入力を同期させる 1 ･･･ 外部クロック入力を同期させない If TMR1CS = 0 このビットは無視されます。TMR1CS = 0 のとき、タイマ 1 は内部クロックを使用します。 TMR1CS (1): タイマ 1 クロックソース選択ビット 0 ･･･ 内部クロック (Fosc/4) 1 ･･･ RC0/T1OSO/T1CKI（立ち上がりエッジ）ピンからの外部クロック TMR1ON (0): タイマ 1 オン・ビット 0 ･･･ タイマ 1 を停止する 1 ･･･ タイマ 1 を動作させる タイマ 1 による割り込みの仕組み タイマ 1 の仕組みは、ほぼタイマ 0 と同じ仕組みになっていますが、タイマ 1 のカウンタは TMR1L (8bit) と TMR1H (8bit) の計 16 bit を使うため、プリスケーラを入れないでも、65,536 までのカウントが可能です。 ただし、プリスケーラはタイマ 0 の時と違い、少なめの 3 bit になっており、スケールは 1:8 までです。 といっても、合計 19bit のカウンタとして働くので、プリスケーラを入れて、524,288 までのカウントが可能となり、システムクロックが 10MHz の場合は約 210 msec までのインターバルを実現することができます（20MHz の場合は約 105 msec まで）。</description></item><item><title>バンクとページの切り替え ─ PIC めもめも</title><link>https://maku77.github.io/p/dtabczb/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dtabczb/</guid><description>バンク ･･･ 汎用レジスタ (RAM) の区分け MOVWF 命令などのデスティネーションアドレスは下のように 7 ビットとなっているので、このままでは 128 バイト分の汎用レジスタにしかアクセスすることができません。
MOVWF 命令の構造 → 0000001fffffff これを解決するために、SFR (Special Function Register) である STATUS レジスタ の 5, 6 ビット目 (RP0, RP1) をアドレスの拡張に使用します。 これにより 7 + 2 = 9 ビット、つまり 512 バイト分の汎用レジスタにアクセスできるようになります（ただしデバイスごとに使用できるサイズは異なります）。
バンク STATUS&amp;lt;RP0&amp;gt; STATUS&amp;lt;RP1&amp;gt; アクセスできるアドレス範囲 Bank0 0 0 0x0000 ～ 0x007F (128 bytes) Bank1 1 0 0x0080 ～ 0x00FF (128 bytes) Bank2 0 1 0x0100 ～ 0x017F (128 bytes) Bank3 1 1 0x0180 ～ 0x01FF (128 bytes) PORTA を出力か入力かどちらに使うかの設定をするための TRISA レジスタは Bank1 にあるので、バンクを切り替えて値を設定する必要があります（PORTA は Bank0 にあります）。 バンクを切り替えて TRISA にアクセスする例を示します。</description></item><item><title>ラベル ─ PIC めもめも</title><link>https://maku77.github.io/p/zm6rg3v/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zm6rg3v/</guid><description>ラベル定義の構文 &amp;lt;ラベル名&amp;gt; EQU &amp;lt;リテラル値&amp;gt; EQU 命令を使うことによってラベルを定義することができます。 指定したラベルは、リテラル (k) として使用することができます。 変数領域が割り当てられるわけではないので、定義する時にアドレスを気にしたりする必要はありません。
例: MAX_VAL を 0xFF として定義 MAX_VAL EQU 0xFF ; MAX_VAL=0xFF これは、C 言語のプリプロセッサの #define のようなものです。
#define MAX_VAL 0xFF</description></item><item><title>変数の割り当て ─ PIC めもめも</title><link>https://maku77.github.io/p/hoytbx6/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hoytbx6/</guid><description>領域として自由に使用できる汎用レジスタの範囲 ユーザが変数領域として自由に使用できる汎用レジスタ (データ RAM) の範囲の一例です。
Device Bank0 Bank1 Bank2 Bank3 データ RAM サイズ PIC16F83PIC16CR83 0Ch ～ 2Fh(36 bytes) 8Ch ～ AFh(Bank0 へのマップ) ─ ─ 36 bytes PIC16F84PIC16CR84 0Ch ～ 4Fh(68 bytes) 8Ch ～ CFh(Bank0 へのマップ) ─ ─ 68 bytes PIC16F873PIC16F874 20h ～ 7Fh(96 bytes) A0h ～ FFh(96 bytes) ─ ─ PIC16F876PIC16F877 20h ～ 7Fh(96 bytes) A0h ～ EFh(80 bytes) 110h ～ 16Fh(96 bytes) 190h ～ 1EFh(96 bytes) PIC16F87x の Bank1 ～ 3 の最後の部分には、Bank0 へのマッピングアドレスとして使えるものがあります。 うまく使えば効率的なプログラムが作れるかもしれません。 詳しくは各デバイスのデータシートを参照してください。</description></item><item><title>汎用テクニック ─ PIC めもめも</title><link>https://maku77.github.io/p/p83uim3/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/p83uim3/</guid><description>どの Page にあるか分からないサブルーチンにジャンプする ; ; どのページにあるか分からないサブルーチンにジャンプする ; ... MOVLW HIGH(SUB) ; SUB の上位アドレス MOVWF PCLATH ; を PCLATH にセット CALL SUB ... SUB ... RETURN 特定のマスクで 2 つの値を比較 ; ; 特定のマスクで比較 (A と B を 01110000 のビットマスクで比較) ; MOVF A, W XORWF B, W ANDLW B&amp;#39;01110000&amp;#39; BTFSC STATUS, Z GOTO AB_IS_SAME ; 同じだった (→ AB_IS_SAME へ) GOTO AB_IS_NOT_SAME ; 違った (→ AB_IS_NOT_SAME へ) AB_IS_SAME ... GOTO xxx AB_IS_NOT_SAME ... GOTO xxx W レジスタの値 (0～F) を 7 セグメント LED 用の値に変換する ;============================================================================== ; W の値を 7 セグメント LED 用の値に変換します。 ; ; 使い方: ; (W に 0～9 の値が入っている時に) ; CALL TO_7SEG ;============================================================================== TO_7SEG ADDWF PCL, F ; プログラムカウンタに W の値を加える RETLW B&amp;#39;01111110&amp;#39; ; 0 の表示用 RETLW B&amp;#39;00001100&amp;#39; ; 1 の表示用 RETLW B&amp;#39;10110110&amp;#39; ; 2 の表示用 RETLW B&amp;#39;10011110&amp;#39; ; 3 の表示用 RETLW B&amp;#39;11001100&amp;#39; ; 4 の表示用 RETLW B&amp;#39;11011010&amp;#39; ; 5 の表示用 RETLW B&amp;#39;11111010&amp;#39; ; 6 の表示用 RETLW B&amp;#39;00001110&amp;#39; ; 7 の表示用 RETLW B&amp;#39;11111110&amp;#39; ; 8 の表示用 RETLW B&amp;#39;11001110&amp;#39; ; 9 の表示用</description></item><item><title>遅延時間 ─ PIC めもめも</title><link>https://maku77.github.io/p/yzbkxhz/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yzbkxhz/</guid><description>1 サイクル (1 命令) にかかる時間 1 つの命令を実行するためにかかる時間（1 サイクル）は、クロックの周期(sec) * 4、あるいは、4 / クロックの周波数(Hz) となります。 具体的な値は次のようになります。
10MHzの場合の1命令にかかる時間 ･･･ 0.1 (μsec) * 4 = 0.4 (μsec) 20MHzの場合の1命令にかかる時間 ･･･ 0.05 (μsec) * 4 = 0.2 (μsec) プログラムカウンタの値を変更する命令の場合は、2 サイクルの時間がかかります。 このような命令には CALL, GOTO, RETFIE, RETLW, RETURN があります。 また、DECFSZ, INCFSZ, BTFSC, BTFSS でスキップした場合も 2 サイクルかかります。
遅延時間を作るサブルーチン 遅延を発生させるサブルーチンを作る場合は、次のような手順で作成します。
1. 必要なサイクル数を求める サブルーチンに必要なサイクル数は、遅延時間 / 1 サイクルにかかる時間で求めることができます。 例えば、10MHz (0.4μsec) で 100μsec の遅延を作りたい場合は、100 / 0.4 = 250 サイクルが必要になります。
2. ループ回数を決める ループ回数は、(1 で求めたサイクル数 - 6) / 3 で求められます（余りは NOP で調整します）。 -6 の部分は、MOVLW, MOVWF, DECFSZ(2), RETURN のサイクルで、/3 の部分は、DECFSZ(1), GOTO の部分の実行回数を求めています。 以下にいくつかの遅延時間発生ルーチンの例を示します。</description></item><item><title>部品メモ: 3端子レギュレータ ─ PIC めもめも</title><link>https://maku77.github.io/p/hzva4rn/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hzva4rn/</guid><description>可変3端子レギュレータ LM317 大きめの四角いレギュレータ 7805 (DC, +5V 1A) は、出力電流が 1A あり、7～20V を 5±0.25V に変換できます。 ちっちゃい３端子レギュレータ 78L05 (DC, +5V 100mA) は、ひらぺったい方から見て、右の端子から IN, GND, OUT になっています。 この順番はレギュレータごとに異なる ので、必ずデータシートで確認する必要があります。7～25V を 5±0.25V に変換できます。 3端子レギュレータの配線方法 3端子レギュレータの入力、出力側に共通のグランドが必要です。 出力側のコンデンサは不要ですが、あると過渡応答を改善できます。</description></item><item><title>部品メモ: LED（Light Emitting Diode: 発光ダイオード） ─ PIC めもめも</title><link>https://maku77.github.io/p/spggmm3/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/spggmm3/</guid><description>LED の極性 LED には２つの端子があり、それぞれ下記のような名前が付けられています。
アノード (A) ･･･ 端子の長い方 (+ 電源へ) カソード (K) ･･･ 端子の短い方 (GND へ) LED の電気的特性として、順方向 (アノード → カソード) にしか電流を流さないという特徴を持っています。 順方向でも一定の電圧降下があります（1.7V 程度）。
LED へ流す電流の決め方 LED の明るさは流す電流の大きさによって変わります。 ただし、あまり大きな電流を流すと LED が壊れてしまうので、電源との間に抵抗を入れて流れる電流を調整する必要があります。 何Ωの抵抗を接続すればいいかを計算する時は、LED による電圧降下を考えて求める必要があります。
計算式: R = (V - VLED) / I
例えば、電源 (V) を 5V、適正電流 (I) を 5mA とすると、
R = (5.0 - 1.7) / 0.005 = 660 (Ω) と求められます。</description></item><item><title>部品メモ: RS-232C (Recommend Standard number 232) ─ PIC めもめも</title><link>https://maku77.github.io/p/dppsjeu/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dppsjeu/</guid><description>はじめに（用語とか） スペース状態 ･･･ 信号 0。入力 +3V 以上。出力 +5V ～ +15V。 マーク状態 ･･･ 信号 1。入力 -3V 以下。出力 -5V ～ -15V。 短絡時最大出力電流 ･･･ 500mA。 ハードウェアフローコントロール ･･･ RTS と CTS の信号線を使ったフロー制御。RTS／CTS とも記述されます。 ソフトウェアフローコントロール ･･･ ソフトウェアによるフロー制御。アプリケーションで決められた特殊な記号を送信することでフロー制御を行います。RTS と CTS ワイヤは使用しません。Xon／Xoff とも記述されます。 DTE デバイス ･･･ 通常は PC を示します。オスコネクタを持ちます。 DCE デバイス ･･･ 通常は シリアルデバイスを示します。メスコネクタを持ちます。DTE デバイスと DCE デバイスをつなぐ時は通常ストレートケーブルを用います。 ヌルモデムケーブル／ヌルアダプタ ･･･ 送信と受信の信号線をクロスさせたものです。TxD ⇔ RxD、DTR ⇔ DSR、RTS ⇔ CTS のようにクロスされます。 DSub 9 ピン （DTE デバイス（PC 側）オス）
9 ピンミニ DSUB コネクタ (PC 側オス) ピン番号表記I/O意味説明 1 DCD In Data Carrier Detect（キャリア検出） 外部端末の送受信準備ができたことを知る 2 RxD In Receive Data（受信データ） &amp;nbsp; 3 TxD Out Transmit Data（送信データ） &amp;nbsp; 4 DTR Out Data Terminal Ready（データ端末準備） PC が繋がっていることを認識させる（PC → 外部） 5 GND --- Ground（信号用グラウンド） &amp;nbsp; 6 DSR In Data Set Ready（データセット準備） 端末が繋がっていることを認識する（PC ← 外部） 7 RTS Out Request To Send (DTE の送信要求) PC の送信開始信号（フロー制御用）（PC → 外部） 8 CTS In Clear To Send（DCE の送信要求） PC への受信開始要求（フロー制御用）（PC ← 外部） 9 RI In Ring Indication（被呼表示） 電話がかかってきたことを伝える／PC の電源を制御する PC からデータを送信するのに最低限必要なのは、TxD(3) と GND(5) です。 データを受信する時は RxD(2) が必要です。 出力の信号線は、デフォルトでマーク状態(-)かスペース状態(+)のどちらかを出力してます。</description></item><item><title>部品メモ: 水晶振動子（クリスタル振動子、オシレーター） ─ PIC めもめも</title><link>https://maku77.github.io/p/yzdxf7i/</link><pubDate>Thu, 01 Aug 2002 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yzdxf7i/</guid><description>水晶振動子（クリスタル振動子）20MHz</description></item></channel></rss>