<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Octave on 天才まくまくノート</title><link>https://maku77.github.io/octave/</link><description>Recent content in Octave on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 31 Mar 2017 00:00:00 +0900</lastBuildDate><atom:link href="https://maku77.github.io/octave/index.xml" rel="self" type="application/rss+xml"/><item><title>Octave でファイルに記述した関数を実行する（関数ファイル）</title><link>https://maku77.github.io/p/o9qhvyu/</link><pubDate>Fri, 31 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/o9qhvyu/</guid><description>関数ファイルの基本 Octave で読み込む外部ファイル (.m) が、関数定義 (function) で始まっていると、そのファイルは 関数ファイル として認識され、組み込み関数のように呼び出せるようになります。
関数ファイルの名前は、ファイルの先頭で定義する関数名に合わせます。 次の例では myfunc という関数を定義しているので、ファイル名は myfunc.m とします。
myfunc.m function y = myfunc(x) y = x**2; end 上記のように関数ファイルで定義した関数は、組み込み関数と同じ感覚で呼び出すことができます。
&amp;gt;&amp;gt; myfunc(7) 49 サブファンクション 関数ファイルで定義された関数は、先頭で定義した関数だけが公開されます。 例えば、下記の関数ファイルでは、hello 関数と hello2 関数を定義していますが、外部から呼び出せる関数は hello 関数だけであり、hello2 関数はファイル内からのみ呼び出せるサブファンクション として定義されます。
hello.m % 先頭で定義されているこの関数だけが公開される function hello() disp(&amp;#39;hello&amp;#39;); hello2(); end % 以降の関数はサブファンクションとみなされて外部には公開されない function hello2() disp(&amp;#39;hello2&amp;#39;) end 実行例 &amp;gt;&amp;gt; hello hello hello2 &amp;gt;&amp;gt; hello2 % サブファンクションは外からは直接呼び出せない error: &amp;#39;hello2&amp;#39; undefined near line 1 column 1 プライベートファンクション サブファンクションは、定義したファイル内でしか呼び出すことができないので、いろいろな関数から呼び出したいヘルパー関数を作成したいときには都合が悪いです。 このような場合は、ヘルパー関数を プライベートファンクション として別の関数ファイルに分離しておきます。 作成方法は通常の関数ファイルと同様ですが、作成したファイルを private ディレクトリ内に格納するようにします。</description></item><item><title>Octave で関数を定義する (function)</title><link>https://maku77.github.io/p/vo54icm/</link><pubDate>Wed, 29 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/vo54icm/</guid><description>関数定義の基本 Octave で関数を定義するには、function ~ end の構文を使用します。 例えば、渡された数値の 2 乗を返す関数 myfunc は下記のように定義できます。
myfunc 関数を定義する function ret = myfunc(x) ret = x ** 2; end myfunc 関数を呼び出す y = myfunc(7); %=&amp;gt; 49 戻り値は return で指定するのではなく、関数値用に宣言した変数に代入することで表現することに注意してください。 上記の例では、関数値を表す変数は ret という名前で定義していますが、任意の名前を付けることができます。 もちろん、関数を途中で抜けるときは return を使用することができますが、その場合も戻り値はあらかじめ関数値用の変数に格納しておく必要があります。
途中で関数を抜ける場合 function y = f(x) if x == 0 y = -1; % 戻り値は return では返せない return end ... end 戻り値を持たない関数を定義する 戻り値を持たない関数も同様に定義できます（関数というよりサブルーチンというのが正しいのかも）。 内部で出力処理まで終わらせてしまうような関数がこれにあたります。
function greet(name) printf(&amp;#39;Hello %s\n&amp;#39;, name); end 多値関数（複数の戻り値を持つ関数）を定義する 関数値としてベクトルを返すように定義すれば、複数の戻り値を持つ関数として扱うことができます。 下記の例では、除算結果の商と剰余を返す関数を定義しています。</description></item><item><title>Octave でファイルに記述したデータを読み込む/保存する (load, save)</title><link>https://maku77.github.io/p/bi5rv73/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/bi5rv73/</guid><description>ファイルからデータを読み込む (load) Octave で、ファイルに保存したデータファイルを読み込むには、組み込み関数の load を使用します。 例えば、下記のような二次元データ（行列データ）があるとします。
mydata.txt 100 200 300 400 500 600 700 800 900 このデータファイルを読み込むには、下記のようにします（あらかじめ cd コマンドで、データファイルのあるディレクトリに移動しておいてください）。 データファイルの内容は、ファイル名と同じ名前の変数に格納されます。
データファイルを読み込む &amp;gt;&amp;gt; load mydata.txt &amp;gt;&amp;gt; mydata mydata = 100 200 300 400 500 600 700 800 900 データファイルの内容を別の名前の変数に格納したいときは、次のように load 関数の戻り値を変数に代入します。
データファイルを指定した変数に読み込む &amp;gt;&amp;gt; A = load(&amp;#39;mydata.txt&amp;#39;) A = 100 200 300 400 500 600 700 800 900 ちなみに、現在定義されている変数の一覧を表示するには、whos コマンドを使用します。
変数の一覧を表示 &amp;gt;&amp;gt; whos Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== mydata 3x3 72 double ファイルから読み込んだ mydata が、サイズ 3x3 のデータとして定義されていることが分かります。</description></item><item><title>Octave でファイルに記述したプログラムを実行する（スクリプトファイル）</title><link>https://maku77.github.io/p/mgjgq8m/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/mgjgq8m/</guid><description>スクリプトファイルと実行方法 Octave では、カレントディレクトリに スクリプト名.m という名前でスクリプトファイルを作成しておくと、下記のようにしてそのスクリプトを実行することができます。
スクリプト名.m の呼び出し &amp;gt;&amp;gt; スクリプト名 ただし、スクリプトファイルが置かれたディレクトリで実行しなければいけません。 カレントディレクトリを移動するには、cd コマンドを実行します。 次のようにしてスクリプトを格納したディレクトリに移動しましょう。
&amp;gt;&amp;gt; cd D: % D ドライブのルートへ移動 カレントディレクトリがどこになっているかを確認するには、pwd コマンドを実行します。
&amp;gt;&amp;gt; pwd ans = C:\Users\maku スクリプトの実行例 ここでは、下記のようなスクリプトファイルを用意してみます。
myscript.m [X, Y] = meshgrid(-8:.5:8); R = sqrt(X.^2 + Y.^2) + eps; Z = sin(R) ./ R; figure mesh(X, Y, Z) このファイルが置いてあるディレクトリに移動して、拡張子 .m を除いた部分の名前を入力すると、スクリプトを実行できます。
&amp;gt;&amp;gt; cd somewhere &amp;gt;&amp;gt; myscript 次のようなグラフが表示されれば成功です。
図: myscript.m によるグラフ描画</description></item><item><title>Octave で対角行列を作成する (diag)</title><link>https://maku77.github.io/p/8tddagn/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8tddagn/</guid><description>$$ diag(c_1, c_2, &amp;hellip;, c_n) = \begin{pmatrix} c_1 &amp;amp; &amp;amp; &amp;amp; 0 \\ &amp;amp; c_2 &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ 0 &amp;amp; &amp;amp; &amp;amp; c_n \end{pmatrix} $$
正方行列のうち、対角成分 (diagonal elements) 以外がすべて零のものを 対角行列 (diagonal matrix) といいます。 Octave の組み込み関数 diag を使用すると、対角行列からの対角成分の抽出や、対角成分からの対格行列の生成を行うことができます。
対角行列から対角成分を抽出する &amp;gt;&amp;gt; A = [3 0 0; 0 -1 0; 0 0 2] A = 3 0 0 0 -1 0 0 0 2 &amp;gt;&amp;gt; v = diag(A) v = 3 -1 2 抽出された対角成分は、列ベクトルとして返されます。</description></item><item><title>Octave で行列／ベクトルのサイズを変更する</title><link>https://maku77.github.io/p/xfuxvwq/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/xfuxvwq/</guid><description>行列サイズを拡張する 既存の行列の存在しない領域の要素に代入を行うと、行列のサイズが自動的に拡張されます。 下記の例では、2x2 の行列に対して、(4,4) の位置に値を代入する操作をしています。
&amp;gt;&amp;gt; A = [1 2; 3 4] A = 1 2 3 4 &amp;gt;&amp;gt; A(4, 4) = 7 A = 1 2 0 0 3 4 0 0 0 0 0 0 0 0 0 7 上記のように、行列のサイズは自動的に拡張されて、4x4 になります。 自動的に拡張されて、値が指定されていない部分の値は 0 が設定されます。
ベクトルのサイズも同様に拡張できます。
&amp;gt;&amp;gt; v = 1:3 v = 1 2 3 &amp;gt;&amp;gt; v(7) = 100 v = 1 2 3 0 0 0 100 もちろん、下記のように行列を結合した場合も、行列のサイズは自動的に拡張されることになります。</description></item><item><title>Octave の制御命令: for / while / until ループ</title><link>https://maku77.github.io/p/h9pgnw6/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/h9pgnw6/</guid><description>Octave のループ構文は、下記のようなものが用意されています。
for ループ while ループ do ~ until ループ Octave には do ~ while ループや、単純な until ループは存在しないことに注意してください。 C++ や Java と同様に、各ループ処理の中では、continue によるループ継続や、break によるループ脱出を行えます。
for ループ for x = ベクトル ... end とすると、ベクトル要素（あるいは行列要素）を 1 つずつ取り出しながらループ処理を行うことができます。 下記の例では、1～5 までの値を順番に足しこんでいく様子を表示しています。
1 ~ 5 まで合計する sum = 0 for x = 1:5 sum += x; disp(sum) end 実行結果 1 3 6 10 15 for ループは入れ子構造で記述することもできます。 下記は 2 重ループで 3x3 の行列を初期化しています。
3x3 行列の初期化 for i = 1:3 for j = 1:3 A(i, j) = i * j; end end disp(A) 実行結果 1 2 3 2 4 6 3 6 9 次の例では、行列 A の各要素をループでひとつずつ取得して表示しています。 組み込み関数の size は行列のサイズを返してくれますが、第２パラメータで 1 と 2 を指定することで、それぞれ行数、列数を返してくれるようになります。 これを利用して、正しい数だけループ処理しています。</description></item><item><title>Octave の制御命令: if ～ else</title><link>https://maku77.github.io/p/4x34ejm/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4x34ejm/</guid><description>Octave (MATLAB) の if ～ else の構文は以下のようになっています。
if (COND) ... elseif (COND) ... else ... end 条件式では下記のような比較演算子が使用できます。 特に、a と b が等しくないことを表す記号が ~= であることに注意してください。
演算子 意味 a == b a と b が等しい a ~= b a と b が等しくない a &amp;lt; b a が b より小さい a &amp;gt; b a が b より大きい a &amp;lt;= b a が b 以下 a &amp;gt;= b a が b 以上 a a が 0 以外 また、論理演算子を組み合わせて使用できます。</description></item><item><title>Octave の制御命令: switch ～ case</title><link>https://maku77.github.io/p/r9h53gn/</link><pubDate>Mon, 27 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r9h53gn/</guid><description>変数に格納された値の種類によって分岐処理を行うには、次のように switch と case で分岐させます。
val = 2 switch val case 1 disp(&amp;#39;one&amp;#39;) case 2 disp(&amp;#39;two&amp;#39;) otherwise disp(&amp;#39;other&amp;#39;) endswitch 下記のように、複数のパターンを１つの case でまとめて処理することもできます。
yesno = &amp;#39;yes&amp;#39;; switch yesno case {&amp;#39;Yes&amp;#39; &amp;#39;yes&amp;#39; &amp;#39;YES&amp;#39; &amp;#39;y&amp;#39; &amp;#39;Y&amp;#39;} value = 1; case {&amp;#39;No&amp;#39; &amp;#39;no&amp;#39; &amp;#39;NO&amp;#39; &amp;#39;n&amp;#39; &amp;#39;N&amp;#39;} value = 0; otherwise error (&amp;#39;invalid value&amp;#39;); endswitch 逆に、下記のように、複数の case を連続して記述する方法はうまくいかないので注意してください（値が 1 のケースは何も処理しないという意味になってしまいます）。
間違った書き方 switch val case 1 % 間違った書き方 case 2 disp(&amp;#39;one or two&amp;#39;) otherwise disp(&amp;#39;other&amp;#39;) endswitch</description></item><item><title>Octave ですべての要素が 1 の行列を作成する (ones)</title><link>https://maku77.github.io/p/ngxvjuy/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ngxvjuy/</guid><description>Octave の組み込み関数 ones を使用すると、すべての要素が 1 である行列を作成することができます。
&amp;gt;&amp;gt; ones(3) ans = 1 1 1 1 1 1 1 1 1 &amp;gt;&amp;gt; ones(2, 4) ans = 1 1 1 1 1 1 1 1 スカラー値を掛けることで、1 以外の任意の値にすることができます。
&amp;gt;&amp;gt; ones(2, 4) * 7 ans = 7 7 7 7 7 7 7 7 ones 関数のドキュメント &amp;gt;&amp;gt; help ones &amp;#39;ones&amp;#39; is a built-in function from the file libinterp/corefcn/data.cc -- ones (N) -- ones (M, N) -- ones (M, N, K, .</description></item><item><title>Octave でランダムな数値の行列を作成する (rand)</title><link>https://maku77.github.io/p/kyjrsit/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/kyjrsit/</guid><description>0 ～ 1 のランダムな実数を生成する 組み込み関数の rand を使用すると、(0, 1) の範囲のランダムな実数を生成することができます。
&amp;gt;&amp;gt; x = rand() x = 0.68694 パラメータとして、行列のサイズを指定することで、ランダムな数値からなる行列を生成することができます。
&amp;gt;&amp;gt; rand(3) ans = 0.21961 0.93511 0.42575 0.40439 0.57059 0.47850 0.33873 0.52912 0.58643 &amp;gt;&amp;gt; rand(2, 4) ans = 0.710878 0.077407 0.991165 0.606275 0.807493 0.428040 0.497468 0.606412 任意の範囲のランダム値を生成する 任意の数値の範囲のランダム値を生成するには、下記のような演算を行います。
例: 0 ～ 10 の範囲のランダム値を生成 &amp;gt;&amp;gt; rand * 10 ans = 8.0312 例: -5 ～ 5 の範囲のランダム値を生成 &amp;gt;&amp;gt; rand * 10 - 5 ans = -4.</description></item><item><title>Octave で出力する桁数を増やす (format)</title><link>https://maku77.github.io/p/fism9pp/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fism9pp/</guid><description>Octave の内部では倍精度の浮動小数点数（10 進数で 15 桁程度の精度）で計算が行われていますが、画面出力時のデフォルト桁数は 5 桁に設定されています。
&amp;gt;&amp;gt; pi pi = 3.1416 表示桁数を増やすには、下記のように format 関数を使用します。
表示桁数を増やす &amp;gt;&amp;gt; format long &amp;gt;&amp;gt; pi ans = 3.14159265358979 上記のように、パラメーターとして long を指定すると、倍精度実数の表現限界である 15 桁程度の数値を表示してくれるようになります。 元に戻したい場合は、パラメータなしで format 関数を実行します。
表示桁数を元に戻す &amp;gt;&amp;gt; format &amp;gt;&amp;gt; pi ans = 3.1415 format 関数で指定できるパラメータの詳細は、次のようにヘルプで確認できます。
&amp;gt;&amp;gt; help format</description></item><item><title>Octave で単位行列を作成する (eye)</title><link>https://maku77.github.io/p/h24njtn/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/h24njtn/</guid><description>eye 関数 Octave で任意のサイズの 単位行列 \(I\) を作成するには、組み込み関数の eye を使用します。
$$ I = \begin{pmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; \ldots &amp;amp; 0 \\ &amp;amp; \vdots &amp;amp; &amp;amp; \ddots &amp;amp; \vdots \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 1 \end{pmatrix} $$
&amp;gt;&amp;gt; eye(3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 &amp;gt;&amp;gt; eye(5) ans = Diagonal Matrix 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1</description></item><item><title>Octave で行列／ベクトルのサイズ（形状）を確認する (size, length)</title><link>https://maku77.github.io/p/aodnfsx/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/aodnfsx/</guid><description>行列のサイズを調べる (size) Octave の組み込み関数 size を使用すると、行列（あるいはベクトル）の形状（サイズ）を調べることができます。
&amp;gt;&amp;gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &amp;gt;&amp;gt; size(A) ans = 2 3 size メソッドの戻り値自体も、1 行 2 列の行列（行ベクトル）になっています。
&amp;gt;&amp;gt; size(size(A)) ans = 1 2 ベクトルのサイズを調べる (length) ベクトルのサイズを調べるときにも、size 関数を使用することができますが、代わりに length 関数を使用することで、スカラ値でベクトルのサイズを取得することができます。 length 関数は、行ベクトルの場合でも、列ベクトルの場合でも同様な値を返してくれます。
行ベクトルの場合 &amp;gt;&amp;gt; v = [1 2 3 4 5]; &amp;gt;&amp;gt; length(v) ans = 5 列ベクトルの場合 &amp;gt;&amp;gt; v = [1; 2; 3; 4; 5]; &amp;gt;&amp;gt; length(v) ans = 5 上記のように、行ベクトルでも列ベクトルでも共通の値を返してくれるのは、length 関数が 「行のサイズと列のサイズのうち大きい方を返す」 という振る舞いをするからです。 行列に対して length 関数を適用すると、下記のようにあまり意味のない結果を返すことになるので、length 関数はベクトル用だと思って使うのがよいでしょう。</description></item><item><title>Octave で行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う</title><link>https://maku77.github.io/p/hfgbxqq/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/hfgbxqq/</guid><description>行列同士の四則演算 下記のような 2 行 3 列の行列を 2 つ用意します。
&amp;gt;&amp;gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &amp;gt;&amp;gt; B = [10 20 30; 40 50 60] B = 10 20 30 40 50 60 各要素同士の四則演算を行うには、+、-、.*、./ という演算子を使用します。 .* と ./ は、ドットが必要なことに注意してください。
&amp;gt;&amp;gt; A + B ans = 11 22 33 44 55 66 &amp;gt;&amp;gt; A - B ans = -9 -18 -27 -36 -45 -54 &amp;gt;&amp;gt; A .</description></item><item><title>Octave で行列／ベクトルを結合する</title><link>https://maku77.github.io/p/6vpzojf/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6vpzojf/</guid><description>下記のような 2 行 3 列の行列が 2 つあるとします。
&amp;gt;&amp;gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &amp;gt;&amp;gt; B = [11 12 13; 14 15 16] B = 11 12 13 14 15 16 これらの行列を横方向、あるいは縦方向に繋げて新しい行列を作成することができます。
横方向に結合する &amp;gt;&amp;gt; C = [A B] C = 1 2 3 11 12 13 4 5 6 14 15 16 縦方向に結合する &amp;gt;&amp;gt; D = [A; B] D = 1 2 3 4 5 6 11 12 13 14 15 16 横方向に結合する場合は行のサイズ、縦方向に結合する場合は列のサイズが等しくなければいけません。 上記の例の場合は、たまたま行列 A と行列 B の形状が同じなので、どちらの方向にも結合できています。</description></item><item><title>Octave で行列／ベクトル内の要素を参照する</title><link>https://maku77.github.io/p/6ss2mk8/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6ss2mk8/</guid><description>行列内の特定の要素を参照する 下記のような 3x3 の行列があるとします。
&amp;gt;&amp;gt; A = [1 2 3; 4 5 6; 7 8 9] A = 1 2 3 4 5 6 7 8 9 この行列の 1 行 2 列の位置の要素を参照するには次のようにします。 各要素を参照する方法です。
1 行 2 列の要素を参照する &amp;gt;&amp;gt; A(1, 2) ans = 2 行列内の要素を行単位、列単位で取得する すべての行や列を表すには、: を使います。
3 行目の要素をすべて取得する（行ベクトル） &amp;gt;&amp;gt; A(3, :) ans = 7 8 9 2 列目の要素をすべて取得する（列ベクトル） &amp;gt;&amp;gt; A(:, 2) ans = 2 5 8 1 行目と 3 行目の要素をすべて取得する &amp;gt;&amp;gt; A([1 3], :) ans = 1 2 3 7 8 9 指定した位置への代入にも使用することができます。 下記の例では、3 行目の各要素を書き換えています。</description></item><item><title>Octave で逆行列を作成する (inv)</title><link>https://maku77.github.io/p/fkau9he/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fkau9he/</guid><description>$$ \begin{bmatrix} 1 &amp;amp; 2 \\ 3 &amp;amp; 4 \end{bmatrix}^{-1} = \begin{bmatrix} -2 &amp;amp; 1 \\ 1.5 &amp;amp; -0.5 \end{bmatrix} $$
Octave で行列 \(A\) の逆行列 \(A^{-1}\) を求めるには、組み込み関数の inv を使用します。
&amp;gt;&amp;gt; A = [1 2; 3 4] A = 1 2 3 4 &amp;gt;&amp;gt; inv(A) ans = -2.00000 1.00000 1.50000 -0.50000 元の行列と逆行列の積は、単位行列になります（\(AA^{-1} = A^{-1}A = I\)）。
&amp;gt;&amp;gt; A * inv(A) ans = 1.00000 0.00000 0.00000 1.00000 &amp;gt;&amp;gt; inv(A) * A ans = 1.</description></item><item><title>Octave で零行列（ゼロ行列）を作成する</title><link>https://maku77.github.io/p/o9bmzfy/</link><pubDate>Fri, 24 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/o9bmzfy/</guid><description>zeros 関数 $$ O = \begin{pmatrix} 0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ 0 &amp;amp; 0 &amp;amp; \ldots &amp;amp; 0 \end{pmatrix} $$
Octave でゼロ行列 (zero vector) を作成するには、組み込みの zeros 関数を使用します。
&amp;gt;&amp;gt; O = zeros(3) O = 0 0 0 0 0 0 0 0 0 &amp;gt;&amp;gt; O = zeros(2, 4) O = 0 0 0 0 0 0 0 0 zeros のドキュメント &amp;gt;&amp;gt; help zeros &amp;#39;zeros&amp;#39; is a built-in function from the file libinterp/corefcn/data.</description></item><item><title>Octave で行列／ベクトルを作成する</title><link>https://maku77.github.io/p/65afkmg/</link><pubDate>Thu, 23 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/65afkmg/</guid><description>行列の定義 ３行２列 $$ A = \begin{bmatrix} 1 &amp;amp; 2 \\ 3 &amp;amp; 4 \\ 5 &amp;amp; 6 \end{bmatrix} $$
A = [1 2; 3 4; 5 6]; 行ごとにセミコロンで区切ります。
２行３列 $$ A = \begin{bmatrix} 1 &amp;amp; 2 &amp;amp; 3 \\ 4 &amp;amp; 5 &amp;amp; 6 \end{bmatrix} $$
&amp;gt;&amp;gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 ベクトルの定義 行ベクトル (row vector) $$ v = \begin{bmatrix} 1 &amp;amp; 2 &amp;amp; 3 \end{bmatrix} $$</description></item><item><title>Octave で転置行列を作成する</title><link>https://maku77.github.io/p/a7z6ojh/</link><pubDate>Thu, 23 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/a7z6ojh/</guid><description>転置行列を求める $$ {A} = \left[ \begin{array}{ccc} 1 &amp;amp; 2 &amp;amp; 3 \\ 4 &amp;amp; 5 &amp;amp; 6 \end{array} \right] $$
$$ {A}^{\mathrm{T}} = \left[ \begin{array}{cc} 1 &amp;amp; 4 \\ 2 &amp;amp; 5 \\ 3 &amp;amp; 6 \end{array} \right] $$
行列 A の転置行列 (transposed matrix) である \(A^T\) は、ダッシュ記号 (') を付加するだけで求められます。
&amp;gt;&amp;gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &amp;gt;&amp;gt; A&amp;#39; ans = 1 4 2 5 3 6 転置行列と共役転置行列 A' で得られる行列は、正確には 共役転置行列 であり、転置行列の各要素の複素共役をとったものになっています。 各要素の値が実数の場合は違いはありませんが、複素数が含まれていると結果が変わってきます。</description></item></channel></rss>