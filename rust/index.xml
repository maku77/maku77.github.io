<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on 天才まくまくノート</title><link>https://maku77.github.io/rust/</link><description>Recent content in Rust on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 13 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust の文法: 制御構文 (if, while, loop, for)</title><link>https://maku77.github.io/p/22cnw7f/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/22cnw7f/</guid><description>条件分岐 if 文 (if statement) if n &amp;gt; 0 { println!(&amp;#34;{} is positive&amp;#34;, n); } else if n &amp;lt; 0 { println!(&amp;#34;{} is negative&amp;#34;, n); } else { println!(&amp;#34;{} is zero&amp;#34;, n); } C/C++ と異なり、条件式は () で囲む必要はありません。 ただし、ブロック部分は必ず {} で囲む必要があります。
if 式 (if expression) Rust の if は式として扱うことができるので、分岐後に評価した値を参照することができます（Kotlin などのモダンな言語と同様です）。 下記の変数 s には、n の値に応じて Good あるいは Bad が格納されます。
let s = if n &amp;gt; 0 { &amp;#34;Good&amp;#34; } else { &amp;#34;Bad&amp;#34; }; if を式として使う場合は、必ず else 句が必要なことに注意してください。 また、評価後の値（上記の例では &amp;quot;Good&amp;quot; や &amp;quot;Bad&amp;quot;）の後ろには、セミコロン (;) を付けてはいけません。</description></item><item><title>Rust の文法: 所有権 (ownership) と借用 (borrow)</title><link>https://maku77.github.io/p/4nx8hqy/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4nx8hqy/</guid><description>所有権 (ownership) Rust においてヒープ上で管理される値には 所有権 (ownership) という概念があり、必ず 1 つの変数だけが所有権を保持しています。 所有権を持つ変数が関数などのスコープから外れるときに、メモリが解放され、値が破棄されます。 この仕組み（制約）により、Rust では、ヒープ上に確保された値がどこで解放されるかをコンパイル時に決定できるようになっています（Java のようなガーベジコレクションが必要ありません）。
Rust で独特なのは、所有権が変数間で移動するところで、次のような操作を行ったときに所有権が移動します（この振る舞いを move と呼びます）。
代入演算子 (=) で別の変数に代入したとき 関数の引数として変数を渡したとき 関数の戻り値として変数を返したとき 代入による所有権の移動 // ヒープ上に String インスタンスが確保され、変数 s1 が所有者 (owner) となる let s1 = String::from(&amp;#34;Hello&amp;#34;); // s1 の所有権が s2 に移動 (move) し、s1 は無効化される let s2 = s1; // コンパイルエラー！（ここでは s1 はもう使えない） println!(&amp;#34;{}, {}&amp;#34;, s1, s2); 次のように clone メソッドで明示的なディープコピーを行えば、所有権は移動しません。 ヒープ上の新しい領域に値がコピーされ、それぞれの変数が別の値の所有者となるからです。
let s1 = String::from(&amp;#34;Hello&amp;#34;); let s2 = s1.clone(); // ディープコピー // s1 も s2 も独立した値の所有者なので両方アクセスできる println!</description></item><item><title>Rust の文法: 構造体 (struct) を定義する</title><link>https://maku77.github.io/p/h8kw8ju/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/h8kw8ju/</guid><description>構造体の基本 Rust の構造体の定義とインスタンス化は直感的です。 文字列フィールドの型としては、&amp;amp;str（文字列スライス）ではなく String を使うことで、構造体インスタンス自身が文字列の所有者になることができます。
// 構造体の定義 struct User { name: String, email: String, sign_in_count: u64, active: bool, } // インスタンス化 let user = User { email: String::from(&amp;#34;maku@example.com&amp;#34;), name: String::from(&amp;#34;maku&amp;#34;), active: true, sign_in_count: 1, }; // フィールドの参照にはドットを使う println!(&amp;#34;{}&amp;#34;, user.name); 構造体インスタンスの参照（借用）経由でフィールドにアクセスする場合もドットが使えます。
let user_ref = &amp;amp;user; // 借用 (borrow) して参照を作成 println!(&amp;#34;{}&amp;#34;, user_ref.name); // 参照のフィールドもドットでアクセスする 可変な構造体 インスタンス生成時に let の代わりに let mut を使うと、可変 (mutable) なインスタンスとなり、すべてのフィールドに再代入可能になります（一部のフィールドだけを再代入可能にすることはできません）。
let mut user = User { // ... }; // 各フィールドに別の値を代入可能 user.</description></item><item><title>Rust の文法: 配列 (array) とタプル (tuple)</title><link>https://maku77.github.io/p/7r3cmv6/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7r3cmv6/</guid><description>配列 (array) 配列の基本 Rust の配列は、多くの言語と同様に [] を使って生成することができます。 配列の要素の型はすべて同一である必要があり、配列サイズ（要素数）は不変です。 要素数をあらかじめ固定できない場合は、配列の代わりに ベクター (Vec) 型 を使います。
let arr = [0, 1, 2]; // [i32; 3] let arr = [&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;]; // [&amp;amp;str; 3] let arr = [true, false, true]; // [bool; 3] 要素の参照は、C/C++ と同様に 0 始まりのインデックス指定で行えます (arr[0])。 配列のサイズ（要素数）は arr.len() で取得できます。
println!(&amp;#34;{}, {}, {}&amp;#34;, arr[0], arr[1], arr[2]); println!(&amp;#34;len={}&amp;#34;, arr.len()); 可変配列 (mutable array) 要素を変更可能にしたいときは、次のように let mut で配列を定義します（配列のサイズや型を変更することはできません）。
let mut arr = [&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;]; arr[1] = &amp;#34;XXX&amp;#34;; println!</description></item><item><title>Rust でハッシュマップ型 (HashMap) を扱う</title><link>https://maku77.github.io/p/eefwaa3/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eefwaa3/</guid><description>ハッシュマップの基本 Rust の標準ライブラリとして、キー＆バリューのコレクションを扱うハッシュマップ型 (HashMap&amp;lt;K, V&amp;gt;) が用意されています。
下記は、空のハッシュマップを作成し、キー＆バリューを追加／取得する例です。
use std::collections::HashMap; let mut map = HashMap::new(); map.insert(String::from(&amp;#34;AAA&amp;#34;), 100); map.insert(String::from(&amp;#34;BBB&amp;#34;), 200); map.insert(String::from(&amp;#34;CCC&amp;#34;), 300); println!(&amp;#34;{:?}&amp;#34;, map.get(&amp;#34;AAA&amp;#34;)); //=&amp;gt; Some(100) println!(&amp;#34;{:?}&amp;#34;, map.get(&amp;#34;ZZZ&amp;#34;)); //=&amp;gt; None 上記の例では、HashMap の型パラメーターを省略していますが、insert しているデータから、キーの型は String、値の型は i32 と推測されます。 HashMap のキーの型が String であっても、get メソッドの引数には &amp;amp;str を渡せるようになっています。
ハッシュマップの生成方法 空のハッシュマップを生成する (new, with_capacity) let mut map: HashMap&amp;lt;String, i32&amp;gt; = HashMap::new(); let mut map: HashMap&amp;lt;String, i32&amp;gt; = HashMap::with_capacity(100) 空のマップは new で生成できますが、あらかじめ格納する要素数を想定できるときは with_capacity を使うと効率的です。 HashMap 型には、Vec 型の vec! のようなインスタンス生成用のマクロは用意されていないので、これらの関数を使ってインスタンスを生成する必要があります。 空のハッシュマップには何らかのデータを詰める必要があるので、通常は mutable な変数として定義します。</description></item><item><title>Rust で Excel ファイルを読み込む (calamine)</title><link>https://maku77.github.io/p/4ye2eah/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ye2eah/</guid><description>calamine とは Rust の calamine クレートは、Excel ファイルを読み込むためのライブラリです。
calamine - Rust tafia/calamine: A pure Rust Excel/OpenDocument SpeadSheets file reader: rust on metal sheets 読み込み専用 (read-only) のライブラリですが、ピュアな Rust 実装で軽量です。 作者の tafia (Johann Tuffe) 氏によると、「書き込み (write) はめっちゃ複雑だから対応しないよ。セルのアップデートくらいなら対応するかもね」とのこと。
Rust プロジェクトで次のように依存関係を追加すれば準備完了です。
$ cargo add calamine 以下、Excel ファイルを読み込むサンプルコードです。
ワークシート名のリストを取得する (Xlsx#sheet_names) open_workbook で Excel ファイルを開いて、Xlsx インスタンスを取得するところがすべての始まりです。 Xlsx#sheet_names メソッドで、ワークシート名の一覧を取得できます。
use calamine::{Reader, Xlsx}; fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; { let workbook: Xlsx&amp;lt;_&amp;gt; = calamine::open_workbook(&amp;#34;sample.xlsx&amp;#34;)?; let sheet_names = workbook.sheet_names(); println!</description></item><item><title>Rust でコマンドライン引数を扱う (2) clap クレート</title><link>https://maku77.github.io/p/bdp2doy/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bdp2doy/</guid><description>clap とは？ clap クレート は、コマンドライン引数のパーサーライブラリで、次のような機能を備えています。
一般的なオプション形式（-a や --name val）や、サブコマンド形式の引数のパース ヘルプ出力 (usage) の自動生成 シェル用の入力補完スクリプト生成（clap_complete クレート） derive マクロにより多くのボイラプレートコードを自動生成してくれるので、コードをシンプルに保ちつつ、高度なコマンドライン引数処理を行うことができます。
clap を使う準備 clap クレートを使うために、最初に Cargo.toml に依存関係を追加しておきます。
clap クレートを使う準備 $ cargo add clap --features derive derive マクロを有効にするために、--features derive オプションが必要です。 次のように依存関係が追加されていれば OK です。
Cargo.toml [dependencies] clap = &amp;#34;4.0.32&amp;#34; clap の基本 任意の構造体定義に、clap が提供する #[derive(Parser)] マクロを付加することで、コマンドライン引数用のバッファとして使えるようになります。
src/main.rs use clap::Parser; /// ヘルプ出力の最初に表示されるテキスト #[derive(Parser)] struct Args { /// 1 番目のパラメーターの説明として表示されるテキスト first: String, /// 2 番目のパラメーターの説明として表示されるテキスト second: u32, } fn main() { let args = Args::parse(); println!</description></item><item><title>Rust で JSON フォーマットを扱う (serde)</title><link>https://maku77.github.io/p/xdyk5o8/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xdyk5o8/</guid><description>Serde とは？ Rust の serde クレート は、Rust プログラム内で定義したユーザー型（struct や enum）を、JSON や YAML、BSON といった様々なデータ形式にシリアライズ／デシリアライズするためのライブラリです。 Serde という名前は、Serialize ＋ Deserialize から来ています。 発音は、すぁーでぃ です。
Serde website serde API documentation Serde を使う準備 Serde を使うためには、ベースとなる serde クレートに加えて、扱いたいデータフォーマット用のクレート（Serializer / Deserialize 実装）を依存関係に追加しておく必要があります。　例えば、JSON であれば serde_json、YAML であれば serde_yaml です。
serde 本体と各データフォーマット用の依存を追加 $ cargo add serde --features=derive $ cargo add serde_json # データフォーマットとして JSON を使う場合 Serde の derive マクロを有効にするために、--features=derive オプションを指定する必要があることに注意してください。 Cargo.toml に次のような依存関係が追加されていれば準備 OK です。
Cargo.toml [dependencies] serde = { version = &amp;#34;1.</description></item><item><title>Rust で正規表現を扱う (regex)</title><link>https://maku77.github.io/p/r7sdwgy/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r7sdwgy/</guid><description>Rust の regex クレート を使うと、正規表現を使った様々な文字列処理を行うことができます。 Rust (Cargo) プロジェクト内で以下のように実行して Cargo.toml に依存関係を追加すれば regex の使用準備は完了です。
$ cargo add regex Cargo.toml [dependencies] regex = &amp;#34;1.7.0&amp;#34; パターンに一致するか調べる (is_match) Regex#is_match メソッドを使うと、引数で渡した文字列に、Regex のパターンに一致する部分文字列が含まれているかを調べることができます。
use regex::Regex; let re = Regex::new(r&amp;#34;\d{4}-\d{2}-\d{2}&amp;#34;).unwrap(); let input = &amp;#34;Today&amp;#39;s date is 2023-01-07.&amp;#34;; if re.is_match(input) { println!(&amp;#34;日付らしき文字列が見つかりました&amp;#34;); } Regex#is_match メソッドは、パターンに一致する文字列が部分的にでも見つかれば true を返します。 文字列全体がパターンに一致するかどうかを調べたい場合は、パターンに ^（行頭）と $（行末）を含めて、r&amp;quot;^\d{4}-\d{2}-\d{2}$&amp;quot; のようにします。
パターンに一致した位置を調べる (find, find_iter) Regex#find メソッドは、パターンに一致する部分文字列が見つかったときに regex::Match オブジェクトを返します。 見つからない場合は Option::None を返します。 Match のメソッドを使って、実際に一致した部分文字列や、その位置を取得できます。
連続する数値を探す let re = Regex::new(r&amp;#34;\d+&amp;#34;).unwrap(); let input = &amp;#34;server: ok=100 changed=50 unreachable=0 failed=3&amp;#34;; match re.</description></item><item><title>Rust の Result オブジェクトを消費せずに参照する (as_ref, as_mut)</title><link>https://maku77.github.io/p/z3gts64/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z3gts64/</guid><description>通常、Result オブジェクトを match や unwrap、ok メソッドでハンドルすると、その Result は消費されます（所有権が移動します）。 この振る舞いを防ぐには、as_ref や as_mut メソッドを使います。
std::result::Result のメソッド pub const fn as_ref(&amp;amp;self) -&amp;gt; Result&amp;lt;&amp;amp;T, &amp;amp;E&amp;gt; pub fn as_mut(&amp;amp;mut self) -&amp;gt; Result&amp;lt;&amp;amp;mut T, &amp;amp;mut E&amp;gt; as_ref メソッドで取得した Result オブジェクト経由で Ok/Err を参照すれば、それらのオブジェクトが消費されずに済みます。
let ok_opt = result.as_ref().ok(); // 借用 (borrow) // ... // ここでまだ result の Ok/Err は有効</description></item><item><title>Rust の Result のエイリアス型でコードを簡潔にする</title><link>https://maku77.github.io/p/ez9gpw5/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ez9gpw5/</guid><description>std::io モジュールの関数は、戻り値として Result&amp;lt;T, std::io::Error&amp;gt; 型のオブジェクトを返すのですが、後ろの std::io::Error はいつも同じなので、これを省略して記述できるように、次のような std::io::Result というエイリアス型が定義されています。
std::io::Result pub type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Error&amp;gt;; // 後ろの Error は std::io::Error std::result::Result とは別物なので注意してください。 std::io::Result を使うと、例えば、String を成功値 (Ok バリアントのフィールド) とする Result は、io::Result&amp;lt;String&amp;gt; と簡潔に記述することができます。 下記が具体的な使用例です。
use std::io; /// 標準入力から 1 行読み込みます fn get_string() -&amp;gt; io::Result&amp;lt;String&amp;gt; { let mut buffer = String::new(); io::stdin().read_line(&amp;amp;mut buffer)?; Ok(buffer) } この io::Result&amp;lt;String&amp;gt; は、実際には std::result::Result&amp;lt;String, std::io::Error&amp;gt; と同等です。
関数の処理が成功したときに値を返す必要がない（Ok バリアントのデータが必要ない）場合は、もっとシンプルに io::Result&amp;lt;()&amp;gt; という型になります。
fn foo() -&amp;gt; io::Result&amp;lt;()&amp;gt; { // ... Ok(()) } Result&amp;lt;()&amp;gt; といった表現が出てきた場合、どこかにこういったエイリアス型が定義されているはずです。</description></item><item><title>Rust の各種ライブラリのエラー型と Error トレイト</title><link>https://maku77.github.io/p/8amv5eo/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8amv5eo/</guid><description>いろんな Error 型 Rust には、成功と失敗を表現するための標準的な型である std::result::Result 型が用意されています。
std::result::Result enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } Result を返す関数内でエラーが発生した場合は、Err バリアントのフィールドに具体的なエラーオブジェクトを詰めて返すことになるのですが、このエラーオブジェクトの型として、各ライブラリが独自のエラー型を定義しています。 下記はその一例です。
std::io::Error std::fmt::Error std::str::Utf8Error std::num::ParseIntError Error トレイト Rust は共通のエラーインタフェースとして、次のような std::error::Error トレイト を定義しています。 前述の各種エラー型は、この Error トレイトを実装しています。
pub trait Error: Debug + Display { fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn Error + &amp;#39;static)&amp;gt; { ... } fn description(&amp;amp;self) -&amp;gt; &amp;amp;str { ... } fn cause(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;dyn Error&amp;gt; { ... } fn provide(&amp;amp;&amp;#39;a self, demand: &amp;amp;mut Demand&amp;lt;&amp;#39;a&amp;gt;) { .</description></item><item><title>Rust でベクター型 (Vec) を扱う</title><link>https://maku77.github.io/p/jku3biq/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jku3biq/</guid><description>Vec 型とは？ Rust のベクター型 (Vec&amp;lt;T&amp;gt;) は、特定の型 (T) の要素を保持する可変長配列です。 次の例では、Vec::new 関数で空の Vec&amp;lt;i32&amp;gt; インスタンスを作成し、push メソッドにより動的に要素を追加しています。
let mut v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // 型は推論されるので省略可能 v.push(10); v.push(20); v.push(30); println!(&amp;#34;{:?}&amp;#34;, v); //=&amp;gt; [10, 20, 30] 動的に要素を追加／削除するためには、Vec 変数は mut を付けて定義しておく必要があります。 この例の場合、push メソッドの使い方から、要素の型は i32 であることが推測されるので、Vec インスタンスの作成時に型注釈を省略することができます（ほとんどのケースでは省略できます）。
let mut v = Vec::new(); Vec インスタンスの作成方法 // 空の Vec を作成する let mut v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // vec! マクロで初期値を指定して作成する let mut v: Vec&amp;lt;i32&amp;gt; = vec![]; let mut v = vec![10, 20, 30]; let mut v = vec!</description></item><item><title>Rust で列挙型 (enum) を定義して match、if let で照合する</title><link>https://maku77.github.io/p/ffqyajs/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ffqyajs/</guid><description>列挙型は、あらかじ定義された値（列挙子、バリアント、variant）の内、いずれかの値をとることができる型です。 Rust の列挙型は、各バリアントに任意の値を保持することができるので非常に強力です。 列挙型は構造体 (struct) と同様に、impl ブロックを使ったメソッド定義を行えます。
列挙型の基本 列挙型は enum キーワードを使って定義します。 列挙型がとりうる値のことを バリアント (variant) と呼びます。 次の Fruit 列挙型は、バリアントとして Apple、Banana、Orange を持ちます。
enum 型を定義する enum Fruit { Apple, Banana, Orange, } match 構文によりパターンマッチにより、列挙型変数の値に基づいて分岐処理を行うことができます。 下記は 3 つのパターンがありますが、これらのパターンごとの記述を Rust ではアーム (arm) と呼びます。 各アームはカンマ (,) で区切って記述します。
match による分岐 let f = Fruit::Banana; match f { Fruit::Apple =&amp;gt; println!(&amp;#34;I like apples&amp;#34;), Fruit::Banana =&amp;gt; println!(&amp;#34;I like bananas&amp;#34;), Fruit::Orange =&amp;gt; println!(&amp;#34;I like oranges&amp;#34;), } Rust の match は式として扱われる ので、評価結果を変数などで受け取ることができます。</description></item><item><title>Rust の Option 型の基本 ─ 値の有無を表現する型</title><link>https://maku77.github.io/p/9m6m5m3/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9m6m5m3/</guid><description>Option 型とは？ 多くのオブジェクト指向言語には、オブジェクトが存在しないことを示す null という値が用意されていますが、Rust には null は存在しません。 Rust の設計者は、null という概念が不具合の温床となっていると判断しました。 その代わりに、Rust には Option という組み込みの列挙型 (enum) が用意されており、ある値が存在しているか を表現できるようになっています。 そして、この設計は null を使った表現よりも柔軟で、かつ安全です。
Option 型の定義はとてもシンプルで、次のような感じになっています。
Option 型の定義 pub enum Option&amp;lt;T&amp;gt; { Some(T), None, } Some バリアントが「（任意の型 T の）値が存在する」ことを示し、None バリアントが「値が存在しない」ことを示します。 つまり、Some と None で値の有無を表現しつつ、値が存在する場合はその値を Some バリアントから取り出せるようになっています。
例えば、値が存在しないかもしれない String 型（他の言語では Nullable な String 型）は、Option&amp;lt;String&amp;gt; 型として表現することができ、その Some 値と None 値を次のように生成できます。
let some_val: Option&amp;lt;String&amp;gt; = Some(String::from(&amp;#34;Hello&amp;#34;)); let none_val: Option&amp;lt;String&amp;gt; = None; こんな感じで別名を付けると理解しやすいでしょうか。
type NullableString = Option&amp;lt;String&amp;gt;; let some_val: NullableString = Some(String::from(&amp;#34;Hello&amp;#34;)); let none_val: NullableString = None; Option 型のバリアントは頻繁に使用するため、Option::Some や Option::None ではなく、Some や None と記述できるようになっています。 これらのシンボルは、Rust の初期化処理 (prelude) でロードされるからです。</description></item><item><title>Rust でコマンドライン引数を扱う (1) std::env::args</title><link>https://maku77.github.io/p/wu6gqz9/</link><pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wu6gqz9/</guid><description>Rust プログラムに渡されたコマンドライン引数を扱う方法として、std::env::args 関数 を使う方法を説明します。 この関数は標準で呼び出すことができるのでお手軽ですが、リッチなコマンドライン引数を提供したいときは、clap クレートを使う方法 がおすすめです。
std::env::args の基本 std::env::args 関数は、イテレート可能な std::env::Args オブジェクトを返します。 1 番目の要素には実行したファイルの名前（相対パス）が含まれており、2 番目以降にコマンドライン引数が格納されています。
src/main.rs use std::env; fn main() { // std::env::Args を取得してループ処理 for arg in env::args() { println!(&amp;#34;{arg}&amp;#34;); // arg は単純な String 型 } } cargo run でコマンドを実行する場合、プログラムに渡すコマンドライン引数は、次のように -- の後ろに指定します。
実行例 $ cargo -q run -- --aaa 100 200 target/debug/sample --aaa 100 200 -- というセパレーターを入れないと、--aaa オプションが、cargo 側のオプションとして渡されてしまうので注意してください。
Iterator トレイトの nth メソッド を使って、インデックス指定で参照することもできます。 ユーザーがコマンドライン引数を指定しなかった場合は、Option::None が返されることに注意してください。
let first_arg: String = std::env::args().</description></item><item><title>Rust で自作したプログラムをシステムにインストールする (cargo install)</title><link>https://maku77.github.io/p/owbo2dp/</link><pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/owbo2dp/</guid><description>何をするか？ Rust で自作したコマンドラインツール (CLI) は、プロジェクトのワーキングディレクトリ以下で cargo run で実行できますが、毎回ディレクトリを移動するのは面倒です。 cargo install コマンド で、パスの通ったディレクトリに実行ファイルをインストールすれば、どのディレクトリからでもコマンドを実行できるようになります。
自作コマンドをインストールする (cargo install) Rust のプロジェクトがなければ、次のように適当に作ってください。 ここでは、hello-rust という名前のプログラムを作成することにします。
$ cargo new ~/hello-rust $ cd ~/hello-rust ローカルで開発している Rust プログラムをシステムにインストールするには、次のように cargo install コマンドを実行します。 このとき、--path オプションで Cargo.toml ファイルがあるディレクトリを指定する必要があります。 自動的にリリースモードでビルド (cargo build -r) してからインストールしてくれるので、あらかじめビルドしておく必要はありません。
$ cargo install --path . Installing hello-rust v0.1.0 (/Users/maku/hello-rust) Compiling hello-rust v0.1.0 (/Users/maku/hello-rust) Finished release [optimized] target(s) in 0.35s Installing /Users/maku/.cargo/bin/hello-rust Installed package `hello-rust v0.1.0 (/Users/maku/hello-rust)` (executable `hello-rust`) 生成された実行ファイル (hello-rust) は、~/.</description></item><item><title>ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf)</title><link>https://maku77.github.io/p/36hr2bj/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/36hr2bj/</guid><description>Path と PathBuf Rust には、ファイルやディレクトリのパス情報を扱うための std::path::Path struct が用意されています。 Path の mutable 版（可変）である、std::path::PathBuf struct を使うと、パス情報を動的に組み立てていくことができます。
次の例では、パス形式の文字列リテラルから Path と PathBuf のインスタンスを生成しています。
use std::path::{Path, PathBuf}; fn main() { let path = Path::new(&amp;#34;/dir1/dir2/file.txt&amp;#34;); let path_buf = PathBuf::from(&amp;#34;/dir1/dir2/file.txt&amp;#34;); println!(&amp;#34;{:?}&amp;#34;, path); //=&amp;gt; &amp;#34;/dir1/dir2/file.txt&amp;#34; println!(&amp;#34;{:?}&amp;#34;, path_buf); //=&amp;gt; &amp;#34;/dir1/dir2/file.txt&amp;#34; } ☝️ パスを文字列で取り出す Path や PathBuf インスタンスから、パスを表現する文字列を取得したければ次のように記述できます。
let path = Path::new(&amp;#34;/aaa/bbb/ccc&amp;#34;); let s = path.to_string_lossy(); assert_eq!(s, &amp;#34;/aaa/bbb/ccc&amp;#34;); ただ、実際のプロダクトコード内でパス情報を扱うときは、Path オブジェクトのまま扱った方が都合がよいので、実際にこのような処理が必要になることはあまりありません。 例えば、ファイルを扱う std::fs モジュールの各種関数は、パスを表す文字列と Path インスタンスのどちらも扱えるようになっています。
パスを分解する Path や PathBuf の、次のようなメソッドを使うことで、/dir1/dir2/file.txt のようなパス文字列から、親ディレクトリ名や、ベースネーム、拡張子名などを抽出することができます。</description></item><item><title>ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf)</title><link>https://maku77.github.io/p/fbkt3ah/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fbkt3ah/</guid><description>Path や PathBuf 構造体が備えている is_file メソッドや is_dir メソッドを使うと、そのそのパスに対応するファイルやディレクトリが存在するかを調べることができます。 他にも、パスが絶対パスか相対パスかを調べるメソッドなどが用意されています。
メソッド名 戻り値の型 意味 Path::is_file() bool そのパスが示す ファイルが存在するか を調べます。シンボリックリンクの場合は、リンク先のファイルが存在するかを調べます。ファイルのアクセス権がない場合は、false を返します。 Path::is_dir() bool そのパスが示す ディレクトリが存在するか を調べます。シンボリックリンクの場合は、リンク先のディレクトリが存在するかを調べます。ディレクトリのアクセス権がない場合は、false を返します。 Path::is_symlink() bool そのパスが示す シンボリックファイルが存在するか を調べます。リンク先のファイルやディレクトリが存在するかまではチェックしません（シンボリックリンクが壊れていても true を返します）。 Path::is_absolute() bool そのパスが 絶対パスか を調べます。 Path::is_relative() bool そのパスが 相対パスか を調べます。 Path::has_root() bool そのパスが ルートセパレーターを持つか を調べます（ほぼ is_absolute と同義）。 use std::path::Path; fn main() { // 存在するファイル（相対パス指定）の場合 let path = Path::new(&amp;#34;Cargo.toml&amp;#34;); assert_eq!(path.is_file(), true); assert_eq!(path.is_dir(), false); assert_eq!(path.is_symlink(), false); assert_eq!(path.is_absolute(), false); assert_eq!(path.is_relative(), true); assert_eq!(path.has_root(), false); // 存在しないファイル（絶対パス指定）の場合 let path = Path::new(&amp;#34;/nonexisting/file/path&amp;#34;); assert_eq!</description></item><item><title>Rust でディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all)</title><link>https://maku77.github.io/p/zju5eow/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zju5eow/</guid><description>ディレクトリを作成する (create_dir) Rust でディレクトリを作成するには、std::fs::create_dir 関数 を使用します。
カレントディレクトリに aaa ディレクトリを作成 use std::fs; fn main() -&amp;gt; std::io::Result&amp;lt;()&amp;gt; { fs::create_dir(&amp;#34;aaa&amp;#34;)?; Ok(()) } すでに同名のディレクトリが存在している場合など、ディレクトリを作成できない場合はエラーが発生します。
use std::fs; fn main() { match fs::create_dir(&amp;#34;aaa&amp;#34;) { Ok(_) =&amp;gt; println!(&amp;#34;ディレクトリを作成しました&amp;#34;), Err(_) =&amp;gt; eprintln!(&amp;#34;ディレクトリを作成できませんでした&amp;#34;), } } 複数階層のディレクトリを作成する (create_dir_all) 深い階層のディレクトリを一気に作成するには、create_dir の代わりに create_dir_all 関数 を使用します。 このメソッドは、すでに存在しているディレクトリを指定してもエラーにならない ので、create_dir より使い勝手はよいかもしれません。
aaa/bbb/ccc ディレクトリが存在しなければ作成する use std::fs; fn main() { fs::create_dir_all(&amp;#34;aaa/bbb/ccc&amp;#34;).unwrap(); // 成功する前提で unwrap } ディレクトリを削除する (remove_dir) 既存の（空の）ディレクトリを削除するには、std::fs::remove_dir 関数を使用します。 この関数は、Linux の rmdir コマンドと同様、空のディレクトリしか削除できないことに注意してください（DirectoryNotEmpty エラーが発生します）。 存在しないディレクトリを削除しようとした場合もエラーが発生します。
ディレクトリ aaa を削除する use std::fs; fn main() -&amp;gt; std::io::Result&amp;lt;()&amp;gt; { fs::remove_dir(&amp;#34;aaa&amp;#34;)?</description></item><item><title>Rust でディレクトリ内のファイルを列挙する (fs::read_dir)</title><link>https://maku77.github.io/p/2kv6eub/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2kv6eub/</guid><description>read_dir 関数の基本 Rust の標準モジュール std::fs の read_dir 関数 を使うと、ディレクトリ内のファイルやディレクトリを列挙することができます。
std::fs::read_dir 関数 pub fn read_dir&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; Result&amp;lt;ReadDir&amp;gt; 列挙結果には、カレントディレクトリ (.) や親ディレクトリ (..) は含まれないので、自然な列挙が可能です。
src/main.rs use std::fs; fn main() { let entries = fs::read_dir(&amp;#34;.&amp;#34;).unwrap(); // ReadDir を取得 // ループで Result&amp;lt;DieEntry, Error&amp;gt; をひとつずつ処理 for entry in entries { // DirEntry#file_name() でファイル名（ディレクトリ名）を取得できる println!(&amp;#34;{:?}&amp;#34;, entry.unwrap().file_name()); } } 実行結果 &amp;#34;Cargo.toml&amp;#34; &amp;#34;target&amp;#34; &amp;#34;Cargo.lock&amp;#34; &amp;#34;.gitignore&amp;#34; &amp;#34;.git&amp;#34; &amp;#34;src&amp;#34; エラーチェックする 上記ではコードを簡素化するために Result#unwrap メソッドを使っていますが、万が一 Err 値が返された場合は panic が発生してしまうので、プロダクトコードでは unwrap メソッドは使うべきではありません。 Result が Ok 値を持っているかを調べつつ、その値を取り出すには、次のように if let 構文を使用できます。</description></item><item><title>Rust でファイルやディレクトリの名前を変更（移動）する (std::fs::rename)</title><link>https://maku77.github.io/p/raiqzbr/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/raiqzbr/</guid><description>Rust でファイルやディレクトリの名前を変更するには、std::fs::rename 関数 を使用します。 rename 関数は、ファイルの移動にも使用できます。
ファイルの名前を変更する a.txt を b.txt にリネームする use std::{fs, io}; fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; { fs::rename(&amp;#34;a.txt&amp;#34;, &amp;#34;b.txt&amp;#34;)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイル名の代わりにディレクトリ名を指定すれば、ディレクトリ名を変更することができます。
rename 関数には Path インスタンスを渡すこともできます。
use std::{fs, io, path::Path}; fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; { let path_from = Path::new(&amp;#34;a.txt&amp;#34;); let path_to = Path::new(&amp;#34;b.txt&amp;#34;); fs::rename(&amp;amp;path_from, &amp;amp;path_to)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイルを移動する rename 関数の移動先パスとして、ディレクトリ階層を含むファイルパスを指定すれば、ファイルをそのディレクトリに移動することができます。 このとき、ファイル名を変更すれば、移動とファイル名の変更が同時に行われます（逆に言うと、移動だけしたいのであれば、同じファイル名を指定する必要があります）。
a.txt を aaa/bbb/ccc.txt として移動する use std::{fs, io}; fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; { // 移動先のディレクトリが存在しなければ先に作成しておく fs::create_dir_all(&amp;#34;aaa/bbb&amp;#34;)?</description></item><item><title>Rust でキーボードからの入力を取得する</title><link>https://maku77.github.io/p/eamw7fp/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eamw7fp/</guid><description>std::io::Stdin の read_line 関数を使うと、ユーザーのキーボード入力を読み取ることができます。
main.rs use std::io::{self, Write}; fn main() { print!(&amp;#34;Please input your name: &amp;#34;); // プロンプトを表示して入力を促す io::stdout().flush().unwrap(); // 上記出力を強制フラッシュ let mut line = String::new(); // 入力用のバッファ io::stdin() .read_line(&amp;amp;mut line) // キーボードからの入力（標準入力）を 1 行読み込む .expect(&amp;#34;Failed to read line&amp;#34;); // 戻り値の Result が Err の場合は終了 println!(&amp;#34;Hi, {}!&amp;#34;, line.trim_end()); // 末尾の改行コードは trim_end で削除可能 } 実行例 Please input your name: Maku Hi, Maku!</description></item><item><title>Rust で型の名前を取得する (std::any::type_name)</title><link>https://maku77.github.io/p/m9vdtaq/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m9vdtaq/</guid><description>std::any::type_name 関数を使うと、型パラメーターで指定した型の名前を、文字列表現で取得することができます。 次の例では、String 型の型名を取得しています。
let name = std::any::type_name::&amp;lt;String&amp;gt;(); println!(&amp;#34;{}&amp;#34;, name) //=&amp;gt; alloc::string::String 返される文字列の形式は明確には仕様化されておらず、Rust のバージョンごとに変わったりするので、この文字列に依存したビジネスロジックは記述すべきではない とされています（診断用にのみ使用できます）。
次のようなユーティリティ関数を作成すれば、任意のリテラル値や変数の型を簡単に調べることができます。
fn print_type_of&amp;lt;T&amp;gt;(_: T) { println!(&amp;#34;{}&amp;#34;, std::any::type_name::&amp;lt;T&amp;gt;()) } fn main() { print_type_of(0); //=&amp;gt; i32 print_type_of(0b1111); //=&amp;gt; i32 print_type_of(0i8); //=&amp;gt; i8 print_type_of(0u64); //=&amp;gt; u64 print_type_of(0.1); //=&amp;gt; f64 print_type_of(0.1e5); //=&amp;gt; f64 print_type_of(0.1f32); //=&amp;gt; f32 print_type_of(0.1e5f32); //=&amp;gt; f32 print_type_of(&amp;#39;a&amp;#39;); //=&amp;gt; char print_type_of(&amp;#34;Hello&amp;#34;); //=&amp;gt; &amp;amp;str }</description></item><item><title>Rust の Result 型の基本 ─ 成功と失敗を表現する型</title><link>https://maku77.github.io/p/us2ahpw/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/us2ahpw/</guid><description>Result 型とは？ Rust の標準ライブラリには、std::result::Result という列挙型 (enum) が用意されており、何らかの処理が「成功」したこと、あるいは「失敗」したことを表現するために使われます（仕組み的には、値の「有無」を表現する Option 型 と同様です）。 他の言語では、例外 (exception) の仕組みでエラーの発生を表現したりしますが、Rust では Result 型を使ってエラーを表現します（Rust には例外の仕組みが存在しません）。 Result 列挙型のバリアントとしては、次のように Ok と Err だけが定義されており、それぞれが何らかの処理の「成功」と「失敗」を表現します。
Result 型の定義 enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } 成功と失敗を表すだけであれば、bool 型だけで表現できそうですが、Result 型は Ok と Err というバリアントが任意の値を持つことができるようになっているので、成功した場合の結果や、失敗した場合の理由を表現することができます。 また、何らかのメソッドが Result 型を返すとき、その値を呼び出し側で利用していないと、コンパイラが警告を出してくれるため、エラーのハンドル忘れを防ぐ効果 があります。 Result 型の概念は、他のモダンな言語でも採用されています（例: Kotlin の Result 型）。
これらのシンボルはデフォルトでインポートされるようになっており、Result、Ok、Err と記述するだけで使用することができます（Result::Ok や Result::Err のように記述する必要はありません）。
Result を処理する Result インスタンスから Ok バリアントや Err バリアントの情報を取り出すには、match 式や if let 式を使います。 以下のサンプルコードでは、str::parse メソッドで、数値を含む文字列をパースして i32 値に変換しています。 パースに成功すると Ok バリアントが返されるので、そこからパース結果を取り出すことができます。 パースに失敗すると Err バリアントが返されるので、そこからエラー情報（ParseIntError など）を取り出すことができます。</description></item><item><title>Rust プログラミングを始める（rustc と cargo コマンド）</title><link>https://maku77.github.io/p/96o6xfv/</link><pubDate>Sun, 11 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/96o6xfv/</guid><description>Rust 関連コマンドのインストール Rust コンパイラ (rustc) と Rust 用のパッケージマネージャー (cargo) は、下記の公式サイトの手順で簡単にインストールできます。 推奨されている方法でインストールすると、Rust 関連のコマンドをアップデートするための rustup コマンドもインストールされます。
公式サイト: Rust をインストール - Rustプログラミング言語 標準構成でインストールすると、Rust 関連の各コマンドが ~/.cargo/bin/ ディレクトリにインストールされます。
$ ls ~/.cargo/bin cargo* clippy-driver* rust-lldb* rustup* cargo-clippy* rls* rustc* cargo-fmt* rust-gdb* rustdoc* cargo-miri* rust-gdbgui* rustfmt* rustc コマンドで Rust コードをビルドする 次の main.rs ファイルは、Rust 言語の Hello World プログラムです。
main.rs fn main() { println!(&amp;#34;Hello, world!&amp;#34;); } この main.rs ファイルをコンパイルするには、rustc コマンドを使用します。 デフォルトでは、.rs ファイルのベース名と同じ名前の実行ファイルが生成されます。
Rust コード (.rs) のコンパイル $ rustc main.rs $ .</description></item></channel></rss>