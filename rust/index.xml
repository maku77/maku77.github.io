<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on 天才まくまくノート</title><link>https://maku77.github.io/rust/</link><description>Recent content in Rust on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 23 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust で MongoDB を扱う (mongodb)</title><link>https://maku77.github.io/p/nzi6xbm/</link><pubDate>Sat, 23 Dec 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nzi6xbm/</guid><description>Rust プログラムから MongoDB にアクセスするには、mongodb クレート を使用します。
各種クレートのインストール cargo add コマンドを使って、次のようなクレートをインストールします。
mongodb &amp;hellip; MongoDB を扱うためのクレート serde &amp;hellip; MongoDB 内の BSON データと Rust の struct を相互変換（シリアライズ／デシリアライズ）するためのクレート tokio &amp;hellip; Rust の async 処理用のランタイム実装を提供するクレート futures &amp;hellip; TryStream と呼ばれる非同期ストリームを操作するための拡張メソッドを使うため（サンプルコード内の cursor.try_next() の部分に必要） # （必要に応じて）プロジェクトの作成 $ cargo new myapp $ cd myapp # クレートのインストール $ cargo add mongodb serde tokio futures Cargo.toml に次のような感じで依存関係が追加されていれば準備 OK です。
Cargo.toml [dependencies] futures = &amp;#34;0.3.29&amp;#34; mongodb = &amp;#34;2.8.0&amp;#34; serde = &amp;#34;1.0.193&amp;#34; tokio = &amp;#34;1.</description></item><item><title>Rust のオブジェクトのライフタイム（生存期間）を理解する ('static, 'a)</title><link>https://maku77.github.io/p/zfhtasm/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zfhtasm/</guid><description>ライフタイムの基本 Rust のオブジェクトのライフタイム（生存期間）は、その名の通り、オブジェクトが有効な期間を表しています。 変数とその借用 (borrow) である参照は、異なるライフタイムを持っています。
変数のライフタイム 変数のライフタイムは、その変数が初期化されるときに開始し、スコープを抜けるときに終了します。 スコープを抜けるとき、その変数はドロップ（破棄）され、それ以降は使用できなくなります。
{ let s = String::from(&amp;#34;Hello&amp;#34;); // 変数 s のライフタイムはここで終わり、ドロップされる } // 変数 s はここではもう使えない スコープはその変数を囲んでいるブロックであり、専門的には lexical scope と呼ばれます。 そのため、変数のライフタイムのことを lexical lifetime と呼ぶことがあります。
参照のライフタイム 一方で、参照（リファレンス）のライフタイムは、その参照を使う最後の文で終了します。 つまり、参照を使っているコード範囲がそのままライフタイムになるため、とてもシンプルです。
let s = String::from(&amp;#34;Hello&amp;#34;); let r = &amp;amp;s; // 参照 r のライフタイムはここから始まり println!(&amp;#34;{}&amp;#34;, r); // ここで終わる println!(&amp;#34;{}&amp;#34;, s); 参照は、ある変数を借用 (borrow) したものであり、参照のライフタイムが終了しても、その参照先の変数が破棄（ドロップ）されるようなことはありません。
ライフタイムは「変数＞参照」でなければいけない 変数とその参照のライフタイム関係は、次のような入れ子関係になっていなければいけないことは明らかです。
図: 正しいライフタイム関係 次のように、参照のライフタイムが、その参照先のオブジェクトのライフタイムを超えるのはおかしいからです。
図: 誤ったライフタイム関係 次のコードは、参照がライフタイム違反をしている例です。
間違った例 let r; { let num = 1; r = &amp;amp;num; } println!</description></item><item><title>Rust で数値を特定の範囲に収まるように修正する (clamp, min, max)</title><link>https://maku77.github.io/p/23fd7nv/</link><pubDate>Mon, 10 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/23fd7nv/</guid><description>clamp メソッド Rust である数値を指定した範囲に収まるように修正するには、clamp メソッドを使用します。 次の例では、いろいろな数値を「0 以上 5 以下」の範囲に収まるように修正しています。
println!(&amp;#34;{}&amp;#34;, (-3).clamp(0, 5)); //=&amp;gt; 0 println!(&amp;#34;{}&amp;#34;, 0.clamp(0, 5)); //=&amp;gt; 0 println!(&amp;#34;{}&amp;#34;, 2.clamp(0, 5)); //=&amp;gt; 2 println!(&amp;#34;{}&amp;#34;, 7.clamp(0, 5)); //=&amp;gt; 5 min / max メソッド clamp メソッドは、数値を指定した最小値と最大値の範囲に収まるようにするメソッドでしたが、最小値と最大値のいずれかを指定すればよい場合は、max や min メソッドを使用します。
// 0 以上になるように修正する println!(&amp;#34;{}&amp;#34;, (-5).max(0)); //=&amp;gt; 0 println!(&amp;#34;{}&amp;#34;, 0.max(0)); //=&amp;gt; 0 println!(&amp;#34;{}&amp;#34;, 10.max(0)); //=&amp;gt; 10 // 100 以下になるように修正する println!(&amp;#34;{}&amp;#34;, (-5).min(100)); //=&amp;gt; -5 println!(&amp;#34;{}&amp;#34;, (27).min(100)); //=&amp;gt; 27 println!(&amp;#34;{}&amp;#34;, (999).min(100)); //=&amp;gt; 100</description></item><item><title>Rust でジェネリクス構造体・関数を定義する（任意の型を扱えるようにする）</title><link>https://maku77.github.io/p/be8u7sg/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/be8u7sg/</guid><description>ジェネリクスの基本 Rust の ジェネリクス (generics) の仕組みを使うと、任意の型を扱う処理を 1 つのコードで記述することができます。
まずは、ジェネリクスを使っていないコードから見てみます。 次のサンプルコードでは、整数型 (i32) の座標値を表現する構造体 Point と、その浮動小数点数型 (f64) バージョンである PointF を定義しています。
ジェネリクスを使わない Point 構造体 /// 整数型の座表値 struct Point { x: i32, y: i32, } /// 浮動小数点数型の座標値 struct PointF { x: f64, y: f64, } // 使用例 fn main() { let p1 = Point { x: 0, y: 5 }; println!(&amp;#34;{}, {}&amp;#34;, p1.x, p1.y); let p2 = PointF { x: -1.2, y: 7.4 }; println!</description></item><item><title>Rust で複数の数値の中から最小値・最大値を見つける (min, max)</title><link>https://maku77.github.io/p/e3o2ra3/</link><pubDate>Sun, 09 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/e3o2ra3/</guid><description>2 つの数値から大きい方を取り出す Rust の標準ライブラリが提供しているジェネリクス関数 std::cmp::max を使うと、2 つの数値のうち大きい方の値を取り出すことができます。
let larger = std::cmp::max(2, 5); //=&amp;gt; 5 // 呼び出し時のコードを短くしたいときは次のように use 宣言します // use std::cmp::max; // let larger = max(2, 5); また、数値のプリミティブ型 (i32 や f64) は core::cmp::Ord トレイトを実装しているため、max メソッドでも上記と同様の処理を行えます。
let larger = 2.max(5); //=&amp;gt; 5 前者の関数型と比較して、後者のメソッド型は直感的に理解しにくいかもしれませんが、場面によっては便利です。 例えば、num.max(0) という表現は、num が負の値だったときに、0 になるよう修正する という処理になります。
参考: 数値を特定の範囲に収まるように修正する (clamp, min, max) 複数の数値の中から最大値を取り出す 数値型のベクターや配列から、最大の値を持つ値を取り出すには次のようにします。
Vec&amp;lt;i32&amp;gt; から最大値を取り出す let nums: Vec&amp;lt;i32&amp;gt; = vec![3, 1, 5, 2, 4]; // let nums: [i32; 5] = [3, 1, 5, 2, 4]; if let Some(max) = nums.</description></item><item><title>Rust のパニック (panic) の扱いについて</title><link>https://maku77.github.io/p/nfxwcc2/</link><pubDate>Thu, 06 Jul 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nfxwcc2/</guid><description>パニックとは Rust のパニックはプログラムに不具合があるときに発生するもので、パニックが発生すると、通常はプログラムの動作を継続することができません。 パニックは発生しないようにコーディングすべきです。
パニックを発生させる処理の例: 数値のゼロ除算 配列の範囲外アクセス Option 変数の値が None なのに unwrap したとき Result 変数の値が Err なのに unwrap したとき panic! マクロを呼び出したとき panic! マクロで意図的にパニックを発生させることができますが、プロダクトコードでは呼び出さないようにします（println! と同様の引数を渡すことができます）。
パニック発生時には、unwind the stack（スタック巻き戻し） あるいは、abort the process（プロセス強制終了） のいずれかの処理が実行されます。
unwind the stack（スタック巻き戻し） パニック発生時のデフォルトの動作です。 スタック上のデータが逆順に解放されて、ファイルなどのリソースが閉じられます。 このとき、ユーザー定義の drop メソッドも呼び出されます。 そして、最後に当該スレッドが終了します。 終了するのがメインスレッドであれば、プロセスが終了することになります。 このように、パニックはカレントスレッドに対して発生するものであり、本質的にはプロセス全体を止めるものではないことに注意してください。 abort the process（プロセス強制終了） パニック発生後の drop 中に別のパニックが発生すると、Rust はスタックの巻き戻し処理 (unwind the stack) をあきらめて、プロセスを強制終了します。 コンパイル時に -C panic=abort オプションを指定すると、最初のパニック発生時に、ただちにプロセスが終了するようになります。 エラーを表現する場合は Result 型を使うべし プログラムの実行中には様々なエラーが発生する可能性があります。 Rust で何らかの処理が成功、あるいは失敗（エラー）したことを表現するには、Result 型を使用します。
参考: Result 型の基本 ─ 成功と失敗を表現する型 例えば、ユーザーが指定したファイルを開こうとした際に、ファイルが存在しない場合、エラーとして扱われますが、これはプログラムの不具合ではないため、パニックを引き起こすのは不適切です。 このような一般的なユースケースで発生するエラーを処理する際には、Result 型の Err バリアントを使用してエラーを表現します。 Result 型を使用することで、エラーを適切にハンドルし、処理を続行することが可能です。</description></item><item><title>Rust でモジュールを定義する (mod)</title><link>https://maku77.github.io/p/gxj4n7q/</link><pubDate>Sun, 05 Mar 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gxj4n7q/</guid><description>規模の大きい Rust プログラムを作る場合、モジュール の仕組みを使ってコードを階層化すると見通しがよくなります。 Rust でモジュールを定義するときは、mod キーワードを使用します。 1 つの .rs ファイルの中にインライン形式でモジュールを定義することも、別ファイルに分けてモジュールを定義することもできます。
クレートとモジュール すべての Rust プログラムはクレート (crate) であり、バイナリクレート か ライブラリクレート のどちらかです。 クレートは、Rust におけるコンパイルの単位です。
バイナリクレート &amp;hellip; 1 つの実行ファイルを作り上げるもの。 ライブラリクレート &amp;hellip; 1 つのライブラリを作り上げるもの。 コンパイルはクレート単位で行われますが、コードレベルの実装では、モジュール という論理的な単位で分割／階層化できるようになっています。 クレートは 1 つ以上のモジュールで構成され、必ず 1 つの ルートモジュール（クレートルート） を持っています。 ルートモジュールのファイル名は決まっていて、バイナリクレートの場合は src/main.rs で、ライブラリクレートの場合は src/lib.rs です。 ルートモジュールはサブモジュールを含むことができ、さらに、サブモジュールも同様にサブモジュールを含むことができます。
クレートの論理的構造 ルートモジュール (main.rs あるいは lib.rs) +-- サブモジュール | +-- サブサブモジュール | +-- ... +-- サブモジュール +-- サブサブモジュール +-- ... 上記のように、クレート内のモジュールはルートモジュールを起点とするツリー構造になるため、mod キーワードを使ってモジュールを定義するとき、それは必ず何らかの親モジュールのサブモジュールということになります。
モジュールの作り方 インラインモジュール mod ブロックを使ってサブモジュールを定義することができます。 サブモジュールの実装をブロック内に直接記述するので、インラインモジュール と呼ばれます。 次の例では、calc モジュールを定義して、その中に add 関数を定義しています。</description></item><item><title>Rust の文法: 制御構文 (if, match, while, loop, for)</title><link>https://maku77.github.io/p/22cnw7f/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/22cnw7f/</guid><description>条件分岐 if 文 (if statement) if n &amp;gt; 0 { println!(&amp;#34;{} is positive&amp;#34;, n); } else if n &amp;lt; 0 { println!(&amp;#34;{} is negative&amp;#34;, n); } else { println!(&amp;#34;{} is zero&amp;#34;, n); } C/C++ と異なり、条件式は () で囲む必要はありません。 ただし、ブロック部分は必ず {} で囲む必要があります。
if 式 (if expression) Rust の if は式として扱うことができるので、分岐後に評価した値を参照することができます（Kotlin などのモダンな言語と同様です）。 下記の変数 s には、n の値に応じて Good あるいは Bad が格納されます。
let s = if n &amp;gt; 0 { &amp;#34;Good&amp;#34; } else { &amp;#34;Bad&amp;#34; }; if を式として使う場合は、必ず else 句が必要なことに注意してください。 また、評価後の値（上記の例では &amp;quot;Good&amp;quot; や &amp;quot;Bad&amp;quot;）の後ろには、セミコロン (;) を付けてはいけません。 セミコロンを付けると、それは式ではなく値を持たない文とみなされてしまうので、if 式の評価結果が空（空タプル ()）になってしまいます。</description></item><item><title>Rust の文法: 所有権 (ownership) と借用 (borrow)</title><link>https://maku77.github.io/p/4nx8hqy/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4nx8hqy/</guid><description>所有権 (ownership) Rust においてヒープ上で管理される値には 所有権 (ownership) という概念があり、必ず 1 つの変数だけが所有権を保持しています。 所有権を持つ変数が関数などのスコープから外れるときに、メモリが解放され、値が破棄されます。 この仕組み（制約）により、Rust では、ヒープ上に確保された値がどこで解放されるかをコンパイル時に決定できるようになっています（Java のようなガーベジコレクションが必要ありません）。
Rust で独特なのは、所有権が変数間で移動するところで、次のような操作を行ったときに所有権が移動します（この振る舞いを move と呼びます）。
代入演算子 (=) で別の変数に代入したとき 関数の引数として変数を渡したとき 関数の戻り値として変数を返したとき 代入による所有権の移動 // ヒープ上に String インスタンスが確保され、変数 s1 が所有者 (owner) となる let s1 = String::from(&amp;#34;Hello&amp;#34;); // s1 の所有権が s2 に移動 (move) し、s1 は無効化される let s2 = s1; // コンパイルエラー！（ここでは s1 はもう使えない） println!(&amp;#34;{}, {}&amp;#34;, s1, s2); 次のように clone メソッドで明示的なディープコピーを行えば、所有権は移動しません。 ヒープ上の新しい領域に値がコピーされ、それぞれの変数が別の値の所有者となるからです。
let s1 = String::from(&amp;#34;Hello&amp;#34;); let s2 = s1.clone(); // ディープコピー // s1 も s2 も独立した値の所有者なので両方アクセスできる println!</description></item><item><title>Rust の文法: 構造体 (struct) とタプル構造体 (tuple struct)</title><link>https://maku77.github.io/p/h8kw8ju/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/h8kw8ju/</guid><description>構造体の基本 Rust の構造体の定義とインスタンス化は直感的です。 構造体を定義するときは struct 構造体名 { ... }、定義済みの構造体をインスタンス化するときは 構造体名 { ... } という構文を使用します。 先頭に struct というキーワードが付くかどうかの違いしかないので、どちらの処理を行っているのか気を付けて読み取ってください。
// 構造体の定義（フィールド名と型を指定していく） struct User { name: String, email: String, active: bool, sign_in_count: u64, } // インスタンス化（フィ―ルド名と初期値を指定していく） let user = User { email: String::from(&amp;#34;maku@example.com&amp;#34;), name: String::from(&amp;#34;maku&amp;#34;), active: true, sign_in_count: 1, }; // フィールドの参照にはドットを使う println!(&amp;#34;{}&amp;#34;, user.name); 構造体のフィールドとして文字列を持ちたいときは、&amp;amp;str（文字列スライス）ではなく String 型を使うことで、構造体インスタンス自身が文字列の所有者になることができます（参考: 所有権と借用）。
構造体インスタンスの参照（借用）経由でフィールドにアクセスする場合もドットが使えます。
let user_ref = &amp;amp;user; // 借用 (borrow) して参照 (&amp;amp;User) を作成 println!(&amp;#34;{}&amp;#34;, user_ref.name); // 参照のフィールドもドットでアクセスする 可変な構造体 (mutable struct) インスタンス生成時に let の代わりに let mut を使うと、可変 (mutable) なインスタンスとなり、すべてのフィールドが再代入可能になります（一部のフィールドだけを再代入可能にすることはできません）。</description></item><item><title>Rust の文法: 配列 (array) とタプル (tuple)</title><link>https://maku77.github.io/p/7r3cmv6/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7r3cmv6/</guid><description>配列 (array) 配列の基本 Rust の配列は、多くの言語と同様に [] を使って生成することができます。 配列の要素の型はすべて同一である必要があり、配列サイズ（要素数）は不変です。 要素数をあらかじめ固定できない場合は、配列の代わりに ベクター (Vec) 型 を使います。
let arr = [0, 1, 2]; // [i32; 3] let arr = [&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;]; // [&amp;amp;str; 3] let arr = [true, false, true]; // [bool; 3] 要素の参照は、C/C++ と同様に 0 始まりのインデックス指定で行えます (arr[0])。 配列のサイズ（要素数）は arr.len() で取得できます。
let arr = [&amp;#39;あ&amp;#39;, &amp;#39;い&amp;#39;, &amp;#39;う&amp;#39;]; println!(&amp;#34;{}, {}, {}&amp;#34;, arr[0], arr[1], arr[2]); // あ, い, う println!(&amp;#34;len={}&amp;#34;, arr.len()); // len=3 可変配列 (mutable array) 要素を変更可能にしたいときは、次のように let mut で配列を定義します。 可変というのは、ある位置の値を変更できるという意味であって、配列のサイズや型を変更することはできないことに注意してください。</description></item><item><title>Rust でハッシュマップ型 (HashMap) を扱う</title><link>https://maku77.github.io/p/eefwaa3/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eefwaa3/</guid><description>ハッシュマップの基本 Rust の標準ライブラリとして、キー＆バリューのコレクションを扱うハッシュマップ型 (HashMap&amp;lt;K, V&amp;gt;) が用意されています。
下記は、空のハッシュマップを作成し、キー＆バリューを追加／取得する例です。
use std::collections::HashMap; let mut map = HashMap::new(); map.insert(String::from(&amp;#34;AAA&amp;#34;), 100); map.insert(String::from(&amp;#34;BBB&amp;#34;), 200); map.insert(String::from(&amp;#34;CCC&amp;#34;), 300); println!(&amp;#34;{:?}&amp;#34;, map.get(&amp;#34;AAA&amp;#34;)); //=&amp;gt; Some(100) println!(&amp;#34;{:?}&amp;#34;, map.get(&amp;#34;ZZZ&amp;#34;)); //=&amp;gt; None 上記の例では、HashMap の型パラメーターを省略していますが、insert しているデータから、キーの型は String、値の型は i32 と推測されます。 HashMap のキーの型が String であっても、get メソッドの引数には &amp;amp;str を渡せるようになっています。
ハッシュマップの生成方法 空のハッシュマップを生成する (new, with_capacity) let mut map: HashMap&amp;lt;String, i32&amp;gt; = HashMap::new(); let mut map: HashMap&amp;lt;String, i32&amp;gt; = HashMap::with_capacity(100) 空のマップは new で生成できますが、あらかじめ格納する要素数を想定できるときは with_capacity を使うと効率的です。 HashMap 型には、Vec 型の vec! のようなインスタンス生成用のマクロは用意されていないので、これらの関数を使ってインスタンスを生成する必要があります。 空のハッシュマップには何らかのデータを詰める必要があるので、通常は mutable な変数として定義します。</description></item><item><title>Rust で Excel ファイルを読み込む (calamine)</title><link>https://maku77.github.io/p/4ye2eah/</link><pubDate>Fri, 20 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ye2eah/</guid><description>calamine とは Rust の calamine クレートは、Excel ファイルを読み込むためのライブラリです。
calamine - Rust tafia/calamine: A pure Rust Excel/OpenDocument SpeadSheets file reader: rust on metal sheets 読み込み専用 (read-only) のライブラリですが、ピュアな Rust 実装で軽量です。 作者の tafia (Johann Tuffe) 氏によると、「書き込み (write) はめっちゃ複雑だから対応しないよ。セルのアップデートくらいなら対応するかもね」とのこと。
Rust プロジェクトで次のように依存関係を追加すれば準備完了です。
$ cargo add calamine 以下、Excel ファイルを読み込むサンプルコードです。
ワークシート名のリストを取得する (Xlsx#sheet_names) open_workbook で Excel ファイルを開いて、Xlsx インスタンスを取得するところがすべての始まりです。 Xlsx#sheet_names メソッドで、ワークシート名の一覧を取得できます。
use calamine::{Reader, Xlsx}; fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; { let workbook: Xlsx&amp;lt;_&amp;gt; = calamine::open_workbook(&amp;#34;sample.xlsx&amp;#34;)?; let sheet_names = workbook.sheet_names(); println!</description></item><item><title>Rust でコマンドライン引数を扱う (2) clap クレート</title><link>https://maku77.github.io/p/bdp2doy/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bdp2doy/</guid><description>clap とは？ clap クレート は、コマンドライン引数のパーサーライブラリで、次のような機能を備えています。
一般的なオプション形式（-a や --name val）や、サブコマンド形式の引数のパース ヘルプ出力 (usage) の自動生成 シェル用の入力補完スクリプト生成（clap_complete クレート） derive マクロにより多くのボイラプレートコードを自動生成してくれるので、コードをシンプルに保ちつつ、高度なコマンドライン引数処理を行うことができます。
clap を使う準備 clap クレートを使うために、最初に Cargo.toml に依存関係を追加しておきます。
clap クレートを使う準備 $ cargo add clap --features derive derive マクロを有効にするために、--features derive オプションが必要です。 次のように依存関係が追加されていれば OK です。
Cargo.toml [dependencies] clap = &amp;#34;4.0.32&amp;#34; clap の基本 任意の構造体定義に、clap が提供する #[derive(Parser)] マクロを付加することで、コマンドライン引数用のバッファとして使えるようになります。
src/main.rs use clap::Parser; /// ヘルプ出力の最初に表示されるテキスト #[derive(Parser)] struct Args { /// 1 番目のパラメーターの説明として表示されるテキスト first: String, /// 2 番目のパラメーターの説明として表示されるテキスト second: u32, } fn main() { let args = Args::parse(); println!</description></item><item><title>Rust で JSON フォーマットを扱う (serde)</title><link>https://maku77.github.io/p/xdyk5o8/</link><pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xdyk5o8/</guid><description>Serde とは？ Rust の serde クレート は、Rust プログラム内で定義したユーザー型（struct や enum）を、JSON や YAML、BSON といった様々なデータ形式にシリアライズ／デシリアライズするためのライブラリです。 Serde という名前は、Serialize ＋ Deserialize から来ています。 発音は、すぁーでぃ です。
Serde website serde API documentation Serde を使う準備 Serde を使うためには、ベースとなる serde クレートに加えて、扱いたいデータフォーマット用のクレート（Serializer / Deserialize 実装）を依存関係に追加しておく必要があります。　例えば、JSON であれば serde_json、YAML であれば serde_yaml です。
serde 本体と各データフォーマット用の依存を追加 $ cargo add serde --features=derive $ cargo add serde_json # データフォーマットとして JSON を使う場合 Serde の derive マクロを有効にするために、--features=derive オプションを指定する必要があることに注意してください。 Cargo.toml に次のような依存関係が追加されていれば準備 OK です。
Cargo.toml [dependencies] serde = { version = &amp;#34;1.</description></item><item><title>Rust で正規表現を扱う (regex)</title><link>https://maku77.github.io/p/r7sdwgy/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r7sdwgy/</guid><description>Rust の regex クレート を使うと、正規表現を使った様々な文字列処理を行うことができます。 Rust (Cargo) プロジェクト内で以下のように実行して Cargo.toml に依存関係を追加すれば regex の使用準備は完了です。
$ cargo add regex Cargo.toml [dependencies] regex = &amp;#34;1.7.0&amp;#34; パターンに一致するか調べる (is_match) Regex#is_match メソッドを使うと、引数で渡した文字列に、Regex のパターンに一致する部分文字列が含まれているかを調べることができます。
use regex::Regex; let re = Regex::new(r&amp;#34;\d{4}-\d{2}-\d{2}&amp;#34;).unwrap(); let input = &amp;#34;Today&amp;#39;s date is 2023-01-07.&amp;#34;; if re.is_match(input) { println!(&amp;#34;日付らしき文字列が見つかりました&amp;#34;); } Regex#is_match メソッドは、パターンに一致する文字列が部分的にでも見つかれば true を返します。 文字列全体がパターンに一致するかどうかを調べたい場合は、パターンに ^（行頭）と $（行末）を含めて、r&amp;quot;^\d{4}-\d{2}-\d{2}$&amp;quot; のようにします。
パターンに一致した位置を調べる (find, find_iter) Regex#find メソッドは、パターンに一致する部分文字列が見つかったときに regex::Match オブジェクトを返します。 見つからない場合は Option::None を返します。 Match のメソッドを使って、実際に一致した部分文字列や、その位置を取得できます。
連続する数値を探す let re = Regex::new(r&amp;#34;\d+&amp;#34;).unwrap(); let input = &amp;#34;server: ok=100 changed=50 unreachable=0 failed=3&amp;#34;; match re.</description></item><item><title>Rust の Result オブジェクトを消費せずに参照する (as_ref, as_mut)</title><link>https://maku77.github.io/p/z3gts64/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z3gts64/</guid><description>通常、Result オブジェクトを match や unwrap、ok メソッドなどでハンドルすると、その Result は消費されます（所有権が移動します）。 この振る舞いを防ぐには、as_ref や as_mut メソッドを使います。
std::result::Result のメソッド pub const fn as_ref(&amp;amp;self) -&amp;gt; Result&amp;lt;&amp;amp;T, &amp;amp;E&amp;gt; pub fn as_mut(&amp;amp;mut self) -&amp;gt; Result&amp;lt;&amp;amp;mut T, &amp;amp;mut E&amp;gt; as_ref メソッドで取得した Result オブジェクト経由で Ok/Err バリアントを参照すれば、それらのオブジェクトが消費されずに済みます。
let ok_opt = result.as_ref().ok(); // 借用 (borrow) // ... // ここでまだ result の Ok/Err は有効</description></item><item><title>Rust の Result 型エイリアスでコードを簡潔にする</title><link>https://maku77.github.io/p/ez9gpw5/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ez9gpw5/</guid><description>Rust の std::io モジュールの関数は、戻り値として Result&amp;lt;T, std::io::Error&amp;gt; 型のオブジェクトを返すのですが、Result::Err バリアント部分の型は std::io::Error でいつも同じなので、簡潔に記述できるように、次のような std::io::Result というエイリアス型が定義されています。
std::io::Result pub type Result&amp;lt;T&amp;gt; = Result&amp;lt;T, Error&amp;gt;; // 後ろの Error は std::io::Error ここで定義している Result 型は、基礎となる std::result::Result とは別物なので注意してください。 std::io::Result という型を、std::result::Result と std::io::Error を組み合わせて定義しています。
std::io::Result を使うと、例えば、String を成功値 (Ok バリアントのフィールド) とする Result は、io::Result&amp;lt;String&amp;gt; と簡潔に記述することができます。 下記が具体的な使用例です。
use std::io; /// 標準入力から 1 行読み込みます fn get_string() -&amp;gt; io::Result&amp;lt;String&amp;gt; { let mut buffer = String::new(); io::stdin().read_line(&amp;amp;mut buffer)?; Ok(buffer) } 上記の get_string() 関数の戻り値の型 io::Result&amp;lt;String&amp;gt; は、実際には std::result::Result&amp;lt;String, std::io::Error&amp;gt; と同等です。</description></item><item><title>Rust の各種ライブラリのエラー型と Error トレイト</title><link>https://maku77.github.io/p/8amv5eo/</link><pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8amv5eo/</guid><description>いろんな Error 実装がある Rust には、成功と失敗を表現するための標準的な型である std::result::Result 型が用意されています。
std::result::Result enum Result&amp;lt;T, E&amp;gt; { Ok(T), Err(E), } Result を返す関数内でエラーが発生した場合は、Err バリアントのフィールドに具体的なエラーオブジェクトを詰めて返すことになるのですが、このエラーオブジェクトの型として、各ライブラリが独自のエラー型を定義しています。 下記はその一例です。
std::io::Error std::fmt::Error std::str::Utf8Error std::num::ParseIntError 同じエラー型を使っているつもりでも、上記のように実体は異なる定義だったりするので注意してください。
Error トレイト Rust は共通のエラーインタフェースとして、次のような std::error::Error トレイト を定義しています。 前述の各種エラー型は、この Error トレイトを実装しています。
pub trait Error: Debug + Display { fn source(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;(dyn Error + &amp;#39;static)&amp;gt; { ... } fn description(&amp;amp;self) -&amp;gt; &amp;amp;str { ... } fn cause(&amp;amp;self) -&amp;gt; Option&amp;lt;&amp;amp;dyn Error&amp;gt; { ... } fn provide(&amp;amp;&amp;#39;a self, demand: &amp;amp;mut Demand&amp;lt;&amp;#39;a&amp;gt;) { .</description></item><item><title>Rust でベクター型 (Vec) を扱う</title><link>https://maku77.github.io/p/jku3biq/</link><pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jku3biq/</guid><description>Vec 型とは？ Rust のベクター型 (Vec&amp;lt;T&amp;gt;) は、特定の型 (T) の要素を保持する可変長配列です。 サイズが固定であれば、通常の配列 (array) を使った方が効率的です。
次の例では、Vec::new 関数で空の Vec&amp;lt;i32&amp;gt; インスタンスを作成し、push メソッドにより動的に要素を追加しています。
let mut v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // 型は推論されるので省略可能 v.push(10); v.push(20); v.push(30); println!(&amp;#34;{:?}&amp;#34;, v); //=&amp;gt; [10, 20, 30] 動的に要素を追加／削除するためには、Vec 変数は mut を付けて定義しておく必要があります。 この例の場合、push メソッドの使い方から、要素の型は i32 であることが推測されるので、Vec インスタンスの作成時に型注釈を省略することができます（ほとんどのケースでは省略できます）。
let mut v = Vec::new(); Vec インスタンスの作成方法 // 空の Vec を作成する let mut v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // vec! マクロで初期値を指定して作成する let mut v: Vec&amp;lt;i32&amp;gt; = vec![]; let mut v = vec!</description></item><item><title>Rust で列挙型 (enum) を定義して match、if let で照合する</title><link>https://maku77.github.io/p/ffqyajs/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ffqyajs/</guid><description>列挙型は、あらかじ定義された値（列挙子やバリアントと呼びます）の内、いずれかの値をとることができる型です。 Rust の列挙型は、各バリアントに任意の値を保持することができるので非常に強力です。 列挙型は構造体 (struct) と同様に、impl ブロックを使ったメソッド定義を行えます。
列挙型の基本 列挙型は enum キーワードを使って定義します。 列挙型がとりうる値のことを バリアント (variant) と呼びます。 次の Fruit 列挙型は、バリアントとして Apple、Banana、Orange を持ちます。
enum 型を定義する // Fruit 列挙型を定義する #[derive(Debug)] enum Fruit { Apple, Banana, Orange, } // Fruit インスタンスを生成する let f = Fruit::Apple; println!(&amp;#34;{:?}&amp;#34;, f); //=&amp;gt; Apple println!(&amp;#34;{}&amp;#34;, f as i32); //=&amp;gt; 0 上記のように列挙型の定義時に #[derive(Debug)] 属性を付けておくと、println! マクロで列挙型変数の値を {:?} で参照できるようになります。 あるいは、as i32 を使って、バリアントが持つ 内部的な整数値を取り出す こともできます。
match による分岐 match 構文によりパターンマッチにより、列挙型変数の値に基づいて分岐処理を行うことができます。 次の例では 3 つのパターンで分岐していますが、これらのパターンごとの記述を Rust では アーム (arm) と呼びます。 各アームはカンマ (,) で区切って記述します。</description></item><item><title>Rust の Option 型の基本 ─ 値の有無を表現する型</title><link>https://maku77.github.io/p/9m6m5m3/</link><pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9m6m5m3/</guid><description>Option 型とは？ 多くのオブジェクト指向言語には、オブジェクトが存在しないことを示す null という値が用意されていますが、Rust には null は存在しません。 Rust の設計者は、null という概念が不具合の温床となっていると判断しました。 その代わりに、Rust には std::option::Option という組み込みの列挙型 (enum) が用意されており、ある値が存在しているか を表現できるようになっています。 そして、この設計は null を使った表現よりも柔軟で、かつ安全です。
Option 型の定義はとてもシンプルで、次のような感じの列挙型 (enum) として定義されています。
Option 型の定義 pub enum Option&amp;lt;T&amp;gt; { Some(T), // T 型の何らかの値 None, // 値が存在しない } Some バリアントが「（任意の型 T の）値が存在する」ことを示し、None バリアントが「値が存在しない」ことを示します。 つまり、Some と None で値の有無を表現しつつ、値が存在する場合はその値を Some バリアントから取り出せるようになっています。
例えば、値が存在しないかもしれない String 型（他の言語では Nullable な String 型）は、Option&amp;lt;String&amp;gt; 型として表現することができ、その Some 値と None 値を次のように生成できます。
let some_val: Option&amp;lt;String&amp;gt; = Some(String::from(&amp;#34;Hello&amp;#34;)); let none_val: Option&amp;lt;String&amp;gt; = None; // 他の言語では null や nil に相当 こんな感じで別名を付けると理解しやすいでしょうか。</description></item><item><title>Rust でコマンドライン引数を扱う (1) std::env::args</title><link>https://maku77.github.io/p/wu6gqz9/</link><pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wu6gqz9/</guid><description>Rust プログラムに渡されたコマンドライン引数を扱う方法として、std::env::args 関数 を使う方法を説明します。 この関数は標準で呼び出すことができるのでお手軽ですが、リッチなコマンドライン引数を提供したいときは、clap クレートを使う方法 がおすすめです。
std::env::args の基本 std::env::args 関数は、イテレート可能な std::env::Args オブジェクトを返します。 1 番目の要素には実行したファイルの名前（相対パス）が含まれており、2 番目以降にコマンドライン引数が格納されています。
src/main.rs use std::env; fn main() { // std::env::Args を取得してループ処理 for arg in env::args() { println!(&amp;#34;{arg}&amp;#34;); // arg は単純な String 型 } } cargo run でコマンドを実行する場合、プログラムに渡すコマンドライン引数は、次のように -- の後ろに指定します。
実行例 $ cargo -q run -- --aaa 100 200 target/debug/sample --aaa 100 200 -- というセパレーターを入れないと、--aaa オプションが、cargo 側のオプションとして渡されてしまうので注意してください。
Iterator トレイトの nth メソッド を使って、インデックス指定で参照することもできます。 ユーザーがコマンドライン引数を指定しなかった場合は、Option::None が返されることに注意してください。
let first_arg: String = std::env::args().</description></item><item><title>Rust で自作したプログラムをシステムにインストールする (cargo install)</title><link>https://maku77.github.io/p/owbo2dp/</link><pubDate>Mon, 02 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/owbo2dp/</guid><description>何をするか？ Rust で自作したコマンドラインツール (CLI) は、プロジェクトのワーキングディレクトリ以下で cargo run で実行できますが、毎回ディレクトリを移動するのは面倒です。 cargo install コマンド で、パスの通ったディレクトリに実行ファイルをインストールすれば、どのディレクトリからでもコマンドを実行できるようになります。
自作コマンドをインストールする (cargo install) Rust のプロジェクトがなければ、次のように適当に作ってください。 ここでは、hello-rust という名前のプログラムを作成することにします。
$ cargo new ~/hello-rust $ cd ~/hello-rust ローカルで開発している Rust プログラムをシステムにインストールするには、次のように cargo install コマンドを実行します。 このとき、--path オプションで Cargo.toml ファイルがあるディレクトリを指定する必要があります。 自動的にリリースモードでビルド (cargo build -r) してからインストールしてくれるので、あらかじめビルドしておく必要はありません。
$ cargo install --path . Installing hello-rust v0.1.0 (/Users/maku/hello-rust) Compiling hello-rust v0.1.0 (/Users/maku/hello-rust) Finished release [optimized] target(s) in 0.35s Installing /Users/maku/.cargo/bin/hello-rust Installed package `hello-rust v0.1.0 (/Users/maku/hello-rust)` (executable `hello-rust`) 生成された実行ファイル (hello-rust) は、~/.</description></item><item><title>ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf)</title><link>https://maku77.github.io/p/36hr2bj/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/36hr2bj/</guid><description>Path と PathBuf Rust には、ファイルやディレクトリのパス情報を扱うための std::path::Path struct が用意されています。 Path の mutable 版（可変）である、std::path::PathBuf struct を使うと、パス情報を動的に組み立てていくことができます。
次の例では、パス形式の文字列リテラルから Path と PathBuf のインスタンスを生成しています。
use std::path::{Path, PathBuf}; fn main() { let path = Path::new(&amp;#34;/dir1/dir2/file.txt&amp;#34;); let path_buf = PathBuf::from(&amp;#34;/dir1/dir2/file.txt&amp;#34;); println!(&amp;#34;{:?}&amp;#34;, path); //=&amp;gt; &amp;#34;/dir1/dir2/file.txt&amp;#34; println!(&amp;#34;{:?}&amp;#34;, path_buf); //=&amp;gt; &amp;#34;/dir1/dir2/file.txt&amp;#34; } ☝️ パスを文字列で取り出す Path や PathBuf インスタンスから、パスを表現する文字列を取得したければ次のように記述できます。
let path = Path::new(&amp;#34;/aaa/bbb/ccc&amp;#34;); let s = path.to_string_lossy(); assert_eq!(s, &amp;#34;/aaa/bbb/ccc&amp;#34;); ただ、実際のプロダクトコード内でパス情報を扱うときは、Path オブジェクトのまま扱った方が都合がよいので、実際にこのような処理が必要になることはあまりありません。 例えば、ファイルを扱う std::fs モジュールの各種関数は、パスを表す文字列と Path インスタンスのどちらも扱えるようになっています。
パスを分解する Path や PathBuf の、次のようなメソッドを使うことで、/dir1/dir2/file.txt のようなパス文字列から、親ディレクトリ名や、ベースネーム、拡張子名などを抽出することができます。</description></item><item><title>ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf)</title><link>https://maku77.github.io/p/fbkt3ah/</link><pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fbkt3ah/</guid><description>Path や PathBuf 構造体が備えている is_file メソッドや is_dir メソッドを使うと、そのそのパスに対応するファイルやディレクトリが存在するかを調べることができます。 他にも、パスが絶対パスか相対パスかを調べるメソッドなどが用意されています。
メソッド名 戻り値の型 意味 Path::is_file() bool そのパスが示す ファイルが存在するか を調べます。シンボリックリンクの場合は、リンク先のファイルが存在するかを調べます。ファイルのアクセス権がない場合は、false を返します。 Path::is_dir() bool そのパスが示す ディレクトリが存在するか を調べます。シンボリックリンクの場合は、リンク先のディレクトリが存在するかを調べます。ディレクトリのアクセス権がない場合は、false を返します。 Path::is_symlink() bool そのパスが示す シンボリックファイルが存在するか を調べます。リンク先のファイルやディレクトリが存在するかまではチェックしません（シンボリックリンクが壊れていても true を返します）。 Path::is_absolute() bool そのパスが 絶対パスか を調べます。 Path::is_relative() bool そのパスが 相対パスか を調べます。 Path::has_root() bool そのパスが ルートセパレーターを持つか を調べます（ほぼ is_absolute と同義）。 use std::path::Path; fn main() { // 存在するファイル（相対パス指定）の場合 let path = Path::new(&amp;#34;Cargo.toml&amp;#34;); assert_eq!(path.is_file(), true); assert_eq!(path.is_dir(), false); assert_eq!(path.is_symlink(), false); assert_eq!(path.is_absolute(), false); assert_eq!(path.is_relative(), true); assert_eq!(path.has_root(), false); // 存在しないファイル（絶対パス指定）の場合 let path = Path::new(&amp;#34;/nonexisting/file/path&amp;#34;); assert_eq!</description></item><item><title>Rust でディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all)</title><link>https://maku77.github.io/p/zju5eow/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zju5eow/</guid><description>ディレクトリを作成する (create_dir) Rust でディレクトリを作成するには、std::fs::create_dir 関数 を使用します。
カレントディレクトリに aaa ディレクトリを作成 use std::fs; fn main() -&amp;gt; std::io::Result&amp;lt;()&amp;gt; { fs::create_dir(&amp;#34;aaa&amp;#34;)?; Ok(()) } すでに同名のディレクトリが存在している場合など、ディレクトリを作成できない場合はエラーが発生します。
use std::fs; fn main() { match fs::create_dir(&amp;#34;aaa&amp;#34;) { Ok(_) =&amp;gt; println!(&amp;#34;ディレクトリを作成しました&amp;#34;), Err(_) =&amp;gt; eprintln!(&amp;#34;ディレクトリを作成できませんでした&amp;#34;), } } 複数階層のディレクトリを作成する (create_dir_all) 深い階層のディレクトリを一気に作成するには、create_dir の代わりに create_dir_all 関数 を使用します。 このメソッドは、すでに存在しているディレクトリを指定してもエラーにならない ので、create_dir より使い勝手はよいかもしれません。
aaa/bbb/ccc ディレクトリが存在しなければ作成する use std::fs; fn main() { fs::create_dir_all(&amp;#34;aaa/bbb/ccc&amp;#34;).unwrap(); // 成功する前提で unwrap } ディレクトリを削除する (remove_dir) 既存の（空の）ディレクトリを削除するには、std::fs::remove_dir 関数を使用します。 この関数は、Linux の rmdir コマンドと同様、空のディレクトリしか削除できないことに注意してください（DirectoryNotEmpty エラーが発生します）。 存在しないディレクトリを削除しようとした場合もエラーが発生します。
ディレクトリ aaa を削除する use std::fs; fn main() -&amp;gt; std::io::Result&amp;lt;()&amp;gt; { fs::remove_dir(&amp;#34;aaa&amp;#34;)?</description></item><item><title>Rust でディレクトリ内のファイルを列挙する (fs::read_dir)</title><link>https://maku77.github.io/p/2kv6eub/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2kv6eub/</guid><description>read_dir 関数の基本 Rust の標準モジュール std::fs の read_dir 関数 を使うと、ディレクトリ内のファイルやディレクトリを列挙することができます。
std::fs::read_dir 関数 pub fn read_dir&amp;lt;P: AsRef&amp;lt;Path&amp;gt;&amp;gt;(path: P) -&amp;gt; Result&amp;lt;ReadDir&amp;gt; 列挙結果には、カレントディレクトリ (.) や親ディレクトリ (..) は含まれないので、自然な列挙が可能です。
src/main.rs use std::fs; fn main() { let entries = fs::read_dir(&amp;#34;.&amp;#34;).unwrap(); // ReadDir を取得 // ループで Result&amp;lt;DieEntry, Error&amp;gt; をひとつずつ処理 for entry in entries { // DirEntry#file_name() でファイル名（ディレクトリ名）を取得できる println!(&amp;#34;{:?}&amp;#34;, entry.unwrap().file_name()); } } 実行結果 &amp;#34;Cargo.toml&amp;#34; &amp;#34;target&amp;#34; &amp;#34;Cargo.lock&amp;#34; &amp;#34;.gitignore&amp;#34; &amp;#34;.git&amp;#34; &amp;#34;src&amp;#34; エラーチェックする 上記ではコードを簡素化するために Result#unwrap メソッドを使っていますが、万が一 Err 値が返された場合は panic が発生してしまうので、プロダクトコードでは unwrap メソッドは使うべきではありません。 Result が Ok 値を持っているかを調べつつ、その値を取り出すには、次のように if let 構文を使用できます。</description></item><item><title>Rust でファイルやディレクトリの名前を変更（移動）する (std::fs::rename)</title><link>https://maku77.github.io/p/raiqzbr/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/raiqzbr/</guid><description>Rust でファイルやディレクトリの名前を変更するには、std::fs::rename 関数 を使用します。 rename 関数は、ファイルの移動にも使用できます。
ファイルの名前を変更する a.txt を b.txt にリネームする use std::{fs, io}; fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; { fs::rename(&amp;#34;a.txt&amp;#34;, &amp;#34;b.txt&amp;#34;)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイル名の代わりにディレクトリ名を指定すれば、ディレクトリ名を変更することができます。
rename 関数には Path インスタンスを渡すこともできます。
use std::{fs, io, path::Path}; fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; { let path_from = Path::new(&amp;#34;a.txt&amp;#34;); let path_to = Path::new(&amp;#34;b.txt&amp;#34;); fs::rename(&amp;amp;path_from, &amp;amp;path_to)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイルを移動する rename 関数の移動先パスとして、ディレクトリ階層を含むファイルパスを指定すれば、ファイルをそのディレクトリに移動することができます。 このとき、ファイル名を変更すれば、移動とファイル名の変更が同時に行われます（逆に言うと、移動だけしたいのであれば、同じファイル名を指定する必要があります）。
a.txt を aaa/bbb/ccc.txt として移動する use std::{fs, io}; fn main() -&amp;gt; io::Result&amp;lt;()&amp;gt; { // 移動先のディレクトリが存在しなければ先に作成しておく fs::create_dir_all(&amp;#34;aaa/bbb&amp;#34;)?</description></item><item><title>Rust でキーボードからの入力を取得する</title><link>https://maku77.github.io/p/eamw7fp/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eamw7fp/</guid><description>std::io::Stdin の read_line 関数を使うと、ユーザーのキーボード入力を読み取ることができます。
main.rs use std::io::{self, Write}; fn main() { print!(&amp;#34;Please input your name: &amp;#34;); // プロンプトを表示して入力を促す io::stdout().flush().unwrap(); // 上記出力を強制フラッシュ let mut line = String::new(); // 入力用のバッファ io::stdin() .read_line(&amp;amp;mut line) // キーボードからの入力（標準入力）を 1 行読み込む .expect(&amp;#34;Failed to read line&amp;#34;); // 戻り値の Result が Err の場合は終了 println!(&amp;#34;Hi, {}!&amp;#34;, line.trim_end()); // 末尾の改行コードは trim_end で削除可能 } 実行例 Please input your name: Maku Hi, Maku!</description></item><item><title>Rust で型の名前を取得する (std::any::type_name)</title><link>https://maku77.github.io/p/m9vdtaq/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m9vdtaq/</guid><description>std::any::type_name 関数を使うと、型パラメーターで指定した型の名前を、文字列表現で取得することができます。 次の例では、String 型の型名を取得しています。
let name = std::any::type_name::&amp;lt;String&amp;gt;(); println!(&amp;#34;{}&amp;#34;, name) //=&amp;gt; alloc::string::String 返される文字列の形式は明確には仕様化されておらず、Rust のバージョンごとに変わったりするので、この文字列に依存したビジネスロジックは記述すべきではない とされています（診断用にのみ使用できます）。
次のようなユーティリティ関数を作成すれば、任意のリテラル値や変数の型を簡単に調べることができます。
fn print_type_of&amp;lt;T&amp;gt;(_: T) { println!(&amp;#34;{}&amp;#34;, std::any::type_name::&amp;lt;T&amp;gt;()) } fn main() { print_type_of(0); //=&amp;gt; i32 print_type_of(0b1111); //=&amp;gt; i32 print_type_of(0i8); //=&amp;gt; i8 print_type_of(0u64); //=&amp;gt; u64 print_type_of(0.1); //=&amp;gt; f64 print_type_of(0.1e5); //=&amp;gt; f64 print_type_of(0.1f32); //=&amp;gt; f32 print_type_of(0.1e5f32); //=&amp;gt; f32 print_type_of(&amp;#39;a&amp;#39;); //=&amp;gt; char print_type_of(&amp;#34;Hello&amp;#34;); //=&amp;gt; &amp;amp;str }</description></item><item><title>Rust の Result 型の基本 ─ 成功と失敗を表現する型</title><link>https://maku77.github.io/p/us2ahpw/</link><pubDate>Thu, 29 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/us2ahpw/</guid><description>Result 型とは？ Rust の標準ライブラリには、std::result::Result という列挙型 (enum) が用意されており、何らかの処理が「成功」したこと、あるいは「失敗」したことを表現するために使われます（仕組み的には、値の「有無」を表現する Option 型 と同様です）。 他の言語では、例外 (exception) の仕組みでエラーの発生を表現したりしますが、Rust では Result 型を使ってエラーを表現します（Rust には例外の仕組みが存在しません）。 Result 列挙型のバリアントとしては、次のように Ok と Err だけが定義されており、それぞれが何らかの処理の「成功」と「失敗」を表現します。
Result 型の定義 enum Result&amp;lt;T, E&amp;gt; { Ok(T), // T 型の成功値 Err(E), // E 型の失敗値 } 成功と失敗を表すだけであれば、bool 型だけで表現できそうですが、Result 型は Ok と Err というバリアントが任意の値を持つことができるようになっているので、成功した場合の結果や、失敗した場合の理由を表現することができます。 また、何らかのメソッドが Result 型を返すとき、その値を呼び出し側で利用していないと、コンパイラが警告を出してくれるため、エラーのハンドル忘れを防ぐ効果 があります。 Result 型の概念は、他のモダンな言語でも採用されています（例: Kotlin の Result 型）。
これらのシンボルはデフォルトでインポートされるようになっており、Result、Ok、Err と記述するだけで使用することができます（Result::Ok や Result::Err のように記述する必要はありません）。
Result を処理する Result インスタンスから Ok バリアントや Err バリアントの情報を取り出すには、match 式や if let 式を使います。 以下のサンプルコードでは、str::parse メソッドで、数値を含む文字列をパースして i32 値に変換しています。 パースに成功すると Ok バリアントが返されるので、そこからパース結果を取り出すことができます。 パースに失敗すると Err バリアントが返されるので、そこからエラー情報（ParseIntError など）を取り出すことができます。</description></item><item><title>Rust プログラミングを始める（rustc と cargo コマンド）</title><link>https://maku77.github.io/p/96o6xfv/</link><pubDate>Sun, 11 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/96o6xfv/</guid><description>Rust 関連コマンドのインストール Rust のインストール Rust コンパイラ (rustc) や Rust 用のパッケージマネージャー (cargo) は、下記の公式サイトの手順で簡単にインストールできます。 推奨されている方法でインストールすると、Rust 関連のコマンドをアップデートするための rustup コマンドもインストールされます。
公式サイト: Rust をインストール - Rustプログラミング言語 Rust のインストール方法の例（Linux/macOS の場合） $ curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 標準構成でインストールすると、Rust 関連の各コマンドが ~/.cargo/bin/ ディレクトリにインストールされます。
Rust 関連コマンドの一覧 $ ls ~/.cargo/bin cargo* clippy-driver* rust-lldb* rustup* cargo-clippy* rls* rustc* cargo-fmt* rust-gdb* rustdoc* cargo-miri* rust-gdbgui* rustfmt* Rust のバージョンアップ 一度 rustup コマンドのインストールが済んでしまえば、上記の Rust 関連コマンド（Rust ツールチェイン）は次のようにまとめてアップデートできます。
Rust ツールチェインの更新 $ rustup update Rust のアンインストール Rust 関連コマンドを削除したいときも、rustup コマンドを使用します。 次のようにすると、rustup コマンドを含む、すべての Rust 関連コマンドがアンインストールされます（$HOME/.</description></item></channel></rss>