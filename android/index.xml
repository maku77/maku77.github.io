<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on 天才まくまくノート</title><link>https://maku77.github.io/android/</link><description>Recent content in Android on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 08 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android エミュレーターをコマンドラインから操作する (emulator, adb emu)</title><link>https://maku77.github.io/p/zgyhygw/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zgyhygw/</guid><description>emulator コマンドと adb コマンド Android SDK に付属している emulator コマンドや adb コマンドを使うことで、Android のエミュレーターを操作することができます。
emulator コマンド エミュレーター端末 (= AVD: Android Virtual Device) の一覧を表示したり、エミュレーター端末を起動したりするのに使うコマンドです。 adb コマンド エミュレーター端末が起動した後に、コマンドを送り込んで各種操作を行います。adb はエミュレーター専用のコマンドではありませんが、adb emu のようなエミュレーターに特化したサブコマンドがあります。 emulator コマンドは、Android SDK をインストールしたディレクトリの emulator ディレクトリに格納されています。 例えば次のようなパスにあります（ユーザー名が maku の場合）。
Windows の場合: C:\Users\maku\AppData\Local\Android\Sdk\emulator\emulator.exe macOS の場合: /Users/maku/Library/Android/sdk/emulator/emulator 次のような感じで OS のパスを通しておくと、どこからでもコマンドを実行できるようになります。
~/.zlogin（macOS で zsh の場合） export ANDROID_HOME=~/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin export PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/tools ☝️ emulator/emulator と tools/emulator tools ディレクトリにも同名の emulator コマンドがあったりしますが、こちらではなく、emuator ディレクトリの方にあるコマンドを使うのが正解のようです。 なので、パスを通すときは、emulator ディレクトリが先に来るように指定しておく必要があります。 emulator コマンドの使用例 AVD（エミュレーター端末）のリストを表示する (emulator -list-avds) $ emulator -list-avds phone-s phone-t tv-s tv-t AVD 名には、上記のようなシンプルな名前を付けておくのがおすすめです。 エミュレーターを起動するときに AVD を指定するのが楽になります。</description></item><item><title>Android エミュレーター内のサーバーに外部からアクセスする (adb forward)</title><link>https://maku77.github.io/p/q6r98p8/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q6r98p8/</guid><description>Android エミュレーターへのポート転送 (adb forward) サーバー機能を持つ Android アプリをエミュレーターで動作させているときに、ホスト PC の外からエミュレーター内のサーバーにアクセスするには、adb forward コマンドによるポート転送の設定が必要です。 例えば、次のようにフォワード設定すると、ホスト PC の 9080 番ポートへのアクセスが、エミュレーターの 8080 番ポートへ転送されるようになります。
PC の 9080 ポートをエミュレーターの 8080 ポートへ転送 $ adb forward tcp:9080 tcp:8080 9080 次の図は、Android エミュレーターを動かしている開発用 PC (192.168.1.1) を経由して、エミュレーター内の Web サーバーにアクセスする構成を示しています。
図: adb forward によるポート転送 外部の端末（PC やスマホ）から見ると、開発 PC (192.168.1.1) 上で Web サーバーが動いているかのように見えます。 Web ブラウザーで http://192.168.1.1:9080 という URL を開けば、エミュレーター内の Web サーバーに繋がります。 開発 PC 上で Web ブラウザーを開いてアクセスする場合は、自分自身にアクセスする形になるので、http://localhost:9080 や http://127.0.0.1:9080 のようなループバックアドレスを指定します。 この構成は、Android アプリ内のサーバープログラムを、PC 上のツールを使ってデバッグしたいときに便利です。
正確に言うと、adb forward によるポート転送はエミュレーター専用というわけではないので、USB で接続されている Android 端末への転送も可能です。 ただ、通常、物理スマホなどは直接 LAN に繋がっていることが多いので、ポート転送が必要になるケースは少ないでしょう（adb shell ip addr で端末のアドレスを確認して直接アクセスした方が早い）。</description></item><item><title>Golang で Android 上で動く CLI コマンドを作成する (go build)</title><link>https://maku77.github.io/p/ftducta/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ftducta/</guid><description>何をするか？ Golang（Go 言語）のクロスコンパイル機能を使うと、Android 上で動作するコマンドラインツール (CLI) を簡単に作成することができます。 Android 端末上で何らかの解析をするときに、Android 組み込みの Linux コマンドだとちょっと足りないな、といったときに便利です。 ここでは、Golang で簡単な Hello World アプリをビルドして、Android 端末上で動かしてみます。
Go 言語全般に関してはこちらを参照 → まくまく Golang ノート Android 端末の CPU アーキテクチャを確認しておく Golang でのクロスコンパイル時に CPU アーキテクチャを指定する必要があるので、対象の Anrdoid 端末のアーキテクチャを先に確認しておきます。 adb shell で Android 端末にシェル接続して、uname -a コマンドの末尾あたりで確認してしまうのが手っ取り早いです。
$ adb shell uname -a Linux localhost 5.10.100 #1 SMP PREEMPT Thu Mar 17 17:10:36 UTC 2022 aarch64 arm や aarch という文字列が入っていたら、ARM アーキテクチャの CPU だと思ってよいです。
Golang プログラムをビルドする 下記は、Golang の Hello World プログラムです。</description></item><item><title>ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)</title><link>https://maku77.github.io/p/uh84kfj/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uh84kfj/</guid><description>（確認バージョン: Android 12 (S)）
pm list packages コマンド adb shell pm list packages コマンドを使用すると、Android デバイスにインストールされているパッケージ (APK) の一覧を取得できます。 パッケージ名は順不同で表示されるので、出力をパイプで sort につなぐと見やすくなります。
$ adb shell pm list packages | sort ... package:com.google.android.apps.maps package:com.google.android.apps.messaging package:com.google.android.apps.nexuslauncher package:com.google.android.apps.photos package:com.google.android.apps.restore package:com.google.android.apps.wallpaper ... -f オプションを付けて実行すると、各 APK の インストール先のパス を調べることができます。
$ adb shell pm list packages -f | sort ... package:/system/priv-app/UserDictionaryProvider/UserDictionaryProvider.apk=com.android.providers.userdictionary package:/system/priv-app/VpnDialogs/VpnDialogs.apk=com.android.vpndialogs package:/system_ext/priv-app/CarrierConfig/CarrierConfig.apk=com.android.carrierconfig package:/system_ext/priv-app/EmergencyInfo/EmergencyInfo.apk=com.android.emergency ... -3 オプションを付けて実行すると、サードパーティ製のパッケージ の一覧を表示できます。 つまり、Google Play ストアからインストールしたアプリや、自分で作ってインストールしたアプリの一覧を確認できます。
$ adb shell pm list packages -3 package:com.</description></item><item><title>dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認）</title><link>https://maku77.github.io/p/26hr2bk/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/26hr2bk/</guid><description>Janky frames 情報を取得する Android デバイス上で実行可能なコマンド dumpsys gfxinfo を使用すると、指定したアプリにおける Janky frames（ジャンクフレーム）の発生率を調べることができます。 Janky frame の説明は「dropped frame」と書かれていたりしますが、60FPS 出ていないフレーム（16.6ミリ秒以上かかったフレーム）だと考えればよいと思います。 アプリの UI が、どの程度ぬるぬるさくさくなアニメーション (60FPS) を達成できているかを定量的に調べたいときに使えるかもしれません。
$ adb shell dumpsys gfxinfo com.example.myapp | grep frames Total frames rendered: 544 Janky frames: 242 (44.56%) 本来 dumpsys gfxinfo の出力はもっと長いのですが、上記では frames という単語で grep してフィルタしちゃってます（Windows なら findstr を使えば OK）。 Janky frames の発生率を確認したいのであれば、これが手っ取り早いです。 dumpsys gfxinfo の詳細は下記ドキュメントが参考になります。
参考: UI パフォーマンスをテストする｜Android デベロッパー フレームの計測単位 Total frames rendered は、アプリを起動してからの総フレーム数を表しています。 ただし、この数はフレームメトリクスとして計測されたフレームのみが対象で、アニメーションが発生していないときは増加しません。 これは、開発者オプションの Profile HWUI rendering を有効にしたときに、画面上にバーが増えていく速度と同じです。</description></item><item><title>Perfetto でシステム全体のパフォーマンスを計測する</title><link>https://maku77.github.io/p/ehu5eox/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ehu5eox/</guid><description>Perfetto とは Android 端末のシステム全体のプロファイリングを行うには、Perfetto というツールを使用します。 システム全体の動作を調査する場合、従来は Systrace を使っていましたが、Android 10 (Q) 以降は、より洗練された Perfetto で分析を行うことができます。
Perfetto - System profiling, app tracing and trace analysis - Perfetto Tracing Docs Android には Perfetto 用のトレースデーモンと、トレースデータを取得するための perfetto コマンドが標準搭載されています。
取得したトレースデータは、Perfetto の Web アプリ (Perfetto UI) から読み込んで、グラフィカルな UI で分析を行うことができます。 開発 PC と Android 端末が Bluetooth や USB 接続されていれば、Perfetto UI から直接トレースデータを取得することができます。
Perfetto デーモンの有効化 （この設定は、Android 10 (Q) の端末でのみ必要です。Android 11 (R) 以降は必要ありません）
perfetto コマンドでトレースを開始するには、Android 端末上で Perfetto デーモンを起動しておく必要があります。 次のようにシステムプロパティを設定すれば、Perfetto デーモンが起動します。
$ adb shell setprop persist.</description></item><item><title>Android アプリのパフォーマンス改善のためのチェックリスト</title><link>https://maku77.github.io/p/sfqyajt/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sfqyajt/</guid><description>はじめに パフォーマンスの最適化を行うには、フレームワーク特有の知識と、プロファイラによる計測 の両面から攻めていく必要があります。 アプリケーションを 60FPS の描画性能で動作させるには、1フレームあたりわずか 16.6 ミリ秒で処理を終えなければいけません。 複雑な計算処理や描画を行うアプリケーションにおいて、常に 60FPS を達成するのは非常に大変で、考えるべきことがたくさんあります。 ここでは、Android アプリのパフォーマンス改善のヒントをまとめておきます。
パフォーマンス可視化自動化のススメ 定期的にパフォーマンスに関するプロファイリングを行うのはよいことですが、もっといい方法は、パフォーマンスに関する計測を自動化＆見える化 することです。 例えば次のような仕組みを作り、普段の開発では常に有効化しておきます。
各フェーズの実行にかかった時間を、画面上に自動で表示する 画面上に FPS を表示する 各端末のパフォーマンス（メトリクス情報）を自動でサーバーに送り、統計をグラフ化する このような仕組みを作り込んでおけば、チームメンバー全員が普段からパフォーマンスを意識 して開発できるようになります。 アーキテクトだけにプロファイリング作業を任せたり、プロジェクト終盤になってからパフォーマンス計測をはじめたりするのはやめましょう。 コードを作り込んでからデータ構造やスレッド戦略を変更するのはとても大変で、手遅れになることが多いです。
上記の仕組みによって表示された結果は、製品リリースのためのパフォーマンスクライテリアを満たしているかの指標にもなります。
まずは計測 FPS の確認（1 フレームあたり何ミリ秒かかっているか） 開発者オプションから GPU バー表示を ON にして確認 GPU レンダリング速度のプロファイリング Profile HWUI rendering の設定は ADB で OFF/ON する と素早く切り替えられる 何らかの操作をしているときに、赤色のライン (16.6ms) を上回ることがないか を調べる Window.OnFrameMetricsAvailableListener でフレームごとのメトリクス情報を取得できる Firebase などを使えるのであれば、メトリクス情報をサーバー集計することが可能 Choreographer を使ってプログラム内で FPS を確認する 方法もあり adb shell dumpsys gfxinfo PKG名 | grep frames で ジャンクフレーム発生率を調べる オーバードローの確認（Debug GPU overdraw で何度も重ねて描画している部分がないか確認） レイアウトの確認（Layout Inspector で無駄なネストを確認） 全般的なボトルネックの確認 CPU Profiler でアプリ内のボトルネックを調査（Traceview はサポート終了） 各スレッドのビジー状態や、どのメソッドに時間がかかっているか を調べる → メソッド単位の最適化 GC (Garbage Collection) が頻繁に発生していないか を調べる (Perfeto/SystraceAllocation Tracker)。 Perfetto でシステム全体のボトルネックを調査 他のプロセスとの Binder 通信などがボトルネックになっていなかを調べる adb shell perfetto で計測開始するか、Perfetto の Web アプリから直接データ取得可能（要 Bluetooth/USB 接続） 昔は Systrace だったけど、Android 10 以降は Perfetto で。 改善ポイント 背景色描画の削減 背景色は、テーマ、Activity、Fragment、View のいずれかのレイヤで一回のみ指定する テーマの背景色が余計なときは、テーマの定義で android:windowbackground=&amp;quot;null&amp;quot; するか、Activity で window.</description></item><item><title>ADB で描画パフォーマンス計測のデバッグ機能を有効にする</title><link>https://maku77.github.io/p/bn8q8o6/</link><pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bn8q8o6/</guid><description>Android の開発者向けオプション (Developer options) には、描画パフォーマンスなどを測定するための便利なツールが揃っています。 特に、GPU オーバードロー領域の表示や、レンダリングプロファイル（画面上にバー表示）は、描画パフォーマンス 60 FPS を達成するために必須のツールです。
でも、これらの設定項目は設定メニューの深いところにあって、ホーム画面に戻って毎回切り替えるのは手間がかかります。 実はこれらのオプション設定は、adb shell から setprop コマンドを実行することで簡単に切り替えることができます。 コマンドからこれらの設定を変更した場合は、すぐに設定が有効にならないことがあるので注意してください。 その場合は、アプリの再起動や、アプリ内での画面遷移などを発生させると有効になるようです。
各種デバッグ項目の ADB からの設定方法 Show view updates（GPU表示の更新を表示） ON にすると、GPU での描画時にウィンドウ内の表示を点滅させます。 (Flash views inside windows when drawn)
設定方法 意味 adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を OFF adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を ON Show hardware layers updates（ハードウェア層情報を表示） ON にすると、ハードウェア層が更新されると緑を表示します。 (Flash hardware layers green when they update)
GPU を活用した描画が行えているのであれば、GPU 層での更新は頻繁に発生するものではありません。 新しいビューが生成されたときのみ緑色のフラッシュが発生していれば OK です。
設定方法 意味 adb shell setprop debug.</description></item><item><title>Choreographer で FPS を計測する（Fps クラスの実装）</title><link>https://maku77.github.io/p/imx8hr2/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/imx8hr2/</guid><description>Choreographer クラスによる FPS 計測 Android の Choreographer クラスを使用すると、フレームの描画開始のタイミングで呼び出されるコールバック (Choreographer.FrameCallback) を登録することができます。
Choreographer#postFrameCallback(callback: Choreographer.FrameCallback!) 上記のメソッドでコールバックを登録すると、次のフレーム描画のタイミングで doFrame(long frameTimeNanos) メソッドが呼び出されます。
Choreographer.FrameCallback#doFrame(frameTimeNanos: Long) パラメータとして描画開始時刻（ナノ秒単位）が渡されるため、前回のコールバック時の描画開始時刻からの差分を取れば、1 フレームの描画にかかった時間を求めることができます。 この値を使えば、FPS (Frame per second) は下記のように計算できます。
FPS = 1秒あたりのナノ秒 / 描画にかかった時間（ナノ秒） サンプルコード Fps クラスの実装 下記の Fps クラスは、FPS を簡単に計測するためのクラスです。 内部で Android の Choreographer を使っています。
Fps.kt import android.view.Choreographer import java.util.concurrent.TimeUnit class Fps : Choreographer.FrameCallback { interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Float) } private val choreographer = Choreographer.</description></item><item><title>ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast)</title><link>https://maku77.github.io/p/eezeq4g/</link><pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eezeq4g/</guid><description>以下のコマンドは、adb shell でデバイスに接続した状態から実行することを想定しています。 接続と同時に実行するには、adb shell を先頭に追加して実行してください（例: adb shell am start ...）。
Activity（アクティビティ）を起動する シェル上で am start コマンドを実行すると、Intent を発生させて Activity を起動することができます。
am start &amp;lt;INTENT&amp;gt; Intent 引数（&amp;lt;INTENT&amp;gt; の部分）の指定方法は、Specification for INTENT arguments のページに詳しく記載されています。 具体的には、次のようなオプションの組み合わせで Intent を構成します。
-a &amp;lt;ACTION&amp;gt; 例: -a android.intent.action.VIEW -d &amp;lt;DATA_URI&amp;gt; 例: -d content://contacts/people/1 -t &amp;lt;MIME_TYPE&amp;gt; 例: -t image/png -c &amp;lt;CATEGORY&amp;gt; 例: -c android.intent.category.APP_CONTACTS -n &amp;lt;COMPONENT&amp;gt; 例: -n com.example.app/.ExampleActivity 必要に応じて、Bundle データを渡すこともできます。
--esn &amp;lt;EXTRA_KEY&amp;gt; （キーのみ） -e|--es &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt; --ez &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_BOOLEAN_VALUE&amp;gt; --ei &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt; --el &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt; --ef &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt; --eu &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_URI_VALUE&amp;gt; --ecn &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_COMPONENT_NAME_VALUE&amp;gt; --eia &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt;[,&amp;lt;EXTRA_INT_VALUE.</description></item><item><title>APK のパッケージ依存関係やクラス依存関係を調べる</title><link>https://maku77.github.io/p/w6ste5j/</link><pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w6ste5j/</guid><description>ここでは、jdeps と dex2jar を使って、APK ファイル内の依存関係を調査する方法を示します。
jdeps と dex2jar JDK 8 にはパッケージ依存関係やクラス依存関係を調べるための jdeps コマンドが標準搭載されました。
jdeps コマンド - Oracle Java Documentation これを使用すると、.class ファイル（あるいは .jar ファイル）を入力情報として、そこから参照しているクラスやパッケージの情報を調べることができるのですが、Android の APK としてビルドされたコードは .dex ファイルになっていますので、まずはこれを通常の .class 形式に変更してやる必要があります。 APK ファイル内の .dex を .class 形式に変換するには、dex2jar というツールを使用します。
dex2jar のダウンロード 上記から、たとえば dex-tools-2.1-20150601.060031-26.zip をダウンロードし、パスの通ったディレクトリに展開すればインストール完了です。
APK ファイルのパッケージ依存、クラス依存情報を調べる まず、d2j-dex2jar コマンドを使用して、APK ファイル内の .dex を .class 形式に変換します。 APK ファイルを unzip して取り出した .dex ファイルを変換することもできますが、下記のように直接 APK ファイルを .jar に変換してしまうのが手っ取り早いです。
apk から jar への変換 $ d2j-dex2jar app/build/outputs/apk/app-debug.apk -o app.jar dex2jar app/build/outputs/apk/app-debug.</description></item><item><title>ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts)</title><link>https://maku77.github.io/p/jfqtfyn/</link><pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jfqtfyn/</guid><description>dumpsys コマンドの activity broadcast サブコマンドを実行すると、ブロードキャストインテントをハンドルするように登録しているレシーバーの一覧を確認することができます。
$ adb shell dumpsys activity broadcasts 実行結果（抜粋） ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts) Registered Receivers: ... * ReceiverList{82bcce 603 com.android.systemui/10019/u0 remote:83b3dc9} app=603:com.android.systemui/u0a19 pid=603 uid=10019 user=0 Filter #0: BroadcastFilter{28557ef} Action: &amp;#34;android.intent.action.TIME_TICK&amp;#34; Action: &amp;#34;android.intent.action.TIME_SET&amp;#34; Action: &amp;#34;android.intent.action.BATTERY_CHANGED&amp;#34; ... AutoVerify=false Filter #1: BroadcastFilter{56b72fc} Action: &amp;#34;android.intent.action.BOOT_COMPLETED&amp;#34; mPriority=1000, mHasPartialTypes=false AutoVerify=false ... Registered Receivers のセクションには、アプリごとにどのようなフィルタでインテントを監視しているかが表示されます。 上記の例では、com.android.systemui アプリが、android.intent.action.TIME_TICK インテントなどのブロードキャストを監視していること示しています。
さらに下の方を見ると、Receiver Resolver Table というセクションがあります。
Receiver Resolver Table: ... Non-Data Actions: ... android.intent.action.BOOT_COMPLETED: BroadcastFilter{10f199e u0 ReceiverList{b1ecbd9 493 system/1000/u0 local:28f4620}} BroadcastFilter{989a5ad u0 ReceiverList{ae0d2c4 493 system/1000/u0 local:48b9d7}} BroadcastFilter{213887b u0 ReceiverList{758680a 493 system/1000/u0 local:513e075}} BroadcastFilter{56b72fc u0 ReceiverList{82bcce 603 com.</description></item><item><title>ADB からキー入力やテキスト入力を行う (input text, input keyevent)</title><link>https://maku77.github.io/p/gorux24/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gorux24/</guid><description>ADB shell 上で input コマンドを使用すると、任意のキー入力やテキスト入力をエミュレートすることができます。
キー入力の例 (input keyevent) input keyevent コマンドを使用することで、単一のキー入力をエミュレートできます。
$ adb shell input keyevent ENTER # Enter キー $ adb shell input keyevent DPAD_CENTER # D-pad 上の決定キー $ adb shell input keyevent DPAD_RIGHT # 右キー $ adb shell input keyevent POWER # 電源キー $ adb shell input keyevent A # キーボードの A キー $ adb shell input keyevent TV # TV キー（Android TV 用） $ adb shell input keyevent NUMBER_ENTRY # 10-key キー（Android TV 用） $ adb shell input keyevent TV_TERRESTRIAL_DIGITAL # 地デジキー（Android TV 用） パラメータに指定できるキー名は、android.</description></item><item><title>Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd)</title><link>https://maku77.github.io/p/ycwfweu/</link><pubDate>Wed, 13 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ycwfweu/</guid><description>（追記） Android 10 (Q) 以降では、より洗練された Perfetto を使ってパフォーマンス解析できます。
systrace コマンドの基本 Android - Systrace Android - Analyzing UI Performance with Systrace Android SDK に付属している systrace.py スクリプトを使用すると、Android デバイス全体のプロセスに関するプロファイリングを行うことができます（I/O アクセスや UI スレッドの状況など）。 systrace は Python スクリプトとして提供されているため、実行するときは下記のような感じでパラメータを指定して実行します。
例: 10 秒間の systrace 実行する $ cd android-sdk/platform-tools/systrace $ python systrace.py --time=10 -o trace.html sched gfx view wm プロファイルの取得が完了すると、プロファイル結果を表示するための HTML ファイルがカレントディレクトリに作成されます。
Capturing trace......................................................Done. Downloading trace....Done. wrote file://C:\trace.html この HTML を Web ブラウザで開いてボトルネックの分析を行うことができます。 Web ブラウザ上で ? キーを押すと、使用できるショートカットキーの一覧を確認できます。
バッチファイル化 systrace コマンドを実行するときに、同じようなパラメータを毎回指定するのは面倒ですし、Windows 環境ですと PATH を通したりするのも若干面倒ですので、下記のようなバッチファイルを作成しておくと便利です。</description></item><item><title>Ruby で adb コマンドの出力結果を処理する</title><link>https://maku77.github.io/p/w6vao2e/</link><pubDate>Wed, 06 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w6vao2e/</guid><description>下記は、Ruby スクリプトの中から adb shell コマンドを呼び出して、その出力をハンドルするサンプルです。
ここで定義している adb_shell メソッドは、受け取ったコマンド文字列を adb shell の後ろにくっつけた形のコマンドを実行します（adb_shell('pm list packages') とすると、adb shell pm list packages が実行される）。
sample.rb # Executes the command via &amp;#39;adb shell&amp;#39;. # Obtained result will be passed to the specified block line by line. def adb_shell(command) result = `adb shell #{command}` result.gsub!(&amp;#34;\n\n&amp;#34;, &amp;#34;\n&amp;#34;) # for Windows result.lines { |line| yield line } end # Test if $0 == __FILE__ adb_shell(&amp;#39;pm list packages&amp;#39;) do |line| puts &amp;#39;==&amp;gt; &amp;#39; + line end end 実行結果 $ ruby sample.</description></item><item><title>APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages)</title><link>https://maku77.github.io/p/ghtgxgw/</link><pubDate>Mon, 27 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ghtgxgw/</guid><description>指定したパッケージの APK のファイルパスを調べる Android デバイスに adb shell で接続し、pm path &amp;lt;パッケージ名&amp;gt; コマンドを実行すると、指定したパッケージ名の APK ファイルが、デバイス上のどのパスに置かれているかを調べることができます。
com.example.myapp パッケージがどの APK ファイルか調べる $ adb shell pm path com.example.myapp package:/system/app/MyApp/MyApp.apk インストールされているすべての APK のファイルパスとパッケージ名を調べる インストールされている APK パッケージの一覧は、pm list packages コマンドで調べることができます。
インストール済みパッケージの一覧を表示 $ adb shell pm list packages package:com.google.android.apps.mediashell package:com.google.android.katniss package:com.android.providers.calendar package:com.android.tv.settings package:com.android.providers.media ... さらに、-f オプションを指定して実行すると、すべての APK に関するファイルパスとパッケージ名の対応情報を調べることができます。 sort コマンドと組み合わせて使用すると見やすくなります。
APK 名とパッケージ名の対応リスト $ adb shell pm list packages -f | sort package:/system/app/Backdrop/Backdrop.apk=com.google.android.backdrop package:/system/app/BasicDreams/BasicDreams.apk=com.android.dreams.basic package:/system/app/Bluetooth/Bluetooth.apk=com.android.bluetooth package:/system/app/KeyChain/KeyChain.apk=com.android.keychain ... システムにプリインストールされているアプリケーションだけを列挙したい場合は、-s オプションも同時に指定します。</description></item><item><title>Systrace の画面が真っ白になるときの対応方法</title><link>https://maku77.github.io/p/u3n5m3j/</link><pubDate>Wed, 08 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/u3n5m3j/</guid><description>追記 (2021-04): 現在は Systrace は deprecated になっており、Perfetto という新しいトレースツールを使うことができます（参考: Perfetto でシステム全体のパフォーマンスを計測する。 過去に systrace で取得したトレースファイルを開きたいときは、Perfetto UI のサイト上で Open with Legacy UI から開くことができます。
Android の DDMS などで利用可能な systrace を実行すると、trace.html ファイルが生成されますが、この中で非推奨になった JavaScript API(Object.observe) を使用しているため、最新の Chrome では表示できない問題が出ています。
参考: http://stackoverflow.com/questions/36865899/react-native-android-systrace-html-is-blank-in-ubuntu-14-04/37008945 上記サイトでの回避策としては、生成された HTML のヘッダに下記を追加することがあげられています。
&amp;lt;script src=&amp;#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 生成される HTML ファイルを毎回修正するのが面倒な場合は、Android SDK のディレクトリにある下記のファイルを編集するという方法もあります。 このファイルに追記した内容は、生成される HTML にも反映されるようになります。
$ANDROID_SDK/platform-tools/systrace/prefix.html &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head i18n-values=&amp;#34;dir:textdirection;&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34;&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;/&amp;gt; &amp;lt;script src=&amp;#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; ★これを追加</description></item><item><title>Android アプリのパフォーマンス改善に使用できるツール</title><link>https://maku77.github.io/p/39cfimo/</link><pubDate>Tue, 07 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/39cfimo/</guid><description>systrace / perfetto: システム全体の負荷状況などを調べる systrace を使用すると、カーネルレベルでの CPU 負荷状況などを調べられるため、システム全体で重くなっている場合などの一次分析に使用できます。 DDMS ツール (monitor.bat) から任意のタイミングでプロファイル取得できます。
（追記） Android 10 (Q) 以降は、より洗練された Perfetto を使用してください。
参考: Perfetto でシステム全体のパフォーマンスを計測する traceview: アプリ内のメソッド呼び出し数などを調べる traceview を使用すると、特定のアプリ内のメソッド単位のプロファイル情報を取得することができます。 メソッド呼び出し回数が想定よりも多くなっているとか、処理に時間がかかりすぎているメソッドなどを発見できます。
DDMS ツールから任意のタイミングでプロファイル取得できます。あるいは、コードに開始／終了タイミングを明示することで、ピンポイントで特定の区間のプロファイルを取得することもできます。
Show GPU overdraw: 同じ領域を何度も描画しないか調べる 開発者オプションで Show GPU overdraw の機能を有効にすると、画面上に重ねて描画される領域があったときに、その領域が描画回数に応じた色で矩形表示されるようになります。 例えば、赤色で矩形表示された場合は、その領域が 3 回以上重複して描画されていることを示しており、プログラム内の描画シーケンスを見直すべきだと分かります。
Show GPU overdraw の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Drawing → Show GPU overdraw)。
Profile GPU rendering: 60FPS で描画できている調べる 開発者オプションで Profile GPU rendering の機能を有効にすると、描画フレームごとに UI スレッドでかかった時間を画面上にバー表示することができます。 緑色のラインは 16.6ms を示しており、このラインを超えるということは 60 FPS で描画できていないということです。メインスレッド上で描画以外の処理を行っていないか見直す必要があります。</description></item><item><title>ADB で指定したアプリを強制終了する (am force-stop)</title><link>https://maku77.github.io/p/9yse3iz/</link><pubDate>Mon, 06 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9yse3iz/</guid><description>Android 端末に ADB 接続された状態で adb shell am force-stop コマンドを実行すると、任意のアプリケーションを強制終了することができます。
$ adb shell am force-stop com.example.myapp adb shell 接続されている状態であれば、adb shell の部分は省略して実行します。
generic_x86:/ $ am force-stop com.example.myapp ちなみに、インストールされているアプリのパッケージ名一覧は adb shell pm list packages で調べることができます（こちらは am じゃなくて pm コマンドであることに注意してください）。
参考: ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)</description></item><item><title>ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk)</title><link>https://maku77.github.io/p/8k5m4k2/</link><pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8k5m4k2/</guid><description>Android SDK に付属している android コマンドの list sdk サブコマンドを使用すると、追加でインストール可能な SDK コンポーネントの一覧を取得することができます。
インストール可能な SDK コンポーネント $ android list sdk --no-ui --all --extended ... ---------- id: 157 or &amp;#34;extra-google-usb_driver&amp;#34; Type: Extra Desc: Google USB Driver, revision 11 By Google Inc. USB Driver for Windows, revision 11 Install path: extras\google\usb_driver ---------- id: 158 or &amp;#34;extra-google-webdriver&amp;#34; Type: Extra Desc: Google Web Driver, revision 2 By Google Inc. WebDriver Install path: extras\google\webdriver ---------- id: 159 or &amp;#34;extra-intel-Hardware_Accelerated_Execution_Manager&amp;#34; Type: Extra Desc: Intel x86 Emulator Accelerator (HAXM installer), revision 5.</description></item><item><title>protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions)</title><link>https://maku77.github.io/p/8x8qmy3/</link><pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8x8qmy3/</guid><description>pm list permissions コマンドに -d オプションを付けて実行すると、protectionLevel が dangerous に設定されたパーミッションのみを一覧表示してくれます。 Android M からは、dangerous なパーミッションはユーザが個別に On/Off することができるようになったため、どのようなパーミッションが存在しているのかを把握することがより重要になりました。
shell@xxx:/ $ pm list permissions -d Dangerous Permissions: permission:com.android.providers.tv.permission.READ_EPG_DATA permission:com.android.providers.tv.permission.WRITE_EPG_DATA adb shell で接続する前に実行する場合は、上記のコマンドの先頭に adb shell を付けて実行してください。</description></item><item><title>パーミッショングループの一覧を表示する (pm list permission-groups)</title><link>https://maku77.github.io/p/viry8fo/</link><pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/viry8fo/</guid><description>パーミッショングループの一覧 Android 端末内にどのようなパーミッショングループが存在しているかを調べるには、adb shell で接続した後に pm list permission-groups コマンドを使用します。
shell@xxx:/ $ pm list permission-groups permission group:android.permission-group.PHONE_CALLS permission group:android.permission-group.WALLPAPER permission group:android.permission-group.MESSAGES permission group:android.permission-group.USER_DICTIONARY permission group:android.permission-group.CALENDAR permission group:android.permission-group.BLUETOOTH_NETWORK ... adb shell で接続前に実行したい場合は、下記のように adb shell に続けてコマンド入力しても OK です。 ホスト側の PC で出力を sort したい場合などはこちらの方が便利かもしれません。
$ adb shell pm list permission-groups | sort permission group:android.permission-group.ACCESSIBILITY_FEATURES permission group:android.permission-group.ACCOUNTS permission group:android.permission-group.AFFECTS_BATTERY permission group:android.permission-group.APP_INFO permission group:android.permission-group.AUDIO_SETTINGS permission group:android.permission-group.BLUETOOTH_NETWORK ... パーミッショングループに属するパーミッションの一覧 それぞれのパーミッショングループが、どのようなパーミッションから構成されているかを調べるには、pm list permissions -g コマンドを使用します。
shell@xxx:/ $ pm list permissions -g All Permissions: group:android.</description></item><item><title>APK ファイルに署名する (keytool, jarsigner)</title><link>https://maku77.github.io/p/3yk3j2i/</link><pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3yk3j2i/</guid><description>APK に署名する方法は、従来の Java で行われていた JAR ファイルへの署名方法と同様です。 下記の JAR ファイルへの署名方法を参考にしてください。
参考: JAR ファイルの署名について - まくまく Java ノート (1) keystore ファイルを作成する ここでは下記の条件でキーを作成します。
作成するキーストアファイル名: MyKeyStore.jks エイリアス名: android 有効期限: 10000日 $ keytool -genkey -v -keystore MyKeyStore.jks -alias android -keyalg RSA -keysize 2048 -validity 10000 Enter keystore password:（キーストアのパスワードを入力） （名前や組織名などを聞かれるので順番に入力していく） (2) keystore ファイルを使って APK に署名する 上記のように作成した keystore ファイルには、非公開鍵と、それに関連付けられた X.509 証明書が含まれており、このファイルを使用して APK に署名を行うことができます。 ここでは、MyApp.apk に署名を行います。
$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore MyKeyStore.jks MyApp.apk android （キーストアのパスワードを入力）（キーエイリアスのパスワードを入力） (3) APK の署名を確認する $ jarsigner -verify -verbose -certs MyApp.</description></item><item><title>Dex 形式の Shared library (JAR) を作成する (dx)</title><link>https://maku77.github.io/p/huevdub/</link><pubDate>Thu, 30 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/huevdub/</guid><description>Android デバイスの /system/framework に以下に格納して使用する Shared JAR ライブラリは、DEX 形式にコンパイルされたクラスを含んでいる必要があります。Eclipse などで単純に JAR ファイルを生成すると、PC 用の JAR ライブラリができてしまうので、DEX 形式に変換してから /system/framework にインストールする必要があります。
$ dx --dex --output=output.jar input.jar</description></item><item><title>APK ファイルの署名を確認する (jarsigner, openssl)</title><link>https://maku77.github.io/p/2x9it3c/</link><pubDate>Fri, 22 Aug 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2x9it3c/</guid><description>署名情報を確認する方法 JDK に付属している jarsigner コマンドを使用して、APK ファイルの署名情報を確認することができます。
MyApp.apk の署名を確認する $ jarsigner -verify -certs -verbose MyApp.apk ... sm 21632 Mon Sep 01 17:08:16 JST 2014 lib/libhoge.so X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] s 36381 Fri Oct 03 14:10:34 JST 2014 META-INF/MANIFEST.MF X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] 36434 Fri Oct 03 14:10:34 JST 2014 META-INF/CERT.</description></item><item><title>メモリの使用状況を確認する (dumpsys meminfo)</title><link>https://maku77.github.io/p/t6wfxev/</link><pubDate>Tue, 29 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/t6wfxev/</guid><description>各プロセスのメモリ使用状況を確認する dumpsys コマンドの meminfo セクションでは、各プロセスのメモリ使用状況を確認することができます。
$ adb shell dumpsys meminfo Applications Memory Usage (kB): Uptime: 169910958 Realtime: 170196415 Total PSS by process: 96302 kB: system (pid 728) 44547 kB: com.android.systemui (pid 965) 32601 kB: com.sonyericsson.android.pobox.imecore (pid 1042) 29610 kB: com.android.settings (pid 8006) 26500 kB: com.sonyericsson.home (pid 1321) 23027 kB: com.facebook.katana (pid 7371) 17963 kB: com.facebook.katana:dash (pid 7641) 13579 kB: com.google.android.gms (pid 5171) ... プロセスを指定してメモリ使用状況を確認する 上記で表示されたパッケージ名や pid を、dumpsys meminfo コマンドの後ろに続けて指定することで、そのプロセスにおける詳細なメモリ使用情報を調べられます。
$ adb shell dumpsys meminfo com.</description></item><item><title>adb から Backup Manager を走らせる (bmgr backup, bmgr restore)</title><link>https://maku77.github.io/p/x9xhyhz/</link><pubDate>Thu, 26 Jan 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x9xhyhz/</guid><description>Android アプリケーションで BackupAgent を実装しておくと、設定値などを Google アカウントに紐づけてバックアップすることができます。 例えば、Android システム設定のバックアップは SettingsProvider (com.android.providers.settings) の SettingsBackupAgent クラスで実装されています。
アプリケーションの実装で、BackupManager.dataChanged() を読んでおくと、ダーティフラグがセットされて、Android が適切なタイミングで Google のサーバーにバックアップするのですが、adb shell から bmgr コマンドを使うことで、バックアップ、リストアを任意のタイミングで実行できます。
設定を Google サーバへバックアップ adb&amp;gt; bmgr backup com.android.providers.settings adb&amp;gt; bmgr run 設定を Google サーバからリストア adb&amp;gt; bmgr restore com.android.providers.settings 参考: BackupAgent | Android Developers 参考: Android Backup Service を使用して Key-Value ペアをバックアップする</description></item><item><title>APK ファイルの情報を表示する (aapt)</title><link>https://maku77.github.io/p/qqrxpjd/</link><pubDate>Sun, 11 Sep 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qqrxpjd/</guid><description>Android SDK に付属している aapt (Android Asset Packaging Tool) を使用すると、APK の情報を調べることができます。 主にリソースなどの Asset を対象としたツールですが、バージョン情報や、パーミッション情報なども調べることができます。
aapt コマンドは、昔は build-tools ディレクトリ直下にありましたが、現在は build-tools\23.0.2 のようなバージョン名のディレクトリ以下にインストールされるようです。
具体的には下記のようなオプションを指定して APK の情報を確認できます（dump パラメータは d と省略できます）。
aapt d badging myapp.apk パッケージ名、アプリ名、バージョン、パーミッション情報、サポートする Locale の一覧などを確認 aapt d permissions myapp.apk 使用しているパーミッション (uses-permission) と、定義しているパーミッション (permission) の一覧 aapt d strings myapp.apk 文字列リソースの一覧 aapt d resources myapp.apk リソースの一覧（大量に出力されるので注意） aapt d xmltree myapp.apk res/animator/fadein.xml 指定した XML リソースのツリー情報 aapt list myapp.apk リソースファイル名の一覧 aapt コマンドのヘルプ パラメータなしで、aapt コマンドを実行すると、下記のようにヘルプが表示されます。
$ aapt Android Asset Packaging Tool Usage: aapt l[ist] [-v] [-a] file.</description></item><item><title>Activity の情報を表示する (dumpsys activity)</title><link>https://maku77.github.io/p/mbnw7gq/</link><pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mbnw7gq/</guid><description>Android 端末に adb shell で接続後、dumpsys コマンドを実行すると Activity core サービスの情報を表示できます。 例えば、出力の Activity スタックを確認することで、最前面に表示されているアプリの正体を調べることができます。 dumpsys コマンドをパラメータなしで実行すると、大量のメッセージが表示されてしまうので、activity パラメータを指定して Activity に関する情報だけに絞り込むと見やすくなります。
端末上で実行する場合（adb shell でログイン後） # dumpsys activity adb 経由で実行する場合 $ adb shell dumpsys activity 例えば、以下のようにすれば、Stop 状態のアクティビティ含め、現在起動中のアクティビティの一覧を簡単に調べることができます（ここでは Windows の findstr コマンドを使用しています）。
C:\&amp;gt; adb shell dumpsys activity activities | findstr /c:&amp;#34;* TaskRecord&amp;#34; * TaskRecord{2758379e #1 A=com.google.android.leanbacklauncher U=0 sz=1} * TaskRecord{18c788c2 #7 A=com.example.myapp1 U=0 sz=1} * TaskRecord{3cffb420 #4 A=com.example.myapp2 U=0 sz=1}</description></item><item><title>APK ファイルを逆コンパイルする (apktool)</title><link>https://maku77.github.io/p/xr3n5jk/</link><pubDate>Fri, 27 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xr3n5jk/</guid><description>Apktool を使用すると、APK ファイルを逆コンパイルして、内部のファイルの内容を確認することができます。
Apktool - A tool for reverse engineering Android apk files 使い方は簡単で、次のように解析対象の APK ファイルと、出力先のディレクトリを指定するだけです。
使い方 $ apktool d &amp;lt;APKファイル名&amp;gt; &amp;lt;展開先ディレクトリ&amp;gt;</description></item><item><title>Traceview でプロファイル情報を表示する</title><link>https://maku77.github.io/p/2wgxfwd/</link><pubDate>Fri, 14 Jan 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2wgxfwd/</guid><description>参考: Traceview - Android Developers
プロファイリングデータを取得する アプリケーション内の特定のコード区間のプロファイリングを行うには、プロファイリンク期間を android.os.debug.Debug クラスの startMethodTracing() と stopMethodTracing() で囲みます。
Debug.startMethodTracing(); ... プロファイリング中 ... Debug.stopMethodTracing(); プロファイリング結果は、/sdcard/dmtrace.trace というバイナリファイルに出力されます。 端末に SD カードが挿入されていないとエラーになります。
startMethodTracing メソッドのパラメータでファイル名のベース名を指定すると、/sdcard/&amp;lt;basename&amp;gt;.trace というファイル名で出力されるようになります。 結局 SD カードに出力されることには変わりありません。
ドキュメントには、
These methods start and stop method tracing across the entire virtual machine.
と記述されているので、Debug.startMethodTracing() を呼び出した時点から、アプリケーション全体（正確には Dalvik VM 全体）のプロファイリングが行われることになります。 Activity がそのアプリのエントリポイントとなっているのなら、onCreate(), onDestroy() でそれぞれ、startMethodTracing()、stopMethodTracing() を呼び出すようにすれば、そのアプリ全体のプロファイリングを行うことができます。
プロファイリングデータを表示する Android SDK に含まれている traceview コマンドを使用すると、プロファイリング結果をグラフィカルに表示することができます。
図: Traceview 上記の図では、タイムラインに main スレッドが一本だけ表示されていますが、複数のスレッドが存在すれば、main 以外のスレッドもその下に表示されます。
まずは、/sdcard/dmtrace.trace ファイルを PC に取得します。
C:\&amp;gt; adb pull /sdcard/dmtrace.</description></item></channel></rss>