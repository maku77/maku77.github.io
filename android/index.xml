<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on 天才まくまくノート</title><link>https://maku77.github.io/android/</link><description>Recent content in Android on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Tue, 08 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android エミュレーターをコマンドラインから操作する (emulator, adb emu)</title><link>https://maku77.github.io/p/zgyhygw/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zgyhygw/</guid><description>emulator コマンドと adb コマンド Android SDK に付属している emulator コマンドや adb コマンドを使うことで、Android のエミュレーターを操作することができます。
emulator コマンド エミュレーター端末 (= AVD: Android Virtual Device) の一覧を表示したり、エミュレーター端末を起動したりするのに使うコマンドです。 adb コマンド エミュレーター端末が起動した後に、コマンドを送り込んで各種操作を行います。adb はエミュレーター専用のコマンドではありませんが、adb emu のようなエミュレーターに特化したサブコマンドがあります。 emulator コマンドは、Android SDK をインストールしたディレクトリの emulator ディレクトリに格納されています。 例えば次のようなパスにあります（ユーザー名が maku の場合）。
Windows の場合: C:\Users\maku\AppData\Local\Android\Sdk\emulator\emulator.exe macOS の場合: /Users/maku/Library/Android/sdk/emulator/emulator 次のような感じで OS のパスを通しておくと、どこからでもコマンドを実行できるようになります。
~/.zlogin（macOS で zsh の場合） export ANDROID_HOME=~/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin export PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/tools ☝️ emulator/emulator と tools/emulator tools ディレクトリにも同名の emulator コマンドがあったりしますが、こちらではなく、emuator ディレクトリの方にあるコマンドを使うのが正解のようです。 なので、パスを通すときは、emulator ディレクトリが先に来るように指定しておく必要があります。 emulator コマンドの使用例 AVD（エミュレーター端末）のリストを表示する (emulator -list-avds) $ emulator -list-avds phone-s phone-t tv-s tv-t AVD 名には、上記のようなシンプルな名前を付けておくのがおすすめです。 エミュレーターを起動するときに AVD を指定するのが楽になります。</description></item><item><title>Android エミュレーター内のサーバーに外部からアクセスする (adb forward)</title><link>https://maku77.github.io/p/q6r98p8/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q6r98p8/</guid><description>Android エミュレーターへのポート転送 (adb forward) サーバー機能を持つ Android アプリをエミュレーターで動作させているときに、ホスト PC の外からエミュレーター内のサーバーにアクセスするには、adb forward コマンドによるポート転送の設定が必要です。 例えば、次のようにフォワード設定すると、ホスト PC の 9080 番ポートへのアクセスが、エミュレーターの 8080 番ポートへ転送されるようになります。
PC の 9080 ポートをエミュレーターの 8080 ポートへ転送 $ adb forward tcp:9080 tcp:8080 9080 次の図は、Android エミュレーターを動かしている開発用 PC (192.168.1.1) を経由して、エミュレーター内の Web サーバーにアクセスする構成を示しています。
図: adb forward によるポート転送 外部の端末（PC やスマホ）から見ると、開発 PC (192.168.1.1) 上で Web サーバーが動いているかのように見えます。 Web ブラウザーで http://192.168.1.1:9080 という URL を開けば、エミュレーター内の Web サーバーに繋がります。 開発 PC 上で Web ブラウザーを開いてアクセスする場合は、自分自身にアクセスする形になるので、http://localhost:9080 や http://127.0.0.1:9080 のようなループバックアドレスを指定します。 この構成は、Android アプリ内のサーバープログラムを、PC 上のツールを使ってデバッグしたいときに便利です。
正確に言うと、adb forward によるポート転送はエミュレーター専用というわけではないので、USB で接続されている Android 端末への転送も可能です。 ただ、通常、物理スマホなどは直接 LAN に繋がっていることが多いので、ポート転送が必要になるケースは少ないでしょう（adb shell ip addr で端末のアドレスを確認して直接アクセスした方が早い）。</description></item><item><title>Golang で Android 上で動く CLI コマンドを作成する (go build)</title><link>https://maku77.github.io/p/ftducta/</link><pubDate>Fri, 21 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ftducta/</guid><description>何をするか？ Golang（Go 言語）のクロスコンパイル機能を使うと、Android 上で動作するコマンドラインツール (CLI) を簡単に作成することができます。 Android 端末上で何らかの解析をするときに、Android 組み込みの Linux コマンドだとちょっと足りないな、といったときに便利です。 ここでは、Golang で簡単な Hello World アプリをビルドして、Android 端末上で動かしてみます。
Go 言語全般に関してはこちらを参照 → まくまく Golang ノート Android 端末の CPU アーキテクチャを確認しておく Golang でのクロスコンパイル時に CPU アーキテクチャを指定する必要があるので、対象の Anrdoid 端末のアーキテクチャを先に確認しておきます。 adb shell で Android 端末にシェル接続して、uname -a コマンドの末尾あたりで確認してしまうのが手っ取り早いです。
$ adb shell uname -a Linux localhost 5.10.100 #1 SMP PREEMPT Thu Mar 17 17:10:36 UTC 2022 aarch64 arm や aarch という文字列が入っていたら、ARM アーキテクチャの CPU だと思ってよいです。
Golang プログラムをビルドする 下記は、Golang の Hello World プログラムです。</description></item><item><title>ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)</title><link>https://maku77.github.io/p/uh84kfj/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uh84kfj/</guid><description>（確認バージョン: Android 12 (S)）
pm list packages コマンド adb shell pm list packages コマンドを使用すると、Android デバイスにインストールされているパッケージ (APK) の一覧を取得できます。 パッケージ名は順不同で表示されるので、出力をパイプで sort につなぐと見やすくなります。
$ adb shell pm list packages | sort ... package:com.google.android.apps.maps package:com.google.android.apps.messaging package:com.google.android.apps.nexuslauncher package:com.google.android.apps.photos package:com.google.android.apps.restore package:com.google.android.apps.wallpaper ... -f オプションを付けて実行すると、各 APK の インストール先のパス を調べることができます。
$ adb shell pm list packages -f | sort ... package:/system/priv-app/UserDictionaryProvider/UserDictionaryProvider.apk=com.android.providers.userdictionary package:/system/priv-app/VpnDialogs/VpnDialogs.apk=com.android.vpndialogs package:/system_ext/priv-app/CarrierConfig/CarrierConfig.apk=com.android.carrierconfig package:/system_ext/priv-app/EmergencyInfo/EmergencyInfo.apk=com.android.emergency ... -3 オプションを付けて実行すると、サードパーティ製のパッケージ の一覧を表示できます。 つまり、Google Play ストアからインストールしたアプリや、自分で作ってインストールしたアプリの一覧を確認できます。
$ adb shell pm list packages -3 package:com.</description></item><item><title>ADB で Android 端末のバージョンや API レベルを調べる (getprop)</title><link>https://maku77.github.io/p/bg2g4bu/</link><pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bg2g4bu/</guid><description>ADB 経由で adb shell getprop コマンドを実行すると、Android 端末に設定されたシステムプロパティの一覧を取得することができます。 この中には、Android バージョンの情報も含まれています。
$ adb shell getprop | grep &amp;#34;ro.product.build.version&amp;#34; [ro.product.build.version.incremental]: [8015633] [ro.product.build.version.release]: [12] [ro.product.build.version.release_or_codename]: [12] [ro.product.build.version.sdk]: [32] この出力から次のようなことがわかります。
8015633 &amp;hellip; ビルドナンバー 12 &amp;hellip; Android のバージョン（この場合は Android S(12) を示す） 32 &amp;hellip; SDK バージョン</description></item><item><title>dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認）</title><link>https://maku77.github.io/p/26hr2bk/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/26hr2bk/</guid><description>Janky frames 情報を取得する Android デバイス上で実行可能なコマンド dumpsys gfxinfo を使用すると、指定したアプリにおける Janky frames（ジャンクフレーム）の発生率を調べることができます。 Janky frame の説明は「dropped frame」と書かれていたりしますが、60FPS 出ていないフレーム（16.6ミリ秒以上かかったフレーム）だと考えればよいと思います。 アプリの UI が、どの程度ぬるぬるさくさくなアニメーション (60FPS) を達成できているかを定量的に調べたいときに使えるかもしれません。
$ adb shell dumpsys gfxinfo com.example.myapp | grep frames Total frames rendered: 544 Janky frames: 242 (44.56%) 本来 dumpsys gfxinfo の出力はもっと長いのですが、上記では frames という単語で grep してフィルタしちゃってます（Windows なら findstr を使えば OK）。 Janky frames の発生率を確認したいのであれば、これが手っ取り早いです。 dumpsys gfxinfo の詳細は下記ドキュメントが参考になります。
参考: UI パフォーマンスをテストする｜Android デベロッパー フレームの計測単位 Total frames rendered は、アプリを起動してからの総フレーム数を表しています。 ただし、この数はフレームメトリクスとして計測されたフレームのみが対象で、アニメーションが発生していないときは増加しません。 これは、開発者オプションの Profile HWUI rendering を有効にしたときに、画面上にバーが増えていく速度と同じです。</description></item><item><title>Perfetto でシステム全体のパフォーマンスを計測する</title><link>https://maku77.github.io/p/ehu5eox/</link><pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ehu5eox/</guid><description>Perfetto とは Android 端末のシステム全体のプロファイリングを行うには、Perfetto というツールを使用します。 システム全体の動作を調査する場合、従来は Systrace を使っていましたが、Android 10 (Q) 以降は、より洗練された Perfetto で分析を行うことができます。
Perfetto - System profiling, app tracing and trace analysis - Perfetto Tracing Docs Android には Perfetto 用のトレースデーモンと、トレースデータを取得するための perfetto コマンドが標準搭載されています。
取得したトレースデータは、Perfetto の Web アプリ (Perfetto UI) から読み込んで、グラフィカルな UI で分析を行うことができます。 開発 PC と Android 端末が Bluetooth や USB 接続されていれば、Perfetto UI から直接トレースデータを取得することができます。
Perfetto デーモンの有効化 （この設定は、Android 10 (Q) の端末でのみ必要です。Android 11 (R) 以降は必要ありません）
perfetto コマンドでトレースを開始するには、Android 端末上で Perfetto デーモンを起動しておく必要があります。 次のようにシステムプロパティを設定すれば、Perfetto デーモンが起動します。
$ adb shell setprop persist.</description></item><item><title>Android アプリのパフォーマンス改善のためのチェックリスト</title><link>https://maku77.github.io/p/sfqyajt/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sfqyajt/</guid><description>はじめに パフォーマンスの最適化を行うには、フレームワーク特有の知識と、プロファイラによる計測 の両面から攻めていく必要があります。 アプリケーションを 60FPS の描画性能で動作させるには、1フレームあたりわずか 16.6 ミリ秒で処理を終えなければいけません。 複雑な計算処理や描画を行うアプリケーションにおいて、常に 60FPS を達成するのは非常に大変で、考えるべきことがたくさんあります。 ここでは、Android アプリのパフォーマンス改善のヒントをまとめておきます。
パフォーマンス可視化自動化のススメ 定期的にパフォーマンスに関するプロファイリングを行うのはよいことですが、もっといい方法は、パフォーマンスに関する計測を自動化＆見える化 することです。 例えば次のような仕組みを作り、普段の開発では常に有効化しておきます。
各フェーズの実行にかかった時間を、画面上に自動で表示する 画面上に FPS を表示する 各端末のパフォーマンス（メトリクス情報）を自動でサーバーに送り、統計をグラフ化する このような仕組みを作り込んでおけば、チームメンバー全員が普段からパフォーマンスを意識 して開発できるようになります。 アーキテクトだけにプロファイリング作業を任せたり、プロジェクト終盤になってからパフォーマンス計測をはじめたりするのはやめましょう。 コードを作り込んでからデータ構造やスレッド戦略を変更するのはとても大変で、手遅れになることが多いです。
上記の仕組みによって表示された結果は、製品リリースのためのパフォーマンスクライテリアを満たしているかの指標にもなります。
まずは計測 FPS の確認（1 フレームあたり何ミリ秒かかっているか） 開発者オプションから GPU バー表示を ON にして確認 GPU レンダリング速度のプロファイリング Profile HWUI rendering の設定は ADB で OFF/ON する と素早く切り替えられる 何らかの操作をしているときに、赤色のライン (16.6ms) を上回ることがないか を調べる Window.OnFrameMetricsAvailableListener でフレームごとのメトリクス情報を取得できる Firebase などを使えるのであれば、メトリクス情報をサーバー集計することが可能 Choreographer を使ってプログラム内で FPS を確認する 方法もあり adb shell dumpsys gfxinfo PKG名 | grep frames で ジャンクフレーム発生率を調べる オーバードローの確認（Debug GPU overdraw で何度も重ねて描画している部分がないか確認） レイアウトの確認（Layout Inspector で無駄なネストを確認） 全般的なボトルネックの確認 CPU Profiler でアプリ内のボトルネックを調査（Traceview はサポート終了） 各スレッドのビジー状態や、どのメソッドに時間がかかっているか を調べる → メソッド単位の最適化 GC (Garbage Collection) が頻繁に発生していないか を調べる (Perfeto/SystraceAllocation Tracker)。 Perfetto でシステム全体のボトルネックを調査 他のプロセスとの Binder 通信などがボトルネックになっていなかを調べる adb shell perfetto で計測開始するか、Perfetto の Web アプリから直接データ取得可能（要 Bluetooth/USB 接続） 昔は Systrace だったけど、Android 10 以降は Perfetto で。 改善ポイント 背景色描画の削減 背景色は、テーマ、Activity、Fragment、View のいずれかのレイヤで一回のみ指定する テーマの背景色が余計なときは、テーマの定義で android:windowbackground=&amp;quot;null&amp;quot; するか、Activity で window.</description></item><item><title>ADB で描画パフォーマンス計測のデバッグ機能を有効にする</title><link>https://maku77.github.io/p/bn8q8o6/</link><pubDate>Fri, 29 Jan 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bn8q8o6/</guid><description>Android の開発者向けオプション (Developer options) には、描画パフォーマンスなどを測定するための便利なツールが揃っています。 特に、GPU オーバードロー領域の表示や、レンダリングプロファイル（画面上にバー表示）は、描画パフォーマンス 60 FPS を達成するために必須のツールです。
でも、これらの設定項目は設定メニューの深いところにあって、ホーム画面に戻って毎回切り替えるのは手間がかかります。 実はこれらのオプション設定は、adb shell から setprop コマンドを実行することで簡単に切り替えることができます。 コマンドからこれらの設定を変更した場合は、すぐに設定が有効にならないことがあるので注意してください。 その場合は、アプリの再起動や、アプリ内での画面遷移などを発生させると有効になるようです。
各種デバッグ項目の ADB からの設定方法 Show view updates（GPU表示の更新を表示） ON にすると、GPU での描画時にウィンドウ内の表示を点滅させます。 (Flash views inside windows when drawn)
設定方法 意味 adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を OFF adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を ON Show hardware layers updates（ハードウェア層情報を表示） ON にすると、ハードウェア層が更新されると緑を表示します。 (Flash hardware layers green when they update)
GPU を活用した描画が行えているのであれば、GPU 層での更新は頻繁に発生するものではありません。 新しいビューが生成されたときのみ緑色のフラッシュが発生していれば OK です。
設定方法 意味 adb shell setprop debug.</description></item><item><title>Choreographer で FPS を計測する（Fps クラスの実装）</title><link>https://maku77.github.io/p/imx8hr2/</link><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/imx8hr2/</guid><description>Choreographer クラスによる FPS 計測 Android の Choreographer クラスを使用すると、フレームの描画開始のタイミングで呼び出されるコールバック (Choreographer.FrameCallback) を登録することができます。
Choreographer#postFrameCallback(callback: Choreographer.FrameCallback!) 上記のメソッドでコールバックを登録すると、次のフレーム描画のタイミングで doFrame(long frameTimeNanos) メソッドが呼び出されます。
Choreographer.FrameCallback#doFrame(frameTimeNanos: Long) パラメータとして描画開始時刻（ナノ秒単位）が渡されるため、前回のコールバック時の描画開始時刻からの差分を取れば、1 フレームの描画にかかった時間を求めることができます。 この値を使えば、FPS (Frame per second) は下記のように計算できます。
FPS = 1秒あたりのナノ秒 / 描画にかかった時間（ナノ秒） サンプルコード Fps クラスの実装 下記の Fps クラスは、FPS を簡単に計測するためのクラスです。 内部で Android の Choreographer を使っています。
Fps.kt import android.view.Choreographer import java.util.concurrent.TimeUnit class Fps : Choreographer.FrameCallback { interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Float) } private val choreographer = Choreographer.</description></item><item><title>ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast)</title><link>https://maku77.github.io/p/eezeq4g/</link><pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eezeq4g/</guid><description>以下のコマンドは、adb shell でデバイスに接続した状態から実行することを想定しています。 接続と同時に実行するには、adb shell を先頭に追加して実行してください（例: adb shell am start ...）。
Activity（アクティビティ）を起動する シェル上で am start コマンドを実行すると、Intent を発生させて Activity を起動することができます。
am start &amp;lt;INTENT&amp;gt; Intent 引数（&amp;lt;INTENT&amp;gt; の部分）の指定方法は、Specification for INTENT arguments のページに詳しく記載されています。 具体的には、次のようなオプションの組み合わせで Intent を構成します。
-a &amp;lt;ACTION&amp;gt; 例: -a android.intent.action.VIEW -d &amp;lt;DATA_URI&amp;gt; 例: -d content://contacts/people/1 -t &amp;lt;MIME_TYPE&amp;gt; 例: -t image/png -c &amp;lt;CATEGORY&amp;gt; 例: -c android.intent.category.APP_CONTACTS -n &amp;lt;COMPONENT&amp;gt; 例: -n com.example.app/.ExampleActivity 必要に応じて、Bundle データを渡すこともできます。
--esn &amp;lt;EXTRA_KEY&amp;gt; （キーのみ） -e|--es &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_STRING_VALUE&amp;gt; --ez &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_BOOLEAN_VALUE&amp;gt; --ei &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt; --el &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_LONG_VALUE&amp;gt; --ef &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_FLOAT_VALUE&amp;gt; --eu &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_URI_VALUE&amp;gt; --ecn &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_COMPONENT_NAME_VALUE&amp;gt; --eia &amp;lt;EXTRA_KEY&amp;gt; &amp;lt;EXTRA_INT_VALUE&amp;gt;[,&amp;lt;EXTRA_INT_VALUE.</description></item><item><title>APK のパッケージ依存関係やクラス依存関係を調べる</title><link>https://maku77.github.io/p/w6ste5j/</link><pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w6ste5j/</guid><description>ここでは、jdeps と dex2jar を使って、APK ファイル内の依存関係を調査する方法を示します。
jdeps と dex2jar JDK 8 にはパッケージ依存関係やクラス依存関係を調べるための jdeps コマンドが標準搭載されました。
jdeps コマンド - Oracle Java Documentation これを使用すると、.class ファイル（あるいは .jar ファイル）を入力情報として、そこから参照しているクラスやパッケージの情報を調べることができるのですが、Android の APK としてビルドされたコードは .dex ファイルになっていますので、まずはこれを通常の .class 形式に変更してやる必要があります。 APK ファイル内の .dex を .class 形式に変換するには、dex2jar というツールを使用します。
dex2jar のダウンロード 上記から、たとえば dex-tools-2.1-20150601.060031-26.zip をダウンロードし、パスの通ったディレクトリに展開すればインストール完了です。
APK ファイルのパッケージ依存、クラス依存情報を調べる まず、d2j-dex2jar コマンドを使用して、APK ファイル内の .dex を .class 形式に変換します。 APK ファイルを unzip して取り出した .dex ファイルを変換することもできますが、下記のように直接 APK ファイルを .jar に変換してしまうのが手っ取り早いです。
apk から jar への変換 $ d2j-dex2jar app/build/outputs/apk/app-debug.apk -o app.jar dex2jar app/build/outputs/apk/app-debug.</description></item><item><title>ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts)</title><link>https://maku77.github.io/p/jfqtfyn/</link><pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jfqtfyn/</guid><description>dumpsys コマンドの activity broadcast サブコマンドを実行すると、ブロードキャストインテントをハンドルするように登録しているレシーバーの一覧を確認することができます。
$ adb shell dumpsys activity broadcasts 実行結果（抜粋） ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts) Registered Receivers: ... * ReceiverList{82bcce 603 com.android.systemui/10019/u0 remote:83b3dc9} app=603:com.android.systemui/u0a19 pid=603 uid=10019 user=0 Filter #0: BroadcastFilter{28557ef} Action: &amp;#34;android.intent.action.TIME_TICK&amp;#34; Action: &amp;#34;android.intent.action.TIME_SET&amp;#34; Action: &amp;#34;android.intent.action.BATTERY_CHANGED&amp;#34; ... AutoVerify=false Filter #1: BroadcastFilter{56b72fc} Action: &amp;#34;android.intent.action.BOOT_COMPLETED&amp;#34; mPriority=1000, mHasPartialTypes=false AutoVerify=false ... Registered Receivers のセクションには、アプリごとにどのようなフィルタでインテントを監視しているかが表示されます。 上記の例では、com.android.systemui アプリが、android.intent.action.TIME_TICK インテントなどのブロードキャストを監視していること示しています。
さらに下の方を見ると、Receiver Resolver Table というセクションがあります。
Receiver Resolver Table: ... Non-Data Actions: ... android.intent.action.BOOT_COMPLETED: BroadcastFilter{10f199e u0 ReceiverList{b1ecbd9 493 system/1000/u0 local:28f4620}} BroadcastFilter{989a5ad u0 ReceiverList{ae0d2c4 493 system/1000/u0 local:48b9d7}} BroadcastFilter{213887b u0 ReceiverList{758680a 493 system/1000/u0 local:513e075}} BroadcastFilter{56b72fc u0 ReceiverList{82bcce 603 com.</description></item><item><title>ADB からキー入力やテキスト入力を行う (input text, input keyevent)</title><link>https://maku77.github.io/p/gorux24/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gorux24/</guid><description>ADB shell 上で input コマンドを使用すると、任意のキー入力やテキスト入力をエミュレートすることができます。
キー入力の例 (input keyevent) input keyevent コマンドを使用することで、単一のキー入力をエミュレートできます。
$ adb shell input keyevent ENTER # Enter キー $ adb shell input keyevent DPAD_CENTER # D-pad 上の決定キー $ adb shell input keyevent DPAD_RIGHT # 右キー $ adb shell input keyevent POWER # 電源キー $ adb shell input keyevent A # キーボードの A キー $ adb shell input keyevent TV # TV キー（Android TV 用） $ adb shell input keyevent NUMBER_ENTRY # 10-key キー（Android TV 用） $ adb shell input keyevent TV_TERRESTRIAL_DIGITAL # 地デジキー（Android TV 用） パラメータに指定できるキー名は、android.</description></item><item><title>Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd)</title><link>https://maku77.github.io/p/ycwfweu/</link><pubDate>Wed, 13 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ycwfweu/</guid><description>（追記） Android 10 (Q) 以降では、より洗練された Perfetto を使ってパフォーマンス解析できます。
systrace コマンドの基本 Android - Systrace Android - Analyzing UI Performance with Systrace Android SDK に付属している systrace.py スクリプトを使用すると、Android デバイス全体のプロセスに関するプロファイリングを行うことができます（I/O アクセスや UI スレッドの状況など）。 systrace は Python スクリプトとして提供されているため、実行するときは下記のような感じでパラメータを指定して実行します。
例: 10 秒間の systrace 実行する $ cd android-sdk/platform-tools/systrace $ python systrace.py --time=10 -o trace.html sched gfx view wm プロファイルの取得が完了すると、プロファイル結果を表示するための HTML ファイルがカレントディレクトリに作成されます。
Capturing trace......................................................Done. Downloading trace....Done. wrote file://C:\trace.html この HTML を Web ブラウザで開いてボトルネックの分析を行うことができます。 Web ブラウザ上で ? キーを押すと、使用できるショートカットキーの一覧を確認できます。
バッチファイル化 systrace コマンドを実行するときに、同じようなパラメータを毎回指定するのは面倒ですし、Windows 環境ですと PATH を通したりするのも若干面倒ですので、下記のようなバッチファイルを作成しておくと便利です。</description></item><item><title>Androidメモ: ADB で WakeLock を強制的に外す</title><link>https://maku77.github.io/p/xx3mb8e/</link><pubDate>Thu, 07 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xx3mb8e/</guid><description>/sys/power/wake_unlock に対して WakeLock 名を書き込むことで、その WakeLock を強制キャンセルすることができます。
現在取得されている WakeLock（カーネル・ウェイクロック）の一覧は下記のようにして調べることができます。
$ adb shell cat /sys/power/wake_lock PowerManagerService PowerManagerService.Display PowerManagerService.WakeLocks 上記で表示された WakeLock 名を参考にして、下記のように wake_unlock に書き込みます。
$ adb shell &amp;#34;echo PowerManagerService &amp;gt; /sys/power/wake_unlock&amp;#34;</description></item><item><title>Ruby で adb コマンドの出力結果を処理する</title><link>https://maku77.github.io/p/w6vao2e/</link><pubDate>Wed, 06 Jul 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w6vao2e/</guid><description>下記は、Ruby スクリプトの中から adb shell コマンドを呼び出して、その出力をハンドルするサンプルです。
ここで定義している adb_shell メソッドは、受け取ったコマンド文字列を adb shell の後ろにくっつけた形のコマンドを実行します（adb_shell('pm list packages') とすると、adb shell pm list packages が実行される）。
sample.rb # Executes the command via &amp;#39;adb shell&amp;#39;. # Obtained result will be passed to the specified block line by line. def adb_shell(command) result = `adb shell #{command}` result.gsub!(&amp;#34;\n\n&amp;#34;, &amp;#34;\n&amp;#34;) # for Windows result.lines { |line| yield line } end # Test if $0 == __FILE__ adb_shell(&amp;#39;pm list packages&amp;#39;) do |line| puts &amp;#39;==&amp;gt; &amp;#39; + line end end 実行結果 $ ruby sample.</description></item><item><title>APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages)</title><link>https://maku77.github.io/p/ghtgxgw/</link><pubDate>Mon, 27 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ghtgxgw/</guid><description>指定したパッケージの APK のファイルパスを調べる Android デバイスに adb shell で接続し、pm path &amp;lt;パッケージ名&amp;gt; コマンドを実行すると、指定したパッケージ名の APK ファイルが、デバイス上のどのパスに置かれているかを調べることができます。
com.example.myapp パッケージがどの APK ファイルか調べる $ adb shell pm path com.example.myapp package:/system/app/MyApp/MyApp.apk インストールされているすべての APK のファイルパスとパッケージ名を調べる インストールされている APK パッケージの一覧は、pm list packages コマンドで調べることができます。
インストール済みパッケージの一覧を表示 $ adb shell pm list packages package:com.google.android.apps.mediashell package:com.google.android.katniss package:com.android.providers.calendar package:com.android.tv.settings package:com.android.providers.media ... さらに、-f オプションを指定して実行すると、すべての APK に関するファイルパスとパッケージ名の対応情報を調べることができます。 sort コマンドと組み合わせて使用すると見やすくなります。
APK 名とパッケージ名の対応リスト $ adb shell pm list packages -f | sort package:/system/app/Backdrop/Backdrop.apk=com.google.android.backdrop package:/system/app/BasicDreams/BasicDreams.apk=com.android.dreams.basic package:/system/app/Bluetooth/Bluetooth.apk=com.android.bluetooth package:/system/app/KeyChain/KeyChain.apk=com.android.keychain ... システムにプリインストールされているアプリケーションだけを列挙したい場合は、-s オプションも同時に指定します。</description></item><item><title>Systrace の画面が真っ白になるときの対応方法</title><link>https://maku77.github.io/p/u3n5m3j/</link><pubDate>Wed, 08 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/u3n5m3j/</guid><description>追記 (2021-04): 現在は Systrace は deprecated になっており、Perfetto という新しいトレースツールを使うことができます（参考: Perfetto でシステム全体のパフォーマンスを計測する。 過去に systrace で取得したトレースファイルを開きたいときは、Perfetto UI のサイト上で Open with Legacy UI から開くことができます。
Android の DDMS などで利用可能な systrace を実行すると、trace.html ファイルが生成されますが、この中で非推奨になった JavaScript API(Object.observe) を使用しているため、最新の Chrome では表示できない問題が出ています。
参考: http://stackoverflow.com/questions/36865899/react-native-android-systrace-html-is-blank-in-ubuntu-14-04/37008945 上記サイトでの回避策としては、生成された HTML のヘッダに下記を追加することがあげられています。
&amp;lt;script src=&amp;#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; 生成される HTML ファイルを毎回修正するのが面倒な場合は、Android SDK のディレクトリにある下記のファイルを編集するという方法もあります。 このファイルに追記した内容は、生成される HTML にも反映されるようになります。
$ANDROID_SDK/platform-tools/systrace/prefix.html &amp;lt;!DOCTYPE HTML&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head i18n-values=&amp;#34;dir:textdirection;&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;Content-Type&amp;#34; content=&amp;#34;text/html; charset=utf-8&amp;#34;&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;/&amp;gt; &amp;lt;script src=&amp;#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; ★これを追加</description></item><item><title>Android アプリのパフォーマンス改善に使用できるツール</title><link>https://maku77.github.io/p/39cfimo/</link><pubDate>Tue, 07 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/39cfimo/</guid><description>systrace / perfetto: システム全体の負荷状況などを調べる systrace を使用すると、カーネルレベルでの CPU 負荷状況などを調べられるため、システム全体で重くなっている場合などの一次分析に使用できます。 DDMS ツール (monitor.bat) から任意のタイミングでプロファイル取得できます。
（追記） Android 10 (Q) 以降は、より洗練された Perfetto を使用してください。
参考: Perfetto でシステム全体のパフォーマンスを計測する traceview: アプリ内のメソッド呼び出し数などを調べる traceview を使用すると、特定のアプリ内のメソッド単位のプロファイル情報を取得することができます。 メソッド呼び出し回数が想定よりも多くなっているとか、処理に時間がかかりすぎているメソッドなどを発見できます。
DDMS ツールから任意のタイミングでプロファイル取得できます。あるいは、コードに開始／終了タイミングを明示することで、ピンポイントで特定の区間のプロファイルを取得することもできます。
Show GPU overdraw: 同じ領域を何度も描画しないか調べる 開発者オプションで Show GPU overdraw の機能を有効にすると、画面上に重ねて描画される領域があったときに、その領域が描画回数に応じた色で矩形表示されるようになります。 例えば、赤色で矩形表示された場合は、その領域が 3 回以上重複して描画されていることを示しており、プログラム内の描画シーケンスを見直すべきだと分かります。
Show GPU overdraw の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Drawing → Show GPU overdraw)。
Profile GPU rendering: 60FPS で描画できている調べる 開発者オプションで Profile GPU rendering の機能を有効にすると、描画フレームごとに UI スレッドでかかった時間を画面上にバー表示することができます。 緑色のラインは 16.6ms を示しており、このラインを超えるということは 60 FPS で描画できていないということです。メインスレッド上で描画以外の処理を行っていないか見直す必要があります。</description></item><item><title>ADB で指定したアプリを強制終了する (am force-stop)</title><link>https://maku77.github.io/p/9yse3iz/</link><pubDate>Mon, 06 Jun 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9yse3iz/</guid><description>Android 端末に ADB 接続された状態で adb shell am force-stop コマンドを実行すると、任意のアプリケーションを強制終了することができます。
$ adb shell am force-stop com.example.myapp adb shell 接続されている状態であれば、adb shell の部分は省略して実行します。
generic_x86:/ $ am force-stop com.example.myapp ちなみに、インストールされているアプリのパッケージ名一覧は adb shell pm list packages で調べることができます（こちらは am じゃなくて pm コマンドであることに注意してください）。
参考: ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)</description></item><item><title>Android Studio で静的解析プラグインを使用する (CheckStyle, FindBugs)</title><link>https://maku77.github.io/p/web92kb/</link><pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/web92kb/</guid><description>Gradle で Checkstyle や FindBugs のタスクを実行するのもよいですが、Android Studio に Plugin を入れておくと、警告箇所を簡単に調べられるようになります。
CheckStyle 用のプラグイン (CheckStyle-IDEA) インストール Ctrl + Alt + S で Settings を開く Plugins の Browse repositories... ボタンを押す CheckStyle-IDEA をインストール Android Studio を再起動 設定（プロジェクト用の設定が必要な場合） Ctrl + Alt + S で Settings を開く Other tools の CheckStyle を開く プロジェクト用の設定ファイルを追加し、チェックボックスにチェックを入れる 実行 Ctrl + Shift + A で check と入力 カレントファイルをチェックする場合: Check Current File モジュール全体をチェックする場合: Check Module プロジェクト全体をチェックする場合: Check Project FindBugs 用のプラグイン (FindBugs-IDEA) インストール Ctrl + Alt + S で Settings を開く Plugins の Browse repositories.</description></item><item><title>Android Gradleメモ: リソース名に正しくプレフィックスが付いているか確認する (resourcePrefix)</title><link>https://maku77.github.io/p/4zogpen/</link><pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4zogpen/</guid><description>マルチプロジェクト構成な Android プロジェクトでは、サブプロジェクトによるリソース名の重複を意識しなければいけません。 リソース名の重複を防ぐには、例えば、サブプロジェクト内で使用するリソース名にプレフィックス名を付けたりします。
build.gradle で下記のように resourcePrefix を指定しておくと、リソース名のプレフィックスが正しく付けられているかチェックしてくれるようになります。 この設定は、Android Studio 0.5.8 以降で使用可能です。
android { resourcePrefix &amp;#39;mylib_&amp;#39; } 指定したプレフィックスが付いていないリソース名が見つかると、Android Lint による警告が発生します。</description></item><item><title>Androidメモ: AAR 形式のファイルを作成する/使用する</title><link>https://maku77.github.io/p/3m9f8yv/</link><pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3m9f8yv/</guid><description>AAR とは Android Studio では、従来の JAR 形式のライブラリファイルに加え、AAR (Android Archive) 形式のライブラリ を作成することができます。
JAR ライブラリとは違い、AAR ライブラリは Android 固有のアセット、リソース、AndroidManifest.xml などを含めることができます。 AAR ライブラリには AndroidManifest.xml を含めることができるので、uses-library 宣言をライブラリ内で完結させるといったことが可能になります。
AAR ライブラリを作成する 通常のアプリプロジェクトの下に AAR ライブラリ用のサブプロジェクトを作成する方法 現状の Android Studio (version 1.5) では、AAR ライブラリ専用の新規プロジェクトを作成することができません（後述の方法で、ごにょごにょすれば AAR 専用のプロジェクトとして扱うことはできます）。 なので、通常はアプリケーションプロジェクトの下に、サブプロジェクトとして AAR ライブラリのプロジェクトを作成することになります。 AAR ライブラリを作成する場合は、その使用例などを示すサンプルプロジェクトなども用意する必要がありますから、この構成で作成しておいても特に問題ないでしょう。
まずは下記のように親プロジェクトとなるアプリプロジェクトを作成します。 Android Phone 用の UI ライブラリを作るつもりであれば、それを前提とした構成で作成しておけばよいでしょう。
メニューから File =&amp;gt; New =&amp;gt; New Project... を選択 次に、そのサブプロジェクトとして、AAR ライブラリ作成用のプロジェクトを作成します。
メニューから File =&amp;gt; New =&amp;gt; New Module... を選択 Android Library を選択し、Module name に AAR ライブラリのファイル名、Package name にライブラリの Java パッケージ名を入力 AAR ライブラリ用のサブプロジェクトが作成されたら、そこに Java のクラスやリソース、AndroidManifest.</description></item><item><title>Android Gradleメモ: Android の Gradle 関連ファイルまとめ</title><link>https://maku77.github.io/p/8f3pcke/</link><pubDate>Thu, 12 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8f3pcke/</guid><description>Android Studio を使ったり、Gradle でマルチプロジェクトを扱っていたりすると、Gradle 関連のプロパティファイル (.properties) やビルドスクリプト (.gradle) が増えてきます。 混乱しやすいのでまとめておきます。
ファイル名 自動生成される？ Gitにコミットする？ 説明 build.gradle 手動で編集 する プロジェクトごとのビルドスクリプト settings.gradle 手動で編集 する マルチプロジェクト構成のプロジェクトにおいて、サブプロジェクトなどのリストを管理 gradle.properties Android Studio が自動生成 しない Gradle 実行のプロキシ設定やメモリ容量設定 local.properties Android Studio が自動生成 しない Android SDK のパスなど、個人環境に依存する設定が格納される その他.properties 手動で編集 する 独自に作成したプロパティファイル（ビルドスクリプト内で読み込んだりしているはず）</description></item><item><title>ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk)</title><link>https://maku77.github.io/p/8k5m4k2/</link><pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8k5m4k2/</guid><description>Android SDK に付属している android コマンドの list sdk サブコマンドを使用すると、追加でインストール可能な SDK コンポーネントの一覧を取得することができます。
インストール可能な SDK コンポーネント $ android list sdk --no-ui --all --extended ... ---------- id: 157 or &amp;#34;extra-google-usb_driver&amp;#34; Type: Extra Desc: Google USB Driver, revision 11 By Google Inc. USB Driver for Windows, revision 11 Install path: extras\google\usb_driver ---------- id: 158 or &amp;#34;extra-google-webdriver&amp;#34; Type: Extra Desc: Google Web Driver, revision 2 By Google Inc. WebDriver Install path: extras\google\webdriver ---------- id: 159 or &amp;#34;extra-intel-Hardware_Accelerated_Execution_Manager&amp;#34; Type: Extra Desc: Intel x86 Emulator Accelerator (HAXM installer), revision 5.</description></item><item><title>protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions)</title><link>https://maku77.github.io/p/8x8qmy3/</link><pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8x8qmy3/</guid><description>pm list permissions コマンドに -d オプションを付けて実行すると、protectionLevel が dangerous に設定されたパーミッションのみを一覧表示してくれます。 Android M からは、dangerous なパーミッションはユーザが個別に On/Off することができるようになったため、どのようなパーミッションが存在しているのかを把握することがより重要になりました。
shell@xxx:/ $ pm list permissions -d Dangerous Permissions: permission:com.android.providers.tv.permission.READ_EPG_DATA permission:com.android.providers.tv.permission.WRITE_EPG_DATA adb shell で接続する前に実行する場合は、上記のコマンドの先頭に adb shell を付けて実行してください。</description></item><item><title>パーミッショングループの一覧を表示する (pm list permission-groups)</title><link>https://maku77.github.io/p/viry8fo/</link><pubDate>Tue, 04 Aug 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/viry8fo/</guid><description>パーミッショングループの一覧 Android 端末内にどのようなパーミッショングループが存在しているかを調べるには、adb shell で接続した後に pm list permission-groups コマンドを使用します。
shell@xxx:/ $ pm list permission-groups permission group:android.permission-group.PHONE_CALLS permission group:android.permission-group.WALLPAPER permission group:android.permission-group.MESSAGES permission group:android.permission-group.USER_DICTIONARY permission group:android.permission-group.CALENDAR permission group:android.permission-group.BLUETOOTH_NETWORK ... adb shell で接続前に実行したい場合は、下記のように adb shell に続けてコマンド入力しても OK です。 ホスト側の PC で出力を sort したい場合などはこちらの方が便利かもしれません。
$ adb shell pm list permission-groups | sort permission group:android.permission-group.ACCESSIBILITY_FEATURES permission group:android.permission-group.ACCOUNTS permission group:android.permission-group.AFFECTS_BATTERY permission group:android.permission-group.APP_INFO permission group:android.permission-group.AUDIO_SETTINGS permission group:android.permission-group.BLUETOOTH_NETWORK ... パーミッショングループに属するパーミッションの一覧 それぞれのパーミッショングループが、どのようなパーミッションから構成されているかを調べるには、pm list permissions -g コマンドを使用します。
shell@xxx:/ $ pm list permissions -g All Permissions: group:android.</description></item><item><title>Androidメモ: ADB 経由でスクリーンキャプチャを取得する (screencap)</title><link>https://maku77.github.io/p/kp3ubcu/</link><pubDate>Wed, 01 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kp3ubcu/</guid><description>Android デバイス上で screencap コマンドを使うと、スクリーンキャプチャを取得できます。 ADB 接続ができている状態であれば、下記のように実行することで PC 側のカレントディレクトリに capture.png ファイルを取得できます。
$ adb shell screencap -p /sdcard/capture.png $ adb pull /sdcard/capture.png $ adb shell rm /sdcard/capture.png</description></item><item><title>APK ファイルに署名する (keytool, jarsigner)</title><link>https://maku77.github.io/p/3yk3j2i/</link><pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3yk3j2i/</guid><description>APK に署名する方法は、従来の Java で行われていた JAR ファイルへの署名方法と同様です。 下記の JAR ファイルへの署名方法を参考にしてください。
参考: JAR ファイルの署名について - まくまく Java ノート (1) keystore ファイルを作成する ここでは下記の条件でキーを作成します。
作成するキーストアファイル名: MyKeyStore.jks エイリアス名: android 有効期限: 10000日 $ keytool -genkey -v -keystore MyKeyStore.jks -alias android -keyalg RSA -keysize 2048 -validity 10000 Enter keystore password:（キーストアのパスワードを入力） （名前や組織名などを聞かれるので順番に入力していく） (2) keystore ファイルを使って APK に署名する 上記のように作成した keystore ファイルには、非公開鍵と、それに関連付けられた X.509 証明書が含まれており、このファイルを使用して APK に署名を行うことができます。 ここでは、MyApp.apk に署名を行います。
$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore MyKeyStore.jks MyApp.apk android （キーストアのパスワードを入力）（キーエイリアスのパスワードを入力） (3) APK の署名を確認する $ jarsigner -verify -verbose -certs MyApp.</description></item><item><title>Dex 形式の Shared library (JAR) を作成する (dx)</title><link>https://maku77.github.io/p/huevdub/</link><pubDate>Thu, 30 Oct 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/huevdub/</guid><description>Android デバイスの /system/framework に以下に格納して使用する Shared JAR ライブラリは、DEX 形式にコンパイルされたクラスを含んでいる必要があります。Eclipse などで単純に JAR ファイルを生成すると、PC 用の JAR ライブラリができてしまうので、DEX 形式に変換してから /system/framework にインストールする必要があります。
$ dx --dex --output=output.jar input.jar</description></item><item><title>APK ファイルの署名を確認する (jarsigner, openssl)</title><link>https://maku77.github.io/p/2x9it3c/</link><pubDate>Fri, 22 Aug 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2x9it3c/</guid><description>署名情報を確認する方法 JDK に付属している jarsigner コマンドを使用して、APK ファイルの署名情報を確認することができます。
MyApp.apk の署名を確認する $ jarsigner -verify -certs -verbose MyApp.apk ... sm 21632 Mon Sep 01 17:08:16 JST 2014 lib/libhoge.so X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] s 36381 Fri Oct 03 14:10:34 JST 2014 META-INF/MANIFEST.MF X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] 36434 Fri Oct 03 14:10:34 JST 2014 META-INF/CERT.</description></item><item><title>メモリの使用状況を確認する (dumpsys meminfo)</title><link>https://maku77.github.io/p/t6wfxev/</link><pubDate>Tue, 29 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/t6wfxev/</guid><description>各プロセスのメモリ使用状況を確認する dumpsys コマンドの meminfo セクションでは、各プロセスのメモリ使用状況を確認することができます。
$ adb shell dumpsys meminfo Applications Memory Usage (kB): Uptime: 169910958 Realtime: 170196415 Total PSS by process: 96302 kB: system (pid 728) 44547 kB: com.android.systemui (pid 965) 32601 kB: com.sonyericsson.android.pobox.imecore (pid 1042) 29610 kB: com.android.settings (pid 8006) 26500 kB: com.sonyericsson.home (pid 1321) 23027 kB: com.facebook.katana (pid 7371) 17963 kB: com.facebook.katana:dash (pid 7641) 13579 kB: com.google.android.gms (pid 5171) ... プロセスを指定してメモリ使用状況を確認する 上記で表示されたパッケージ名や pid を、dumpsys meminfo コマンドの後ろに続けて指定することで、そのプロセスにおける詳細なメモリ使用情報を調べられます。
$ adb shell dumpsys meminfo com.</description></item><item><title>Androidメモ: Xperia Tablet Z に adb 接続する</title><link>https://maku77.github.io/p/eq3tw6z/</link><pubDate>Fri, 30 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eq3tw6z/</guid><description>まずは、下記と同様に「開発者向けオプション」を有効にし、「USB デバッグ」を有効にしておきます。
Nexus7 (2013) に adb 接続する Windows への ADB ドライバのインストール Xperia には、端末側に &amp;ldquo;PC Companion software&amp;rdquo; というものが入っていて、USB 経由で PC 側にインストールすることができます。 同時に ADB ドライバもインストールされます。
Xperia の「Settings =&amp;gt; Xperia =&amp;gt; USB Connectivity =&amp;gt; Install PC Companion」にチェックを入れておく。 USB で PC と接続すると、Xperia 側にインストール確認のダイアログが表示されるので、&amp;ldquo;Install&amp;rdquo; を選択。 PC 側でインストール用のドライブが開くのでアイコンからインストーラを起動 (Startme.exe)。 最初に ADB 接続するときは、端末を MTP (Media transfer mode) から、MSC (Mass storage mode) に変えておかないと adb devices で認識しないことがあるみたいです。
Xperia の「Settings =&amp;gt; Xperia =&amp;gt; USB Connectivity =&amp;gt; USB connection mode」を選択。 MSC (Mass storage mode) を選択。 あとは、以下のように接続を確認できます。</description></item><item><title>Androidメモ: TCP/IP で adb 接続する</title><link>https://maku77.github.io/p/492mmkw/</link><pubDate>Tue, 08 Apr 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/492mmkw/</guid><description>ADB を TCP/IP 接続に切り替える Android アプリ開発時に、ADB 接続を USB 経由ではなく LAN 経由での接続 (TCP/IP プロトコル）で行うようにする手順です。
Android 端末側の ADB デーモンを TCP/IP モードに切り替えないといけないので、この設定自体は USB 接続された状態で行う必要があります。 一度設定してしまえば、次回からは USB ケーブルは必要なくなります。
Android 端末側の「開発者向けオプション」を有効にして USB 接続する [設定] &amp;gt; [デバイス情報] に移動して、[ビルド番号] を 7 回タップすると「開発者向けオプション」が有効になります。 （USB 接続された状態で）Android 端末側の ADB デーモンを TCP/IP 接続モードにする adb tcpip 5555 Android 端末の LAN 内の IP アドレスを確認しておく adb shell &amp;quot;ip addr | grep inet&amp;quot; （この時点で USB ケーブルは外して OK） PC から Android 端末のアドレスとポート番号を指定して TCP/IP で接続 adb connect 192.</description></item><item><title>Androidベンダー向けメモ: Android デバイスのパーティション構成概要</title><link>https://maku77.github.io/p/ks84q3k/</link><pubDate>Thu, 07 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ks84q3k/</guid><description>パーティション構成 Android のパーティション構成は、およそ下記のようになっています。
/boot &amp;hellip; Android kernel と ramdisk /system &amp;hellip; Android OS およびプリインアプリなど /recovery &amp;hellip; リカバリ時に /boot パーティションの代わりに起動されるリカバリ OS /data &amp;hellip; GooglePlay からインストールしたアプリやユーザデータ（書き込み可能） /cache &amp;hellip; アプリ用キャッシュ（リカバリイメージのダウンロードもここに入る） Nexus7 (2013) の情報を見てみる マウント情報の表示 $ mount （あるいは cat /proc/mounts） rootfs / rootfs ro,relatime 0 0 tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0 devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0 proc /proc proc rw,relatime 0 0 sysfs /sys sysfs rw,seclabel,relatime 0 0 selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0 debugfs /sys/kernel/debug debugfs rw,relatime 0 0 none /acct cgroup rw,relatime,cpuacct 0 0 tmpfs /mnt/secure tmpfs rw,seclabel,relatime,mode=700 0 0 tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0 tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0 none /dev/cpuctl cgroup rw,relatime,cpu 0 0 /dev/block/platform/msm_sdcc.</description></item><item><title>Androidメモ: Nexus7 (2013) に adb 接続する</title><link>https://maku77.github.io/p/5b6pmtc/</link><pubDate>Wed, 06 Nov 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5b6pmtc/</guid><description>Android タブレットの Nexus7 に、adb コマンドで接続するまでの手順です。 下記は Android 4.3 で確認しています。
Android の設定メニューに「開発者向けオプション」を表示 設定 =&amp;gt; タブレット情報 (About tablet) 「ビルド番号 (Build number)」を 7 回タップ この操作で「デベロッパー」として認識され、設定メニューに「開発者向けオプション (Developer options)」の項目が表示されます。 開発者向けオプションでは、USB による adb 接続を行うために以下のチェックを入れておきます。
USBデバッグ この設定を行ってから USB Driver を更新する必要があります。
Windows 7 に USB Driver をインストール https://developer.android.com/sdk/win-usb.html の指示に従ってドライバのダウンロード、インストールをすれば OK です。 簡単に手順をまとめると、
Google USB Driver をダウンロードして展開しておく（SDK Manager で GUI からダウンロードも可能） 「開発者向けオプション/USBデバッグ」を ON にした状態で Nexus7 を USB で接続 デバイスマネージャを起動（&amp;ldquo;Computer&amp;rdquo; を右クリック =&amp;gt; &amp;ldquo;Manage&amp;rdquo; =&amp;gt; 左側のペーンから &amp;ldquo;Device Manager&amp;rdquo; を選択） &amp;ldquo;Other devices/Nexus 7&amp;rdquo; を右クリック =&amp;gt; &amp;ldquo;Update Driver Software&amp;hellip;&amp;rdquo; （&amp;ldquo;Portable Devices/Nexus 7&amp;rdquo; の方と間違えないように。&amp;ldquo;Other devices&amp;rdquo; の方が表示されない場合は、USBデバッグが ON になっていない可能性が高いです。） ドライバの入っているディレクトリを選択 SDK Manager でダウンロードした場合: &amp;lt;android-sdk&amp;gt;/extras/google/usb_driver 手動ダウンロードした場合: 展開してできた usb_driver ディレクトリを選択 ADB を最新版に更新 SDK Manager で以下を最新にアップデートしておく（これやらないと adb devices で認識しないことあり） Android SDK Platoform-tools（2013-11-06 時点で rev.</description></item><item><title>Androidメモ: SHARP IS03 に adb 接続する</title><link>https://maku77.github.io/p/4hhc7ba/</link><pubDate>Tue, 09 Oct 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4hhc7ba/</guid><description>SHARP のスマホ IS03 を adb devices コマンドで認識させるまでの手順です。 Android SDK のインストールは済んでいて、adb コマンドは実行できる状態になっているとします。
IS03 用 USB ドライバをダウンロード＆インストール https://k-tai.sharp.co.jp/support/a/is03/download.html#usb_driver ドライバをインストールする前に USB でつないでいた場合は、正しく認識できなくなってしまうことがあるようです。 その場合は、「プログラムの追加と削除」から一度、「au IS03 USB Software」をアンインストールしてから、USB 接続を外した状態で、再度インストールします。 Sharp 共通の ADB USBドライバをダウンロード＆展開 https://sh-dev.sharp.co.jp/android/modules/driver/ 次の手順でインストールするドライバをダウンロードして、展開しておきます。 ADB USB ドライバをインストール Android 端末の USB デバッグを有効にし（設定 ＞ アプリケーション ＞ 開発）、USB 接続すると、ドライバのインストールダイアログがポップアップするので、手順 2 で展開した ADB USB ドライバのディレクトリを選択してインストールします。 ポップアップしない場合は、「高速転送モード」に切り替えると出たりします。 それでも出ない場合は、「Device Manager」から、Other devices/Android ADB Interface などを見つけられれば、再インストール可能です。 確認 インストールが完了すれば、以下のように adb から認識されれいるはずです。 C:\&amp;gt; adb devices List of devices attached SSHEV012345 device</description></item><item><title>Androidベンダー向けメモ: Android 4.0 でサポートされている Locale の一覧</title><link>https://maku77.github.io/p/ypihqom/</link><pubDate>Tue, 18 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ypihqom/</guid><description>下記は、Android 4.0 においてサポートされている Locale の一覧です。 Android の UI 上の言語名は ICU のライブラリから取得した情報をもとに表示されるのですが、中国語に関しては例外的に、表示上の言語名が「繁体字」or「簡体字」のようになるように拡張されています。 これらの文言は android/packages/apps/Settings/res/values/arrays.xml 内で定義されています。
af_ZA: Afrikaans (South Africa) / アフリカーンス語 (南アフリカ) am_ET: Amharic (Ethiopia) / アムハラ語 (エチオピア) ar_EG: Arabic (Egypt) / アラビア語 (エジプト) bg_BG: Bulgarian (Bulgaria) / ブルガリア語 (ブルガリア) ca_ES: Catalan (Spain) / カタロニア語 (スペイン) cs_CZ: Czech (Czech Republic) / チェコ語 (チェコ) da_DK: Danish (Denmark) / デンマーク語 (デンマーク) de_DE: German (Germany) / ドイツ語 (ドイツ) el_GR: Greek (Greece) / ギリシア語 (ギリシア) en_GB: English (United Kingdom) / 英語 (イギリス) en_US: English (United States) / 英語 (アメリカ合衆国) es_ES: Spanish (Spain) / スペイン語 (スペイン) es_US: Spanish (United States) / スペイン語 (アメリカ合衆国) fa_IR: Persian (Iran) / ペルシア語 (イラン) fi_FI: Finnish (Finland) / フィンランド語 (フィンランド) fr_FR: French (France) / フランス語 (フランス) hi_IN: Hindi (India) / ヒンディー語 (インド) hi_IN: Hindi (India) / ヒンディー語 (インド) hr_HR: Croatian (Croatia) / クロアチア語 (クロアチア) hu_HU: Hungarian (Hungary) / ハンガリー語 (ハンガリー) in_ID: Indonesian (Indonesia) / インドネシア語 (インドネシア) it_IT: Italian (Italy) / イタリア語 (イタリア) iw_IL: Hebrew (Israel) / ヘブライ語 (イスラエル) ja_JP: Japanese (Japan) / 日本語 (日本) ko_KR: Korean (South Korea) / 韓国語 (大韓民国) lt_LT: Lithuanian (Lithuania) / リトアニア語 (リトアニア) lv_LV: Latvian (Latvia) / ラトビア語 (レット語) (ラトビア) ms_MY: Malay (Malaysia) / マライ語 (マレーシア) nb_NO: Norwegian Bokm?</description></item><item><title>adb から Backup Manager を走らせる (bmgr backup, bmgr restore)</title><link>https://maku77.github.io/p/x9xhyhz/</link><pubDate>Thu, 26 Jan 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x9xhyhz/</guid><description>Android アプリケーションで BackupAgent を実装しておくと、設定値などを Google アカウントに紐づけてバックアップすることができます。 例えば、Android システム設定のバックアップは SettingsProvider (com.android.providers.settings) の SettingsBackupAgent クラスで実装されています。
アプリケーションの実装で、BackupManager.dataChanged() を読んでおくと、ダーティフラグがセットされて、Android が適切なタイミングで Google のサーバーにバックアップするのですが、adb shell から bmgr コマンドを使うことで、バックアップ、リストアを任意のタイミングで実行できます。
設定を Google サーバへバックアップ adb&amp;gt; bmgr backup com.android.providers.settings adb&amp;gt; bmgr run 設定を Google サーバからリストア adb&amp;gt; bmgr restore com.android.providers.settings 参考: BackupAgent | Android Developers 参考: Android Backup Service を使用して Key-Value ペアをバックアップする</description></item><item><title>Androidベンダー向けメモ: root ユーザで adb 接続する</title><link>https://maku77.github.io/p/4ucsovh/</link><pubDate>Wed, 14 Dec 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ucsovh/</guid><description>（下記はデバイス開発者向けの解説であり、root を取得する権限があることを前提としています）
Android 端末の /system 領域を rw で remount したのに、
$ adb push sample.apk /system/app が Permission denied でエラーになる場合は、ADB 接続が system ユーザで実行されている可能性があります。 以下のようすると root ユーザで ADB 接続できます。
# adb root # adb kill-server # adb start-server</description></item><item><title>Androidメモ: Sony Tablet S に adb 接続する</title><link>https://maku77.github.io/p/gg59gt5/</link><pubDate>Sat, 24 Sep 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gg59gt5/</guid><description>基本的には、以下の Sony 公式説明に従えば OK です。
https://www.sony.jp/support/tablet/products/info/sdk.html Android SDK のインストールは済んでいて、adb コマンドは実行できる状態になっていることを前提としています。
Mac OSX から接続する Tablet の設定画面で Debug モード有効にする Tablet と Mac を USB で接続 Mac に Vendor ID を登録する $ echo 0x054c &amp;gt;&amp;gt; $HOME/.android/adb_usb.ini ADB 接続 $ adb kill-server $ adb start-server 接続できたか確認 $ adb devices Windows から接続する Tablet の設定画面で Debug モード有効にする
Tablet と Windows を USB で接続
Google USB Driver をインストール
デバイスマネージャの Sony_Tablet を右クリックして、&amp;ldquo;Update Driver Software&amp;hellip;&amp;rdquo; を選択。 ドライバのディレクトリは、Android SDK の &amp;ldquo;extras/google/usb_driver&amp;rdquo; ディレクトリを選択。 Windows に Vendor ID を登録する</description></item><item><title>Androidメモ: 現在のスクリーンレイアウトサイズを取得する (Configuration)</title><link>https://maku77.github.io/p/7e9mdcp/</link><pubDate>Wed, 14 Sep 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7e9mdcp/</guid><description>Android の現在のスクリーンサイズ (small, medium, large, xlarge) などの情報は Configuration オブジェクトに格納されています。 Activity の中から以下のように情報を取得できます。
// import android.content.res.Configuration; Configuration config = getResources().getConfiguration(); if ((config.screenLayout &amp;amp; Configuration.SCREENLAYOUT_SIZE_MASK) == Configuration.SCREENLAYOUT_SIZE_LARGE) { // LARGE の場合 }</description></item><item><title>APK ファイルの情報を表示する (aapt)</title><link>https://maku77.github.io/p/qqrxpjd/</link><pubDate>Sun, 11 Sep 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qqrxpjd/</guid><description>Android SDK に付属している aapt (Android Asset Packaging Tool) を使用すると、APK の情報を調べることができます。 主にリソースなどの Asset を対象としたツールですが、バージョン情報や、パーミッション情報なども調べることができます。
aapt コマンドは、昔は build-tools ディレクトリ直下にありましたが、現在は build-tools\23.0.2 のようなバージョン名のディレクトリ以下にインストールされるようです。
具体的には下記のようなオプションを指定して APK の情報を確認できます（dump パラメータは d と省略できます）。
aapt d badging myapp.apk パッケージ名、アプリ名、バージョン、パーミッション情報、サポートする Locale の一覧などを確認 aapt d permissions myapp.apk 使用しているパーミッション (uses-permission) と、定義しているパーミッション (permission) の一覧 aapt d strings myapp.apk 文字列リソースの一覧 aapt d resources myapp.apk リソースの一覧（大量に出力されるので注意） aapt d xmltree myapp.apk res/animator/fadein.xml 指定した XML リソースのツリー情報 aapt list myapp.apk リソースファイル名の一覧 aapt コマンドのヘルプ パラメータなしで、aapt コマンドを実行すると、下記のようにヘルプが表示されます。
$ aapt Android Asset Packaging Tool Usage: aapt l[ist] [-v] [-a] file.</description></item><item><title>Androidベンダー向けメモ: LowMemoryKiller の仕組み</title><link>https://maku77.github.io/p/qmcauwd/</link><pubDate>Wed, 07 Sep 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qmcauwd/</guid><description>LowMemoryKiller によるプロセス kill の優先順位の仕組み Android 独自の仕組みである Low Memory Killer は、空きメモリが一定以下になると、アプリプロセスを自動的に kill します。 実体は下記のカーネルに含まれているネイティブプログラムです。
kernel/drivers/staging/android/lowmemorykiller.c どのプロセスが kill されるかは、プロセスごとに設定された adj の値によって決まります。 この値が小さい方が優先度の高いプロセスであることを示し、Low Memory Killer によって殺されにくくなります。 メモリサイズと、adj の関連は、init.rc の中で以下のような感じで設定されます。
# Write value must be consistent with the above properties. write /sys/module/lowmemorykiller/parameters/adj 0,1,2,3,4,5,6,7,14,15 write /sys/module/lowmemorykiller/parameters/minfree 2048,4096,8192,8192,16384,20000,25000,30000,35000,40000 上記の設定では、空きメモリが 8192 page (= 8192 * 4K = 32768K) 以下になったときに、adj が 3 以上であるプロセスが kill されることを示しています。 adj の具体的な値として、以下のようなものがあらかじめ定義されています (Honeycomb)。
ActivityManagerService 内変数 System property Default Description SYSTEM_ADJ -16 The system process runs at the default adjustment.</description></item><item><title>Androidメモ: AsyncTask による非同期処理と UI 更新処理</title><link>https://maku77.github.io/p/o3hggfz/</link><pubDate>Mon, 22 Aug 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o3hggfz/</guid><description>AsyncTask とは android.os.AsyncTask クラスは、バックグラウンドで何か処理をしながら、逐次 UI を更新していくときに便利に使用できるユーティリティ・クラスです。 UI の更新処理はメインスレッドで行わなければいけないため、ワーカースレッドから UI 更新する場合は、通常は Handler オブジェクトを介して処理をメインスレッドに委譲しなければいけません。 AsyncTask を使用すると、このあたりの処理を隠ぺいすることができます。
AsyncTask で実装するメソッド AsyncTask のサブクラスで以下のようなメソッドをオーバーライドし、処理内容を記述します。 ワーカースレッドでの処理内容を doInBackground() 内に記述し、UI の更新処理を onProgressUpdate() で記述するようにします。
doInBackground(Params...) ワーカースレッドで行いたい処理を記述する。UI スレッドとは違うスレッドで実行される。 onProgressUpdate(Progress...) UI の更新処理を記述する。UI スレッドで実行される。doInBackground() 内から progressUpdate() をコールすることで、明示的に呼び出す。 doInBackground() の実行前と、実行後には、以下のようなメソッドが UI スレッドから呼び出されます。 このメソッドもオーバーライドして、UI の更新処理を記述することができます。
onPreExecute() onPostExecute(Result) AsyncTask のキャンセル処理について doInBackground() 内から cancel() を呼ぶと、その時点で onPostExecute() が実行され、その後も doInBackground() は継続されます。 AsyncTask の外から cancel() を呼ぶと、その時点で onCanceled() が実行され、その後も doInBackground() は継続されます。この場合は、onPostExecute() は呼び出されません。</description></item><item><title>Androidメモ: ADB でディレクトリ内のファイルをすべて取得する (adb pull)</title><link>https://maku77.github.io/p/36huwqe/</link><pubDate>Fri, 29 Jul 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/36huwqe/</guid><description>Android SDK の adb pull コマンドは、単一のファイルだけではなく、ディレクトリごとファイルを取得するのにも使用できます。 下記の例では、Android デバイス上の /system/lib ディレクトリ内のファイルをすべて取得しています。
$ adb pull /system/lib pull: building file list... pull: /system/lib/libcutils.so -&amp;gt; ./libcutils.so pull: /system/lib/libssl.so -&amp;gt; ./libssl.so ... 245 files pulled. 0 files skipped. 1575 KB/s (97775523 bytes in 60.596s)</description></item><item><title>Activity の情報を表示する (dumpsys activity)</title><link>https://maku77.github.io/p/mbnw7gq/</link><pubDate>Wed, 08 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mbnw7gq/</guid><description>Android 端末に adb shell で接続後、dumpsys コマンドを実行すると Activity core サービスの情報を表示できます。 例えば、出力の Activity スタックを確認することで、最前面に表示されているアプリの正体を調べることができます。 dumpsys コマンドをパラメータなしで実行すると、大量のメッセージが表示されてしまうので、activity パラメータを指定して Activity に関する情報だけに絞り込むと見やすくなります。
端末上で実行する場合（adb shell でログイン後） # dumpsys activity adb 経由で実行する場合 $ adb shell dumpsys activity 例えば、以下のようにすれば、Stop 状態のアクティビティ含め、現在起動中のアクティビティの一覧を簡単に調べることができます（ここでは Windows の findstr コマンドを使用しています）。
C:\&amp;gt; adb shell dumpsys activity activities | findstr /c:&amp;#34;* TaskRecord&amp;#34; * TaskRecord{2758379e #1 A=com.google.android.leanbacklauncher U=0 sz=1} * TaskRecord{18c788c2 #7 A=com.example.myapp1 U=0 sz=1} * TaskRecord{3cffb420 #4 A=com.example.myapp2 U=0 sz=1}</description></item><item><title>APK ファイルを逆コンパイルする (apktool)</title><link>https://maku77.github.io/p/xr3n5jk/</link><pubDate>Fri, 27 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xr3n5jk/</guid><description>Apktool を使用すると、APK ファイルを逆コンパイルして、内部のファイルの内容を確認することができます。
Apktool - A tool for reverse engineering Android apk files 使い方は簡単で、次のように解析対象の APK ファイルと、出力先のディレクトリを指定するだけです。
使い方 $ apktool d &amp;lt;APKファイル名&amp;gt; &amp;lt;展開先ディレクトリ&amp;gt;</description></item><item><title>Androidベンダー向けメモ: Android の Locale を切り替える（Configuration 値の変更）</title><link>https://maku77.github.io/p/dzocr3s/</link><pubDate>Thu, 19 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dzocr3s/</guid><description>Android の Locale などの Configuration 値を切り替えるには、IActivityManager の updateConfiguration() メソッドを呼び出す必要があります。 ただし、ActivityManagerNative などは hide クラスとして定義されており、一般のアプリ開発者は以下のコードはビルドできません。
IActivityManaager am = ActivityManagerNative.getDefault(); try { Configuration config = am.getConfiguration(); config.XXXX = YYYY; am.updateConfiguration(config); } catch (RemoteException e) { e.printStackTrace(); } 以下のコードは、Locale を変更する方法を示しています。
IActivityManager am = ActivityManagerNative.getDefault(); Configuration config = am.getConfiguration(); config.locale = locale; config.userSetLocale = true; am.updateConfiguration(config);</description></item><item><title>Android Nativeメモ: ServiceManager に登録されたサービスを列挙する</title><link>https://maku77.github.io/p/qn635m9/</link><pubDate>Mon, 09 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qn635m9/</guid><description>下記は、デバイス上の ServiceManager に登録されたサービスを列挙するためのプログラムです。 Android の make でビルドすると、ListServices という実行ファイルが生成されます。
main.cpp #undef LOG_TAG #define LOG_TAG &amp;#34;ListServices&amp;#34; #include &amp;lt;binder/IServiceManager.h&amp;gt; #include &amp;lt;utils/Log.h&amp;gt; #include &amp;lt;utils/RefBase.h&amp;gt; #include &amp;lt;utils/Vector.h&amp;gt; #include &amp;lt;utils/String16.h&amp;gt; #include &amp;lt;utils/String8.h&amp;gt; using namespace android; static int compareServiceName(const String16* lhs, const String16* rhs) { return *lhs &amp;gt; *rhs; } int main() { sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager(); Vector&amp;lt;String16&amp;gt; services = sm-&amp;gt;listServices(); size_t n = services.size(); LOGI(&amp;#34;%d services have found&amp;#34;, n); services.sort(compareServiceName); for (size_t i = 0; i &amp;lt; n; ++i) { LOGI(&amp;#34;[%2d] %s&amp;#34;, i + 1, String8(services[i]).</description></item><item><title>Android Nativeメモ: ネイティブサービスの実装 (3) サービスのインタフェースを定義する</title><link>https://maku77.github.io/p/33w8db9/</link><pubDate>Mon, 09 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/33w8db9/</guid><description>クライアント側のコードをすっきりさせたい IBinder クラスの transact() インタフェースだけでサービスの機能にアクセスするのは分かりにくく、すべてのクライアントコードに本質的ではない Parcel オブジェクトの生成コードが表れてしまいます。
例: CalcService を利用する煩雑なクライアントコード sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager(); sp&amp;lt;IBinder&amp;gt; binder = sm-&amp;gt;getService(String16(&amp;#34;CalcService&amp;#34;)); Parcel data; // Input Parcel reply; // Output data.writeInt32(100); data.writeInt32(50); binder-&amp;gt;transact(0, data, &amp;amp;reply); // Add function LEGI(&amp;#34;CalcService returns: %d&amp;#34;, reply.readInt32()); サービスのインタフェースを定義し、そのインタフェース経由で機能にアクセスできるようにすればクライアント側のコードがすっきりします。 Binder フレームワークには、このためのヘルパークラスなどが用意されていて、これらをうまく使用すると、以下のような感じで CalcService にアクセスできるようになります。
sp&amp;lt;IServiceManager&amp;gt; sm = defaultServiceManager(); sp&amp;lt;IBinder&amp;gt; binder = sm-&amp;gt;getService(String16(&amp;#34;CalcService&amp;#34;)); sp&amp;lt;ICalcService&amp;gt; calc = interface_cast&amp;lt;ICalcService&amp;gt;(binder); int result = calc.add(100, 50); // すっきり！ 簡単に言ってしまえば、IBinder を直接使うのではなく、分かりやすいラッパークラスを用意してやりましょうということです。 interface_cast というテンプレート関数は、IInterface.h で定義されていて、上記のサンプルコードは以下のように展開されます。
sp&amp;lt;ICalcService&amp;gt; calc = interface_cast&amp;lt;ICalcService&amp;gt;(binder); ↓ sp&amp;lt;ICalcService&amp;gt; calc = ICalcService::asInterface(binder); 要するに、ICalcService には、IBinder オブジェクトから ICalcService オブジェクトを取得するための asInterface() メソッドが定義されていないといけません。 最終的にクライアントに公開されるファイルは、サービスインタフェースである ICalcService.</description></item><item><title>Android Nativeメモ: ネイティブサービスの実装 (1) Binder 関連のクラス</title><link>https://maku77.github.io/p/ds6rhco/</link><pubDate>Wed, 27 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ds6rhco/</guid><description>Binder 関連クラス Android のネイティブレイヤのサービスを実装するには、以下のような Binder 関連クラスを使用します。
継承構造 RefBase &amp;hellip; 各種オブジェクトの生存期間を参照カウンタ IBinder &amp;hellip; サービスの基底クラス。プロセス間通信の共通インタフェースとしても使われる。 BpBinder &amp;hellip; クライアント側のプロキシクラス（ServiceManager が自動的にインスタンスを生成する） BBinder &amp;hellip; サービスの基底クラス（基本的な実装を提供） BnInterface IInterface &amp;hellip; クライアントに提供するサービスインタフェースの基底クラス BpRefBase BpInterface &amp;hellip; クライアントに提供するサービスインタフェースの実装 ポイント (a) サービスクラスは BBinder をサブクラス化して作成する。 (b) サービスにアクセスするインタフェースは IInterface をサブクラス化して作成する。 (c) サービスにアクセスするインタフェースの実装は BpInterface をサブクラス化して作成する。 (a) さえ準備してサービスを立ち上げれば、クライアントは IBinder インタフェースでサービスにアクセスできるようになります。 (b)、(c) はまともなサービスインタフェースとしてクライアントに公開する場合に必要です。
ファイルのパス クラス定義 frameworks/base/include/binder/Binder.h (BBinder, BpRefBase) frameworks/base/include/binder/BpBinder.h (BpBinder) frameworks/base/include/binder/IBinder.h (IBinder) frameworks/base/include/binder/IInterface.h (IInterface, BnInterface, BpInterface) frameworks/base/include/utils/RefBase.h (RefBase) frameworks/base/include/utils/StrongPointer.h (sp) 実装 frameworks/base/libs/binder/BpBinder.cpp frameworks/base/libs/binder/IInterface.cpp frameworks/base/libs/utils/RefBase.cpp Binder 関連クラスをざっと眺めてみる RefBase RefBase クラスは、すべての Binder 関連クラスの基底クラスで、インスタンスの生存期間をリファレンスカウンタで管理しています。</description></item><item><title>Android Nativeメモ: ネイティブサービスの実装 (2) サービスの実装から利用まで</title><link>https://maku77.github.io/p/edjwtcr/</link><pubDate>Wed, 27 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/edjwtcr/</guid><description>サービスの実装 サービスとなるクラスは IBinder で定義されたインタフェースを実装する必要があります。 IBinder を直接実装しようとすると、多くの abstract メソッドを実装しないといけませんが、基本的な実装を提供している BBinder クラスを継承してサービスを作成すれば、最低限のインタフェースを実装するだけで済みます。
一番重要なメソッドは、サービスの機能を提供する onTransact() メソッドです。 例えば、計算を行うためのサービス CalcService を考えます。
CalcService.h #include &amp;lt;binder/Binder.h&amp;gt; class CalcService : public android::BBinder { public: virtual status_t onTransact( uint32_t code, // 処理内容分岐のための ID const android::Parcel&amp;amp; data, // 入力値 android::Parcel* reply, // 戻り値 uint32_t flags // 戻り値が必要かどうかなどを示すフラグ ); virtual ~CalcService() {} }; クライアントからの入力値は data パラメータで受け取り、クライアントへの戻り値は reply パラメータに格納します。 この CalcService に複数の機能（足し算、引き算など）を持たせたい場合は、onTransact() メソッドの第一引数で渡される code（int 値）をもとに処理を分岐させます。
status_t CalcService::onTransact(uint32_t code, const Parcel&amp;amp; data, Parcel* reply, uint32_t flags) { switch (code) { case 0: // Add function { int a = data.</description></item><item><title>Androidベンダー向けメモ: android/build/core 以下の *.mk ファイルで定義されている関数 (define) のリスト</title><link>https://maku77.github.io/p/7zgfhqz/</link><pubDate>Fri, 08 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7zgfhqz/</guid><description>下記の bash スクリプトを android/build/core 以下で実行すると、Android の Makefile (.mk) 用に定義されている関数を一覧で取得できます。 Android が定義している関数はハイフンを単語区切りにしているみたいです。
list_defines.sh #!/bin/bash find -name &amp;#39;*.mk&amp;#39; -o -name &amp;#39;Makefile&amp;#39; | xargs grep &amp;#39;^define &amp;#39; | sed &amp;#39;s/^\(.\+\):\(.\+\)/\2 ... \1/&amp;#39; | sort | uniq 実行結果 $ cd android/build/core $ ./list_defines.sh define add-assets-to-package ... ./definitions.mk define _add-clean-step ... ./cleanbuild.mk define add-clean-step ... ./cleanbuild.mk define add-dependency ... ./definitions.mk define add-dex-to-package ... ./definitions.mk define add-java-resources-to-package ... ./definitions.mk define add-jni-shared-libs-to-package ... ./definitions.mk define add-prebuilt-file ... .</description></item><item><title>Androidベンダー向けメモ: インストールされた各 APK パッケージに割り当てられたユーザー ID を調べる (packages.xml)</title><link>https://maku77.github.io/p/okshfzt/</link><pubDate>Tue, 05 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/okshfzt/</guid><description>/data/system/packages.xml ファイルを見ると、各 APK に割り当てられているユーザー ID を調べることができます。
/data/system/packages.xml &amp;lt;package name=&amp;#34;com.example.history&amp;#34; codePath=&amp;#34;/system/app/History.apk&amp;#34; system=&amp;#34;true&amp;#34; ts=&amp;#34;1301918167000&amp;#34; version=&amp;#34;7&amp;#34; userId=&amp;#34;10006&amp;#34;&amp;gt; &amp;lt;sigs count=&amp;#34;1&amp;#34;&amp;gt; &amp;lt;cert index=&amp;#34;3&amp;#34; /&amp;gt; &amp;lt;/sigs&amp;gt; &amp;lt;/package&amp;gt;</description></item><item><title>Android Nativeメモ: ネイティブライブラリ (.so) の展開先</title><link>https://maku77.github.io/p/9dzwawd/</link><pubDate>Thu, 31 Mar 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9dzwawd/</guid><description>Android 1.5 から JNI 呼び出しで用いる共有ライブラリ (.so) は、APK の作成時に自動的にパッケージングされるようになりました。
共有ライブラリはアプリ (.apk) をインストールするときに、自動的に /data/data/&amp;lt;package&amp;gt;/lib に展開される。 アプリ起動時に /data/data/&amp;lt;package&amp;gt;/lib の下の共有ライブラリ (.so) は動的にロードできるようパスが通される。 アプリのアンインストール時には共有ライブラリは自動的に削除される。</description></item><item><title>Android Nativeメモ: C++ 実装用のスマートポインタ (RefBase, sp) を使用する</title><link>https://maku77.github.io/p/w48omg6/</link><pubDate>Thu, 03 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w48omg6/</guid><description>Android フレームワークの android/frameworks/base/include/utils/RefBase.h にスマートポインタクラス sp が定義されてます。 使い方は、
sp&amp;lt;Hoge&amp;gt; hoge = new Hoge(); のような感じで、hoge がスコープを外れると自動的にデストラクタを呼んでくれます。 sp はリファレンスカウンタを持っているので、sp オブジェクト間で代入処理 (operator=) を行っても大丈夫です（代入した瞬間に delete されてしまうことはない）。
スマートポインタとして扱えるようにするクラスは、以下のように RefBase を継承して作成する必要があります。 これは、RefBase が参照カウンタなどを実装しているからです。
Hoge.h #include &amp;lt;utils/RefBase.h&amp;gt; class Hoge : public virtual RefBase { public: static sp&amp;lt;Hoge&amp;gt; self(); ... }; Hoge.cpp Hoge::Hoge() : RefBase() {} Android.mk では libutils.so を使用する指定をしておく必要があります。
Android.mk LOCAL_SHARED_LIBRARIES := \ libutils</description></item><item><title>Traceview でプロファイル情報を表示する</title><link>https://maku77.github.io/p/2wgxfwd/</link><pubDate>Fri, 14 Jan 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2wgxfwd/</guid><description>参考: Traceview - Android Developers
プロファイリングデータを取得する アプリケーション内の特定のコード区間のプロファイリングを行うには、プロファイリンク期間を android.os.debug.Debug クラスの startMethodTracing() と stopMethodTracing() で囲みます。
Debug.startMethodTracing(); ... プロファイリング中 ... Debug.stopMethodTracing(); プロファイリング結果は、/sdcard/dmtrace.trace というバイナリファイルに出力されます。 端末に SD カードが挿入されていないとエラーになります。
startMethodTracing メソッドのパラメータでファイル名のベース名を指定すると、/sdcard/&amp;lt;basename&amp;gt;.trace というファイル名で出力されるようになります。 結局 SD カードに出力されることには変わりありません。
ドキュメントには、
These methods start and stop method tracing across the entire virtual machine.
と記述されているので、Debug.startMethodTracing() を呼び出した時点から、アプリケーション全体（正確には Dalvik VM 全体）のプロファイリングが行われることになります。 Activity がそのアプリのエントリポイントとなっているのなら、onCreate(), onDestroy() でそれぞれ、startMethodTracing()、stopMethodTracing() を呼び出すようにすれば、そのアプリ全体のプロファイリングを行うことができます。
プロファイリングデータを表示する Android SDK に含まれている traceview コマンドを使用すると、プロファイリング結果をグラフィカルに表示することができます。
図: Traceview 上記の図では、タイムラインに main スレッドが一本だけ表示されていますが、複数のスレッドが存在すれば、main 以外のスレッドもその下に表示されます。
まずは、/sdcard/dmtrace.trace ファイルを PC に取得します。
C:\&amp;gt; adb pull /sdcard/dmtrace.</description></item><item><title>Androidベンダー向けメモ: make 後の生成イメージが格納されるディレクトリを調べる ($ANDROID_PRODUCT_OUT)</title><link>https://maku77.github.io/p/xsdpj94/</link><pubDate>Mon, 08 Nov 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xsdpj94/</guid><description>Android ビルド時に lunch コマンドでビルドターゲットを指定すると、ビルドイメージが作成される先のディレクトリ名を $ANDROID_PRODUCT_OUT 変数で参照できるようになります。
$ echo $ANDROID_PRODUCT_OUT /home/maku/work/android/out/target/product/your_product 上記の変数は、build/envsetup.sh の中で定義されるようになっています。
この変数を使用すれば、例えば、adb push で /system/app ディレクトリ内のファイルを端末に転送するための下記のような関数を定義することができます（/system 用のデバイスが /dev/sda5 になっている場合）。
~/.bashrc function adb-push-all { adb shell &amp;#39;mount -o remount -rw /dev/sda5 /system&amp;#39; adb push $ANDROID_PRODUCT_OUT/system/app /system/app adb shell &amp;#39;sync&amp;#39; }</description></item><item><title>Androidメモ: スリープモードに遷移する／スリープから抜ける</title><link>https://maku77.github.io/p/cfqazd7/</link><pubDate>Mon, 01 Nov 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cfqazd7/</guid><description>ADB コマンドを使ってスリープモードに移行する／スリープから抜ける ADB コマンドでスリープ状態に入る $ adb shell &amp;#34;echo mem &amp;gt; /sys/power/state&amp;#34; ADB コマンドでスリープ状態から抜ける $ adb shell &amp;#34;echo on &amp;gt; /sys/power/state&amp;#34; コード内からスリープモードに移行する（ベンダー向け情報） プログラム内からスリープモードに移行するには、AndroidManifest.xml に DEVICE_POWER のパーミッション使用宣言を追加しておきます。
AndroidManifest.xml &amp;lt;manifest ...&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.DEVICE_POWER&amp;#34; /&amp;gt; &amp;lt;/manifest&amp;gt; 適切にパーミッションが割り当てられると、コード内から以下のようにスリープへ移行することができます。
PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); pm.goToSleep(SystemClock.uptimeMillis() + 1); このコードを実行するには、システム権限アプリとして動作している必要があります。 通常アプリから実行すると、以下のような SecurityException が発生します。
E/AndroidRuntime( 7118): java.lang.RuntimeException: Unable to create service com.example.sample.MyService: java.lang.SecurityException: Neither user 10052 nor current process has android.permission.DEVICE_POWER.</description></item><item><title>Androidメモ: ネットワーク情報を取得する (ConnectivityManager, NetworkInfo)</title><link>https://maku77.github.io/p/rm9ve9q/</link><pubDate>Thu, 09 Sep 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rm9ve9q/</guid><description>ネットワークの情報を取得する ネットワーク関連の情報は、ConnectivityManager の getActiveNetworkInfo() メソッドで取得できる NetworkInfo オブジェクトを使って参照できます。 NetworkInfo オブジェクトは以下のように取得します。
// import android.net.ConnectivityManager; // import android.net.NetworkInfo; ConnectivityManager manager = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE); if (manager == null) { return false; } NetworkInfo networkInfo = manager.getActiveNetworkInfo(); if (networkInfo == null) { return false; } NetworkInfo を取得するためには ACCESS_NETWORK_STATE パーミッションが必要なため、AndroidManifest.xml で以下のように宣言しておきます。
AndroidManifest.xml &amp;lt;manifest ...&amp;gt; &amp;lt;uses-permission android:name=&amp;#34;android.permission.ACCESS_NETWORK_STATE&amp;#34; /&amp;gt; ... &amp;lt;/manifest&amp;gt; 参考: ConnectivityManager｜Android Developers ネットワークの情報を一覧表示する NetworkInfo オブジェクトの toString() メソッドで、ネットワーク情報の文字列表現を取得できます。
System.out.println(networkInfo.toString()); 出力結果（実際は一行） NetworkInfo: type: ETHERNET[], state: CONNECTED/CONNECTED, reason: eth0 DHCP success, extra: (none), roaming: false, failover: false, isAvailable: false, iPaddress: 192.</description></item><item><title>ANR の原因を突き止める</title><link>https://maku77.github.io/p/be5zj9v/</link><pubDate>Mon, 16 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/be5zj9v/</guid><description>Android のメインスレッドを長期間ブロックするコードがあると、ANR (Application Not Responding) が発生してアプリケーションが強制終了されます。 端末の画面上で Not responding ダイアログが表示されたら [Force Close] ボタンを押すと、以下のようなログが出るので、kill されたプロセス ID を確認します。
I ActivityManager: Killing process com.example.player (pid=854) at user&amp;#39;s request I Process : Sending signal. PID: 854 SIG: 9 この場合のプロセス ID は 854 です。 ANR の詳細は、/data/anr/traces.txt に出力されています。 このテキストファイルを見てそのプロセス ID に関するコールスタックを確認すると、具体的にどのメソッドでブロックしてしまっているかがわかります。
$ adb pull /data/anr/traces.txt $ vim traces.txt 例えば、以下のように出力されていれば、VideoView.java 258 行目の MediaPlayer.prepareAsync 呼び出しでブロックしていることが分かります。
----- pid 854 at 2008-10-01 12:03:02 ----- Cmd line: com.example.player DALVIK THREADS: &amp;#34;main&amp;#34; prio=5 tid=3 NATIVE | group=&amp;#34;main&amp;#34; sCount=1 dsCount=0 s=N obj=0xb4c69e50 self=0x804d3f0 | sysTid=854 nice=0 sched=0/0 cgrp=unknown handle=-1224341824 at android.</description></item><item><title>Androidメモ: Androidの特殊ディレクトリの情報を取得する (android.os.Environment)</title><link>https://maku77.github.io/p/vjcad5m/</link><pubDate>Tue, 15 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vjcad5m/</guid><description>Android の特殊ディレクトリの情報を取得するには、android.os.Environment クラスを使用します。 以下は、いくつかの主要なディレクトリのパスを取得する方法です。
java.io.File dataDir = android.os.Environment.getDataDirectory(); java.io.File downloadDir = android.os.Environment.getDownloadCacheDirectory(); java.io.File storageDir = android.os.Environment.getExternalStorageDirectory(); java.io.File rootDir = android.os.Environment.getRootDirectory(); Log.d(TAG, dataDir.getAbsolutePath()); // &amp;#34;/data&amp;#34; Log.d(TAG, downloadDir.getAbsolutePath()); // &amp;#34;/cache&amp;#34; Log.d(TAG, storageDir.getAbsolutePath()); // &amp;#34;/sdcard&amp;#34; Log.d(TAG, rootDir.getAbsolutePath()); // &amp;#34;/system&amp;#34;</description></item><item><title>Androidベンダー向けメモ: ART/Dalvik VM のバージョンを調べる (dalvikvm -showversion)</title><link>https://maku77.github.io/p/5at33s8/</link><pubDate>Tue, 01 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5at33s8/</guid><description>Android デバイスの VM のバージョンは dalvikvm コマンドで調べることができます。
$ adb shell # dalvikvm -showversion DalvikVM version 1.1.0 ART を使用している場合は、下記のような感じで表示されます。
# dalvikvm -showversion ART version 2.1.0</description></item><item><title>Logcat のログ出力をフィルタする</title><link>https://maku77.github.io/p/asryvzc/</link><pubDate>Mon, 19 Apr 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/asryvzc/</guid><description>Android の logcat ログの出力は、出力のレベルでフィルタリングしたり、Log.d() メソッドなどの第一引数で指定したタグでフィルタリングできるようになっています。
adb logcat コマンドでのフィルタ方法 logcat コマンドによるログのフィルタリングでは、priority として V/D/I/W/E/F/S のいずれかを指定できます 例えば、W を指定した場合は、Warning レベル以上のログ (W/E/F/S) のみが表示されるようになります。
$ adb logcat *:W # Warning 以上のログだけ表示 $ adb logcat -s Tag1:* # Tag1 タグのログだけを表示 $ adb logcat *:S Tag1:* # 同上 $ adb logcat -s Tag1:W Tag2:E # Tag1 と Tag2 のログだけを表示 $ adb logcat Tag1:S # Tag1 タグのログを非表示 タグ名でログを絞り込みたい場合は、-s オプションで全てタグのログをデフォルトでオフした上で、任意のタグを指定する必要があります。 そうしないと、指定していないタグに関しては、すべてのレベルのログが出てしまいます。
絞り込みに失敗する例 (Tag1 に関してしかレベル制御されない） $ adb logcat Tag1:W Linux を使っているなら、grep にパイプしまって適当にフィルタリングするのもありです。 正規表現も使えるし、こっちのが実は柔軟性は高いかもしれません。 ただ、このやり方は、ログ受信側でフィルタしているだけなので、Android のシステムがログの出力を抑制しているわけではないことに注意してください。</description></item><item><title>Androidメモ: Eclipse から Android SDK を使えるようにする (ADK)</title><link>https://maku77.github.io/p/4ch6hjg/</link><pubDate>Sun, 11 Apr 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ch6hjg/</guid><description>Android SDK がインストール済みであることを前提にしています。
Eclipse に Android Development Toolkit (ADK) をインストール Eclipse から Android SDK を使用するには、ADK というプラグインをインストールします。
Eclipse メニューから Help =&amp;gt; Install New Software... と選択。 Work with: の欄に https://dl-ssl.google.com/android/eclipse/ と入力してインストール。 Android SDK のパスを設定 Eclipse のメニューから Window =&amp;gt; Preferences を選択。 Android を選択し、SDK Location に SDK を展開したディレクトリのパスを入力。 （これをやっておかないと、New Android Project のダイアログで Android SDK has not been setup. と出てプロジェクトを作成できません） プロキシ設定 プロキシ環境にいる場合は、Window =&amp;gt; Preferences =&amp;gt; General =&amp;gt; Network Connections から設定します。
プロキシを設定してもダメな場合は、以下のようなことを試すとうまくいくかもしれません。
アドレスを https:// から http:// に変える Eclipse のバージョンを最新にする Android SDK の Package のアップデート Eclipse のメニューから Window =&amp;gt; Android SDK and ADV Manager。 Available Packages を選択し、URL を選択して、Install Selected をクリック。 SDK のアップデート中に fetching&amp;hellip; から進まない場合 プロキシ設定を行う必要があるかもしれません。 Eclipse そのもののプロキシ設定ではなく、Android SDK and AVD Manager ウィンドウの Settings という項目で設定します。</description></item></channel></rss>