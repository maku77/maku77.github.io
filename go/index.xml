<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on 天才まくまくノート</title><link>https://maku77.github.io/go/</link><description>Recent content in Golang on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 16 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang で MongoDB を扱う (go.mongodb.org/mongo-driver)</title><link>https://maku77.github.io/p/uft7jv9/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uft7jv9/</guid><description>Golang を使って MongoDB サーバーに接続する方法の説明です。
Golang 用の MongoDB ドライバー go.mongodb.org/mongo-driver/mongo モジュールは、Golang 用の MongoDB 公式ドライバーです。 Golang のプロジェクトをモジュールモードで初期化して、go get で依存関係を追加すれば MongoDB にアクセスする準備は完了です。
$ mkdir example-mongo $ cd example-mongo $ go mod init example-mongo $ go get go.mongodb.org/mongo-driver/mongo 接続先の MongoDB サーバーはローカルで起動しておくか、MongoDB Atlas などのクラウドサービスで用意しておいてください。
参考: MongoDB 関連記事｜まくろぐ MongoDB に接続する MongoDB へ接続するためのクライアント設定は、options.ClientOptions インスタンスで表現します。 このインスタンスは options.Client() 関数で生成できるので、あとは各種セッターメソッドでオプション指定していきます。 MongoDB Atlas などのサービスを使っているのであれば、接続文字列が提供されているはずなので、それをそのまま ApplyURI メソッドに渡してやるだけで最低限の接続設定は完了します（参考: 接続文字列の形式）。
main.go（localhost:27017 への接続例） package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;go.mongodb.org/mongo-driver/mongo&amp;#34; &amp;#34;go.mongodb.org/mongo-driver/mongo/options&amp;#34; ) // MongoDB サーバーの接続文字列 const uri = &amp;#34;mongodb://localhost:27017&amp;#34; func main() { ctx := context.</description></item><item><title>gqlgen で子フィールドの情報を返すリゾルバーを実装する</title><link>https://maku77.github.io/p/wdvdtap/</link><pubDate>Wed, 05 Oct 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wdvdtap/</guid><description>何をするか？ Golang の GraphQL ライブラリである gqlgen を使って、GraphQL スキーマからサーバー実装用のコードを自動生成するときに、オブジェクト型の子フィールド用のリゾルバーを生成する方法を説明します。 gqlgen の基本的な使い方は下記を参照してください。
参考: GraphQL サーバーを作成する (gqlgen) デフォルト設定でコード生成した場合 ここでは、入力用の GraphQL スキーマとして次のようなファイルを使うことにします。 オブジェクト型として Book と Author があり、Author は Book の author フィールドとしてのみ使用されています。
graph/schema.graphqls type Query { books: [Book!]! } type Book { id: ID! title: String! author: Author } type Author { id: ID! name: String! } gqlgen generate すると、次のようなモデル（型情報）コードが生成されます。
graph/model/models_gen.go // Code generated by github.com/99designs/gqlgen, DO NOT EDIT. package model type Author struct { ID string `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` } type Book struct { ID string `json:&amp;#34;id&amp;#34;` Title string `json:&amp;#34;title&amp;#34;` Author *Author `json:&amp;#34;author&amp;#34;` } さらに、リゾルバーのテンプレートコードとして次のようなメソッドが自動生成されるのですが、デフォルトの設定 (gqlgen.</description></item><item><title>Golang のジェネリクスで複数の型を扱える関数を定義する (generics)</title><link>https://maku77.github.io/p/cp8o6m2/</link><pubDate>Sun, 25 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cp8o6m2/</guid><description>Golang のジェネリクスを使用すると、複数の型を扱う関数を定義できます。 ジェネリクスは別の言語ではごく一般的な機能として提供されていますが、シンプルな言語仕様を理想としている Golang では当初提供されていませんでした。 ただ、ジェネリクスを望む声は多く、Golang ver 1.8 で導入されることになりました。
ジェネリクスを使わない場合 次のコードの SumInt64 関数と SumFloat64 関数は、両方とも数値スライスの要素を足し合わせる関数ですが、パラメーターの型が int64 と float64 で異なっているため、別々の関数として定義しています。
package main import &amp;#34;fmt&amp;#34; // int64 スライスの全要素を足し合わせた結果を返します。 func SumInt64(vals []int64) int64 { var sum int64 for _, v := range vals { sum += v } return sum } // float64 スライスの全要素を足し合わせた結果を返します。 func SumFloat64(vals []float64) float64 { var sum float64 for _, v := range vals { sum += v } return sum } func main() { fmt.</description></item><item><title>Golang でランダム値（乱数）を扱う (math/rand, crypto/rand)</title><link>https://maku77.github.io/p/graq8o5/</link><pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/graq8o5/</guid><description>Golang でランダム値を扱うパッケージは以下の 2 つが用意されています。
math/rand &amp;hellip; 擬似乱数生成器 (pseudo-random number generator)。初期化のための Seed によって生成される一連の乱数が決定するため、再現性がある。高速な生成が可能だが、生成されるランダム値が予測され得るため、暗号系技術での使用には適さない。 crypto/rand &amp;hellip; 暗号論的擬似乱数生成器（CSPRNG: cryptographically secure pseudo random number generator)。生成されるランダム値を予測するのが困難で、暗号系技術での使用に適している。例えば、秘密鍵の生成や、Nonce 値の生成に用いることができる。math/rand に比べ、crypto/rand でのランダム値生成は時間がかかる。 math/rand による乱数生成 math/rand パッケージのランダム生成器 (*rand.Rand) は、rand.New コンストラクタで生成します。 典型的には、現在時刻を元にしたシードを与えて初期化します。
*rand.Rand を生成する方法 seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) val := r.Float64() // 乱数を生成（rand.Rand のメソッド） あるいは、rand.Seed 関数で、トップレベル関数用のシードを設定することもできます。 こちらの方法を使う場合は、*rand.Rand インスタンスを生成する必要はありません。
トップレベル関数用のシードを設定する方法 seed := time.Now().UnixNano() rand.Seed(seed) val := rand.Float64() // 乱数を生成（rand のトップレベル関数） math/rand パッケージは、次のような乱数生成関数を提供しています。
メソッド 説明 戻り値の型 値の範囲 Int31() 0 以上の 31 ビット整数 int32 0 〜 2,147,483,647 Int31n(n) 0 以上 n 未満の 31 ビット整数 int32 0 〜 n（n ≧ 1） Uint32() 0 以上の 32 ビット整数 uint32 0 〜 4,294,967,295 Int63() 0 以上の 63 ビット整数 int64 0 〜 9,223,372,036,854,775,807 Int63n(n) 0 以上 n 未満の 63 ビット整数 int64 0 〜 n（n ≧ 1） Uint64() 0 以上の 64 ビット整数 uint64 0 〜 18,446,744,073,709,551,615 Int() 0 以上の整数（少なくとも 32 ビット） int 0 〜 システム依存 Intn(n) 0 以上 n 未満の整数（少なくとも 32 ビット） int 0 〜 n（n ≧ 1） Float32() 浮動小数点数（float32 型） float32 [0.</description></item><item><title>Golang でカレントディレクトリ、実行ファイルのパスを取得する (os.Getwd, os.Executable)</title><link>https://maku77.github.io/p/egs2bjt/</link><pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/egs2bjt/</guid><description>カレントディレクトリのパス (os.Getwd) Golang でカレントディレクトリのパスを取得するには、os.Getwd 関数 を使用します。 戻り値は、カレントディレクトリを示す 絶対パス（フルパス） の文字列になります。 カレントディレクトリは、go run コマンドなどを実行したときのディレクトリのことであり、.go ファイルのあるパスではないことに注意してください。
main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { dir, err := os.Getwd() if err != nil { panic(err) } fmt.Println(dir) } 実行結果 $ cd /Users/maku/hello $ go run main.go /Users/maku/hello $ cd /Users/maku $ go run hello/main.go /Users/maku 実行中のファイルのパス (os.Executable) 実行中のファイル (executable) のフルパスを取得するには、os.Executable 関数 を使用します。
main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { path, err := os.</description></item><item><title>Golang で CSV 形式の文字列やファイルを扱う (encoding/csv)</title><link>https://maku77.github.io/p/6k5m3iz/</link><pubDate>Tue, 20 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6k5m3iz/</guid><description>Golang 標準パッケージの encoding/csv を使用すると、CSV 形式のテキストやファイルを Golang の string 配列で読み書きできます。 CSV はカンマ区切りの単純なフォーマットなので、自力でテキストファイルを読み書きすれば済んでしまいそうですが、改行やダブルクォート (&amp;quot;) 含むフィールドの扱い方 (RFC 4180) など、微妙に考慮しないといけない部分もあるので、やはり専用の Reader/Writer 実装を使った方が安心です。
import &amp;#34;encoding/csv&amp;#34; このパッケージは、主に次のクラスを提供しています。
csv.Reader &amp;hellip; CSV の読み出しに使用 csv.Writer &amp;hellip; CSV の書き込みに使用 パッケージ名に csv という名前が使われていますが、オプション指定によりタブ区切り形式の TSV データを扱うこともできます（後述）。
CSV ファイル／テキストを読み出す (csv.Reader) CSV 形式のファイルやテキストを読み出すには、csv.NewReader コンストラクタで csv.Reader を生成します。
func csv.NewReader(r io.Reader) *csv.Reader このコンストラクタは、データソースを読み出すための io.Reader を受け取るようになっているので、CSV テキストを扱いたいときは strings.Reader を、CSV ファイルを扱いたいときは os.File を渡してやれば OK です（どちらも io.Reader のメソッド Read を実装しています）。 あとは、次のようなメソッドで各レコードを文字列スライスとして読み出すことができます。
// 1 つのレコードを読み出す func (r *csv.Reader) Read() (record []string, err error) // すべてのレコードを読み出す func (r *csv.</description></item><item><title>Golang で RDB（リレーショナルデーターベース）を扱う (database/sql)</title><link>https://maku77.github.io/p/kgzfwdt/</link><pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kgzfwdt/</guid><description>Golang の database/sql パッケージ を使用すると、Postgres、MariaDB (MySQL)、SQLite といった RDB 系のデータベースを共通のインタフェースで操作することができます。 database/sql を使ってコーディングしておけば、将来的な RDBMS の乗り換えが容易になります。
ドライバーのインストール database/sql はデータベース操作用の抽象化レイヤーを提供するだけなので、実際にデータベースに接続するには、それぞれのデータベースごとのドライバーが必要です。
ドライバーは SQLDrivers の一覧ページ から好きなものを選択します。 例えば、mattn 氏の SQLite 用ドライバーを使う場合は、次のように go.mod の依存関係を更新し、
$ go get github.com/mattn/go-sqlite3 Go プログラム内で次のようにインポートしておきます（先にインポート文を書いてから go get . とする方法もあります）。
import ( &amp;#34;database/sql&amp;#34; _ &amp;#34;github.com/mattn/go-sqlite3&amp;#34; ) ☝️ ブランク・インポートが必要 アプリケーションのコードの中でドライバーが提供する関数を直接参照しない場合は、上記のようにアンダースコアを使ったブランク・インポートを行い、go mod tidy 時にこの行が削除されないようにしておく必要があります。 インポート行が削除されてしまうと、database/sql パッケージがドライバーを見つけられれず、unknown driver &amp;quot;sqlite3&amp;quot; (forgotten import?) といったエラーが発生します。 データベースへの接続 (sql.Open, DB.Ping) データベースに接続（ドライバーをオープン）するには、sql.Open 関数 を使用します。
func Open(driverName, dataSourceName string) (*sql.DB, error) 第 1 引数には使用するドライバーの名前（例: mysql、sqlite3）、第 2 引数にはドライバーごとの接続文字列 (DSN: data source name) を指定します。 SQLite3 の場合は、接続文字列はデータベースファイル名なので、とてもシンプルです。</description></item><item><title>Golang でコマンドライン引数を扱う (os.Args, flags)</title><link>https://maku77.github.io/p/o8vbo2f/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o8vbo2f/</guid><description>Golang でコマンドライン引数を扱うには、標準パッケージの os や flags を使用します。
os.Args &amp;hellip; 単純に文字列配列で参照する場合 flags パッケージ &amp;hellip; -key value スタイルのオプションを扱う場合 文字列配列でコマンドライン引数を参照する (os.Args) os.Args という文字列配列を参照すると、コマンド実行時に指定したファイル名と、コマンドライン引数を取得することができます。 次のサンプルコードでは、この配列のサイズと、各要素を出力しています。
main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { fmt.Printf(&amp;#34;Length = %d\n&amp;#34;, len(os.Args)) for i, arg := range os.Args { fmt.Printf(&amp;#34;[%d] %s\n&amp;#34;, i, arg) } } 実行例 $ go build -o hello.exe # ビルド $ hello AAA BBB &amp;#34;CCC DDD&amp;#34; Length = 4 [0] hello [1] AAA [2] BBB [3] CCC DDD 上記の &amp;quot;CCC DDD&amp;quot; のように、コマンドライン引数をダブルクォート (&amp;quot;) で囲むことで、1 つの引数として扱われます。</description></item><item><title>Golang で JSON 形式の文字列やファイルを扱う (encoding/json)</title><link>https://maku77.github.io/p/dsbs9p5/</link><pubDate>Sun, 04 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsbs9p5/</guid><description>Golang 標準パッケージの encoding/json を使用すると、Golang のオブジェクトと JSON テキストを相互に変換することができます。
import &amp;#34;encoding/json&amp;#34; Go と JSON の型を変換するとき、次のように対応付けられます（Channel など、一部扱えないデータはあります）。
Go の型 JSON の型 bool boolean float64 number string string []interface{} 配列 map[string]interface{} オブジェクト nil null デフォルトでは、Go の構造体のフィールド名がそのまま JSON のプロパティ名になりますが、構造体フィールドのタグで JSON のプロパティ名を指定する ことができます。 構造体のフィールドがポインタ型である場合は、ポインタが指す実際の値を使って JSON データに変換してくれます。
JSON のプロパティ名を指定する Golang の構造体は、各フィールドにタグという情報を追加 できるようになっています。 encoding/json パッケージは、構造体の json タグを読み取って、JSON データに変換したときのプロパティ名として使用するようになっています。
type Person struct { Name string `json:&amp;#34;name&amp;#34;` Age int `json:&amp;#34;age&amp;#34;` } 上記ように json タグ設定した構造体を、encoding/json パッケージの各種メソッドで JSON に変換すると、次のような感じの JSON データになります。 json タグで指定した通り、プロパティ名がすべて小文字になっていることが分かります。</description></item><item><title>Golang の構造体にタグ情報を追加する (struct tags)</title><link>https://maku77.github.io/p/hxhzfbs/</link><pubDate>Sat, 03 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hxhzfbs/</guid><description>構造体タグ (struct tags) の基本 Go 言語の構造体 (struct) では、各フィールドの末尾に、タグ (struct tags) と呼ばれるメタ情報を付加することができます。 JSON データを扱うプログラムの構造体で、`json:&amp;quot;id&amp;quot;` のような記述があるのを見かけたことがあるかもしれません。 下記の例は、タグを追加した Book 構造体の例です。
type Book struct { Title string `label:&amp;#34;タイトル&amp;#34;` Price int `label:&amp;#34;価格&amp;#34;` } 各タグは、タグ名:&amp;quot;タグ値&amp;quot; というフォーマットの文字列リテラルで設定します。 コロン (:) の前後にスペースを入れてはいけません。 Golang の言語仕様 (Struct types) では、任意の文字列リテラルを配置できると記述されていますが、VS Code などの Lint 系プラグインでは、上記のようなフォーマットで記述していないと警告が出たりするので、このフォーマットで記述しておくのが無難です。 通常はダブルクォート (&amp;quot;) のエスケープをしなくて済むように、バッククォート (`) で囲んだ Raw string literals（生文字列リテラル） を使います。
構造体タグを参照する 構造体の各フィールドに付加したタグを参照するには、reflect パッケージを使ったリフレクションを利用します。 次の例では、各フィールドの label タグの値を出力しています。
main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) type Book struct { Title string `label:&amp;#34;タイトル&amp;#34;` Price int `label:&amp;#34;価格&amp;#34;` } func main() { book := Book{Title: &amp;#34;Golang入門&amp;#34;, Price: 2000} // リフレクションで構造体の各フィールドをループ処理 t := reflect.</description></item><item><title>Golang で GraphQL サーバーを作成する (gqlgen)</title><link>https://maku77.github.io/p/v48adgi/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v48adgi/</guid><description>Go 言語用の GraphQL ライブラリ gqlgen を使って、GraphQL サーバーを作ってみます。 gqlgen は、スキーマファーストの設計を採用しており、最初に GraphQL スキーマを定義し、それに合わせて各クエリ用のリゾルバーを実装していきます。 リゾルバーの雛形は、gqlgen generate というコマンドで生成できます。
Go プロジェクトを作成して gqlgen コマンドをインストールする Go プロジェクトの作成 まずは、Go のプロジェクトを Go Modules として作成します。 モジュール名は適当に example.com/myapp としておきます。
$ mkdir myapp &amp;amp;&amp;amp; cd myapp $ go mod init example.com/myapp これで、myapp ディレクトリ内に go.mod ファイルが生成されます。
gqlgen コマンドのインストール gqlgen コマンドは github.com/99designs/gqlgen という Go モジュールとして提供されています。 Go 言語の慣例として、プロジェクトのビルドに必要なツールのモジュール依存情報は、tools.go というファイルに記述すべしとされているので、次のような内容で作成しておきます（参考: How can I track tool dependencies for a module?）。
tools.go //go:build tools package tools import ( _ &amp;#34;github.</description></item><item><title>Golang で HTTP サーバーを作成する (net/http, rs/cors)</title><link>https://maku77.github.io/p/goruwy4/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/goruwy4/</guid><description>Hugo 標準ライブラリの net/http パッケージ (src) は、HTTP クライアント／サーバーを作成するためのパッケージです。 ここでは、この net/http パッケージを使って、簡単な Web サーバーを実装してみます。
最小限の HTTP サーバーを作る main.go package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { // ポート番号 8080 で待ち受けを開始 log.Fatal(http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil)) } これがおそらく Golang における最小の HTTP サーバー実装です。 http.ListenAndServe 関数 で、指定したアドレスとポート番号で待ち受けを開始しています。 ここではポート番号 8080 だけを指定しているため、localhost:8080 で待ち受けることになります。
☝️ log.Fatal で囲んでいるのはなぜ？ http.ListenAndServe 関数はサーバーの起動に失敗すると error オブジェクトを返します。 log.Fatal 関数で囲んでいるのは、エラーが発生した場合にその内容を出力してから終了するためです。 例えば、サーバーを 2 回続けて起動しようとしたときに、ポート番号が使用中であることを表示してくれます。 逆にサーバーの起動に成功した場合は、http.ListenAndServe 関数は戻ってこないので、log.Fatal 関数が実行されることはありません。 サーバーを Ctrl + C で終了したときも、log.Fatal 関数は実行されません。 このイディオムは、net/http パッケージのドキュメントでも使われています。 go run main.</description></item><item><title>Golang で環境変数を扱う (os.Getenv, os.LookupEnv)</title><link>https://maku77.github.io/p/4ox6dmu/</link><pubDate>Sat, 13 Aug 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ox6dmu/</guid><description>Go 言語で OS の環境変数を扱うには、標準ライブラリの os パッケージ を使用します。
環境変数を参照する (os.Getenv, os.LookupEnv) os.Getenv 関数 を使うと、特定の環境変数を参照することができます。 指定した名前の環境変数が設定されていない場合は、空文字列 (&amp;quot;&amp;quot;) を返します。
main.go package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { shell := os.Getenv(&amp;#34;SHELL&amp;#34;) if shell == &amp;#34;&amp;#34; { fmt.Println(&amp;#34;環境変数 SHELL が設定されていません&amp;#34;) return } fmt.Printf(&amp;#34;SHELL = %s\n&amp;#34;, shell) } 環境変数の値として、明示的に空文字列が設定されていることを判別したい場合は、os.Getenv の代わりに os.LookupEnv 関数 関数を使用します。 os.LookupEnv は、2 番目の bool 型戻り値で、環境変数が設定されているかどうかを返します。
val, ok := os.LookupEnv(key) if !ok { fmt.Printf(&amp;#34;%s not set\n&amp;#34;, key) } else { fmt.Printf(&amp;#34;%s=%s\n&amp;#34;, key, val) } 文字列リテラルで環境変数を参照する (s.</description></item><item><title>Go でコマンドラインツールを作って GitHub で公開する</title><link>https://maku77.github.io/p/whs2bjt/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/whs2bjt/</guid><description>何をするか？ ここでは、Go 言語の HelloWorld として、go-hello というコマンドを作って、GitHub で公開できるようにしてみます。 この手順が完了すると、世界中のユーザーが次のように go-hello コマンドをインストールできるようになります。
$ go install github.com/&amp;lt;User&amp;gt;/go-hello@latest go-hello プロジェクトの作成 まず、適当なディレクトリにプロジェクト用のディレクトリを作成します。
$ mkdir -p ~/go-hello $ cd ~/go-hello go mod コマンドで、プロジェクトのルートディレクトリに go.mod ファイルを作成します。 引数として、モジュール名（モジュールパス）を指定します。 GitHub で公開するのであれば次のような感じで指定します（maku77 の部分は自分の GitHub ユーザー ID に変更してください）。
$ go mod init github.com/maku77/go-hello 作成された go.mod の内容 module github.com/maku77/go-hello go 1.18 Go は、go.mod ファイルのあるディレクトリをモジュールルートとみなします。
go-hello コマンドの実装 実装 Go 言語では実行可能なコマンドは main パッケージの main 関数として実装します。 ファイル名は何でもよいのですが、ここでは main.go として作成します。
go-hello/main.go package main import &amp;#34;fmt&amp;#34; func main() { fmt.</description></item><item><title>Go のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin)</title><link>https://maku77.github.io/p/s258beh/</link><pubDate>Sun, 10 Apr 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s258beh/</guid><description>go install コマンドで Go の実行可能コマンドをインストールすると、次のようなディレクトリにコマンドがインストールされます。
GOBIN 環境変数が設定されていれば、$GOBIN が指すディレクトリ GOPATH 環境変数が設定されていれば、$GOPATH/bin が指すディレクトリ $HOME/go/bin ディレクトリ これらのディレクトリに OS のパスを通しておくと、どのディレクトリからでもインストールしたコマンドを実行できるようになります。 Linux や macOS であれば、~/.zlogin や ~/.bash_profile で次のような感じで設定できます。 ここでは、GOBIN 環境変数を設定して、コマンドのインストール先を ~/bin に設定しています。
~/.zlogin export GOBIN=~/bin export PATH=$PATH:$GOBIN でも、なんだかんだ言って次のような標準的な構成にしておくとトラブルが少なくてよい気がします。
~/.zlogin export GOPATH=$HOME/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN Windows の場合は、コントロールパネルの「環境変数を編集」から次のような感じで設定します（%USERPROFILE% 以外の変数を参照すると、うまく展開できなくて問題が出たりするので注意）。
GOPATH → %USERPROFILE%\go GOBIN → %USERPROFILE%\go\bin PATH → %USERPROFILE%\go\bin （を PATH に追加） 上記のようにパスを通しておけば、go install でインストールしたコマンドを、どこからでも実行できるようになります。
$ go install github.com/maku77/go-hello@latest $ go-hello Hello, world!</description></item><item><title>インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding)</title><link>https://maku77.github.io/p/tbf357g/</link><pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tbf357g/</guid><description>Go 言語には継承の仕組みはありませんが、埋め込み (Embedding) という仕組みによって型の拡張（結合）を行うことができます。
インタフェース埋め込み (Interface Embedding) Go 言語標準の io パッケージには、下記のような Reader インタフェースと Writer インタフェースが定義されています。
type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } ここで、Read メソッドと Write メソッドを両方とも備えるインタフェースを単純に定義しようとすると、下記のように記述することになります。
type ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } Go 言語では、このようなケースのために 埋め込み (Embedding) の仕組みが提供されており、次のように既存のインタフェースを再利用する形で新しいインタフェースを定義することができます。
type ReadWriter interface { Reader Writer } ReadWriter インタフェースを備えるオブジェクトは、ReadWriter 型のパラメータを取る関数だけでなく、Reader 型のパラメータを取る関数や、Writer 型のパラメータを取る関数にも渡すことができます。 ちなみに、この ReadWriter インタフェースも標準の io パッケージで定義されています。</description></item><item><title>ベンチマークを行う (testing.B)</title><link>https://maku77.github.io/p/29dgjnq/</link><pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/29dgjnq/</guid><description>Go のベンチマーク機能の基本的な使い方 Go にはテストフレームワーク（testing パッケージ）の一機能として、ベンチマークを行う仕組みが搭載されています。 ここでは、下記のような構造体を、「値渡し」した場合と、「ポインタ渡し」した場合のパフォーマンスの違いを調べてみましょう。
type Book struct { Title string Author string Price int } func CallByValue(b Book) { } func CallByPointer(b *Book) { } ベンチマーク実行用の関数は、下記のように、Benchmark という名前で始まり、*testing.B 型のパラメーターを持つ関数として定義します。
func BenchmarkXxxYyyZzz(b *testing.B) 例えば、次のような感じで実装します。
// CallByValue の実行速度を計測 func BenchmarkCallByValue(b *testing.B) { book := Book{&amp;#34;Golang&amp;#34;, &amp;#34;Maku&amp;#34;, 1500} for i := 0; i &amp;lt; b.N; i++ { CallByValue(book) } } // CallByPointer の実行速度を計測 func BenchmarkCallByPointer(b *testing.B) { book := Book{&amp;#34;Golang&amp;#34;, &amp;#34;Maku&amp;#34;, 1500} for i := 0; i &amp;lt; b.</description></item><item><title>時刻データを扱う (time)</title><link>https://maku77.github.io/p/sy58beh/</link><pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sy58beh/</guid><description>Go 言語で日付や時刻の情報を扱うには、組み込みの time パッケージを使用します。
時刻データ (time.Time) を作成する 現在時刻を取得する Go 言語で日時を表す型は、time パッケージで定義されている time.Time 型です。 現在の時刻を取得するには、time.Now 関数を使用します。
t := time.Now() fmt.Printf(&amp;#34;%v\n&amp;#34;, t) // time.Time が保持する値を表示 fmt.Printf(&amp;#34;%T\n&amp;#34;, t) // 型名を表示 実行結果 2017-09-12 21:23:23.7770078 +0900 JST m=+0.003000200 time.Time 日時を指定して作成する time.Date 関数を使用して、指定した日時の time.Time を作成することができます。 パラメータには、年、月、日、時、分、秒、ナノ秒、Location を指定します。
t := time.Date(2017, 9, 12, 23, 0, 0, 0, time.Local) fmt.Println(t) // &amp;#34;2017-09-12 23:00:00 +0900 JST&amp;#34; Location には、ローカルタイムで設定することを表す time.Local や、協定世界時で設定することを表す time.UTC を指定することができます。
文字列表現から作成する time.Parse 関数 を使用すると、日時を表す文字列から time.Time オブジェクトを作成することができます。 第 1 パラメータに、日時文字列の形式を表す layout string（後述）、第 2 パラメータに、実際に変換する文字列を渡します。</description></item><item><title>Go 言語のインタフェースの扱いを理解する (interface)</title><link>https://maku77.github.io/p/aimpsvz/</link><pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/aimpsvz/</guid><description>Go 言語で、ある型にインタフェースを実装するときは、Java などとは異なり、implements キーワードを使ったインタフェースの明示は行いません。 Ruby や Python と同様に、同じシグネチャのメソッドを実装した時点で、そのインタフェースを備えているとみなされます。
インタフェースを定義する (type &amp;hellip; interface) Go 言語でインタフェースを定義するときは、構造体 (struct) の定義と同様に type キーワードを使用します。 下記は Go 言語で定義されているインタフェースの例です。
fmt.Stringer インタフェース type Stringer interface { String() string } io.Reader インタフェース type Reader interface { Read(p []byte) (n int, err error) } 上記の例からも想像できるように、Go 言語では、1 つのメソッドだけを持つインタフェースの名前は、メソッド名＋er とする規約となっています。
String 関数だけを持つ → Stringer インタフェース Read 関数だけを持つ → Reader インタフェース Write 関数だけを持つ → Writer インタフェース Format 関数だけを持つ → Formatter インタフェース インタフェースを使用する インタフェースを引数として受け取る関数を定義すると、そのインタフェースが定義するメソッドを実装しているオブジェクトだけを渡せるようになります。
func PrintSomething(s fmt.</description></item><item><title>Golang のパニックによるエラー処理 (panic, recover)</title><link>https://maku77.github.io/p/j47aswy/</link><pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/j47aswy/</guid><description>Go 言語には try ~ catch による例外処理の仕組みは存在しませんが、panic という仕組みが用意されています。
パニックとは？ Go 言語では、関数呼び出し時に発生するエラーは、error オブジェクトを戻り値として返す方法が採用されています（参考: 関数を定義する）。 一方で、実行を継続できないランタイムエラー（スライスの範囲外アクセスなど）が発生した場合には、パニック (panic) を発生させる仕組みになっています。
vals := []int{10, 20, 30} println(vals[3]) // panic: runtime error: index out of range [3] with length 3 パニックが発生すると、デフォルトでは プログラム全体が終了します。 一般的なアプリケーションではパニックは発生させるべきではなく、関数内でエラーが発生したときは error オブジェクトを返すことが推奨されています。
パニックを発生させる (panic) 関数の中から明示的にパニックを発生させるには、panic 関数を呼び出します。 panic 関数には、エラーの内容を示す error オブジェクトを渡すことができます。
import &amp;#34;errors&amp;#34; func dumpBook(b *Book) { if b == nil { panic(errors.New(&amp;#34;Book cannot be nil&amp;#34;)) } // ... } このようにパニックの仕組みは簡単に使えてしまいますが、実行を継続できないケースに限って使用すべきです。 通常シーケンスで発生するエラーに関しては、戻り値として error オブジェクトを返すようにし、呼び出し側で簡単にハンドルできるようにしておきましょう。
panic 関数の代わりに、log パッケージの log.</description></item><item><title>型キャストと型アサーションによる型変換</title><link>https://maku77.github.io/p/jruz369/</link><pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jruz369/</guid><description>Go 言語では暗黙的な型キャストは許されていません。明示的な型変換関数を使用するか、Type Assertion という仕組みを使用して型の変換を行う必要があります。
型キャスト Go 言語では暗黙的な型変換は許されていないため、下記のような異なる型の変数への代入はコンパイルエラーになります。
var i int = 100 var f float64 = i // cannot use i (type int) as type float64 このようなケースでは、型名(値) という形で明示的な 型キャスト を行います。
var i int = 100 var f float64 = float64(i) // OK 下記は様々な型変換の例です。
int8 → int32 var a uint8 = 100 var b uint32 = uint32(a) int32 → int8 var a uint32 = 1234567890 var b uint8 = uint8(a) fmt.Println(b) // 210（情報が欠落する） string → []byte var str string = &amp;#34;ABC&amp;#34; var bytes []byte = []byte(str) fmt.</description></item><item><title>テンプレート機能を使用する (text/template, html/template)</title><link>https://maku77.github.io/p/z8behko/</link><pubDate>Sun, 10 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z8behko/</guid><description>Go には標準パッケージとしてテンプレート機能が用意されています。 テンプレート機能は、定型の Web ページ作成などに活用できます。
２つのテンプレートパッケージ Go 言語には、組込みのテンプレート・パッケージとして、text/template と html/template パッケージが搭載されています。 Web ページの構築に使用する場合は、パラメータを HTML エスケープ処理してくれる html/template パッケージの方を利用します。
text/template Package html/template Package テンプレート機能の基本的な使い方 Template オブジェクトの生成 テンプレート機能を使用するには、まずは Template オブジェクトを生成します。 テンプレートファイルを使用する場合は template.ParseFiles 関数、文字列データをテンプレートとして使用する場合は template.Parse 関数を使用します。
t, err := template.ParseFiles(&amp;#34;./template.html&amp;#34;) if err != nil { log.Fatal(err) } テンプレートファイルのパース処理が成功することが分かっている場合は、次のように template.Must 関数を組み合わせて使用することで、エラー処理の記述を省略することができます（エラーになった場合は panic が発生します）。
t := template.Must(template.ParseFiles(&amp;#34;./template.html&amp;#34;)) テンプレートへの値の埋め込み テンプレートへの値の埋め込みは、Template オブジェクトの Execute メソッドによって行います。 第一引数には出力先、第二引数には埋め込むデータを渡します。
data := &amp;#34;Hello World&amp;#34; if err := t.Execute(os.Stdout, data); err != nil { log.</description></item><item><title>Golang でファイルを読み書きする (os, io)</title><link>https://maku77.github.io/p/6eimpsv/</link><pubDate>Fri, 08 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6eimpsv/</guid><description>Go 言語でファイルの読み書きを行うには、os パッケージや io パッケージを使用します。
ファイルからバイトデータを読み出す（io.Reader） 既存のファイルを読み込み用にオープンするには、os.Open 関数を使用して下記のようにします。
// ファイルを読み取りオープン file, err := os.Open(&amp;#34;./input.txt&amp;#34;) // *os.File if err != nil { log.Fatal(err) } defer file.Close() // 関数を抜けるときに自動実行 defer キーワードでクローズ処理を登録しておくことで、関数から抜けるときに自動的にファイルクローズを実行してくれるようになります。 ファイルを扱うときは、常にこのように記述しておくことで、関数の途中で return したときなどのクローズ忘れを防ぐことができます。 ファイルを開いてすぐに実行すべきイディオムとして覚えておきましょう。
ファイルのオープンに失敗すると、２番目の戻り値として error オブジェクトが返され、下記のようなエラーメッセージを表示して終了 (log.Fatal) します。
2017/09/08 23:43:40 open ./input.txt: The system cannot find the file specified. ファイルのオープンに成功したら、取得した os.File オブジェクトの Read メソッドを使用して読み出し処理を行います（Read は io.Reader インタフェースで定義されているメソッドです）。 Read メソッドは、引数で渡した []byte スライスにファイルの内容を読み込みます。 一度に読み込むサイズは、パラメータとして渡すスライスの長さ (len(s)) になるため、あらかじめ make 関数などを使ってスライス長を確保しておく必要があります。 Read 関数は、ファイルの末尾まで読み込み終わると、0, io.EOF を返します。 ２番目の戻り値が io.</description></item><item><title>マップを扱う (map)</title><link>https://maku77.github.io/p/5cgjnqt/</link><pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5cgjnqt/</guid><description>Go 言語でマップを定義するには、map キーワードを使用します。
マップを定義する (map) Go 言語のマップ型は、map[キーの型]値の型 のように表現します。 どこにもスペースをいれないことに注意してください（go fmt コマンドで自動的にこのようにフォーマットされます）。
例えば、キーの型を string、値の型を int とするマップは次のように作成できます。
空のマップを作る方法 var m = map[string]int{} m := map[string]int{} // 関数内ではこの省略形が使える m := make(map[string]int) // make を使う方法 次のように初期値を指定せずにマップを作成するとゼロ値 (nil) になります。 要素数ゼロのマップとして参照はできますが、要素を追加しようとすると panic が発生します。
あまり意味のない nil マップの作成方法 var m map[string]int // これはゼロ値 (nil) になる println(len(m)) // 0 m[&amp;#34;maku&amp;#34;] = 14 // panic 配列やスライス と同様、初期値を同時に設定してしまうこともできます（前述の例では初期値を空っぽ {} にしています）。 下記のように複数行に分けて初期値を記述する場合、最後の要素の後ろのカンマは省略できないことに注意してください。
m := map[string]int{ &amp;#34;maku&amp;#34;: 14, &amp;#34;puni&amp;#34;: 7, &amp;#34;hemu&amp;#34;: 10, } fmt.</description></item><item><title>メソッドを定義する（レシーバ付き関数）</title><link>https://maku77.github.io/p/4behkor/</link><pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4behkor/</guid><description>Go 言語にはクラスは存在しませんが、構造体型にメソッドを追加するという方法で同様のことを実現することができます。 メソッドは次のような文法で定義します。
func (レシーバ) 関数名(パラメータ) 戻り値 { ... } 通常の関数定義の関数名の前に、(レシーバ) という部分が追加されただけです。 例えば、下記の raisePrice メソッドは、レシーバとして Book オブジェクトを受け取り、そのフィールド値を書き換えます。 パラメータと戻り値はありません。
func (b *Book) raisePrice() { b.Price *= 2 } フィールド値を書き換える場合は、このようにレシーバをポインタ型で指定する必要があります。 このメソッドを呼び出すには、次のようにレシーバとして渡すオブジェクトにドットを付けて呼び出します。
b.raisePrice() // raisePrice メソッドの呼び出し 下記は、完全に動作するサンプルコードです。
package main // Book 構造体を定義 type Book struct { Title string Price int } // Book 構造体にメソッドを追加 func (b *Book) raisePrice() { b.Price *= 2 } func main() { b := Book{Title: &amp;#34;Golang&amp;#34;, Price: 2500} println(b.Price) // 2500 b.</description></item><item><title>構造体を定義する (struct)</title><link>https://maku77.github.io/p/8z2o63r/</link><pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8z2o63r/</guid><description>Go 言語の構造体は、struct というキーワードを使って定義します。
構造体の基本 構造体は、複数のデータをまとめて扱うためのデータ構造です。 下記の例では、書籍のタイトルと著者、値段をフィールドとして持つ Book という構造体を定義しています。
type Book struct { Title string Authors []string Price int } 組込み型に別名を付ける ときには type Age int のように記述しますが、この後ろの int の部分が struct {...} という記述に置き換わったと考えればよいでしょう。
定義した構造体は下記のように使用することができます。
// Book 構造体を定義する type Book struct { Title string Authors []string Price int } func main() { // Book オブジェクトを生成する b := Book{ Title: &amp;#34;Golang ABC&amp;#34;, Authors: []string{&amp;#34;Maku&amp;#34;, &amp;#34;Moja&amp;#34;}, Price: 2500, } // 各フィールドの値を参照する fmt.Println(b.Title) // Golang ABC fmt.Println(b.Authors) // [Maku Moja] fmt.</description></item><item><title>組込み型に独自の型名を付ける (type)</title><link>https://maku77.github.io/p/cuxyj8c/</link><pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cuxyj8c/</guid><description>独自型を定義する Go 言語で type キーワードを使用すると、組込み型に新しい名前を付けることができます。 これは単なるエイリアスではなく新しい型として認識されるので、コンパイル時の型チェックの対象となり、コーディングミスを減らすことができます。 また、自身の値を操作対象とするメソッドを追加することができます。
次のような構文で、既存の組込み型をベースにして、新しい型を定義することができます。
type 型名 既存の型 下記の例では、string 型と同じように使用できる Title 型と Author 型を定義しています。
type Title string type Author string 独自型で型安全なコードを記述する 独自に定義した型を関数のパラメータの型として使うことで、コンパイル時に正しい型のデータが渡されているかをチェックしてくれるようになります。
独自型を使った型安全なコード package main import &amp;#34;fmt&amp;#34; type Title string type Author string func printBook(title Title, author Author) { fmt.Printf(&amp;#34;Title:&amp;#39;%s&amp;#39;, Author:&amp;#39;%s&amp;#39;\n&amp;#34;, title, author) } func main() { t := Title(&amp;#34;Golang ABC&amp;#34;) // var t Title = &amp;#34;Golang ABC&amp;#34; でも OK a := Author(&amp;#34;Maku&amp;#34;) // var a Author = &amp;#34;Maku&amp;#34; でも OK printBook(t, a) } 上記の printBook 関数は、パラメータとして Title、Author 型の値を受け取るように定義しているため、組み込み型の string 変数を渡そうとするとコンパイルエラーになります。</description></item><item><title>ポインタを扱う (＊)</title><link>https://maku77.github.io/p/vpz8fnv/</link><pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vpz8fnv/</guid><description>Go 言語には、C/C++ と同様にポインタが存在します。構文もかなり似ていますが、簡潔に記述できるような工夫がされています。
Go 言語のポインタの基本 Go 言語では、変数の型のプレフィックスとしてアスタリスク (*) を付けると、ポインタ型の変数になります。 ポインタ変数は、その型の値が格納されているメモリアドレスを保持します。 ポインタ変数のゼロ値（初期値）は nil です。
var p *int // p is a pointer to int fmt.Printf(&amp;#34;%v\n&amp;#34;, p) // &amp;lt;nil&amp;gt; 既存の変数のアドレスは &amp;amp; プレフィックスをつけて取得できます。 次の例では、int 型変数 i のアドレスを p に格納しています。
i := 100 p := &amp;amp;i fmt.Printf(&amp;#34;%v (%T)\n&amp;#34;, i, i) // 100 (int) fmt.Printf(&amp;#34;%v (%T)\n&amp;#34;, p, p) // 0xc00018a000 (*int) 逆にポインタが指し示す値にアクセスするには、ポインタ変数の前に * を付けて参照します。 下記の例では、ポインタ経由で参照先の値を書き換えています。
var i int = 100 var p *int = &amp;amp;i fmt.</description></item><item><title>Go 言語の組込み型一覧</title><link>https://maku77.github.io/p/as29hpw/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/as29hpw/</guid><description>Go 言語には次のような組込み型が定義されています。
真偽値 bool &amp;hellip; true or false 文字列 string &amp;hellip; 文字列。文字列リテラルは、&amp;quot;あいうえお&amp;quot; のようにダブルクォートで囲んで表現する。文字列は immutable（不変）であり、文字列の内容を部分的に書き換えることはできない（1 文字でも違う場合は、必ず別の文字列を作成する必要がある）。空文字列 (&amp;quot;&amp;quot;) は格納できるが、nil は格納できない。 数値 整数 int &amp;hellip; システム依存サイズの符号あり整数（ただし、少なくとも 32 ビット以上） int8 &amp;hellip; 8 ビット符号あり整数 int16 &amp;hellip; 16 ビット符号あり整数 int32 &amp;hellip; 32 ビット符号あり整数 int64 &amp;hellip; 64 ビット符号あり整数 uint &amp;hellip; システム依存サイズの符号なし整数（ただし、少なくとも 32 ビット以上） uint8 &amp;hellip; 8 ビット符号なし整数 uint16 &amp;hellip; 16 ビット符号なし整数 uint32 &amp;hellip; 32 ビット符号なし整数 uint64 &amp;hellip; 64 ビット符号なし整数 byte &amp;hellip; uint8 のエイリアス 浮動小数点数 float32 &amp;hellip; 32 ビット浮動小数点数 float64 &amp;hellip; 64 ビット浮動小数点数 複素数 complex64 &amp;hellip; 64 ビット複素数 complex128 &amp;hellip; 128 ビット複素数 ポインタ uintptr &amp;hellip; ポインタ値（アドレス）を格納する、システム依存サイズの符号なし整数 文字 rune &amp;hellip; １文字を表す（Unicode のコードポイント）。int32 のエイリアス。文字リテラルは、'あ' のようにシングルクォートで囲んで表現する。 エラー用インタフェース error</description></item><item><title>変数を定義する (var)／ゼロ値について</title><link>https://maku77.github.io/p/5dhkoru/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5dhkoru/</guid><description>Go 言語では明示的に型を指定した変数定義と、コンパイラによる型推論を利用した変数定義を行うことができます。
変数定義の基本 Go 言語では、var キーワードを使用して、var 変数名 型名 というフォーマットで変数定義します。 Pascal や Ada のように、型名を後ろに指定することに注意してください。
var x int 同じ型の変数を複数定義するときは、下記のように型名を一度だけ記述するだけで済みます（逆に、var x int, y int, z int のように冗長に記述することはできません）。
var x, y, z int 括弧を使用して複数行に分けて変数定義することもできます。
var ( name string age int ) 変数の初期値を指定する = キーワードを使用して、変数の初期値を指定することができます。
var x int = 100 var a, b int = 100, 200 var ( name string = &amp;#34;Rei Ayanami&amp;#34; age int = 14 ) Go には型推論の仕組みが備わっているため、変数の初期値を指定する場合は、型の記述を省略することができます。
var x = 100 var a, b = 100, 200 var ( name = &amp;#34;Rei Ayanami&amp;#34; age = 14 ) 関数の中で変数を定義するときは、:= を使用することで var と型の記述を両方とも省略することができます。</description></item><item><title>構造体のコンストラクタ（ファクトリ関数）を定義する</title><link>https://maku77.github.io/p/6dhkoru/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6dhkoru/</guid><description>Go 言語には構造体のコンストラクタ用の文法は用意されていません。 通常の関数の形で構造体のファクトリ関数を実装します。 ただ、簡単なプログラムであれば、下記のような初期化リストを使ったオブジェクト生成で間に合ってしまいます。
b := Book{Title: &amp;#34;Title&amp;#34;, Price: 2500} 任意のパラメータからオブジェクトを生成できるようにしたい場合は、New で始まる名前のファクトリ関数を作成し、構造体のポインタを返す のが慣例となっています。
book/book.go package book type Book struct { Title string Author string Price int } func NewAuthorlessBook(title string) *Book { return &amp;amp;Book{ Title: title, Author: &amp;#34;Unknown Author&amp;#34;, Price: 100, } } 上記では、book パッケージの中で Book 構造体とそのファクトリ関数を定義してみました。 外部の main パッケージから使用する場合は、下記のような感じのコードになります。
main.go package main import &amp;#34;fmt&amp;#34; import &amp;#34;local.packages/book&amp;#34; func main() { b := book.NewAuthorlessBook(&amp;#34;The World&amp;#34;) fmt.Printf(&amp;#34;%+v\n&amp;#34;, b) } 実行結果 $ go run main.</description></item><item><title>配列とスライスを扱う</title><link>https://maku77.github.io/p/cjosvz3/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cjosvz3/</guid><description>Go 言語の配列は固定長ですが、スライスを組み合わせて使用することで、可変長配列のように扱うことができます。
配列定義の基本 ([n], [&amp;hellip;]) Go で配列を定義するときは、変数の型名の前に [サイズ] プレフィックスを付けて定義します。 例えば、サイズ 3 の int 配列を定義するには次のようにします。
var arr [3]int variable arr is array 3 of int. と自然な英文として読めるような文法になっています。 配列の各要素には、Java や C/C++ のように 0 から始まるインデックスを指定してアクセスすることができます。
var arr [3]int arr[0] = 100 arr[1] = 200 arr[2] = 300 fmt.Println(arr) //=&amp;gt; [100 200 300] // 下記はビルドエラー (invalid argument: array index 3 out of bounds [0:3]) // arr[3] = 400 次のようにすれば、配列定義と同時に 初期値 を設定することができます。
var arr = [3]int{100, 200, 300} // 関数内であれば次のように書ける arr := [3]int{100, 200, 300} 初期値と指定する要素の数と同じサイズの配列を定義するのであれば、配列サイズを下記のように .</description></item><item><title>Golang で関数を定義する (func)</title><link>https://maku77.github.io/p/kswy47a/</link><pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kswy47a/</guid><description>Go 言語の関数定義はシンプルでありながら、複数の値を返すことができるなど、十分な機能を備えています。
関数定義の基本 Go 言語で関数を定義するときは、func キーワードを使用します。
func 関数名(パラメータ) 戻り値の型 { // ... } パラメータや、戻り値を持たない場合は、それぞれ省略することができます。 次の例は、メッセージを出力するだけの単純な関数の実装例です。
パラメータも戻り値もない関数 func hello() { fmt.Println(&amp;#34;Hello&amp;#34;) } 次の関数は、２つの int 型パラメータを受け取り、足し合わせた結果を返します。
func add(a, b int) int { return a + b } 複数の戻り値を持つ関数を定義する（多値関数） Go 言語の関数は、複数の戻り値を返すことができます。 その場合、戻り値の型をカンマで区切って並べ、括弧で囲みます。
func swap(a, b int) (int, int) { return b, a } func main() { x, y := swap(10, 20) fmt.Println(x, y) //=&amp;gt; 20, 10 } 複数の戻り値をひとつの変数で受け取ろうとすると、コンパイルエラーになります。
x := swap(10, 20) // Error: multiple-value swap() in single-value context 必要のない戻り値がある場合は、アンダースコア (_) を使って受け取ります。</description></item><item><title>（旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する</title><link>https://maku77.github.io/p/xs3ahpw/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xs3ahpw/</guid><description>主要なプログラミング言語には、インターネット上のセントラルリポジトリでパッケージを配布する仕組みが提供されていることが多いのですが（Ruby の RubyGems など）、Go 言語では、Git リポジトリ上（主に GitHub）に公開されたソースコードを直接取得 (go get) してインポートする方法を採用しています。
GitHub 上のパッケージをインポートする go get コマンドで、GitHub リポジトリのパスを下記のように指定すると、GitHub 上で公開されている Go パッケージ（ここでは github.com/maku77/gosample）のコードを、$GOPATH/src ディレクトリに取得することができます（$GOPATH についてはこちらを参照）。
github.com/maku77/gosample パッケージを取得する $ go get github.com/maku77/gosample 取得したパッケージは、標準パッケージと同じようにインポートして使用することができます。
sample.go package main import &amp;#34;github.com/maku77/gosample&amp;#34; func main() { gosample.Hello(&amp;#34;Maku&amp;#34;) } ビルド＆実行 $ go run sample.run Hello, Maku! go get コマンドの面白いところは、GitHub 上で公開されているリポジトリ名そのものではなく、そのサブディレクトリで公開されている Go パッケージ名を指定してコードを取得できるところです（git clone コマンドではこのようなことはできませんね）。 例えば、代表的な Pretty Print 系のパッケージである github.com/davecgh/go-spew/spew パッケージは、GitHub 上でのリポジトリ名は https://github.com/davecgh/go-spew.git ですが、そのサブディレクトリとして公開されているパッケージ名を指定して取得することができます。
$ go get github.com/davecgh/go-spew/spew 実際には、go-spew.git リポジトリ以下のファイルがすべて取得されますが、その配下のパッケージを使用するユーザが特に意識する必要はありません。
下記は spew パッケージの使用例です。</description></item><item><title>（旧）GOPATH によるコードの一元管理</title><link>https://maku77.github.io/p/u48bfim/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/u48bfim/</guid><description>Go 言語を用いた開発では、他のプログラミング言語とは異なり、1 つのワークスペース内ですべてのコードを管理するという慣習があります。
（追記）Go 1.11 以降は Go modules の仕組みで、任意のディレクトリでプロジェクト（モジュール）を作成できるようになりました。
ワークスペースの構成 Go のワークスペースは下記のように、bin、pkg、src という３つのディレクトリで構成することが決められています。 このルールに従ってファイルを配置することで、Makefile のようなビルド設定ファイルを用意しなくても、ビルドコマンド (go build) は構造化されたディレクトリ構成のプロジェクトを認識できるようになっています。
~/gowork/ +-- bin/ # 作成したバイナリファイル（go install したときの保存先） +-- pkg/ # 依存パッケージのオブジェクトファイル（.a ファイルなど） +-- src/ # ソースコード（実行対象のファイルやインポートするファイルを配置） Go による開発では、ひとつのシステム内（PC 内）に、ひとつのワークスペースだけを用意して、その中ですべての作業を完結させる方法が主流となっています。 自分で作成しているパッケージも、go get コマンドでインターネット上から取得したパッケージも、PC で唯一のワークスペース内の src/ ディレクトリの中に格納します。 Go のプログラム内から外部パッケージをインポートするときは、まず pkg/ ディレクトリ内のバイナリ版が検索され、次に src/ ディレクトリが参照されるようになっています。
他の言語と比べると、特殊な管理方法（ほとんどルールベースで動作する）なので最初は戸惑うかもしれませんが、一度分かってしまえばそれほど複雑な仕組みではありません（こういった１ワークスペースでの開発が、Google 社内の開発ルールに適していたのかもしれませんね）。
GOPATH によるワークスペースの指定 Go 言語用のワークスペースとして扱うディレクトリ（上記の例では gowork ディレクトリ）は、GOPATH 環境変数であらかじめ指定しておく必要があります。 Go 1.8 以上では、GOPATH を明示的に指定しなかった場合のデフォルトパスは $HOME/go となります（Windows の場合は %USERPROFILE%\go です）。
$ export GOPATH=$HOME/gowork Go が認識している GOPATH の値は、go env GOPATH コマンドで確認することができます。</description></item><item><title>Go ツアーを起動して Go 言語の基本を勉強する</title><link>https://maku77.github.io/p/dkpsvz3/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dkpsvz3/</guid><description>Go ツアーの Web サイトで学ぶ Go には、Go ツアーという Go 言語勉強用のツールが用意されています。まずはこれで Go の基本を一通り学んでみるのがよいです。
下記の Web サイトでは、ブラウザ上で Go 言語のコードを記述、実行しながら Go 言語の基本を学んでいくことができます。
A Tour of Go (https://go.dev/tour/) ローカルで Go ツアーを起動する方法 A Tour of Go は、次のようにローカルの Web サーバーとして立ち上げることができます。 サーバーが立ち上がると、自動的に Web ブラウザが開きます。
$ go run golang.org/x/website/tour@latest 次のようにして、tour コマンドとしてインストールすることもできます。
$ go install golang.org/x/website/tour@latest デフォルトでは $HOME/go/bin 以下に tour コマンドがインストールされるので、次のように起動できます。
$ ~/go/bin/tour GOBIN 環境変数や GOPATH 環境変数を設定している場合は、go install によるコマンドのインストール先が変わるので注意してください。
参考: go install のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin)</description></item><item><title>Golang の if による条件分岐</title><link>https://maku77.github.io/p/pw258be/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pw258be/</guid><description>Go 言語の if 文の構文は、Java や C++ とほぼ同じですが、括弧の使用ルールが微妙に異なります。
if 文の構文 Go 言語の if 文は、条件部を括弧で囲みません。 一方で、実行部分のブロックを囲む中括弧（{ と }）は省略することができません。
x, y := 100, 200 if x &amp;gt; y { fmt.Println(&amp;#34;x is larger than y&amp;#34;) } else if x &amp;lt; y { fmt.Println(&amp;#34;x is smaller than y&amp;#34;) } else { fmt.Println(&amp;#34;x is equal to y&amp;#34;) } 比較演算子としては、Java や C++ と同様の ==、!=、&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;= が使用できます。 文字列の比較も == 演算子で行えます。 論理演算子も同様に、||、&amp;amp;&amp;amp;、! を使用できます。
s := &amp;#34;hemu&amp;#34; x, y := 100, 200 if s == &amp;#34;hemu&amp;#34; &amp;amp;&amp;amp; x &amp;lt; y { // .</description></item><item><title>Golang の switch 条件分岐（switch の基本、便利な使い方、型スイッチ）</title><link>https://maku77.github.io/p/x6adgjn/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x6adgjn/</guid><description>Go 言語の switch 文は、Java や C++ に比べて簡潔に記述できるようになっています。
switch 文の基本 Go 言語の switch 文では、case に複数の値をカンマで区切って指定することができます。 １つの case が実行されると自動的に switch 文を終了するため、C 言語のように case ごとに break と記述する必要はありません。 逆に、次の case を続けて実行したい場合は、明示的に fallthrough と記述する必要があります。
func checkNumber(i int) { switch i { case 0: fmt.Println(&amp;#34;zero&amp;#34;) case 2, 3, 5, 7: fmt.Println(&amp;#34;primary number&amp;#34;) fallthrough default: fmt.Println(&amp;#34;good number&amp;#34;) } } if 文の代わりに switch 文を使うことでコードを簡潔にできることがあります。
func shouldEscape(c byte) bool { switch c { case &amp;#39; &amp;#39;, &amp;#39;?&amp;#39;, &amp;#39;&amp;amp;&amp;#39;, &amp;#39;=&amp;#39;, &amp;#39;#&amp;#39;, &amp;#39;+&amp;#39;, &amp;#39;%&amp;#39;: return true } return false } if 文と同様に、switch 文でも変数のスコープをブロック内に絞った変数定義を行うことができます。 次の os 変数は、switch 文の中でのみ参照できます。</description></item><item><title>パッケージの作成とインポート (import)</title><link>https://maku77.github.io/p/t269cgj/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/t269cgj/</guid><description>Go 言語でパッケージを作る方法と、他のパッケージを参照する色々な方法を紹介します。
パッケージとモジュール パッケージ Go 言語のパッケージは、1 つのディレクトリ内にまとめられたソースコードの集まりです。 下記のディレクトリ構成では、mymodule というモジュール（後述）に、pkg1 と pkg2 という名前の 2 つのパッケージが含まれています。
- mymodule/ - pkg1/ - auth.go (package pkg1) - user.go (package pkg1) - pkg2/ - hoge.go (package pkg2) パッケージ内のファイルの分割粒度は自由で、あるコードがパッケージ内のどの Go ファイルに記述されているかで違いはありません。 パッケージのインポート時にはパッケージ名しか指定しないので、パッケージの利用者は、パッケージを構成する各々の Go ファイルの存在を意識する必要はありません。 パッケージの実装者は、パッケージ内のファイルを都合のいいように分割できます。
Go 言語のソースコードは、必ず 1 つのパッケージに所属している必要があり、ソースコードの先頭の package ディレクティブでパッケージ名（＝親ディレクトリ名）を指定します。
package pkg1 特に、プログラムのエントリポイントとなる main 関数は、main パッケージに存在している必要があり、典型的にはモジュールルートを main パッケージとして扱います。
package main function main() { // ... } モジュール Go 1.11 以降は モジュール という考え方が導入され、Go 1.10 以前の GOPATH によるコードの一元管理 からの移行が進みました。 簡単に言うと、プロジェクト単位でディレクトリを自由な場所に置けるようになりました（以前はすべてのプロジェクトを $GOPATH 以下に置かなければいけませんでした）。 モジュールは単一あるいは複数のパッケージを集めたもので、GitHub などで管理するときののリリース単位として用いられます。</description></item><item><title>Golang のループ処理（for ループ）</title><link>https://maku77.github.io/p/v58cfik/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v58cfik/</guid><description>Go 言語では、for キーワード 1 つだけで while ループや無限ループを表現することができます。
C/C++ 言語風の for ループ for 初期化; 条件式; 後処理 { // ... } Go 言語の for ループは、C/C++ 言語に似た構文を使用しますが、for の直後は括弧で囲みません。 ただし、実行部分の括弧は必ず記述する必要があります。 このあたりのルールは、if 文と同じですね。
記述例 for i := 0; i &amp;lt; 3; i++ { fmt.Println(i) } 実行結果 0 1 2 ちなみに、i++ という部分を、++i という前置インクリメントに置き換えることはできません。 Go 言語では、i++ という後置インクリメントは文として扱われる（評価後の値を得られない）ため、式の中に埋め込むことができないようになっています。 そのため、前置インクリメントと後置インクリメントを区別する必要がそもそもなく、文法として後置インクリメントの形に統一するようになっています。
while ループ（としての for ループ） Go 言語には while ループ（条件に一致する限り繰り返し）は存在しませんが、for ループで代用できます。
i := 0 // i が 3 より小さい間、繰り返す for i &amp;lt; 3 { fmt.</description></item><item><title>定数を定義する (const, iota)</title><link>https://maku77.github.io/p/qqy9gok/</link><pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qqy9gok/</guid><description>Go 言語の定数は、変数を定義するのと同じ感覚で定義することができます。
定数定義の基本 (const) Go 言語の定数は、const キーワードを使用して定義します。
func main() { const foo = 100 fmt.Println(foo) } 次のように複数の定数をまとめて定義することもできます。
const ( hoge = 100 fuga = 200 ) 定数値をパッケージ外に公開する パッケージ外に公開する定数値は、名前を大文字で始めます（関数や変数と同様です）。 逆に、小文字で始まる定数値は、同じパッケージ内からのみ参照可能です。
mypkg/mypkg.go package mypkg const PublicConst = 100 // 別のパッケージから mypkg.PublicConst で参照可能 const privateConst = 200 // mypkg 内からのみ参照可能 main.go package main import &amp;#34;fmt&amp;#34; import &amp;#34;mypkg&amp;#34; func main() { fmt.Println(mypkg.PublicConst) //=&amp;gt; 100 } 標準パッケージの math パッケージも、円周率πを math.Pi という大文字で始まる定数名で公開しています。
package main import &amp;#34;fmt&amp;#34; import &amp;#34;math&amp;#34; func main() { fmt.</description></item><item><title>Go 言語で Hello World をコンパイル、実行する</title><link>https://maku77.github.io/p/nuz369c/</link><pubDate>Wed, 30 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nuz369c/</guid><description>ここでは、Go 言語を使用して簡単な Hello World プログラムを作成し、コンパイル＆実行してみます。
Go 言語で Hello World を実装する Go 言語のソースコードファイルの拡張子は、.go を使用します。
hello.go package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello Go&amp;#34;) } エントリポイントとなる Go プログラムは、main パッケージとして作成し、main 関数を含んでいる必要があります（main.main と表現します）。 ファイル名は何でも構いません。
Hello World を実行する Go 言語はコンパイル型の言語ですが、go run コマンドを使用すると、ソースコードファイルを指定してそのまま実行することができます。
$ go run hello.go Hello Go ビルドして実行ファイル（Windows なら hello.exe）を作成するには、go build コマンドを使用します。
$ go build hello.go $ ./hello Hello Go 作成された実行ファイルは、同じ環境（OS、アーキテクチャ）であれば、Go の処理系がインストールされていなくてもそのまま実行することができます。 別の OS 用にビルドする場合は、クロスコンパイルの機能を使用します。 Go のクロスコンパイルがサポートしている OS と CPU アーキテクチャは、こちらのドキュメント に記述されています。
（応用）モジュール対応モードでアプリを作成する いろいろな外部パッケージを活用して Go アプリを作る場合、モジュールとしてアプリを初期化します（module-aware mode と呼びます）。 モジュールを初期化するには、モジュールルートにしたいディレクトリの下で go mod init &amp;lt;モジュールパス名&amp;gt; を実行します。 Node.</description></item><item><title>Go 言語とは？／Go をインストールする</title><link>https://maku77.github.io/p/wxhzfvc/</link><pubDate>Wed, 30 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wxhzfvc/</guid><description>Go 言語 (Golang) は、Google が 2009 年に発表したオープンソースのプログラミング言語です。 コンパクトな実行ファイルを生成できるため、サーバーレス環境やコンテナ化されたアプリケーションとの相性がよく、多くのプロジェクトでメイン言語として採用されることが増えてきています。 ここでは Go 言語の特徴と、インストール方法を紹介します。
Go 言語の特徴 Go 言語は下記のような特徴を持っています。
マスコットキャラクター（Gopher: ホリネズミ）が 気持ち悪い かわいい 開発者 Ken Thompson（ケン・トンプソン）（C 言語の開発者） Rob Pike（ロブ・パイク）（UTF-8 の開発者） Brad Fitzpatrick（ブラッド・フィッツパトリック）（memcached の開発者） コンパイル型の言語 コンパイルが非常に高速 コンパイルせずにソースコードを指定して実行することも可能（go run sample.go) クロスコンパイルをサポートしており、Windows、Linux、macOS 用の実行ファイルを容易に生成できる 今まで C/C++ で行っていたシステムレイヤのプログラミングをより効率的に行う目的で作成された（ミドルウェアなどの実装に最適） シンプルな言語仕様のため習得が用意で、大規模開発にも耐えられる 最小限の構文により、コーディングのミスを防ぎ、コンパイルを最適化している 例えば、ループ構文は for ループしかない、三項演算子もない 行末のセミコロンは必要ない マクロなどのプリプロセッサ構文はない（コンパイルの低速化の原因のため） 暗黙の型変換はない ポインタはあるが、危険なポインタ演算はない GC による自動メモリ解放（C 言語と Java のいいとこ取り） 継承、ジェネリックプログラミング、アサーション、オーバーロードなども存在しない 2022-03-15 の Go 1.18 リリース でジェネリクスがサポートされました 不要なインポートがあるとコンパイルエラーになる（警告ではなくエラー） try-catch による例外の仕組みがない（関数が多値を返すことでカバー）（panic と recover という仕組みがある） クラスはないが、構造体＋レシーバ付き関数でカバー 豊富な標準パッケージを同梱（暗号化、圧縮、RDB、JSON、テスト用のライブラリなど） 並行処理もネイティブにサポート（ゴルーチンという軽量スレッド、チャネルによるスレッド間通信） テスト実行 (go test) やドキュメント生成 (godoc) のコマンドを標準搭載 バージョン 1.</description></item><item><title>Go 言語のコーディングスタイル（コーディング規約）</title><link>https://maku77.github.io/p/rz47adg/</link><pubDate>Wed, 30 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rz47adg/</guid><description>Go 言語には、標準のコーディング規約が用意されており、それに合わせた組み込みのコードフォーマッター (go fmt) も提供されています。
Go 言語のコーディング規約 Go 言語におけるコーディングスタイルは、下記のドキュメントが参考になるでしょう。
Effective Go - The Go Programming Language ポイントを簡単にまとめておきます。
インデントにはハードタブ（タブ文字）を使用 し、ソフトタブ（半角スペース）を使用しない。 １行あたりの文字数に制限はない。もちろん、長すぎる場合は改行してもよい。 連続した変数定義やコメントは縦に揃える type T struct { name string // name of the object value int // its value } 演算子の前後にスペースを入れない。演算子の優先順位を明確にするときのみスペースを入れる。その代わり余計な括弧を使わない。 x&amp;lt;&amp;lt;8 + y&amp;lt;&amp;lt;16 x, y = y, x+y 命名規則 公開メソッド、フィールド: MexedCaps（大文字で始める） 非公開メソッド、フィールド: mixedCaps（小文字で始める） コンストラクタ: NewBook（New + 生成対象の構造体名） １つのメソッドを持つインタフェース: Reader（Read メソッドだけを持つインタフェース） というように、いくつかのフォーマットルールがあるのですが、Go には下記のような自動整形ツールが付属しているので、これを実行して自動で整形してしまうのが手っ取り早いです。
コードを自動整形する (go fmt と gofmt) Go 言語には、コーディング規約に従ってコードを自動整形するためのツール (go fmt) が標準で搭載されています。</description></item></channel></rss>