<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on 天才まくまくノート</title><link>https://maku77.github.io/docker/</link><description>Recent content in Docker on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 03 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Compose で環境変数を使用する (env_file, environment)</title><link>https://maku77.github.io/p/8r3cmu5/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8r3cmu5/</guid><description>環境変数を参照する Docker Compose の Compose ファイル (docker-compose.yml) 内では、次のように OS（シェル）の環境変数の値を参照することができます。
例: 環境変数 TAG の値を参照する services: web: image: &amp;#34;webapp:${TAG}&amp;#34; この仕組みを利用すると環境に依存する値をハードコードしなくて済むようになるため、汎用的な docker-compose.yml を記述できるようになります。 上記の例では、${TAG} のように記述していますが、多くのケースでは $TAG のようにカッコを省略することができます。 ドル記号 ($) そのものを扱いたい場合は、$$ のように記述する必要があります。
.env ファイル .env ファイルは自動で読み込まれる docker compose up コマンドは、プロジェクトディレクトリに置いてある環境ファイル .env を読み込んでくれます。 .env ファイルには、次のように複数の環境変数を定義しておくことができます。
.env の記述例 # この行はコメント MYAPP_PORT=3000 DB_PASSWORD=mypassword 別の .env ファイルを参照する docker compose コマンドの --env-file オプションを指定すると、参照する .env ファイルを切り替えることができます。
例: .env ではなく .env.prod を参照する $ docker compose --env-file .env.prod up 優先順位 シェル環境で同じ名前の環境変数がセットされている場合（例: export MYAPP_PORT=4000）は、そちらが優先して使われます。 つまり、.</description></item><item><title>Docker Compose の基本</title><link>https://maku77.github.io/p/qm5k2hx/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qm5k2hx/</guid><description>Docker Compose とは？ Docker Compose (docker compose) を使うと、複数の Docker コンテナをまとめてコントロールすることができます。 各コンテナの起動時に必要となるパラメーターや連携方法を docker-compose.yml という YAML ファイルにまとめて記述できるため、すべてのコンテナの起動を docker compose up というシンプルなコマンドで行うことができます。
Docker Compose は複数のコンテナをコントロールすることを想定していますが、単一のコンテナを起動するときにも便利 です。 例えば、Dockerfile を使ったイメージビルド、ポート番号のマッピング、ネットワークの定義などを docker-compose.yml で定義しておいて、docker compose up コマンド一発で実行できます。
docker-compose.yml の中では環境変数の値を参照できる（例: ${APP_PORT}）ため、環境ごとに異なる値をハードコードしなくて済みます。 また、docker compose up コマンドは、環境変数を定義した .env ファイルを自動的に読み込んでくれます。
単一のコンテナを起動してみる Docker Compose で簡単な nginx サーバーを立ち上げてみます。 Docker Compose は、デフォルトで カレントディレクトリ名をプロジェクト名として使用します（-p オプションで任意のプロジェクト名を付けることもできます）。 ここでは、myproject というディレクトリを作って、その中に Compose ファイル (docker-compose.yml) を配置することにします。
$ mkdir myproject $ cd myproject 次のようなシンプルな Compose ファイルを作成します。
docker-compose.yml services: web: image: nginx ports: - &amp;#34;80:80&amp;#34; 各サービス（コンテナ）の定義は、services プロパティの下に記述していきます。 この例では、web という名前のサービスを 1 つだけ定義しており、その下の image プロパティで nginx のイメージを使うよう指示しています。 さらに、ports プロパティで、ホストの 80 番ポートへのアクセスをコンテナの 80 番ポートへ転送しています。 この定義で生成されるコンテナの名前は web ではなく、プロジェクト名や連番が付加された myproject-web-1 という名前になります。</description></item><item><title>Docker Compose をデタッチモードで起動する (docker compose up -d)</title><link>https://maku77.github.io/p/94m3izf/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/94m3izf/</guid><description>docker compose up コマンドを実行すると、現在のターミナル（端末）に入出力がアタッチされて Docker Compose のログが出力されるようになるため、その端末では別の入力作業ができなくなってしまいます（Ctrl-D で停止できます）。
$ docker compose up [+] Running 2/0 ⠿ Network myproject_default Created ⠿ Container myproject-web-1 Created Attaching to myproject-web-1 ...（省略）... myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker processes myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 31 myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 32 ...（省略）... docker compose up コマンドを実行するときに、-d (--detach) オプションを指定すると、Docker Compose がデタッチモードで起動（バックグラウンド実行）されるため、その端末を引き続き使用できるようになります。
$ docker compose up -d [+] Running 1/1 ⠿ Container myproject-web-1 Started $ （次のコマンドを入力可能） 表示されなくなったログは、docker compose logs コマンドで確認できます。</description></item><item><title>Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run)</title><link>https://maku77.github.io/p/y2biqx6/</link><pubDate>Sun, 15 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y2biqx6/</guid><description>コンテナイメージをダウンロードする (docker image pull) Docker でコンテナを作成するためには、ベースとなるイメージが必要です。 多くのイメージが Docker Hub に用意されているので、通常はここからベースとなるイメージを取得します。 ここでは、Ubuntu 20.04 のイメージをダウンロードしてみます。 docker image pull（旧: docker pull）コマンドに、ダウンロードしたいイメージ名 ubuntu と、バージョンを表すタグ 20.04 を指定してダウンロードします。 省略するとデフォルトタグとして、最新バージョンを表す lastest が使用されます。
イメージを取得する $ docker image pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:669e010b58baf5beb2836b253c1fd5768333f0d1dbcb834f7c07a4dc93f474be Status: Downloaded newer image for ubuntu:20.04 docker.io/library/ubuntu:20.04 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。
イメージの一覧を表示する $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB Docker イメージを削除したくなったときは、次のように docker image rm コマンド（旧: docker rmi ）で削除できます。</description></item><item><title>Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach)</title><link>https://maku77.github.io/p/y8cfimp/</link><pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y8cfimp/</guid><description>何をするか？ ここでは、Ubuntu の Docker イメージを使ってコンテナを起動し、その上で実行した bash シェルに接続して自由にコマンドを実行できるようにします。 docker container run、start、attach、exec など似たようなコマンドがたくさんありますが、用途はそれぞれ違うのでここでひととおり理解しておきましょう。
コマンド 意味 docker container run 「イメージの取得」「コンテナの作成」「コンテナの起動」を連続して行う docker container start 作成済みのコンテナを「起動」する docker container attach 動作しているコンテナに「接続」する docker container exec 動作しているコンテナで「プロセスを起動」する docker container run はコンテナの「作成」と「起動」 docker container run（旧: docker run）は、もっとも頻繁に紹介されているコマンドですが、内部で複数のことを行うので 一番分かりにくいコマンド かもしれません。 docker container run は次のようなことを一度に実行します。
指定したイメージがなければダウンロード (docker image pull) Docker コンテナを作成する (docker container create) Docker コンテナを起動する (docker container start) 例えば、次のコマンドを実行すると、Docker イメージ (ubuntu:20.04) のダウンロード、Docker コンテナ (mycon) の作成、そのコンテナの起動までを一気に実行します。
$ docker container run --name mycon -it ubuntu:20.</description></item><item><title>Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs)</title><link>https://maku77.github.io/p/dmpsvz3/</link><pubDate>Wed, 11 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dmpsvz3/</guid><description>コンテナのバックグラウンド起動 (docker container run -d) Docker コンテナ内でプログラムが動作している状態をキープするには、何らかの終了しないプログラムを動かす必要があります（典型的には何らかのサーバープログラムです）。 ここでは、5 秒おきに HELLO と表示するプログラムを動かしてみます。 次のような簡単な bash プログラムです。
/bin/bash -c &amp;#39;while true; do echo HELLO; sleep 5; done&amp;#39; 上記のようなプログラムを、docker run コマンドで単純に Docker コンテナ内で動かすと、起動元の端末（の標準出力）に HELLO と表示され続けてしまいます。 そうではなくて、Docker コンテナ内に閉じて出力するには、docker run コマンドに -d (--detach) オプションを付けて実行します。
$ docker container run --rm -d --name mycon ubuntu:22.04 /bin/bash -c &amp;#39;while true; do echo HELLO; sleep 5; done&amp;#39; 57bf2e3edddf8dcc786ee42e9b2b5a1f50786d80bd45525afa21debcf108613b 引数の意味:
--rm … コンテナ停止時にコンテナを自動で削除します。 -d (--detach) … コンテナをバックグラウンドで動作させます。 --name mycon … コンテナに mycon という名前を付けます。 ubuntu:22.</description></item><item><title>Docker のプロキシ設定</title><link>https://maku77.github.io/p/w69cfim/</link><pubDate>Tue, 10 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w69cfim/</guid><description>Docker ホスト側のプロキシ設定 docker pull などで、Docker Hub リポジトリからイメージを取得するときにプロキシ接続が必要な場合は、Docker コンテナーではなく、Docker ホスト側のプロキシ設定を行う必要があります。 実際には、docker pull コマンドは、docker デーモンに対して命令を送っているだけなので、docker デーモンの方がプロキシ設定を認識する必要があります。 docker デーモンのプロキシ設定は、/etc/default/docker ファイルで行います。
/etc/default/docker（あるいは docker.io） export http_proxy=&amp;#34;http://proxy.example.com:3128/&amp;#34; 設定変更後は、docker デーモンを再起動すれば OK です。
$ sudo service docker.io restart これで、無事にプロキシ経由で docker pull できるようになります。
Docker コンテナ内で使用するプロキシ設定 Docker コンテナの中で、apt-get や curl などを使ったインターネットアクセスを行う場合は、Docker コンテナ側でプロキシの設定を行う必要があります。 docker run で Docker コンテナを起動するときに、-e オプションで http_proxy 環境変数 を渡して起動することができます。
$ sudo docker run -e http_proxy=http://proxy.example.com:8888/ -it debian:wheezy もちろん、Docker コンテナを起動したあとで、コンテナ上のシェルから環境変数を設定することもできます。
$ sudo docker run -it debian:wheezy root@7cb147891556:/# export http_proxy=http://proxy.example.com:8888/ root@7cb147891556:/# Docker イメージとして、必ず特定のプロキシを使うことが決まっているのであれば、Docker イメージを作成する際の Dockerfile にプロキシ設定を埋め込んでしまうこともできます。 このプロキシ設定は、Docker イメージを構築する際の、RUN コマンド (apt-get) にも効いてきます。</description></item><item><title>一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録）</title><link>https://maku77.github.io/p/an7o5m3/</link><pubDate>Tue, 10 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/an7o5m3/</guid><description>docker コマンドは、内部で socket を使って通信を行っており、一般ユーザからコマンドを実行すると、permission denied で怒られることがあります。
$ docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a 2015/03/10 22:50:19 Get http:///var/run/docker.sock/v1.12/version: dial unix //var/run/docker.sock: permission denied 上記の出力を見ると、var/run/docker.sock ファイルへのアクセス権限がないことが分かります。 このような場合は、次のいずれかの方法で docker コマンドを実行できるようになります。
sudo を付けて実行する ユーザーを docker グループに追加する sudo を付けて実行する方法 sudo をつけてスーパーユーザー権限で docker コマンドを実行する方法です。
$ sudo docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a Server version: 1.</description></item><item><title>Docker をインストールする (Docker Desktop / Docker Engine)</title><link>https://maku77.github.io/p/96o6n4j/</link><pubDate>Mon, 09 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/96o6n4j/</guid><description>Docker 実行環境のインストール Docker の実行環境（docker コマンド）をインストールするには、下記の公式マニュアルの手順に従ってください。 基本的に、Windows や macOS では Docker Desktop、Linux では Docker Engine をインストールすることになります。
https://docs.docker.com/get-docker/ 例: Windows の場合 (Docker Desktop) 例: macOS の場合 (Docker Desktop) 例: Ubuntu の場合 (Docker Engine) 例: Debian の場合 (Docker Engine) 例えば、Linux 環境では次のような感じで Docker Engine をインストールできます（詳細は上記の公式ページを参照してください）。
# インストール $ curl -sSL get.docker.com -o install.sh $ sh install.sh # Docker サービスを systemd で自動起動する設定 $ systemctl enable docker # Docker サービスを直ちに起動 $ systemctl start docker インストール手順を実行後、docker コマンドが使えるようになっていれば準備 OK です。</description></item></channel></rss>