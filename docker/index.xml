<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on 天才まくまくノート</title><link>https://maku77.github.io/docker/</link><description>Recent content in Docker on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 31 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>サーバー再起動時に Docker コンテナを自動起動する</title><link>https://maku77.github.io/p/rh8qm2n/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rh8qm2n/</guid><description>VPS などのサーバーを再起動したときに Docker コンテナを自動起動するには、docker container run コマンドでコンテナを起動するときに、--restart フラグを付けて 再起動ポリシー を設定します。
$ docker run -d --restart always redis Docker Compose ファイルを使う場合は次のように記述します。
docker-compose.yml version: &amp;#39;3.8&amp;#39; services: redis: image: redis container_name: redis restart: always 起動方法 $ docker compose up -d 正確には VPS サーバーの再起動時というより、Docker デーモンの再起動時に、コンテナの再起動ポリシーによりコンテナが再起動されるという流れになります。 VPS サーバーが起動したときに Docker デーモンを自動起動するようにする設定は、systemd などのプロセスマネージャーで別途設定しておく必要があります。
☝️ ワンポイント VPS サーバー再起動時の Docker コンテナー自動起動の流れ:
プロセスマネージャー (systemd) により Docker デーモンが起動する Docker の再起動ポリシーによりコンテナが起動する</description></item><item><title>WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh)</title><link>https://maku77.github.io/p/w6cjckc/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w6cjckc/</guid><description>別 PC から WSL2 内のサーバーへのアクセス Windows の WSL2 環境で Docker コンテナを動かしているとき、そこで起動した Web サーバーなどへは、LAN 内の別 PC からはデフォルトではアクセスできません。
LAN 内の別 PC ---&amp;gt; Windows ---&amp;gt; WSL2 (Docker) このようなアクセスを許可するには、Windows のコマンドプロンプトを管理者として実行し、次のように netsh interface portproxy コマンドでポートフォワード設定をしてやる必要があります。 netsh ユーティリティ（ネットワークサービスシェル）は、Windows 上の様々なネットワーク構成を設定／参照するためのコマンドです。
Windows のポートフォワード設定を追加する C:\&amp;gt; netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=80 connectaddress=172.28.72.28 connectport=80 上記の例では、外部からの Windows の 80 番ポートへのアクセス (0.0.0.0:80) を、WSL2 の 80 番ポート（この例では 172.28.72.28:80）へ転送するように設定しています。
現在のポートフォワード設定 (portproxy) は次のように確認できます。
Windows のポートフォワード設定を確認する C:\&amp;gt; netsh interface portproxy show all ipv4 をリッスンする: ipv4 に接続する: Address Port Address Port --------------- ---------- --------------- ---------- 0.</description></item><item><title>Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する</title><link>https://maku77.github.io/p/5f2j2hz/</link><pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5f2j2hz/</guid><description>何をするか？ 複数の Web アプリを 1 つの VPS（レンタルサーバー）でホスティングする場合、一般的にはリバースプロキシ（nginx など）を立てて、各 Web アプリのバックエンドに繋ぐことになります。 例えば、nginx のバーチャルホスト機能を使って、app1.example.com というアドレスと app2.example.com というアドレスでアクセスされたときに、それぞれ別の Web アプリサーバー（バックエンド）に処理を振り分けます。 ここでは、リバースプロキシと 2 つの Web アプリを別々の Docker Compose で立ち上げて連携する方法を説明します。
図: リバースプロキシによる Docker Compose 連携 1 セットの Web アプリであれば、1 つの Docker Compose 内に関連するコンテナをすべて含めてしまうのが楽ですが、ここでは、独立した 2 つの Web アプリを 1 つの物理サーバー (VPS) 上で運用することを考えているので、別々の Docker Compose に分けています。 もちろん、各アプリが使用する DB コンテナなどは、それぞれの Docker Compose 内にある想定ですが、上記の図では省略しています。
ここで紹介しているソースコードは GitHub に置いてあります。
テスト用の事前準備（hosts ファイル） 今回使用する nginx の設定ファイルでは、app1.example.com と app2.example.com という仮のドメインを使用していますが、本来は実在するドメインでなければいけません。 この設定のままテストしたい場合は、OS の hosts ファイルに次のようなエントリを追加して、ローカルホスト (127.</description></item><item><title>Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する</title><link>https://maku77.github.io/p/qatbs9p/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qatbs9p/</guid><description>Docker コンテキストとは？ Docker コンテキストは、ひとことで言うと、Docker CLI で入力したコマンド (docker) の操作対象ホストを切り替えるための仕組みです。
図: Docker コンテキストの切り替え 例えば、Conoha などの VPS サーバー や、Azure (ACI)、AWS (ECS) といったクラウドサービス上の Docker エンジンに対して、ローカルホストから docker コマンドを実行できるようになります。 カレントコンテキストは、docker compose use コマンドで簡単に切り替えることができるので、ローカルでのコンテナのテストが終わったら、コンテキストを Azure (ACI) に切り替えてクラウド環境上で docker compose up するといったことが簡単にできます。
当然、接続先のコンテナサービスごとに接続プロトコルは異なるのですが、Docker は標準で Azure や AWS をターゲットとしたコンテキストの作成に対応しており、実際に docker コマンドを実行するときは接続プロトコルを意識しないで済むようになっています。 ここでは、より汎用的な SSH 接続を用いるコンテキストを作成し、リモートホスト上の Docker エンジンに対して Docker コマンドを実行してみます。
前提条件:
リモートホストに Docker がインストールされていること リモートホストに SSH キーで SSH 接続できるようなっていること（参考: SSH の使い方） 接続先のユーザーが sudo なしで docker コマンドを実行できるようなっていること（参考: docker グループへの追加） デフォルト・コンテキスト Docker Desktop をインストールすると、デフォルトのコンテキストとして、default という名前のコンテキストが作成されます。 Docker コンテキストの一覧を表示するには、docker context ls コマンドを使用します。</description></item><item><title>Docker Compose で環境変数を使用する (env_file, environment)</title><link>https://maku77.github.io/p/8r3cmu5/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8r3cmu5/</guid><description>環境変数を参照する Docker Compose の Compose ファイル (docker-compose.yml) 内では、次のように OS（シェル）の環境変数の値を参照することができます。
例: 環境変数 TAG の値を参照する services: web: image: &amp;#34;webapp:${TAG}&amp;#34; この仕組みを利用すると環境に依存する値をハードコードしなくて済むようになるため、汎用的な docker-compose.yml を記述できるようになります。 上記の例では、${TAG} のように記述していますが、多くのケースでは $TAG のようにカッコを省略することができます。 ドル記号 ($) そのものを扱いたい場合は、$$ のように記述する必要があります。
.env ファイル .env ファイルは自動で読み込まれる docker compose up コマンドは、プロジェクトディレクトリに置いてある環境ファイル .env を読み込んでくれます。 .env ファイルには、次のように複数の環境変数を定義しておくことができます。
.env の記述例 # この行はコメント MYAPP_PORT=3000 DB_PASSWORD=mypassword 別の .env ファイルを参照する docker compose コマンドの --env-file オプションを指定すると、参照する .env ファイルを切り替えることができます。
例: .env ではなく .env.prod を参照する $ docker compose --env-file .env.prod up 優先順位 シェル環境で同じ名前の環境変数がセットされている場合（例: export MYAPP_PORT=4000）は、そちらが優先して使われます。 つまり、.</description></item><item><title>Docker Compose の基本</title><link>https://maku77.github.io/p/qm5k2hx/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qm5k2hx/</guid><description>Docker Compose とは？ Docker Compose (docker compose) を使うと、複数の Docker コンテナをまとめてコントロールすることができます。 各コンテナの起動時に必要となるパラメーターや連携方法を docker-compose.yml という YAML ファイルにまとめて記述できるため、すべてのコンテナの起動を docker compose up というシンプルなコマンドで行うことができます。
Docker Compose は複数のコンテナをコントロールすることを想定していますが、単一のコンテナを起動するときにも便利 です。 例えば、Dockerfile を使ったイメージビルド、ポート番号のマッピング、ネットワークの定義などを docker-compose.yml で定義しておいて、docker compose up コマンド一発で実行できます。
docker-compose.yml の中では環境変数の値を参照できる（例: ${APP_PORT}）ため、環境ごとに異なる値をハードコードしなくて済みます。 また、docker compose up コマンドは、環境変数を定義した .env ファイルを自動的に読み込んでくれます。
単一のコンテナを起動してみる Docker Compose で簡単な nginx サーバーを立ち上げてみます。 Docker Compose は、デフォルトで カレントディレクトリ名をプロジェクト名として使用します（-p オプションで任意のプロジェクト名を付けることもできます）。 ここでは、myproject というディレクトリを作って、その中に Compose ファイル (docker-compose.yml) を配置することにします。
$ mkdir myproject $ cd myproject 次のようなシンプルな Compose ファイルを作成します。
docker-compose.yml services: web: image: nginx ports: - &amp;#34;80:80&amp;#34; 各サービス（コンテナ）の定義は、services プロパティの下に記述していきます。 この例では、web という名前のサービスを 1 つだけ定義しており、その下の image プロパティで nginx のイメージを使うよう指示しています。 さらに、ports プロパティで、ホストの 80 番ポートへのアクセスをコンテナの 80 番ポートへ転送しています。 この定義で生成されるコンテナの名前は web ではなく、プロジェクト名や連番が付加された myproject-web-1 という名前になります。</description></item><item><title>Docker Compose をデタッチモードで起動する (docker compose up -d)</title><link>https://maku77.github.io/p/94m3izf/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/94m3izf/</guid><description>docker compose up コマンドを実行すると、現在のターミナル（端末）に入出力がアタッチされて Docker Compose のログが出力されるようになるため、その端末では別の入力作業ができなくなってしまいます（Ctrl-D で停止できます）。
$ docker compose up [+] Running 2/0 ⠿ Network myproject_default Created ⠿ Container myproject-web-1 Created Attaching to myproject-web-1 ...（省略）... myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker processes myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 31 myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 32 ...（省略）... docker compose up コマンドを実行するときに、-d (--detach) オプションを指定すると、Docker Compose がデタッチモードで起動（バックグラウンド実行）されるため、その端末を引き続き使用できるようになります。
$ docker compose up -d [+] Running 1/1 ⠿ Container myproject-web-1 Started $ （次のコマンドを入力可能） 表示されなくなったログは、docker compose logs コマンドで確認できます。</description></item><item><title>Docker Hub のイメージを検索する (docker search)</title><link>https://maku77.github.io/p/4ohyhxe/</link><pubDate>Sun, 03 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ohyhxe/</guid><description>docker search コマンドを使って、Docker Hub（レジストリ）で公開されているイメージを検索することができます。 次の例では、ubuntu というキーワードでイメージを検索しています。 Docker Hub 上で付けられたスターの数や、公式イメージかどうかもチェックできます。
$ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 14524 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 286 [OK] ubuntu-upstart DEPRECATED, as is Upstart (find other proces… 112 [OK] neurodebian NeuroDebian provides neuroscience research s… 91 [OK] open-liberty Open Liberty multi-architecture images based… 53 [OK] ubuntu/nginx Nginx, a high-performance reverse proxy &amp;amp; we… 52 ubuntu-debootstrap DEPRECATED; use &amp;#34;ubuntu&amp;#34; instead 46 [OK] ubuntu/apache2 Apache, a secure &amp;amp; extensible open-source HT… 36 ubuntu/mysql MySQL open source fast, stable, multi-thread… 34 kasmweb/ubuntu-bionic-desktop Ubuntu productivity desktop for Kasm Workspa… 29 ubuntu/prometheus Prometheus is a systems and service monitori… 27 ubuntu/squid Squid is a caching proxy for the Web.</description></item><item><title>Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal)</title><link>https://maku77.github.io/p/najs2ah/</link><pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/najs2ah/</guid><description>コンテナからホスト側のサーバーにアクセスする Docker コンテナの中から、ホスト側で動作しているサービス（Web サーバーなど）にアクセスするには、IP アドレスの代わりに特殊な DNS 名 host.docker.internal を使用します（localhost だとコンテナ自身を参照してしまうのでうまくいきません）。
コンテナからホスト上のサービスにアクセスする $ curl http://host.docker.internal:8000/ 接続テスト テストとして、ホスト上で Web サーバーを起動してコンテナからアクセスしてみます。 まず、何でもいいのでホスト側で Web サーバーを起動します。
Docker で nginx サーバーを起動する方法 $ docker container run --rm -p 8000:80 --name webserver nginx:alpine Python のワンライナーで Web サーバーを起動する方法 $ python -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... 参考: Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) 次に、コンテナ側からこの Web サーバーに curl でアクセスできるか確認します。 ここでは、軽量のコンテナとして Alpine Linux を使っています。
コンテナからホスト側の Web サーバーにアクセス $ docker container run --rm -it alpine ash / # apk add curl / # curl http://host.</description></item><item><title>Docker のネットワークについて理解する (none, host, bridge)</title><link>https://maku77.github.io/p/7fjnqtw/</link><pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7fjnqtw/</guid><description>Docker の 3 つのネットワーク Docker をインストールすると、デフォルトで none、host、bridge という 3 つのネットワークが生成されます。 docker network ls コマンドの出力の NAME カラムを見ると、これら 3 つの名前があることを確認できます。
$ docker network ls NETWORK ID NAME DRIVER SCOPE 1d32c46c83f6 bridge bridge local a97adbf7b226 host host local 7543afe52cd6 none null local none Docker コンテナにネットワークインタフェースを持たせたくない場合に指定します。 つまり、外部との通信が一切できないコンテナになります。 host ホスト側のネットワークインタフェースを共有するときに指定します。 つまり、ホストと同じ IP アドレスがコンテナに割り当てられます。 bridge 一番よく使用されるネットワークで、bridge という名前の仮想ブリッジに接続されたネットワーク環境であることを示します。 docker container create (run) でコンテナを作成するときにネットワーク (--net) を指定しないと、デフォルトでこの bridge が使われます。 Linux のブリッジ機能を利用しており、このネットワークに参加したコンテナからは、インターネットにアクセスすることができます。 同じ bridge に接続するコンテナは、同じ仮想ブリッジで接続された状態（同じネットワークに所属する状態）になるため、相互に通信ができます（ping など）。 Docker コンテナを作成する際には、どのネットワークを使うかを --net オプションで指定します。 指定しない場合はデフォルトで bridge が使われます。</description></item><item><title>Docker のコンテナイメージを削除する (docker image rm/prune)</title><link>https://maku77.github.io/p/8fjnqtw/</link><pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8fjnqtw/</guid><description>docker image rm （指定したコンテナイメージを削除する） 使い方 docker image pull や docker container run 経由でダウンロードした Docker イメージを削除するには、docker image rm コマンド（旧: docker rmi）を使用します。
$ docker image rm ＜イメージ＞ 削除するイメージは、イメージ名:タグ名 や イメージID の形で指定します。
$ docker image rm ubuntu:20.04 $ docker image rm 54c9d81cbb44 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。
$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB ヘルプ $ docker help image rm Usage: docker image rm [OPTIONS] IMAGE [IMAGE.</description></item><item><title>Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する</title><link>https://maku77.github.io/p/z3n4hye/</link><pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z3n4hye/</guid><description>マルチステージビルドとは？ ある GitHub のリポジトリに、Dockerfile と src/hello.go（Go 言語のコード）が入っているとします。
myapp/ +-- Dockerfile （アプリのビルド＆実行コンテナイメージの生成用） +-- src/hello.go （Hello World アプリのソースコード） この Dockerfile で作成したいのは、Go ソースコードをビルドしてできた hello アプリを実行するための Docker イメージです。 つまり、この Dockerfile ファイルには、次のようなイメージ生成手順を記述することになります。
src/hello.go をビルドして、実行ファイル hello を生成する。 hello を実行するための Docker コンテナイメージを生成する。 ここで 1 つ疑問が出てきます。 最終的な Docker イメージでは hello アプリの実行環境さえ整っていればよいはずですが、上記の手順通りに Docker イメージを構築すると、Go 言語のビルド環境まで含まれてしまいそうです。 hello アプリを実行するための軽量なイメージを作るにはどうしたらよいでしょうか？ このようなケースで便利なのが、Docker の マルチステージビルド です。
なお、アプリのソースコード (src/hello.go) には何を使ってもよいのですが、ここでは次のような簡単な Hello World コードを使うことにします。
src/hello.go package main import &amp;#34;fmt&amp;#34; func main() { fmt.Printf(&amp;#34;Hello World\n&amp;#34;) } シングルステージビルドの場合 マルチステージビルドの効果を実感するために、まずはシングルステージによるビルド（従来のビルド方法）で Docker コンテナをビルドしてみます。</description></item><item><title>Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp)</title><link>https://maku77.github.io/p/cqar8o5/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cqar8o5/</guid><description>docker container cp コマンドを使用すると、Docker コンテナ内の任意のファイルやディレクトリを、ホスト PC にコピーすることができます。
例えば、以下のようにすると、mycon コンテナ内の /work/hello というファイルを、ホスト側のカレントディレクトリにコピーすることができます。
$ docker container cp mycon:/work/hello ./ ディレクトリごと丸ごとコピーすることもできます。
$ docker container cp mycon:/work/imgs ./imgs 逆に、ホスト側のファイルを Docker コンテナにコピーすることもできます。
$ docker container cp hoge.txt mycon:/work/tempdir</description></item><item><title>Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfs マウント）</title><link>https://maku77.github.io/p/hxhzgxf/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hxhzgxf/</guid><description>Docker の 3 種類のマウント Docker コンテナ内で作成・編集した作業ファイルは、コンテナを停止 (docker container stop) しても消えてしまうことはありませんが、コンテナを削除 (docker container rm) した場合には消えてしまいます。 これは、コンテナ内のファイル群が、コンテナ内に閉じて存在しているからです（だからこそコンテナなのですが）。
Docker のマウント機能を用いると、コンテナ内の特定のディレクトリパス（の中のファイル群）をホスト PC 上のファイルシステムに関連付けることができるため、コンテナのライフサイクルとは切り離して作業ファイルを管理できるようになります。 マウントには下記で説明する 3 種類がありますが、作業ファイルをホスト PC 側に永続化したい場合は、「ボリュームマウント」か「バインドマウント」というマウントタイプを使用します。 もうひとつの「tmpfs マウント」は、その名のとおりテンポラリファイルにのみ使用できます。
図: Docker の 3 種類のマウント（公式サイトより） ボリュームマウント ホスト PC 上にコンテナ用のデータファイルを作成 し、コンテナ内の特定のディレクトリパスにマッピングします。 このデータファイルはポータビリティが高く、クラウド上に保存するということもできます（ボリュームドライバーが必要）。 複数のコンテナから 1 つのボリュームを共有することも可能です。 コンテナ内で作成したファイルの永続化には、このボリュームの使用が推奨されています。 バインドマウント ホスト PC の特定のディレクトリ（絶対パス指定） を、コンテナ内の特定のディレクトリパスにマッピングします。 ボリュームと比べてポータビリティが低いため、名前付きボリュームの使用が推奨されてます。例えば、バインドマウントでは、ホスト側の多数のファイルとマッピングされてしまうため別環境に移しにくいとか、マウント時のパス表現が OS に依存してしまうといった欠点があります。 ホスト側からコンテナで操作したファイルをささっと覗いて見たいときはバインドマウントは便利ですが、これはコンテナ内で作成した危険なファイルが、そのままホスト上にも作られてしまうということを示しています。 tmpfs マウント ホスト PC のメモリ領域 を、コンテナ内の特定のディレクトリパスにマッピングします。コンテナ上でファイル生成を行うと、実際には一時的なメモリ領域に保存されることになるので、ここに保存されたファイルはコンテナを停止すると消えてしまいます。一時的なファイルを格納するディレクトリを tmpfs マウントすることで、コンテナサイズの増加を防ぐことができ（書き込みレイヤーに出力されない）、パフォーマンスの向上を見込めます。 上記で、「ホスト PC」といっているのは Docker コンテナの実行環境のことであり、Windows や macOS で Docker Desktop を使用している場合は、正確には Linux VM のことを示します。</description></item><item><title>Android ビルド環境を構築するための Dockerfile</title><link>https://maku77.github.io/p/ao8p7n4/</link><pubDate>Thu, 02 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ao8p7n4/</guid><description>下記の Dockerfile を使うと、Ubuntu 14.04 あるいは、Ubuntu 12.04 をベースにした Android ビルド用の Docker イメージを作成することができます。
Dockerfile (Ubuntu 14.04) FROM ubuntu:14.04 # Set the proxies if needed. # ENV http_proxy http://proxy.example.com:10080/ # ENV https_proxy http://proxy.example.com:10080/ # Suppress errors on interactive installer ENV DEBIAN_FRONTEND noninteractive # To install i386 packages such as zlib1g-dev:i386 RUN dpkg --add-architecture i386 # The following is based on http://source.android.com/source/initializing.html # For installing openjdk-7-jdk, --no-install-recommends option has to be added # not to struggle with &amp;#39;colord&amp;#39; and &amp;#39;sgml-base&amp;#39; errors.</description></item><item><title>Docker チートシート／Docker コマンドの一覧</title><link>https://maku77.github.io/p/p4o6m3i/</link><pubDate>Thu, 02 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/p4o6m3i/</guid><description>Registry / Repository / Image / Tag の概念 図: Docker のコンテナレジストリ／リポジトリ／イメージ／タグの関係 DockerHub などのレジストリ上では、複数のリポジトリが管理されている。 Top-level リポジトリでは、ubuntu や devian といった有名どころなものが管理されている。 Top-level リポジトリ以外に、ユーザリポジトリがあり、こちらは &amp;lt;user&amp;gt;/ というプレフィックスが付く。 各リポジトリ内には複数のイメージがあり、イメージ ID やタグで指定できる。 1 つのイメージに対しては唯一の ID が付けられるが、タグは複数付けられていることがある。 docker image（イメージ関連のコマンド） コマンド 旧コマンド 説明 docker image build docker build Dockerfile からイメージをビルドする
Build an image from a Dockerfile docker image history docker history イメージのレイヤ構造を表示する
Show the history of an image docker image import docker import tar ファイルからファイルシステムイメージを作成する
Import the contents from a tarball to create a filesystem image docker image inspect docker inspect イメージの詳細を表示する</description></item><item><title>Docker で apt-get install するときに TERM 系のエラーが出る</title><link>https://maku77.github.io/p/3i2iygw/</link><pubDate>Thu, 02 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3i2iygw/</guid><description>docker image build などで apt-get install を実行中に、下記のようなエラーが出ることがあります。
debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline このような場合、Dockerfile で下記のように環境変数を設定してから apt-get するとエラーが出なくなります。
ENV DEBIAN_FRONTEND noninteractive あるいは、apt-get 実行時に下記のようにプレフィックスで設定することもできます。
DEBIAN_FRONTEND=noninteractive apt-get install -y ... DEBIAN_FRONTEND というのは、Debian Installer が使うフロントエンド (UI) を指定するもので、noninteractive にすることで、ユーザの入力を受け付けないインストールが可能になります。
参考: http://www.debian.org/releases/sarge/s390/ch05s02.html.ja</description></item><item><title>Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき</title><link>https://maku77.github.io/p/6g3j2iz/</link><pubDate>Thu, 02 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6g3j2iz/</guid><description>ubuntu:14.04 などのベースイメージに対して、zlib1g-dev:i386 などの i386 系のパッケージをインストールしようとしたときに下記のようなエラーがでることがあります。
E: Unable to locate package zlib1g-dev これを防ぐには、Dockerfile で下記のように実行するようにしておきます。
RUN dpkg --add-architecture i386</description></item><item><title>リポジトリ名のついていない Docker イメージをすべて削除する</title><link>https://maku77.github.io/p/oziyhxf/</link><pubDate>Thu, 02 Apr 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oziyhxf/</guid><description>普通に Docker コンテナ上で編集作業などを行っていると、Docker イメージのキャッシュがどんどん増えていってしまいます。
$ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 8a15692b92ea About an hour ago 1.077 GB &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 0bcfd9025fab About an hour ago 1.077 GB &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 4a0a98efbd7e About an hour ago 802.8 MB ... docker image ls コマンドの出力で、REPOSITORY 名が &amp;lt;none&amp;gt; になっているイメージをすべて削除するには、例えば以下のようにします。
$ sudo docker rmi $(docker images | awk &amp;#39;/^&amp;lt;none&amp;gt;/ {print $3}&amp;#39;) 参考: Docker のコンテナイメージを削除する (docker image rm/prune)</description></item><item><title>Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run)</title><link>https://maku77.github.io/p/y2biqx6/</link><pubDate>Sun, 15 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y2biqx6/</guid><description>コンテナイメージをダウンロードする (docker image pull) Docker でコンテナを作成するためには、ベースとなるイメージが必要です。 多くのイメージが Docker Hub に用意されているので、通常はここからベースとなるイメージを取得します。 ここでは、Ubuntu 20.04 のイメージをダウンロードしてみます。 docker image pull（旧: docker pull）コマンドに、ダウンロードしたいイメージ名 ubuntu と、バージョンを表すタグ 20.04 を指定してダウンロードします。 省略するとデフォルトタグとして、最新バージョンを表す lastest が使用されます。
イメージを取得する $ docker image pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:669e010b58baf5beb2836b253c1fd5768333f0d1dbcb834f7c07a4dc93f474be Status: Downloaded newer image for ubuntu:20.04 docker.io/library/ubuntu:20.04 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。
イメージの一覧を表示する $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB Docker イメージを削除したくなったときは、次のように docker image rm コマンド（旧: docker rmi ）で削除できます。</description></item><item><title>Docker イメージを Docker Hub に登録する (docker image push)</title><link>https://maku77.github.io/p/rwco2dp/</link><pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rwco2dp/</guid><description>作成した Docker イメージを Docker Hub リポジトリに登録すると、世界中のユーザがそのイメージを使えるようになります（プライベートにすることもできます）。 まずは、下記のサイトで、Docker Hub リポジトリのアカウントを作成しておく必要があります。
https://hub.docker.com アップロード予定の Docker イメージは、下記のように作成済みであるとします。
ローカルのイメージの一覧を確認 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/sample v1 8a6608d7d353 7 minutes ago 188.3 MB Docker イメージのアップロードには、docker image push コマンドを使用します。
レジストリにイメージをデプロイ $ docker image push maku77/sample:v1 ... （Docker Hub のログインパスワードなどを入力） ... Pushing tag for rev [8a6608d7d353] on {https://cdn-registry-1.docker.io/v1/repositories/maku77/sample/tags/v1} Docker Hub で公開されているイメージは、docker search コマンドで検索することができるので、たった今登録したイメージを検索してみます。
レジストリ上のイメージを検索 $ docker search maku77 NAME DESCRIPTION STARS OFFICIAL AUTOMATED maku77/sample 0 これで、任意の Docker ホストからこのイメージをダウンロードして使えるようになりました。</description></item><item><title>Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach)</title><link>https://maku77.github.io/p/y8cfimp/</link><pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y8cfimp/</guid><description>何をするか？ ここでは、Ubuntu の Docker イメージを使ってコンテナを起動し、その上で実行した bash シェルに接続して自由にコマンドを実行できるようにします。 docker container run、start、attach、exec など似たようなコマンドがたくさんありますが、用途はそれぞれ違うのでここでひととおり理解しておきましょう。
コマンド 意味 docker container run 「イメージの取得」「コンテナの作成」「コンテナの起動」を連続して行う docker container start 作成済みのコンテナを「起動」する docker container attach 動作しているコンテナに「接続」する docker container exec 動作しているコンテナで「プロセスを起動」する docker container run はコンテナの「作成」と「起動」 docker container run（旧: docker run）は、もっとも頻繁に紹介されているコマンドですが、内部で複数のことを行うので 一番分かりにくいコマンド かもしれません。 docker container run は次のようなことを一度に実行します。
指定したイメージがなければダウンロード (docker image pull) Docker コンテナを作成する (docker container create) Docker コンテナを起動する (docker container start) 例えば、次のコマンドを実行すると、Docker イメージ (ubuntu:20.04) のダウンロード、Docker コンテナ (mycon) の作成、そのコンテナの起動までを一気に実行します。
$ docker container run --name mycon -it ubuntu:20.</description></item><item><title>Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port)</title><link>https://maku77.github.io/p/ow258be/</link><pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ow258be/</guid><description>docker container port コマンドの使い方 docker container port（あるいは docker port）コマンドを使用すると、Docker コンテナの中で公開されているポート番号 (private port) が、ホスト側のどのポート番号にマッピングされているかを調べることができます。
$ docker container port &amp;lt;コンテナ名&amp;gt; [コンテナ側ポート番号] 例えば、my-nginx コンテナの中で Web サーバーが動作しているとして、それがホスト側から見てどのポート番号にマッピングされているかを調べるには以下のようにします。
$ docker container port my-nginx 80/tcp -&amp;gt; 0.0.0.0:8000 80/tcp -&amp;gt; :::8000 この例では、コンテナ側の 80 番ポートが、ホスト側の 8000 番ポートにマッピングされていることがわかります。 つまり、コンテナの Web サーバーには、http://localhost:8000 といったアドレスでアクセスできます。
特定の（コンテナ側の）ポート番号に関してだけ調べることもできます。 次の例では、コンテナ側の 80 番ポートに対して、ホスト側のどのポートがマッピングされているかを調べています。
$ docker container port my-nginx 80 0.0.0.0:8000 :::8000 （おまけ）nginx サーバーを立ち上げて実際に試してみる Alpine Linux をベースにした nginx サーバーのイメージ (nginx:alpine) はとても軽量（20MB くらい）なので、これを利用して、上記の docker container port コマンドを試してみます。
コンテナで nginx サーバーを起動するには次のように実行します。 ここでは、コンテナ名を my-nginx とし、ホスト側の 8000 番ポートとコンテナ側の 80 番ポートを結びつけています。</description></item><item><title>Docker のコンテナイメージを作成する (docker image build, docker container commit)</title><link>https://maku77.github.io/p/5j4k3iy/</link><pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5j4k3iy/</guid><description>2 つのイメージ作成方法 Docker イメージの作成方法には、大きく下記の 2 つの方法があります。
Dockerfile にイメージの作成手順を記載しておき、docker image build で作成 OS イメージをインタラクティブモードで起動し、各種設定を行った後に docker container commit で作成 再現性、ポータビリティといった観点から、Dockerfile を扱うアプローチが推奨されています。
docker image build アプローチ Dockerfile という、Docker イメージ作成のための手順書を作成しておくと、docker image build（あるいは docker build）コマンドを使って自動的にイメージを作成することができます。 下記は、Debian のイメージをベースにして、Python 3 をインストールしたイメージを作成する場合の Dockerfile の例です。
Dockerfile # Debian (Wheezy) のイメージをベースにする FROM debian:wheezy # コンテナ構築のためのコマンド実行 RUN apt-get -qq update &amp;amp;&amp;amp; apt-get -y install python3 この Dockerfile を元に Docker イメージを作成するには、下記のように docker image build を実行します。
コンテナイメージのビルド $ docker image build -t &amp;lt;イメージ名&amp;gt; &amp;lt;Dockerfileのあるディレクトリ&amp;gt; -t の後ろに指定するイメージ名は &amp;lt;user&amp;gt;/&amp;lt;repo&amp;gt;:&amp;lt;tag&amp;gt; という構成で指定します。 末尾のタグ名 (:&amp;lt;tag&amp;gt;) を省略すると、自動的に latest というタグが付けられます。 カレントディレクトリに Dockerfile ファイルがある場合は次のような感じでイメージをビルドします。</description></item><item><title>すべての Docker コンテナを停止／削除する (docker container stop/rm)</title><link>https://maku77.github.io/p/6ehmpsv/</link><pubDate>Thu, 12 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6ehmpsv/</guid><description>全コンテナを停止する すべての Docker コンテナをまとめて停止するには次のようにします。 これは、docker container ps -a -q コマンドですべてのコンテナ ID を取得できることを利用しているため、Linux や macOS 上でしか実行できません（Windows のコマンドプロンプトでは実行できません）。
すべての Docker コンテナを停止する $ docker container stop $(docker container ps -a -q) 全コンテナを削除する 同様に、次のようにすればすべての Docker コンテナを削除することができます。
すべての Docker コンテナを削除する $ docker container rm $(docker container ps -a -q) 動作中のコンテナも含めてすべて削除したいときは、docker contaier rm に -f オプションを付けて実行する必要があります。 ただし、これはとても危険なので注意して実行してください。</description></item><item><title>Docker コンテナの詳細情報を表示する (docker container inspect)</title><link>https://maku77.github.io/p/47hs3ck/</link><pubDate>Wed, 11 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/47hs3ck/</guid><description>docker container inspect（あるいは docker inspect）コマンドを使用すると、Docker コンテナの詳細情報を表示することができます。 その Docker コンテナがどのイメージをもとに作成されているのか、環境変数の設定はどうなっているのかなどを JSON 形式で出力してくれます。
$ docker container inspect my-container [ { &amp;#34;Id&amp;#34;: &amp;#34;ac2dc4e539f1bc7c273beb71d03536e83393d7f673d7ba67994569c75173b2a2&amp;#34;, &amp;#34;Created&amp;#34;: &amp;#34;2022-02-25T05:28:16.4553051Z&amp;#34;, &amp;#34;Path&amp;#34;: &amp;#34;/bin/bash&amp;#34;, &amp;#34;Args&amp;#34;: [], &amp;#34;State&amp;#34;: { &amp;#34;Status&amp;#34;: &amp;#34;exited&amp;#34;, &amp;#34;Running&amp;#34;: false, &amp;#34;Paused&amp;#34;: false, &amp;#34;Restarting&amp;#34;: false, &amp;#34;OOMKilled&amp;#34;: false, &amp;#34;Dead&amp;#34;: false, &amp;#34;Pid&amp;#34;: 0, &amp;#34;ExitCode&amp;#34;: 0, &amp;#34;Error&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;StartedAt&amp;#34;: &amp;#34;2022-02-25T05:29:17.5120196Z&amp;#34;, &amp;#34;FinishedAt&amp;#34;: &amp;#34;2022-02-25T05:29:22.1845301Z&amp;#34; }, &amp;#34;Image&amp;#34;: &amp;#34;sha256:54c9d81cbb440897908abdcaa98674db83444636c300170cfd211e40a66f704f&amp;#34;, ... } ]</description></item><item><title>Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs)</title><link>https://maku77.github.io/p/dmpsvz3/</link><pubDate>Wed, 11 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dmpsvz3/</guid><description>コンテナのバックグラウンド起動 (docker container run -d) Docker コンテナ内でプログラムが動作している状態をキープするには、何らかの終了しないプログラムを動かす必要があります（典型的には何らかのサーバープログラムです）。 ここでは、5 秒おきに HELLO と表示するプログラムを動かしてみます。 次のような簡単な bash プログラムです。
/bin/bash -c &amp;#39;while true; do echo HELLO; sleep 5; done&amp;#39; 上記のようなプログラムを、docker run コマンドで単純に Docker コンテナ内で動かすと、起動元の端末（の標準出力）に HELLO と表示され続けてしまいます。 そうではなくて、Docker コンテナ内に閉じて出力するには、docker run コマンドに -d (--detach) オプションを付けて実行します。
$ docker container run --rm -d --name mycon ubuntu:22.04 /bin/bash -c &amp;#39;while true; do echo HELLO; sleep 5; done&amp;#39; 57bf2e3edddf8dcc786ee42e9b2b5a1f50786d80bd45525afa21debcf108613b 引数の意味:
--rm … コンテナ停止時にコンテナを自動で削除します。 -d (--detach) … コンテナをバックグラウンドで動作させます。 --name mycon … コンテナに mycon という名前を付けます。 ubuntu:22.</description></item><item><title>Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top)</title><link>https://maku77.github.io/p/s3m4jyg/</link><pubDate>Wed, 11 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s3m4jyg/</guid><description>docker container top &amp;lt;コンテナ名&amp;gt; コマンドを実行すると、指定した Docker コンテナ内で現在動作しているプロセスを確認することができます（互換性維持のため、docker top コマンドも残されています）。
$ docker container top my-container PID USER COMMAND 854 root python app.py 855 root sleep 1 末尾に ps コマンドのオプションを指定して、出力内容をカスタマイズできます。 次の例では、-o pid,command と指定することで、出力するフィールドを PID と COMMAND のみにしています。
$ docker container top my-container -o pid,command PID COMMAND 2007 /usr/bin/qemu-x86_64 /usr/sbin/mysqld mysqld</description></item><item><title>Docker のプロキシ設定</title><link>https://maku77.github.io/p/w69cfim/</link><pubDate>Tue, 10 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w69cfim/</guid><description>Docker ホスト側のプロキシ設定 docker pull などで、Docker Hub リポジトリからイメージを取得するときにプロキシ接続が必要な場合は、Docker コンテナーではなく、Docker ホスト側のプロキシ設定を行う必要があります。 実際には、docker pull コマンドは、docker デーモンに対して命令を送っているだけなので、docker デーモンの方がプロキシ設定を認識する必要があります。 docker デーモンのプロキシ設定は、/etc/default/docker ファイルで行います。
/etc/default/docker（あるいは docker.io） export http_proxy=&amp;#34;http://proxy.example.com:3128/&amp;#34; 設定変更後は、docker デーモンを再起動すれば OK です。
$ sudo service docker.io restart これで、無事にプロキシ経由で docker pull できるようになります。
Docker コンテナ内で使用するプロキシ設定 Docker コンテナの中で、apt-get や curl などを使ったインターネットアクセスを行う場合は、Docker コンテナ側でプロキシの設定を行う必要があります。 docker run で Docker コンテナを起動するときに、-e オプションで http_proxy 環境変数 を渡して起動することができます。
$ sudo docker run -e http_proxy=http://proxy.example.com:8888/ -it debian:wheezy もちろん、Docker コンテナを起動したあとで、コンテナ上のシェルから環境変数を設定することもできます。
$ sudo docker run -it debian:wheezy root@7cb147891556:/# export http_proxy=http://proxy.example.com:8888/ root@7cb147891556:/# Docker イメージとして、必ず特定のプロキシを使うことが決まっているのであれば、Docker イメージを作成する際の Dockerfile にプロキシ設定を埋め込んでしまうこともできます。 このプロキシ設定は、Docker イメージを構築する際の、RUN コマンド (apt-get) にも効いてきます。</description></item><item><title>一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録）</title><link>https://maku77.github.io/p/an7o5m3/</link><pubDate>Tue, 10 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/an7o5m3/</guid><description>docker コマンドは、内部で socket を使って通信を行っており、一般ユーザからコマンドを実行すると、permission denied で怒られることがあります。
$ docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a 2015/03/10 22:50:19 Get http:///var/run/docker.sock/v1.12/version: dial unix //var/run/docker.sock: permission denied 上記の出力を見ると、var/run/docker.sock ファイルへのアクセス権限がないことが分かります。 このような場合は、次のいずれかの方法で docker コマンドを実行できるようになります。
sudo を付けて実行する ユーザーを docker グループに追加する sudo を付けて実行する方法 sudo をつけてスーパーユーザー権限で docker コマンドを実行する方法です。
$ sudo docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a Server version: 1.</description></item><item><title>Docker をインストールする (Docker Desktop / Docker Engine)</title><link>https://maku77.github.io/p/96o6n4j/</link><pubDate>Mon, 09 Mar 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/96o6n4j/</guid><description>Docker 実行環境のインストール Docker の実行環境（docker コマンド）をインストールするには、下記の公式マニュアルの手順に従ってください。 基本的に、Windows や macOS では Docker Desktop、Linux では Docker Engine をインストールすることになります。
https://docs.docker.com/get-docker/ 例: Windows の場合 (Docker Desktop) 例: macOS の場合 (Docker Desktop) 例: Ubuntu の場合 (Docker Engine) 例: Debian の場合 (Docker Engine) 例えば、Linux 環境では次のような感じで Docker Engine をインストールできます（詳細は上記の公式ページを参照してください）。
# インストール $ curl -sSL get.docker.com -o install.sh $ sh install.sh # Docker サービスを systemd で自動起動する設定 $ systemctl enable docker # Docker サービスを直ちに起動 $ systemctl start docker インストール手順を実行後、docker コマンドが使えるようになっていれば準備 OK です。</description></item></channel></rss>