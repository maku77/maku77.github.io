<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on 天才まくまくノート</title><link>https://maku77.github.io/js/</link><description>Recent content in JavaScript on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 01 Dec 2023 00:00:00 +0900</lastBuildDate><atom:link href="https://maku77.github.io/js/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript の yield を使ってイテレート可能な関数（ジェネレーター関数）を定義する</title><link>https://maku77.github.io/p/q3a7jg4/</link><pubDate>Wed, 13 Mar 2024 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/q3a7jg4/</guid><description>JavaScript の関数内で yield キーワードを使用すると、関数の呼び出し側でイテレート処理（ループ処理）が可能な関数を定義することができます。 値を生成する関数になるので、ジェネレーター関数 と呼ばれます。
☝️ ワンポイント yield キーワードは ES2015 (ECMAScript 6) で導入されました。 ジェネレーター関数の基本 下記は number 値を生成するジェネレーター関数の実装例です（TypeScript の型としては Generator を使います）。 ジェネレーター関数を定義するときは、function の代わりに function* を使います。
シンプルなジェネレーター関数 function* counter(): Generator&amp;lt;number&amp;gt; { yield 1; yield 2; yield 3; } ジェネレーター関数が生成する次の値を取得するには、next() メソッドを使用します。 next() メソッドは、value プロパティと done プロパティを持つ IteratorResult を返します。 すべての値の生成が終わると（ジェネレーター関数が return すると）、value プロパティの値は undefined になります。
const gen = counter(); console.log(gen.next().value); // 1 console.log(gen.next().value); // 2 console.log(gen.next().value); // 3 console.log(gen.next().value); // undefined ジェネレーター関数内の処理は、yield が実行されたタイミングで一時停止します。 呼び出し側で next() メソッドが呼び出されたときに実行が再開されます。</description></item><item><title>JavaScript で文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd)</title><link>https://maku77.github.io/p/buatano/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/buatano/</guid><description>padStart と padEnd の基本 JavaScript の String#padStart() および String#padEnd() メソッドを使うと、指定した文字数になるまで文字列を拡張してくれます。 どのような文字で埋め合わせるかは、第 2 引数で指定します。
左側にパディング const s = &amp;#34;ABC&amp;#34;; console.log(s.padStart(2, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padStart(3, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padStart(4, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;xABC&amp;#34; console.log(s.padStart(5, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;xxABC&amp;#34; console.log(s.padStart(6, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;xxxABC&amp;#34; 右側にパディング const s = &amp;#34;ABC&amp;#34;; console.log(s.padEnd(2, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padEnd(3, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padEnd(4, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABCx&amp;#34; console.log(s.padEnd(5, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABCxx&amp;#34; console.log(s.padEnd(6, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABCxxx&amp;#34; 第 2 引数に 2 文字以上の文字列を指定すると、各文字が順番に使われます。
const s = &amp;#34;ABC&amp;#34;; console.</description></item><item><title>JavaScript で文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec)</title><link>https://maku77.github.io/p/tvuztbm/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/tvuztbm/</guid><description>JavaScript の String オブジェクトの中で正規表現を利用できるメソッドとしては、search()、replace()、split() などがありますが、中でも強力なのは match() メソッドです。
String#match(regexp) メソッドを使用すると、指定した正規表現パターンに一致する部分を配列オブジェクトとして取得することができます。 一致する部分がひとつも見つからない場合は null を返します。 match メソッドは、パラメータとして渡す正規表現パターンで g フラグを指定した場合と指定しない場合で振る舞いが変化します。
match の正規表現パターンに g フラグを指定したとき String#match(regexp) の正規表現パターンで、g フラグを付加すると、戻り値はパターンに一致した部分文字列の配列 になります。
例: 数値部分だけを抽出して配列で取得する const text = &amp;#39;ABC 123 DEF 456 GHI 789 123ABC&amp;#39;; const arr = text.match(/\b\d+\b/g); if (arr != null) { console.log(arr); //=&amp;gt; [ &amp;#39;123&amp;#39;, &amp;#39;456&amp;#39;, &amp;#39;789&amp;#39; ] } match の正規表現パターンに g フラグを指定しなかったとき String#match(regexp) の正規表現パターンで g フラグを付加しない場合、RegExp#exec(string) を単発で呼び出した場合と同様の振る舞い をします。 具体的には、戻り値の配列の先頭には、パターンに一致した部分の全体が格納され、残りの配列要素（インデックス 1 以降）には、( と ) でグルーピングされたパターンに一致した部分文字列が順番に格納されます。
これを利用すると、特定のフォーマットに従った文字列から各パートの文字列を抽出するということが簡単に実現できます。</description></item><item><title>JavaScript で文字列の中から文字列を検索する (String#search, RegExp#test)</title><link>https://maku77.github.io/p/p5nx3n9/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/p5nx3n9/</guid><description>String#search による文字列検索 search の基本 String#search() メソッドを使用すると、正規表現パターンを使用して String オブジェクト内の文字列を検索することができます。 文字列が見つかった場合は、その先頭のインデックスを返し、見つからなかった場合は -1 を返します。 パラメータには RegExp オブジェクトを指定するか、次のように正規表現リテラルで検索パターンを指定します（単純な文字列を渡した場合は、内部で RegExp オブジェクトが生成されます）。
例: text の中から leader という文字列を検索 const text = &amp;#34;A leader is a dealer in hope.&amp;#34;; const index = text.search(/leader/); if (index == -1) { console.log(&amp;#34;見つかりませんでした&amp;#34;); } else { console.log(`位置 ${index} に見つかりました`); } 実行結果 位置 2 に見つかりました。 大文字と小文字を区別しない検索 String#search() メソッドのパラメータとして渡す正規表現の属性として i を指定すると、大文字と小文字を区別しない検索を行えます。
const index = text.search(/javascript/i); 上記のようにすると、JavaScript にも javascript にも JAVASCRIPT にも一致します。
コラム: グローバル検索はない String#search() メソッドは、最初に見つかった文字列のインデックスを返すため、次のように正規表現属性の g（グローバル検索）を指定しても無視されます（意味がありません）。</description></item><item><title>JavaScript で HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索</title><link>https://maku77.github.io/p/on7omgt/</link><pubDate>Sat, 06 Jan 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/on7omgt/</guid><description>タグ名で要素を取得する (getElementsByTagName) document.getElementsByTagName() 関数を使用すると、指定したタグ名を持つ要素を取得することができます。 同じタグ名を持つ要素は複数存在する可能性があるので、戻り値は配列になります。
例: p 要素をすべて取得する &amp;lt;p&amp;gt;こんにちは&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;おやすみ&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { const elems = document.getElementsByTagName(&amp;#34;p&amp;#34;); for (const e of elems) { console.log(e.innerText); } }; &amp;lt;/script&amp;gt; 実行結果 こんにちは おやすみ クラス名で要素を取得する (getElementsByClassName) document.getElementsByClassName() 関数を使用すると、指定したクラス名が class 属性に含まれている要素を取得することができます。 そのような要素は複数存在する可能性があるので、戻り値は配列になります。
&amp;lt;div class=&amp;#34;foo&amp;#34;&amp;gt;AAA&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;foo bar&amp;#34;&amp;gt;BBB&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;foo bar baz&amp;#34;&amp;gt;CCC&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { const elems = document.getElementsByClassName(&amp;#34;foo&amp;#34;); for (const e of elems) { console.log(e.innerText); } }; &amp;lt;/script&amp;gt; 実行結果 AAA BBB CCC ID で要素を取得する (getElementById) document.</description></item><item><title>ESLint で JavaScript コードの静的解析を行う</title><link>https://maku77.github.io/p/s8i5cr9/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/s8i5cr9/</guid><description>eslint コマンドのインストール ESLint のインストールは、Node.js の npm コマンドで簡単に行うことができます。
eslint のインストール $ npm install -g eslint インストールできたか確認します。
$ eslint --version v0.18.0 次のように .js ファイルを指定することで静的解析を実行できます。
sample.js の静的解析 $ eslint sample.js ESLint の設定ファイル ESLint の設定は、JSON 形式あるいは YAML 形式の .eslintrc ファイルで行います。 以下のような構成で、前提とする実行環境、参照可能なグローバルオブジェクト、適用する Lint ルールの設定、を記述していきます。
.eslintrc ファイルの構成 { &amp;#34;env&amp;#34;: { (1) 実行環境 }, &amp;#34;globals&amp;#34;: { (2) 参照するグローバルオブジェクト }, &amp;#34;rules&amp;#34;: { (3) Lint ルールの設定 } } Node モジュールとして作成する JS ファイルに対しては、package.json の中に ESLint の設定を記述してしまうことができます。 その場合は、下記のように、eslintConfig プロパティの中に同様の設定を記述します。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.</description></item><item><title>JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint)</title><link>https://maku77.github.io/p/ufcmoxr/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ufcmoxr/</guid><description>各ツールのトレンド 2015 年時点では JSHint が一番メジャーですが、これからは ESLint が主流になりそうです。 JSLint は使われなくなりつつあります。
図: JavaScript の静的解析ツールのトレンド それぞれのツールの特徴 JSLint https://jslint.com 初期リリースは 2007 年頃。 作者は Douglas Crockford で、著書に JavaScript Good Parts があり、JSON RFC4627 の仕様策定などを行っている人です。 後出の JSHint に比べると、デフォルトのチェックが厳しいです。 この厳しさは好き嫌いが分かれるところで、逆にチェックの緩い JSHint の方が好まれる理由にもなっています。
JSHint https://jshint.com 初期リリースは 2011 年頃。 作者は Anton Kovalyov（アントン・コバリャノフ）で、JSLint の fork として作られました。 ベースとなった JSLint は便利である一方で、作者 Douglas Crockford の頑固な設定（var 宣言は 1 つにまとめないと必ずエラーなど）が強制されるため、開発者から敬遠される部分が多くありました。 そこで、Anton は、より柔軟な設定を行える JSLint となることを目指して 2011 年に JSHint の開発を始めました。
JSLint と比べると、デフォルト設定におけるチェックが甘いため、有効活用するためには適切な設定を行う必要があります。 設定は JSON 形式のファイル (.jshintrc) で行えます。 JSHint は、インデントのスペース数などのコーディングスタイルに関するチェックを行うことは対象外とすることを決め、そういったチェックは JSCS を使ってくださいということになりました（そこまでやるのなら ESLint を使った方が楽かも）。</description></item><item><title>JSHint で JavaScript コードの静的解析を行う</title><link>https://maku77.github.io/p/y7o9g7a/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/y7o9g7a/</guid><description>JSHint は JavaScript の静的解析ツールのひとつです。 JSLint を元に作成されていますが、より柔軟な設定ができるようになっています。
JSHint のインストール JSHint は JSHint の Web サイト 上に直接コードを記述して実行することもできますが、通常は Node.js によるコマンドライン版（jshint コマンド）を使用します。 Node.js がインストールされている環境であれば、npm (Node Package Manager) コマンドを使用して簡単にインストールすることができます。
jshint のインストール $ npm install -g jshint Windows 7 の場合、上記のようにインストールしたパッケージは、以下のディレクトリに保存されるようなので、このディレクトリに PATH が通っていない場合はコントロールパネルから PATH に追記しておくようにします。
C:\Users\&amp;lt;UserName&amp;gt;\AppData\Roaming\npm\ インストールが終わったら、jshint コマンドが実行できるようになっているはずです。
jshint コマンドの実行 $ jshint --version jshint v2.6.3 JSHint の実行方法 実際に解析を行う場合は、以下のように .js ファイルを指定して実行します。
sample.js を jshint で解析 $ jshint sample.js sample.js: line 8, col 6, Missing semicolon. 1 error 問題が見つからなかった場合は、何も表示されません。</description></item><item><title>JSLint で JavaScript コードの静的解析を行う</title><link>https://maku77.github.io/p/os3jvi6/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/os3jvi6/</guid><description>jslist コマンドのインストール JSLint は Web サイト上 (https://jslint.com) でコードを張り付けて実行することができますが、普段の開発では jslint コマンドとして実行できるようにしておいた方が便利です。 多くのスクリプトエンジンによるラッパ実装がありますが、ここでは手軽な Node.js 版の node-jslist をインストールしてみます（あらかじめ Node.js をインストールして、npm コマンドを使えるようにしておく必要があります）。
jslint のインストール $ npm install -g jslint インストールが終わったら、動作確認します。
$ jslint --version node-jslint version: 0.9.0-pre006 JSLint edition 2013-08-26 使い方は簡単で、以下のように解析対象の .js ファイルを指定するだけです。
$ jslint sample.js $ jslint **/*.js # カレントディレクトリ以下の全ての JS ファイルに対して実行 グローバルな変数や関数を参照するときのエラーを抑制する jQuery の $ や、console、document などのグローバル変数（別のファイルで定義されている変数）を参照しようとすると、JSLint は未定義エラーと認識してしまいます。 グローバル変数を参照してもエラーにならないようにするには、global ディレクティブを使用します。 下記の例では、$ と console を参照できるようにしています。
/*global $: false, jQuery: false, console: false */ $(function () { &amp;#39;use strict&amp;#39;; console.</description></item><item><title>JavaScript のコーディングスタイル</title><link>https://maku77.github.io/p/pgw5j96/</link><pubDate>Mon, 19 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/pgw5j96/</guid><description>一般的に採用されている JavaScript のコーディングスタイルのまとめです。
記述フォーマット 一行の最大文字数は 79 文字（改行を入れて 80 文字） インデントはスペース 2 つ（複数行にまたがる時は、スペース 4 つにするか、前の行のドット等に合わせる） ファイルのエンコーディング形式は UTF-8、改行コードは LF (0x0A) ドキュメンテーションコメント ドキュメンテーションコメントは JSDoc で記述します。
/** * Find a person who has a specified nickname. * * @param {String} nickname - The nickname to be searched * @return {Person} A person if found, null if not found */ function findPerson(nickname) { // ... return person; } 命名規則 クラス: ClassName メソッド (public/protected) : methodName メソッド (private) : methodName_ プロパティ (public/protected): propName プロパティ (private): propName_ 変数: varName 定数: CONSTANT_NAME 省略形は先頭文字だけ大文字にします。</description></item><item><title>JavaScript は Strict モードを有効にすべし (ECMAScript 5)</title><link>https://maku77.github.io/p/bxrtpbp/</link><pubDate>Fri, 09 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/bxrtpbp/</guid><description>Strict Mode を有効にする ECMAScript 5 では、文法チェックを厳しくするための Strict Mode という機能が導入されています。
JavaScript コードの先頭行に、以下のように記述しておくと、Strict Mode が有効になります。 仮に、Strict Mode が使えない環境でこの行が記述されていても、単純に無視されるだけなので、常に記述しておくことをお勧めします。
スクリプト全体を Strict Mode で動かす &amp;#39;use strict&amp;#39;; 関数の中の先頭行で &amp;lsquo;use strict&amp;rsquo; と記述すると、その関数のみが Strict Mode で実行されます。
関数だけを Strict Mode で動かす function hoge() { &amp;#39;use strict&amp;#39;; ... } Strict Mode を有効にすると、例えば、未定義の変数を参照したときに ReferenceError が発生するようになります。
&amp;#39;use strict&amp;#39;; var num1 = 100; print(num1); // OK print(num2); // ReferenceError! Strict Mode のエラーが発生しない分かりにくい例 以下の例では、print(num) の時点で num が定義されていないので、一見 ReferenceError が発生しそうですが、同じスコープの中で num を定義している箇所があればエラーは発生しません。
sample.js &amp;#39;use strict&amp;#39;; print(num); // エラーは発生しない var num = 100; ただし、num を参照した時点では、値がまだ代入されていないので、undefined という値として参照されることになります。</description></item><item><title>JavaScript の 6 つの型</title><link>https://maku77.github.io/p/wur8gmp/</link><pubDate>Sun, 28 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wur8gmp/</guid><description>JavaScript is a &amp;ldquo;Loosely Typed Language&amp;rdquo; JavaScript は弱い型付け言語 (A Loosely Typed Language) です。 変数の宣言時に、型を指定する必要はありませんが、内部的には型情報を保持しています。
const s = &amp;#39;Hello World&amp;#39;; // 型指定はしていないが、内部的に文字列型として保持される print(typeof s); // =&amp;gt; string JavaScript の型は 6 種類 JavaScript の型には 5 つの基本型 (primitive value) と、プロパティを持つことができるオブジェクト型があります。 ようするに、全部で 6 つの型があります。
基本型 number（数値） &amp;ndash; 64 bit 浮動小数点数 string（文字列） boolean（真偽値） &amp;ndash; true or false null &amp;ndash; null だけが存在する型 undefined &amp;ndash; 未定義を表す オブジェクト型 5 つの基本型は、ECMAScript の仕様書では、primitive value と呼ばれています。 JavaScript には、C/C++ や Java 言語における char のような 1 文字を格納するための型は存在しないため、長さ 1 の string で代用することになります。 配列に関してはオブジェクト型（Array オブジェクト）に分類されています。 日付を表す Date などもすべてオブジェクト型です。</description></item><item><title>JavaScript で文字列をデリミタで分割する／1文字ずつに分割する (String#split)</title><link>https://maku77.github.io/p/dpp4v8n/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/dpp4v8n/</guid><description>JavaScript の文字列を任意の区切り文字で分割するには、split() メソッドを使用します。
カンマで文字列を分割する const s = &amp;#39; aaa, bbb, ccc &amp;#39;; const arr = s.split(&amp;#39;,&amp;#39;); // =&amp;gt; [&amp;#34; aaa&amp;#34;, &amp;#34; bbb&amp;#34;, &amp;#34; ccc &amp;#34;] 区切り文字列の前後の空白を削除したい場合は、以下のように正規表現で区切り文字を指定するとよいでしょう。
const s = &amp;#39; aaa, bbb, ccc &amp;#39;; const arr = s.split(/\s*,\s*/); // =&amp;gt; [&amp;#34; aaa&amp;#34;, &amp;#34;bbb&amp;#34;, &amp;#34;ccc &amp;#34;] 元のテキストの先頭や末尾にある空白が残ってしまっていることに注意してください。 これらを削除するには、以下のように最初に trim() で消してしまうのが早いです。
const s = &amp;#39; aaa, bbb, ccc &amp;#39;; const arr = s.trim().split(/\s*,\s*/); // =&amp;gt; [&amp;#34;aaa&amp;#34;, &amp;#34;bbb&amp;#34;, &amp;#34;ccc&amp;#34;] あるいは、以下のように分割した後の各文字列に対して trim() を実行するという方法もありますが、元の文字列に 1 回だけ trim() をかけた方が効率がよいでしょう。</description></item><item><title>JavaScript で文字列を置換する (String#replace, String#replaceAll)</title><link>https://maku77.github.io/p/8pnuzk4/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8pnuzk4/</guid><description>replace と replaceAll の基本 String#replace() メソッドを使用すると、String オブジェクト内のパターンに一致する文字列を置換することができます。
ABC を XXX に置換 const text = &amp;#39;ABC 123 ABC 123&amp;#39;; const s = text.replace(&amp;#39;ABC&amp;#39;, &amp;#39;XXX&amp;#39;); //=&amp;gt; &amp;#39;XXX 123 ABC 123&amp;#39; replace() メソッドは、自分自身のオブジェクトの内容を変更しないため、置換結果は戻り値として受け取る必要があることに注意してください。
また、デフォルトでは上記のように、最初に見つかった文字列だけ が置換されます。 パターンが複数箇所に一致した場合に、すべて置換するには、次のように String#replaceAll() メソッドを使用します（後述の正規表現パターンを使用する方法もあります）。
すべての ABC を XXX に置換 const text = &amp;#39;ABC 123 ABC 123&amp;#39;; const s = text.replaceAll(&amp;#39;ABC&amp;#39;, &amp;#39;XXX&amp;#39;); //=&amp;gt; &amp;#39;XXX 123 ABC 123&amp;#39; 正規表現パターンに一致する文字列を全て置換する String#replace() メソッドの第 1 引数には、正規表現パターンを渡すこともできます。 正規表現属性の g（グローバル検索）を付ければ、パターンに一致した部分すべてを一括置換することができます（replaceAll() ではなく、replace() ですべて置換できます）。
例: すべての ABC を XXX に置換 const text = &amp;#39;ABC 123 ABC 123&amp;#39;; const s = text.</description></item></channel></rss>