<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on 天才まくまくノート</title><link>https://maku77.github.io/js/</link><description>Recent content in JavaScript on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Fri, 01 Dec 2023 00:00:00 +0900</lastBuildDate><atom:link href="https://maku77.github.io/js/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript の yield を使ってイテレート可能な関数（ジェネレーター関数）を定義する</title><link>https://maku77.github.io/p/q3a7jg4/</link><pubDate>Wed, 13 Mar 2024 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/q3a7jg4/</guid><description>JavaScript の関数内で yield キーワードを使用すると、関数の呼び出し側でイテレート処理（ループ処理）が可能な関数を定義することができます。 値を生成する関数になるので、ジェネレーター関数 と呼ばれます。
☝️ ワンポイント yield キーワードは ES2015 (ECMAScript 6) で導入されました。 ジェネレーター関数の基本 下記は number 値を生成するジェネレーター関数の実装例です（TypeScript の型としては Generator を使います）。 ジェネレーター関数を定義するときは、function の代わりに function* を使います。
シンプルなジェネレーター関数 function* counter(): Generator&amp;lt;number&amp;gt; { yield 1; yield 2; yield 3; } ジェネレーター関数が生成する次の値を取得するには、next() メソッドを使用します。 next() メソッドは、value プロパティと done プロパティを持つ IteratorResult を返します。 すべての値の生成が終わると（ジェネレーター関数が return すると）、value プロパティの値は undefined になります。
const gen = counter(); console.log(gen.next().value); // 1 console.log(gen.next().value); // 2 console.log(gen.next().value); // 3 console.log(gen.next().value); // undefined ジェネレーター関数内の処理は、yield が実行されたタイミングで一時停止します。 呼び出し側で next() メソッドが呼び出されたときに実行が再開されます。</description></item><item><title>JavaScript で文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd)</title><link>https://maku77.github.io/p/buatano/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/buatano/</guid><description>padStart と padEnd の基本 JavaScript の String#padStart() および String#padEnd() メソッドを使うと、指定した文字数になるまで文字列を拡張してくれます。 どのような文字で埋め合わせるかは、第 2 引数で指定します。
左側にパディング const s = &amp;#34;ABC&amp;#34;; console.log(s.padStart(2, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padStart(3, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padStart(4, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;xABC&amp;#34; console.log(s.padStart(5, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;xxABC&amp;#34; console.log(s.padStart(6, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;xxxABC&amp;#34; 右側にパディング const s = &amp;#34;ABC&amp;#34;; console.log(s.padEnd(2, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padEnd(3, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABC&amp;#34; console.log(s.padEnd(4, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABCx&amp;#34; console.log(s.padEnd(5, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABCxx&amp;#34; console.log(s.padEnd(6, &amp;#34;x&amp;#34;)); //=&amp;gt; &amp;#34;ABCxxx&amp;#34; 第 2 引数に 2 文字以上の文字列を指定すると、各文字が順番に使われます。
const s = &amp;#34;ABC&amp;#34;; console.</description></item><item><title>JavaScriptメモ: 文字列内のひらがなとカタカナを変換する</title><link>https://maku77.github.io/p/ci73hgm/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ci73hgm/</guid><description>「ひらがな → カタカナ」の変換 次の関数 hiraToKata() は、渡された文字列内のすべてのひらがなをカタカナに変換します。
/** 文字列内のひらがなをカタカナに変換します。 */ function hiraToKata(str) { return str.replace(/[\u3041-\u3096]/g, ch =&amp;gt; String.fromCharCode(ch.charCodeAt(0) + 0x60) ); } // 使用例 console.log(hiraToKata(&amp;#39;あいうえおABC&amp;#39;)); //=&amp;gt; アイウエオABC console.log(hiraToKata(&amp;#39;アイウエオ123&amp;#39;)); //=&amp;gt; アイウエオ123 「カタカナ → ひらがな」の変換 次の関数 kataToHira() は、渡された文字列内のすべてのカタカナをひらがなに変換します。
/** 文字列内のカタカナをひらがなに変換します。 */ function kataToHira(str) { return str.replace(/[\u30A1-\u30FA]/g, ch =&amp;gt; String.fromCharCode(ch.charCodeAt(0) - 0x60) ); } console.log(kataToHira(&amp;#39;あいうえおABC&amp;#39;)); //=&amp;gt; あいうえおABC console.log(kataToHira(&amp;#39;アイウエオ123&amp;#39;)); //=&amp;gt; あいうえお123 解説 次のように、カタカナとひらがなの UTF-16 コードポイントの値を比較すると、0x60 だけずれていることが分かります。
const diff = &amp;#39;ア&amp;#39;.charCodeAt(0) - &amp;#39;あ&amp;#39;.charCodeAt(0); console.log(diff.toString(16)); //=&amp;gt; 60 この 0x60 という値を、ひらがなに足してやればカタカナに、カタカナから引いてやればひらがなに変換することができます。 ある文字が、ひらがな、あるいはカタカナであることを調べるには、次のような正規表現が使えます（ただし全角文字のみ）。</description></item><item><title>JavaScriptメモ: 文字列内に NG ワード（禁止語句）が含まれていないか調べる (RegExp#test)</title><link>https://maku77.github.io/p/fg35hk8/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fg35hk8/</guid><description>下記の記事の応用例ですが、
文字列の中から文字列を検索する (String#search, RegExp#test) ある文字列内に NG ワードが含まれているかを調べるには、正規表現クラス (RegExp) の test メソッドを使用して OR 検索すると簡単です。
// ユーザー入力が input 変数に含まれていると仮定 // var input = &amp;#39;あんたバカ？&amp;#39;; const NG_WORDS = /アホ|まぬけ|バカ/; if (NG_WORDS.test(input)) { console.log(&amp;#39;アホ言うやつがアホや！&amp;#39;); } ちなみに、正規表現リテラルのオプションとして i フラグを指定しておけば、大文字と小文字を区別しない比較が可能です。
const NG_WORDS = /fxxk/i; 参考: RegExp.prototype.test() - JavaScript｜MDN</description></item><item><title>JavaScriptメモ: 全角文字と半角文字を含んだ文字列を正規化して表記ゆれを吸収する (normalize)</title><link>https://maku77.github.io/p/7b6o87n/</link><pubDate>Mon, 08 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7b6o87n/</guid><description>String.prototype.normalize() - JavaScript｜MDN
String#normalize() のパラメータとして、NFKC（正規化形式 KC）を指定して文字列を正規化すると、ある文字列中に含まれる半角文字や全角文字を正規化して表現を統一することができます。 これを利用すると、テキスト検索などのプログラムにおける表記ゆれの問題を（ある程度）解決できます。
下記のサンプルコードでは、半角カタカナ（ｱｲｳｴｵ）と、全角アルファベット（ＡＢＣ）を normalize() を使って正規化しています。
const s1 = &amp;#39;ｱｲｳｴｵ&amp;#39;; const s2 = &amp;#39;ＡＢＣ&amp;#39;; console.log(`${s1} =&amp;gt; ${s1.normalize(&amp;#39;NFKC&amp;#39;)}`); console.log(`${s2} =&amp;gt; ${s2.normalize(&amp;#39;NFKC&amp;#39;)}`); 実行結果 ｱｲｳｴｵ =&amp;gt; アイウエオ ＡＢＣ =&amp;gt; ABC 半角カタカナは全角に、全角アルファベットは半角に変換されていることがわかります。
いろいろな正規化フォーマット String#normalize() では、下記のような Unicode 正規化フォーマットを指定できるようになっています。
'NFC' &amp;hellip; Normalize Format C: 正規化形式 C （デフォルト） 'NFD' &amp;hellip; Normalize Format D: 正規化形式 D 'NFKC' &amp;hellip; Normalize Format KC: 正規化形式 KC 'NFKD' &amp;hellip; Normalize Format KD: 正規化形式 KD 正規化フォーマットの詳細仕様に関しては下記を参照してください。
Unicode Standard Annex #15, Unicode Normalization Forms Unicode正規化 - Wikipedia 下記のようなサンプルコードで、それぞれの正規化フォーマットによる変換を試すことができます。</description></item><item><title>JavaScript で文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec)</title><link>https://maku77.github.io/p/tvuztbm/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/tvuztbm/</guid><description>JavaScript の String オブジェクトの中で正規表現を利用できるメソッドとしては、search()、replace()、split() などがありますが、中でも強力なのは match() メソッドです。
String#match(regexp) メソッドを使用すると、指定した正規表現パターンに一致する部分を配列オブジェクトとして取得することができます。 一致する部分がひとつも見つからない場合は null を返します。 match メソッドは、パラメータとして渡す正規表現パターンで g フラグを指定した場合と指定しない場合で振る舞いが変化します。
match の正規表現パターンに g フラグを指定したとき String#match(regexp) の正規表現パターンで、g フラグを付加すると、戻り値はパターンに一致した部分文字列の配列 になります。
例: 数値部分だけを抽出して配列で取得する const text = &amp;#39;ABC 123 DEF 456 GHI 789 123ABC&amp;#39;; const arr = text.match(/\b\d+\b/g); if (arr != null) { console.log(arr); //=&amp;gt; [ &amp;#39;123&amp;#39;, &amp;#39;456&amp;#39;, &amp;#39;789&amp;#39; ] } match の正規表現パターンに g フラグを指定しなかったとき String#match(regexp) の正規表現パターンで g フラグを付加しない場合、RegExp#exec(string) を単発で呼び出した場合と同様の振る舞い をします。 具体的には、戻り値の配列の先頭には、パターンに一致した部分の全体が格納され、残りの配列要素（インデックス 1 以降）には、( と ) でグルーピングされたパターンに一致した部分文字列が順番に格納されます。
これを利用すると、特定のフォーマットに従った文字列から各パートの文字列を抽出するということが簡単に実現できます。</description></item><item><title>JavaScript で文字列の中から文字列を検索する (String#search, RegExp#test)</title><link>https://maku77.github.io/p/p5nx3n9/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/p5nx3n9/</guid><description>String#search による文字列検索 search の基本 String#search() メソッドを使用すると、正規表現パターンを使用して String オブジェクト内の文字列を検索することができます。 文字列が見つかった場合は、その先頭のインデックスを返し、見つからなかった場合は -1 を返します。 パラメータには RegExp オブジェクトを指定するか、次のように正規表現リテラルで検索パターンを指定します（単純な文字列を渡した場合は、内部で RegExp オブジェクトが生成されます）。
例: text の中から leader という文字列を検索 const text = &amp;#34;A leader is a dealer in hope.&amp;#34;; const index = text.search(/leader/); if (index == -1) { console.log(&amp;#34;見つかりませんでした&amp;#34;); } else { console.log(`位置 ${index} に見つかりました`); } 実行結果 位置 2 に見つかりました。 大文字と小文字を区別しない検索 String#search() メソッドのパラメータとして渡す正規表現の属性として i を指定すると、大文字と小文字を区別しない検索を行えます。
const index = text.search(/javascript/i); 上記のようにすると、JavaScript にも javascript にも JAVASCRIPT にも一致します。
コラム: グローバル検索はない String#search() メソッドは、最初に見つかった文字列のインデックスを返すため、次のように正規表現属性の g（グローバル検索）を指定しても無視されます（意味がありません）。</description></item><item><title>JavaScriptメモ: 実数の小数点以下の切り上げ、切り捨て、整数への変換 (floor, ceil, round, toFixed)</title><link>https://maku77.github.io/p/92v7zx8/</link><pubDate>Thu, 17 May 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/92v7zx8/</guid><description>小数点以下を切り下げる (Math.floor) Math.floor は、指定した実数を上回らない最大の整数を返します。
Math.floor(3) //=&amp;gt; 3 Math.floor(3.1) //=&amp;gt; 3 Math.floor(-3) //=&amp;gt; -3 Math.floor(-3.1) //=&amp;gt; -4 小数点以下を切り上げる (Math.ceil) Math.ceil は、指定した実数を下回らない最小の整数を返します。
Math.ceil(3) //=&amp;gt; 3 Math.ceil(3.1) //=&amp;gt; 4 Math.ceil(-3) //=&amp;gt; -3 Math.ceil(-3.1) //=&amp;gt; -3 小数点以下を四捨五入する (Math.round) Math.round は、小数点以下を四捨五入した整数を返します。
Math.round(3) //=&amp;gt; 3 Math.round(3.1) //=&amp;gt; 3 Math.round(3.5) //=&amp;gt; 4 Math.round(3.7) //=&amp;gt; 4 負の値に対して実行した場合は、小数点以下が 0.5 の場合に切り上げになるので注意してください。 小数点以下が 0.5 に到達するたびに、大きい整数に切り上がると考えるとわかりやすいです。
Math.round(-3) //=&amp;gt; -3 Math.round(-3.1) //=&amp;gt; -3 Math.round(-3.5) //=&amp;gt; -3 （注意） Math.round(-3.6) //=&amp;gt; -4 小数点以下を削除する (parseInt) parseInt は、小数点以下を無視して整数値を返します。</description></item><item><title>JavaScript で HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索</title><link>https://maku77.github.io/p/on7omgt/</link><pubDate>Sat, 06 Jan 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/on7omgt/</guid><description>タグ名で要素を取得する (getElementsByTagName) document.getElementsByTagName() 関数を使用すると、指定したタグ名を持つ要素を取得することができます。 同じタグ名を持つ要素は複数存在する可能性があるので、戻り値は配列になります。
例: p 要素をすべて取得する &amp;lt;p&amp;gt;こんにちは&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;おやすみ&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { const elems = document.getElementsByTagName(&amp;#34;p&amp;#34;); for (const e of elems) { console.log(e.innerText); } }; &amp;lt;/script&amp;gt; 実行結果 こんにちは おやすみ クラス名で要素を取得する (getElementsByClassName) document.getElementsByClassName() 関数を使用すると、指定したクラス名が class 属性に含まれている要素を取得することができます。 そのような要素は複数存在する可能性があるので、戻り値は配列になります。
&amp;lt;div class=&amp;#34;foo&amp;#34;&amp;gt;AAA&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;foo bar&amp;#34;&amp;gt;BBB&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;foo bar baz&amp;#34;&amp;gt;CCC&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; window.onload = function() { const elems = document.getElementsByClassName(&amp;#34;foo&amp;#34;); for (const e of elems) { console.log(e.innerText); } }; &amp;lt;/script&amp;gt; 実行結果 AAA BBB CCC ID で要素を取得する (getElementById) document.</description></item><item><title>JavaScriptメモ: テンプレート文字列の機能で文字列リテラル内の変数を展開する (template literal)</title><link>https://maku77.github.io/p/p3fzkd7/</link><pubDate>Fri, 05 Jan 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/p3fzkd7/</guid><description>テンプレート文字列内で変数展開する 文字列を定義する時に、シングルクォートやダブルクォートの代わりに、バッククォート (`) で囲むと、その文字列リテラルはテンプレート文字列 (template literal) とみなされ、内部で変数や式の評価を行うことができるようになります。
テンプレート文字列内で式の評価を行いたい部分は、${ と } で囲みます。
const name = &amp;#39;Maku&amp;#39;; const msg = `I am ${name}`; //=&amp;gt; &amp;#39;I am Maku&amp;#39; 上記は単純な変数展開を行う例ですが、次のように内部で演算を行ったり、関数呼び出しを行ったりすることもできます。
const a = 1; const b = 2; const msg = `1 + 2 = ${a + b}`; //=&amp;gt; &amp;#39;1 + 2 = 3&amp;#39; 複数行に渡る文字列を定義する テンプレート文字列の定義の中で改行を行うことで、複数行に渡る文字列を定義することができます。 コード上で行った改行は、そのまま改行コードとして文字列の中に含められます。
const msg = `This is a long long long long long long long long long long text.`; console.</description></item><item><title>JavaScriptメモ: 文字列と数値を変換する</title><link>https://maku77.github.io/p/upvd655/</link><pubDate>Mon, 20 Mar 2017 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/upvd655/</guid><description>演算による数値と文字列の暗黙変換 JavaScript では文字列と数値の四則演算を行うと、暗黙的な型の変換が行われるようになっているため、通常は数値が必要な場所で文字列をそのまま使うことができます。 演算を行う場合は、基本的に数値に変換されて計算されるのですが、例外的に + 演算子だけは常に文字列同士の結合として扱われます。
文字列 &amp;#39;100&amp;#39; と数値の演算 console.log(&amp;#39;100&amp;#39; + 7); //=&amp;gt; &amp;#39;1007&amp;#39; (string) ★ここだけ文字列結合 console.log(&amp;#39;100&amp;#39; - 7); //=&amp;gt; 93 (number) console.log(&amp;#39;100&amp;#39; * 7); //=&amp;gt; 700 (number) console.log(&amp;#39;100&amp;#39; / 7); //=&amp;gt; 14.285714285714286 (number) console.log(&amp;#39;100&amp;#39; % 7); //=&amp;gt; 2 (number) 数値とみなせない文字列と数値を四則演算した場合は、NaN となります。 ただし、この場合も + 演算だけは文字列結合になります。
数値と数値とみなせない文字列 &amp;#39;30a&amp;#39; の演算 console.log(50 + &amp;#39;30a&amp;#39;); //=&amp;gt; &amp;#39;5030a&amp;#39; (string) ★ここだけ文字列結合 console.log(50 - &amp;#39;30a&amp;#39;); //=&amp;gt; NaN (number) console.log(50 * &amp;#39;30a&amp;#39;); //=&amp;gt; NaN (number) console.log(50 / &amp;#39;30a&amp;#39;); //=&amp;gt; NaN (number) console.</description></item><item><title>ESLint で JavaScript コードの静的解析を行う</title><link>https://maku77.github.io/p/s8i5cr9/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/s8i5cr9/</guid><description>eslint コマンドのインストール ESLint のインストールは、Node.js の npm コマンドで簡単に行うことができます。
eslint のインストール $ npm install -g eslint インストールできたか確認します。
$ eslint --version v0.18.0 次のように .js ファイルを指定することで静的解析を実行できます。
sample.js の静的解析 $ eslint sample.js ESLint の設定ファイル ESLint の設定は、JSON 形式あるいは YAML 形式の .eslintrc ファイルで行います。 以下のような構成で、前提とする実行環境、参照可能なグローバルオブジェクト、適用する Lint ルールの設定、を記述していきます。
.eslintrc ファイルの構成 { &amp;#34;env&amp;#34;: { (1) 実行環境 }, &amp;#34;globals&amp;#34;: { (2) 参照するグローバルオブジェクト }, &amp;#34;rules&amp;#34;: { (3) Lint ルールの設定 } } Node モジュールとして作成する JS ファイルに対しては、package.json の中に ESLint の設定を記述してしまうことができます。 その場合は、下記のように、eslintConfig プロパティの中に同様の設定を記述します。
package.json { &amp;#34;name&amp;#34;: &amp;#34;myapp&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.</description></item><item><title>JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint)</title><link>https://maku77.github.io/p/ufcmoxr/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ufcmoxr/</guid><description>各ツールのトレンド 2015 年時点では JSHint が一番メジャーですが、これからは ESLint が主流になりそうです。 JSLint は使われなくなりつつあります。
図: JavaScript の静的解析ツールのトレンド それぞれのツールの特徴 JSLint https://jslint.com 初期リリースは 2007 年頃。 作者は Douglas Crockford で、著書に JavaScript Good Parts があり、JSON RFC4627 の仕様策定などを行っている人です。 後出の JSHint に比べると、デフォルトのチェックが厳しいです。 この厳しさは好き嫌いが分かれるところで、逆にチェックの緩い JSHint の方が好まれる理由にもなっています。
JSHint https://jshint.com 初期リリースは 2011 年頃。 作者は Anton Kovalyov（アントン・コバリャノフ）で、JSLint の fork として作られました。 ベースとなった JSLint は便利である一方で、作者 Douglas Crockford の頑固な設定（var 宣言は 1 つにまとめないと必ずエラーなど）が強制されるため、開発者から敬遠される部分が多くありました。 そこで、Anton は、より柔軟な設定を行える JSLint となることを目指して 2011 年に JSHint の開発を始めました。
JSLint と比べると、デフォルト設定におけるチェックが甘いため、有効活用するためには適切な設定を行う必要があります。 設定は JSON 形式のファイル (.jshintrc) で行えます。 JSHint は、インデントのスペース数などのコーディングスタイルに関するチェックを行うことは対象外とすることを決め、そういったチェックは JSCS を使ってくださいということになりました（そこまでやるのなら ESLint を使った方が楽かも）。</description></item><item><title>JSHint で JavaScript コードの静的解析を行う</title><link>https://maku77.github.io/p/y7o9g7a/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/y7o9g7a/</guid><description>JSHint は JavaScript の静的解析ツールのひとつです。 JSLint を元に作成されていますが、より柔軟な設定ができるようになっています。
JSHint のインストール JSHint は JSHint の Web サイト 上に直接コードを記述して実行することもできますが、通常は Node.js によるコマンドライン版（jshint コマンド）を使用します。 Node.js がインストールされている環境であれば、npm (Node Package Manager) コマンドを使用して簡単にインストールすることができます。
jshint のインストール $ npm install -g jshint Windows 7 の場合、上記のようにインストールしたパッケージは、以下のディレクトリに保存されるようなので、このディレクトリに PATH が通っていない場合はコントロールパネルから PATH に追記しておくようにします。
C:\Users\&amp;lt;UserName&amp;gt;\AppData\Roaming\npm\ インストールが終わったら、jshint コマンドが実行できるようになっているはずです。
jshint コマンドの実行 $ jshint --version jshint v2.6.3 JSHint の実行方法 実際に解析を行う場合は、以下のように .js ファイルを指定して実行します。
sample.js を jshint で解析 $ jshint sample.js sample.js: line 8, col 6, Missing semicolon. 1 error 問題が見つからなかった場合は、何も表示されません。</description></item><item><title>JSLint で JavaScript コードの静的解析を行う</title><link>https://maku77.github.io/p/os3jvi6/</link><pubDate>Tue, 07 Apr 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/os3jvi6/</guid><description>jslist コマンドのインストール JSLint は Web サイト上 (https://jslint.com) でコードを張り付けて実行することができますが、普段の開発では jslint コマンドとして実行できるようにしておいた方が便利です。 多くのスクリプトエンジンによるラッパ実装がありますが、ここでは手軽な Node.js 版の node-jslist をインストールしてみます（あらかじめ Node.js をインストールして、npm コマンドを使えるようにしておく必要があります）。
jslint のインストール $ npm install -g jslint インストールが終わったら、動作確認します。
$ jslint --version node-jslint version: 0.9.0-pre006 JSLint edition 2013-08-26 使い方は簡単で、以下のように解析対象の .js ファイルを指定するだけです。
$ jslint sample.js $ jslint **/*.js # カレントディレクトリ以下の全ての JS ファイルに対して実行 グローバルな変数や関数を参照するときのエラーを抑制する jQuery の $ や、console、document などのグローバル変数（別のファイルで定義されている変数）を参照しようとすると、JSLint は未定義エラーと認識してしまいます。 グローバル変数を参照してもエラーにならないようにするには、global ディレクティブを使用します。 下記の例では、$ と console を参照できるようにしています。
/*global $: false, jQuery: false, console: false */ $(function () { &amp;#39;use strict&amp;#39;; console.</description></item><item><title>RequireJS の使い方メモ</title><link>https://maku77.github.io/p/nouqw33/</link><pubDate>Thu, 18 Jul 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/nouqw33/</guid><description>RequireJS を使うと、JavaScript のコードで、C/C++ の include のようなことができるようになります。 しかも、非同期にロードされるので、パフォーマンス上の利点もあります。
RequireJS で Hello World RequireJS 本体 (require.js) は下記サイトからダウンロードできます。
https://requirejs.org/docs/download.html ここでは、以下のようなディレクトリ構成でファイルを配置することにします。
index.html js/main.js js/vendor/require.js require.js を script 要素でロードするときに、data-main 属性の値として、任意の JavaScript ファイルを指定しておくと、require.js がロードされた後にその JavaScript ファイルを自動的に実行してくれます。 つまり、data-main で指定した JavaScript ファイルが、アプリケーションのエントリポイントとなります。
index.html &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;RequireJS Test&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello RequireJS&amp;lt;/h1&amp;gt; &amp;lt;script data-main=&amp;#34;js/main.js&amp;#34; src=&amp;#34;js/vendor/require.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; js/main.js require([], function() { alert(&amp;#39;Hello World&amp;#39;); }); 上記の index.html をブラウザで開くと js/main.js が自動的にロードされ、Hello World と表示されます。 エントリポイントとなる JavaScript ファイルには、require() を使って main 関数となる function を定義しておきます。 require() の第 1 引数には依存するモジュールを配列で指定できますが、今回は依存するモジュールはないので空にしてあります。</description></item><item><title>JavaScriptメモ: 文字列の先頭と末尾の空白を削除する (String#trim)</title><link>https://maku77.github.io/p/hpvmzdu/</link><pubDate>Fri, 12 Jul 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/hpvmzdu/</guid><description>ECMAScript 2015 以降では、String クラスの trim() メソッドを使って、文字列の先頭と末尾にある余計なスペース（空白やタブ、改行など）をすべて取り除くことができます。
JavaScript (ECMAScript 2015) の trim() を使う方法 &amp;#39; ABC &amp;#39;.trim(); //=&amp;gt; &amp;#39;ABC&amp;#39; jQuery の trim() を使う方法 jQuery には、ユーティリティ関数 jQuery.trim() が用意されていますが、ECMAScript 2015 で String クラスに trim() が標準装備されたので、もう出番はないでしょう。
$.trim(&amp;#39; ABC &amp;#39;); //=&amp;gt; &amp;#39;ABC&amp;#39; 自力で trim() 関数を実装する方法 下記の trim() 関数は、渡された文字列の先頭、末尾から空白、タブ、改行を削除して返します。
function trim(str) { return str.replace(/^\s+|\s+$/g, &amp;#39;&amp;#39;); } 下記のように使用できます。
const s = trim(&amp;#39; ABC &amp;#39;); //=&amp;gt; &amp;#39;ABC&amp;#39;</description></item><item><title>JavaScriptメモ: テンプレートを使ってテキストを生成する (Underscore.js)</title><link>https://maku77.github.io/p/gamk5vt/</link><pubDate>Wed, 05 Jun 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/gamk5vt/</guid><description>Underscore.js の template 関数を使う方法 Underscore.js の _.template() を使用すると、テンプレートテキストを利用した文字列生成を行うことができます。 _.template() の第一引数には、プレースホルダを含むテンプレートテキストを指定します。 テンプレートテキスト内に、
&amp;lt;%= プロパティ名 %&amp;gt; という文字列（プレースホルダ）を含めておくと、第二引数で渡したオブジェクトのプロパティ値がそこに展開されます。
&amp;lt;script src=&amp;#34;http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const template = &amp;#39;Hello &amp;lt;%= name %&amp;gt;&amp;#39;; const text = _.template(template, { name: &amp;#39;Makkuma&amp;#39; }); //=&amp;gt; &amp;#39;Hello Makkuma&amp;#39; &amp;lt;/script&amp;gt; テキストの展開時に、同時に HTML エスケープしたい場合は、&amp;lt;%= ... %&amp;gt; の代わりに、&amp;lt;%- ... %&amp;gt; を使用します。 Web サイトの HTML 要素を動的に構築するようなケースではこちらを使用するとよいでしょう。
const template = &amp;#39;Note: &amp;lt;%- value %&amp;gt;&amp;#39;; const data = { value: &amp;#39;&amp;lt;em&amp;gt; means emphasize&amp;#39; }; const text = _.template(template, data); //=&amp;gt; &amp;#39;Note: &amp;amp;lt;em&amp;amp;gt; means emphasize&amp;#39; テンプレートテキストを事前コンパイルして高速化 同じテンプレートテキストを何度も使用する場合は、第二引数を省略して _.</description></item><item><title>Backbone.jsの使い方メモ</title><link>https://maku77.github.io/p/wobqnsc/</link><pubDate>Sun, 10 Mar 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wobqnsc/</guid><description>Backbone.js の特徴 軽量（5KB くらい）な MVC ライブラリ。 MIT ライセンス。 DocumentClould の Jeremy Ashkenas 氏（CoffeeScript 作った人）によって作成。 Underscore.js が必須。他には jQuery などが必要（選択肢あり）。 SPI (Single Page Interface) の構築に最適。 使用実績: SoundCloud、DocumentCloud、Foursquare、LinkedIn Mobile、Pandora、Qiita。 js 使うための準備（backbone.js のロード） Backbone.js を使用するには、あらかじめ underscore.js や jQuery をロードしておく必要があります。
以下のサンプルでは、https://cdnjs.com から JS ファイルをロードしています。
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Backbone.js sample&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script src=&amp;#34;http://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.9.10/backbone-min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; $(function() { &amp;#39;use strict&amp;#39;; var MyModel = Backbone.Model.extend({ defaults: { name: &amp;#39;&amp;#39; } }); var model = new MyModel(); model.</description></item><item><title>JavaScriptメモ: ある処理を 1 秒間に何回実行できるかプロファイリングする</title><link>https://maku77.github.io/p/zy772in/</link><pubDate>Mon, 24 Dec 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/zy772in/</guid><description>瞬間的に終わってしまうような処理のパフォーマンスを調べるには、その処理を 1 回実行するのにかかった時間を調べるより、1 秒間に何回その処理を行えるかを調べた方が正確な結果が得られます。
const startTime = Date.now(); let timeElapsed = 0; let count = 0; while (timeElapsed &amp;lt; 1000) { // do something here timeElapsed = Date.now() - startTime; count++; } console.log(`${count} times per second`); 以下のような関数を用意しておけば、ある関数が 1 秒間に何度実行できるかを簡単に調べることができます。
function howManyTimes(func) { const startTime = Date.now(); let timeElapsed = 0; let count = 0; while (timeElapsed &amp;lt; 1000) { func(); timeElapsed = Date.now() - startTime; count++; } return count; } 以下のように使います。</description></item><item><title>JavaScript のコーディングスタイル</title><link>https://maku77.github.io/p/pgw5j96/</link><pubDate>Mon, 19 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/pgw5j96/</guid><description>一般的に採用されている JavaScript のコーディングスタイルのまとめです。
記述フォーマット 一行の最大文字数は 79 文字（改行を入れて 80 文字） インデントはスペース 2 つ（複数行にまたがる時は、スペース 4 つにするか、前の行のドット等に合わせる） ファイルのエンコーディング形式は UTF-8、改行コードは LF (0x0A) ドキュメンテーションコメント ドキュメンテーションコメントは JSDoc で記述します。
/** * Find a person who has a specified nickname. * * @param {String} nickname - The nickname to be searched * @return {Person} A person if found, null if not found */ function findPerson(nickname) { // ... return person; } 命名規則 クラス: ClassName メソッド (public/protected) : methodName メソッド (private) : methodName_ プロパティ (public/protected): propName プロパティ (private): propName_ 変数: varName 定数: CONSTANT_NAME 省略形は先頭文字だけ大文字にします。</description></item><item><title>JavaScript は Strict モードを有効にすべし (ECMAScript 5)</title><link>https://maku77.github.io/p/bxrtpbp/</link><pubDate>Fri, 09 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/bxrtpbp/</guid><description>Strict Mode を有効にする ECMAScript 5 では、文法チェックを厳しくするための Strict Mode という機能が導入されています。
JavaScript コードの先頭行に、以下のように記述しておくと、Strict Mode が有効になります。 仮に、Strict Mode が使えない環境でこの行が記述されていても、単純に無視されるだけなので、常に記述しておくことをお勧めします。
スクリプト全体を Strict Mode で動かす &amp;#39;use strict&amp;#39;; 関数の中の先頭行で &amp;lsquo;use strict&amp;rsquo; と記述すると、その関数のみが Strict Mode で実行されます。
関数だけを Strict Mode で動かす function hoge() { &amp;#39;use strict&amp;#39;; ... } Strict Mode を有効にすると、例えば、未定義の変数を参照したときに ReferenceError が発生するようになります。
&amp;#39;use strict&amp;#39;; var num1 = 100; print(num1); // OK print(num2); // ReferenceError! Strict Mode のエラーが発生しない分かりにくい例 以下の例では、print(num) の時点で num が定義されていないので、一見 ReferenceError が発生しそうですが、同じスコープの中で num を定義している箇所があればエラーは発生しません。
sample.js &amp;#39;use strict&amp;#39;; print(num); // エラーは発生しない var num = 100; ただし、num を参照した時点では、値がまだ代入されていないので、undefined という値として参照されることになります。</description></item><item><title>JavaScript の 6 つの型</title><link>https://maku77.github.io/p/wur8gmp/</link><pubDate>Sun, 28 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wur8gmp/</guid><description>JavaScript is a &amp;ldquo;Loosely Typed Language&amp;rdquo; JavaScript は弱い型付け言語 (A Loosely Typed Language) です。 変数の宣言時に、型を指定する必要はありませんが、内部的には型情報を保持しています。
const s = &amp;#39;Hello World&amp;#39;; // 型指定はしていないが、内部的に文字列型として保持される print(typeof s); // =&amp;gt; string JavaScript の型は 6 種類 JavaScript の型には 5 つの基本型 (primitive value) と、プロパティを持つことができるオブジェクト型があります。 ようするに、全部で 6 つの型があります。
基本型 number（数値） &amp;ndash; 64 bit 浮動小数点数 string（文字列） boolean（真偽値） &amp;ndash; true or false null &amp;ndash; null だけが存在する型 undefined &amp;ndash; 未定義を表す オブジェクト型 5 つの基本型は、ECMAScript の仕様書では、primitive value と呼ばれています。 JavaScript には、C/C++ や Java 言語における char のような 1 文字を格納するための型は存在しないため、長さ 1 の string で代用することになります。 配列に関してはオブジェクト型（Array オブジェクト）に分類されています。 日付を表す Date などもすべてオブジェクト型です。</description></item><item><title>JavaScriptメモ: 文字列内の１文字を取得する／１文字ずつループ処理する (charAt)</title><link>https://maku77.github.io/p/sbc3jzk/</link><pubDate>Fri, 26 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/sbc3jzk/</guid><description>文字列内の１文字を取得する ECMAScript の仕様に従うのであれば、文字列内の任意の位置の文字を取得するには charAt() を使用します。
const s = &amp;#39;ABCDE&amp;#39;; console.log(s.charAt(2)); //=&amp;gt; &amp;#39;C&amp;#39; ただ、JavaScript の独自拡張では、以下のように数値プロパティで任意の位置の文字を取り出せますので、環境依存のコードでもよいのであれば、こちらのシンプルな方法もありです。
console.log(s[2]); //=&amp;gt; &amp;#39;C&amp;#39; １文字ずつループ処理する 文字列の長さだけ for ループを回せば、文字列内の文字を１文字ずつ処理することができます。
const s = &amp;#39;ABCDE&amp;#39;; for (let i = 0; i &amp;lt; s.length; ++i) { console.log(`${i + 1}文字目: ${s.charAt(i)}`); } 実行結果 1文字目: A 2文字目: B 3文字目: C 4文字目: D 5文字目: E split メソッドで１文字ずつの配列に分割してしまってから、その配列をループ処理するという方法もありますね。
const s = &amp;#39;ABCDE&amp;#39;; const arr = s.split(&amp;#39;&amp;#39;); for (let i = 0; i &amp;lt; arr.length; ++i) { console.</description></item><item><title>JavaScriptメモ: 文字列を大小比較すると何が起こるか</title><link>https://maku77.github.io/p/iakd4aw/</link><pubDate>Wed, 24 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/iakd4aw/</guid><description>文字列同士を &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;= などで大小比較すると、Unicode のコードポイントベースで大小比較されます。
console.log(50 &amp;gt; 100); // false console.log(&amp;#39;50&amp;#39; &amp;gt; &amp;#39;100&amp;#39;); // true !! '5' という文字のコードポイントは '1' という文字のコードポイントより大きいので、結果的に '50' という文字列は '100' より大きいと判断されます。 数値の比較にはならないことに注意してください。</description></item><item><title>JavaScriptメモ: == と === による文字列比較の違い</title><link>https://maku77.github.io/p/squitgq/</link><pubDate>Mon, 22 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/squitgq/</guid><description>JavaScript における文字列の比較には、== あるいは === (strict equal) 演算子が使用できます。
const str1 = &amp;#39;ABC&amp;#39;; const str2 = &amp;#39;AB&amp;#39; + &amp;#39;C&amp;#39;; console.log(str1 == str2); //=&amp;gt; true console.log(str1 === str2); //=&amp;gt; true 文字列と数値の比較 文字列値 (string) 同士の比較であれば、上記のように差は出ませんが、== を使用した比較は、型変換を行ってから比較を行うため、異なる型同士の比較をした場合に差が出てきます。
const num = 100; const str = &amp;#39;100&amp;#39;; console.log(num == str); //=&amp;gt; true （型変換してから比較するため一致） console.log(num === str); //=&amp;gt; false（型が異なるので必ず false） console.log(num != str); //=&amp;gt; false console.log(num !== str); //=&amp;gt; true 型変換が伴うと、分かりにくい結果になりやすいので、できる限り === (strict equal) による比較を行うことをお勧めします。
console.log(123 == &amp;#39;ABC123&amp;#39;); //=&amp;gt; false console.</description></item><item><title>JavaScriptメモ: デバッグ出力用の print 関数の統一について</title><link>https://maku77.github.io/p/r5vogb3/</link><pubDate>Mon, 22 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r5vogb3/</guid><description>JavaScript には、コア言語機能として文字列をデバッグ出力する print() のような関数が存在しないため、それぞれの環境で出力方法を切り替える必要があります。
Rhino (jrunscript) の場合 js&amp;gt; print(&amp;#39;Hello\n&amp;#39;); Rhino (jrunscript) の環境では、標準で print() 関数が使用できます。
Web ブラウザの場合 alert(&amp;#39;Hello&amp;#39;); document.write(&amp;#39;Hello&amp;#39;); Node.js、Chrome の JavaScript Console、FireFox の FireBug の場合 console.log(&amp;#39;Hello&amp;#39;);</description></item><item><title>JavaScriptメモ: 文字列と文字列、数値を結合する</title><link>https://maku77.github.io/p/egfww25/</link><pubDate>Sun, 21 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/egfww25/</guid><description>文字列同士の結合 JavaScript の文字列は、+ 演算子で結合できます。単項演算子の += も使えます。
let s1 = &amp;#39;AAA&amp;#39; + &amp;#39;BBB&amp;#39;; s1 += &amp;#39;CCC&amp;#39;; console.log(s1); //=&amp;gt; AAABBBCCC 文字列と数値の結合 文字列と数値を + 演算子で結合すると、文字列として結合されます。
const val = 100 + &amp;#39;200&amp;#39;; console.log(val); //=&amp;gt; 100200 console.log(typeof val); //=&amp;gt; string これを利用したイディオムとして、次のように数値を文字列に変換する方法があります。
const num = 100; const str = num + &amp;#39;&amp;#39;; console.log(typeof str); //=&amp;gt; string</description></item><item><title>JavaScriptメモ: new String は避ける</title><link>https://maku77.github.io/p/is2iir3/</link><pubDate>Sat, 20 Oct 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/is2iir3/</guid><description>JavaScript の文字列リテラル シングルクォートあるいは、ダブルクォートで囲んだ文字列リテラルから、文字列値を生成することができます。 JavaScript の文字列変数は、基本的にこの形で生成すべきです。
const s1 = &amp;#39;xxx&amp;#39;; const s2 = &amp;#34;yyy&amp;#34;; console.log(typeof(s1)); // &amp;#34;string&amp;#34; console.log(typeof(s2)); // &amp;#34;string&amp;#34; シングルクォートとダブルクォートのどちらで囲むかによっては違いは出ませんが、例えばダブルクォートで囲んだ場合は、内部にエスケープなしでシングルクォート文字を含められます。
const s1 = &amp;#39;That\&amp;#39;s great!&amp;#39;; const s2 = &amp;#34;That&amp;#39;s great!&amp;#34;; 文字列を new String で作成するのは避ける 文字列を new String で作成すると、文字列の同値比較ができなくなってしまうので、文字列は必ず文字列リテラルで生成するようにすべきです。 これは、new String で生成した値の型が、string ではなく object 型になってしまうことが原因です。
object 同士の比較は false になる const s1 = new String(&amp;#39;ABC&amp;#39;); const s2 = new String(&amp;#39;ABC&amp;#39;); console.log(s1 == s2); //=&amp;gt; false console.log(s1 === s2); //=&amp;gt; false object と string の比較は == の場合のみ true になる const s1 = &amp;#39;ABC&amp;#39;; const s2 = new String(&amp;#39;ABC&amp;#39;); console.</description></item><item><title>JavaScript で文字列をデリミタで分割する／1文字ずつに分割する (String#split)</title><link>https://maku77.github.io/p/dpp4v8n/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/dpp4v8n/</guid><description>JavaScript の文字列を任意の区切り文字で分割するには、split() メソッドを使用します。
カンマで文字列を分割する const s = &amp;#39; aaa, bbb, ccc &amp;#39;; const arr = s.split(&amp;#39;,&amp;#39;); // =&amp;gt; [&amp;#34; aaa&amp;#34;, &amp;#34; bbb&amp;#34;, &amp;#34; ccc &amp;#34;] 区切り文字列の前後の空白を削除したい場合は、以下のように正規表現で区切り文字を指定するとよいでしょう。
const s = &amp;#39; aaa, bbb, ccc &amp;#39;; const arr = s.split(/\s*,\s*/); // =&amp;gt; [&amp;#34; aaa&amp;#34;, &amp;#34;bbb&amp;#34;, &amp;#34;ccc &amp;#34;] 元のテキストの先頭や末尾にある空白が残ってしまっていることに注意してください。 これらを削除するには、以下のように最初に trim() で消してしまうのが早いです。
const s = &amp;#39; aaa, bbb, ccc &amp;#39;; const arr = s.trim().split(/\s*,\s*/); // =&amp;gt; [&amp;#34;aaa&amp;#34;, &amp;#34;bbb&amp;#34;, &amp;#34;ccc&amp;#34;] あるいは、以下のように分割した後の各文字列に対して trim() を実行するという方法もありますが、元の文字列に 1 回だけ trim() をかけた方が効率がよいでしょう。</description></item><item><title>JavaScript で文字列を置換する (String#replace, String#replaceAll)</title><link>https://maku77.github.io/p/8pnuzk4/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8pnuzk4/</guid><description>replace と replaceAll の基本 String#replace() メソッドを使用すると、String オブジェクト内のパターンに一致する文字列を置換することができます。
ABC を XXX に置換 const text = &amp;#39;ABC 123 ABC 123&amp;#39;; const s = text.replace(&amp;#39;ABC&amp;#39;, &amp;#39;XXX&amp;#39;); //=&amp;gt; &amp;#39;XXX 123 ABC 123&amp;#39; replace() メソッドは、自分自身のオブジェクトの内容を変更しないため、置換結果は戻り値として受け取る必要があることに注意してください。
また、デフォルトでは上記のように、最初に見つかった文字列だけ が置換されます。 パターンが複数箇所に一致した場合に、すべて置換するには、次のように String#replaceAll() メソッドを使用します（後述の正規表現パターンを使用する方法もあります）。
すべての ABC を XXX に置換 const text = &amp;#39;ABC 123 ABC 123&amp;#39;; const s = text.replaceAll(&amp;#39;ABC&amp;#39;, &amp;#39;XXX&amp;#39;); //=&amp;gt; &amp;#39;XXX 123 ABC 123&amp;#39; 正規表現パターンに一致する文字列を全て置換する String#replace() メソッドの第 1 引数には、正規表現パターンを渡すこともできます。 正規表現属性の g（グローバル検索）を付ければ、パターンに一致した部分すべてを一括置換することができます（replaceAll() ではなく、replace() ですべて置換できます）。
例: すべての ABC を XXX に置換 const text = &amp;#39;ABC 123 ABC 123&amp;#39;; const s = text.</description></item><item><title>JavaScriptメモ: 文字列の小文字と大文字を変換する (toLowerCase, toUpperCase)</title><link>https://maku77.github.io/p/xbyztsb/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/xbyztsb/</guid><description>String オブジェクトの toLowerCase() 関数、toUpperCase() 関数を使用すると、文字列全体を小文字、大文字に変換することができます。
let s = &amp;#34;Hello World&amp;#34;; console.log(s.toLowerCase()); // &amp;#34;hello world&amp;#34; console.log(s.toUpperCase()); // &amp;#34;HELLO WORLD&amp;#34; console.log(s); // &amp;#34;Hello World&amp;#34; あくまで変換後の結果が戻り値として返されるだけで、元の文字列は変更されないことに注意してください。 同じ変数で、変換後の文字列を参照したい場合は、次のように代入する必要があります。
let s = &amp;#34;Hello World&amp;#34;; s = s.toUpperCase(); // 変換後の文字列を代入</description></item><item><title>JavaScriptメモ: 文字列の長さを取得する</title><link>https://maku77.github.io/p/f9anam8/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/f9anam8/</guid><description>文字列の長さを調べるには、length プロパティを参照します。 マルチバイト文字も 1 文字としてカウントします。
const a = &amp;#39;ABCDE&amp;#39;; console.log(a.length); // =&amp;gt; 5 const b = &amp;#39;あいうえお&amp;#39;; console.log(b.length); // =&amp;gt; 5</description></item><item><title>JavaScriptメモ: 部分文字列を取得する (substring, slice)</title><link>https://maku77.github.io/p/tkd8fi2/</link><pubDate>Fri, 20 Jan 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/tkd8fi2/</guid><description>n 文字目から m 文字目までの部分文字列を取得する substring() メソッド（あるいは slice() メソッド）を使用すると、文字列から位置を指定して部分文字列を抽出することができます。
const s = &amp;#39;ABCDEFGHIJ&amp;#39;; console.log(s.substring(5)); // &amp;#39;FGHIJ&amp;#39; （５文字目以降） console.log(s.slice(5)); // &amp;#39;FGHIJ&amp;#39; （５文字目以降） console.log(s.substring(5, 8)); // &amp;#39;FGH&amp;#39; （５文字目から８文字目） console.log(s.slice(5, 8)); // &amp;#39;FGH&amp;#39; （５文字目から８文字目） 後ろから n 文字の部分文字列を取得する 上記のように 0 以上のインデックスを指定した場合は、substring() も slice() も同様に振る舞いますが、負のインデックスを指定した場合は動作が異なります。 substring() の場合は、0 を指定したのと同様に振る舞うため、文字列の先頭を指定したことになります。 slice() の場合は、例えば -3 と指定すれば、末尾から３文字目を指定したことになります。
const s = &amp;#39;ABCDEFGHIJ&amp;#39;; console.log(s.substring(-3)); // &amp;#39;ABCDEFGHIJ&amp;#39;（負の値は０を指定したのと同じ） console.log(s.slice(-3)); // &amp;#39;HIJ&amp;#39; （末尾の３文字）</description></item></channel></rss>