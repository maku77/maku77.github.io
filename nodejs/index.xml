<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Node.js on 天才まくまくノート</title><link>https://maku77.github.io/nodejs/</link><description>Recent content in Node.js on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 25 Jan 2024 00:00:00 +0900</lastBuildDate><atom:link href="https://maku77.github.io/nodejs/index.xml" rel="self" type="application/rss+xml"/><item><title>corepack を使ってプロジェクト内で使用する pnpm/yarn のバージョンを管理する</title><link>https://maku77.github.io/p/tzwio3y/</link><pubDate>Thu, 25 Jan 2024 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/tzwio3y/</guid><description>corepack とは Node.js の実行環境には、パッケージマネージャーとして標準で npm コマンドが搭載されていますが、npm の代わりに yarn や pnpm などを導入しているプロジェクトが多くあります。 従来は、これらのコマンドを npm install -g pnpm のように別途インストールする必要がありましたが、Node.js に標準搭載された corepack の仕組みを使用すると、はじめからインストールされているかのように yarn や pnpm コマンドを実行できるようになります。
corepack が使用するパッケージマネージャーは、package.json の packageManager プロパティで宣言しておくことができるので、プロジェクト内で使用するパッケージマネージャーとそのバージョンを統一できます。
☝️ ワンポイント package.json の packageManager フィールドはプロジェクトが使うパッケージマネージャーとそのバージョンを宣言しているだけで、このフィールドは corepack 専用のフィールドというわけではありません。 あくまで、システムの Node.js 環境で corepack が有効化されている場合に、このフィールドの内容に基づいて yarn や pnpm のバージョンが自動制御される、ということです。 最初の準備（既存の yarn/pnpm の削除と corepack の有効化） もし、npm install や brew でグローバルインストールした yarn や pnpm がある場合は、もう必要ないのでアンインストールしておきましょう。
不要な yarn や pnpm はアンインストール $ npm uninstall -g yarn $ npm uninstall -g pnpm $ brew uninstall yarn $ brew uninstall pnpm corepack コマンドは Node.</description></item><item><title>nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager)</title><link>https://maku77.github.io/p/3x95seb/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/3x95seb/</guid><description>nvm (Node Version Manager) とは？ nvm というコマンドラインツールを使うと、システム内に複数バージョンの Node.js 実行環境をインストールして、切り替えて使うことができるようになります。 nvm 実行のために、あらかじめ Node.js をインストールしておく必要はありません。
$ nvm use 16 # node コマンドを version 16.x.x に切り替え（必要に応じてインストール） $ nvm use 14 # node コマンドを version 14.x.x に切り替え（必要に応じてインストール） 上記のように node コマンドのバージョンを簡単に切り替えることができるため、新しいバージョンの Node.js を試してみたいときや、複数バージョンでテストを行いたい場合に便利です。 nvm はスタンドアローン版の Node.js とも共存できるので、安心してインストールすることができます。 nvm を使わずにインストールされた Node.js は、system という名前で参照できるようになっています。
$ nvm use system # node コマンドをスタンドアローン版に切り替え nvm のインストール nvm コマンドは次のように簡単にインストールできます。
macOS や Linux の場合 macOS や Linux の場合 $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 最新バージョンのインストール方法は nvm-sh/nvm - GitHub の公式サイトで確認してください。 インストール後は、ターミナル（bash など）を再起動するか、source ~/.</description></item><item><title>Node.jsメモ: node-fetch モジュールを使用して HTTP 通信を行う</title><link>https://maku77.github.io/p/6hndyxs/</link><pubDate>Mon, 17 Aug 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6hndyxs/</guid><description>node-fetch とは node-fetch モジュールは、Node.js アプリで Web ブラウザと同様の fetch 関数を扱えるようにするためのライブラリです。 これを使うと、Promise ベースの HTTP 通信を行うことができます。
node-fetch - npm 2020 年 2 月に HTTP 通信モジュールのデファクトスタンダードであった request モジュールやそれに依存する request-promise モジュールが非推奨（deprecated）になってしまったため、代わりの HTTP 通信モジュールが必要です。 代替モジュールとしては axios なども人気がありますが、node-fetch モジュールであれば、Web ブラウザの JavaScript から使える fetch 関数と同じ感覚で使えるため、API の使用方法を新しく学ぶ手間が省けます。
node-fetch のインストール node-fetch は次のようにインストールできます。 コンパクトなモジュールなので、インストールは一瞬で終わります。
$ npm install node-fetch --save node-fetch を使用する 次のサンプルコードは、node-fetch が提供する fetch 関数を使って、HTTP GET リクエストを送信する例です。 Promise に対応しているので、非同期処理を .then ～ .catch のチェーンで簡潔に記述することができます。
const fetch = require(&amp;#39;node-fetch&amp;#39;); const URL = &amp;#39;https://example.com&amp;#39;; fetch(URL) .</description></item><item><title>Node.jsメモ: プロキシ経由の HTTP 通信を行う（global-agent モジュール）</title><link>https://maku77.github.io/p/vwu58as/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/vwu58as/</guid><description>global-agent モジュール を使用すると、Node.js プログラム内の HTTP 通信をプロキシ経由で行うように設定できます。 具体的には、Node.js 標準の http モジュールによる通信がプロキシ経由になるように設定されます。 サードパーティ製のネットワークモジュールも、ベースは http モジュールであることが多いため、global-agent でプロキシ設定を行うことで、Node.js アプリ全体の通信をプロキシ経由にすることができます。
global-agent のインストール global-agent は次のようにインストールします。 TypeScript を使用する場合は、型定義ファイルも一緒にインストールしてください。
$ npm install --save global-agent $ npm install --save-dev @types/global-agent global-agent によるプロキシ設定 GLOBAL_AGENT_HTTP_PROXY global-agent モジュールが提供する bootstrap() 関数を実行すると、GLOBAL_AGENT_HTTP_PROXY 環境変数で設定されたプロキシが、それ以降の HTTP 通信で使われるようになります。 環境変数は OS の設定画面から設定しておくこともできますし、次のようにプログラム内で設定することもできます。
// Setup HTTP proxy import {bootstrap} from &amp;#39;global-agent&amp;#39;; process.env.GLOBAL_AGENT_HTTP_PROXY = &amp;#39;http://proxy.example.com:10080&amp;#39;; bootstrap(); 内部的には、bootstrap() 実行時に GLOBAL_AGENT_HTTP_PROXY 環境変数の値が global.GLOBAL_AGENT.HTTP_PROXY という変数にコピーされ、その後の HTTP 通信で参照されるようになります。
GLOBAL_AGENT_HTTPS_PROXY HTTPS 通信用のプロキシを別アドレスにしたい場合は、GLOBAL_AGENT_HTTPS_PROXY という環境変数を指定します。
export GLOBAL_AGENT_HTTPS_PROXY=&amp;#39;https://proxy.example.com:10080&amp;#39; この環境変数を設定しない場合は、GLOBAL_AGENT_HTTP_PROXY で指定したプロキシが HTTPS 通信においても使用されます。</description></item><item><title>Node.jsメモ: util.promisify でコールバックベースの関数を Promise 化する</title><link>https://maku77.github.io/p/62d6wuc/</link><pubDate>Wed, 03 Jun 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/62d6wuc/</guid><description>util.promisify の概要 Node.js v8.0.0 で導入された util.promisify 関数 を使用すると、コールバックベースの関数を簡単に Promise クラスでラップすることができます。
次の例では、fs.stat 関数を Promise 化した stat 関数を作成しています。
const util = require(&amp;#39;util&amp;#39;); const fs = require(&amp;#39;fs&amp;#39;); const stat = util.promisify(fs.stat); stat(&amp;#39;.&amp;#39;).then((stats) =&amp;gt; { // Do something with `stats` }).catch((err) =&amp;gt; { // Handle the error. }); util.promisify() は、Promise 対応されていない 3rd パーティ製ライブラリを使用する際に威力を発揮します。
Promise クラス自体の詳しい使い方については下記の記事を参照してください。
参考: Promise オブジェクトで連続するコールバック処理を簡潔に記述する ｜ まくまくJavaScriptノート 自力で Promise 対応した場合 ここでは、次のような、割り算の計算結果をコールバックで返す関数を題材にして説明します。
function div(num1, num2, callback) { if (num2 == 0) { callback(&amp;#39;ERROR: Zero division&amp;#39;); } else { callback(null, num1 / num2); } } 上記の例では、0 除算によるエラーが発生した場合、コールバック関数の第 1 パラメータでエラーメッセージを返すように実装しています。 このように、コールバック関数の第 1 パラメータをエラー情報として使うものを、エラー・ファースト・コールバック (error-first callback) といい、非同期関数のコールバックは伝統的にこのような形式に従っていました。</description></item><item><title>Node.jsメモ: npm run のスクリプトの中でディレクトリを削除する (rimraf)</title><link>https://maku77.github.io/p/wzufzn6/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wzufzn6/</guid><description>なぜ rimraf が必要か？ TypeScript などのトランスパイラを使って Node.js アプリを開発していると、ビルド結果を格納するディレクトリを削除する clean コマンド（NPM スクリプト）を定義したくなります。
package.json { &amp;#34;scripts&amp;#34;: { &amp;#34;clean&amp;#34;: &amp;#34;rm -rf build&amp;#34; } } これはこれで間違いではないのですが、Linux の rm コマンドを使用しているので、OS 依存の package.json になってしまいます。
そこで、OS に依存しない rm -rf コマンドを実現するのが rimraf という NPM パッケージです。 rimraf は NPM の作者である Isaac 氏が作成しており、安心して使用できます。 rimraf という名前は Linux コマンドの rm -rf の発音が由来だと言われています。
rimraf の使い方 rimraf のインストール rimraf コマンドは NPM パッケージとして提供されているので、下記のように簡単にインストールすることができます。
$ npm install --save-dev rimraf --save-dev オプションを付けて、package.json の devDependencies エントリに追加するようにしましょう。
rimraf でディレクトリを削除する 下記の package.</description></item><item><title>Node.jsメモ: npm run のスクリプトを連続実行・並列実行する (npm-run-all)</title><link>https://maku77.github.io/p/fzudboe/</link><pubDate>Mon, 07 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fzudboe/</guid><description>なぜ npm-run-all が必要か？ package.json の scripts プロパティでスクリプトを定義しておくと、任意のコマンドを npm run コマンド経由で実行できるようになります（以降 NPM スクリプトと呼びます）。
しかし、デフォルトでは、複数の NPM スクリプトを連続して実行する方法（Linux の cmd1 &amp;amp;&amp;amp; cmd2）や、並列に実行する方法（Linux の cmd1 &amp;amp; cmd2）は提供されていません。 強引に各 OS のシェルの &amp;amp;&amp;amp; や &amp;amp; を組み合わせることでできないことはありませんが、Windows と Linux で記述方法が異なるので、OS に依存した package.json になってしまいます。
このような場合に、npm-run-all という NPM パッケージを使用すると、複数の NPM スクリプトを逐次／並列実行するスクリプトを、OS に依存しない形で記述できるようになります。
npm-run-all パッケージ npm-run-all の使い方 npm-run-all のインストール npm-run-all は下記のようにインストールします。
$ npm install --save-dev npm-run-all npm-run-all コマンドは、package.json の scripts 定義の中から呼び出して使用するので、上記のように --save-dev オプションを指定して、devDependencies の依存情報に追加するようにしましょう。
npm-run-all でシーケンシャル実行 (run-s) run-s （npm-run-all のショートカット）というコマンドを使用すると、指定した NPM スクリプトをシーケンシャルに（ひとつずつ順番に）実行していくことができます。</description></item><item><title>Node.jsメモ: npm run のスクリプトの中でファイルのコピーを行う (cpx)</title><link>https://maku77.github.io/p/j9dkm52/</link><pubDate>Sat, 05 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/j9dkm52/</guid><description>OS 依存のコピーコマンドでファイルコピーする方法 package.json の scripts プロパティでスクリプトを定義しておくと、任意のコマンドを npm run コマンド経由で実行できるようになります。
参考: npm run で任意のコマンドを実行する (npm run, npm start) このスクリプト定義は便利なので、例えば、下記のようにファイルのコピーや削除を行うスクリプトを定義したくなるかもしれません。
package.json（Windows でしか動作しない copy スクリプトの定義） { &amp;#34;scripts&amp;#34;: { &amp;#34;copy&amp;#34;: &amp;#34;xcopy /S /H /Y static\\** build\\&amp;#34; } } この copy スクリプトを下記のように実行すると、static ディレクトリ内のファイルが build ディレクトリにすべてコピーされます。
D:\&amp;gt; npm run copy しかし、xcopy コマンドは Windows のコマンドなので、Linux などで同様のことを行うためには、下記のように別のスクリプトを用意しなければいけません。
{ &amp;#34;scripts&amp;#34;: { &amp;#34;copy-win&amp;#34;: &amp;#34;xcopy /S /H /Y static\\** build\\&amp;#34;, &amp;#34;copy-linux&amp;#34;: &amp;#34;mkdir -p ./build &amp;amp;&amp;amp; cp -pR ./static/* ./build&amp;#34; } } Toru Nagashima さんの作成した cpx という NPM パッケージを使用すると、ファイルのコピー処理を汎用的に記述することができます。 同様のことを行える copyfiles という NPM パッケージもあるのですが、ここでは使い方がよりシンプルな cpx を採用することにします。</description></item><item><title>Node.jsメモ: nodemon で Node.js サーバの再起動を自動化する</title><link>https://maku77.github.io/p/rvghobv/</link><pubDate>Fri, 07 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/rvghobv/</guid><description>nodemon とは？ Express や Restify で Web サーバの実装をしていると、ソースコードを修正するたびに Ctrl + C でサーバを強制終了し、node app.js で再起動するという操作が必要になります。 node コマンドの代わりに nodemon コマンドを使用すると、ソースコードの変更を監視し、自動的に node コマンドを再起動してくれます。
$ nodemon app.js node の代わりに nodemon とタイプするだけで、快適な実装生活を送ることができます。 Node.js でサーバ系のコーディングを行うときは nodemon を使うようにしましょう！
nodemon のインストール nodemon コマンドは、Node.js 付属の npm コマンドで簡単にインストールすることができます。
$ npm install -g nodemon システム全体で使用可能なコマンドとしてインストールしたいので、-g オプションを付けて実行してください。
nodemon を使ってみる ここでは、Node.js の標準モジュールである http を使って簡単な Web サーバを作り、それを nodemon で起動してみます。 下記は、Hello という返答を返すだけの簡単な Web サーバプログラムです。
app.js var server = require(&amp;#39;http&amp;#39;).createServer(); server.on(&amp;#39;request&amp;#39;, function(req, res) { res.writeHead(200, {&amp;#39;Content-Type&amp;#39;: &amp;#39;text/plain&amp;#39;}); res.</description></item><item><title>Node.jsメモ: Yaml ファイルを読み書きする (js-yaml)</title><link>https://maku77.github.io/p/fpxsu6v/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fpxsu6v/</guid><description>js-yaml パッケージのインストール js-yaml パッケージは、npm を使ってインストールすることができます。
$ npm install js-yaml $ npm install js-yaml --save # package.json に依存情報を追記する場合 js-yaml (YAML1.2 parser/writer) - npm js-yaml で Yaml ファイルを読み込む 例えば、ここでは下記のような Yaml ファイルを読み込んでみます（出典はこちら）。
☝️ .yaml or .yml YAML ファイルの拡張子は、.yaml が使われていたり .yml が使われていたりしますが、YAML 公式サイトでは .yaml を使うことを推奨しているようです。 data.yaml --- receipt: Oz-Ware Purchase Invoice date: 2012-08-06 customer: first_name: Dorothy family_name: Gale items: - part_no: A4786 descrip: Water Bucket (Filled) price: 1.47 quantity: 4 - part_no: E1628 descrip: High Heeled &amp;#34;Ruby&amp;#34; Slippers size: 8 price: 133.</description></item><item><title>Node.jsメモ: エントリポイントとなった JavaScript ファイルのパスやディレクトリ名を取得する (require.main.filename)</title><link>https://maku77.github.io/p/jm48fwe/</link><pubDate>Wed, 27 Mar 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/jm48fwe/</guid><description>require.main.filename の基本 require.main.filename を参照すると、プログラムのエントリポイントとなった JavaScript ファイルの絶対パスを取得することができます。
下記のサンプルでは、main.js から mylib/foo.js を呼び出しており、呼び出される側で require.main.filename の値を出力しています。 参考のため、自分自身のファイル名を示す __filename の値も出力しています。
main.js import &amp;#39;./mylib/foo.js&amp;#39;; mylib/foo.js import path from &amp;#39;node:path&amp;#39;; console.log(`エントリ: ${require.main.filename}`); console.log(`自分自身: ${__filename}`); main.js ファイルをエントリポイントとして実行すると、下記のような結果になります。
$ node main.js エントリ: /User/maku/main.js 自分自身: /User/maku/mylib/foo.js require.main.filename の値は、正しく main.js のパスになっていることがわかります。 一方、mylib/foo.js をエントリポイントとして実行すると、下記のように結果が変わります。
$ node mylib/foo.js エントリ: /User/maku/mylib/foo.js 自分自身: /User/maku/mylib/foo.js 応用例: アプリのルートディレクトリにある設定ファイルを読み込む この仕組みを利用すると、どのディレクトリ階層に置かれたライブラリの中からでも、エントリポイントとなる JavaScript が置いてあるディレクトリパスを取得することができます。
例えば、アプリのルートディレクトリに設定ファイル (app.config) を置くという仕様にした場合、下記のようにして app.config のフルパスを構築することができます（エントリポイントの index.js が置かれたディレクトリをルートと呼んでいます）。
mylib/aaa/bbb/hello.js import path from &amp;#39;node:path&amp;#39;; const configPath = path.join(path.dirname(require.main.filename), &amp;#39;app.</description></item><item><title>Node.jsメモ: 環境変数の代わりに .env ファイルを使用する (dotenv)</title><link>https://maku77.github.io/p/6kruhwy/</link><pubDate>Tue, 26 Mar 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6kruhwy/</guid><description>dotenv モジュールとは Node.js のプログラムから環境変数を参照するには process.env を参照します。
参考: Node.js で環境変数を参照する (process.env) ユーザー設定を環境変数で行うようにしているアプリはよくあるのですが、たかが 1 つのアプリのために環境変数を設定するのは面倒だというユーザーは少なくありません（設定がどこで行われているのかわかりにくいという理由もあります）。
dotenv モジュールを使用すると、カレントディレクトリに置かれた .env ファイルを読み込み、そこに記述されたキーと値のペアを process.env 経由で参照できるようになります。
dotenv - npm つまり、ユーザーはアプリの設定を、従来通り環境変数で行うこともできるし、.env ファイルでも行うことができるようになります。 環境変数を使ってアプリの挙動を変えるような実装をしている場合は、.env ファイルによる設定もサポートしておくと親切です。 クラウドサービスと連携するアプリケーションなどは、接続キー などの情報を .env ファイルで指定できるようにしているものがよくあります。
dotenv モジュールのインストール dotenv モジュールは npm コマンドで下記のようにインストールすることができます。 インストールされたモジュールは node_modules ディレクトリに格納されます。
$ npm install dotenv dotenv モジュールの基本的な使い方 まず、サンプルの設定ファイルとして、プロジェクトのルートディレクトリに、下記のような .env ファイルを作成します。
.env # これはコメント行 KEY1=VALUE1 KEY2=VALUE2 KEY3=VALUE3 .env ファイルの内容を読み込んで、process.env オブジェクトのプロパティとして参照できるようにするには、アプリの最初の方で下記のように実行します。
sample.js require(&amp;#39;dotenv&amp;#39;).config(); 基本的にはやることはこれだけです。 仮に、.env ファイルが見つからない場合は、単純に無視されるだけなので、上記のコードは安心して入れておくことができます。
後は、通常の環境変数と同様に process.env オブジェクト経由で値を参照するだけです。
require(&amp;#39;dotenv&amp;#39;).config(); console.log(process.env.KEY1); //=&amp;gt; VALUE1 console.log(process.env.KEY2); //=&amp;gt; VALUE2 console.</description></item><item><title>Node.jsメモ: キーボードからの入力を取得する (readline.question)</title><link>https://maku77.github.io/p/9pjvmzj/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9pjvmzj/</guid><description>キーボード（標準入力）からのユーザ入力を取得するには、readline 標準モジュールを使用します。 特に、readline.question() 関数を使用することで、ユーザへのプロンプトメッセージ表示と、ユーザ入力の取得を同時に行うことができます。
非同期でキーボード入力を取得する 下記の例では、プロンプトでユーザ名の入力を促し、入力された名前を使って挨拶文を表示します。
sample.js import readline from &amp;#39;node:readline&amp;#39;; const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question(&amp;#39;What is your name? &amp;#39;, (answer) =&amp;gt; { console.log(`Hello, ${answer}!`); rl.close(); }); 実行例 $ node sample.js What is your name? Maku Hello, Maku! 同期でキーボード入力を取得する readline モジュールは基本的に非同期に結果を受け取るように設計されているため、同期的にユーザ入力を取得したい場合は、Promise を使用した処理が必要になります。 下記の例では、ECMAScript 2017 の async、await を利用して同期的にキーボードからの入力を取得しています。
sample.js import readline from &amp;#39;node:readline&amp;#39;; // ユーザからのキーボード入力を取得する Promise を生成する function readUserInput(question) { const rl = readline.createInterface({ input: process.stdin, output: process.</description></item><item><title>Node.jsメモ: コマンドライン引数（パラメータ）を取得する (process.argv)</title><link>https://maku77.github.io/p/9i67itz/</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9i67itz/</guid><description>process.argv によるコマンドライン引数の取得 Node.js プログラムから、コマンドライン引数を取得するには、process.argv プロパティを参照します。 process モジュールはデフォルトで使用できるようになっているので、追加でモジュールを読み込む必要ありません。
process.argv は配列になっており、argv[2] 以降にコマンドライン引数が格納されています。 下記のサンプルコードは、process.argv 配列の内容を列挙します。
args.js for (let i = 0; i &amp;lt; process.argv.length; ++i) { console.log(i + &amp;#39;: &amp;#39; + process.argv[i]); } // entries() を使う方法 // for (const [i, val] of process.argv.entries()) { // console.log(`${i}: ${val}`); // } 実行例 $ node args.js AAA BBB CCC 0: C:\app\nodejs\node.exe 1: D:\sandbox\node\test.js 2: AAA 3: BBB 4: CCC ちなみに、argv[0] には node 実行ファイル (node.exe) のフルパス、argv[1] にはスクリプトファイル (.</description></item><item><title>Node.jsメモ: モジュール自身のコードにテストコードを記述する (require.main)</title><link>https://maku77.github.io/p/3b52x28/</link><pubDate>Mon, 10 Dec 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/3b52x28/</guid><description>Node.js で実行中のプログラムから require.main を参照すると、エントリポイントとして起動した module インスタンスを参照することができます。 つまり、下記のようにして、エントリポイントとして起動された JavaScript ファイルかどうかを判別することができます。
if (require.main === module) { // このモジュールを node で直接起動した場合のみ実行される } あるいは、下記のように判定することもできます。
if (require.main.filename === __filename) { // ... } この仕組みを利用して、あるモジュールのテストコードを、そのモジュールのコード内に埋め込むことができます。 下記は、add 関数と subtract 関数を提供する簡単なモジュールのサンプルです。
mymath.js function add(a, b) { return a + b; } function subtract(a, b) { return a - b; } module.exports = { add: add, subtract: subtract }; // このモジュール自身のテストコード if (require.main === module) { let assert = require(&amp;#39;assert&amp;#39;); assert.</description></item><item><title>Node.jsメモ: 外部の JSON ファイルを読み込む (require)</title><link>https://maku77.github.io/p/uf6zrk6/</link><pubDate>Mon, 10 Dec 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/uf6zrk6/</guid><description>Node.js の require は、外部の JSON ファイルを読み込むのにも使用することができます。 下記は、設定情報を settings.json というファイルに記述しておき、その情報を読み込む例です。
settings.json { &amp;#34;srcDir&amp;#34;: &amp;#34;src/main/js&amp;#34;, &amp;#34;testDir&amp;#34;: &amp;#34;src/test/js&amp;#34; } main.js var settings = require(&amp;#39;./settings.json&amp;#39;); // 拡張子は省略可能 console.log(settings.srcDir); //=&amp;gt; &amp;#39;src/main/js&amp;#39; console.log(settings.testDir); //=&amp;gt; &amp;#39;src/test/js&amp;#39; 上記では require に渡すファイル名として ./settings.json と拡張子まで指定していますが、./settings のように拡張子を省略することもできます。 ただし、同じディレクトリに ./settings.js があると、そちらが優先的に読み込まれてしまうので注意してください（拡張子だけ異なるファイルは作らない方がよいです）。</description></item><item><title>Node.jsメモ: request-promise モジュールを使用して HTTP 通信を行う</title><link>https://maku77.github.io/p/r8qw3qs/</link><pubDate>Tue, 27 Nov 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r8qw3qs/</guid><description>request パッケージと request-promise パッケージ 「request モジュールを使用して HTTP 通信を行う」の記事で説明しているように、request パッケージを使用すると、HTTP 通信による情報取得を簡単に行えます。 request パッケージの拡張版として、request-promise パッケージが提供されており、request パッケージの代わりに使用することで、ECMAScript 2015 の Promise や ECMAScript 2017 の async/await を使用したコーディングを行うことができます。
request-promise パッケージ Promise や async/await の使い方に関しては下記の記事で説明していますが、簡単に言うと、従来のコールバックを使用したコーディングよりもわかりやすいコーディングが行えるようになります。
Promise オブジェクトで連続するコールバック処理を簡潔に記述する Promise な非同期処理を async/await でさらに読みやすくする request-promise パッケージのインストール request-promise パッケージは、npm install コマンドで簡単にインストールすることができます。 request パッケージに依存している (peer dependencies) ため、request パッケージも一緒にインストールしておく必要があります。
$ npm install request $ npm install request-promise package.json の dependencies エントリに追加したい場合は、次のように --save オプションを追加してインストールします。
$ npm install --save request $ npm install --save request-promise TypeScript で開発している場合は、DefinitelyTyped プロジェクトで提供されている型情報 @types/request-promise をインストールしましょう。</description></item><item><title>Node.jsメモ: npm コマンドでインストールされている Node.js 用パッケージの一覧を表示する (npm list, ll)</title><link>https://maku77.github.io/p/7srzpt3/</link><pubDate>Thu, 22 Nov 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7srzpt3/</guid><description>npm install によってインストールされた Node パッケージの一覧は、npm list コマンドで確認することができます（エイリアスとして npm ls も使用可能）。
$ npm list # ローカルモードでインストールしたパッケージを一覧表示 $ npm list -g # グローバルモードでインストールしたパッケージを一覧表示 各パッケージが依存しているパッケージに関しても、階層構造ですべて表示してくれます。
例: require パッケージがインストールされている場合 D:\y\sandbox&amp;gt; npm list D:\y\sandbox `-- require@2.4.20 +-- std@0.1.40 `-- uglify-js@2.3.0 +-- async@0.2.10 +-- optimist@0.3.7 | `-- wordwrap@0.0.3 `-- source-map@0.1.43 `-- amdefine@1.0.1 npm list の代わりに、npm la や npm ll を使用すると、より詳細な情報を表示することができます。
D:\y\sandbox&amp;gt; npm ll | D:\y\sandbox | `-- require@2.4.20 | javascript module management! brings node&amp;#39;s require statement to the browser | git://github.</description></item><item><title>Node.jsメモ: npm コマンドでインストール可能なパッケージを検索する (npm search)</title><link>https://maku77.github.io/p/akf8eh9/</link><pubDate>Thu, 22 Nov 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/akf8eh9/</guid><description>npm search コマンドを使用すると、npm によって取得可能なパッケージを検索することができます。 例えば、次のように実行すると、パッケージ名や Description、キーワードリストなどに express という単語が含まれているパッケージの一覧を表示することができます。
例: express に関するパッケージを検索 $ npm search express NAME | DESCRIPTION | AUTHOR | DATE | VERSION | KEYWORDS express | Fast,… | =dougwilson… | 2018-10-11 | 4.16.4 | express framework sinatra web rest restful router app api path-to-regexp | Express style path… | =blakeembrey… | 2018-08-26 | 2.4.0 | express regexp route routing cors | Node.js CORS… | =dougwilson… | 2018-11-04 | 2.</description></item><item><title>Node.jsメモ: プログラムの実行時間を計測する (console.time, console.timeEnd)</title><link>https://maku77.github.io/p/226tint/</link><pubDate>Thu, 22 Nov 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/226tint/</guid><description>Node.js でグローバルに定義されている console オブジェクトには、プログラムの経過時間を計るための下記のようなメソッドが用意されています。
console.time 系のメソッド console.time([label]): 計測開始 console.timeEnd([label]): 計測終了して経過時間を stdio へ出力 console.timeLog([label][, ...data]): console.time と console.timeEnd の間で使用し、途中経過を stdio へ出力する console.time の基本的な使い方 下記は、単純なループ処理にかかる経過時間を計測するサンプルです。
sample.js console.time(&amp;#39;inc-100-times&amp;#39;); let a = 1; for (let i = 0; i &amp;lt; 100; ++i) { a += 1; } console.timeEnd(&amp;#39;inc-100-times&amp;#39;); 実行結果 $ node sample.js inc-100-times: 0.150ms console.timeEnd メソッドは結果の出力まで実行してくれるため、console.log などを呼び出して出力する必要がないことに注目してください。 そのため、自力で Date オブジェクトなどを生成して経過時間を計測する方法よりも、手軽にパフォーマンス計測を行うことができます。
console.timeLog で途中経過を出力する 次の例では、さらに console.timeLog を使用することで、console.time ～ console.timeEnd の間の途中経過を出力しています。
sample2.js // 計測したい任意の処理 function doHoge() { let a = 1.</description></item><item><title>Node.jsメモ: 実行中の JavaScript ファイルのパスやディレクトリ名を取得する (__filename, __dirname)</title><link>https://maku77.github.io/p/d48fxh9/</link><pubDate>Thu, 22 Nov 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/d48fxh9/</guid><description>__filename と __dirname でモジュールのパスを取得する Node.js のプログラム内から __filename や __dirname を参照すると、現在実行中のモジュール（jsファイル）の絶対パスや、そのファイルが含まれているディレクトリの絶対パスを取得することができます。
__filename: 現在実行中のモジュールの絶対パス __dirname: 現在実行中のモジュールの親ディレクトリの絶対パス サンプルコード (D:/sandbox/sample.js) console.log(__filename); console.log(__dirname); 実行結果 D:\sandbox\node\sample.js D:\sandbox\node カレントディレクトリを取得する process.cwd() __dirname と似たようなものに、カレントディレクトリを調べる process.cwd() がありますが、こちらは現在のプロセスのカレントディレクトリを調べるものなので、JavaScript ファイルが置かれているパスとは関係がありません。 もちろん、JavaScript ファイルがあるディレクトリで node コマンドを実行すれば __dirname と同じ結果になりますが、process.chdir() などでカレントディレクトリを変更すると、process.cwd() の結果は変化します。
sample.js console.log(__dirname); console.log(process.cwd()); process.chdir(&amp;#39;..&amp;#39;); // 上のディレクトリへ移動 console.log(__dirname); console.log(process.cwd()); 実行結果 D:\sandbox\node D:\sandbox\node D:\sandbox\node D:\sandbox</description></item><item><title>Node.jsメモ: 現在位置のスタックトレースを出力する (console.trace)</title><link>https://maku77.github.io/p/oeka5t6/</link><pubDate>Thu, 22 Nov 2018 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/oeka5t6/</guid><description>Node.js にグローバルで定義されている console オブジェクトの trace メソッドを呼び出すと、現在位置のスタックトレースを標準エラー出力に出力してくれます。
参考: console.trace メソッドの定義 下記のサンプルでは、world() 関数の中で console.trace() を呼び出しています。
sample.js function hello() { world(); } function world() { console.trace(); } hello(); 実行結果 $ node sample.js Trace at world (D:\sandbox\test-node\sample.js:8:13) at hello (D:\sandbox\test-node\sample.js:4:5) at Object.&amp;lt;anonymous&amp;gt; (D:\sandbox\test-node\sample.js:11:1) at Module._compile (internal/modules/cjs/loader.js:688:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:699:10) at Module.load (internal/modules/cjs/loader.js:598:32) at tryModuleLoad (internal/modules/cjs/loader.js:537:12) at Function.Module._load (internal/modules/cjs/loader.js:529:3) at Function.Module.runMain (internal/modules/cjs/loader.js:741:12) at startup (internal/bootstrap/node.js:285:19) 出力されたトレースの上の方を見ると、hello() → world() という順に呼び出されていることが分かります。</description></item><item><title>Node.jsメモ: Node.js がどのバージョンの V8 エンジンで動作しているか調べる</title><link>https://maku77.github.io/p/cf7eoyo/</link><pubDate>Mon, 08 Aug 2016 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/cf7eoyo/</guid><description>node コマンドを実行したときにどのバージョンの V8 エンジンで動作するかを調べるには下記のようにします。
$ node -p process.versions.v8 5.0.71.52</description></item><item><title>Node.jsメモ: Node.js 用モジュールの作り方（require でロード可能な Node モジュールを作成する）</title><link>https://maku77.github.io/p/9fapzbb/</link><pubDate>Tue, 19 Jul 2016 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9fapzbb/</guid><description>Node モジュール作成の基本 Node.js では、.js ファイルをモジュールとして扱うことができます（配布用に package.json が用意されたものは、特に「パッケージ」と呼ばれます）。 作成したモジュールは下記のように require() を使用して読み込むことができます。
var mod = require(&amp;#39;./mymodule.js&amp;#39;); // .js は省略可能 mod.foo(1, 2); Node モジュールで公開するプロパティや関数は、以下のいずれかの方法で設定します。
exports の各プロパティに設定する方法 module.exports 自体に任意のオブジェクトを代入する方法 (1) exports のプロパティとして公開プロパティを設定する方法 exportsオブジェクト（実際は module.exports のエイリアス）のプロパティとして設定したものが require したクライアント側からアクセスできるようになります。 逆に、exports のプロパティに設定されていない変数や関数は、ファイル内にスコープが限定されます。
下記の例では、exports のプロパティ経由で、name 変数、add 関数を公開しています。
mymodule.js（Node モジュール） // 公開される変数や関数 exports.name = &amp;#39;magu&amp;#39;; exports.add = function(a, b) { return privFunc(a, b); } // 非公開の変数や関数 var secret = 100; function privFunc(a, b) { return a + b + secret; } この Node モジュールは、以下のように require() 関数でロードして使用します。 同じディレクトリに置いたモジュールは、プレフィックスに .</description></item><item><title>Node.jsメモ: 外部プログラムを実行してその出力を取得する (child_process)</title><link>https://maku77.github.io/p/8kgdvvd/</link><pubDate>Mon, 11 Jul 2016 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8kgdvvd/</guid><description>child_process.exec による外部プログラムの実行 Node.js の標準モジュールである child_process モジュール を使用すると、任意のシェルコマンドを実行し、その結果（標準出力や標準エラー出力）を取得することができます。 下記のサンプルでは、シェルコマンドとして echo Hello World を実行して、その出力である Hello World というテキストを取得しています。
sample.js import { exec } from &amp;#39;node:child_process&amp;#39;; // シェル上で実行するコマンド const COMMAND = &amp;#39;echo Hello World&amp;#39;; exec(COMMAND, (error, stdout, stderr) =&amp;gt; { // シェル上でコマンドを実行できなかった場合のエラー処理 if (error !== null) { console.log(`exec error: ${error}`); return; } // シェル上で実行したコマンドの標準出力が stdout に格納されている console.log(`stdout: ${stdout}`); }); 実行結果 C:\&amp;gt; node sample.js stdout: Hello World stdout のバッファがあふれてしまう場合 child_process.exec() によって起動された外部プログラムの出力は stdout バッファに保持されますが、デフォルトの最大バッファサイズ (maxBuffer) が 200KB (200 * 1024) に設定されているため、あまり大量の出力を行うプログラムを実行するとバッファあふれのエラーが出てしまうことがあります。</description></item><item><title>Node.jsメモ: ディレクトリ内のファイルを列挙する</title><link>https://maku77.github.io/p/ke25m82/</link><pubDate>Sat, 09 May 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ke25m82/</guid><description>ディレクトリ内のファイルやディレクトリを列挙する（一階層のみ） Node.js の標準モジュールである fs モジュールの readdir() を使用して、指定したディレクトリ内のファイルやディレクトリを列挙することができます。
fs.readdir function 見つかったファイルリストは、コールバック関数の第 2 引数として渡されます。 ドットで始まるファイルやディレクトリは検索対象になりますが、カレントディレクトリ (.) や、親ディレクトリ (..) は結果に入りません。
下記は、カレントディレクトリ内のファイルとディレクトリを列挙するサンプルです。
sample.js import fs from &amp;#39;node:fs&amp;#39;; fs.readdir(&amp;#39;.&amp;#39;, (err, files) =&amp;gt; { if (err) { console.error(err); } else { console.log(files); } }); 実行例 $ node sample [ &amp;#39;dummy.txt&amp;#39;, &amp;#39;dummy_dir&amp;#39;, &amp;#39;sample.js&amp;#39; ] 指定したディレクトリが存在しない場合は、ENOENT (-2) エラーが発生します。
D:\y\sandbox\node&amp;gt; node sample { Error: ENOENT: no such file or directory, scandir &amp;#39;D:\y\sandbox\node\aaaa&amp;#39; at Error (native) errno: -4058, code: &amp;#39;ENOENT&amp;#39;, syscall: &amp;#39;scandir&amp;#39;, path: &amp;#39;D:\\y\\sandbox\\node\\aaaa&amp;#39; } ディレクトリ内のファイルを再帰的に列挙する 下記の dirutil モジュールは、指定したディレクトリ内のファイルを再帰的に列挙する walkDir 関数を提供します。</description></item><item><title>Node.jsメモ: 指定したパスがディレクトリかどうか調べる (Stats.isDirectory)</title><link>https://maku77.github.io/p/af2r6mq/</link><pubDate>Sat, 09 May 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/af2r6mq/</guid><description>Node.js の標準モジュール fs が提供している fs.stat(path, callback) 関数を使用すると、指定したファイルやディレクトリの情報を表す fs.Stats オブジェクトを取得することができます。
参考: Node.js - fs.stat メソッド 参考: Node.js - fs.Stats クラス main.js import fs from &amp;#39;node:fs&amp;#39;; fs.stat(&amp;#39;/dir/path&amp;#39;, (err, stats) =&amp;gt; { if (err) throw err; console.log(`stats: ${JSON.stringify(stats)}`); }); fs.Stats オブジェクトには、isDirectory() メソッドが用意されているので、これを利用して指定したパスがディレクトリかどうかを調べることができます。
fs.stat(&amp;#39;/dir/path&amp;#39;, (err, stats) =&amp;gt; { if (err) throw err; if (stats.isDirectory()) { console.log(&amp;#39;This is a directory&amp;#39;); } }); fs.stat の同期バージョンである fs.statSync も用意されていますが、可能な限り上記の非同期バージョンを使うように実装すべきです。 fs.statSync は戻り値で fs.Stats オブジェクトを返します。
参考: Node.js - fs.statSync メソッド main.</description></item><item><title>Node.jsメモ: CSV ファイルを読み込む (csv)</title><link>https://maku77.github.io/p/r7ckr36/</link><pubDate>Sun, 22 Mar 2015 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r7ckr36/</guid><description>Node.js で CSV ファイルを簡単に扱うための csv モジュールが公開されています。 このモジュールは npm コマンドで下記のようにインストールできます。
csv モジュールのインストール $ npm install csv 下記の例では、input.csv という入力ファイルを読み込んで、各行ごとに配列データとして取得しています。 Parser オブジェクトを作成するときに、trim オプションを true に設定しているので、カンマの前後のスペースが自動的に削除されています。
main.js import fs from &amp;#39;node:fs&amp;#39;; import path from &amp;#39;node:path&amp;#39;; import csv from &amp;#39;csv&amp;#39;; const FILE = path.join(__dirname, &amp;#39;input.csv&amp;#39;); const parser = csv.parse({trim: true}, (err, data) =&amp;gt; { console.log(data); }); fs.createReadStream(FILE).pipe(parser); input.csv aaa, bbb, ccc 100, 200, 300 400, 500, 600 実行結果 $ node main [ [ &amp;#39;aaa&amp;#39;, &amp;#39;bbb&amp;#39;, &amp;#39;ccc&amp;#39; ], [ &amp;#39;100&amp;#39;, &amp;#39;200&amp;#39;, &amp;#39;300&amp;#39; ], [ &amp;#39;400&amp;#39;, &amp;#39;500&amp;#39;, &amp;#39;600&amp;#39; ] ] さらに、columns オプションを true に設定することで、CSV ファイルの一行目をヘッダとして扱うことができます。 この場合、一行目に記述したカラム名をプロパティ名としたオブジェクトとして、各行のデータが取得されます。</description></item><item><title>Node.jsメモ: npm でインストール可能なパッケージのバージョンを調べる</title><link>https://maku77.github.io/p/6u8xexa/</link><pubDate>Tue, 23 Sep 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6u8xexa/</guid><description>npm info コマンドを使用すると、NPM リポジトリで管理されているパッケージの情報を調べることができます。
例: 最新の Express のバージョンを表示する $ npm info express version 4.9.4 例: インストール可能な Express のバージョンのリストを表示する $ npm info express versions [ &amp;#39;0.14.0&amp;#39;, &amp;#39;0.14.1&amp;#39;, ... &amp;#39;4.9.3&amp;#39;, &amp;#39;4.9.4&amp;#39; ] 最後のパラメータを変更することで、パッケージに関するいろいろな情報を表示することができます。
コマンド 説明 npm info &amp;lt;pkg&amp;gt; version 最新のバージョン番号を表示する npm info &amp;lt;pkg&amp;gt; versions 有効なバージョン番号の一覧を表示する npm info &amp;lt;pkg&amp;gt; homepage ホームページの URL を表示する npm info &amp;lt;pkg&amp;gt; repository ソースコードのリポジトリの URL を表示する npm info &amp;lt;pkg&amp;gt; author 作者の情報を表示する npm info &amp;lt;pkg&amp;gt; contributors コントリビューターの一覧を表示する npm info &amp;lt;pkg&amp;gt; すべての情報を表示する</description></item><item><title>Node.jsメモ: Express サーバの HTTP アクセスログを表示する (express.logger() / morgan)</title><link>https://maku77.github.io/p/i5h4yx6/</link><pubDate>Mon, 22 Sep 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/i5h4yx6/</guid><description>Express で HTTP サーバログを表示するには、Logger 系のミドルウェアを使用します。 Application オブジェクトの use() メソッドで、以下のように Logger 系ミドルウェアを設定するだけです。 Express 3 では、Express に logger ミドルウェアが組み込まれていましたが、Express 4 からは、独立したミドルウェア (morgan) をロードする必要があります。
// Express 3 まで（Express オブジェクトからミドルウェア生成可能） app.use(express.logger()); // Express 4 以降（別途 npm install morgan しておく） var morgan = require(&amp;#39;morgan&amp;#39;); app.use(morgan(&amp;#39;combined&amp;#39;)); これにより、HTTP アクセスがあったときに、下記のような感じでターミナルにログ出力されるようになります。
127.0.0.1 - - [Sun, 21 Sep 2014 13:58:13 GMT] &amp;#34;GET / HTTP/1.1&amp;#34; 200 13 “-&amp;#34; &amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.122 Safari/537.36&amp;#34; 127.</description></item><item><title>Node.jsメモ: Express のルート定義の URL のパラメータで数字のみを受け付けるようにする</title><link>https://maku77.github.io/p/f2ow3kr/</link><pubDate>Mon, 22 Sep 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/f2ow3kr/</guid><description>Express の Application オブジェクトのルート定義で指定するパラメータには、正規表現パターンを指定することが可能です。
app.get(&amp;#39;/memos/:id([0-9]+)&amp;#39;, function (request, response) { res.json({ your_request_id: req.params.id }); }); 上記のように設定すると、/memos/ に続く部分（id: パラメータ）が数字のみの場合にマッチします。[0-9]+ は1文字以上の数字を意味する正規表現です。
http://localhost/memos/123 // { &amp;#34;your_request_id&amp;#34; : &amp;#34;123&amp;#34; } http://localhost/memos/xyz // Cannot GET /memos/xyz</description></item><item><title>Node.jsメモ: Node.js が require() で検索するパスのまとめ</title><link>https://maku77.github.io/p/ysmmmia/</link><pubDate>Mon, 22 Sep 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ysmmmia/</guid><description>require() によって Node.js がどのようにロードするモジュールを検索するかは、Node.js の Modules のドキュメント に詳しく説明されていますが、若干複雑なのでここでまとめておきます。
require の使い分け require でモジュールをロードするとき、多くは下記の 3 パターンのロード方法に分類できます。
// コアモジュール、あるいは node_modules にインストールしたパッケージのロード const crypto = require(&amp;#39;crypto&amp;#39;); // ローカルモジュールのロード const myLocalModule = require(&amp;#39;./path/to/myLocalModule&amp;#39;); // JSON ファイルのロード const jsonData = require(&amp;#39;./path/to/data.json&amp;#39;); 簡単にまとめると、
組み込みモジュールや、外部パッケージを使うときは名前そのものを指定する。 自分で作成したローカルモジュールや JSON ファイルは ./ で始まるパスで指定する。 と理解しておけばよいでしょう。
require がどのようにモジュールを検索するか？ require によってどのパスに置かれたファイルがロードされるかは、下記のようなアルゴリズムで決められます。
require(&amp;rsquo;name&amp;rsquo;) としたとき require のパラメータでモジュール名そのもの（express など）を指定した場合は、下記のようなアルゴリズムでロードするモジュールが決められます。
name というコアモジュールを探す。 同じディレクトリの node_modules/name というパッケージを探す。 より上位のディレクトリの node_modules/name というパッケージを探していく。 見つからなければ not found エラーを投げる。 例えば、/aaa/bbb/main.js 内で require('express') とすると、下記のように検索されていきます。
コアモジュール（Node の組み込みモジュール）の express /aaa/bbb/node_modules/express /aaa/node_modules/express /node_modules/express ちなみに、name というモジュール名の部分に、path/to/name のようにディレクトリパスが含まれていれば、そのような階層でインストールされた name モジュールがロードされます（node_modules/path/to/name などが検索される）。</description></item><item><title>Node.jsメモ: Node.js で assert を使用する</title><link>https://maku77.github.io/p/3x3y8h8/</link><pubDate>Sun, 13 Jul 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/3x3y8h8/</guid><description>Node.js には、標準で assert モジュールが用意されています。
参考: Assert - Node.js Manual &amp;amp; Documentation 使用例 import assert from &amp;#39;node:assert&amp;#39;; const count = 0; assert(count &amp;gt; 0, &amp;#39;count should be positive&amp;#39;); console オブジェクトには assert() メソッドが用意されており、こちらは何もモジュールをインポートしなくても使用できます。
console.assert(count &amp;gt; 0, &amp;#39;count should be positive&amp;#39;);</description></item><item><title>Node.jsメモ: 標準出力 (stdout)、標準エラー出力 (stderr) への出力</title><link>https://maku77.github.io/p/sffabwx/</link><pubDate>Sun, 13 Jul 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/sffabwx/</guid><description>Node.js でグローバルに定義されている console オブジェクトを使用すると、標準出力、標準エラー出力への出力を行うことができます。
参考: Node.js ドキュメント - console console で文字列を出力する console オブジェクトを使用して文字列を出力するときは、主に次のようなメソッドを使用します。
標準出力 (stdout) への出力: console.log() あるいは console.info() 標準エラー (stderr) への出力: console.error() あるいは console.warn() console.info() と console.warn() は単なるエイリアスなので、console.log() と console.error() を覚えておけば十分です。
これらのメソッドは、単純な文字列を渡すこともできますし、C 言語の printf 関数のようにフォーマット文字列を指定することもできます。
console.log(&amp;#39;Hello World&amp;#39;); console.log(&amp;#39;Count: %d&amp;#39;, 100); console.log(&amp;#39;Hello: %s&amp;#39;, &amp;#39;Tom&amp;#39;); console.log(&amp;#39;JSON: %j&amp;#39;, obj); // JSONテキストの出力 console でオブジェクトを直接出力する console.log メソッドなどに、フォーマット文字列を指定せずに直接オブジェクトを渡すと、適切にフォーマットされてオブジェクトの内容が表示されます。
実行例: パラメータに直接オブジェクトを渡した場合 console.log(obj); //=&amp;gt; { a: 100, b: 200 } console.dir() というメソッドもあります。 console.dir() はオブジェクトを 1 つだけ受け取り、基本的には console.log() と同様の情報を出力します。 ただし、Chrome や Firefox などの開発者ツール上で console.</description></item><item><title>Node.jsメモ: WebSocket サーバに接続してきたクライアントの情報を調べる</title><link>https://maku77.github.io/p/hn2896q/</link><pubDate>Thu, 27 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/hn2896q/</guid><description>WebSocket で接続してきたクライアントの URL は、connection イベントのハンドラに渡される client オブジェクトの req.url プロパティで参照することができます。
var ws = require(&amp;#39;websocket.io&amp;#39;); // WebSocket サーバの起動 var server = ws.listen(5000, function () { console.log(&amp;#39;Listening on port 5000&amp;#39;); }); // 各クライアントからの接続を処理 server.on(&amp;#39;connection&amp;#39;, function (client) { var url = client.req.url; //=&amp;gt; 例: &amp;#39;/aaa/bbb&amp;#39; など });</description></item><item><title>Node.jsメモ: Express で検索用の URL を定義する (req.query)</title><link>https://maku77.github.io/p/ryqsrbv/</link><pubDate>Sun, 23 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ryqsrbv/</guid><description>Express で検索用の URL を定義する方法について説明します。 例えば、/memos という URL でアクセスした場合はすべてのメモを取得し、/memos?q=keyword とクエリ文字列を指定した場合は検索結果を取得できるようにしたいとします。 このような場合は、req.query プロパティを参照して、特定のクエリが存在するかで処理を分けることで実現できます。
app.get(&amp;#39;/memos&amp;#39;, function(req, res) { var keyword = req.query[&amp;#39;q&amp;#39;]; if (keyword) { res.send(&amp;#39;q: &amp;#39; + keyword); } else { res.send(&amp;#39;All memos&amp;#39;); } }); ハンドラの第３パラメータとして渡される next 関数を使用すれば、それぞれの処理を分離して記述することも可能です。
参考: Express で next() により次のハンドラへ処理を委譲する function searchMemo(req, res, next) { var keyword = req.query[&amp;#39;q&amp;#39;]; if (keyword) { res.send(&amp;#39;q: &amp;#39; + keyword); } else { next(); } } function getAllMemos(req, res) { res.send(&amp;#39;All memos&amp;#39;); } app.</description></item><item><title>Node.jsメモ: Express の next() メソッドで次のハンドラへ処理を委譲する</title><link>https://maku77.github.io/p/izz3fkg/</link><pubDate>Sun, 23 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/izz3fkg/</guid><description>Express のルーティングハンドラーを設定する際には、下記のように app.get() や app.post() メソッドを使用します。
app.get(&amp;#39;/path&amp;#39;, function(req, res, next) { // handler code }); このハンドラ関数の第 3 パラメータ next は、Express が自動的に渡してくれる関数で、この関数を呼び出すことで、次に登録されているハンドラへ処理を委譲することができます。 app.get() に指定したハンドラの第 3 パラメータの next メソッドを呼び出すと、次のハンドラに処理を委譲することができます。 例えば、
app.get(&amp;#39;/test&amp;#39;, ...); app.get(&amp;#39;/test&amp;#39;, ...); のように、同じパスに対して、複数のハンドラを設定しておいて、条件に一致したときに次のハンドラへ処理を委譲させるといったことができます。 next() を明示的に呼び出さない場合は、最初に設定したハンドラしか呼び出されません。 下記の例では、/test/hello というパスでアクセスした場合にだけ、２番目のハンドラに処理を委譲します。
app.get(&amp;#39;/test/:id&amp;#39;, function(req, res, next) { if (req.params.id === &amp;#39;hello&amp;#39;) { next(); // delegate to the second handler } else { res.send(&amp;#39;1st handler&amp;#39;); } }); app.get(&amp;#39;/test/:id&amp;#39;, function(req, res) { res.send(&amp;#39;2nd handler&amp;#39;); });</description></item><item><title>Node.jsメモ: package.json による依存パッケージの管理方法まとめ</title><link>https://maku77.github.io/p/9m96xqi/</link><pubDate>Tue, 18 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9m96xqi/</guid><description>Node.js アプリケーションが使用する依存パッケージの情報は、package.json というファイルに記述します。
package.json ファイルのひな型を生成する (npm init) 下記のコマンドを実行すると、対話形式で package.json ファイルを作成することができます。
$ npm init 何も入力せずに Enter を連打していくと、以下のようなファイルが生成されます。
package.json { &amp;#34;name&amp;#34;: &amp;#34;sample&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;scripts&amp;#34;: { &amp;#34;test&amp;#34;: &amp;#34;echo \&amp;#34;Error: no test specified\&amp;#34; &amp;amp;&amp;amp; exit 1&amp;#34; }, &amp;#34;repository&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;BSD&amp;#34; } すでにカレントディレクトリに package.json がある場合でも、npm init は、単純な上書きはしないで、足りないプロパティだけ補ってくれます。 副次的な作用として、フォーマットの整形にも使えます。
最小限の package.json Node.js アプリケーションのマニフェストファイルである package.json には、最低限以下のような情報を記述しておきます。
package.json { &amp;#34;name&amp;#34;: &amp;#34;my-app&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;private&amp;#34;: true, &amp;#34;dependencies&amp;#34;: { &amp;#34;express&amp;#34;: &amp;#34;3.2.x&amp;#34;, &amp;#34;jade&amp;#34;: &amp;#34;*&amp;#34; } } アプリの名前 (name)、バージョン (version)、npm registry に公開しないこと (&amp;quot;private&amp;quot;: true)、依存するモジュール (dependencies) などを記載しています。</description></item><item><title>Node.jsメモ: Express の動作を環境ごとに切り替える（NODE_ENV 変数）</title><link>https://maku77.github.io/p/3eqz2eo/</link><pubDate>Sun, 09 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/3eqz2eo/</guid><description>Express は、NODE_ENV 環境変数を見て、現在の実行環境を判断する機能を持っています。 現在設定されている NODE_ENV の値は、app.get('env') で参照可能です。
app.js var express = require(&amp;#39;express&amp;#39;); var app = express(); console.log(app.get(&amp;#39;env&amp;#39;)); // development NODE_ENV は node コマンド実行時に、シェルから設定することができます。
$ NODE_ENV=development node app development $ NODE_ENV=production node app production 何も設定しなかった場合は、NODE_ENV の値はデフォルトで development になります。
$ node app development この値を利用して、実行環境ごとに異なる処理を実行することができます。 下記の例では、development 環境のときのみ、サーバ側のアクセスログをターミナルに表示するようにしています。
var logger = require(&amp;#39;morgan&amp;#39;); if (&amp;#39;development&amp;#39; == app.get(&amp;#39;env&amp;#39;)) { app.use(logger(&amp;#39;dev&amp;#39;)); } ☝️ ワンポイント Express 3 までは、app.configure() メソッドを使用することでも実行環境ごとの処理を記述することができましたが、Express 4 で app.configure() は削除されています。 代わりに上記のように、app.get('env') か、app.settings.env か、process.env.NODE_ENV を使用して実行環境を判断する必要があります。 環境ごとの振る舞いの違いを別のファイルにまとめておくのもよいでしょう。 例えば、以下のような設定ファイルを用意して、</description></item><item><title>Node.jsメモ: リバースプロキシ経由で Express サーバにアクセスしたときのクライアントのアドレスを取得する (x-forwarded-for)</title><link>https://maku77.github.io/p/hvoegru/</link><pubDate>Sun, 09 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/hvoegru/</guid><description>クライアントからの Node サーバーへのアクセスがリバースプロキシ経由になる場合、req.ip で取得できる IP アドレスは、リバースプロキシのアドレスになってしまいます。 これを防ぐには、Express の Application オブジェクトを使って次のように設定します。
app.set(&amp;#39;trust proxy&amp;#39;, true); この機能を使用する場合、リバースプロキシが X-Forwarded-For (XFF) ヘッダーをサポートしている必要があります。 X-Forwarded-For ヘッダーは、プロキシやロードバランサを経由したときに「元のクライアントの IP アドレス」をサーバ側に伝えるための事実上の標準ヘッダーです。</description></item><item><title>Node.jsメモ: Node.js で WebSocket サーバを作る（簡単な chat サーバ）</title><link>https://maku77.github.io/p/hfrkkyx/</link><pubDate>Wed, 05 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/hfrkkyx/</guid><description>WebSocket サーバは、接続中のすべてのクライアントに対して処理を行うことができます。 例えば、以下のようなプロパティがあります。
server.clientsCount &amp;ndash; 接続中のクライアント数 server.clients &amp;ndash; 接続中のクライアントのリスト すべてのクライアントに対してメッセージを送信すれば、簡単なチャットサーバになります。
サーバ側 (server.js) var ws = require(&amp;#39;websocket.io&amp;#39;); // WebSocket サーバの起動 var server = ws.listen(5000, function () { console.log(&amp;#39;Listening on port 5000&amp;#39;); }); // 各クライアントからの接続を処理 server.on(&amp;#39;connection&amp;#39;, function (client) { console.log(&amp;#39;Client connected: &amp;#39; + server.clientsCount); // クライアントからメッセージを受信した時 client.on(&amp;#39;message&amp;#39;, function (msg) { // 全クライアントに送信 server.clients.forEach(function (c) { if (c == null) return; // 接続が切れると null になっていることがある c.send(msg); }); }); // クライアントが切断した時 client.on(&amp;#39;close&amp;#39;, function () { console.</description></item><item><title>Node.jsメモ: Node.js で WebSocket サーバを作る（簡単な echo サーバ）</title><link>https://maku77.github.io/p/zrifcfx/</link><pubDate>Wed, 05 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/zrifcfx/</guid><description>ここでは、Node.js の websocket.io モジュールを使って、簡単な WebSocket echo サーバを作成する方法を説明します。 まず、websocket.io モジュールをインストールします。
websocket.io モジュールのインストール $ npm install websocket.io 下記は、クライアントから送られてきたメッセージ（テキスト）をそのまま送り返す、WebSocket による echo サーバの例です。
サーバ側 (server.js) var ws = require(&amp;#39;websocket.io&amp;#39;); // WebSocket サーバの起動 var server = ws.listen(5000, function () { console.log(&amp;#39;Listening on port 5000&amp;#39;); }); // 各クライアントからの接続を処理 server.on(&amp;#39;connection&amp;#39;, function (client) { console.log(&amp;#39;Client connected&amp;#39;); // クライアントからメッセージを受信した時 client.on(&amp;#39;message&amp;#39;, function (msg) { console.log(&amp;#39;Message from client: &amp;#39; + msg); client.send(msg); }); // クライアントが切断した時 client.on(&amp;#39;close&amp;#39;, function () { console.log(&amp;#39;Client disconnected&amp;#39;); }); // エラーが発生した時 client.</description></item><item><title>Node.jsメモ: WebSocket クライアントを作成する</title><link>https://maku77.github.io/p/iuah33v/</link><pubDate>Wed, 05 Mar 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/iuah33v/</guid><description>JavaScript の WebSocket API を使うときの流れは以下のようになります。
WebSocket コンストラクタでサーバに接続 イベントハンドラを設定 onopen: 接続時のイベント onclose: 切断時のイベント onmessage: メッセージ受信時のイベント onerror: エラー発生時のイベント 任意のタイミングで send(): データの送信 close(): 切断 次のサンプルでは、ws://echo.websocket.org/ に接続しています。 この WebSocket サーバは開発者向けに公開されており、WebSocket#send() で送信したメッセージをそのまま返す仕様になっています。
index.html &amp;lt;script&amp;gt; var socket = new WebSocket(&amp;#39;ws://echo.websocket.org/&amp;#39;); // 接続時のイベント socket.onopen = function (evt) { console.log(&amp;#39;Connected&amp;#39;); socket.send(&amp;#39;Hello 1&amp;#39;); socket.send(&amp;#39;Hello 2&amp;#39;); socket.send(&amp;#39;Hello 3&amp;#39;); socket.send(&amp;#39;Hello 4&amp;#39;); }; // 切断時のイベント socket.onclose = function (evt) { console.log(&amp;#39;Disconnected&amp;#39;); }; // メッセージ受信時のイベント socket.onmessage = function (evt) { console.log(evt.data); if (evt.data === &amp;#39;Hello 3&amp;#39;) { socket.</description></item><item><title>Node.jsメモ: mongoose と Express で RESTful Web API を作成する</title><link>https://maku77.github.io/p/ttx5vvz/</link><pubDate>Tue, 11 Feb 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ttx5vvz/</guid><description>以下のような HTTP リクエストをハンドルする RESTful Web API を、Express（Web サーバー）と mongoose（MongoDB）を使って作成するサンプルです。
GET http://localhost/memos &amp;hellip; 全てのメモを取得 GET http://localhost/memos/&amp;lt;id&amp;gt; &amp;hellip; 指定した ID のメモを取得 POST http://localhost/memos &amp;hellip; メモを作成 PUT http://localhost/memos/&amp;lt;id&amp;gt; &amp;hellip; メモの更新 DELETE http://localhost/memos/&amp;lt;id&amp;gt; &amp;hellip; メモを削除 下記のように Web サーバを起動することで、REST API の呼び出しに応答するようになります。
$ node app Listening on port 5000 app.js import express from &amp;#39;express&amp;#39;; import memos from &amp;#39;./routes/memos.js&amp;#39;; const app = express(); // Setup middlewares app.use(express.json()); // Handle POST messages // RESTful CRUD APIs app.post(&amp;#39;/memos&amp;#39;, memos.createMemo); // [C]REATE app.</description></item><item><title>Node.jsメモ: mongoose で MongoDB (1) mongoose をインストールする</title><link>https://maku77.github.io/p/wfrqz8r/</link><pubDate>Mon, 10 Feb 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wfrqz8r/</guid><description>mongoose のインストール mongoose は Node.js で MongoDB を使用するためのモジュールです。 npm コマンドを使用して簡単にインストールすることができます。
$ npm install mongoose mongoose で MongoDB データベースへ接続する 下記は、mongoose を使用して MongoDB のデータベースに接続する例です。
sample.js import mongoose from &amp;#39;mongoose&amp;#39;; // 接続後のコールバック mongoose.connection.once(&amp;#39;open&amp;#39;, (e) =&amp;gt; { console.log(&amp;#39;connected&amp;#39;); }); // エラー発生時のコールバック mongoose.connection.on(&amp;#39;error&amp;#39;, (err) =&amp;gt; { console.log(`ERROR: ${err.message}`); }); mongoose.connect(&amp;#39;mongodb://localhost/testdb&amp;#39;); mongoose.connect() により MongoDB へ接続し、指定したデータベースにアクセスできるようになります。 データベースへ接続するときの接続パスは、以下のように指定します。
mongodb://user:pass@host:port/dbname 上記のサンプルコードでは、接続時とエラー発生時のイベントハンドラを設定しています。 mongod などが起動していない場合などはエラーが発生し、以下のように表示されます。
$ node sample.js ERROR: failed to connect to [localhost:27017] mongoose のモデルクラス モデルクラスを作成する mongoose で MongoDB のドキュメントを扱うには、先にモデルクラスとして各フィールドの型などを定義しておく必要があります。 以下のサンプルでは、Memo という名前のモデルクラスを定義しています。</description></item><item><title>Node.js での例外処理: try ～ catch による例外処理の基本</title><link>https://maku77.github.io/p/uqx7hq7/</link><pubDate>Sat, 25 Jan 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/uqx7hq7/</guid><description>実行時のエラーをハンドルする Node.js での処理中に何かエラーが発生した場合、そのエラーをハンドルするコードがないと、デフォルトではスタックトレースが表示されて処理が終了します。 明示的にエラーをハンドルするには、try ~ catch の構文を使用します (Node.js 特有ではなく、通常の JavaScript の構文です)。 以下の例では、未定義の関数を呼び出したときに発生する ReferenceError をハンドルしています。
例: ReferenceError のハンドル try { foo(); } catch (err) { console.log(err.name + &amp;#39;: &amp;#39; + err.message); process.exit(-1); } 実行結果 ReferenceError: foo is not defined Error オブジェクト catch ブロックで受け取る Error オブジェクトは、V8 (JavaScript Engine) でネイティブに定義されているオブジェクトで、以下のようなプロパティを参照できます。
err.name → エラー名 err.message → エラーメッセージ err.toString() → エラー名: エラーメッセージ err.stack → スタックトレース err.name の例 ReferenceError err.message の例 foo is not defined err.toString() の例 ReferenceError: foo is not defined err.</description></item><item><title>Node.js での例外処理: Uncaught Exception（未捕捉例外）をハンドルする</title><link>https://maku77.github.io/p/4zwjrzz/</link><pubDate>Sat, 25 Jan 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4zwjrzz/</guid><description>Uncaught Exception を処理する ハンドルされていない例外を最上位でまとめてハンドルするには、以下のように process グローバルオブジェクトで uncaughtException イベントをハンドル するよう設定します。
参考: Node.js - Process Event: &amp;lsquo;uncaughtException&amp;rsquo; sample.js process.on(&amp;#39;uncaughtException&amp;#39;, function (err) { console.log(err.name); console.log(err.message); console.log(err.toString()); console.log(&amp;#39;----------------------------------&amp;#39;); console.log(err.stack); process.exit(-1); }); foo(); // 未定義の関数を呼び出してみる 実行結果 ReferenceError foo is not defined ReferenceError: foo is not defined ---------------------------------- ReferenceError: foo is not defined at Object.&amp;lt;anonymous&amp;gt; (/Users/maku/sandbox/test.js:10:1) at Module._compile (module.js:456:26) at Object.Module._extensions..js (module.js:474:10) at Module.load (module.js:356:32) at Function.Module._load (module.js:312:12) at Function.Module.runMain (module.js:497:10) at startup (node.js:119:16) at node.js:902:3 上記の例では、uncaughtException のハンドラ内で process.</description></item><item><title>Node.jsメモ: node-sqlite3 で SQLite データベースを扱う</title><link>https://maku77.github.io/p/oxxpf3h/</link><pubDate>Fri, 24 Jan 2014 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/oxxpf3h/</guid><description>node-sqlite3 のインストール Node.js で SQLite を使用するためのライブラリとして node-sqlite3 があります。 以下のようにインストールします。
$ npm install sqlite3 node-sqlite3 の使用例 下記は、dic.sqlite3 という DB ファイルから、words テーブルのレコードを取得するサンプルです。
import sqlite3 from &amp;#39;sqlite3&amp;#39;; const db = new sqlite3.Database(&amp;#39;dic.sqlite3&amp;#39;); db.all(&amp;#39;SELECT en, jp FROM words&amp;#39;, (err, rows) =&amp;gt; { if (err) { console.log(err); return; } rows.forEach((row) =&amp;gt; { console.log(`${row.en} ${row.jp}`); }); }); node-sqlite3 による逐次処理&amp;quot; node-sqlite3 による各種 DB 処理は、非同期に実行されるようになっています。 例えば、以下のように SQL ステートメントを実行すると、CREATE TABLE と INSERT 処理が非同期に実行されるため、エラーが発生します。
間違った例 import sqlite3 from &amp;#39;sqlite3&amp;#39;; const db = new sqlite3.</description></item><item><title>Node.jsメモ: npm run で任意のコマンドを実行する (npm run/start)</title><link>https://maku77.github.io/p/9kiba2c/</link><pubDate>Sat, 28 Dec 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9kiba2c/</guid><description>npm run-script とは package.json の scripts プロパティでスクリプトを定義しておくと、npm run &amp;lt;スクリプト名&amp;gt; でそのスクリプトを実行できるようになります。 run は run-script の省略形であり、下記は同じ意味を持ちます。
$ npm run hello $ npm run-script hello 参考: npm-run | npm Docs npm run で Hello World 下記は、簡単な echo コマンドを実行するスクリプトの定義例です。 スクリプト名は hello にしています。
package.json { &amp;#34;scripts&amp;#34;: { &amp;#34;hello&amp;#34;: &amp;#34;echo Hello!&amp;#34; } } npm run に続けてスクリプト名を指定すると、そのスクリプトを実行できます。
実行例 C:\&amp;gt; npm run hello &amp;gt; node@1.0.0 hello C: &amp;gt; echo Hello! Hello! 途中でコマンド実行の過程が表示されていますが、出力をスクリプトの実行結果だけに絞りたいときは、--silent オプションを付けて実行します。
C:\&amp;gt; npm run hello --silent Hello!</description></item><item><title>Node.jsメモ: async.js による非同期処理</title><link>https://maku77.github.io/p/4fzs5fs/</link><pubDate>Mon, 16 Dec 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4fzs5fs/</guid><description>async.js とは JavaScript のオープンソースライブラリである async.js を使用すると、
複数の非同期関数を指定した順に実行する 複数の非同期関数を同時に実行してすべての処理が終わるのを待つ など、非同期処理のフロー制御を簡単に行うことができます。
async モジュールは次のようにインストールできます。
$ npm install async 複数の非同期処理の結果を同時に取得する(async.parallel) async.parallel(tasks, [callback]) を使用すると、複数の非同期関数を並行して実行し、すべての処理が終了したときにその結果をまとめて受け取ることができます。
sample.js import async from &amp;#39;async&amp;#39;; function func1(callback) { setTimeout(() =&amp;gt; { callback(null, &amp;#39;Result1&amp;#39;); }, 2000); } function func2(callback) { setTimeout(() =&amp;gt; { callback(null, &amp;#39;Result2&amp;#39;); }, 1000); } async.parallel([func1, func2], (err, results) =&amp;gt; { console.log(`error = ${err}`); console.log(`results = ${results}`); }); 実行結果 $ node sample error = null results = Result1,Result2 実行する非同期関数は、第一引数としてコールバック関数を受け取るようにし、非同期処理が終わった時にそのコールバック関数を呼び出すように実装する必要があります。その際、コールバック関数の引数には、非同期処理の結果として、（発生した場合は）エラーあるいは、結果を渡します。</description></item><item><title>Node.jsメモ: request モジュールを使用して HTTP 通信を行う</title><link>https://maku77.github.io/p/5y9mne4/</link><pubDate>Sat, 14 Dec 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/5y9mne4/</guid><description>request モジュールのインストール オープンソースとして公開されている request モジュールを使用すると、標準の http モジュールをそのまま使うより手軽に HTTP リクエストを発行することができます。 最新バージョンの request モジュールは以下のようにインストールできます。
$ npm install request package.json の dependencies 情報も同時に更新するには、--save オプションを付けてインストールします。
$ npm install --save request 参考: package.json で依存パッケージを管理する request モジュールの使い方の基本 以下は、request モジュールを使用して www.yahoo.co.jp に HTTP でアクセスするサンプルです。
sample.js var request = require(&amp;#39;request&amp;#39;); request.get(&amp;#39;http://www.yahoo.co.jp&amp;#39;, function(err, res, body) { if (err) { console.log(&amp;#39;Error: &amp;#39; + err.message); return; } console.log(body); }); Web API の呼び出しなどで、HTTP リクエスト時に JSON データを送る場合は、以下のようにします。
var request = require(&amp;#39;request&amp;#39;); var qs = require(&amp;#39;querystring&amp;#39;); var query = { aaa: 100, bbb: 200 }; var url = &amp;#39;http://example.</description></item><item><title>Node.jsメモ: Express で CORS 設定を行う（クロスドメインでのアクセスを許可する）</title><link>https://maku77.github.io/p/unsuyqg/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/unsuyqg/</guid><description>Express で特定のリクエスト時にクロスドメイン通信を許すには、下記のように特定のリクエストに対する response で Access-Control-Allow-Origin ヘッダーを追加します。
const express = require(&amp;#39;express&amp;#39;); const app = express(); app.get(&amp;#39;/books&amp;#39;, function (request, response) { response.header(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); response.json(books); }); アプリケーション全体で CORS 設定を行うには、次のように app.use() を使ってすべてのレスポンスに適用するようにします。
// CORS settings. const allowCrossDomain = function(req, res, next) { res.header(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;*&amp;#39;); res.header(&amp;#39;Access-Control-Allow-Headers&amp;#39;, &amp;#39;X-Requested-With&amp;#39;); next(); } app.use(allowCrossDomain); 特定のドメインからのアクセスだけを許可するには、以下のようにします。
example.com ドメインのサイトからの JavaScript 通信を許可 res.header(&amp;#39;Access-Control-Allow-Origin&amp;#39;, &amp;#39;https://example.com&amp;#39;); 特定のサブドメインからのアクセスだけを許可するには、以下のようにします。 Access-Control-Allow-Origin ヘッダーに指定できるドメインは 1 つだけなので、プログラム内で動的にサブドメイン名を設定する必要があります。
// CORS settings. const allowCrossDomain = function(req, res, next) { if (req.headers.origin.endsWith(&amp;#39;.example.com&amp;#39;)) { res.</description></item><item><title>Node.js スクリプトにシェバング (#!) を付けてコマンドとして起動できるようにする</title><link>https://maku77.github.io/p/ptactsj/</link><pubDate>Tue, 19 Nov 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ptactsj/</guid><description>一般的なスクリプト言語と同様に、Node.js で動作させるアプリもシェバング (#!) で node コマンドを指定しておくことができます。
app.js #!/usr/bin/env node console.log(&amp;#39;Hello&amp;#39;); あとは、.js ファイルに実行権限を付けてやれば、コマンドとして扱うことができるようになります。
実行方法 $ chmod +x app.js $ ./app.js Hello</description></item><item><title>Node.jsメモ: パスを結合する (path.join)</title><link>https://maku77.github.io/p/32q8w98/</link><pubDate>Tue, 19 Nov 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/32q8w98/</guid><description>ディレクトリ名を表すパスと、ディレクトリ名あるいはファイル名を結合するには、Node.js の標準モジュール path が提供している path.join メソッドを使用します。
例: 実行中のスクリプトのディレクトリ名と hoge.txt というファイル名を結合したパスを取得 import path from &amp;#39;node:path&amp;#39;; const filepath = path.join(__dirname, &amp;#39;hoge.txt&amp;#39;); console.log(filepath); 実行結果 D:\y\sandbox\node&amp;gt; node sample D:\y\sandbox\node\hoge.txt</description></item><item><title>Node.jsメモ: jQuery クライアントと Express サーバで JSON データを送受信する例</title><link>https://maku77.github.io/p/twrqbe3/</link><pubDate>Tue, 05 Nov 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/twrqbe3/</guid><description>クライアント (jQuery) からサーバ (Express) への JSON データ送信（GET メソッド） クライアント（送信側） var jsonData = { aaa: 100, bbb: {ccc: 200} }; $.ajax({ type: &amp;#39;GET&amp;#39;, url: &amp;#39;http://localhost:7000/api&amp;#39;, data: jsonData, contentType: &amp;#39;application/json&amp;#39;, // 送信側のヘッダ情報 success: function(data, status, xhr) { alert(&amp;#39;OK&amp;#39;); }, error: function(xhr, status, err) { alert(&amp;#39;ERROR&amp;#39;); } }); Express サーバ（受信側） app.get(&amp;#39;/api&amp;#39;, function(req, res) { var jsonData = req.query; console.dir(jsonData); res.send(&amp;#39;&amp;#39;); // とりあえずレスポンス処理を終わらせる }); サーバ (Express) からクライアントへの JSON データ送信（GET メソッド） Express サーバ（送信側） app.get(&amp;#39;/api&amp;#39;, function(req, res) { var obj = {aaa:100, bbb:200}; res.</description></item><item><title>Node.jsメモ: http 標準モジュールを使用して HTTP 通信を行う</title><link>https://maku77.github.io/p/vo8hdpa/</link><pubDate>Mon, 04 Nov 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/vo8hdpa/</guid><description>http モジュールの基本的な使い方 下記は、Node.js の標準モジュールである http モジュールを使用して HTTP 通信を行う例です。
レスポンスのデータは、分割された data イベントとして受信されるので、data イベントが呼び出されるたびに受信したデータを結合していく必要があります。 短いデータを受信する場合は結合しなくても全体を受信できてしまうため、この点に気付きにくいので注意が必要です。
var http = require(&amp;#39;http&amp;#39;); var uri = &amp;#39;http://www.example.com/&amp;#39;; http.get(uri, function(res) { console.log(&amp;#39;Status: &amp;#39; + res.statusCode); console.log(&amp;#39;Headers: &amp;#39; + JSON.stringify(res.headers)); res.setEncoding(&amp;#39;utf8&amp;#39;); var body = &amp;#39;&amp;#39;; // Receive body chunks res.on(&amp;#39;data&amp;#39;, function (chunk) { body += chunk; }); // Finish receiving a body res.on(&amp;#39;end&amp;#39;, function() { console.log(body); }); }); http モジュールでリクエスト時の HTTP ヘッダを指定する HTTP リクエストの内容をより詳細に設定したい場合は、http.get() の第一引数に URI ではなく、オプションオブジェクトを指定します。
下記の例では、HTTP GET 時のリクエストヘッダとして user-agent などを設定しています。</description></item><item><title>Node.jsメモ: Express で Basic 認証を有効にする (basicAuth)</title><link>https://maku77.github.io/p/mv6umxp/</link><pubDate>Tue, 29 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/mv6umxp/</guid><description>Express に標準で付属している basicAuth ミドルウェアを使用すると、簡単に Basic 認証をかけることができます。 次の例では、サイト全体に Basic 認証をかけています（ユーザー名: user、パスワード: pass）。
app.js const express = require(&amp;#39;express&amp;#39;); const app = express(); app.use(express.basicAuth(&amp;#39;user&amp;#39;, &amp;#39;pass&amp;#39;)); app.get(&amp;#39;/&amp;#39;, function(req, res) { res.send(&amp;#39;Private&amp;#39;); }); app.listen(3000, function() { console.log(&amp;#39;Listening on port 3000&amp;#39;); }); 特定のパス以下にだけ Basic 認証をかけるには、app.get() や app.post() でルーティング設定するときに basicAuth ミドルウェアのオブジェクトを渡します。 下記の例では、/private という URI でアクセスしたときに Basic 認証がかかります。
const auth = express.basicAuth(&amp;#39;user&amp;#39;, &amp;#39;pass&amp;#39;); // ここには Basic 認証をかけない app.get(&amp;#39;/&amp;#39;, function(req, res) { res.send(&amp;#39;Public information&amp;#39;); }); // ここに Basic 認証をかける app.</description></item><item><title>Node.jsメモ: Express で GET/POST リクエストをハンドルする</title><link>https://maku77.github.io/p/7wjhpud/</link><pubDate>Tue, 29 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7wjhpud/</guid><description>Express によるリクエストハンドリング Express の Application オブジェクトのメソッドである app.get() や app.post() を使うと、HTTP の GET/POST リクエストをハンドルすることができます。
app.get(&amp;#39;/path&amp;#39;, function(req, res) { // GET リクエストをハンドルするコード }); app.post(&amp;#39;/path&amp;#39;, function(req, res) { // POST リクエストをハンドルするコード }); HTTP の GET/POST メソッドで送られてきたデータは、Request オブジェクトの以下のプロパティを使って取得することができます。
req.query['name'] &amp;hellip; GET メソッドの場合（URL のクエリ文字列で送られてくるデータ） req.body['name'] &amp;hellip; POST メソッドの場合（リクエストボディで送られてくるデータ） 上記の代わりに req.param() メソッドを使用すると、GET/POST の区別無しにパラメータ取得することができますが、できれば GET/POST は明示的に区別して取得する方がよいでしょう（URI の部分文字列を取得する req.params プロパティと混同しないようにしてください）。
GET メソッドにおけるデータ受信の例 次のサンプルでは、public/memo.html のフォームから、/memo/create という URI に対して GET でデータを送ります。
public/memo.html（GET でデータを送るフォーム） &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;html&amp;gt; &amp;lt;b&amp;gt;New Memo&amp;lt;/b&amp;gt; &amp;lt;form method=&amp;#34;get&amp;#34; action=&amp;#34;/memo/create&amp;#34;&amp;gt; &amp;lt;label for=&amp;#34;title&amp;#34;&amp;gt;Title&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;title&amp;#34; name=&amp;#34;memo[title]&amp;#34; size=&amp;#34;50&amp;#34;&amp;gt;&amp;lt;/input&amp;gt;&amp;lt;br&amp;gt; &amp;lt;label for=&amp;#34;body&amp;#34;&amp;gt;Body&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;body&amp;#34; name=&amp;#34;memo[body]&amp;#34; size=&amp;#34;50&amp;#34;&amp;gt;&amp;lt;/input&amp;gt;&amp;lt;br&amp;gt; &amp;lt;button type=&amp;#34;submit&amp;#34;&amp;gt;Submit&amp;lt;/button&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/html&amp;gt; app.</description></item><item><title>Node.jsメモ: Express でテンプレートエンジンを使用する (Jade)</title><link>https://maku77.github.io/p/gnewjs4/</link><pubDate>Mon, 28 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/gnewjs4/</guid><description>Jade テンプレートエンジンを使用すると、HTML をより簡潔に記述することができます。 Jade フォーマットでの記述はインデントベースで行うため、HTML タグの開始・終了タグを明示的に記述する必要がなくなります。 Express では、Jade をはじめとする様々なテンプレートエンジンを利用することができますが、ここでは Jade を使用する方法について説明します。
Node パッケージのインストール まず、Express と Jade を使用するために、関連パッケージをインストールしておきます。
$ npm install express $ npm install jade Express から Jade を使用する Express では Node.js で使用可能なテンプレートエンジンをすべて利用することができます。 例えば、テンプレートエンジンとして Jade を使用するには、以下のように Application#set('view engine', ...) を使って変数設定しておく必要があります。
// view engine の指定。Jade テンプレートエンジンを使用する場合は &amp;#39;jade&amp;#39; app.set(&amp;#39;view engine&amp;#39;, &amp;#39;jade&amp;#39;); // テンプレートファイル (*.jade) を格納するディレクトリの指定 app.set(&amp;#39;views&amp;#39;, path.join(__dirname, &amp;#39;views&amp;#39;)); View ファイル（テンプレートファイル）を使って HTML を出力するには、Response#render() メソッドを使用します（拡張子 .jade は省略できます）。
app.get(&amp;#39;/&amp;#39;, function(req, res) { // Render by using /views/index.</description></item><item><title>Node.jsメモ: Express で静的ファイル（static ファイル）をホスティングする</title><link>https://maku77.github.io/p/sururg6/</link><pubDate>Mon, 28 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/sururg6/</guid><description>Express で static ファイルを使用するには、標準で組み込まれている static ミドルウェアを使用します。 例えば、以下のようなディレクトリ構成で、public ディレクトリに JavaScript や CSS などの static ファイルを格納するとします。
app.js public/ +-- images/ +-- js/ +-- css/ static ミドルウェアの基本的な使い方は、次のように Application オブジェクトの use() を使ってミドルウェアの設定を行うだけです。 とっても簡単です（Express 4 から、Express 用の各種ミドルウェアが独立したパッケージに分かれましたが、static モジュールだけは Express に含まれています）。
public ディレクトリを静的ファイルのルートに設定する app.use(express.static(__dirname + &amp;#39;/public&amp;#39;)); 例えば、サーバ上の public ディレクトリに images/hoge.jpg を置いた場合は、http://localhost:3000/images/hoge.jpg という URI でアクセスできるようになります。 URL には public というパスは含まれないことに注意してください。 URL にプレフィックスを入れたい場合は、下記のようにミドルウェア設定時にプレフィックスを指定します。
app.use(&amp;#39;/assets&amp;#39;, express.static(__dirname + &amp;#39;/public&amp;#39;)); このようにすると、サーバ上の public/images/hoge.jpg にアクセスする URL は、http://localhost:3000/assets/images/hoge.jpg となります。
下記は全体のコードです。
app.js var express = require(&amp;#39;express&amp;#39;); var app = express(); app.</description></item><item><title>Node.jsメモ: Express サーバの Internal Server Error を分かりやすく HTTP ページで表示する</title><link>https://maku77.github.io/p/4duroxg/</link><pubDate>Sun, 27 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4duroxg/</guid><description>Express サーバで、インターナルサーバエラー (5xx) が発生した場合、クライアントの Web ブラウザには、デフォルトでそっけないテキスト形式のスタックトレースが表示されます。 Express が提供している errorHandler ミドルウェアを適用すると、もう少しリッチな Internal Server Error のページを表示できます。
app.use(app.router); app.use(express.errorHandler()); 表示例（サーバ側で存在しないメソッド hoge を呼び出した場合） Express 4 では、ミドルウェアが Express から独立したモジュール (errorhandler) に分けられたので、下記のようにすることがドキュメントに記載されています。
// Express 4 以降 var errorhandler = require(&amp;#39;errorhandler&amp;#39;); app.use(errorhandler()); ただし、現時点 (2014-09-22) では errorhandler ミドルウェアはうまく動作しないようです。 単純に、NODE_ENV=development（デフォルト）でクライアントの Web ブラウザ上にスタックトレースが表示され、NODE_ENV=production でスタックトレース表示が抑制されるように動作します。
下記バージョンで確認:
node 0.10.32 express 4.9.4 errorhandler 1.2.0</description></item><item><title>Node.jsメモ: mongojs で MongoDB を扱う</title><link>https://maku77.github.io/p/exs9wor/</link><pubDate>Fri, 25 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/exs9wor/</guid><description>Node.js で実行する JavaScript から MongoDB にアクセスするには、Node.js Driver をインストールする必要があります。 Node.js Driver の一つに、mongojs があります。 mongojs を使うと、mongo クライアントと同様のインタフェースで MongoDB にアクセスすることができます。
mongojs のインストール mongojs は下記のように npm コマンドで簡単にインストールすることができます。
$ npm install mongojs # インストール $ npm list # 確認 mongojs の使用例 main.js import mongojs from &amp;#39;mongojs&amp;#39;; const db = mongojs.connect(&amp;#39;mydb&amp;#39;, [&amp;#39;mycollection&amp;#39;]); // すべての Document を削除 db.mycollection.remove(); // Document 追加 db.mycollection.insert({name: &amp;#39;maku&amp;#39;}); db.mycollection.insert({name: &amp;#39;moja&amp;#39;}); // Document を検索 db.mycollection.find((err, docs) =&amp;gt; { if (err) { console.log(&amp;#39;Error!&amp;#39;); return; } docs.</description></item><item><title>Node.jsメモ: Express で Web サーバを作成する</title><link>https://maku77.github.io/p/7ee8e5h/</link><pubDate>Tue, 22 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7ee8e5h/</guid><description>Express のメインオブジェクトは Application オブジェクトと呼ばれ、以下のようにして生成します。 慣習的に変数名は app にします。
var express = require(&amp;#39;express&amp;#39;); var app = express(); Web サーバに対して GET メソッドによるリクエストが来たときの処理は、以下のように指定します。
app.get(&amp;#39;/&amp;#39;, function(req, res) { res.send(&amp;#39;Hello Express!&amp;#39;); }); 上記では、ルートパスにアクセスしたときのレスポンスを定義していますが、Backbone.js や CodeIgniter のように、柔軟に URI ルーティング設定を行うことができます。
server.js var express = require(&amp;#39;express&amp;#39;); var app = express(); app.get(&amp;#39;/&amp;#39;, function(req, res) { res.send(&amp;#39;Hello Express!&amp;#39;); }); app.get(&amp;#39;/hello/:name&amp;#39;, function(req, res) { res.send(&amp;#39;Hello &amp;#39; + req.params.name); }); app.listen(3000, function() { console.log(&amp;#39;Express server started on port 3000...&amp;#39;); }); 実行 $ node server.</description></item><item><title>Node.jsメモ: Express の特徴とインストール</title><link>https://maku77.github.io/p/h5yxgh9/</link><pubDate>Mon, 21 Oct 2013 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/h5yxgh9/</guid><description>Express の特徴 Express は Node.js で簡単に Web サーバを構築できるようにするためのモジュールで、下記のような機能を備えています。
URI ルーティング / RESTful インタフェース セッション / クッキー管理 キャッシュ管理 ロギング MIME タイプ テンプレート言語（Pug など） 認証 この記事は 2013 年頃に書き始めたものですが、2020 年になっても、Node.js 用の Web サーバーモジュールとして不動の地位を確立しています。 Express の開発経緯は以下の通りです。
Express は Ruby の Sinatra にインスパイアされて開発されました。 Node 自体に Web server API はありますが、Low level すぎて使いにくいです。Express モジュールの登場により、簡単に Web server を構築できるようになりました。 かつて、似たようなプロジェクトとして、Ruby の Rack に影響された Connect という Node module もありましたが、2010 年に Express と Connect の両方のプロジェクトに参加していた T.J. Holowaychuk が統合して Express v1.0.0 になりました。 Express のメインモジュール (express) はごく基本的な機能だけを提供しており、拡張モジュールを組み合わせて、機能を追加していく方法を採用しています。</description></item><item><title>Node.jsメモ: Node.js でお手軽リバースプロキシを作る (http-proxy)</title><link>https://maku77.github.io/p/7i26pjh/</link><pubDate>Fri, 07 Dec 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7i26pjh/</guid><description>Node.js の http-proxy モジュールについて Node.js の node-http-proxy モジュールを使うと、簡単にリバースプロキシを作ることができます。
nodejitsu/node-http-proxy: A full-featured http proxy for node.js Squid や Apache などを使用してプロキシサーバを立ち上げる方法もありますが、Node.js でプロキシサーバを作成する利点は以下のようなものがあります（本家 README.md より抜粋）。
Forward proxy も Reverse proxy も簡単に作れます オーバヘッドも Latency も少ないです JSON ベースで簡単に設定できます HTTPS をサポートしています WebSockets をサポートしています node-http-proxy によるリバースプロキシの作成 http-proxy モジュールのインストール $ npm install http-proxy myproxy.js（リバースプロキシの実装） var httpProxy = require(&amp;#39;http-proxy&amp;#39;); httpProxy.createServer(80, &amp;#39;localhost&amp;#39;).listen(8080); 実行例 $ node myproxy.js これで、localhost:8080 へのアクセスが、localhost:80 へ転送されるようになります。 リバースプロキシが 2 行で書けた！ ٩(๑❛ᴗ❛๑)۶ わーぃ
もうちょっと高度に振り分けてみる さらに拡張して、サーバアクセス時のホスト名に応じて、別々のポートへ処理を振り分けるようにしてみます（バーチャルホスト）。
aaa.example.com としてアクセスしてきたら 8000 ポートに振り分け bbb.</description></item><item><title>Node.jsメモ: プロキシ経由の HTTP 通信を行う (request モジュール)</title><link>https://maku77.github.io/p/y2oxwej/</link><pubDate>Fri, 07 Dec 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/y2oxwej/</guid><description>request モジュールによるプロキシ経由の HTTP アクセス プロキシ経由で HTTP アクセスするときは、request モジュールを使うとお手軽です。
https://github.com/mikeal/request/blob/master/README.md プロキシ経由で HTTP GET var request = require(&amp;#39;request&amp;#39;); var proxy = request.defaults({&amp;#39;proxy&amp;#39;: &amp;#39;http://proxy.example.com:8080/&amp;#39;}) proxy.get(&amp;#39;http://www.google.com/&amp;#39;, function (error, response, body) { if (!error &amp;amp;&amp;amp; response.statusCode == 200) { console.log(body); } }); コード内でプロキシ設定を行うのではなく、環境変数で設定しておくことも可能です。
https://github.com/request/request#controlling-proxy-behaviour-using-environment-variables HTTP_PROXY (http_proxy) HTTPS_PROXY (https_proxy) NO_PROXY (no_proxy) bash における設定例 export http_proxy=http://proxy.example.com:8080/ export https_proxy=http://proxy.example.com:8080/ export no_proxy=google.com, yahoo.com 応用例: HTTP サーバからのプロキシ経由 HTTP アクセス Node.js で立ち上げた HTTP サーバからプロキシ経由でアクセスすることもできます。
var http = require(&amp;#39;http&amp;#39;); var request = require(&amp;#39;request&amp;#39;); var proxy = request.</description></item><item><title>Node.jsメモ: 環境変数を参照する (process.env)</title><link>https://maku77.github.io/p/e44uun8/</link><pubDate>Fri, 07 Dec 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/e44uun8/</guid><description>Node.js で環境変数を扱いたいときは、process.env オブジェクトを参照します。 process モジュールはデフォルトで参照できるようになっているので、require でモジュールを読み込む必要はありません。
指定した環境変数を取得する process.env.環境変数名 とすれば、任意の環境変数を参照できます。
$ node &amp;gt; console.log(process.env.HOME); D:\x\home 下記は、環境変数 HTTP_PROXY の設定の有無に応じて処理を振り分ける例です。
if (process.env.HTTP_PROXY != undefined) { // Proxy 環境で動作している場合 } else { // Proxy 環境ではない場合 } 環境変数が指定されていない場合のデフォルト値 環境変数が設定されていない場合（undefined の場合）にデフォルト値を設定したいのであれば、下記のように ??（Null 合体演算子）を使います。
const port = process.env.MYSERVER_PORT ?? 50000; ?? 演算子は ES2020 で導入された Nullish Coalescing という仕組みで、ある変数の値を参照しつつ、その値が undefined あるいは null の場合に、右側に指定した値を代わりに返してくれます。 上の例の場合は、環境変数 MYSERVER_PORT が設定されていないときに、デフォルトのポート番号として 50000 が使用されます。
?? 演算子が導入される前は、次のように undefined 判定を行う必要がありました。
let port = process.env.MYSERVER_PORT; if (typeof port === &amp;#39;undefined&amp;#39;) port = 50000; // 簡易的に if (port !</description></item><item><title>Node.jsメモ: npm コマンドで Node.js のパッケージをインストール／アンインストールする (npm install, uninstall)</title><link>https://maku77.github.io/p/2dua65s/</link><pubDate>Tue, 27 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/2dua65s/</guid><description>npm による Node パッケージのインストール (npm install) Node.js の環境で追加パッケージをインストールするには、Node Package Manager（npm コマンド）を使用します。 下記のようなコマンドで、Node パッケージをインストールできます。 公開されている Node パッケージは、The NPM Registry というサイトで検索することができます。
$ npm install &amp;lt;package_name&amp;gt; 上記のようにインストールしたパッケージは、カレントディレクトリ以下の node_modules ディレクトリに格納されます。 例えば、socket.io パッケージをインストールした場合は、node_modeles/socket.io ディレクトリ内に関連ファイルが格納されます。 また、socket.io が依存しているパッケージがある場合は、自動的に node_modules/socket.io/node_modules 以下にインストールされます。
node_modules ディレクトリ以下にすべてが格納されるので、npm コマンドによってそれ以外のディレクトリが汚染されてしまう心配をする必要がありません。 また、別の記事で紹介している package.json というファイルに必要なパッケージを記述しておくことにより、1 コマンドで依存パッケージをインストールできるため、Node.js を使用したアプリケーションを配布するときは、node_modules ディレクトリ以下の外部パッケージを配布する必要はありません。
例: socket.io パッケージのインストール $ npm install socket.io ... socket.io@0.9.11 node_modules\socket.io ├── policyfile@0.0.4 ├── redis@0.7.3 └── socket.io-client@0.9.11 (xmlhttprequest@1.4.2, uglify-js@1.2.5, active-x-obfuscator@0.0.1, ws@0.4.23) 例: restify パッケージのインストール $ npm install restify restify@1.4.4 node_modules\restify ├── byline@2.</description></item><item><title>Node.jsメモ: npm コマンド用に HTTP プロキシを設定する (npm config)</title><link>https://maku77.github.io/p/45tu88x/</link><pubDate>Mon, 26 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/45tu88x/</guid><description>プロキシ経由でインターネットに接続しなければいけない環境（企業内ネットワークなど）では、npm コマンドのプロキシ設定を行う必要があります。 これをやっておかないと、npm install コマンドによるネットワーク経由でのパッケージのインストールができません。
プロキシを設定する $ npm config set proxy http://proxy.example.com:8080/ プロキシ設定を削除する $ npm config delete proxy # 設定を削除する場合 現状のプロキシ設定を確認する $ npm config get proxy http://proxy.example.com:8080/</description></item><item><title>Node.js をインストールする</title><link>https://maku77.github.io/p/z5ap5bf/</link><pubDate>Sun, 25 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/z5ap5bf/</guid><description>Node.js とは Node.js は、JavaScript によって記述されたプログラム（スクリプト）を実行するための実行環境です。 JavaScript は、元々は Web ブラウザ内のコンテキストで実行されるスクリプト言語として開発されたものですが、Node.js のランタイム (Windows の場合は node.exe) を使用すると、ネイティブな実行環境で、JavaScript のプログラムを実行することができます。 Python や Ruby のような実行環境が、JavaScript 言語にも提供されたと考えると分かりやすいです。 例えば、Python によるプログラムは以下のように実行しますが、
$ python sample.py 同様に JavaScript で記述したプログラムを、下記のように実行できます。
$ node sample.js Node.js は、内部的には下記のような構成要素で成り立っています。
V8 — Google 製の JavaScript 実行エンジン。 libuv — 非同期イベントライブラリ。Node.js の作者の Ryan Dahl によって作成された。 Node.js では、libuv をベースとする非同期 I/O の仕組みによって、シングルスレッドながらも多くの接続を処理することができるようになっており、サーバサイドのプログラミング言語としても注目を集めています。
Node.js のインストール 各 OS 用の Node.js インストーラが提供されています。 下記のサイトからダウンロードして実行するだけで簡単にインストールできます。 複数バージョンの Node.js 実行環境をインストールしたい場合は、nvm というコマンドラインツールを使って Node.js をインストール してください。
Node.js - https://nodejs.org/ Node.js の実行環境は、デフォルトで下記のようなディレクトリにインストールされます。</description></item><item><title>Node.jsメモ: http 標準モジュールを使用して HTTP サーバを立てる</title><link>https://maku77.github.io/p/7cmeoeh/</link><pubDate>Mon, 19 Nov 2012 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7cmeoeh/</guid><description>http モジュールによる HTTP サーバの基本 以下は Node.js の標準モジュールである http モジュールを使用して、簡単な Web サーバを立ち上げるサンプルです。 node コマンドで実行し、localhost:51200 というアドレスに Web ブラウザでアクセスすると、Hello World と表示されます。
server.js var http = require(&amp;#39;http&amp;#39;); var server = http.createServer(function (req, res) { res.writeHead(200, {&amp;#39;Content-Type&amp;#39;: &amp;#39;text/plain&amp;#39;}); res.write(&amp;#39;Hello World\n&amp;#39;); res.end(); }); server.listen(51200); console.log(&amp;#39;Server running at localhost:51200&amp;#39;); http.createServer() に渡した関数は、リクエストを受けるたびに呼び出されます。 ポート番号 80 で listen() するには、root ユーザである必要があります。
実行例 $ node server.js Server running at localhost:51200 curl でレスポンス確認 (1) 基本 $ curl localhost:51200 Hello World curl でレスポンス確認 (2) ヘッダ付き $ curl -i localhost:51200 HTTP/1.</description></item></channel></rss>