<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux/Shell on 天才まくまくノート</title><link>https://maku77.github.io/linux/</link><description>Recent content in Linux/Shell on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 05 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux シェルスクリプト: echo の結果を標準エラー出力 (stderr) に出力する</title><link>https://maku77.github.io/p/q2k3j2h/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q2k3j2h/</guid><description>標準エラー出力への出力 echo コマンドの出力結果を、デフォルトの標準出力ではなく、標準エラー出力に出力するには、末尾で 1&amp;gt;&amp;amp;2 のようにリダイレクトします（&amp;gt;&amp;amp;2 という省略形でも OK）。
#!/bin/bash echo &amp;#34;Hello World&amp;#34; 1&amp;gt;&amp;amp;2 このように出力先を制御したプログラムは、実行結果をリダイレクトしたり、パイプ接続した場合の振る舞いに影響してきます。
sample.sh #!/bin/bash echo AAA echo BBB 1&amp;gt;&amp;amp;2 echo CCC 上記のプログラムの出力結果を out.txt というファイルにリダイレクトすると、ターミナル上には BBB という標準エラー出力のみが表示されます。
実行例 $ ./sample.sh &amp;gt; out.txt BBB out.txt の内容 AAA CCC cat の場合 cat コマンドによるヒアドキュメントでも、標準エラー出力に出力できます。
cat 1&amp;gt;&amp;amp;2 &amp;lt;&amp;lt;EOF AAA AAA AAA BBB BBB BBB CCC CCC CCC EOF シェルスクリプトの Usage 出力などに便利です。
usage() { cat 1&amp;gt;&amp;amp;2 &amp;lt;&amp;lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .</description></item><item><title>Linux シェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts)</title><link>https://maku77.github.io/p/2fyizgw/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2fyizgw/</guid><description>Bash 組み込みの getopts コマンドを使用すると、シェルスクリプトに渡されたコマンドラインオプション (-a など）を解析することができます。 getopts は 1 文字のオプションしか扱えないことに注意してください。
引数なしのオプション 下記は getopts の基本的な使用例です。 getopts のオプション文字列として abc を指定することにより、このシェルスクリプトには、-a、-b、-c という 3 種類のオプションを受け取れるようになっています。 ユーザーが指定したオプションが、1 文字ずつ opt 変数に格納されるので、その値で case による分岐処理を行います。
sample.sh #!/bin/bash while getopts &amp;#39;abc&amp;#39; opt; do case &amp;#34;${opt}&amp;#34; in a) echo &amp;#34;オプション -a を指定しました&amp;#34; ;; b) echo &amp;#34;オプション -b を指定しました&amp;#34; ;; c) echo &amp;#34;オプション -c を指定しました&amp;#34; ;; esac done 実行例 $ ./sample.sh -a オプション -a を指定しました $ ./sample.sh -a -c オプション -a を指定しました オプション -c を指定しました $ .</description></item><item><title>Linux シェルスクリプト: expect で外部コマンドの出力を待機する</title><link>https://maku77.github.io/p/3i3j2hx/</link><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3i3j2hx/</guid><description>expect コマンドを使用すると、任意のコマンドの出力を待ち受けて、自動でそれに応答するといったことを実現できます。
expect の基本的な使い方 Linux のコマンド expect がインストールされていない場合は、パッケージ管理ツール（apt や yum）を使用してインストールしてください（macOS には最初からインストールされています）。 まずは、簡単な例として、下記のような簡単なユーザ入力を必要とするスクリプトを自動で動作させてみます。
greet.sh #!/bin/bash echo -n &amp;#34;Enter your name: &amp;#34; read name echo &amp;#34;Hello, $name&amp;#34; これをそのまま実行すると、下記のようにユーザ入力の待ち受け状態となります。
$ ./greet.sh Enter your name: このような状態になったときに、自動的に入力を行うには、下記のように expect -c コマンドを使ったシェルスクリプトを作成します。
sample.sh #!/bin/bash expect -c &amp;#34; set timeout 3 spawn ./greet.sh expect \&amp;#34;Enter your name:\&amp;#34; send \&amp;#34;Maku\n\&amp;#34; interact &amp;#34; expect -c の後ろのダブルクォートで囲まれた部分には、expect で実行するスクリプトを記述します。 この中でダブルクォートを使用したいときは、\&amp;quot; のようにエスケープしなければいけないことに注意してください。 スクリプト中の各行は次のような意味を持っています。
set timeout 3 … 外部プログラムの実行を 3 秒待つ spawn ./greet.sh … 指定した外部プログラム (.</description></item><item><title>echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ</title><link>https://maku77.github.io/p/25gqyai/</link><pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/25gqyai/</guid><description>Linux の echo コマンドで文字列変数 $str の値を出力しようとして、下記のように実行すると、文字列に含まれている連続するスペースが 1 つのスペースにまとめられてしまいます。
sample.sh（間違った方法） #!/bin/bash str=&amp;#34;AAA BBB CCC&amp;#34; echo $str 実行結果 AAA BBB CCC これは、変数展開が行われることによってダブルクォートが取り除かれ、下記のように echo コマンドに 3 つのパラメータが渡されたものとして扱われるからです。 パラメータの区切りとして使われるスペースの数は関係なく、各パラメータ (AAA、BBB、CCC) が 1 つのスペースで結合されて出力されます。
$ echo AAA BBB CCC AAA BBB CCC スペースを含む文字列を 1 つの文字列として echo コマンドに渡すには、次のようにダブルクォートで囲む必要があります。
sample.sh（正しい方法） #!/bin/bash str=&amp;#34;AAA BBB CCC&amp;#34; echo &amp;#34;$str&amp;#34; 実行結果 AAA BBB CCC</description></item><item><title>Linux シェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)</title><link>https://maku77.github.io/p/s9r9q7n/</link><pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s9r9q7n/</guid><description>パイプで while read につなぐ方法 外部コマンドの出力結果を 1 行ずつ変数に取得しながらループ処理するには、コマンドの出力をパイプ (|) で while read につなぎます。 次の例では、外部コマンド find . -name '*.sh'（カレントディレクトリ以下の .sh ファイルを再帰的に列挙）の出力結果を 1 行ずつ line 変数に取得してループ処理しています。
find . -name &amp;#39;*.sh&amp;#39; | while read line; do echo &amp;#34;$line&amp;#34; done line という変数名は別の名前に変えても大丈夫です。 この例では 1 ファイルずつループ処理しているので、file という変数名の方が直感的かもしれません。
☝️ ワンポイント echo 出力時に &amp;quot;$line&amp;quot; のようにダブルクォートで囲んでいるのは、echo が連続したスペースを 1 つのスペースにまとめて出力してしまうのを防ぐためです。 パス内にスペースが含まれていなければ問題は発生しませんが、必ずダブルクォートで囲むようにしましょう。 外部コマンドの出力を配列として受け取る方法 パイプ (|) を使用せず、$(command) の形で実行した外部コマンドの出力を、配列で受け取る方法もあります。
list=$(find . -name &amp;#39;*.sh&amp;#39;) for line in &amp;#34;$list&amp;#34;; do echo &amp;#34;$line&amp;#34; done 外部コマンドの出力を 1 行ずつ正しくループ処理するために、$list をダブルクォートで囲むことを忘れないでください。 for ループの in の後ろには、スペース区切りで各要素が列挙されているものとして認識されます。 行内にスペースが含まれている場合に、行全体を 1 つの要素として処理するためには、$list 変数を展開するときにダブルクォートで囲んでおく必要があります。</description></item><item><title>Linux シェルスクリプト: ユーザー入力を取得する (read)</title><link>https://maku77.github.io/p/6m6n5k3/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6m6n5k3/</guid><description>ユーザー入力の基本 bash スクリプトの中で、read 変数名 とすると、ユーザーがキーボードで入力したテキストを変数に取得することができます。 変数名 の部分には、$ プレフィックスを付けないことに注意してください（変数の内容を参照するときは $ が必要です）。
hello.sh #!/bin/sh echo -n &amp;#34;Enter your name: &amp;#34; read name echo &amp;#34;Hello, $name&amp;#34; 実行結果 $ ./hello.sh Enter your name: まくまく Hello, まくまく ☝️ echo の -n オプション echo コマンドの出力はデフォルトで末尾で改行されますが、-n オプションを使うとこの改行を抑制できます。 上記の例のように、プロンプト表示で利用できます。 ユーザーが y を入力したときだけ処理を継続する read コマンドの典型的な使用例として、ユーザーに y/n の選択肢を入力させるものがあります。 次の remove_all 関数は、何もかもを削除する前に、ユーザーに最終確認を行っています。
remove.sh #!/bin/bash function remove_all { echo -n &amp;#39;Are you sure? (y/n): &amp;#39; read input if [ &amp;#34;$input&amp;#34; = &amp;#39;Y&amp;#39; -o &amp;#34;$input&amp;#34; = &amp;#39;y&amp;#39; ]; then echo &amp;#39;All things have been removed!</description></item><item><title>シェルスクリプト: テキストファイルを 1 行ずつ読み込む (read)</title><link>https://maku77.github.io/p/co9p7nj/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/co9p7nj/</guid><description>テキストファイルを 1 行だけ読み込む read コマンドは、ユーザからの入力を 1 行取得するために使用できますが、ファイルからの入力を 1 行読み込むのにも使用できます。
sample.sh （input.txt の内容を 1 行だけ読み込む） #!/bin/bash read line &amp;lt; input.txt echo &amp;#34;$line&amp;#34; input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 これだけだとあまり役に立たないので、通常は次のように while ループを組み合わせて、すべての行を読み出します。
テキストファイルから 1 行ずつ読み込む read コマンドと while ループを組み合わせると、テキストファイルのすべての行を 1 行ずつ処理できます。
sample.sh （input.txt の内容を 1 行ずつ読み込む） #!/bin/bash while read line; do echo &amp;#34;$line&amp;#34; done &amp;lt; input.txt input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 BBB 200 CCC 300 ☝️ ワンポイント echo のパラメータ &amp;quot;$line&amp;quot; をダブルクォートで囲んでいることに注意してください。 こうすることで、1 行分の文字列を、ひとつのパラメータとして渡すことができます。 ダブルクォートで囲まないと、echo AAA 100 のように、2 つのパラメータが渡されたかのように処理されてしまうため、連続するスペースが 1 つのスペースに置き換えられて出力されてしまいます。 参考: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ 行頭のスペースが消えてしまうのを防ぐ 例えば、下記のように行頭がインデントされたテキストファイルを読み込むとします。</description></item><item><title>Linux シェルスクリプト: echo で出力する文字の色を変える</title><link>https://maku77.github.io/p/fufwdub/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fufwdub/</guid><description>Linux の echo コマンドで特殊なエスケープシーケンスを出力すると、テキストの文字を変更することができます。 次の Bash スクリプトでは、色を変更しつつ echo 出力する、error / warn / info 関数を定義しています。
sample.sh #!/bin/bash error() { echo -e &amp;#34;\033[31m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } warn() { echo -e &amp;#34;\033[33m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } info() { echo -e &amp;#34;\033[32m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } error &amp;#39;Error message&amp;#39; warn &amp;#39;Warning message&amp;#39; info &amp;#39;Information message&amp;#39; このシェルスクリプトを実行すると、次のように色付きのメッセージが表示されます。
図: echo コマンドの出力色を変更 ちなみに、echo コマンドの末尾の &amp;gt;&amp;amp;2 は、標準エラー出力へ出力することを示しています。
参考: echo の結果を標準エラー出力 (stderr) に出力する (1&amp;gt;&amp;amp;2)</description></item><item><title>Linux シェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while)</title><link>https://maku77.github.io/p/or3cmv6/</link><pubDate>Sun, 06 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/or3cmv6/</guid><description>ワイルドカードを使用する方法 ワイルドカード (*) を使って、カレントディレクトリ内のファイルをループ処理することができます。
例: すべてのファイル（ドットファイルを除く）をループ処理 for x in *; do echo &amp;#34;$x&amp;#34; done 特定の拡張子を持つファイルのみを列挙するには次のようにします。
例: すべての PNG ファイルをループ処理 for x in *.png; do echo $x done 次のように一行で書くこともできます。
for x in *.png; do echo &amp;#34;$x&amp;#34;; done find コマンドの結果を使用する方法（再帰的にファイル探索） 下記の例では、find コマンドによって見つかったファイルを while ループで順番に処理しています。 深い階層にあるファイルも再帰的に処理されます。
find . -type f | while read x; do echo &amp;#34;$x&amp;#34; done</description></item><item><title>Bash の変数展開機能を活用する（文字列の置換、デフォルト値など）</title><link>https://maku77.github.io/p/jsctar8/</link><pubDate>Tue, 20 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jsctar8/</guid><description>Bash の変数は通常 ${x} のような形で参照しますが、様々な変数展開機能を利用すると、変数の存在を確認したり、一部を置換したり、デフォルト値を設定したりすることができます。 下記にざっと紹介しますが、公式なドキュメントは man bash の Parameter Expansion のセクションで参照することができます。
パターン照合演算子 次のような変数展開の構文を使用すると、変数に格納された文字列の一部を置換した文字列を作成することができます。
構文 意味 ${変数/パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（１つだけ） ${変数//パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（すべて） ${変数#パターン} 先頭から最短一致でパターンに一致する部分を取り除く ${変数##パターン} 先頭から最長一致でパターンに一致する部分を取り除く ${変数%パターン} 末尾から最短一致でパターンに一致する部分を取り除く ${変数%%パターン} 末尾から最長一致でパターンに一致する部分を取り除く パターン部分では、ワイルドカード（*、?、[a-z] など）を使用できます。
例: 変数内の b を B に置換する $ x=aaabbbccc $ y=${x/b/B} $ echo $y aaaBbbccc 最初に見つかった文字列だけが置換されていることがわかります。 パターンに一致する文字列をすべて置換するには次のようにします（最初のスラッシュを2つにします）。
$ x=aaabbbccc $ y=${x//b/B} $ echo $y aaaBBBccc 以下のように sed コマンドを使ったのと同様の効果を bash の機能だけで実現できていることになります。
$ y=$(echo $x | sed -e &amp;#39;s/bbb/BBB/g&amp;#39;) 例: フルパスから basename を取り出す 下記の例では /aaa/bbb/ccc という絶対パスから、ベースネーム部分の ccc を抽出しています。 */ というパターンで先頭から最長一致させ、/aaa/bbb/ という部分を取り除いています。</description></item><item><title>シェルスクリプト: ある外部コマンドが使用できるかチェックする</title><link>https://maku77.github.io/p/xi5sjju/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xi5sjju/</guid><description>シェルスクリプトの中で特定の外部コマンドを使用する必要がある場合、先頭部分でその外部コマンドが使用できる状態かどうかを調べておくと親切です。 例えば、次のようにすれば、ruby コマンドが使用できるかを確認できます。
sample.sh if type -P ruby &amp;gt; /dev/null; then echo &amp;#39;ruby コマンドを使用できます&amp;#39; else echo &amp;#39;ruby コマンドが見つかりません&amp;#39; fi ☝️ type -P コマンド type -P ruby コマンドは、パスの通ったディレクトリから ruby を検索してそのパスを取得するためのものですが、ここでは ruby コマンドが使用できる環境になっているかを確認するために利用しています。 単純に実行すると、検索結果のパスが出力されてしまうので、null デバイスへリダイレクトして出力を抑制しています。 特定のコマンドが使用できない場合にスクリプトを終了させるには、以下のように記述すればよいでしょう。 条件式を ! で反転させていることに注意してください。
if ! type -P ruby &amp;gt; /dev/null; then echo &amp;#39;This script requires Ruby. Please install Ruby first and try again.&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続</description></item><item><title>シェルスクリプト: ある環境変数が定義されているかチェックする (test -z)</title><link>https://maku77.github.io/p/r3myewb/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r3myewb/</guid><description>環境変数がセットされているかを確認する 下記の例では、SRC_ROOT という環境変数が設定されているかを調べ、設定されていない場合はメッセージを終了しています。
sample.sh #!/bin/bash if [ -z $SRC_ROOT ]; then echo &amp;#39;Please set the &amp;#34;SRC_ROOT&amp;#34; environment variable and try again.&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi echo &amp;#39;Program continues...&amp;#39; ☝️ ワンポイント echo の出力を &amp;gt;&amp;amp;2 とリダイレクトすると標準エラー出力へ出力できます。 実行例 $ ./sample.sh Please set the &amp;#34;SRC_ROOT&amp;#34; environment variable and try again. $ SRC_ROOT=/Users/maku/src ./sample.sh Program continues... （おまけ）test コマンドについて if [ -z $SRC_ROOT ]; then という条件判定は、次のように test コマンドを使うのと同等です。
if test -z $SRC_ROOT; then test -z コマンドは、指定された変数値の文字列長が 0 かどうかを確認するコマンドです。 これを利用して、上記のように 特定の変数値がセットされていない ことを調べることができます。</description></item><item><title>シェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#)</title><link>https://maku77.github.io/p/4tbzpyf/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4tbzpyf/</guid><description>関連記事: Linux シェルスクリプト: コマンドライン引数を取得する ($1, $@, $*)
コマンドライン引数が足りないときに Usage 出力して終了する シェルスクリプト起動時に渡されたコマンドライン引数の数は、$# 変数で取得することができます。 シェルスクリプトが最低 2 つのパラメーターを必要としている場合は、先頭部分で下記のようなチェックをするのがよいでしょう。
例: 2 つ以上のパラメーターが必要 #!/bin/bash if [ $# -lt 2 ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続 下記はバリエーションです。
例: 1 つ以上のパラメーターが必要 #!/bin/bash if [ ! &amp;#34;$1&amp;#34; ]; then echo &amp;#34;Usage: $(basename $1) &amp;lt;file&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続 例: 1 つは引数が必要で、かつ、その名前のファイルが存在する #!/bin/bash if [ ! &amp;#34;$1&amp;#34; ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi if [ !</description></item><item><title>Linux シェルスクリプト: コマンドライン引数を取得する ($1, $@, $*)</title><link>https://maku77.github.io/p/c2kx7er/</link><pubDate>Wed, 29 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c2kx7er/</guid><description>コマンドライン引数の基本 ($1 ~ $9) bash シェルスクリプト実行時にコマンドラインで渡した引数を参照するには、次のようなパラメーター参照用の特殊変数を使用します。
$1 &amp;hellip; 第 1 パラメーター $2 &amp;hellip; 第 2 パラメーター $3 &amp;hellip; 第 3 パラメーター パラメーターの参照には、$1 〜 $9 が使用できます。 使用することは余りないと思いますが、10 番目以降のパラメータを参照したいときは、${10} のように数値を {} で囲めば参照できます。
sample.sh #!/bin/bash echo &amp;#39;1 番目: &amp;#39; &amp;#34;$1&amp;#34; echo &amp;#39;2 番目: &amp;#39; &amp;#34;$2&amp;#34; echo &amp;#39;3 番目: &amp;#39; &amp;#34;$3&amp;#34; 実行結果 $ ./sample.sh AAA BBB &amp;#34;CCC DDD&amp;#34; 1 番目: AAA 2 番目: BBB 3 番目: CCC DDD コマンドライン引数を指定しなかった場合は、対応する変数は空になります。
$ ./sample.sh AAA 1 番目: AAA 2 番目: 3 番目: ☝️ 変数はダブルクォートで囲む echo の引数として変数の値を渡すときは、&amp;quot;$1&amp;quot; のようにダブルクォートで囲む癖をつけましょう。 $1 のようにそのまま記述してしまうと、変数の値として連続するスペースが含まれていたときに 1 つのスペースにまとめられてしまいます。 ☝️ 引数とパラメーターの違い 正確には、引数 (arguments) という用語は、スクリプトや関数を呼び出す側が渡す値のことを示し、パラメーター (parameters) という用語は、呼び出される側のスクリプトや関数が、その値を参照するときに使う変数のことを示します。 ただ、どちらのケースでもパラメーターという用語を使っているドキュメントもよく見かけるので、あまり気にしないのがよさそうです。 コマンドライン引数にデフォルト値を指定する (${1:-XXX}) コマンドライン引数が指定されなかったときに使用する値として、デフォルト値を指定しておくこともできます。 デフォルト値は、パラメーター参照時に ${1:-デフォルト値} という形で指定します。 下記の例では、1 番目、2 番目、3 番目のコマンドラインパラメーターのデフォルト値を、それぞれ AAA、BBB、CCC に設定しています。</description></item><item><title>Linuxコマンド: ファイルやディレクトリを検索する (find, grep)</title><link>https://maku77.github.io/p/hudubr8/</link><pubDate>Mon, 08 Sep 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hudubr8/</guid><description>find と grep の基本 指定した拡張子のファイルを検索する (find) 次のようにすると、カレントディレクトリ (.) を起点にして、拡張子 .txt を持つファイルを検索して一覧表示することができます。
$ find . -name &amp;#39;*.txt&amp;#39; ファイル内の文字列を検索する (grep) 次のようにすると、指定したテキストファイル内の文字列を検索することができます。
$ grep &amp;#39;検索文字列&amp;#39; hello.txt find で見つけたファイルの中身を grep 検索する find で検索した結果のファイルそれぞれに対して、grep コマンドを実行するには、xargs を組み合わせて使用します。
例: 拡張子に txt を持つファイルを grep $ find . -type f -name &amp;#39;*.txt&amp;#39; | xargs grep &amp;#39;検索文字列&amp;#39; 拡張子などを絞り込まず、単純にそのディレクトリ以下のすべてのテキストファイルを検索するだけでよいのであれば、find を使わず、grep の再帰オプション (-r) を使った方が簡単です。 念のため、テキストファイルのみを grep 対象にするために -I オプション (--binary-files-without-match) も一緒に指定しておきます。
例: すべてのテキストファイルを grep $ grep -r -I &amp;#39;検索文字列&amp;#39; . grep で NOT、AND、OR 検索する NOT 検索 grep の -v オプションを指定すると、指定した 文字列を含まない 行だけを抽出できます。</description></item></channel></rss>