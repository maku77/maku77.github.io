<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux/Shell on 天才まくまくノート</title><link>https://maku77.github.io/linux/</link><description>Recent content in Linux/Shell on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 05 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linuxシェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts)</title><link>https://maku77.github.io/p/2fyizgw/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2fyizgw/</guid><description>Bash 組み込みの getopts コマンドを使用すると、シェルスクリプトに渡されたコマンドラインオプション (-a など）を解析することができます。 getopts は 1 文字のオプションしか扱えないことに注意してください。
引数なしのオプション 下記は getopts の基本的な使用例です。 getopts のオプション文字列として abc を指定することにより、このシェルスクリプトで、-a、-b、-c という 3 種類のオプションを受け取れるようになっています。 ユーザーが指定したオプションが、1 文字ずつ opt 変数に格納されるので、その値で case による分岐処理を行います。
sample.sh #!/bin/bash while getopts &amp;#39;abc&amp;#39; opt; do case &amp;#34;${opt}&amp;#34; in a) echo &amp;#34;オプション -a を指定しました&amp;#34; ;; b) echo &amp;#34;オプション -b を指定しました&amp;#34; ;; c) echo &amp;#34;オプション -c を指定しました&amp;#34; ;; esac done 実行例 $ ./sample.sh -a オプション -a を指定しました $ ./sample.sh -a -c オプション -a を指定しました オプション -c を指定しました $ .</description></item><item><title>Linuxメモ: echo の結果を標準エラー出力 (stderr) に出力する</title><link>https://maku77.github.io/p/q2k3j2h/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q2k3j2h/</guid><description>標準エラー出力への出力 echo コマンドの出力結果を、デフォルトの標準出力ではなく、標準エラー出力に出力するには、末尾で 1&amp;gt;&amp;amp;2 のようにリダイレクトします（&amp;gt;&amp;amp;2 という省略形でも OK）。
#!/bin/bash echo &amp;#34;Hello World&amp;#34; 1&amp;gt;&amp;amp;2 このように出力先を制御したプログラムは、実行結果をリダイレクトしたり、パイプ接続した場合の振る舞いに影響してきます。
sample.sh #!/bin/bash echo AAA echo BBB 1&amp;gt;&amp;amp;2 echo CCC 上記のプログラムの出力結果を out.txt というファイルにリダイレクトすると、ターミナル上には BBB という標準エラー出力のみが表示されます。
実行例 $ ./sample.sh &amp;gt; out.txt BBB out.txt の内容 AAA CCC cat の場合 cat コマンドによるヒアドキュメントでも、標準エラー出力に出力できます。
cat 1&amp;gt;&amp;amp;2 &amp;lt;&amp;lt;EOF AAA AAA AAA BBB BBB BBB CCC CCC CCC EOF シェルスクリプトの Usage 出力などに便利です。
usage() { cat 1&amp;gt;&amp;amp;2 &amp;lt;&amp;lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .</description></item><item><title>Linux シェルスクリプト: expect で外部コマンドの出力を待機する</title><link>https://maku77.github.io/p/3i3j2hx/</link><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3i3j2hx/</guid><description>Linux や macOS の expect コマンドを使用すると、任意のコマンドの出力を待ち受けて、自動でそれに応答するといったことを実現できます。
expect の基本的な使い方 expect がインストールされていない場合は、パッケージ管理ツール（apt や yum）を使用してインストールしてください（macOS には最初からインストールされています）。 まずは、簡単な例として、下記のような簡単なユーザ入力を必要とするスクリプトを自動で動作させてみます。
greet.sh #!/bin/bash echo -n &amp;#34;Enter your name: &amp;#34; read name echo &amp;#34;Hello, $name&amp;#34; これをそのまま実行すると、下記のようにユーザ入力の待ち受け状態となります。
$ ./greet.sh Enter your name: このような状態になったときに、自動的に入力を行うには、下記のように expect -c コマンドを使ったシェルスクリプトを作成します。
sample.sh #!/bin/bash expect -c &amp;#34; set timeout 3 spawn ./greet.sh expect \&amp;#34;Enter your name:\&amp;#34; send \&amp;#34;Maku\n\&amp;#34; interact &amp;#34; expect -c の後ろのダブルクォートで囲まれた部分には、expect で実行するスクリプトを記述します。 この中でダブルクォートを使用したいときは、\&amp;quot; のようにエスケープしなければいけないことに注意してください。 スクリプト中の各行は次のような意味を持っています。
set timeout 3 &amp;hellip; 外部プログラムの実行を 3 秒待つ spawn .</description></item><item><title>Linuxメモ: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ</title><link>https://maku77.github.io/p/25gqyai/</link><pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/25gqyai/</guid><description>Linux の echo コマンドで文字列変数 $str の値を出力しようとして、下記のように実行すると、文字列に含まれている連続するスペースが 1 つのスペースにまとめられてしまいます。
sample.sh（間違った方法） #!/bin/bash str=&amp;#34;AAA BBB CCC&amp;#34; echo $str 実行結果 AAA BBB CCC これは、変数展開が行われることによってダブルクォートが取り除かれ、下記のように echo コマンドに 3 つのパラメータが渡されたものとして扱われるからです。 パラメータの区切りとして使われるスペースの数は関係なく、各パラメータ (AAA、BBB、CCC) が 1 つのスペースで結合されて出力されます。
$ echo AAA BBB CCC AAA BBB CCC スペースを含む文字列を 1 つの文字列として echo コマンドに渡すには、次のようにダブルクォートで囲む必要があります。
sample.sh（正しい方法） #!/bin/bash str=&amp;#34;AAA BBB CCC&amp;#34; echo &amp;#34;$str&amp;#34; 実行結果 AAA BBB CCC</description></item><item><title>Linuxメモ: シェルスクリプトのコーディングスタイル</title><link>https://maku77.github.io/p/oukq4dh/</link><pubDate>Tue, 25 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oukq4dh/</guid><description>Bash のシェルスクリプトを記述するときに最低限揃えておきたいコーディングスタイルです。 Google のコーディングスタイルを参考にしています。
基本的に bash を使用することとし、1 行目の Shebang として #!/bin/bash と記述する インデント: 半角スペース 2 文字（タブ文字は使用しない） if と同じ行に then を記述する for や while と同じ行に do を記述する 1 行あたりの文字数は 80 文字まで 関数名や変数名はすべて小文字（例: my_func） 外部コマンドを実行するときはバッククォート (\) を使用せず、$(func arg1 arg2) という形式を使用する シェル変数は小文字 ($src_dir)、環境変数は大文字 ($FOO_BAR)</description></item><item><title>Linuxメモ: Deep Learning や仮想通貨のマイニング時に CPU 使用率が 100% になってしまうのを防ぐ (cpulimit)</title><link>https://maku77.github.io/p/t8yiqm8/</link><pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/t8yiqm8/</guid><description>概要 普段使い用の PC 上でディープラーニングのプログラムを走らせたりすると、CPU の負荷が 100% になってしまい、別の作業に支障が出てしまうことがあります（特に計算処理に GPU を使えない環境の場合）。 CPU の発熱量が半端なく、ファンが全力で回転してうるさくて集中できなくなってしまいます。 長時間高温な状態で動作させると、ハードウェアへのダメージも大きくなってしまうでしょう。
CPU 負荷を下げようとして、nice コマンドや renice コマンドを使用してプロセスの優先度（nice 値）の値を変更しても無駄です。 なぜなら、プロセスの優先度設定は、あくまで別のプロセスと比較したときの CPU 使用率の割合を変更するものであり、システムをアイドル状態にすることを促すものではないからです。 優先度の低いプロセスであっても、CPU に空きがあったら 100% まで使用してしまいます。
このようなときは、cpulimit を使ってプロセスの CPU 使用率を制限してやることで、負荷の低い状態をキープすることができます。 もちろん、そのプロセス内の処理には時間がかかるようになってしまいますが、ゆっくりでいいから処理が進めばいい、といったケースでは重宝すると思います。
cpulimit のインストール方法 cpulimit はそれぞれの OS 用のパッケージを使ってインストールしてしまうのが手っ取り早いでしょう。
Mac の場合（Homebrew を使用） $ brew install cpulimit Ubuntu (Linux) の場合 $ sudo apt-get install cpulimit cpulimit の使い方 cpulimit の -l (--limit) オプションを使用して、特定のプロセスの CPU 使用率をパーセンテージ指定で制限することができます。
例: プロセス番号 12345 を CPU 使用率50％に制限 $ cpulimit -l 50 -p 12345 ps コマンドなどで実行中のプロセスのプロセス ID を確認することができれば、その ID を指定して CPU 使用率に制限をかけることができます。 上記のように CPU 使用率を制限した場合、cpulimit のプロセスの方を Ctrl-C で停止すれば制限が解除されます。</description></item><item><title>Linuxシェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)</title><link>https://maku77.github.io/p/s9r9q7n/</link><pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s9r9q7n/</guid><description>パイプで while read につなぐ方法 外部コマンドの出力結果を 1 行ずつ変数に取得しながらループ処理するには、コマンドの出力をパイプ (|) で while read につなぎます。 次の例では、外部コマンド find . -name '*.sh'（カレントディレクトリ以下の .sh ファイルを再帰的に列挙）の出力結果を 1 行ずつ line 変数に取得してループ処理しています。
find . -name &amp;#39;*.sh&amp;#39; | while read line; do echo &amp;#34;$line&amp;#34; done line という変数名は別の名前に変えても大丈夫です。 この例では 1 ファイルずつループ処理しているので、file という変数名の方が直感的かもしれません。
☝️ ワンポイント echo 出力時に &amp;quot;$line&amp;quot; のようにダブルクォートで囲んでいるのは、echo が連続したスペースを 1 つのスペースにまとめて出力してしまうのを防ぐためです。 パス内にスペースが含まれていなければ問題は発生しませんが、必ずダブルクォートで囲むようにしましょう。 外部コマンドの出力を配列として受け取る方法 パイプ (|) を使用せず、$(command) の形で実行した外部コマンドの出力を、配列で受け取る方法もあります。
list=$(find . -name &amp;#39;*.sh&amp;#39;) for line in &amp;#34;$list&amp;#34;; do echo &amp;#34;$line&amp;#34; done 外部コマンドの出力を 1 行ずつ正しくループ処理するために、$list をダブルクォートで囲むことを忘れないでください。 for ループの in の後ろには、スペース区切りで各要素が列挙されているものとして認識されます。 行内にスペースが含まれている場合に、行全体を 1 つの要素として処理するためには、$list 変数を展開するときにダブルクォートで囲んでおく必要があります。</description></item><item><title>Linuxメモ: 実行中のシェルスクリプトのファイル名を取得する ($0)</title><link>https://maku77.github.io/p/6vkj2pi/</link><pubDate>Sun, 20 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6vkj2pi/</guid><description>シェルスクリプト内から、自身のファイル名を取得するには $0 という特殊変数を参照します。
sample.sh #!/bin/bash echo &amp;#34;$0&amp;#34; 正確には、$0 に格納されているパスは、そのスクリプト実行時に実際に指定したパスになります。 そのため、どのようにスクリプトを起動したかによって結果が変わってきます。
# 絶対パスで起動した場合 $ /Users/maku/sample.sh /Users/maku/sample.sh # 相対パスで起動した場合 $ cd /Users $ maku/sample.sh maku/sample.sh # カレントディレクトリのスクリプトを起動した場合 $ ./sample.sh ./sample.sh # sh コマンドのパラメータで起動した場合 $ sh sample.sh sample.sh 確実にファイル名（ベース名）だけを取得したい場合や、絶対パスを取得したい場合は以下のようにするのがよいでしょう。
sample.sh #!/bin/bash MY_BASENAME=$(basename $0) MY_ABS_PATH=$(cd $(dirname $0); pwd)/$MY_BASENAME echo &amp;#34;$MY_BASENAME&amp;#34; echo &amp;#34;$MY_ABS_PATH&amp;#34; 実行結果 $ ~/sample.sh sample.sh /Users/maku/sample.sh</description></item><item><title>Linuxメモ: ディレクトリ内のファイルを zip ファイルにバックアップする</title><link>https://maku77.github.io/p/3qnenzf/</link><pubDate>Sat, 19 Aug 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3qnenzf/</guid><description>zip コマンドの基本 下記のようにすると、sample ディレクトリ内のファイルをすべて sample.zip アーカイブとして保存することができます。
$ zip -r sample.zip sample より上位のディレクトリからアーカイブを作成する場合は、同様に、
$ zip -r sample.zip aaa/bbb/ccc/sample とすることができますが、このようにすると、アーカイブ内に aaa/bbb/ccc ディレクトリが含まれてしまいます。 アーカイブ内のトップのディレクトリを sample ディレクトリにしたい場合は、次のようにカレントディレクトリを変更してから zip コマンドを実行するようにします。
$ (cd aaa/bbb/ccc &amp;amp;&amp;amp; zip -r sample.zip sample) コマンド全体を括弧で囲んでいるのは、コマンド実行後にシェルのカレントディレクトリを元のディレクトリに復帰させるためです。
アーカイブファイル名に日付を入れる date コマンドと組み合わせて、下記のように実行すれば、アーカイブ名に自動的に日付を入れることができます（例: sample-20170819.zip）。
$ zip -r sample-`date +%Y%m%d`.zip sample 指定したディレクトリを除いてアーカイブする 例えば、アーカイブの対象から .git ディレクトリを除きたいときは、下記のように --exclude オプションを指定します。
$ zip -r sample.zip --exclude=*/.git/* sample 複数の --exclude オプションを指定することもできます。
$ zip -r sample.zip --exclude=*/.git/* --exclude=*/.svn/* sample</description></item><item><title>Linuxメモ: curl で HTTP のレスポンスヘッダのみを確認する例</title><link>https://maku77.github.io/p/2fnpkp9/</link><pubDate>Wed, 14 Sep 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2fnpkp9/</guid><description>$ curl -s -D - localhost:8080 -o /dev/null HTTP/1.1 403 Forbidden Date: Wed, 14 Sep 2016 12:46:40 GMT Server: Jetty(8.y.z-SNAPSHOT) Expires: Thu, 01 Jan 1970 00:00:00 GMT Content-Type: text/html;charset=UTF-8 X-Hudson: 1.395 X-Jenkins: 1.565.1 X-Jenkins-Session: a53528f4 X-Hudson-CLI-Port: 41906 X-Jenkins-CLI-Port: 41906 X-Jenkins-CLI2-Port: 41906 X-You-Are-Authenticated-As: anonymous X-You-Are-In-Group: X-Required-Permission: hudson.model.Hudson.Read X-Permission-Implied-By: hudson.security.Permission.GenericRead X-Permission-Implied-By: hudson.model.Hudson.Administer Content-Length: 793 Vary: Accept-Encoding Proxy-Connection: Keep-Alive Connection: Keep-Alive Set-Cookie: JSESSIONID.e92abcec=jhmj6nosqyo51rcld8mgf20jc;Path=/</description></item><item><title>Linuxメモ: 実行中のシェルスクリプトがあるディレクトリに移動する</title><link>https://maku77.github.io/p/dpvyxy8/</link><pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dpvyxy8/</guid><description>シェルスクリプト内の処理が、シェルスクリプト自体が置いてあるディレクトリをカレントディレクトリとすることを前提として記述されていると、他のディレクトリにいるときにそのスクリプトを実行することができなくなってしまいます。 そのような場合は、スクリプトの先頭で、そのスクリプトがあるディレクトリに移動するようにしておくと、どのディレクトリからでも実行できるスクリプトにすることができます。
下記は、dirname コマンドを利用してカレントディレクトリを移動する例です。
sample.sh #!/bin/bash cd `dirname $0` # スクリプトのあるディレクトリへ移動 # あとは好きな処理を記述していく chmod -R +r build/ シェルスクリプトは通常新しく起動したシェル内で実行されるため、このスクリプトを起動したシェルのカレントディレクトリが移動してしまうことはありません（source コマンドで起動した場合は例外）。</description></item><item><title>Linuxメモ: シェルスクリプト: シェル変数/環境変数がセットされているか調べる</title><link>https://maku77.github.io/p/xi5nrtd/</link><pubDate>Fri, 16 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xi5nrtd/</guid><description>変数がセットされていることを調べる 下記の例では、変数 NAME がセットされているかどうか調べています。
sample.sh #!/bin/bash if [ -n &amp;#34;$NAME&amp;#34; ]; then echo $NAME fi 実行例 $ ./sample.sh $ NAME=maku ./sample.sh maku 変数がセットされていないことを調べる 下記の例では、変数 NAME がセットされていないことを調べています。
sample.sh #!/bin/bash if [ -z &amp;#34;$NAME&amp;#34; ]; then echo &amp;#39;NAME is not set&amp;#39; fi 実行例 $ ./sample.sh NAME is not set $ NAME=maku ./sample.sh 仕組みの解説 test や [ ... ] 構造で使用できる演算子に下記のようなものがあります。
-z 文字列 - 文字列の長さが 0 の場合に真 -n 文字列 - 文字列の長さが 0 でない場合に真 変数の値を &amp;quot;$NAME&amp;quot; という構文で確実に文字列になるように展開し、上記の演算子でその文字列の長さをチェックすることにより、変数がセットされている（あるいはセットされていない）ことを調べることができます。</description></item><item><title>Linuxメモ: Linux の各種 ID（プロセス ID やユーザ ID など）についてのメモ</title><link>https://maku77.github.io/p/ycrtvgk/</link><pubDate>Thu, 02 Jan 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ycrtvgk/</guid><description> プロセス ID (pid: Process ID) Unix システム上で動作しているプロセスには、0 ～ 30000 までのユニークな pid（プロセス ID）が割り当てられます。 プロセス ID が 1 のものは、最初に立ち上がる init プロセスです（例外として、終了した親プロセスの pid を子プロセスから参照すると 1 が返されます）。 プロセス・グループ ID (pgid: Process Group ID) プロセス・グループとは、1 つ以上のプロセスをまとめて扱う仕組みで、個々のプロセスに対してではなく、プロセス・グループに対してシグナルを送ったりすることができます。 プロセス・グループには 1 つのプロセス・グループ・リーダ（プロセス）が存在し、そのプロセス ID (pid) をプロセス・グループ ID (gpid) として使用します（つまり、プロセス・グループ・リーダの pid と gpid は等しくなります）。 プロセス・グループ・リーダではないプロセスをリーダにするには、setpgrp システムコールを使用します。 ターミナル・グループ (tty group) プロセス・グループ・リーダがあるターミナルと関連を持っている場合、そのプロセス・グループのすべてのプロセスは同じターミナル・グループに属します。 ターミナルとの接続が切れた場合、そのターミナル・グループ内のすべてのプロセスに SIGHUP シグナルが送られます。 リアル・ユーザ ID（実ユーザ ID）(ruid: Real User ID) ログイン名と 1 対 1 で対応付けられるユーザを識別するための ID です。 /etc/passwd を見ると、どのように対応付けられているかが分かります。 子プロセスを生成した場合は、親プロセスの ruid が引き継がれます。 リアル・グループ ID（実グループ ID）(rgid: Real Group ID) リアル・ユーザ ID のグループ版と考えれば OK です。 /etc/passwd を見ると、ログイン名と rgid の対応付けが分かります。 実効ユーザ ID／実効グループ ID ファイルにアクセスできるかどうかを決定するためのカギとなる ID です。 子プロセスは親プロセスの実効ユーザ ID、実効グループ ID を引き継ぎます。 実行した実行ファイルに set-user-id、set-group-id ビットが設定されている場合は、その実行ファイルの所有者のユーザ ID、グループ ID が実効ユーザ ID、および、実効グループ ID となります。</description></item><item><title>Linuxメモ: Bash の構文: 関数のデフォルト引数を定義する</title><link>https://maku77.github.io/p/7ovg5nr/</link><pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7ovg5nr/</guid><description>以下の関数では、パラメータを何も指定しないで呼び出すと、par1 ローカル変数に ABC が入ります。 パラメータを指定すると、そちらが使用されます。
param-test.sh function param-test() { local par1=${1:-ABC}; echo &amp;#34;param = $par1&amp;#34; } 実行例 $ . param-test.sh $ param-test param = ABC $ param-test 10000 param = 10000</description></item><item><title>Linuxメモ: Windows で Linux 系のコマンドを使用できるようにする (Gow)</title><link>https://maku77.github.io/p/qijsiy5/</link><pubDate>Mon, 19 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qijsiy5/</guid><description>Gow のインストール Gow (Gnu On Windows)
Gow をインストールすると、Windows で Linux の主なコマンド群をサクッと使うことができるようになります。 インストーラを実行するだけで数秒でインストールできるので、簡単なコマンドを使うために Cygwin のような大げさな環境をインストールしなくても済みます。
Gow で使えるようになる Linux 系コマンドの一覧 Gow - executables_list
Gow がインストールされている環境であれば、以下のように確認することもできます。
Gow 0.7 で確認 C:\&amp;gt; gow -l Available executables: awk, basename, bash, bc, bison, bunzip2, bzip2, bzip2recover, cat, chgrp, chmod, chown, chroot, cksum, clear, cp, csplit, curl, cut, dc, dd, df, diff, diff3, dirname, dos2unix, du, egrep, env, expand, expr, factor, fgrep, flex, fmt, fold, gawk, gfind, gow, grep, gsar, gzip, head, hostid, hostname, id, indent, install, join, jwhois, less, lesskey, ln, ls, m4, make, md5sum, mkdir, mkfifo, mknod, mv, ncftp, nl, od, pageant, paste, patch, pathchk, plink, pr, printenv, printf, pscp, psftp, putty, puttygen, pwd, rm, rmdir, scp, sdiff, sed, seq, sftp, sha1sum, shar, sleep, sort, split, ssh, su, sum, sync, tac, tail, tar, tee, test, touch, tr, uname, unexpand, uniq, unix2dos, unlink, unrar, unshar, uudecode, uuencode, vim, wc, wget, whereis, which, whoami, xargs, yes, zip</description></item><item><title>Linuxシェルスクリプト: テキストファイルを 1 行ずつ読み込む (read)</title><link>https://maku77.github.io/p/co9p7nj/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/co9p7nj/</guid><description>テキストファイルを 1 行だけ読み込む read コマンドはユーザからの入力を 1 行取得するために使用できますが、ファイルからの入力を 1 行読み込むのにも使用できます。
sample.sh （input.txt の内容を 1 行だけ読み込む） #!/bin/bash read line &amp;lt; input.txt echo &amp;#34;$line&amp;#34; input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 これだけだとあまり役に立たないので、通常は次のように while ループを組み合わせて、すべての行を読み出します。
テキストファイルから 1 行ずつ読み込む read コマンドと while ループを組み合わせると、テキストファイルのすべての行を 1 行ずつ処理できます。
sample.sh （input.txt の内容を 1 行ずつ読み込む） #!/bin/bash while read line; do echo &amp;#34;$line&amp;#34; done &amp;lt; input.txt input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 BBB 200 CCC 300 ☝️ ワンポイント echo のパラメータ &amp;quot;$line&amp;quot; をダブルクォートで囲んでいることに注意してください。 こうすることで、1 行分の文字列を、ひとつのパラメータとして渡すことができます。 ダブルクォートで囲まないと、echo AAA 100 のように、2 つのパラメータが渡されたかのように処理されてしまうため、連続するスペースが 1 つのスペースに置き換えられて出力されてしまいます。 参考: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ 行頭のスペースが消えてしまうのを防ぐ 例えば、下記のように行頭がインデントされたテキストファイルを読み込むとします。</description></item><item><title>Linuxメモ: シェルスクリプト: 変数の基本</title><link>https://maku77.github.io/p/cjn9dbq/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cjn9dbq/</guid><description>変数の定義と参照 変数へ値を代入するときは $ を付けず、変数を参照するときは $ を付けます。
sample.sh #!/bin/sh name=Michael # 変数の定義 echo Hello $name # 変数の参照 echo &amp;#34;Hello $name&amp;#34; # ダブルクォーテーションは変数を展開する echo &amp;#39;Hello $name&amp;#39; # シングルクォーテーションは変数を展開しない 実行結果 $ ./sample.sh Hello Michael Hello Michael Hello $name 定義していない変数は空文字と同じ 未定義の変数を参照すると、空文字列と同様に扱われます。 エラーにはなりません。
sample.sh #!/bin/sh echo &amp;#34;Hello $name !&amp;#34; 実行結果 $ ./sample.sh Hello ! &amp;ldquo;=&amp;rdquo; の前後にスペースは入れちゃだめ！ 変数定義の = の前後にはスペースを入れてはいけません。 スペースを入れると、変数名の部分がシェル上で実行可能なコマンドとして認識されてしまいます。 例えば、以下のようにすると、value というコマンドを、引数 &amp;quot;= hello&amp;quot; で実行すると解釈されてしまいます。
間違った代入（その１） value = hello さらに、以下のように、&amp;quot;=&amp;quot; の後ろだけにスペースを入れると…
間違った代入（その２） value= hello これは、変数 value を空にした状態で、コマンド hello を呼び出すと解釈されてしまいます。</description></item><item><title>Linuxメモ: ユーザー入力を取得する (read)</title><link>https://maku77.github.io/p/6m6n5k3/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6m6n5k3/</guid><description>ユーザー入力の基本 bash スクリプトの中で、read 変数名 とすると、ユーザーがキーボードで入力したテキストを変数に取得することができます。 変数名 の部分には、$ プレフィックスを付けないことに注意してください（変数の内容を参照するときは $ が必要です）。
hello.sh #!/bin/sh echo -n &amp;#34;Enter your name: &amp;#34; read name echo &amp;#34;Hello, $name&amp;#34; 実行結果 $ ./hello.sh Enter your name: まくまく Hello, まくまく ☝️ echo の -n オプション echo コマンドの出力はデフォルトで末尾で改行されますが、-n オプションを使うとこの改行を抑制できます。 上記の例のように、プロンプト表示で利用できます。 ユーザーが y を入力したときだけ処理を継続する read コマンドの典型的な使用例として、ユーザーに y/n の選択肢を入力させるものがあります。 次の remove_all 関数は、何もかもを削除する前に、ユーザーに最終確認を行っています。
remove.sh #!/bin/bash function remove_all { echo -n &amp;#39;Are you sure? (y/n): &amp;#39; read input if [ &amp;#34;$input&amp;#34; = &amp;#39;Y&amp;#39; -o &amp;#34;$input&amp;#34; = &amp;#39;y&amp;#39; ]; then echo &amp;#39;All things have been removed!</description></item><item><title>Linuxメモ: dbus-python で D-Bus の P2P クライアントを実装する</title><link>https://maku77.github.io/p/pzyxbo7/</link><pubDate>Wed, 05 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pzyxbo7/</guid><description>python-dbus では、今のところ P2P 用のサーバを作成できないようです。 なので、ここでは P2P クライアントのサンプルだけを示します。
p2p-client.py P2P 通信を行うには、dbus.SessionBus オブジェクトを使ってバス名を指定するのではなく、dbus.connection.Connection オブジェクトを使って、アドレス指定で接続します。
con = dbus.connection.Connection(&amp;#39;tcp:host=127.0.0.1,port=12300&amp;#39;) Connection が確立できたら、あとは Object path を指定して、リモートオブジェクトを取得できます。
counter_object = con.get_object(object_path=OBJECT_PATH) counter_iface = dbus.Interface(counter_object, INTERFACE)</description></item><item><title>Linuxメモ: dbus-python で Session bus を使用するサーバ＆クライアントを実装する（シグナルの実装）</title><link>https://maku77.github.io/p/zkx7oe6/</link><pubDate>Wed, 05 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zkx7oe6/</guid><description>dbus-python のサーバ＆クライアント実装において、シグナルを使用するサンプルです。 シグナルを使用すると、サーバ側からクライアント側に任意のタイミングで通知を送ることができます。 以下のサンプルでは、SetCount() メソッドが呼ばれた場合に、CountChanged シグナルを発行しています。
サーバ側の実装 server-signal.py サーバ側に、シグナル発行用のメソッド CountChanged() を追加して、SetCount() メソッド内から呼び出すようにします。 シグナルを定義するには、@dbus.service.signal を付けてメソッドを定義します。
class CounterObject(dbus.service.Object): def __init__(self, bus, obj_path): dbus.service.Object.__init__(self, bus, obj_path) self.count = 0 @dbus.service.signal(INTERFACE, signature=&amp;#34;i&amp;#34;) def CountChanged(self, count): print(&amp;#39;Emit signal: &amp;#39; + str(count)) @dbus.service.method(INTERFACE, in_signature=&amp;#34;i&amp;#34;, out_signature=&amp;#34;&amp;#34;) def SetCount(self, count): print(&amp;#39;SetCount called: &amp;#39; + str(count)) self.count = count self.CountChanged(count) @dbus.service.method(INTERFACE, in_signature=&amp;#34;&amp;#34;, out_signature=&amp;#34;i&amp;#34;) def GetCount(self): print(&amp;#39;GetCount called&amp;#39;) return self.count クライアント側の実装 client-signal.py リモートオブジェクトを操作するためのインタフェースを取得したら、connect_to_signal() メソッドを呼ぶことで、シグナルハンドラを登録することができます。 下記の例では、CountChanged シグナルを、on_count_changed というシグナルハンドラで受信するように登録しています。
# Signal handler for &amp;#34;CountChanged&amp;#34; def on_count_changed(count): print(&amp;#39;CountChanged: &amp;#39; + str(count)) def main(): .</description></item><item><title>Linuxメモ: dbus-python で Session bus を使用するサーバ＆クライアントを実装する（単純なメソッドの実装）</title><link>https://maku77.github.io/p/app39n9/</link><pubDate>Wed, 05 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/app39n9/</guid><description>dbus-python を利用したサーバとクライアントの実装例です。 ここでは、SetCount() と GetCount() だけを行える Counter オブジェクトを提供するサービスと、クライアントを作成してみます。 インタフェース名などは以下のようにします。
Bus name: com.example.CounterService Object path: /com/example/CounterObject Interface: com.example.Counter Session bus を使用する Server を実装する server.py D-Bus server 側では、export するオブジェクトを dbus.service.Object を継承して作成します。 公開するメソッドには @dbus.service.method アノテーションを付けて、以下の設定を行います。
何という名前のインタフェース名で公開するか 入力パラメータの Type string (in_signature) 戻り値の Type string (out_signature) class CounterObject(dbus.service.Object): @dbus.service.method(INTERFACE, in_signature=&amp;#34;i&amp;#34;, out_signature=&amp;#34;&amp;#34;) def SetCount(self, count): self.count = count print(&amp;#39;SetCount called: &amp;#39; + str(count)) @dbus.service.method(INTERFACE, in_signature=&amp;#34;&amp;#34;, out_signature=&amp;#34;i&amp;#34;) def GetCount(self): print(&amp;#39;GetCount called&amp;#39;) return self.count 上記のように作成したオブジェクトは、以下のような手順で export します。
SessionBus オブジェクトの作成 session_bus = dbus.</description></item><item><title>Linuxメモ: dbus-python の公式サンプルコード</title><link>https://maku77.github.io/p/k2c9k5k/</link><pubDate>Tue, 04 Sep 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k2c9k5k/</guid><description>dbus-python のサンプルコード 下記は、dbus-python-1.1.1 に付属しているサンプルコードです。
単純なメソッドを実装したサーバー＆クライアント example-service.py example-client.py example-async-client.py シグナルを実装したサーバー＆クライアント example-signal-emitter.py その他 list-system-services.py python-dbus のインストール Python で import dbus の実行時にエラーが発生する場合は、python-dbus がインストールされていません。 以下のようにしてインストールしてください。
Ubuntu の場合 $ sudo apt-get install python-dbus</description></item><item><title>Linuxメモ: Bash の構文: 関数から戻り値を返す ($?)</title><link>https://maku77.github.io/p/8uionzb/</link><pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8uionzb/</guid><description>シェル関数が return で返すことのできる値は 数値 (0～255) だけ です。 return で返された戻り値を参照するには $? を使います。
function myfunc { return 1 } myfunc echo $? 関数の実行結果を文字列として受け取りたい場合は、関数内部で echo した結果を以下のようにバッククォート呼び出しして取得します。
function myfunc { echo &amp;#39;Hello&amp;#39; } val=`myfunc` echo $val</description></item><item><title>Linuxメモ: Bash の構文: 関数内でローカル変数を扱う (local)</title><link>https://maku77.github.io/p/52i36fy/</link><pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/52i36fy/</guid><description>Bash は関数外と関数内で変数を共有します。 例えば、以下のように関数内で代入を行うと、関数外でセットした値を上書きしてしまいます。
function myfunc { a=200 } 実行例 $ a=100 $ myfunc $ echo $a 200 ★aの値が変わってる！ 関数内だけで有効なローカル変数を扱うには以下のように local キーワードを付けます。
function myfunc { local a=200 } 実行例 $ a=100 $ myfunc $ echo $a 100 ★aの値はそのまま</description></item><item><title>Linuxメモ: rsync コマンドでディレクトリを同期する</title><link>https://maku77.github.io/p/dvd889d/</link><pubDate>Thu, 05 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dvd889d/</guid><description>rsync コマンドを使用すると、簡単に 2 つのディレクトリを同期することができます。 下記の例では、src ディレクトリの中身を dst ディレクトリに同期しています。
$ rsync -av src/ dst src の後ろにスラッシュを付ける のを忘れないようにしてください。 このスラッシュを忘れると、dst ディレクトリの中に src ディレクトリができちゃいます。 オプションの -a は archive mode として動作させることを示しており、よく使うオプションをまとめて指定したのと同様の効果があります (例えば、ディレクトリを再帰的にコピー、属性をそのまま保つなど)。
rsync コマンドは更新されているファイルだけをコピーしてくれるので、大量のファイルが格納されていても、同期処理は短時間で完了します。 rsync は、ローカル PC 内のディレクトリの同期だけではなく、リモートホスト上のディレクトリとの同期にも対応しています。 詳しい rsync コマンドの使い方は下記を参照してください。
参考: Linuxコマンド: rsync コマンドで2つのディレクトリを同期する</description></item><item><title>Linuxメモ: GDBus サーバから signal を発行する</title><link>https://maku77.github.io/p/o5744xu/</link><pubDate>Mon, 25 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o5744xu/</guid><description>GDBus のサーバ実装側からシグナルを発行するには、gdbus-codegen で生成されたヘッダファイルに定義されている、xxx_emit_xxx という関数を呼び出します。
あるメソッドの実装の中からシグナルを発行するには、そのメソッドの xxx_complete_xxx 関数を呼び出す前に、xxx_emit_xxx 関数を呼び出す必要があります。
// Implementation of &amp;#34;Add&amp;#34; method. gboolean handleAdd(ComExampleMyAppCalc *object, GDBusMethodInvocation *invocation, gint val1, gint val2) { gint ret = val1 + val2; // ここでシグナル発行 com_example_my_app_calc_emit_hoge_hoge(object, &amp;#34;data1&amp;#34;, &amp;#34;data2&amp;#34;); com_example_my_app_calc_complete_add(object, invocation, ret); return TRUE; }</description></item><item><title>Linuxメモ: D-Bus Java で P2P D-Bus サーバに接続してメソッドを呼び出すサンプル</title><link>https://maku77.github.io/p/uznw8u8/</link><pubDate>Fri, 22 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uznw8u8/</guid><description> Main.java import org.freedesktop.dbus.DBusSigHandler; import org.freedesktop.dbus.DirectConnection; import org.freedesktop.dbus.exceptions.DBusException; import com.example.MyApp.Calc; public class Main { private static final String SERVER_ADDR = &amp;#34;unix:abstract=sample&amp;#34;; private static final String OBJECT_PATH = &amp;#34;/com/example/MyApp&amp;#34;; public static void main(String[] args) { try { DirectConnection dc = new DirectConnection(SERVER_ADDR); Calc calc = dc.getRemoteObject(OBJECT_PATH, Calc.class); // ... int result = calc.Add(100, 200); // ... dc.disconnect(); } catch (DBusException e) { e.printStackTrace(); } ... } }</description></item><item><title>Linuxメモ: GDBus でバイナリデータ（バイト配列）を受け取る方法</title><link>https://maku77.github.io/p/y7cx287/</link><pubDate>Fri, 22 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y7cx287/</guid><description>D-Bus メソッド経由でバイト配列を送ろうとして、パラメータのタイプを ay と定義して、gdbus-codegen でコード生成すると、デフォルトでは gchar* 型の文字列データとしてパラメータが定義されてしまいます。 gchar* データとしてやりとりしようとすると、0 を含むデータを受け取れなくなってしまうので、GVariant* としてバイナリデータを受け取る必要があります。 そのためには、Introspection XML の arg 要素の子要素として、以下のように annotation 要素を追加します。
introspection.xml（抜粋） ... &amp;lt;method name=&amp;#34;PushBinaryData&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;ay&amp;#34; name=&amp;#34;data&amp;#34; direction=&amp;#34;in&amp;#34;&amp;gt; &amp;lt;annotation name=&amp;#34;org.gtk.GDBus.C.ForceGVariant&amp;#34; value=&amp;#34;true&amp;#34; /&amp;gt; &amp;lt;/arg&amp;gt; &amp;lt;/method&amp;gt; ... すると、GDBus サーバ側のハンドラでは GVariant* 型のパラメータとしてデータを受信できるようになるので、以下のように内部のデータを取得できます。 データのサイズも、GVariant オブジェクトから取得することができます。
// GVariant* variant; const char* p = (const char*) g_variant_get_data(variant); gsize size = g_variant_get_size(variant); for (int i = 0; i &amp;lt; size; ++i) { g_print(&amp;#34;data[%d]=%d\n&amp;#34;, i, p[i]); }</description></item><item><title>Linuxメモ: glib の GVariant を使ってみる</title><link>https://maku77.github.io/p/4w6f4u5/</link><pubDate>Wed, 20 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4w6f4u5/</guid><description>GVariant 型とは 本家ドキュメント GVariantType — introduction to the GVariant type system GVariant — strongly typed value datatype GVariant Format Strings GDBus のライブラリを使って、array や dictionary などのデータをやりとりしようとすると、C の実装としては GVariant 型で扱うことになります。 GVariant オブジェクトが保持するデータの型は、type strings という文字列で表現されます。 例えば、GVariant オブジェクトの type strings が、
&amp;#34;s&amp;#34; と定義されている場合、その GVariant オブジェクトは 1 つの文字列データを保持しています。 以下のサンプルコードは、1 つの文字列データを保持する GVariant オブジェクトを作成し、そこから文字列データを取り出す例です。
Makefile CXX = clang++ MY_LIBS = glib-2.0 CPPFLAGS = $(shell pkg-config --cflags ${MY_LIBS}) LDLIBS = $(shell pkg-config --libs ${MY_LIBS}) sample: sample.cpp sample.cpp #include &amp;lt;glib.</description></item><item><title>Linuxメモ: GDBus で簡単な P2P（クライアント＆サーバ）アプリを実装する</title><link>https://maku77.github.io/p/ce62z6o/</link><pubDate>Mon, 11 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ce62z6o/</guid><description>GDBus 用のスタブを自動生成する gdbus-codegen コマンドを使用すると、以下のような introspection データからスタブとなるコードを作成することができます。 gdbus-codegen コマンドがインストールされていない場合は以下のようにインストールできます。
$ sudo apt-get install libglib2.0-dev $ sudo apt-get install libglib2.0-doc ここでは、足し算と引き算を行う com.example.MyApp.Calc インタフェースを考えてみます。
interface.xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;node name=&amp;#34;/com/example/MyApp&amp;#34;&amp;gt; &amp;lt;interface name=&amp;#34;com.example.MyApp.Calc&amp;#34;&amp;gt; &amp;lt;method name=&amp;#34;Add&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val1&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val2&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;ret_val&amp;#34; direction=&amp;#34;out&amp;#34; /&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;method name=&amp;#34;Subtract&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val1&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val2&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;ret_val&amp;#34; direction=&amp;#34;out&amp;#34; /&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;/interface&amp;gt; &amp;lt;/node&amp;gt; 以下のように実行すると、calc.h と calc.c が生成されます。</description></item><item><title>Linuxメモ: D-Bus Java で Session bus に接続してメソッドを呼び出す</title><link>https://maku77.github.io/p/atszfrg/</link><pubDate>Tue, 15 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/atszfrg/</guid><description>D-Bus Java の CreateInterface コマンドを使用すると、API インタフェースを定義した XML ファイル (introspection data) から、Java のインタフェースを作成することができます。
ここでは、以下のような XML ファイルからインタフェースを生成します（セッションバスなどで公開されているオブジェクトに接続して生成することもできます）。
interface.xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;node name=&amp;#34;/com/example/MyApp&amp;#34;&amp;gt; &amp;lt;interface name=&amp;#34;com.example.MyApp.Calc&amp;#34;&amp;gt; &amp;lt;method name=&amp;#34;Add&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val1&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val2&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;ret_val&amp;#34; direction=&amp;#34;out&amp;#34; /&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;method name=&amp;#34;Subtract&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val1&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val2&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;ret_val&amp;#34; direction=&amp;#34;out&amp;#34; /&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;/interface&amp;gt; &amp;lt;/node&amp;gt; 生成 $ CreateInterface interface.xml &amp;gt; Calc.java 以下のようなファイルが生成されます。シンプル！
Calc.java /* File: com/example/MyApp/Calc.</description></item><item><title>Linuxメモ: D-Bus 関連用語</title><link>https://maku77.github.io/p/y3w7mc2/</link><pubDate>Mon, 14 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y3w7mc2/</guid><description>D-Bus 系のライブラリを使用するにあたって、知っておくべき用語を解説します。
Bus D-Bus の通信は、Bus を通して行われます。 Bus は、message bus という特殊なアプリケーション (daemon) が保持しており、以下のような種類があります。
system bus システム内で１つだけ存在する。カーネルレイヤの情報も収集し、USB 接続の検出などにも使われている。 session buses ユーザごとに存在する。一番よく使われるバス。Desktop bus とも呼ばれる。 private buses ２アプリが Peer-to-Peer で接続するためのバス。 Message Bus 経由で伝達する際の、データの１単位を表します。 プログラムで言うと１つのメソッド呼び出しのやり取りに相当します。 メッセージは内部的には非同期通信ですが、各ライブラリ (Bindings) の API として、同期メソッドが提供されています。
Namespace / Address Service name (Bus name) 個々のアプリケーションのバスへの &amp;ldquo;Connection&amp;rdquo; を示す名前。 ドキュメントによっては、&amp;ldquo;bus names&amp;rdquo; と読んでいるが、正確にはバスの名前ではなく、個々のバスへの &amp;ldquo;接続&amp;rdquo; を示す名前であることに注意。 （あくまで、バスの実体は system bus、session bus として存在していて、ここで言う &amp;ldquo;bus name&amp;rdquo;（接続を意味する）とは概念が異なる。） Service 名は、接続相手となるアプリの接続を指定するために使われるので、Java の package 名のように一意な名前をつける必要がある。 接続は一般的には１アプリで１つであり、例えば、mycompany.com というドメインを持つ会社が作成する MyApp というアプリの接続なら、com.mycompany.MyApp というようにドメイン名を逆順に使って名前を付ければよい。 同じアプリケーションが同時に複数起動するケースを考慮する場合は、それぞれのアプリの接続に別の Service 名を割り当てる必要がある。そのような場合は、例えば、Process ID を付加することで一意な Service 名を作り出す。 Object path それぞれの Service は複数の Object を公開することができ、それぞれの Object は複数の Interface を公開することができる。 Object 名は、Object path と呼ばれ、ディレクトリ構造のように / で区切った名前を定義する。 Object path は、必ず / で始めるため、最短でも &amp;ldquo;/&amp;rdquo; の一文字で構成される。 Object path は、一般的には Bus name と同様にドメイン名を使って、一意な Object path を付けることが多い（Object path の例: /com/mycompany/MyApp）。 実際には、アプリ要件ごとに柔軟に定義することができ、例えば、スプレッドシートアプリなら、1 つのセルを表す &amp;ldquo;/cell/A/10&amp;rdquo; のような Object path を定義することができる。 Interface Bus 経由で公開されるメソッド、シグナルの集まりのこと。メソッド名、パラメータ、戻り値などが定義される。 実際にプログラムで実装するメソッド名と合わせる必要はないが、通常は合わせる（Interface の例: org.</description></item><item><title>Linuxメモ: D-Bus Java をインストールする</title><link>https://maku77.github.io/p/dqd9932/</link><pubDate>Fri, 11 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dqd9932/</guid><description>（Ubuntu 12.04 で確認）
必要なファイルのダウンロード 以下から、dbus-java-2.7.tar.gz などをダウンロードします。
http://www.freedesktop.org/wiki/Software/DBusBindings INSTALL ドキュメントを見ると、他にも Metthew さんのライブラリが必要のようなので、以下から libmatthew-java-0.8.tar.gz などをダウンロードします。
http://www.matthew.ath.cx/projects/java/ ライブラリ (*.jar *.so) ファイルのビルド libmatthew-java のビルド $ tar xzvf libmatthew-java-0.8.tar.gz $ cd libmatthew-java-0.8 $ make jni.h が見つからないと言われたら、Makefile を編集して、jni.h のディレクトリにパスを通してから make を実行します。
INCLUDE+= ....... -I/usr/lib/jvm/java-7-openjdk-amd64/include make install まで実行すると、システムに jar ファイルと so ファイルがインストールされるのですが、ここでは、Linux 環境の汚染を防ぐために、make install は行わないことにします（プロジェクトごとに jar ファイルのクラスパスを指定するようにします）。
dbus-java のビルド dbus-java-2.7 のビルドには JDK の version 1.6 が必要そうです (dbus-java のコードが Java の Generics 構文などに対応できていません)。 JDK 1.6 がインストールされていない場合は先にインストールします。
Ubuntu での例 $ sudo apt-get install openjdk-6-jdk $ sudo update-java-alternatives -s java-1.</description></item><item><title>Linuxメモ: D-Bus 関連リンクと関連ツール</title><link>https://maku77.github.io/p/rexgyo3/</link><pubDate>Thu, 10 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rexgyo3/</guid><description>GDBus [本家] Highlevel D-Bus Support [本家] Lowlevel D-Bus Support GDBusServer (Peer-to-Peer の実装サンプル） gdbus-codegen ツールの使い方 D-Bus Java DBus-Java Documentation（Javadoc もあります） D-Bus low-level API や GLib bindings のコードを最初に見るよりも、先に Java bindings を使ってみるのが使い方のイメージを掴みやすいかも。
その他のリンク D-Bus GLib bindings - Reference Manual Development/Tutorials/D-Bus - KDE TechBase maemo.org - Plain_html: D. Source code for the GLib D-Bus synchronous example DBus low-level API を使ったサンプルコード D-Bus 関連ツール qdbusviewer (for Linux) GUI で、System Bus、Session Bus 上のサービスを一覧にし、そのサービスが公開しているオブジェクトと、メソッド＆シグナルも一覧にできるツール。メソッドの呼び出しと、その Reply の確認なども行えます。 qdbus (for Linux) qdbusviewer を CUI 版にしたようなツール。特に理由がなければ、qdbusviewer を使ったほうが便利です。</description></item><item><title>Linuxメモ: dbus-glib で method call を実装する（クライアント側の実装）</title><link>https://maku77.github.io/p/53cn789/</link><pubDate>Thu, 10 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/53cn789/</guid><description>dbus-binding-tool を使用すると、クライアント側の実装に使うヘッダーファイルとして、 以下のようなコードが自動生成されます。
client.h（抜粋） gboolean com_example_DBus_Test_Calc_add(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, gint* OUT_return_val, GError **error) { return dbus_g_proxy_call(proxy, &amp;#34;add&amp;#34;, error, G_TYPE_INT, IN_val1, G_TYPE_INT, IN_val2, G_TYPE_INVALID, G_TYPE_INT, OUT_return_val, G_TYPE_INVALID); } gboolean com_example_DBus_Test_Calc_subtract(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, gint* OUT_return_val, GError **error) { return dbus_g_proxy_call(proxy, &amp;#34;subtract&amp;#34;, error, G_TYPE_INT, IN_val1, G_TYPE_INT, IN_val2, G_TYPE_INVALID, G_TYPE_INT, OUT_return_val, G_TYPE_INVALID); } Async （非同期）版のコードも生成されていることが分かります。
DBusGProxyCall* com_example_DBus_Test_Calc_add_async(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, com_example_DBus_Test_Calc_add_reply callback, gpointer userdata) { // .</description></item><item><title>Linuxメモ: GDBus と dbus-glib</title><link>https://maku77.github.io/p/gqfnr2z/</link><pubDate>Wed, 09 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gqfnr2z/</guid><description>D-Bus の low-level API は libdbus というライブラリで提供されています。
通常、D-Bus アプリケーションを作成するときは、この low-level API だけ使用してコーディングするのではなく、D-Bus binding と呼ばれる、より上位のライブラリを使用します（というような記述が、D-Bus の API ドキュメントのトップに書いてあります）。
http://dbus.freedesktop.org/doc/api/html/index.html 例えば C 言語の場合は、dbus-glib や GDBus などがあります。 現在は dbus-glib は obsolete になっていて、GDBus が GIO ライブラリの一部として提供されているようです（glib-2.30.x 以降でサポート）。 とはいえ、現状は GDBus の情報はネット上にほとんどありません。
それぞれのライブラリで、API のプレフィックスが以下のように異なっているので、サンプルコードなどを読むときに、どのライブラリを使用しているかの判断基準になります。
Low-level API: dbus_XXX dbus-glib API: dbus_g_XXX GDBus API: g_dbus_XXX GDBus は dbus-glib と違い、内部で libdbus を使用していません。
GDBus は type system として GVariant をバリバリ使うので、GVariant についてマスターしている必要があります（はっきり言って、GVariant 使ったコードはあまり美しくないです）。
XML introspection データからグルーコード（Stub とか Proxy とか）を作成するツールがあるのですが、dbus-glib が dbus-binding-tool を使うのに対し、GDBus は gdbus-codegen というツールを使用します。</description></item><item><title>Linuxメモ: dbus-glib で method call を実装する（サーバ側の実装）</title><link>https://maku77.github.io/p/ed9gaii/</link><pubDate>Tue, 08 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ed9gaii/</guid><description>下記は dbus-glib によるサーバ実装のファイル一式です。
dbus-glib-server.zip 実行してから qdbusviewer アプリの表示を見ると、セッションバスに登録された com.example.MyApp サービスを確認することができます。
ちゃんと、com.example.MyApp.Calc インタフェースが公開されていることが分かります。</description></item><item><title>Linuxメモ: dbus-glib で method call を実装する（ヘッダファイルの生成）</title><link>https://maku77.github.io/p/uzr93f8/</link><pubDate>Tue, 08 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uzr93f8/</guid><description>ここでは、D-Bus (GLib bindings) を使って、リモートメソッド呼び出しを実現してみます。 名前は以下のように定義し、リモートでの足し算 (Add) と引き算 (Subtract) を実装します。
Bus name com.example.MyApp Object path /com/example/MyApp Interface com.example.MyApp.Calc Method Add(in INT32, in INT32, out INT32) Subtract(in INT32, in INT32, out INT32) dbus-binding-tool を使って、XML ファイルからサーバ、クライアント実装用のヘッダファイルを生成できます。
interface.xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;node name=&amp;#34;/com/example/MyApp&amp;#34;&amp;gt; &amp;lt;interface name=&amp;#34;com.example.MyApp.Calc&amp;#34;&amp;gt; &amp;lt;method name=&amp;#34;Add&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val1&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val2&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;ret_val&amp;#34; direction=&amp;#34;out&amp;#34; /&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;method name=&amp;#34;Subtract&amp;#34;&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val1&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;val2&amp;#34; direction=&amp;#34;in&amp;#34; /&amp;gt; &amp;lt;arg type=&amp;#34;i&amp;#34; name=&amp;#34;ret_val&amp;#34; direction=&amp;#34;out&amp;#34; /&amp;gt; &amp;lt;/method&amp;gt; &amp;lt;/interface&amp;gt; &amp;lt;/node&amp;gt; ヘッダファイルの生成 $ dbus-binding-tool --mode=glib-server --prefix=ServerImpl interface.</description></item><item><title>Linuxメモ: dbus-glib 開発用ライブラリをインストールする</title><link>https://maku77.github.io/p/pksy5or/</link><pubDate>Wed, 02 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pksy5or/</guid><description>（Ubuntu 12.04 で確認）
dbus-glib ライブラリのインストール ここでは、D-Bus library (GLib bindings) をインストールして、C/C++ で D-Bus を使ったコードをコンパイルできるようにします。
$ sudo apt-get install libdbus-glib-1-dev ちなみに、apt-cache search 'libdbus' のように実行すると、それっぽいパッケージを検索することができます。
上記を実行すると、以下のようなヘッダファイルがインストールされます。
/usr/include/dbus-1.0/dbus/dbus.h /usr/include/dbus-1.0/dbus/dbus-glib.h ... /usr/include/glib-2.0/glib.h ... /usr/lib/x86_64-linux-gnu/glib-2.0/include （64 bit Linux の場合） D-Bus、GLib bindings のヘッダをインクルードするコードをビルドしてみる main.cpp #include &amp;lt;dbus/dbus.h&amp;gt; #include &amp;lt;dbus/dbus-glib.h&amp;gt; #include &amp;lt;glib.h&amp;gt; int main() { } ビルド $ clang++ main.cpp `pkg-config --cflags --libs dbus-glib-1` ここで使用している pkg-config コマンドは、指定したライブラリのインクルードパスなどのオプション文字列を生成してくれます。 単独で実行すると、例えば以下のような出力が得られます。
$ pkg-config --cflags --libs dbus-glib-1 -I/usr/include/dbus-1.0 -I/usr/lib/x86_64-linux-gnu/dbus-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -ldbus-glib-1 -ldbus-1 -lpthread -lrt -lgobject-2.</description></item><item><title>Linuxメモ: シェルスクリプトで配列を扱う</title><link>https://maku77.github.io/p/m82nd2v/</link><pubDate>Thu, 02 Feb 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m82nd2v/</guid><description>Bash シェルスクリプト内で配列を扱う方法です。
配列を作成する 下記の例では、配列変数 arr に 3 つの要素を格納しています。
インデックスを指定して1つずつ代入していく方法 arr[0]=AAA arr[1]=100 arr[2]=&amp;#39;Hello world&amp;#39; echo ${arr[0]} echo ${arr[1]} echo ${arr[2]} 実行結果 AAA 100 Hello world 配列の初期化時に要素をまとめて指定する方法 arr=(AAA BBB CCC) echo ${arr[0]} echo ${arr[1]} echo ${arr[2]} 実行結果 AAA BBB CCC 以下のように、複数行にまたいで値を記述することもできます。
arr=( AAA BBB CCC ) 配列をループ処理する 下記の例では、3 つの要素を持つ配列変数 arr を定義し、各要素をループで 1 つずつ処理しています。 配列要素の値にスペースが含まれる場合、下記の &amp;quot;CCC DDD&amp;quot; のようにダブルクォートで囲む必要があります。
arr=(AAA BBB &amp;#34;CCC DDD&amp;#34;) for x in &amp;#34;${arr[@]}&amp;#34;; do echo &amp;#34;$x&amp;#34; done 実行結果 AAA BBB CCC DDD ちなみに、上記のコードは、以下のようにすれば配列変数を定義しないで書けます。</description></item><item><title>Linuxメモ: Linux システムコールを使用して core dump を吐かないようにする (setrlimit)</title><link>https://maku77.github.io/p/afze7gn/</link><pubDate>Tue, 11 Oct 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/afze7gn/</guid><description>Linux プロセスが異常終了した場合に吐き出される core dump ファイルはセキュリティホールになり得ます。 core dump ファイルを出力しないようにするには、各プロセスで以下のように Linux システムコールの setrlimit を実行します。
core dump を吐かないようにする (C&amp;#43;&amp;#43;) // #include &amp;lt;sys/time.h&amp;gt; // #include &amp;lt;sys/resource.h&amp;gt; rlimit rl; rl.rlim_cur = 0; // soft limit rl.rlim_max = 0; // hard limit if (setrlimit(RLIMIT_CORE, &amp;amp;rl) != 0) { // setrlimit failed! exit process } このように実行しておけば、仮に root を奪取されて ulimit -c コマンドを実行されても core dump を吐かなくなります。</description></item><item><title>Linuxメモ: echo で出力する文字の色を変える</title><link>https://maku77.github.io/p/fufwdub/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fufwdub/</guid><description>Linux の echo コマンドで特殊なエスケープシーケンスを出力すると、テキストの文字を変更することができます。 次の Bash スクリプトでは、色を変更しつつ echo 出力する、error / warn / info 関数を定義しています。
sample.sh #!/bin/bash error() { echo -e &amp;#34;\033[31m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } warn() { echo -e &amp;#34;\033[33m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } info() { echo -e &amp;#34;\033[32m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } error &amp;#39;Error message&amp;#39; warn &amp;#39;Warning message&amp;#39; info &amp;#39;Information message&amp;#39; このシェルスクリプトを実行すると、次のように色付きのメッセージが表示されます。
図: echo コマンドの出力色を変更 ちなみに、echo コマンドの末尾の &amp;gt;&amp;amp;2 は、標準エラー出力へ出力することを示しています。
参考: echo の結果を標準エラー出力 (stderr) に出力する (1&amp;gt;&amp;amp;2)</description></item><item><title>Linuxメモ: 改行コードが原因の関数定義の syntax error</title><link>https://maku77.github.io/p/c2ycgaj/</link><pubDate>Wed, 27 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c2ycgaj/</guid><description>下記は簡単な関数を定義しているだけのシンプルなシェルスクリプトですが、
my_functions.sh function hello { echo &amp;#39;Good morning!&amp;#39; } このファイルを source コマンドで読み込んだときに以下のような syntax error が出ることがあります。
$ source my_functions.sh &amp;#39;ash: my_functions.bash: line 1: syntax error near unexpected token `{ &amp;#39;ash: my_functions.bash: line 1: `function hello { このようなエラーが出る場合は、テキストファイルの改行コードが Windows (CR+LF) で保存されている可能性があります。 改行コードを変更するには、例えば Vim エディタから以下のように実行します。
:set ff=unix :w</description></item><item><title>Linuxメモ: Bash の構文: 関数へパラメータを渡す</title><link>https://maku77.github.io/p/ecj6wbo/</link><pubDate>Fri, 15 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ecj6wbo/</guid><description>関数に渡されたパラメータの処理方法は、シェルスクリプト実行時に渡されたコマンドラインパラメータの処理方法と同じです。 以下のコマンドラインパラメータの処理方法に関する記事も参考にしてください。
コマンドライン引数を取得する 関数へ渡されたパラメータの数を調べる ($#) 関数内で $# を参照すると、渡されたパラメータの数を調べることができます。
サンプルコード function foo { echo $# } 実行結果 $ foo 100 200 2 $ foo aaa bbb ccc 3 $ foo &amp;#34;This is a pen&amp;#34; 1 ☝️ ワンポイント 関数の外で $# を参照すると、シェルスクリプト実行時に渡されたコマンドラインパラメータの数を取得できます。 応用例: 関数へ渡されたパラメータが少なくとも 1 つ以上あるか調べる function foo { if [ $# -lt 1 ]; then echo &amp;#39;Function &amp;#34;foo&amp;#34; needs at least one parameter&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi echo &amp;#39;OK&amp;#39; } 関数へ渡されたパラメータを順番に処理する サンプルコード function enum_params { while [ -n &amp;#34;$1&amp;#34; ]; do echo $1 shift done } [ -n &amp;quot;$1&amp;quot; ] の部分では、パラメーターが空文字ではないかどうかを調べています。 shift コマンドは、パラメータを左にシフトします。 つまり、$2 の値が $1 に、$3 の値が $2 に、というようにシフトされます。 これにより、すべてのパラメーターを $1 で順番に参照することができます。</description></item><item><title>Linuxシェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while)</title><link>https://maku77.github.io/p/or3cmv6/</link><pubDate>Sun, 06 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/or3cmv6/</guid><description>ワイルドカードを使用する方法 ワイルドカード (*) を使って、カレントディレクトリ内のファイルをループ処理することができます。
例: すべてのファイル（ドットファイルを除く）をループ処理 for x in *; do echo &amp;#34;$x&amp;#34; done 特定の拡張子を持つファイルのみを列挙するには次のようにします。
例: すべての PNG ファイルをループ処理 for x in *.png; do echo $x done 次のように一行で書くこともできます。
for x in *.png; do echo &amp;#34;$x&amp;#34;; done find コマンドの結果を使用する方法（再帰的にファイル探索） 下記の例では、find コマンドによって見つかったファイルを while ループで順番に処理しています。 深い階層にあるファイルも再帰的に処理されます。
find . -type f | while read x; do echo &amp;#34;$x&amp;#34; done 参考: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)</description></item><item><title>Linuxメモ: カーネルに渡されたパラメータを調べる (/proc/cmdline)</title><link>https://maku77.github.io/p/3wheif6/</link><pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3wheif6/</guid><description>/proc/cmdline の内容を出力すると、カーネルへ渡されたコマンドラインパラメータを調べることができます。
$ cat /proc/cmdline BOOT_IMAGE=/boot/vmlinuz-2.6.32-28.generic root=UUID=37c279f8-9c77-78c5-c379-d01e2c480351 ro quiet splash 他にも、/proc 以下のファイルにアクセスしていろいろな情報を取得することができます。 例えば、cat /proc/cpuinfo とすると、CPU の情報を調べることができます。 どのような情報を取得できるか、man proc で確認してみてください。</description></item><item><title>Linuxメモ: Linux のメモリ情報を調べるコマンド</title><link>https://maku77.github.io/p/2tumm9k/</link><pubDate>Thu, 20 Jan 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2tumm9k/</guid><description>free コマンド free コマンドを使用して、Linux システム全体の空きメモリ容量 (KByte) を調べることができます。 内部的には、/proc/meminfo の内容を整形して表示しています。
実行例（Ubuntu 10.04 の場合） $ free total used free shared buffers cached Mem: 4057716 3110204 947512 0 255708 2091224 -/+ buffers/cache: 763272 3294444★ ←実質的な空き容量はここを見る Swap: 11884536 60600 11823936 Linux では、ディスクアクセスの負荷軽減のために、空きメモリをバッファ領域（ファイルのメタ情報などを保持）とキャッシュ領域（ファイルの内容そのものをキャッシュ）に割り当てています。 上記の Mem: の行の free 値 947512 は、空き容量からバッファ領域 (buffers) とキャッシュ領域 (cached) に割り当てた分を差し引いた値を示しているので、free の値はいつも小さくなります。 実質的な空き容量を求めるには、free の値に buffers と cached の分を足してやる必要があります。 その下の行の -/+ buffers/cache: というところがこの計算をした結果を示しており、一行目の free、buffers、cached をすべて足した、実質的な空き容量が表示されています。
3294444（実質 free） = 947512 (mem free) + 255708 (buffers) + 2091224 (cached) おまけ: free コマンドの help やオプション 下記は free コマンドのヘルプ説明です。</description></item><item><title>Linuxメモ: カレントディレクトリや指定したファイルの絶対パスを取得する</title><link>https://maku77.github.io/p/arxcjmp/</link><pubDate>Fri, 15 Oct 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/arxcjmp/</guid><description>カレントディレクトリの絶対パスを取得する 以下のどの方法でも、カレントディレクトリの絶対パスを取得できます。
current_dir=$(pwd) current_dir=&amp;#34;$PWD&amp;#34; current_dir=`pwd` 指定したファイルの絶対パスを取得する 相対パスで指定したファイルのパスを絶対パスに変換するには、下記のように dirname と basename を組み合わせて使用します。 $path には、カレントディレクトリからの相対パスでファイル名が格納されているとします。
abs_path=$(cd $(dirname $path); pwd)/$(basename $path) 内部で cd コマンドを実行しているため、ディレクトリ名を含むパスを指定したときは、実際にそのディレクトリが存在していないといけないことに注意してください。 下記のサンプルスクリプトは、コマンドラインパラメータとして渡された相対パスを絶対パスに変換します。
rel2abs.sh（渡されたファイルパスを絶対パスに変換する） #!/bin/bash abs_path=$(cd $(dirname $1); pwd)/$(basename $1) echo &amp;#34;$abs_path&amp;#34; 実行結果 $ cd /Users/maku/scripts $ ./rel2abs.sh aaa/bbb/ccc.txt /Users/maku/scripts/aaa/bbb/ccc.txt $ cd /Users/maku $ scripts/rel2abs.sh scripts/aaa/bbb/ccc.txt /Users/maku/scripts/aaa/bbb/ccc.txt 実行時のカレントディレクトリが異なっていても、正しく絶対パスを取得できていることがわかると思います。</description></item><item><title>Linuxメモ: シェルスクリプト: 定数を定義する (readonly)</title><link>https://maku77.github.io/p/dwsvs5j/</link><pubDate>Tue, 07 Sep 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dwsvs5j/</guid><description>Bash スクリプト内で定数を定義するには、readonly コマンドを使用します。 readonly を使うことで、変数や関数を読み取り専用に設定でき、誤って値を変更したり削除したりすることを防げます。 下記のように実行すると、指定した変数や関数に対する代入や unset ができなくなります。
readonly my_var # 変数 my_var を readonly に readonly -a my_arr # 配列 my_arr を readonly に readonly -f my_func # 関数 my_func を readonly に 変数の定義と同時に readonly 指定することも可能です。
readonly USERNAME=maku 下記の例では、変数 MAX_SIZE を値 100 で初期化し、その後 200 という値を代入しようとしています。
sample.sh #!/bin/bash readonly MAX_SCORE=100 MAX_SCORE=200 MAX_SCORE 変数は readonly 化されているので、代入を実行しようとしたときにエラーになります。
実行結果 $ ./sample.sh ./sample.sh: 行 4: MAX_SCORE: 読み取り専用の変数です</description></item><item><title>Linuxメモ: シェルスクリプトのあるディレクトリの絶対パスを取得する</title><link>https://maku77.github.io/p/m5z4fi3/</link><pubDate>Fri, 20 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m5z4fi3/</guid><description>スクリプト自身の格納されているディレクトリの絶対パスは下記のようにして得ることができます（内部的に cd を実行していますが、実行後のカレントディレクトリが変わってしまうことはありません）。
self_dir=$(cd $(dirname $0); pwd) ちなみに、シェルスクリプトと同じディレクトリにあるファイルの絶対パスは、上記で求めたディレクトリパスと組み合わせれば作れます。
echo ${self_dir}/sample.txt</description></item><item><title>Linuxメモ: NTP でシステム時刻を設定する</title><link>https://maku77.github.io/p/4zi9s4y/</link><pubDate>Thu, 22 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4zi9s4y/</guid><description>（Ubuntu 9.04 で確認）
NTP による時刻設定を有効にする まず、ntp パッケージをインストールします。
$ sudo apt-get install ntp 使用する NTP サーバは、下記のファイルで指定します。
/etc/ntp.conf server ntp.ubuntu.com 上記のような行を編集して、任意の NTP サーバのアドレスを指定してください。 複数の NTP サーバを指定することもできます。
最後に NTP daemon を再起動すれば NTP による自動時刻設定が有効になります。
$ sudo /etc/init.d/ntp restart NTP の動作確認 $ sudo ntpq -p 上記のコマンドで、サーバ名が表示されれば OK です。
手動で NTP サーバの時刻を取得 ntpdate コマンドを使用して、明示的に OS のシステム時刻を NTP サーバの時刻に同期させることができます。
$ sudo ntpdate -u ntp.ubuntu.com</description></item><item><title>Bash の変数展開機能を活用する（文字列の置換、デフォルト値など）</title><link>https://maku77.github.io/p/jsctar8/</link><pubDate>Tue, 20 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jsctar8/</guid><description>Bash の変数は通常 ${x} のような形で参照しますが、様々な変数展開機能を利用すると、変数の存在を確認したり、一部を置換したり、デフォルト値を設定したりすることができます。 下記にざっと紹介しますが、公式なドキュメントは man bash の Parameter Expansion のセクションで参照することができます。
パターン照合演算子 次のような変数展開の構文を使用すると、変数に格納された文字列の一部を置換した文字列を作成することができます。
構文 意味 ${変数/パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（１つだけ） ${変数//パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（すべて） ${変数#パターン} 先頭から最短一致でパターンに一致する部分を取り除く ${変数##パターン} 先頭から最長一致でパターンに一致する部分を取り除く ${変数%パターン} 末尾から最短一致でパターンに一致する部分を取り除く ${変数%%パターン} 末尾から最長一致でパターンに一致する部分を取り除く パターン部分では、ワイルドカード（*、?、[a-z] など）を使用できます。
例: 変数内の b を B に置換する $ x=aaabbbccc $ y=${x/b/B} $ echo $y aaaBbbccc 最初に見つかった文字列だけが置換されていることがわかります。 パターンに一致する文字列をすべて置換するには次のようにします（最初のスラッシュを2つにします）。
$ x=aaabbbccc $ y=${x//b/B} $ echo $y aaaBBBccc 以下のように sed コマンドを使ったのと同様の効果を bash の機能だけで実現できていることになります。
$ y=$(echo $x | sed -e &amp;#39;s/bbb/BBB/g&amp;#39;) 例: フルパスから basename を取り出す 下記の例では /aaa/bbb/ccc という絶対パスから、ベースネーム部分の ccc を抽出しています。 */ というパターンで先頭から最長一致させ、/aaa/bbb/ という部分を取り除いています。</description></item><item><title>Linuxメモ: bash のバージョンを調べる ($BASH_VERSION)</title><link>https://maku77.github.io/p/9w4ywr2/</link><pubDate>Tue, 20 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9w4ywr2/</guid><description>現在使用している bash のバージョンは、$BASH_VERSION 環境変数で参照することができます。
CentOS 5.5 の場合 $ echo $BASH_VERSION 3.2.25(1)-release Ubuntu 12.04 の場合 $ echo $BASH_VERSION 4.2.24(1)-release</description></item><item><title>Linuxメモ: 絶対パスと相対パスの変換 (basename, dirname)</title><link>https://maku77.github.io/p/3qgbv7i/</link><pubDate>Tue, 20 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3qgbv7i/</guid><description>basename - ファイル名だけを抽出する Linux の basename コマンドを使うと、パスを表す文字列からファイル名だけを抽出できます。
$ basename /aaa/bbb/ccc ccc $ basename /aaa/bbb/ccc/ ccc $ basename aaa/bbb/ccc ccc dirname - ディレクトリ、ファイルが格納されているディレクトリのパスを抽出する Linux の dirname コマンドを使うと、ファイルやディレクトリが格納されているディレクトリのパスを抽出できます。
$ dirname /aaa/bbb/ccc /aaa/bbb $ dirname /aaa/bbb/ccc/ /aaa/bbb $ dirname aaa/bbb/ccc aaa/bbb</description></item><item><title>Linuxシェルスクリプト: ある外部コマンドが使用できるかチェックする</title><link>https://maku77.github.io/p/xi5sjju/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xi5sjju/</guid><description>シェルスクリプトの中で特定の外部コマンドを使用する必要がある場合、先頭部分でその外部コマンドが使用できる状態かどうかを調べておくと親切です。 例えば、次のようにすれば、ruby コマンドが使用できるかを確認できます。
sample.sh if type -P ruby &amp;gt; /dev/null; then echo &amp;#39;ruby コマンドを使用できます&amp;#39; else echo &amp;#39;ruby コマンドが見つかりません&amp;#39; fi ☝️ type -P コマンド type -P ruby コマンドは、パスの通ったディレクトリから ruby を検索してそのパスを取得するためのものですが、ここでは ruby コマンドが使用できる環境になっているかを確認するために利用しています。 単純に実行すると、検索結果のパスが出力されてしまうので、null デバイスへリダイレクトして出力を抑制しています。 特定のコマンドが使用できない場合にスクリプトを終了させるには、以下のように記述すればよいでしょう。 条件式を ! で反転させていることに注意してください。
if ! type -P ruby &amp;gt; /dev/null; then echo &amp;#39;This script requires Ruby. Please install Ruby first and try again.&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続</description></item><item><title>Linuxシェルスクリプト: ある環境変数が定義されているかチェックする (test -z)</title><link>https://maku77.github.io/p/r3myewb/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r3myewb/</guid><description>環境変数がセットされているかを確認する 下記の例では、SRC_ROOT という環境変数が設定されているかを調べ、設定されていない場合はメッセージを表示して終了しています。
sample.sh #!/bin/bash if [ -z &amp;#34;$SRC_ROOT&amp;#34; ]; then echo &amp;#39;Please set the &amp;#34;SRC_ROOT&amp;#34; environment variable and try again.&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi echo &amp;#39;Program continues...&amp;#39; -z は、指定された変数の文字列長が 0 であるかを調べるオプションです。 SRC_ROOT 変数にスペースを含む文字列が設定されている場合に備えて、&amp;quot;$SRC_ROOT&amp;quot; のようにダブルクォートで囲むことをお勧めします。
☝️ ワンポイント echo の出力を &amp;gt;&amp;amp;2 とリダイレクトすると標準エラー出力へ出力できます。 実行例 $ ./sample.sh Please set the &amp;#34;SRC_ROOT&amp;#34; environment variable and try again. $ SRC_ROOT=/Users/maku/src ./sample.sh Program continues... （おまけ）test コマンドについて if [ -z &amp;#34;$SRC_ROOT&amp;#34; ]; then という条件判定は、次のように test コマンドを使うのと同等です。
if test -z &amp;#34;$SRC_ROOT&amp;#34;; then test -z コマンドは、指定された変数値の文字列長が 0 かどうかを確認するコマンドです。 これを利用して、上記のように 特定の変数値がセットされていない ことを調べることができます。</description></item><item><title>Linuxシェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#)</title><link>https://maku77.github.io/p/4tbzpyf/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4tbzpyf/</guid><description>関連記事: Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*)
コマンドライン引数が足りないときに Usage 出力して終了する シェルスクリプト起動時に渡されたコマンドライン引数の数は、$# 変数で取得することができます。 シェルスクリプトが最低 2 つのパラメーターを必要としている場合は、先頭部分で下記のようなチェックをするのがよいでしょう。
例: 2 つ以上のパラメーターが必要 #!/bin/bash if [ $# -lt 2 ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続 下記はバリエーションです。
例: 1 つ以上のパラメーターが必要 #!/bin/bash if [ ! &amp;#34;$1&amp;#34; ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続 例: 1 つの引数が必要で、かつ、その名前のファイルが存在する #!/bin/bash if [ ! &amp;#34;$1&amp;#34; ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi if [ !</description></item><item><title>Linuxメモ: シェルスクリプト: 数値変数を加算／減算する</title><link>https://maku77.github.io/p/3cukwcu/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3cukwcu/</guid><description>数値変数 val の値に対して加算／減算を行うには下記のようにします。
val=100 let val=$val+200 echo $val あるいは、下記のように記述することもできます。
val=100 val=$(($val+200)) echo $val 実行結果 300</description></item><item><title>Linuxメモ: Linux カーネル／OS のバージョンを調べる</title><link>https://maku77.github.io/p/odgqrwa/</link><pubDate>Tue, 01 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/odgqrwa/</guid><description>Linux カーネルのバージョンを調べる $ cat /proc/version $ uname -a Linux OS のバージョンを調べる Ubuntu の場合 $ cat /etc/lsb-release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=13.10 DISTRIB_CODENAME=saucy DISTRIB_DESCRIPTION=&amp;#34;Ubuntu 13.10&amp;#34; $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 13.10 Release: 13.10 Codename: saucy Debian の場合 $ cat /etc/debian_version 5.0 CentOS（RedHat系）の場合 $ cat /etc/redhat-release CentOS release 5.5 (Final) Fedora の場合 $ cat /etc/fedora-release Fedora release 9 (Sulphur)</description></item><item><title>Linuxメモ: シェルスクリプトを実行したユーザの名前を調べる</title><link>https://maku77.github.io/p/3eofc3v/</link><pubDate>Wed, 16 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3eofc3v/</guid><description>下記の例では、シェルスクリプトを実行したユーザが root であるかどうかを調べています。
if [ &amp;#34;$USER&amp;#34; != &amp;#34;root&amp;#34; ]; then echo &amp;#34;Must be executed by root.&amp;#34; exit -1 fi</description></item><item><title>Linuxメモ: Bash の構文: 関数を定義する／削除する</title><link>https://maku77.github.io/p/em67j5z/</link><pubDate>Tue, 15 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/em67j5z/</guid><description>関数定義の基本 Bash では以下のいずれかの構文を利用して、関数を定義することができます。
function funcname { &amp;lt;shell commands...&amp;gt; } funcname() { &amp;lt;shell commands...&amp;gt; } 開き括弧 ({) は、上記のように関数名と同じ行に記述してもよいし、次の行に単独で記述してもよいです。
関数を削除する 定義されている関数を削除するには以下のようにします。
unset -f funcname 現在のログインセッションでどんな関数が定義されているかを調べるには以下のようにします。
$ declare -F # 関数名のみ出力 $ declare -f # 関数の定義も出力 関数と環境変数 関数はスクリプトとは異なり、実行したシェルと同じプロセスで実行されます。 つまり、以下のように関数内で環境変数を設定すれば、関数を呼び出したシェルにも反映されます。
myfunc() { export AAA=100 } 空の関数は syntax error になる 中身が空の関数が定義されていると、構文エラーが発生するようです。
myfunc() { # syntax error } エラーの例 $ ./sample.sh ./sample.sh: 行 3: 予期しないトークン `}&amp;#39; 周辺に構文エラーがあります ./sample.sh: 行 3: `}&amp;#39;</description></item><item><title>Linuxメモ: Bash の構文: ループ内での複数の出力をまとめてリダイレクト、パイプ処理する</title><link>https://maku77.github.io/p/tmm4zvz/</link><pubDate>Wed, 02 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tmm4zvz/</guid><description>コマンドのグルーピング Bash 上で任意のコマンドを実行するときに、
$ (command1; command2; command3) のようにコマンドを括弧 () で囲んでグルーピングすると、リダイレクトなどの効果が全てのコマンドに対して働くようになります。
$ (echo &amp;#39;AAA&amp;#39;; echo &amp;#39;BBB&amp;#39;; echo &amp;#39;CCC&amp;#39;) &amp;gt; output.txt 上記は一行で記述していますが、次のように複数行に分けて記述することもできます。 この場合、各コマンドの末尾にセミコロン (;) は必要ありません。
( echo &amp;#39;AAA&amp;#39; echo &amp;#39;BBB&amp;#39; echo &amp;#39;CCC&amp;#39; ) &amp;gt; output.txt グルーピングしたコマンドの出力をパイプ処理でつなげていくこともできます。
( echo &amp;#39;foo&amp;#39; echo &amp;#39;bar&amp;#39; echo &amp;#39;yahoo&amp;#39; echo &amp;#39;foo&amp;#39; ) | sort | uniq 括弧で囲まれたコマンドは子シェルで実行されるので、その中でカレントディレクトリや環境変数などを変更した場合は、コマンド終了時に元に戻ります。 一時的にカレントディレクトリを変更してコマンドを実行したい場合に便利です。
$ pwd /home $ (cd /etc; pwd) /etc $ pwd /home ループ内の出力をリダイレクトする for ループや while ループの中で echo 出力した結果は、done の後ろでリダイレクトするようにすれば、まとめてファイルに出力することができます。
for x in AAA BBB CCC; do echo &amp;#34;$x&amp;#34; echo &amp;#34;.</description></item><item><title>Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*)</title><link>https://maku77.github.io/p/c2kx7er/</link><pubDate>Wed, 29 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c2kx7er/</guid><description>コマンドライン引数の基本 ($1 ~ $9) bash シェルスクリプト実行時にコマンドラインで渡した引数を参照するには、次のようなパラメーター参照用の特殊変数を使用します。
$1 &amp;hellip; 第 1 パラメーター $2 &amp;hellip; 第 2 パラメーター $3 &amp;hellip; 第 3 パラメーター パラメーターの参照には、$1 〜 $9 が使用できます。 使用することは余りないと思いますが、10 番目以降のパラメータを参照したいときは、${10} のように数値を {} で囲めば参照できます。
sample.sh #!/bin/bash echo &amp;#39;1 番目: &amp;#39; &amp;#34;$1&amp;#34; echo &amp;#39;2 番目: &amp;#39; &amp;#34;$2&amp;#34; echo &amp;#39;3 番目: &amp;#39; &amp;#34;$3&amp;#34; 実行結果 $ ./sample.sh AAA BBB &amp;#34;CCC DDD&amp;#34; 1 番目: AAA 2 番目: BBB 3 番目: CCC DDD コマンドライン引数を指定しなかった場合は、対応する変数は空になります。
$ ./sample.sh AAA 1 番目: AAA 2 番目: 3 番目: ☝️ 変数はダブルクォートで囲む echo の引数として変数の値を渡すときは、&amp;quot;$1&amp;quot; のようにダブルクォートで囲む癖をつけましょう。 $1 のようにそのまま記述してしまうと、変数の値として連続するスペースが含まれていたときに 1 つのスペースにまとめられてしまいます。 ☝️ 引数とパラメーターの違い 正確には、引数 (arguments) という用語は、スクリプトや関数を呼び出す側が渡す値のことを示し、パラメーター (parameters) という用語は、呼び出される側のスクリプトや関数が、その値を参照するときに使う変数のことを示します。 ただ、どちらのケースでもパラメーターという用語を使っているドキュメントもよく見かけるので、あまり気にしない方がよさそうです。 コマンドライン引数にデフォルト値を指定する (${1:-XXX}) コマンドライン引数が指定されなかったときに使用する値として、デフォルト値を指定しておくこともできます。 デフォルト値は、パラメーター参照時に ${1:-デフォルト値} という形で指定します。 下記の例では、1 番目、2 番目、3 番目のコマンドラインパラメーターのデフォルト値を、それぞれ AAA、BBB、CCC に設定しています。</description></item><item><title>Linuxメモ: Bash の構文: for/while によるループ処理</title><link>https://maku77.github.io/p/eimpfje/</link><pubDate>Tue, 28 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eimpfje/</guid><description>スペースで区切られた単語（ワード）を順番に処理する 次の Bash スクリプトでは、ループ処理したいテキスト (aaa, bbb, ccc) を直接 for ループで指定しています。 ここでは、do を for と同じ行に記述するコーディングスタイルを採用しています。
例: aaa bbb ccc を順番に処理 for x in aaa bbb ccc; do echo $x done 実行結果 aaa bbb ccc 以下のように、スペースで区切られた文字列が格納された文字列変数を処理することもできます。
list=&amp;#34;aaa bbb ccc&amp;#34; for x in $list; do echo $x done スペースを含む文字列を1つの要素として扱う リスト内の各要素をダブルクォートで囲んでおくと、その単位でループ処理されるようになります。
#!/bin/bash for i in &amp;#34;aaa bbb&amp;#34; &amp;#34;ccc ddd&amp;#34; &amp;#34;eee fff&amp;#34;; do echo $i done 実行結果 aaa bbb ccc ddd eee fff 変数を使う場合もほぼ同様ですが、それぞれの変数をダブルクォートで囲む 必要があります（これを忘れると、それぞれの変数内の文字列がスペースで区切られてループ処理されてしまいます）。</description></item><item><title>Linuxメモ: あるファイルがテキストファイルかどうか調べる (file)</title><link>https://maku77.github.io/p/ams75pd/</link><pubDate>Mon, 08 Sep 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ams75pd/</guid><description>テキストファイルを file コマンドにかけると、... text ... のような結果が出力されます。 それを grep することで、そのファイルがテキストファイルかどうか調べることができます。
$ file sample.txt | grep text</description></item><item><title>Linuxメモ: ファイルやディレクトリを検索する (find, grep)</title><link>https://maku77.github.io/p/hudubr8/</link><pubDate>Mon, 08 Sep 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hudubr8/</guid><description>find と grep の基本 指定した拡張子のファイルを検索する (find) 次のようにすると、カレントディレクトリ (.) を起点にして、拡張子 .txt を持つファイルを検索して一覧表示することができます。
$ find . -name &amp;#39;*.txt&amp;#39; ファイル内の文字列を検索する (grep) 次のようにすると、指定したテキストファイル内の文字列を検索することができます。
$ grep &amp;#39;検索文字列&amp;#39; hello.txt find で見つけたファイルの中身を grep 検索する find で検索した結果のファイルそれぞれに対して、grep コマンドを実行するには、xargs を組み合わせて使用します。
例: 拡張子に txt を持つファイルを grep $ find . -type f -name &amp;#39;*.txt&amp;#39; | xargs grep &amp;#39;検索文字列&amp;#39; 拡張子などを絞り込まず、単純にそのディレクトリ以下のすべてのテキストファイルを検索するだけでよいのであれば、find を使わず、grep の再帰オプション (-r) を使った方が簡単です。 念のため、テキストファイルのみを grep 対象にするために -I オプション (--binary-files-without-match) も一緒に指定しておきます。
例: すべてのテキストファイルを grep $ grep -r -I &amp;#39;検索文字列&amp;#39; . grep で NOT、AND、OR 検索する NOT 検索 grep の -v オプションを指定すると、指定した 文字列を含まない 行だけを抽出できます。</description></item><item><title>Linuxメモ: Bash の構文: case による分岐処理</title><link>https://maku77.github.io/p/hro2nd4/</link><pubDate>Tue, 08 May 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hro2nd4/</guid><description>Bash スクリプトで case を使用すると、ある値がどのパターンに一致するかによって分岐処理を行うことができます。 構文は以下の通りです。
case 式 in パターン1) 処理1 ;; パターン2) 処理2 ;; パターン3) 処理3 ;; *) いずれにも一致しない場合の処理 ;; esac 式 の評価結果が、パターン1 ～ パターン3 のいずれかに一致すると、対応する 処理1 〜 処理3 が実行されます。
パターンには正規表現を使うことができます。
case $1 in -[mM]) # -m あるいは -M だったら more $2;; esac シェルスクリプトや関数に渡された引数の値 ($1) によって処理を分岐させたいときに便利です。
case $1 in one | One) echo 1 ;; two | Two) echo 2 ;; three | Three) echo 3 ;; *) echo unknown ;; esac 次のように処理部分を複数行に分けて記述することもできます。</description></item><item><title>Linuxメモ: Bash の構文: if-else による分岐処理</title><link>https://maku77.github.io/p/seogpah/</link><pubDate>Tue, 08 May 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/seogpah/</guid><description>if-else の基本 Bash スクリプト内での if による条件分岐は下記のように記述します。
if 条件 then 処理 fi then を if と同じ行に記述しているスクリプトもよく見かけます。 Google もこのようなスタイルを採用しています。
if 条件; then 処理 fi 処理内容が簡潔な場合は、下記のようにセミコロンを使用して一行で記述してしまうこともできます。
if 条件; then 処理; fi 複数の条件分岐を連ねる場合 (else if) は、以下のように elif と else を使って記述します。
if 条件1; then 処理1 elif 条件2; then 処理2 elif 条件3; then 処理3 else 処理4 fi test コマンドによる比較処理 if の条件部では、test コマンドを使用して、数値比較や文字列比較を行うことができます。 実際には、test コマンドへのシンボリックリンクである [ を使って記述するのが一般的です。 例えば、以下では数値比較を行うために test コマンドを使っていますが、
if test 1 -gt 0; then echo &amp;#39;OK&amp;#39;; fi これは次のように書くことができます。</description></item><item><title>Linuxメモ: シェルスクリプト: ランダムな数値を取得する ($RANDOM)</title><link>https://maku77.github.io/p/5fhvypy/</link><pubDate>Wed, 27 Jul 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5fhvypy/</guid><description>Bash のシェル変数 $RANDOM を参照すると、0 ～ 32767 の範囲のランダムな整数を取得することができます。
$ echo $RANDOM 27591</description></item><item><title>Linuxメモ: Linux でリダイレクトによってファイルが上書きされてしまうのを防ぐ (`set -o noclobber`)</title><link>https://maku77.github.io/p/jw5xt77/</link><pubDate>Thu, 26 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jw5xt77/</guid><description>例えば Linux で下記のように標準出力をリダイレクトしようとしたときに、すでに出力先のファイルが存在する場合は、そのファイルの内容が上書きされてしまいます。
例: hoge.txt が上書きされてしまう $ echo Hello &amp;gt; hoge.txt こういったリダイレクトによるファイルの上書きを抑制するには、シェルオプションの noclobber を有効化します（bash と zsh で共通です）。 有効化後に hoge.txt が上書きされるような処理を実行すると、以下のようにエラーになります。
例: hoge.txt が上書きされてしまう $ set -o noclobber $ echo Hello &amp;gt; hoge.txt zsh: file exists: hoge.txt シェルオプションは、set -o で有効化、set +o で無効化できます。 bash では ~/.bashrc、zsh では ~/.zshrc に設定を追加しておくとよいでしょう。
~/.zshrc set -o noclobber # noclobberを有効化（既存ファイルの上書きを防止） set +o noclobber # noclobberを無効化（既存ファイルの上書きを許可）（デフォルト） ちなみに、現在のすべてのシェルオプションの設定を確認するには以下のようにします。
$ set -o # on, off 表示 $ set +o # 設定コマンド表示</description></item><item><title>Linuxメモ: リダイレクトとパイプ処理のまとめ</title><link>https://maku77.github.io/p/knkamyp/</link><pubDate>Tue, 24 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/knkamyp/</guid><description>リダイレクトとパイプの役割 デフォルトでは、標準出力 (stdout) の出力先はモニタで、標準入力の入力元はキーボードになっています。 リダイレクトやパイプは、これを変更する役割を持っています。
command &amp;gt; file &amp;hellip; command の標準出力の内容をファイルへ出力する command &amp;lt; file &amp;hellip; ファイルの内容を command の標準入力へ入力する command1 | command2 &amp;hellip; command1 の標準出力を command2 の標準入力へ繋ぐ 例: list.txt の内容を sort コマンドの標準入力へ渡す $ sort -r &amp;lt; list.txt # リダイレクトを使う場合 $ cat list.txt | sort -r # パイプを使う場合 標準出力のリダイレクト 標準出力と標準エラー出力をリダイレクトする $ command &amp;amp;&amp;gt; output.txt 以下のように実行する方法もあり、Linux (bash) も Windows も共通の指定方法で実行できます。
$ command &amp;gt; output.txt 2&amp;gt;&amp;amp;1 2&amp;gt;&amp;amp;1 は、STDERR (2) を STDOUT (1) に結合するという指示です。
標準出力と標準エラー出力を別々にリダイレクトする $ command 1&amp;gt; stdout.</description></item><item><title>Linuxメモ: ls コマンドが使えないときに echo コマンドで代用する</title><link>https://maku77.github.io/p/z3dxcch/</link><pubDate>Mon, 23 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z3dxcch/</guid><description>Linux 環境でパスが狂ってしまったりして、外部コマンドである ls が使えないときは、内部コマンドの echo とシェルのワイルドカード展開機能を使って、ディレクトリ内のファイル一覧を表示できます。
$ echo * $ echo dir/* $ echo test*</description></item><item><title>Linuxメモ: ls コマンドでパターンに一致するファイルだけを列挙する</title><link>https://maku77.github.io/p/vtkjxha/</link><pubDate>Sun, 22 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vtkjxha/</guid><description>ls コマンドでファイルを列挙するときに、Linux シェルのワイルドカードやグロブパターンを利用すると、特定のパターンにマッチするファイルだけを列挙できます。 ? は任意の 1 文字、* は 0 文字以上の任意の文字列にマッチします。
例: 3文字以上のファイルを列挙する $ ls ???* 例: 01, 02, 03 のいずれかの文字列を含むファイルを列挙する $ ls *{01,02,03}* # 方法1 $ ls *0[1-3]* # 方法2</description></item><item><title>Linuxメモ: 今日の日付から YYYYMMDD のような文字列を作成する (date)</title><link>https://maku77.github.io/p/7aj35xe/</link><pubDate>Thu, 21 Apr 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7aj35xe/</guid><description>Linux の date コマンドを使用すると、現在時刻を表す文字列を自由なフォーマットで取得することができます。
$ date +%Y%m%d-%H%M%S 20050521-231345 時刻入りの簡単なログを出力したいときや、バックアップを作成するときのファイル名構成のために使用することができます。
例: 現在日時をファイル名に付けてファイルコピー（バックアップ） $ cp sample.txt sample.txt.`date +%Y%m%d`.back $ ls sample.txt sample.txt.20050102.back</description></item><item><title>Linuxメモ: 行番号付きでテキストファイルの内容を出力する (cat -n, cat -b)</title><link>https://maku77.github.io/p/sybn8yf/</link><pubDate>Thu, 21 Apr 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sybn8yf/</guid><description>cat コマンドには行番号を付加して出力する -n オプションが用意されています。
行番号付きで出力 $ cat -b input.txt -n オプションの代わりに -b オプションを使用すると、空行を除いた行に対して行番号が付加されます。
空行以外の行にだけ行番号を付ける $ cat -b input.txt</description></item></channel></rss>