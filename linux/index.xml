<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux/Shell on 天才まくまくノート</title><link>https://maku77.github.io/linux/</link><description>Recent content in Linux/Shell on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 05 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linuxシェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts)</title><link>https://maku77.github.io/p/2fyizgw/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2fyizgw/</guid><description>Bash 組み込みの getopts コマンドを使用すると、シェルスクリプトに渡されたコマンドラインオプション (-a など）を解析することができます。 getopts は 1 文字のオプションしか扱えないことに注意してください。
引数なしのオプション 下記は getopts の基本的な使用例です。 getopts のオプション文字列として abc を指定することにより、このシェルスクリプトには、-a、-b、-c という 3 種類のオプションを受け取れるようになっています。 ユーザーが指定したオプションが、1 文字ずつ opt 変数に格納されるので、その値で case による分岐処理を行います。
sample.sh #!/bin/bash while getopts &amp;#39;abc&amp;#39; opt; do case &amp;#34;${opt}&amp;#34; in a) echo &amp;#34;オプション -a を指定しました&amp;#34; ;; b) echo &amp;#34;オプション -b を指定しました&amp;#34; ;; c) echo &amp;#34;オプション -c を指定しました&amp;#34; ;; esac done 実行例 $ ./sample.sh -a オプション -a を指定しました $ ./sample.sh -a -c オプション -a を指定しました オプション -c を指定しました $ .</description></item><item><title>Linuxメモ: echo の結果を標準エラー出力 (stderr) に出力する</title><link>https://maku77.github.io/p/q2k3j2h/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q2k3j2h/</guid><description>標準エラー出力への出力 echo コマンドの出力結果を、デフォルトの標準出力ではなく、標準エラー出力に出力するには、末尾で 1&amp;gt;&amp;amp;2 のようにリダイレクトします（&amp;gt;&amp;amp;2 という省略形でも OK）。
#!/bin/bash echo &amp;#34;Hello World&amp;#34; 1&amp;gt;&amp;amp;2 このように出力先を制御したプログラムは、実行結果をリダイレクトしたり、パイプ接続した場合の振る舞いに影響してきます。
sample.sh #!/bin/bash echo AAA echo BBB 1&amp;gt;&amp;amp;2 echo CCC 上記のプログラムの出力結果を out.txt というファイルにリダイレクトすると、ターミナル上には BBB という標準エラー出力のみが表示されます。
実行例 $ ./sample.sh &amp;gt; out.txt BBB out.txt の内容 AAA CCC cat の場合 cat コマンドによるヒアドキュメントでも、標準エラー出力に出力できます。
cat 1&amp;gt;&amp;amp;2 &amp;lt;&amp;lt;EOF AAA AAA AAA BBB BBB BBB CCC CCC CCC EOF シェルスクリプトの Usage 出力などに便利です。
usage() { cat 1&amp;gt;&amp;amp;2 &amp;lt;&amp;lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .</description></item><item><title>Linux シェルスクリプト: expect で外部コマンドの出力を待機する</title><link>https://maku77.github.io/p/3i3j2hx/</link><pubDate>Sat, 10 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3i3j2hx/</guid><description>Linux や macOS の expect コマンドを使用すると、任意のコマンドの出力を待ち受けて、自動でそれに応答するといったことを実現できます。
expect の基本的な使い方 expect がインストールされていない場合は、パッケージ管理ツール（apt や yum）を使用してインストールしてください（macOS には最初からインストールされています）。 まずは、簡単な例として、下記のような簡単なユーザ入力を必要とするスクリプトを自動で動作させてみます。
greet.sh #!/bin/bash echo -n &amp;#34;Enter your name: &amp;#34; read name echo &amp;#34;Hello, $name&amp;#34; これをそのまま実行すると、下記のようにユーザ入力の待ち受け状態となります。
$ ./greet.sh Enter your name: このような状態になったときに、自動的に入力を行うには、下記のように expect -c コマンドを使ったシェルスクリプトを作成します。
sample.sh #!/bin/bash expect -c &amp;#34; set timeout 3 spawn ./greet.sh expect \&amp;#34;Enter your name:\&amp;#34; send \&amp;#34;Maku\n\&amp;#34; interact &amp;#34; expect -c の後ろのダブルクォートで囲まれた部分には、expect で実行するスクリプトを記述します。 この中でダブルクォートを使用したいときは、\&amp;quot; のようにエスケープしなければいけないことに注意してください。 スクリプト中の各行は次のような意味を持っています。
set timeout 3 &amp;hellip; 外部プログラムの実行を 3 秒待つ spawn .</description></item><item><title>Linuxメモ: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ</title><link>https://maku77.github.io/p/25gqyai/</link><pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/25gqyai/</guid><description>Linux の echo コマンドで文字列変数 $str の値を出力しようとして、下記のように実行すると、文字列に含まれている連続するスペースが 1 つのスペースにまとめられてしまいます。
sample.sh（間違った方法） #!/bin/bash str=&amp;#34;AAA BBB CCC&amp;#34; echo $str 実行結果 AAA BBB CCC これは、変数展開が行われることによってダブルクォートが取り除かれ、下記のように echo コマンドに 3 つのパラメータが渡されたものとして扱われるからです。 パラメータの区切りとして使われるスペースの数は関係なく、各パラメータ (AAA、BBB、CCC) が 1 つのスペースで結合されて出力されます。
$ echo AAA BBB CCC AAA BBB CCC スペースを含む文字列を 1 つの文字列として echo コマンドに渡すには、次のようにダブルクォートで囲む必要があります。
sample.sh（正しい方法） #!/bin/bash str=&amp;#34;AAA BBB CCC&amp;#34; echo &amp;#34;$str&amp;#34; 実行結果 AAA BBB CCC</description></item><item><title>Linuxメモ: シェルスクリプトのコーディングスタイル</title><link>https://maku77.github.io/p/oukq4dh/</link><pubDate>Tue, 25 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oukq4dh/</guid><description>Bash のシェルスクリプトを記述するときに最低限揃えておきたいコーディングスタイルです。 Google のコーディングスタイルを参考にしています。
基本的に bash を使用することとし、1 行目の Shebang として #!/bin/bash と記述する インデント: 半角スペース 2 文字（タブ文字は使用しない） if と同じ行に then を記述する for や while と同じ行に do を記述する 1 行あたりの文字数は 80 文字まで 関数名や変数名はすべて小文字（例: my_func） 外部コマンドを実行するときはバッククォート (\) を使用せず、$(func arg1 arg2) という形式を使用する シェル変数は小文字 ($src_dir)、環境変数は大文字 ($FOO_BAR)</description></item><item><title>Linuxシェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)</title><link>https://maku77.github.io/p/s9r9q7n/</link><pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s9r9q7n/</guid><description>パイプで while read につなぐ方法 外部コマンドの出力結果を 1 行ずつ変数に取得しながらループ処理するには、コマンドの出力をパイプ (|) で while read につなぎます。 次の例では、外部コマンド find . -name '*.sh'（カレントディレクトリ以下の .sh ファイルを再帰的に列挙）の出力結果を 1 行ずつ line 変数に取得してループ処理しています。
find . -name &amp;#39;*.sh&amp;#39; | while read line; do echo &amp;#34;$line&amp;#34; done line という変数名は別の名前に変えても大丈夫です。 この例では 1 ファイルずつループ処理しているので、file という変数名の方が直感的かもしれません。
☝️ ワンポイント echo 出力時に &amp;quot;$line&amp;quot; のようにダブルクォートで囲んでいるのは、echo が連続したスペースを 1 つのスペースにまとめて出力してしまうのを防ぐためです。 パス内にスペースが含まれていなければ問題は発生しませんが、必ずダブルクォートで囲むようにしましょう。 外部コマンドの出力を配列として受け取る方法 パイプ (|) を使用せず、$(command) の形で実行した外部コマンドの出力を、配列で受け取る方法もあります。
list=$(find . -name &amp;#39;*.sh&amp;#39;) for line in &amp;#34;$list&amp;#34;; do echo &amp;#34;$line&amp;#34; done 外部コマンドの出力を 1 行ずつ正しくループ処理するために、$list をダブルクォートで囲むことを忘れないでください。 for ループの in の後ろには、スペース区切りで各要素が列挙されているものとして認識されます。 行内にスペースが含まれている場合に、行全体を 1 つの要素として処理するためには、$list 変数を展開するときにダブルクォートで囲んでおく必要があります。</description></item><item><title>Linuxメモ: Bash の構文: 関数のデフォルト引数を定義する</title><link>https://maku77.github.io/p/7ovg5nr/</link><pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7ovg5nr/</guid><description>以下の関数では、パラメータを何も指定しないで呼び出すと、par1 ローカル変数に ABC が入ります。 パラメータを指定すると、そちらが使用されます。
param-test.sh function param-test() { local par1=${1:-ABC}; echo &amp;#34;param = $par1&amp;#34; } 実行例 $ . param-test.sh $ param-test param = ABC $ param-test 10000 param = 10000</description></item><item><title>Linuxメモ: Windows で Linux 系のコマンドを使用できるようにする (Gow)</title><link>https://maku77.github.io/p/qijsiy5/</link><pubDate>Mon, 19 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qijsiy5/</guid><description>Gow のインストール Gow (Gnu On Windows)
Gow をインストールすると、Windows で Linux の主なコマンド群をサクッと使うことができるようになります。 インストーラを実行するだけで数秒でインストールできるので、簡単なコマンドを使うために Cygwin のような大げさな環境をインストールしなくても済みます。
Gow で使えるようになる Linux 系コマンドの一覧 Gow - executables_list
Gow がインストールされている環境であれば、以下のように確認することもできます。
Gow 0.7 で確認 C:\&amp;gt; gow -l Available executables: awk, basename, bash, bc, bison, bunzip2, bzip2, bzip2recover, cat, chgrp, chmod, chown, chroot, cksum, clear, cp, csplit, curl, cut, dc, dd, df, diff, diff3, dirname, dos2unix, du, egrep, env, expand, expr, factor, fgrep, flex, fmt, fold, gawk, gfind, gow, grep, gsar, gzip, head, hostid, hostname, id, indent, install, join, jwhois, less, lesskey, ln, ls, m4, make, md5sum, mkdir, mkfifo, mknod, mv, ncftp, nl, od, pageant, paste, patch, pathchk, plink, pr, printenv, printf, pscp, psftp, putty, puttygen, pwd, rm, rmdir, scp, sdiff, sed, seq, sftp, sha1sum, shar, sleep, sort, split, ssh, su, sum, sync, tac, tail, tar, tee, test, touch, tr, uname, unexpand, uniq, unix2dos, unlink, unrar, unshar, uudecode, uuencode, vim, wc, wget, whereis, which, whoami, xargs, yes, zip</description></item><item><title>Linuxシェルスクリプト: テキストファイルを 1 行ずつ読み込む (read)</title><link>https://maku77.github.io/p/co9p7nj/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/co9p7nj/</guid><description>テキストファイルを 1 行だけ読み込む read コマンドはユーザからの入力を 1 行取得するために使用できますが、ファイルからの入力を 1 行読み込むのにも使用できます。
sample.sh （input.txt の内容を 1 行だけ読み込む） #!/bin/bash read line &amp;lt; input.txt echo &amp;#34;$line&amp;#34; input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 これだけだとあまり役に立たないので、通常は次のように while ループを組み合わせて、すべての行を読み出します。
テキストファイルから 1 行ずつ読み込む read コマンドと while ループを組み合わせると、テキストファイルのすべての行を 1 行ずつ処理できます。
sample.sh （input.txt の内容を 1 行ずつ読み込む） #!/bin/bash while read line; do echo &amp;#34;$line&amp;#34; done &amp;lt; input.txt input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 BBB 200 CCC 300 ☝️ ワンポイント echo のパラメータ &amp;quot;$line&amp;quot; をダブルクォートで囲んでいることに注意してください。 こうすることで、1 行分の文字列を、ひとつのパラメータとして渡すことができます。 ダブルクォートで囲まないと、echo AAA 100 のように、2 つのパラメータが渡されたかのように処理されてしまうため、連続するスペースが 1 つのスペースに置き換えられて出力されてしまいます。 参考: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ 行頭のスペースが消えてしまうのを防ぐ 例えば、下記のように行頭がインデントされたテキストファイルを読み込むとします。</description></item><item><title>Linuxメモ: ユーザー入力を取得する (read)</title><link>https://maku77.github.io/p/6m6n5k3/</link><pubDate>Mon, 05 Nov 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6m6n5k3/</guid><description>ユーザー入力の基本 bash スクリプトの中で、read 変数名 とすると、ユーザーがキーボードで入力したテキストを変数に取得することができます。 変数名 の部分には、$ プレフィックスを付けないことに注意してください（変数の内容を参照するときは $ が必要です）。
hello.sh #!/bin/sh echo -n &amp;#34;Enter your name: &amp;#34; read name echo &amp;#34;Hello, $name&amp;#34; 実行結果 $ ./hello.sh Enter your name: まくまく Hello, まくまく ☝️ echo の -n オプション echo コマンドの出力はデフォルトで末尾で改行されますが、-n オプションを使うとこの改行を抑制できます。 上記の例のように、プロンプト表示で利用できます。 ユーザーが y を入力したときだけ処理を継続する read コマンドの典型的な使用例として、ユーザーに y/n の選択肢を入力させるものがあります。 次の remove_all 関数は、何もかもを削除する前に、ユーザーに最終確認を行っています。
remove.sh #!/bin/bash function remove_all { echo -n &amp;#39;Are you sure? (y/n): &amp;#39; read input if [ &amp;#34;$input&amp;#34; = &amp;#39;Y&amp;#39; -o &amp;#34;$input&amp;#34; = &amp;#39;y&amp;#39; ]; then echo &amp;#39;All things have been removed!</description></item><item><title>Linuxメモ: Bash の構文: 関数から戻り値を返す ($?)</title><link>https://maku77.github.io/p/8uionzb/</link><pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8uionzb/</guid><description>シェル関数が return で返すことのできる値は 数値 (0～255) だけ です。 return で返された戻り値を参照するには $? を使います。
function myfunc { return 1 } myfunc echo $? 関数の実行結果を文字列として受け取りたい場合は、関数内部で echo した結果を以下のようにバッククォート呼び出しして取得します。
function myfunc { echo &amp;#39;Hello&amp;#39; } val=`myfunc` echo $val</description></item><item><title>Linuxメモ: Bash の構文: 関数内でローカル変数を扱う (local)</title><link>https://maku77.github.io/p/52i36fy/</link><pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/52i36fy/</guid><description>Bash は関数外と関数内で変数を共有します。 例えば、以下のように関数内で代入を行うと、関数外でセットした値を上書きしてしまいます。
function myfunc { a=200 } 実行例 $ a=100 $ myfunc $ echo $a 200 ★aの値が変わってる！ 関数内だけで有効なローカル変数を扱うには以下のように local キーワードを付けます。
function myfunc { local a=200 } 実行例 $ a=100 $ myfunc $ echo $a 100 ★aの値はそのまま</description></item><item><title>Linuxメモ: rsync コマンドでディレクトリを同期する</title><link>https://maku77.github.io/p/dvd889d/</link><pubDate>Thu, 05 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dvd889d/</guid><description>rsync コマンドを使用すると、簡単に 2 つのディレクトリを同期することができます。 下記の例では、src ディレクトリの中身を dst ディレクトリに同期しています。
$ rsync -av src/ dst src の後ろにスラッシュを付ける のを忘れないようにしてください。 このスラッシュを忘れると、dst ディレクトリの中に src ディレクトリができちゃいます。 オプションの -a は archive mode として動作させることを示しており、よく使うオプションをまとめて指定したのと同様の効果があります (例えば、ディレクトリを再帰的にコピー、属性をそのまま保つなど)。
rsync コマンドは更新されているファイルだけをコピーしてくれるので、大量のファイルが格納されていても、同期処理は短時間で完了します。 rsync は、ローカル PC 内のディレクトリの同期だけではなく、リモートホスト上のディレクトリとの同期にも対応しています。 詳しい rsync コマンドの使い方は下記を参照してください。
参考: Linuxコマンド: rsync コマンドで2つのディレクトリを同期する</description></item><item><title>Linuxメモ: echo で出力する文字の色を変える</title><link>https://maku77.github.io/p/fufwdub/</link><pubDate>Wed, 11 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fufwdub/</guid><description>Linux の echo コマンドで特殊なエスケープシーケンスを出力すると、テキストの文字を変更することができます。 次の Bash スクリプトでは、色を変更しつつ echo 出力する、error / warn / info 関数を定義しています。
sample.sh #!/bin/bash error() { echo -e &amp;#34;\033[31m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } warn() { echo -e &amp;#34;\033[33m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } info() { echo -e &amp;#34;\033[32m$*\033[00m&amp;#34; &amp;gt;&amp;amp;2 } error &amp;#39;Error message&amp;#39; warn &amp;#39;Warning message&amp;#39; info &amp;#39;Information message&amp;#39; このシェルスクリプトを実行すると、次のように色付きのメッセージが表示されます。
図: echo コマンドの出力色を変更 ちなみに、echo コマンドの末尾の &amp;gt;&amp;amp;2 は、標準エラー出力へ出力することを示しています。
参考: echo の結果を標準エラー出力 (stderr) に出力する (1&amp;gt;&amp;amp;2)</description></item><item><title>Linuxメモ: Bash の構文: 関数へパラメータを渡す</title><link>https://maku77.github.io/p/ecj6wbo/</link><pubDate>Fri, 15 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ecj6wbo/</guid><description>関数に渡されたパラメータの処理方法は、シェルスクリプト実行時に渡されたコマンドラインパラメータの処理方法と同じです。 以下のコマンドラインパラメータの処理方法に関する記事も参考にしてください。
コマンドライン引数を取得する 関数へ渡されたパラメータの数を調べる ($#) 関数内で $# を参照すると、渡されたパラメータの数を調べることができます。
サンプルコード function foo { echo $# } 実行結果 $ foo 100 200 2 $ foo aaa bbb ccc 3 $ foo &amp;#34;This is a pen&amp;#34; 1 ☝️ ワンポイント 関数の外で $# を参照すると、シェルスクリプト実行時に渡されたコマンドラインパラメータの数を取得できます。 応用例: 関数へ渡されたパラメータが少なくとも 1 つ以上あるか調べる function foo { if [ $# -lt 1 ]; then echo &amp;#39;Function &amp;#34;foo&amp;#34; needs at least one parameter&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi echo &amp;#39;OK&amp;#39; } 関数へ渡されたパラメータを順番に処理する サンプルコード function enum_params { while [ -n &amp;#34;$1&amp;#34; ]; do echo $1 shift done } [ -n &amp;quot;$1&amp;quot; ] の部分では、パラメーターが空文字ではないかどうかを調べています。 shift コマンドは、パラメータを左にシフトします。 つまり、$2 の値が $1 に、$3 の値が $2 に、というようにシフトされます。 これにより、すべてのパラメーターを $1 で順番に参照することができます。</description></item><item><title>Linuxシェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while)</title><link>https://maku77.github.io/p/or3cmv6/</link><pubDate>Sun, 06 Feb 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/or3cmv6/</guid><description>ワイルドカードを使用する方法 ワイルドカード (*) を使って、カレントディレクトリ内のファイルをループ処理することができます。
例: すべてのファイル（ドットファイルを除く）をループ処理 for x in *; do echo &amp;#34;$x&amp;#34; done 特定の拡張子を持つファイルのみを列挙するには次のようにします。
例: すべての PNG ファイルをループ処理 for x in *.png; do echo $x done 次のように一行で書くこともできます。
for x in *.png; do echo &amp;#34;$x&amp;#34;; done find コマンドの結果を使用する方法（再帰的にファイル探索） 下記の例では、find コマンドによって見つかったファイルを while ループで順番に処理しています。 深い階層にあるファイルも再帰的に処理されます。
find . -type f | while read x; do echo &amp;#34;$x&amp;#34; done 参考: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)</description></item><item><title>Bash の変数展開機能を活用する（文字列の置換、デフォルト値など）</title><link>https://maku77.github.io/p/jsctar8/</link><pubDate>Tue, 20 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jsctar8/</guid><description>Bash の変数は通常 ${x} のような形で参照しますが、様々な変数展開機能を利用すると、変数の存在を確認したり、一部を置換したり、デフォルト値を設定したりすることができます。 下記にざっと紹介しますが、公式なドキュメントは man bash の Parameter Expansion のセクションで参照することができます。
パターン照合演算子 次のような変数展開の構文を使用すると、変数に格納された文字列の一部を置換した文字列を作成することができます。
構文 意味 ${変数/パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（１つだけ） ${変数//パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（すべて） ${変数#パターン} 先頭から最短一致でパターンに一致する部分を取り除く ${変数##パターン} 先頭から最長一致でパターンに一致する部分を取り除く ${変数%パターン} 末尾から最短一致でパターンに一致する部分を取り除く ${変数%%パターン} 末尾から最長一致でパターンに一致する部分を取り除く パターン部分では、ワイルドカード（*、?、[a-z] など）を使用できます。
例: 変数内の b を B に置換する $ x=aaabbbccc $ y=${x/b/B} $ echo $y aaaBbbccc 最初に見つかった文字列だけが置換されていることがわかります。 パターンに一致する文字列をすべて置換するには次のようにします（最初のスラッシュを2つにします）。
$ x=aaabbbccc $ y=${x//b/B} $ echo $y aaaBBBccc 以下のように sed コマンドを使ったのと同様の効果を bash の機能だけで実現できていることになります。
$ y=$(echo $x | sed -e &amp;#39;s/bbb/BBB/g&amp;#39;) 例: フルパスから basename を取り出す 下記の例では /aaa/bbb/ccc という絶対パスから、ベースネーム部分の ccc を抽出しています。 */ というパターンで先頭から最長一致させ、/aaa/bbb/ という部分を取り除いています。</description></item><item><title>Linuxシェルスクリプト: ある外部コマンドが使用できるかチェックする</title><link>https://maku77.github.io/p/xi5sjju/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xi5sjju/</guid><description>シェルスクリプトの中で特定の外部コマンドを使用する必要がある場合、先頭部分でその外部コマンドが使用できる状態かどうかを調べておくと親切です。 例えば、次のようにすれば、ruby コマンドが使用できるかを確認できます。
sample.sh if type -P ruby &amp;gt; /dev/null; then echo &amp;#39;ruby コマンドを使用できます&amp;#39; else echo &amp;#39;ruby コマンドが見つかりません&amp;#39; fi ☝️ type -P コマンド type -P ruby コマンドは、パスの通ったディレクトリから ruby を検索してそのパスを取得するためのものですが、ここでは ruby コマンドが使用できる環境になっているかを確認するために利用しています。 単純に実行すると、検索結果のパスが出力されてしまうので、null デバイスへリダイレクトして出力を抑制しています。 特定のコマンドが使用できない場合にスクリプトを終了させるには、以下のように記述すればよいでしょう。 条件式を ! で反転させていることに注意してください。
if ! type -P ruby &amp;gt; /dev/null; then echo &amp;#39;This script requires Ruby. Please install Ruby first and try again.&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続</description></item><item><title>Linuxシェルスクリプト: ある環境変数が定義されているかチェックする (test -z)</title><link>https://maku77.github.io/p/r3myewb/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r3myewb/</guid><description>環境変数がセットされているかを確認する 下記の例では、SRC_ROOT という環境変数が設定されているかを調べ、設定されていない場合はメッセージを終了しています。
sample.sh #!/bin/bash if [ -z &amp;#34;$SRC_ROOT&amp;#34; ]; then echo &amp;#39;Please set the &amp;#34;SRC_ROOT&amp;#34; environment variable and try again.&amp;#39; &amp;gt;&amp;amp;2 exit -1 fi echo &amp;#39;Program continues...&amp;#39; -z は、指定された変数の文字列長が 0 であるかを調べるオプションです。 SRC_ROOT 変数にスペースを含む文字列が設定されている場合に備えて、&amp;quot;$SRC_ROOT&amp;quot; のようにダブルクォートで囲むことをお勧めします。
☝️ ワンポイント echo の出力を &amp;gt;&amp;amp;2 とリダイレクトすると標準エラー出力へ出力できます。 実行例 $ ./sample.sh Please set the &amp;#34;SRC_ROOT&amp;#34; environment variable and try again. $ SRC_ROOT=/Users/maku/src ./sample.sh Program continues... （おまけ）test コマンドについて if [ -z &amp;#34;$SRC_ROOT&amp;#34; ]; then という条件判定は、次のように test コマンドを使うのと同等です。
if test -z &amp;#34;$SRC_ROOT&amp;#34;; then test -z コマンドは、指定された変数値の文字列長が 0 かどうかを確認するコマンドです。 これを利用して、上記のように 特定の変数値がセットされていない ことを調べることができます。</description></item><item><title>Linuxシェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#)</title><link>https://maku77.github.io/p/4tbzpyf/</link><pubDate>Sun, 13 Jun 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4tbzpyf/</guid><description>関連記事: Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*)
コマンドライン引数が足りないときに Usage 出力して終了する シェルスクリプト起動時に渡されたコマンドライン引数の数は、$# 変数で取得することができます。 シェルスクリプトが最低 2 つのパラメーターを必要としている場合は、先頭部分で下記のようなチェックをするのがよいでしょう。
例: 2 つ以上のパラメーターが必要 #!/bin/bash if [ $# -lt 2 ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続 下記はバリエーションです。
例: 1 つ以上のパラメーターが必要 #!/bin/bash if [ ! &amp;#34;$1&amp;#34; ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi # 処理を継続 例: 1 つは引数が必要で、かつ、その名前のファイルが存在する #!/bin/bash if [ ! &amp;#34;$1&amp;#34; ]; then echo &amp;#34;Usage: $(basename $0) &amp;lt;file&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit -1 fi if [ !</description></item><item><title>Linuxメモ: Bash の構文: 関数を定義する／削除する</title><link>https://maku77.github.io/p/em67j5z/</link><pubDate>Tue, 15 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/em67j5z/</guid><description>関数定義の基本 Bash では以下のいずれかの構文を利用して、関数を定義することができます。
function funcname { &amp;lt;shell commands...&amp;gt; } funcname() { &amp;lt;shell commands...&amp;gt; } 開き括弧 ({) は、上記のように関数名と同じ行に記述してもよいし、次の行に単独で記述してもよいです。
関数を削除する 定義されている関数を削除するには以下のようにします。
unset -f funcname 現在のログインセッションでどんな関数が定義されているかを調べるには以下のようにします。
$ declare -F # 関数名のみ出力 $ declare -f # 関数の定義も出力 関数と環境変数 関数はスクリプトとは異なり、実行したシェルと同じプロセスで実行されます。 つまり、以下のように関数内で環境変数を設定すれば、関数を呼び出したシェルにも反映されます。
myfunc() { export AAA=100 } 空の関数は syntax error になる 中身が空の関数が定義されていると、構文エラーが発生するようです。
myfunc() { # syntax error } エラーの例 $ ./sample.sh ./sample.sh: 行 3: 予期しないトークン `}&amp;#39; 周辺に構文エラーがあります ./sample.sh: 行 3: `}&amp;#39;</description></item><item><title>Linuxメモ: Bash の構文: ループ内での複数の出力をまとめてリダイレクト、パイプ処理する</title><link>https://maku77.github.io/p/tmm4zvz/</link><pubDate>Wed, 02 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tmm4zvz/</guid><description>コマンドのグルーピング Bash 上で任意のコマンドを実行するときに、
$ (command1; command2; command3) のようにコマンドを括弧 () で囲んでグルーピングすると、リダイレクトなどの効果が全てのコマンドに対して働くようになります。
$ (echo &amp;#39;AAA&amp;#39;; echo &amp;#39;BBB&amp;#39;; echo &amp;#39;CCC&amp;#39;) &amp;gt; output.txt 上記は一行で記述していますが、次のように複数行に分けて記述することもできます。 この場合、各コマンドの末尾にセミコロン (;) は必要ありません。
( echo &amp;#39;AAA&amp;#39; echo &amp;#39;BBB&amp;#39; echo &amp;#39;CCC&amp;#39; ) &amp;gt; output.txt グルーピングしたコマンドの出力をパイプ処理でつなげていくこともできます。
( echo &amp;#39;foo&amp;#39; echo &amp;#39;bar&amp;#39; echo &amp;#39;yahoo&amp;#39; echo &amp;#39;foo&amp;#39; ) | sort | uniq 括弧で囲まれたコマンドは子シェルで実行されるので、その中でカレントディレクトリや環境変数などを変更した場合は、コマンド終了時に元に戻ります。 一時的にカレントディレクトリを変更してコマンドを実行したい場合に便利です。
$ pwd /home $ (cd /etc; pwd) /etc $ pwd /home ループ内の出力をリダイレクトする for ループや while ループの中で echo 出力した結果は、done の後ろでリダイレクトするようにすれば、まとめてファイルに出力することができます。
for x in AAA BBB CCC; do echo &amp;#34;$x&amp;#34; echo &amp;#34;.</description></item><item><title>Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*)</title><link>https://maku77.github.io/p/c2kx7er/</link><pubDate>Wed, 29 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c2kx7er/</guid><description>コマンドライン引数の基本 ($1 ~ $9) bash シェルスクリプト実行時にコマンドラインで渡した引数を参照するには、次のようなパラメーター参照用の特殊変数を使用します。
$1 &amp;hellip; 第 1 パラメーター $2 &amp;hellip; 第 2 パラメーター $3 &amp;hellip; 第 3 パラメーター パラメーターの参照には、$1 〜 $9 が使用できます。 使用することは余りないと思いますが、10 番目以降のパラメータを参照したいときは、${10} のように数値を {} で囲めば参照できます。
sample.sh #!/bin/bash echo &amp;#39;1 番目: &amp;#39; &amp;#34;$1&amp;#34; echo &amp;#39;2 番目: &amp;#39; &amp;#34;$2&amp;#34; echo &amp;#39;3 番目: &amp;#39; &amp;#34;$3&amp;#34; 実行結果 $ ./sample.sh AAA BBB &amp;#34;CCC DDD&amp;#34; 1 番目: AAA 2 番目: BBB 3 番目: CCC DDD コマンドライン引数を指定しなかった場合は、対応する変数は空になります。
$ ./sample.sh AAA 1 番目: AAA 2 番目: 3 番目: ☝️ 変数はダブルクォートで囲む echo の引数として変数の値を渡すときは、&amp;quot;$1&amp;quot; のようにダブルクォートで囲む癖をつけましょう。 $1 のようにそのまま記述してしまうと、変数の値として連続するスペースが含まれていたときに 1 つのスペースにまとめられてしまいます。 ☝️ 引数とパラメーターの違い 正確には、引数 (arguments) という用語は、スクリプトや関数を呼び出す側が渡す値のことを示し、パラメーター (parameters) という用語は、呼び出される側のスクリプトや関数が、その値を参照するときに使う変数のことを示します。 ただ、どちらのケースでもパラメーターという用語を使っているドキュメントもよく見かけるので、あまり気にしない方がよさそうです。 コマンドライン引数にデフォルト値を指定する (${1:-XXX}) コマンドライン引数が指定されなかったときに使用する値として、デフォルト値を指定しておくこともできます。 デフォルト値は、パラメーター参照時に ${1:-デフォルト値} という形で指定します。 下記の例では、1 番目、2 番目、3 番目のコマンドラインパラメーターのデフォルト値を、それぞれ AAA、BBB、CCC に設定しています。</description></item><item><title>Linuxメモ: Bash の構文: for/while によるループ処理</title><link>https://maku77.github.io/p/eimpfje/</link><pubDate>Tue, 28 Oct 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/eimpfje/</guid><description>スペースで区切られた単語（ワード）を順番に処理する 次の Bash スクリプトでは、ループ処理したいテキスト (aaa, bbb, ccc) を直接 for ループで指定しています。 ここでは、do を for と同じ行に記述するコーディングスタイルを採用しています。
例: aaa bbb ccc を順番に処理 for x in aaa bbb ccc; do echo $x done 実行結果 aaa bbb ccc 以下のように、スペースで区切られた文字列が格納された文字列変数を処理することもできます。
list=&amp;#34;aaa bbb ccc&amp;#34; for x in $list; do echo $x done スペースを含む文字列を1つの要素として扱う リスト内の各要素をダブルクォートで囲んでおくと、その単位でループ処理されるようになります。
#!/bin/bash for i in &amp;#34;aaa bbb&amp;#34; &amp;#34;ccc ddd&amp;#34; &amp;#34;eee fff&amp;#34;; do echo $i done 実行結果 aaa bbb ccc ddd eee fff 変数を使う場合もほぼ同様ですが、それぞれの変数をダブルクォートで囲む 必要があります（これを忘れると、それぞれの変数内の文字列がスペースで区切られてループ処理されてしまいます）。</description></item><item><title>Linuxメモ: あるファイルがテキストファイルかどうか調べる (file)</title><link>https://maku77.github.io/p/ams75pd/</link><pubDate>Mon, 08 Sep 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ams75pd/</guid><description>テキストファイルを file コマンドにかけると、... text ... のような結果が出力されます。 それを grep することで、そのファイルがテキストファイルかどうか調べることができます。
$ file sample.txt | grep text</description></item><item><title>Linuxメモ: ファイルやディレクトリを検索する (find, grep)</title><link>https://maku77.github.io/p/hudubr8/</link><pubDate>Mon, 08 Sep 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hudubr8/</guid><description>find と grep の基本 指定した拡張子のファイルを検索する (find) 次のようにすると、カレントディレクトリ (.) を起点にして、拡張子 .txt を持つファイルを検索して一覧表示することができます。
$ find . -name &amp;#39;*.txt&amp;#39; ファイル内の文字列を検索する (grep) 次のようにすると、指定したテキストファイル内の文字列を検索することができます。
$ grep &amp;#39;検索文字列&amp;#39; hello.txt find で見つけたファイルの中身を grep 検索する find で検索した結果のファイルそれぞれに対して、grep コマンドを実行するには、xargs を組み合わせて使用します。
例: 拡張子に txt を持つファイルを grep $ find . -type f -name &amp;#39;*.txt&amp;#39; | xargs grep &amp;#39;検索文字列&amp;#39; 拡張子などを絞り込まず、単純にそのディレクトリ以下のすべてのテキストファイルを検索するだけでよいのであれば、find を使わず、grep の再帰オプション (-r) を使った方が簡単です。 念のため、テキストファイルのみを grep 対象にするために -I オプション (--binary-files-without-match) も一緒に指定しておきます。
例: すべてのテキストファイルを grep $ grep -r -I &amp;#39;検索文字列&amp;#39; . grep で NOT、AND、OR 検索する NOT 検索 grep の -v オプションを指定すると、指定した 文字列を含まない 行だけを抽出できます。</description></item><item><title>Linuxメモ: Bash の構文: case による分岐処理</title><link>https://maku77.github.io/p/hro2nd4/</link><pubDate>Tue, 08 May 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hro2nd4/</guid><description>Bash スクリプトで case を使用すると、ある値がどのパターンに一致するかによって分岐処理を行うことができます。 構文は以下の通りです。
case 式 in パターン1) 処理1 ;; パターン2) 処理2 ;; パターン3) 処理3 ;; *) いずれにも一致しない場合の処理 ;; esac 式 の評価結果が、パターン1 ～ パターン3 のいずれかに一致すると、対応する 処理1 〜 処理3 が実行されます。
パターンには正規表現を使うことができます。
case $1 in -[mM]) # -m あるいは -M だったら more $2;; esac シェルスクリプトや関数に渡された引数の値 ($1) によって処理を分岐させたいときに便利です。
case $1 in one | One) echo 1 ;; two | Two) echo 2 ;; three | Three) echo 3 ;; *) echo unknown ;; esac 次のように処理部分を複数行に分けて記述することもできます。</description></item><item><title>Linuxメモ: Bash の構文: if-else による分岐処理</title><link>https://maku77.github.io/p/seogpah/</link><pubDate>Tue, 08 May 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/seogpah/</guid><description>if-else の基本 Bash スクリプト内での if による条件分岐は下記のように記述します。
if 条件 then 処理 fi then を if と同じ行に記述しているスクリプトもよく見かけます。 Google もこのようなスタイルを採用しています。
if 条件; then 処理 fi 処理内容が簡潔な場合は、下記のようにセミコロンを使用して一行で記述してしまうこともできます。
if 条件; then 処理; fi 複数の条件分岐を連ねる場合 (else if) は、以下のように elif と else を使って記述します。
if 条件1; then 処理1 elif 条件2; then 処理2 elif 条件3; then 処理3 else 処理4 fi test コマンドによる比較処理 if の条件部では、test コマンドを使用して、数値比較や文字列比較を行うことができます。 実際には、test コマンドへのシンボリックリンクである [ を使って記述するのが一般的です。 例えば、以下では数値比較を行うために test コマンドを使っていますが、
if test 1 -gt 0; then echo &amp;#39;OK&amp;#39;; fi これは次のように書くことができます。</description></item><item><title>Linuxメモ: Linux でリダイレクトによってファイルが上書きされてしまうのを防ぐ (`set -o noclobber`)</title><link>https://maku77.github.io/p/jw5xt77/</link><pubDate>Thu, 26 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jw5xt77/</guid><description>例えば Linux で下記のように標準出力をリダイレクトしようとしたときに、すでに出力先のファイルが存在する場合は、そのファイルの内容が上書きされてしまいます。
例: hoge.txt が上書きされてしまう $ echo Hello &amp;gt; hoge.txt こういったリダイレクトによるファイルの上書きを抑制するには、シェルオプションの noclobber を有効化します（bash と zsh で共通です）。 有効化後に hoge.txt が上書きされるような処理を実行すると、以下のようにエラーになります。
例: hoge.txt が上書きされてしまう $ set -o noclobber $ echo Hello &amp;gt; hoge.txt zsh: file exists: hoge.txt シェルオプションは、set -o で有効化、set +o で無効化できます。 bash では ~/.bashrc、zsh では ~/.zshrc に設定を追加しておくとよいでしょう。
~/.zshrc set -o noclobber # noclobberを有効化（既存ファイルの上書きを防止） set +o noclobber # noclobberを無効化（既存ファイルの上書きを許可）（デフォルト） ちなみに、現在のすべてのシェルオプションの設定を確認するには以下のようにします。
$ set -o # on, off 表示 $ set +o # 設定コマンド表示</description></item><item><title>Linuxメモ: リダイレクトとパイプ処理のまとめ</title><link>https://maku77.github.io/p/knkamyp/</link><pubDate>Tue, 24 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/knkamyp/</guid><description>リダイレクトとパイプの役割 デフォルトでは、標準出力 (stdout) の出力先はモニタで、標準入力の入力元はキーボードになっています。 リダイレクトやパイプは、これを変更する役割を持っています。
command &amp;gt; file &amp;hellip; command の標準出力の内容をファイルへ出力する command &amp;lt; file &amp;hellip; ファイルの内容を command の標準入力へ入力する command1 | command2 &amp;hellip; command1 の標準出力を command2 の標準入力へ繋ぐ 例: list.txt の内容を sort コマンドの標準入力へ渡す $ sort -r &amp;lt; list.txt # リダイレクトを使う場合 $ cat list.txt | sort -r # パイプを使う場合 標準出力のリダイレクト 標準出力と標準エラー出力をリダイレクトする $ command &amp;amp;&amp;gt; output.txt 以下のように実行する方法もあり、Linux (bash) も Windows も共通の指定方法で実行できます。
$ command &amp;gt; output.txt 2&amp;gt;&amp;amp;1 2&amp;gt;&amp;amp;1 は、STDERR (2) を STDOUT (1) に結合するという指示です。
標準出力と標準エラー出力を別々にリダイレクトする $ command 1&amp;gt; stdout.</description></item><item><title>Linuxメモ: ls コマンドが使えないときに echo コマンドで代用する</title><link>https://maku77.github.io/p/z3dxcch/</link><pubDate>Mon, 23 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z3dxcch/</guid><description>Linux 環境でパスが狂ってしまったりして、外部コマンドである ls が使えないときは、内部コマンドの echo とシェルのワイルドカード展開機能を使って、ディレクトリ内のファイル一覧を表示できます。
$ echo * $ echo dir/* $ echo test*</description></item><item><title>Linuxメモ: ls コマンドでパターンに一致するファイルだけを列挙する</title><link>https://maku77.github.io/p/vtkjxha/</link><pubDate>Sun, 22 May 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vtkjxha/</guid><description>ls コマンドでファイルを列挙するときに、Linux シェルのワイルドカードやグロブパターンを利用すると、特定のパターンにマッチするファイルだけを列挙できます。 ? は任意の 1 文字、* は 0 文字以上の任意の文字列にマッチします。
例: 3文字以上のファイルを列挙する $ ls ???* 例: 01, 02, 03 のいずれかの文字列を含むファイルを列挙する $ ls *{01,02,03}* # 方法1 $ ls *0[1-3]* # 方法2</description></item><item><title>Linuxメモ: 行番号付きでテキストファイルの内容を出力する (cat -n, cat -b)</title><link>https://maku77.github.io/p/sybn8yf/</link><pubDate>Thu, 21 Apr 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sybn8yf/</guid><description>cat コマンドには行番号を付加して出力する -n オプションが用意されています。
行番号付きで出力 $ cat -b input.txt -n オプションの代わりに -b オプションを使用すると、空行を除いた行に対して行番号が付加されます。
空行以外の行にだけ行番号を付ける $ cat -b input.txt</description></item></channel></rss>