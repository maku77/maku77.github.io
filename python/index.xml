<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 天才まくまくノート</title><link>https://maku77.github.io/python/</link><description>Recent content in Python on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 25 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する</title><link>https://maku77.github.io/p/bp9q8p6/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bp9q8p6/</guid><description>サイトマップとは？ Web サイトのサイトマップファイル (sitemap.xml) には、次のような形で全ページの URL 情報が記載されています。 このファイルは、主に Google などの検索エンジンのために提供されています。
sitemap.xml &amp;lt;urlset xmlns=&amp;#34;http://www.sitemaps.org/schemas/sitemap/0.9&amp;#34; xmlns:xhtml=&amp;#34;http://www.w3.org/1999/xhtml&amp;#34;&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page1/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2021-01-01&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page2/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-02-02&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page3/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2023-03-03&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;/urlset&amp;gt; sitemap.xml から URL の一覧を取得する 次の Python スクリプトは、上記のような sitemap.xml ファイルから、すべての URL 情報を抽出します。 sitemap.xml ファイル自体のダウンロードには urlopen を使用し、XML のパースには ElementTree を使用しています。
extract-urls.py from urllib.request import urlopen from xml.etree import ElementTree url = &amp;#34;https://example.com/sitemap.xml&amp;#34; def fetch(url: str) -&amp;gt; str: &amp;#34;&amp;#34;&amp;#34;指定した URL のリソースを文字列で取得します。&amp;#34;&amp;#34;&amp;#34; with urlopen(url) as res: return res.</description></item><item><title>Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する</title><link>https://maku77.github.io/p/wewevcs/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wewevcs/</guid><description>urllib.request.urlopen() が返した HTTPResponse オブジェクトの info() メソッドを呼び出すと、HTTP レスポンスのヘッダ情報を取得することができます。 ヘッダ情報は HTTPMessage オブジェクト として返されますが、これは通常の辞書オブジェクトと同様に使用することができます。 詳しくは、HTTPMessage の親クラスである email.message.Message の定義を参照してください。
次の例では、Web サイトにアクセスしたときの HTTP レスポンスヘッダーを取得して表示しています。
sample.py import urllib.request url = &amp;#39;https://yahoo.co.jp/&amp;#39; try: with urllib.request.urlopen(url) as res: # HTTP レスポンスのヘッダ情報を取得 headers = res.info() print(type(headers)) #=&amp;gt; http.client.HTTPMessage print() print(headers) # 下記は Body 部分の取得 # text = res.read().decode(&amp;#39;utf-8&amp;#39;) # print(text) except urllib.error.URLError as err: print(&amp;#39;Could not access: %s&amp;#39; % url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) 実行結果 &amp;lt;class &amp;#39;http.client.HTTPMessage&amp;#39;&amp;gt; Cache-Control: private, no-cache, no-store, must-revalidate Content-Type: text/html; charset=UTF-8 Date: Mon, 01 Jun 2020 06:07:42 GMT Expires: -1 Pragma: no-cache Set-Cookie: B=1sg6o4tfd96pe&amp;amp;b=3&amp;amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.</description></item><item><title>Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode)</title><link>https://maku77.github.io/p/w7p7n4j/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w7p7n4j/</guid><description>Python の標準モジュールとして提供されている urllib.parse を使用すると、任意の文字列を URL 内で扱えるようにエンコード／デコードすることができます。 ユーザーが入力したテキストや、日本語を含むテキストをエスケープ処理して URL として扱いたいときに使用できます。
文字列を URL エンコードする (quote) 任意の文字列を URL として扱いたいときは、urllib.parse.quote 関数 を使うと、エスケープすべき文字を %xx という形に変換してくれます。
from urllib.parse import quote print(quote(&amp;#39;あ&amp;#39;)) #=&amp;gt; &amp;#39;%E3%81%82&amp;#39; print(quote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(quote(&amp;#39;A B C&amp;#39;)) #=&amp;gt; &amp;#39;A%20B%20C&amp;#39; print(quote(&amp;#39;A/B/C&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; 上記の結果からわかるように、quote 関数はデフォルトではスラッシュ (/) をエスケープしません。 これは、変換しない文字を示すオプションパラメータ safe のデフォルト値が '/' になっているからです。 次のようにすると、スラッシュが %2F にエスケープされるようになります。
print(quote(&amp;#39;A/B/C&amp;#39;, safe=&amp;#39;&amp;#39;)) #=&amp;gt; &amp;#39;A%2FB%2FC&amp;#39; URL の特定階層のパス名をユーザーに入力させるようなケースで使用できます。
URL をデコードする (unquote) 逆に、URL エンコードされた文字列をデコードして元に戻すには、urllib.parse.unquote 関数 を使用します。
from urllib.parse import unquote print(unquote(&amp;#39;%E3%81%82&amp;#39;)) #=&amp;gt; &amp;#39;あ&amp;#39; print(unquote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(unquote(&amp;#39;A%20B%20C&amp;#39;)) #=&amp;gt; &amp;#39;A B C&amp;#39; print(unquote(&amp;#39;A%2FB%2FC&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; クエリ文字列を作成する (urlencode) HTTP の GET リクエストを送るときに、URL の末尾に次のようにクエリ文字列を付加したいことがあります。</description></item><item><title>.env ファイルで環境変数を設定する (python-dotenv)</title><link>https://maku77.github.io/p/gzo8d7y/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gzo8d7y/</guid><description>python-dotenv モジュールの概要 python-dotenv モジュール を使用すると、Python プログラム実行時に下記のようなファイルを読み込んで、環境変数を設定することができます。
.env MYAPP_USER=maku MYAPP_PASS=makupass MYAPP_CONFIG=${HOME}/${MYAPP_USER}/config 上記の例のように、${HOME} という形で環境変数の値を展開することもできます。
特定のプログラムを実行するために、いちいち OS の環境変数を設定するのを嫌がるユーザーはたくさんいます。 あなたのプログラムが何らかの環境変数を必要としているのであれば、.env ファイルによる設定手段も提供しておくと親切です。 .env の仕組みは Python に限ったものではなく、いろいろな言語で採用されています。
参考: Node.js プログラムで .env ファイルを使用する python-dotenv モジュールのインストール python-dotenv モジュールは pip コマンドでインストールできます。
$ python3 -m pip install python-dotenv システム全体の Python 実行環境を汚したくない場合は、次のように 仮想環境を作成してインストール しましょう。
$ python3 -m venv ~/venv $ source ~/venv/bin/activate (venv) $ python3 -m pip install python-dotenv 仮想環境は次のように抜けられます。
(venv) $ deactivate python-dotenv の使い方 .env ファイルの内容を環境変数に反映する .env ファイルを読み込むのはとても簡単で、load_dotenv() を呼び出すだけです。 次の Python スクリプトでは、同じディレクトリ（あるいは、より上位のディレクトリ）に置かれた .</description></item><item><title>Python の実行環境を切り替えて使用する (venv) Python3.3以降</title><link>https://maku77.github.io/p/wozpogm/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wozpogm/</guid><description>venv モジュールは、Python の仮想実行環境を作成するための標準モジュールです。 Python 3.2 までは virtualenv という外部パッケージを使用していましたが、Python 3.3 以降は標準で同等機能を提供する venv パッケージ を使用できます。
なぜ仮想環境が必要か？ Python で作成されたプログラムは、pip install で外部モジュールをインストールすることを前提に作成されたものがたくさんあります。 Python プログラムを実行するために、何も考えずに pip install を繰り返していると、いろいろなバージョンのモジュールがインストールされてしまい、実行環境がぐちゃぐちゃになってしまいます。 あるプログラムを動作させるために pip install すると、別のプログラムが動作しなくなるといったことが起こります。
venv を使って仮想環境を作ると、その環境内に閉じて pip install することができるようになります。 例えば、app1 と app2 という 2 つの Python プログラム用に別々の仮想環境を作って、それぞれのプログラムに必要なパッケージをインストールするということができます。
（注意）以下、python3 というコマンドを使っていますが、これはバージョン 3 以降の Python を使用することを示しています。 環境によっては、python に置き換えて読んでください（Windows の場合は py だったりします）。
プロジェクト用の仮想環境を作成する／削除する 仮想環境を作成する 仮想環境を作成するには、次のようなコマンドを実行します。 仮想環境はディレクトリの形で作成され、その中に必要なファイルが自動生成されます。
仮想環境の作成 $ python3 -m venv &amp;lt;仮想環境ディレクトリ&amp;gt; プロジェクトごとに仮想環境を作成するのであれば、プロジェクトのルートに仮想環境ディレクトリを作成するのがよいでしょう。 例えば、myapp プロジェクト用の仮想環境を作るには次ようにします（仮想環境ディレクトリ名を .venv としています）。
$ mkdir ~/myapp $ cd ~/myapp $ python3 -m venv .</description></item><item><title>Python でドキュメンテーションコメント (docstring) を記述する</title><link>https://maku77.github.io/p/y2biqz7/</link><pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y2biqz7/</guid><description>Docstring とは？ Python のコードに docstring フォーマットでコメントを記述しておくと、いろいろなツールから API ドキュメントとして参照できるようになります。 例えば、Python 用の統合開発環境 (IDE) におけるコード補完時に、ヒントとして関数の使用方法が表示されます。
下記は PEP 257 &amp;ndash; Docstring Conventions に記述されている docstring の書き方の例です。
def complex(real=0.0, imag=0.0): &amp;#34;&amp;#34;&amp;#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) &amp;#34;&amp;#34;&amp;#34; if imag == 0.0 and real == 0.0: return complex_zero ... docstring はこのように 3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲んで記述します。 docstring コメントは関数の内部に記述する ところがポイントです。 このあたりは、関数の外側にドキュメンテーションコメントを記述する Java や C# などとは異なっています。</description></item><item><title>Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする</title><link>https://maku77.github.io/p/i4zkqye/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i4zkqye/</guid><description>リクエストごとにヘッダを設定する (Request) urllib.request.Request オブジェクトの add_header メソッドや、headers プロパティを使用すると、HTTP リクエスト時のヘッダ情報を設定することができます。 あとは、urllib.request.urlopen で HTTP リクエストを送信するとき、URL の代わりに Request オブジェクトを渡せば、ヘッダ付きのリクエストを送ることができます。
import urllib.request def create_request(): req = urllib.request.Request(&amp;#39;https://example.com/myapi&amp;#39;) req.add_header(&amp;#39;Referer&amp;#39;, &amp;#39;http://www.python.org/&amp;#39;) req.add_header(&amp;#39;User-Agent&amp;#39;, &amp;#39;Mozilla/5.0&amp;#39;) return req if __name__ == &amp;#39;__main__&amp;#39;: req = create_request() with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) 上記の例では、Request#add_header() メソッドを使って、ヘッダ情報を 1 つずつ付加しています。 Request#headers プロパティを使用すれば、複数のヘッダ情報をディクショナリ形式でまとめて設定することができます。
req.headers = { &amp;#39;Referer&amp;#39;: &amp;#39;http://www.python.org/&amp;#39;, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0&amp;#39;, } すべてのリクエストに共通のヘッダを設定する (OpenerDirector) Request オブジェクトは URL まで含んでいるため、アクセス先の URL が変わるたびに生成しなおす必要があります。 一方、OpenerDirector を使用すると、リクエスト時のヘッダ情報などはそのままで、URL だけを変更してアクセスすることができます。
import urllib.request def create_opener(): opener = urllib.</description></item><item><title>Python の実行環境を切り替えて使用する (virtualenv) Python3.2まで</title><link>https://maku77.github.io/p/yqjs3aw/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yqjs3aw/</guid><description>virtualenv コマンドを使用すると、仮想的な Python の実行環境を作成することができます。 （追記）Python 3.3 以降は、virtualenv と同様の機能を提供する venv モジュールが標準搭載されたので、そちらを使うようにしましょう。
Python の実行環境を切り替えて使用する (venv) virtualenv とは Virtualenv Python 製のツールを使おうとすると、使用可能な Python のバージョンが制限されていたり、依存する Python パッケージを pip コマンドでたくさんインストールしなければいけなかったりします。 こういったツールを実行するために、パッケージをどんどんインストールしていくと、PC 内の Python 環境がぐちゃぐちゃになってしまいます（システムの site-packages ディレクトリに大量のパッケージがインストールされて管理できなくなる）。
そこで便利なのが、独立した Python 環境を作成することができる virtualenv コマンドです。 virtualenv で作成した仮想環境の中では、特定のバージョンの Python を使用することができ、閉じた環境内に Python パッケージをインストール (pip install) することができます。 もし、その環境が必要なくなったら、仮想環境ごと削除してしまえば、PC 内のグローバルな Python 実行環境はクリーンなままです。
例えば、何らかの Python 製ツール app があったとして、そのツールを使用するにはいくつかの Python パッケージをインストールしなければならないとします。 virtualenv を使用して、その Python 製ツールを使用するための環境を作る流れは以下のようになります。
app ディレクトリに移動する (cd app) app 用の Python 仮想環境を作成する (virtualenv 環境名) 仮想環境に入る (source 環境名/bin/activate) app に必要な Python パッケージをインストールする (pip install XXX) app を使う (python app.</description></item><item><title>Windows で pydoc コマンドを使用できるようにする</title><link>https://maku77.github.io/p/6h2izfh/</link><pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6h2izfh/</guid><description>pydoc コマンドを使用すると、下記のように Python の API ドキュメントを手軽に参照できます。
$ pydoc list.sort Help on method_descriptor in list: list.sort = sort(...) L.sort(key=None, reverse=False) -&amp;gt; None -- stable sort *IN PLACE* Windows では Python をインストールしただけでは pydoc コマンドは使用できませんが、実装自体は Lib/pydoc.py というスクリプトとしてインストールされます。 下記のようなバッチファイルを python.exe と同じディレクトリに作成しておけば、Windows でも pydoc コマンドを使用できるようになります。
pydoc.cmd @python %~dp0\Lib\pydoc.py %* 実行例 C:\&amp;gt; pydoc dict.update Help on method_descriptor in dict: dict.update = update(...) D.update([E, ]**F) -&amp;gt; None. Update D from dict/iterable E and F. If E is present and has a .</description></item><item><title>Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP)</title><link>https://maku77.github.io/p/6k5m4jy/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6k5m4jy/</guid><description>python コマンドを単独で実行したときのインタラクティブシェルは、環境変数 PYTHONSTARTUP に指定したスタートアップ・スクリプトを最初に実行します。 これを利用して、日常的に使用したい関数などを自動的に定義することができます。
例えば、下記の例では、ホームディレクトリにある .pythonstartup スクリプトを読み込むように設定しています。
~/.bash_profile (Linux や Mac OSX の場合） export PYTHONSTARTUP=~/.pythonstartup Windows の場合は、システムのプロパティから環境変数を設定してください（~/ という表記は使用できないので、スタートアップ・スクリプトの位置はフルパスで指定する必要があります）。 コマンドラインから環境変数を設定することもできます。
C:\&amp;gt; setx PYTHONSTARTUP D:/x/myconf/pythonstartup.py （コマンドプロンプトを再起動して反映） 下記のスタートアップ・スクリプトでは、モジュールのソースコードをさくっと確認するための DEV.code 関数を定義しています。DEV.file 関数の方は、指定したモジュールのコードを Vim エディタで開きます。
~/.pythonstartup class DEV: @staticmethod def code(obj): import inspect print(inspect.getsource(obj)) @staticmethod def file(obj): import inspect import os os.system(&amp;#39;gvim &amp;#39; + inspect.getfile(obj)) あとは、Python のインタラクティブシェルを起動すれば、上記の関数が定義された状態で起動します。
$ python ... &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; DEV.code(os.path.split) def split(p): &amp;#34;&amp;#34;&amp;#34;Split a pathname. Return tuple (head, tail) where tail is everything after the final slash.</description></item><item><title>Python の関数やクラスのソースコードを確認する (inspect)</title><link>https://maku77.github.io/p/xbucsaq/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xbucsaq/</guid><description>関数のコードを表示する Python のプログラムを作成しているときに、ある関数のソースコードを確認したくなったときは、inspect モジュールの getsource 関数を使用して簡単に調べることができます。
次の例では、Python の対話型シェル（python3 コマンド）を起動して、os.path.abspath 関数の実装コードを確認しています。
例: os.path.abspath の実装コードを確認する &amp;gt;&amp;gt;&amp;gt; import inspect &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; print(inspect.getsource(os.path.abspath)) def abspath(path): &amp;#34;&amp;#34;&amp;#34;Return an absolute path.&amp;#34;&amp;#34;&amp;#34; path = os.fspath(path) if not isabs(path): if isinstance(path, bytes): cwd = os.getcwdb() else: cwd = os.getcwd() path = join(cwd, path) return normpath(path) （おまけ）シェルスクリプト化しておく 次のようなシェルスクリプト (pycode) を作っておくと、Python の関数の実装コードを簡単に確認できるようになります。 このシェルスクリプトは、PATH の通ったディレクトリに置いて、chmod +x pycode で実行権限を付けておきます。
/Users/maku/bin/pycode #!/bin/bash # # pycode - Python の関数やクラスの実装コードを表示します # # Usage: # $ pycode &amp;lt;モジュール名&amp;gt; &amp;lt;関数名|クラス名&amp;gt; # # 使用例: # $ pycode os path.</description></item><item><title>Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve)</title><link>https://maku77.github.io/p/5zj72ei/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5zj72ei/</guid><description>urllib.request によるファイルのダウンロード urllib.request.urlretrieve を使用すると、簡単に Web 上のファイルをダウンロードしてローカルファイルとして保存することができます。
urllib.request.urlretrieve 関数 下記の download_file 関数は、指定した URL のファイルをカレントディレクトリにダウンロードします。
import urllib.request import os.path def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; urllib.request.urlretrieve(url, filename) if __name__ == &amp;#39;__main__&amp;#39;: download_file(&amp;#39;https://example.com/&amp;#39;) ローカルに作成されるファイル名は、os.path.basename を使用して、URL の末尾から切り出しています。 URL の末尾にファイル名らしきものが見つからない場合は、デフォルトファイル名として index.html で保存するようにしています。
テンポラリファイルとしてダウンロードする urllib.request.urlretrieve の 2 番目のパラメータ (filename) を省略すると、テンポラリディレクトリに適当なファイル名で保存されます。 このファイルパスは、戻り値で返されるタプルの先頭に格納されています。
path, headers = urllib.request.urlretrieve(&amp;#39;http://example.com/sample.png&amp;#39;) print(path) #=&amp;gt; c:\users\maku\appdata\local\temp\tmpgujizj urlretrieve により作成された一時ファイルを確実に削除するには、下記のように後始末しておきます。
urllib.request.urlcleanup() このファイルはテンポラリディレクトリに作成されるファイルなので、それほど厳密に削除する必要はないかと思いますが、大量のテンポラリファイルが作られるような場合は実行しておいた方がよいでしょう。
ダウンロード時の HTTP レスポンスヘッダの取得 urllib.request.urlretrieve により、ファイルをダウンロードした際に、ついでに HTTP レスポンスヘッダを取得したい場合 は、下記のように 戻り値のタプルの 2 番目の要素 から取得できます。
path, headers = urllib.</description></item><item><title>Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler)</title><link>https://maku77.github.io/p/4yiygwe/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4yiygwe/</guid><description>urllib.request モジュールを使って Basic 認証の設定された Web サイトにアクセスすると、デフォルトでは下記のようなエラーが発生します。
Basic 認証エラー urllib.error.HTTPError: HTTP Error 401: Authorization Required HTTPBasicAuthHandler を使用すると、各 Web サイトにアクセスするときのユーザ名と、パスワード情報を設定することができます。 具体的には、Basic 認証のかかった Web サイトにアクセスした場合に Web サーバから返される realm 情報 と、ベースとなる URI 情報 に対して、使用するユーザ名とパスワードを関連付けます。
下記のサンプルでは、http://example.com/secret/ 以下にアクセスする際に、Basic 認証のユーザ名、パスワードとして、user1、pass1 を利用するように設定しています。 ここでは、realm 情報は無視し、URI 情報だけに関連付けるようにするため、HTTPPassswordMgrWithDefaultRealm を使用しています。
Basic 認証の付いたサイトにアクセスする import urllib.request import os.path def setup_basic_auth(base_uri, user, password): password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password( realm=None, uri=base_uri, user=user, passwd=password) auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr) opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; print(&amp;#39;Downloading .</description></item><item><title>Python で HTML をパースする (HTMLParser)</title><link>https://maku77.github.io/p/nqz8fnu/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nqz8fnu/</guid><description>HTMLParser で HTML を処理する Python に標準搭載されている HTML パーサである html.parser.HTMLParser は、イベントドリブンな HTML パーサです。
HTMLParser クラスを継承して独自のパーサを作成し、feed メソッドに HTML テキストを渡すことによってパースを開始します。 下記のサンプルコードでは、開始タグ、終了タグ、テキストデータ、コメントが見つかったときに、それぞれ内容を出力しています。
sample.py from html.parser import HTMLParser # HTMLParser を継承してパーサクラスを作成する class MyParser(HTMLParser): def handle_starttag(self, tag, attrs): print(&amp;#34;START :&amp;#34;, tag, attrs) def handle_endtag(self, tag): print(&amp;#34;END :&amp;#34;, tag) def handle_data(self, data): print(&amp;#34;DATA :&amp;#34;, data) def handle_comment(self, comment): print(&amp;#34;COMMENT:&amp;#34;, comment) # パーサのインスタンスを生成してパースを実行 parser = MyParser() parser.feed(&amp;#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;#39; &amp;#39;&amp;lt;div class=&amp;#34;class1&amp;#34; id=&amp;#34;id1&amp;#34;&amp;gt;Hello World&amp;lt;/div&amp;gt;&amp;#39; &amp;#39;&amp;lt;!-- I am a comment --&amp;gt;&amp;#39; &amp;#39;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;) 実行結果 START : html [] START : body [] START : div [(&amp;#39;class&amp;#39;, &amp;#39;class1&amp;#39;), (&amp;#39;id&amp;#39;, &amp;#39;id1&amp;#39;)] DATA : Hello World END : div COMMENT: I am a comment END : body END : html HTMLParser は、単純に HTML 要素を前から順番に処理していくだけなので、現在の要素がどのようなコンテキストで記述されているかは、パーサクラス内で判断していくように実装する必要があります。</description></item><item><title>Python の requests パッケージによる HTTP リクエスト</title><link>https://maku77.github.io/p/r7q8q7o/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r7q8q7o/</guid><description>requests パッケージのインストール オープンソースの requests パッケージ を使用すると、Python 3 標準の urllib.request よりも簡単に HTTP リクエストを扱うことができます。 例えば、以下のような処理をシンプルなコードで扱うことができます。
Basic 認証、ダイジェスト認証 ファイルのアップロード クッキー SSL 検証 エンコーディング形式の自動判別 コンテンンツが圧縮されていた場合の自動展開 requests パッケージは、pip コマンドで簡単にインストールできます。
request パッケージのインストール $ pip install requests requests モジュールによる HTTP GET リクエスト requests.get 関数を使うと、HTTP GET リクエストでインターネット上のコンテンツをダウンロードすることができます。 requests.get は、戻り値として requests.models.Response オブジェクトを返します。
Web コンテンツのダウンロード import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) type(res) #=&amp;gt; &amp;lt;class &amp;#39;requests.models.Response&amp;#39;&amp;gt; Response オブジェクトから、ステータスコードや、取得したコンテンツの内容を取得することができます。
requests.get のレスポンスを詳しく見る import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) print(res.status_code) #=&amp;gt; 200 print(res.status_code == requests.codes.ok) #=&amp;gt; True print(res.</description></item><item><title>Python で HTML をパースする (Beautiful Soup)</title><link>https://maku77.github.io/p/r4m4k2i/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r4m4k2i/</guid><description>Beautiful Soup とは Python 標準の html.parser モジュールは、SAX 形式のイベントドリブンなパーサなため、若干扱いにくいところがあります。 Beautiful Soup ライブラリを使用することで、HTML の要素に簡単にアクセスすることができるようになります。
Beautiful Soap Documentation Beautiful Soup パッケージは次のようにインストールできます。
$ pip install beautifulsoup4 HTML をパースする 最初に、HTML 文字列や HTML ファイルから bs4.BeautifulSoup オブジェクトを生成する必要があります。
HTML 文字列から soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(&amp;#34;&amp;lt;html&amp;gt;Hello&amp;lt;/html&amp;gt;&amp;#34;, features=&amp;#34;html.parser&amp;#34;) HTML ファイルから soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(open(&amp;#34;input.html&amp;#34;), features=&amp;#34;html.parser&amp;#34;) Beautiful Soup 自体には Web 上のリソースをダウンロードする機能は備わっていないので、そのようなケースでは、requests モジュールなどで HTML リソースをダウンロードしておいて、BeautifulSoup コンストラクタに渡してやります。
Web 上の HTML リソースから soup を作成（requests モジュールを使用） from bs4 import BeautifulSoup import requests res = requests.</description></item><item><title>Python で HTTP を扱う方法いろいろ</title><link>https://maku77.github.io/p/k5p4axo/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k5p4axo/</guid><description>Python3 の標準 HTTP ライブラリ Python3 には HTTP を扱う、下記のような標準ライブラリが用意されています。
http.client
HTTP (RFC 2616) を実装する 低レベルライブラリ。 urllib.request
上記を利用した 高レベルライブラリ。認証やリダイレクトをサポートしています。 オープンソースの HTTP ライブラリ Python に標準で付属している urllib.request パッケージは、比較的低レベルな処理を行うように設計されているため、手っ取り早く HTTP リクエストでデータを取得したい場合は、オープンソースの requests パッケージ を使うとよいでしょう。 requests パッケージは、Python の公式サイトでも推奨されています。
requests パッケージ</description></item><item><title>Python のパッケージ管理ツール (pip) の使い方</title><link>https://maku77.github.io/p/7o9q8p6/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7o9q8p6/</guid><description>pip とは Python のパッケージ管理ツールである pip コマンドは、従来の setuptools で提供されていた easy_install コマンドを置き換えるものです。 pip コマンドは、主に Python Package Index からパッケージをダウンロードしてインストールします。
pip のインストール Python 3.4 以降の Python インストーラを使用すると、pip コマンドは標準でインストールされます。 下記のいずれかの方法ですでにインストールされているか確認しましょう。
$ pip --version $ python -m pip --version $ python3 -m pip --version 単体でインストールする必要がある場合は、基本的には下記のサイトに従ってインストールします。
Installation - pip documentation pip 1.5.1 までは、setuptools の easy_install コマンドを使用してインストールしていましたが、現在は get-pip.py スクリプトを使ってどの OS 環境でも統一された方法で簡単にインストールすることができます。
pip コマンドのインストール $ curl -kL https://bootstrap.pypa.io/get-pip.py | python3 プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。
pip によるパッケージのインストール、アンインストール $ pip install &amp;lt;package&amp;gt; $ pip install -U &amp;lt;package&amp;gt; # パッケージを最新版にアップグレード $ pip install -I &amp;lt;package&amp;gt; # パッケージをインストールしなおす $ pip uninstall &amp;lt;package&amp;gt; # パッケージのアンインストール プロキシ環境で使用する場合は、--proxy=proxy.</description></item><item><title>Python で XML をパースする (ElementTree)</title><link>https://maku77.github.io/p/cp9q7n5/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cp9q7n5/</guid><description>ElementTree XML API Python 2.5 以降には、XML を扱うための標準 API として、ElementTree XML API が用意されています。
The ElementTree XML API ElementTree では、パースした XML を DOM オブジェクトとしてメモリ上に保持するため、XML データを読み込んだあとは、各 XML 要素へ柔軟にアクセスすることができます。
XML ファイルをパースする ElementTree モジュールが提供している ElementTree.parse 関数を使って、XML ファイルを読み込むことができます。 ElementTree.parse 関数は、読み込んだ XML をパースして ElementTree オブジェクトとして返します。 ElementTree オブジェクトは、XML ツリー全体を表現するオブジェクトです。 XML ツリーの先頭要素を表す Element オブジェクトは、ElementTree#getroot() メソッドで取得することができます。
input.xml（テスト用の XML ファイル） &amp;lt;tree name=&amp;#34;hello&amp;#34;&amp;gt; &amp;lt;trunk&amp;gt;...&amp;lt;/trunk&amp;gt; &amp;lt;/tree&amp;gt; main.py from xml.etree import ElementTree # XML ファイルから ElementTree オブジェクトを生成 tree = ElementTree.parse(&amp;#39;input.xml&amp;#39;) # 先頭要素を表す Element オブジェクトを取得 elem = tree.</description></item><item><title>Python で XML を扱う方法いろいろ</title><link>https://maku77.github.io/p/pt6fpx8/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pt6fpx8/</guid><description>Python には下記のように、標準の XML パーサが複数搭載されています。
xml.etree.ElementTree &amp;hellip; The ElementTree XML API xml.dom &amp;hellip; The Document Object Model API xml.dom.minidom &amp;hellip; Minimal DOM implementation xml.sax &amp;hellip; Support for SAX2 parsers 通常はシンプルな xml.etree.ElementTree を使い、DOM 標準の API を使いたい場合は xml.dom を使用すればよいでしょう。 巨大な XML ファイルを効率的に読み込みたい場合は、SAX API を提供する xml.sax を選択できます。
参考: 20. Structured Markup Processing Tools Beautiful Soup などの 3rd パーティライブラリでも XML を扱うことはできますが、Beautiful Soup はどちらかというと HTML のパースに向いています。 XML のパースは、ほとんどの場合 Python 標準の ElementTree で十分です。</description></item><item><title>Python で XPath を使って XML 要素を参照する (ElementTree)</title><link>https://maku77.github.io/p/fufwevc/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fufwevc/</guid><description>Python 2.5 以降に搭載されている ElementTree XML API は、XPath による要素アクセスをサポートしています。
The Element Tree XML API - XPath support 次の例では、country という名前の要素をすべて取得し、再帰的に子要素を表示しています。
countries.xml（入力ファイル） &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;data&amp;gt; &amp;lt;country name=&amp;#34;Liechtenstein&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;1&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2008&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;141100&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Austria&amp;#34; direction=&amp;#34;E&amp;#34;/&amp;gt; &amp;lt;neighbor name=&amp;#34;Switzerland&amp;#34; direction=&amp;#34;W&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;country name=&amp;#34;Singapore&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;4&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;59900&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Malaysia&amp;#34; direction=&amp;#34;N&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;country name=&amp;#34;Panama&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;68&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;13600&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Costa Rica&amp;#34; direction=&amp;#34;W&amp;#34;/&amp;gt; &amp;lt;neighbor name=&amp;#34;Colombia&amp;#34; direction=&amp;#34;E&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;/data&amp;gt; sample.py from xml.etree import ElementTree def dump_node(node, indent=0): print(&amp;#39; &amp;#39; * indent, node.tag, node.</description></item><item><title>Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen)</title><link>https://maku77.github.io/p/o2e43ct/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o2e43ct/</guid><description>ここでは、Python の組み込みモジュールである urllib.request を使った HTTP アクセスの例を示します。
urlopen による GET/POST リクエストの基本 urllib.request.urlopen 関数は、http.client.HTTPResponse オブジェクトを返します。 HTTPResponse オブジェクトの read メソッドを呼ぶことで、HTTP レスポンスを取得することができます。
https://example.com のコンテンツ (HTML) を取得する from urllib.request import urlopen with urlopen(&amp;#39;https://example.com/&amp;#39;) as res: text = res.read().decode(&amp;#39;utf-8&amp;#39;) print(text) read メソッドが返すデータはバイナリデータ (bytes) なので、テキストとして扱う場合は、エンコーディング形式（utf-8 など）を指定してデコードする必要があります。
urlopen 関数で取得した HTTPResponse オブジェクトは、リソース解放のために明示的に close() することが推奨されているのですが、上記のように Python 3 の with 文を使用すると、close() 処理を自動化できます。
urlopen の引数に、URL 文字列ではなく、urllib.request.Request オブジェクトを渡すこともできます。 Request オブジェクトを使うと、HTTP ヘッダー情報やプロキシ、HTTP メソッド（GET や POST）の指定などを行えます。
HTTP ヘッダーやプロキシを指定したリクエスト import urllib.request URL = &amp;#39;http://example.com/&amp;#39; req = urllib.</description></item><item><title>Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする</title><link>https://maku77.github.io/p/ogq5hdy/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ogq5hdy/</guid><description>urllib.request を使用した HTTP アクセスは、デフォルトでシステムに設定されたプロキシ設定（http_proxy、https_proxy、ftp_proxy 環境変数など）でアクセスが行われます。 これらのプロキシ設定をそのまま使用してもよいし、Python のコード内で明示的にプロキシを設定することもできます。
現在のプロキシ設定を確認する (getproxies) 現在、システムにどのようなプロキシ設定が反映されているかを調べるには、urllib.request.getproxies 関数を使用します。
import urllib.request print(urllib.request.getproxies()) 実行結果 {&amp;#39;http&amp;#39;: &amp;#39;http://proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;: &amp;#39;https://proxy.example.com:8080&amp;#39;, &amp;#39;ftp&amp;#39;: &amp;#39;ftp://proxy.example.com:8080&amp;#39;} リクエストごとにプロキシを設定する (Request) HTTP リクエストごとに使用するプロキシを明示的に指定したい場合は、Request オブジェクトを作成し、set_proxy メソッドでプロキシを指定します。 あとは、その Request オブジェクトを urllib.request.urlopen() に渡して HTTP リクエストを送信します。
リクエスト単位でのプロキシ設定 import urllib.request req = urllib.request.Request(&amp;#39;https://example.com/&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;http&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;) with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) Request#set_proxy() でプロキシサーバーを指定するときは、http:// や https:// といったスキーム名は省略することに注意してください。 スキーム名を記述してしまうと、プロキシがうまく認識されず、次のような DNS エラーになったりします。
urlopen error [Errno 11001] getaddrinfo failed Request オブジェクトは生成時に URL を指定する必要があるため、アクセス先が変わるごとに生成する必要があることに注意してください。</description></item><item><title>Python コードの実行時間を計測する (datetime.now)</title><link>https://maku77.github.io/p/ubtbs9p/</link><pubDate>Thu, 01 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ubtbs9p/</guid><description>下記は datetime モジュールを使って、Python コードの一部の実行時間を計測する例です。
main.py from datetime import datetime start = datetime.now() # ここに実行時間を計測したい処理を記述する print(datetime.now() - start) 実行結果 $ python3 main.py 00:00:01.547393</description></item><item><title>Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer)</title><link>https://maku77.github.io/p/rr3cmu5/</link><pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rr3cmu5/</guid><description>Python がインストールされた環境であれば、コマンドラインから下記のように実行することで簡易 HTTP サーバを立てることができます。
（Python3 の場合）ポート 8000 で HTTP サーバーを起動 $ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... （Python2 の場合）ポート 8000 で HTTP サーバーを起動 $ python -m SimpleHTTPServer 8000 Serving HTTP on 0.0.0.0 port 8000 ... これで、http://localhost:8000/ にアクセスすれば、カレントディレクトリ内のファイルの一覧が表示されます。 開発環境での HTTP 開通テストや、LAN 内の一時的なファイル共有サーバとして使用することができます。</description></item><item><title>Python でユニットテストを記述する (unittest)</title><link>https://maku77.github.io/p/fueucsa/</link><pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fueucsa/</guid><description>Python でユニットテストを書くには、unittest モジュール を使用します。 unittest モジュールは、Python 2.1 以降に標準で搭載されています。
テストケースを作成するには、unittest.TestCase を継承したクラスを作成し、test で始まる名前のテストメソッドを記述するだけで OK です。 unittest.main 関数を呼び出すことにより、それらのテストメソッドが自動的に実行されます。
sample.py import unittest class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def decrement(self): self.count -= 1 def get_count(self): return self.count class CounterTest(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def test_increment(self): c = Counter() c.increment() self.assert_(c.get_count() == 1) c.increment() self.assert_(c.get_count() == 2) def test_decrement(self): c = Counter() c.decrement() self.assert_(c.get_count() == -1) c.decrement() self.</description></item><item><title>Python で XML を構築する (minidom)</title><link>https://maku77.github.io/p/m2k3jyg/</link><pubDate>Fri, 08 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m2k3jyg/</guid><description>下記は、Python の minidom モジュールが提供する DOM インタフェースを使用して XML を構築し、XML ファイルとして保存するサンプルです。
sample.py import codecs from xml.dom import minidom def create_xmldoc(): doc = minidom.Document() tree = doc.createElement(&amp;#39;tree&amp;#39;) doc.appendChild(tree) branch = doc.createElement(&amp;#39;branch&amp;#39;) tree.appendChild(branch) leaf = doc.createElement(&amp;#39;leaf&amp;#39;) leaf.setAttribute(&amp;#39;id&amp;#39;, &amp;#39;001&amp;#39;) branch.appendChild(leaf) text = doc.createTextNode(&amp;#39;This is a leaf&amp;#39;) leaf.appendChild(text) return doc def save_xmldoc(xmldoc, filepath): f = codecs.open(filepath, &amp;#39;wb&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) # Text encoding xmldoc.writexml(f, &amp;#39;&amp;#39;, &amp;#39; &amp;#39;*2, &amp;#39;\n&amp;#39;, encoding=&amp;#39;UTF-8&amp;#39;) # XML header&amp;#39;s encoding f.close() if __name__ == &amp;#39;__main__&amp;#39;: doc = create_xmldoc() save_xmldoc(doc, &amp;#39;output.</description></item><item><title>Python で XML をパースする (minidom)</title><link>https://maku77.github.io/p/guducs9/</link><pubDate>Mon, 04 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/guducs9/</guid><description>Python 2.0 以降では、Document Object Model インタフェース (DOM API) の最小の実装として、xml.dom.minidom が搭載されています。 DOM 標準の API を使って操作する必要のない場合は、よりシンプルなインターフェースを提供している ElementTree モジュールを使用する のがよいでしょう。
Document オブジェクトを取得する minidom を使用して、XML の各要素にアクセスするためには、まずは DOM 全体を表現する xml.dom.minidom.Document オブジェクトを取得する必要があります。 データソースとしては、XML ファイル、XML 文字列、Web 上のリソースなどを利用できます。
XML ファイルを扱う場合 from xml.dom import minidom doc = minidom.parse(&amp;#34;input.xml&amp;#34;) print(doc.toxml()) XML 文字列を扱う場合 from xml.dom import minidom xml = &amp;#34;&amp;#34;&amp;#34; &amp;lt;tree&amp;gt; &amp;lt;branch&amp;gt; &amp;lt;leaf id=&amp;#39;1&amp;#39;&amp;gt;Leaf 1&amp;lt;/leaf&amp;gt; &amp;lt;leaf id=&amp;#39;2&amp;#39;&amp;gt;Leaf 2&amp;lt;/leaf&amp;gt; &amp;lt;leaf id=&amp;#39;3&amp;#39;&amp;gt;Leaf 3&amp;lt;/leaf&amp;gt; &amp;lt;/branch&amp;gt; &amp;lt;/tree&amp;gt;&amp;#34;&amp;#34;&amp;#34; doc = minidom.parseString(xml) print(doc.toxml()) Web 上の XML リソースを扱う場合 urllib モジュールを組み合わせて使えば、Web 上の XML も簡単にパースできます。</description></item><item><title>Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe)</title><link>https://maku77.github.io/p/kyj2izf/</link><pubDate>Tue, 10 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kyj2izf/</guid><description>py2exe を使用すると、Python のスクリプトから Windows 上で実行可能な .exe ファイルを作成することができます。
基本的な使い方 変換対象のスクリプト hello.py と、変換設定ファイル setup.py を用意します。
hello.py print &amp;#39;Hello&amp;#39; setup.py from distutils.core import setup import py2exe setup(console=[&amp;#39;test.py&amp;#39;]) コマンドラインから、次のように実行すると、dist ディレクトリに hello.exe と、必要なライブラリが生成されます。
C:\&amp;gt; python setup.py py2exe 配布するときは、dist ディレクトリの中身をすべてまとめて配布します。
（応用）wxPython などの GUI アプリケーションの場合 setup.py from distutils.core import setup import py2exe setup(windows=[&amp;#39;test.py&amp;#39;]) GUI を持つアプリケーションで、実行時にコマンドプロンプトを表示したくない場合は、setup メソッドのパラメータとして、console の代わりに windows を指定します。</description></item><item><title>Python の対話型シェルで使える小技</title><link>https://maku77.github.io/p/dsbsaq7/</link><pubDate>Wed, 07 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsbsaq7/</guid><description>Python のインタラクティブシェルで _（アンダースコア）を使用すると、 前回評価した値を参照することができます。
&amp;gt;&amp;gt;&amp;gt; [1, 2, 3] [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; len(_) 3</description></item><item><title>Python のコーディングスタイル</title><link>https://maku77.github.io/p/pyk3j2h/</link><pubDate>Tue, 06 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pyk3j2h/</guid><description>Python のコーディングスタイルは、PEP 8 や PEP 257 で指針が示されています。
PEP 8 &amp;ndash; Style Guide for Python Code PEP 257 &amp;ndash; Docstring Conventions このページでは主に上記の内容についてまとめていますが、実際に Python のプロジェクトにコーディングスタイルを適用するときは、Black などの Python フォーマッターを導入 することをおすすめします。 Black は、PEP 8 や PEP 257 と若干異なるところがありますが、理にかなったスタイルを強制的に適用してくれます。
命名規則 大文字／小文字 パッケージ名は小文字のみ（例: mypackage） クラス名は大文字で始める（例: MyClass） 関数、あるいは public メソッドは小文字（例: my_public_method） protected メソッドはアンダースコア 1 つで始める（例: _my_protected_method） private メソッドはアンダースコア 2 つで始める（例: __my_private_method） 定数名はすべて大文字（例: MY_CONSTANT） Python の name mangling の仕組みによって、アンダースコア 2 つで始まる名前は、クラス外部、あるいはサブクラスからその名前ではアクセスできないようになっています（正確には _ClassName__method という名前でアクセスできますが）。 この特性を利用して、private メソッドをアンダースコア 2 つで始めるようにするのがよい、ということです。
グローバル領域でのアンダースコアの使用について トップレベルに定義するクラスや関数で、モジュール（ファイル）内に閉じて外部に公開しないものは、プレフィックスとして 1 つのアンダースコアを付けます。 こうすることで、from M import * の形での自動インポートを防ぐことができます。</description></item></channel></rss>