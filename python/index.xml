<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 天才まくまくノート</title><link>https://maku77.github.io/python/</link><description>Recent content in Python on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 01 Jun 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する</title><link>https://maku77.github.io/p/wewevcs/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wewevcs/</guid><description>urllib.request.urlopen() が返した HTTPResponse オブジェクトの info() メソッドを呼び出すと、HTTP レスポンスのヘッダ情報を取得することができます。 ヘッダ情報は HTTPMessage オブジェクト として返されますが、これは通常の辞書オブジェクトと同様に使用することができます。 詳しくは、HTTPMessage の親クラスである email.message.Message の定義を参照してください。
次の例では、Web サイトにアクセスしたときの HTTP レスポンスヘッダーを取得して表示しています。
sample.py import urllib.request url = &amp;#39;https://yahoo.co.jp/&amp;#39; try: with urllib.request.urlopen(url) as res: # HTTP レスポンスのヘッダ情報を取得 headers = res.info() print(type(headers)) #=&amp;gt; http.client.HTTPMessage print() print(headers) # 下記は Body 部分の取得 # text = res.read().decode(&amp;#39;utf-8&amp;#39;) # print(text) except urllib.error.URLError as err: print(&amp;#39;Could not access: %s&amp;#39; % url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) 実行結果 &amp;lt;class &amp;#39;http.client.HTTPMessage&amp;#39;&amp;gt; Cache-Control: private, no-cache, no-store, must-revalidate Content-Type: text/html; charset=UTF-8 Date: Mon, 01 Jun 2020 06:07:42 GMT Expires: -1 Pragma: no-cache Set-Cookie: B=1sg6o4tfd96pe&amp;amp;b=3&amp;amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.</description></item><item><title>Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode)</title><link>https://maku77.github.io/p/w7p7n4j/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w7p7n4j/</guid><description>Python の標準モジュールとして提供されている urllib.parse を使用すると、任意の文字列を URL 内で扱えるようにエンコード／デコードすることができます。 ユーザーが入力したテキストや、日本語を含むテキストをエスケープ処理して URL として扱いたいときに使用できます。
文字列を URL エンコードする (quote) 任意の文字列を URL として扱いたいときは、urllib.parse.quote 関数 を使うと、エスケープすべき文字を %xx という形に変換してくれます。
from urllib.parse import quote print(quote(&amp;#39;あ&amp;#39;)) #=&amp;gt; &amp;#39;%E3%81%82&amp;#39; print(quote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(quote(&amp;#39;A B C&amp;#39;)) #=&amp;gt; &amp;#39;A%20B%20C&amp;#39; print(quote(&amp;#39;A/B/C&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; 上記の結果からわかるように、quote 関数はデフォルトではスラッシュ (/) をエスケープしません。 これは、変換しない文字を示すオプションパラメータ safe のデフォルト値が '/' になっているからです。 次のようにすると、スラッシュが %2F にエスケープされるようになります。
print(quote(&amp;#39;A/B/C&amp;#39;, safe=&amp;#39;&amp;#39;)) #=&amp;gt; &amp;#39;A%2FB%2FC&amp;#39; URL の特定階層のパス名をユーザーに入力させるようなケースで使用できます。
URL をデコードする (unquote) 逆に、URL エンコードされた文字列をデコードして元に戻すには、urllib.parse.unquote 関数 を使用します。
from urllib.parse import unquote print(unquote(&amp;#39;%E3%81%82&amp;#39;)) #=&amp;gt; &amp;#39;あ&amp;#39; print(unquote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(unquote(&amp;#39;A%20B%20C&amp;#39;)) #=&amp;gt; &amp;#39;A B C&amp;#39; print(unquote(&amp;#39;A%2FB%2FC&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; クエリ文字列を作成する (urlencode) HTTP の GET リクエストを送るときに、URL の末尾に次のようにクエリ文字列を付加したいことがあります。</description></item><item><title>.env ファイルで環境変数を設定する (python-dotenv)</title><link>https://maku77.github.io/p/gzo8d7y/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gzo8d7y/</guid><description>python-dotenv モジュールの概要 python-dotenv モジュール を使用すると、Python プログラム実行時に下記のようなファイルを読み込んで、環境変数を設定することができます。
.env MYAPP_USER=maku MYAPP_PASS=makupass MYAPP_CONFIG=${HOME}/${MYAPP_USER}/config 上記の例のように、${HOME} という形で環境変数の値を展開することもできます。
特定のプログラムを実行するために、いちいち OS の環境変数を設定するのを嫌がるユーザーはたくさんいます。 あなたのプログラムが何らかの環境変数を必要としているのであれば、.env ファイルによる設定手段も提供しておくと親切です。 .env の仕組みは Python に限ったものではなく、いろいろな言語で採用されています。
参考: Node.js プログラムで .env ファイルを使用する python-dotenv モジュールのインストール python-dotenv モジュールは pip コマンドでインストールできます。
$ python3 -m pip install python-dotenv システム全体の Python 実行環境を汚したくない場合は、次のように 仮想環境を作成してインストール しましょう。
$ python3 -m venv ~/venv $ source ~/venv/bin/activate (venv) $ python3 -m pip install python-dotenv 仮想環境は次のように抜けられます。
(venv) $ deactivate python-dotenv の使い方 .env ファイルの内容を環境変数に反映する .env ファイルを読み込むのはとても簡単で、load_dotenv() を呼び出すだけです。 次の Python スクリプトでは、同じディレクトリ（あるいは、より上位のディレクトリ）に置かれた .</description></item><item><title>Python の実行環境を切り替えて使用する (venv) Python3.3以降</title><link>https://maku77.github.io/p/wozpogm/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wozpogm/</guid><description>venv モジュールは、Python の仮想実行環境を作成するための標準モジュールです。 Python 3.2 までは virtualenv という外部パッケージを使用していましたが、Python 3.3 以降は標準で同等機能を提供する venv パッケージ を使用できます。
なぜ仮想環境が必要か？ Python で作成されたプログラムは、pip install で外部モジュールをインストールすることを前提に作成されたものがたくさんあります。 Python プログラムを実行するために、何も考えずに pip install を繰り返していると、いろいろなバージョンのモジュールがインストールされてしまい、実行環境がぐちゃぐちゃになってしまいます。 あるプログラムを動作させるために pip install すると、別のプログラムが動作しなくなるといったことが起こります。
venv を使って仮想環境を作ると、その環境内に閉じて pip install することができるようになります。 例えば、app1 と app2 という 2 つの Python プログラム用に別々の仮想環境を作って、それぞれのプログラムに必要なパッケージをインストールするということができます。
（注意）以下、python3 というコマンドを使っていますが、これはバージョン 3 以降の Python を使用することを示しています。 環境によっては、python に置き換えて読んでください（Windows の場合は py だったりします）。
プロジェクト用の仮想環境を作成する／削除する 仮想環境を作成する 仮想環境を作成するには、次のようなコマンドを実行します。 仮想環境はディレクトリの形で作成され、その中に必要なファイルが自動生成されます。
仮想環境の作成 $ python3 -m venv &amp;lt;仮想環境ディレクトリ&amp;gt; プロジェクトごとに仮想環境を作成するのであれば、プロジェクトのルートに仮想環境ディレクトリを作成するのがよいでしょう。 例えば、myapp プロジェクト用の仮想環境を作るには次ようにします（仮想環境ディレクトリ名を .venv としています）。
$ mkdir ~/myapp $ cd ~/myapp $ python3 -m venv .</description></item><item><title>Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする</title><link>https://maku77.github.io/p/i4zkqye/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i4zkqye/</guid><description>リクエストごとにヘッダを設定する (Request) urllib.request.Request オブジェクトの add_header メソッドや、headers プロパティを使用すると、HTTP リクエスト時のヘッダ情報を設定することができます。 あとは、urllib.request.urlopen で HTTP リクエストを送信するとき、URL の代わりに Request オブジェクトを渡せば、ヘッダ付きのリクエストを送ることができます。
import urllib.request def create_request(): req = urllib.request.Request(&amp;#39;https://example.com/myapi&amp;#39;) req.add_header(&amp;#39;Referer&amp;#39;, &amp;#39;http://www.python.org/&amp;#39;) req.add_header(&amp;#39;User-Agent&amp;#39;, &amp;#39;Mozilla/5.0&amp;#39;) return req if __name__ == &amp;#39;__main__&amp;#39;: req = create_request() with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) 上記の例では、Request#add_header() メソッドを使って、ヘッダ情報を 1 つずつ付加しています。 Request#headers プロパティを使用すれば、複数のヘッダ情報をディクショナリ形式でまとめて設定することができます。
req.headers = { &amp;#39;Referer&amp;#39;: &amp;#39;http://www.python.org/&amp;#39;, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0&amp;#39;, } すべてのリクエストに共通のヘッダを設定する (OpenerDirector) Request オブジェクトは URL まで含んでいるため、アクセス先の URL が変わるたびに生成しなおす必要があります。 一方、OpenerDirector を使用すると、リクエスト時のヘッダ情報などはそのままで、URL だけを変更してアクセスすることができます。
import urllib.request def create_opener(): opener = urllib.</description></item><item><title>Python の実行環境を切り替えて使用する (virtualenv) Python3.2まで</title><link>https://maku77.github.io/p/yqjs3aw/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yqjs3aw/</guid><description>virtualenv コマンドを使用すると、仮想的な Python の実行環境を作成することができます。 （追記）Python 3.3 以降は、virtualenv と同様の機能を提供する venv モジュールが標準搭載されたので、そちらを使うようにしましょう。
Python の実行環境を切り替えて使用する (venv) virtualenv とは Virtualenv Python 製のツールを使おうとすると、使用可能な Python のバージョンが制限されていたり、依存する Python パッケージを pip コマンドでたくさんインストールしなければいけなかったりします。 こういったツールを実行するために、パッケージをどんどんインストールしていくと、PC 内の Python 環境がぐちゃぐちゃになってしまいます（システムの site-packages ディレクトリに大量のパッケージがインストールされて管理できなくなる）。
そこで便利なのが、独立した Python 環境を作成することができる virtualenv コマンドです。 virtualenv で作成した仮想環境の中では、特定のバージョンの Python を使用することができ、閉じた環境内に Python パッケージをインストール (pip install) することができます。 もし、その環境が必要なくなったら、仮想環境ごと削除してしまえば、PC 内のグローバルな Python 実行環境はクリーンなままです。
例えば、何らかの Python 製ツール app があったとして、そのツールを使用するにはいくつかの Python パッケージをインストールしなければならないとします。 virtualenv を使用して、その Python 製ツールを使用するための環境を作る流れは以下のようになります。
app ディレクトリに移動する (cd app) app 用の Python 仮想環境を作成する (virtualenv 環境名) 仮想環境に入る (source 環境名/bin/activate) app に必要な Python パッケージをインストールする (pip install XXX) app を使う (python app.</description></item><item><title>Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve)</title><link>https://maku77.github.io/p/5zj72ei/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5zj72ei/</guid><description>urllib.request によるファイルのダウンロード urllib.request.urlretrieve を使用すると、簡単に Web 上のファイルをダウンロードしてローカルファイルとして保存することができます。
urllib.request.urlretrieve 関数 下記の download_file 関数は、指定した URL のファイルをカレントディレクトリにダウンロードします。
import urllib.request import os.path def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; urllib.request.urlretrieve(url, filename) if __name__ == &amp;#39;__main__&amp;#39;: download_file(&amp;#39;https://example.com/&amp;#39;) ローカルに作成されるファイル名は、os.path.basename を使用して、URL の末尾から切り出しています。 URL の末尾にファイル名らしきものが見つからない場合は、デフォルトファイル名として index.html で保存するようにしています。
テンポラリファイルとしてダウンロードする urllib.request.urlretrieve の 2 番目のパラメータ (filename) を省略すると、テンポラリディレクトリに適当なファイル名で保存されます。 このファイルパスは、戻り値で返されるタプルの先頭に格納されています。
path, headers = urllib.request.urlretrieve(&amp;#39;http://example.com/sample.png&amp;#39;) print(path) #=&amp;gt; c:\users\maku\appdata\local\temp\tmpgujizj urlretrieve により作成された一時ファイルを確実に削除するには、下記のように後始末しておきます。
urllib.request.urlcleanup() このファイルはテンポラリディレクトリに作成されるファイルなので、それほど厳密に削除する必要はないかと思いますが、大量のテンポラリファイルが作られるような場合は実行しておいた方がよいでしょう。
ダウンロード時の HTTP レスポンスヘッダの取得 urllib.request.urlretrieve により、ファイルをダウンロードした際に、ついでに HTTP レスポンスヘッダを取得したい場合 は、下記のように 戻り値のタプルの 2 番目の要素 から取得できます。
path, headers = urllib.</description></item><item><title>Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler)</title><link>https://maku77.github.io/p/4yiygwe/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4yiygwe/</guid><description>urllib.request モジュールを使って Basic 認証の設定された Web サイトにアクセスすると、デフォルトでは下記のようなエラーが発生します。
Basic 認証エラー urllib.error.HTTPError: HTTP Error 401: Authorization Required HTTPBasicAuthHandler を使用すると、各 Web サイトにアクセスするときのユーザ名と、パスワード情報を設定することができます。 具体的には、Basic 認証のかかった Web サイトにアクセスした場合に Web サーバから返される realm 情報 と、ベースとなる URI 情報 に対して、使用するユーザ名とパスワードを関連付けます。
下記のサンプルでは、http://example.com/secret/ 以下にアクセスする際に、Basic 認証のユーザ名、パスワードとして、user1、pass1 を利用するように設定しています。 ここでは、realm 情報は無視し、URI 情報だけに関連付けるようにするため、HTTPPassswordMgrWithDefaultRealm を使用しています。
Basic 認証の付いたサイトにアクセスする import urllib.request import os.path def setup_basic_auth(base_uri, user, password): password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password( realm=None, uri=base_uri, user=user, passwd=password) auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr) opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; print(&amp;#39;Downloading .</description></item><item><title>Python の requests パッケージによる HTTP リクエスト</title><link>https://maku77.github.io/p/r7q8q7o/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r7q8q7o/</guid><description>requests パッケージのインストール オープンソースの requests パッケージ を使用すると、Python 3 標準の urllib.request よりも簡単に HTTP リクエストを扱うことができます。 例えば、以下のような処理をシンプルなコードで扱うことができます。
Basic 認証、ダイジェスト認証 ファイルのアップロード クッキー SSL 検証 エンコーディング形式の自動判別 コンテンンツが圧縮されていた場合の自動展開 requests パッケージは、pip コマンドで簡単にインストールできます。
request パッケージのインストール $ pip install requests requests モジュールによる HTTP GET リクエスト requests.get 関数を使うと、HTTP GET リクエストでインターネット上のコンテンツをダウンロードすることができます。 requests.get は、戻り値として requests.models.Response オブジェクトを返します。
Web コンテンツのダウンロード import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) type(res) #=&amp;gt; &amp;lt;class &amp;#39;requests.models.Response&amp;#39;&amp;gt; Response オブジェクトから、ステータスコードや、取得したコンテンツの内容を取得することができます。
requests.get のレスポンスを詳しく見る import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) print(res.status_code) #=&amp;gt; 200 print(res.status_code == requests.codes.ok) #=&amp;gt; True print(res.</description></item><item><title>Python で HTTP を扱う方法いろいろ</title><link>https://maku77.github.io/p/k5p4axo/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k5p4axo/</guid><description>Python3 の標準 HTTP ライブラリ Python3 には HTTP を扱う、下記のような標準ライブラリが用意されています。
http.client
HTTP (RFC 2616) を実装する 低レベルライブラリ。 urllib.request
上記を利用した 高レベルライブラリ。認証やリダイレクトをサポートしています。 オープンソースの HTTP ライブラリ Python に標準で付属している urllib.request パッケージは、比較的低レベルな処理を行うように設計されているため、手っ取り早く HTTP リクエストでデータを取得したい場合は、オープンソースの requests パッケージ を使うとよいでしょう。 requests パッケージは、Python の公式サイトでも推奨されています。
requests パッケージ</description></item><item><title>Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen)</title><link>https://maku77.github.io/p/o2e43ct/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o2e43ct/</guid><description>ここでは、Python の組み込みモジュールである urllib.request を使った HTTP アクセスの例を示します。
urlopen による GET/POST リクエストの基本 urllib.request.urlopen 関数は、http.client.HTTPResponse オブジェクトを返します。 HTTPResponse オブジェクトの read メソッドを呼ぶことで、HTTP レスポンスを取得することができます。
https://example.com のコンテンツ (HTML) を取得する from urllib.request import urlopen with urlopen(&amp;#39;https://example.com/&amp;#39;) as res: text = res.read().decode(&amp;#39;utf-8&amp;#39;) print(text) read メソッドが返すデータはバイナリデータ (bytes) なので、テキストとして扱う場合は、エンコーディング形式（utf-8 など）を指定してデコードする必要があります。
urlopen 関数で取得した HTTPResponse オブジェクトは、リソース解放のために明示的に close() することが推奨されているのですが、上記のように Python 3 の with 文を使用すると、close() 処理を自動化できます。
urlopen の引数に、URL 文字列ではなく、urllib.request.Request オブジェクトを渡すこともできます。 Request オブジェクトを使うと、HTTP ヘッダー情報やプロキシ、HTTP メソッド（GET や POST）の指定などを行えます。
HTTP ヘッダーやプロキシを指定したリクエスト import urllib.request URL = &amp;#39;http://example.com/&amp;#39; req = urllib.</description></item><item><title>Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする</title><link>https://maku77.github.io/p/ogq5hdy/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ogq5hdy/</guid><description>urllib.request を使用した HTTP アクセスは、デフォルトでシステムに設定されたプロキシ設定（http_proxy、https_proxy、ftp_proxy 環境変数など）でアクセスが行われます。 これらのプロキシ設定をそのまま使用してもよいし、Python のコード内で明示的にプロキシを設定することもできます。
現在のプロキシ設定を確認する (getproxies) 現在、システムにどのようなプロキシ設定が反映されているかを調べるには、urllib.request.getproxies 関数を使用します。
import urllib.request print(urllib.request.getproxies()) 実行結果 {&amp;#39;http&amp;#39;: &amp;#39;http://proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;: &amp;#39;https://proxy.example.com:8080&amp;#39;, &amp;#39;ftp&amp;#39;: &amp;#39;ftp://proxy.example.com:8080&amp;#39;} リクエストごとにプロキシを設定する (Request) HTTP リクエストごとに使用するプロキシを明示的に指定したい場合は、Request オブジェクトを作成し、set_proxy メソッドでプロキシを指定します。 あとは、その Request オブジェクトを urllib.request.urlopen() に渡して HTTP リクエストを送信します。
リクエスト単位でのプロキシ設定 import urllib.request req = urllib.request.Request(&amp;#39;https://example.com/&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;http&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;) with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) Request#set_proxy() でプロキシサーバーを指定するときは、http:// や https:// といったスキーム名は省略することに注意してください。 スキーム名を記述してしまうと、プロキシがうまく認識されず、次のような DNS エラーになったりします。
urlopen error [Errno 11001] getaddrinfo failed Request オブジェクトは生成時に URL を指定する必要があるため、アクセス先が変わるごとに生成する必要があることに注意してください。</description></item><item><title>Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer)</title><link>https://maku77.github.io/p/rr3cmu5/</link><pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rr3cmu5/</guid><description>Python がインストールされた環境であれば、コマンドラインから下記のように実行することで簡易 HTTP サーバを立てることができます。
（Python3 の場合）ポート 8000 で HTTP サーバーを起動 $ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... （Python2 の場合）ポート 8000 で HTTP サーバーを起動 $ python -m SimpleHTTPServer 8000 Serving HTTP on 0.0.0.0 port 8000 ... これで、http://localhost:8000/ にアクセスすれば、カレントディレクトリ内のファイルの一覧が表示されます。 開発環境での HTTP 開通テストや、LAN 内の一時的なファイル共有サーバとして使用することができます。</description></item></channel></rss>