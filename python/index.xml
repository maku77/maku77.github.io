<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 天才まくまくノート</title><link>https://maku77.github.io/python/</link><description>Recent content in Python on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 29 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python の import 時のモジュールの検索パスを調べる (sys.path)</title><link>https://maku77.github.io/p/o4m4jyg/</link><pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o4m4jyg/</guid><description>モジュールの検索パスのリストは sys.path Python でモジュールをインポートするには、import モジュール名 のように記述しますが、このときにどのディレクトリのモジュールが検索されるかは、sys.path 変数の値を見ると分かります。 sys.path は検索パスを示す文字列のリスト (list[str]) です。
モジュールの検索パスを列挙する import sys import pprint pprint.pprint(sys.path) 実行結果 [&amp;#39;/Users/maku/myapp&amp;#39;, &amp;#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python310.zip&amp;#39;, &amp;#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10&amp;#39;, &amp;#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload&amp;#39;, &amp;#39;/Users/maku/myapp/.venv/lib/python3.10/site-packages&amp;#39;] sys.path にはどのような検索パスが含まれているか？ sys.path 変数には、自動的に次のようなパスが登録されます。
起動したスクリプトと同じディレクトリ（ただし、python をインタラクティブモードで起動したときは、カレントディレクトリを示す空文字 '' になります） 環境変数 PYTHONPATH に指定したディレクトリ Python インストーラに応じたデフォルトディレクトリ（標準ライブラリのパスなど） 注目すべきは、sys.path の先頭に追加されるパスで、これは起動されたスクリプトが格納されているディレクトリのパスになっています。 例えば、python ~/myapp/main.py と実行したときは、自動的に ~/myapp が検索パスに追加されるため、~/myapp 以下に配置したモジュール (*.py) をインポートできるようになっています。
main.py import mymod # ~/myapp/mymod.py が検索される モジュールの検索パスを追加する PYTHONPATH 環境変数を設定する方法 PYTHONPATH 環境変数に設定したディレクトリパスは、自動的に sys.path に反映されてモジュールの検索パスとして使われます。
Linux や macOS の場合 $ export PYTHONPATH=/path/to/lib1:/path/to/lib2:$PYTHONPATH パスの区切り文字は Linux や macOS ではコロン (:) ですが、Windows の場合はセミコロン (;) になることに注意してください（PATH 環境変数の指定方法と同じです）。</description></item><item><title>HTML ファイルや Markdown ファイルをプレーンテキストに変換する (unstructured)</title><link>https://maku77.github.io/p/uivwecs/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uivwecs/</guid><description>unstructured ライブラリとは Python の unstructured ライブラリは、様々な形式のデータを機械学習システムに投入する前の変換処理などを行ってくれるライブラリです。 例えば、非構造化データ（HTML や Markdown）には、機械学習には必要のないタグが含まれていたりしますが、unstructured を使ってテキストだけを取り出すことができます。
Unstructured-IO/unstructured: Open source libraries and APIs to build custom preprocessing pipelines for labeling, training, or production machine learning pipelines. 現在、ChatGPT などの大規模言語モデル (LLM) を利用したチャットシステムが注目を浴びていますが、社内ドキュメントなどの情報と統合するためには、ユーザー入力から類似ドキュメントを検索する仕組みが必要になります。 このために使用されるのが、テキスト間の類似度に基づいた検索システムであるベクトル検索 DB などです。 そこに登録するドキュメントのベクトルデータ（Embeddings）は、できるだけクリーンなテキストから生成することが望ましいのですが、unstructured ライブラリを使えば、様々な形式のデータからそういったテキストを作成できます。
unstructured ライブラリのインストール unstructured の Installation マニュアル に従って、必要なライブラリをインストールします。
unstructured ライブラリのインストール $ pip install unstructured 後述のプログラムを実行したときに、tabulate が足りないと言われたので入れました。 このあたりは試行錯誤です。
$ pip install tabulate HTML ファイルをプレーンテキストに変換してみる サンプルの入力ファイルとして、次のような HTML ファイルを用意します。 html や body タグを省略していますが、これも正しい HTML5 文書です。
input.html（入力ファイル） &amp;lt;!</description></item><item><title>Python で URL 文字列を各パートに分割する (urllib.parse.urlparse)</title><link>https://maku77.github.io/p/rr2ahpx/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rr2ahpx/</guid><description>Python の標準ライブラリの urllib.parse.urlparse 関数を使用すると、URL 形式の文字列から ParseResult オブジェクトを生成することができます。 ParseResult オブジェクトの各プロパティを参照することで、URL の各パート（スキーム、ドメイン、パス、クエリ文字列など）を取り出すことができます。
sample.py（URL 文字列を解析する） from urllib.parse import urlparse url = &amp;#34;https://example.com/p/abcdefg/?foo=1&amp;amp;bar=2#top&amp;#34; parsed_url = urlparse(url) # ParseResult オブジェクトを生成する print(parsed_url.scheme) # =&amp;gt; https print(parsed_url.netloc) # =&amp;gt; example.com print(parsed_url.path) # =&amp;gt; /p/abcdefg/ print(parsed_url.query) # =&amp;gt; foo=1&amp;amp;bar=2 print(parsed_url.fragment) # =&amp;gt; top</description></item><item><title>Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する</title><link>https://maku77.github.io/p/bp9q8p6/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bp9q8p6/</guid><description>サイトマップとは？ Web サイトのサイトマップファイル (sitemap.xml) には、次のような形で全ページの URL 情報が記載されています。 このファイルは、主に Google などの検索エンジンのために提供されています。
sitemap.xml &amp;lt;urlset xmlns=&amp;#34;http://www.sitemaps.org/schemas/sitemap/0.9&amp;#34; xmlns:xhtml=&amp;#34;http://www.w3.org/1999/xhtml&amp;#34;&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page1/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2021-01-01&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page2/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-02-02&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page3/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2023-03-03&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;/urlset&amp;gt; sitemap.xml から URL の一覧を取得する 次の Python スクリプトは、上記のような sitemap.xml ファイルから、すべての URL 情報を抽出します。 sitemap.xml ファイル自体のダウンロードには urlopen を使用し、XML のパースには ElementTree を使用しています。
extract-urls.py from urllib.request import urlopen from xml.etree import ElementTree url = &amp;#34;https://example.com/sitemap.xml&amp;#34; def fetch(url: str) -&amp;gt; str: &amp;#34;&amp;#34;&amp;#34;指定した URL のリソースを文字列で取得します。&amp;#34;&amp;#34;&amp;#34; with urlopen(url) as res: return res.</description></item><item><title>Python の dictionary の内部的な要素順序を変更する (dict, OrderedDictionary)</title><link>https://maku77.github.io/p/vexfweu/</link><pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vexfweu/</guid><description>dict が保持する要素の順序 Python の辞書オブジェクト (dict) は要素の追加順序を保持しており、要素のイテレート時や print での出力時はこの順序で出力されるようになっています（Python 3.7 以降）。
sample.py book = { &amp;#39;id&amp;#39;: &amp;#39;123&amp;#39;, &amp;#39;authors&amp;#39;: [&amp;#39;Author 1&amp;#39;], &amp;#39;title&amp;#39;: &amp;#39;Title 1&amp;#39; } print(book) 出力結果 {&amp;#39;id&amp;#39;: &amp;#39;123&amp;#39;, &amp;#39;authors&amp;#39;: [&amp;#39;Author 1&amp;#39;], &amp;#39;title&amp;#39;: &amp;#39;Title 1&amp;#39;} 単純にキー名のアルファベット順にループ処理したい場合は、例えば次のようにします。
キーのリストをソート for key in sorted(book.keys()): print(&amp;#39;%s: %s&amp;#39; % (key, book[key])) でもこれは、出力時に一時的なキーリストをソートしているだけで、辞書オブジェクト内部の要素順序を制御しているわけではありません。 次のようにすれば、あるキーの要素を辞書オブジェクト内で末尾に持ってくることができます。
book[&amp;#39;id&amp;#39;] = book.pop(&amp;#39;id&amp;#39;) 単純に id キーの要素を取り出して、再度辞書オブジェクトに追加しているだけです (^^;
この後、print(book) とすると、id 要素が最後に出力されます。 もっといい方法があるかもしれませんが、この仕組みだけである程度柔軟な並び替えが可能です。 例えば、次の sort_dict 関数は、辞書オブジェクト内部の要素をキー名順に並び替える関数ですが、priority_keys 引数でキー名のリストを渡すと、それらのキーは優先的にその順番で先頭に並べられます。
sort_dict 関数の実装例 def sort_dict(d, priority_keys=()): &amp;#34;&amp;#34;&amp;#34; 辞書オブジェクト d の要素を内部的にキー名でソートします。 ただし、priority_keys にキー名のリストが指定されたときは、 そのキーを優先的に先頭に並べます。 &amp;#34;&amp;#34;&amp;#34; keys1 = list(filter(lambda k: k in d, priority_keys)) keys2 = sorted(d.</description></item><item><title>Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する</title><link>https://maku77.github.io/p/wewevcs/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wewevcs/</guid><description>urllib.request.urlopen() が返した HTTPResponse オブジェクトの info() メソッドを呼び出すと、HTTP レスポンスのヘッダ情報を取得することができます。 ヘッダ情報は HTTPMessage オブジェクト として返されますが、これは通常の辞書オブジェクトと同様に使用することができます。 詳しくは、HTTPMessage の親クラスである email.message.Message の定義を参照してください。
次の例では、Web サイトにアクセスしたときの HTTP レスポンスヘッダーを取得して表示しています。
sample.py import urllib.request url = &amp;#39;https://yahoo.co.jp/&amp;#39; try: with urllib.request.urlopen(url) as res: # HTTP レスポンスのヘッダ情報を取得 headers = res.info() print(type(headers)) #=&amp;gt; http.client.HTTPMessage print() print(headers) # 下記は Body 部分の取得 # text = res.read().decode(&amp;#39;utf-8&amp;#39;) # print(text) except urllib.error.URLError as err: print(&amp;#39;Could not access: %s&amp;#39; % url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) 実行結果 &amp;lt;class &amp;#39;http.client.HTTPMessage&amp;#39;&amp;gt; Cache-Control: private, no-cache, no-store, must-revalidate Content-Type: text/html; charset=UTF-8 Date: Mon, 01 Jun 2020 06:07:42 GMT Expires: -1 Pragma: no-cache Set-Cookie: B=1sg6o4tfd96pe&amp;amp;b=3&amp;amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.</description></item><item><title>Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode)</title><link>https://maku77.github.io/p/w7p7n4j/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w7p7n4j/</guid><description>Python の標準モジュールとして提供されている urllib.parse を使用すると、任意の文字列を URL 内で扱えるようにエンコード／デコードすることができます。 ユーザーが入力したテキストや、日本語を含むテキストをエスケープ処理して URL として扱いたいときに使用できます。
文字列を URL エンコードする (quote) 任意の文字列を URL として扱いたいときは、urllib.parse.quote 関数 を使うと、エスケープすべき文字を %xx という形に変換してくれます。
from urllib.parse import quote print(quote(&amp;#39;あ&amp;#39;)) #=&amp;gt; &amp;#39;%E3%81%82&amp;#39; print(quote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(quote(&amp;#39;A B C&amp;#39;)) #=&amp;gt; &amp;#39;A%20B%20C&amp;#39; print(quote(&amp;#39;A/B/C&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; 上記の結果からわかるように、quote 関数はデフォルトではスラッシュ (/) をエスケープしません。 これは、変換しない文字を示すオプションパラメータ safe のデフォルト値が '/' になっているからです。 次のようにすると、スラッシュが %2F にエスケープされるようになります。
print(quote(&amp;#39;A/B/C&amp;#39;, safe=&amp;#39;&amp;#39;)) #=&amp;gt; &amp;#39;A%2FB%2FC&amp;#39; URL の特定階層のパス名をユーザーに入力させるようなケースで使用できます。
URL をデコードする (unquote) 逆に、URL エンコードされた文字列をデコードして元に戻すには、urllib.parse.unquote 関数 を使用します。
from urllib.parse import unquote print(unquote(&amp;#39;%E3%81%82&amp;#39;)) #=&amp;gt; &amp;#39;あ&amp;#39; print(unquote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(unquote(&amp;#39;A%20B%20C&amp;#39;)) #=&amp;gt; &amp;#39;A B C&amp;#39; print(unquote(&amp;#39;A%2FB%2FC&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; クエリ文字列を作成する (urlencode) HTTP の GET リクエストを送るときに、URL の末尾に次のようにクエリ文字列を付加したいことがあります。</description></item><item><title>.env ファイルで環境変数を設定する (python-dotenv)</title><link>https://maku77.github.io/p/gzo8d7y/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gzo8d7y/</guid><description>python-dotenv モジュールの概要 python-dotenv モジュール を使用すると、Python プログラム実行時に下記のようなファイルを読み込んで、環境変数を設定することができます。
.env MYAPP_USER=maku MYAPP_PASS=makupass MYAPP_CONFIG=${HOME}/${MYAPP_USER}/config 上記の例のように、${HOME} という形で環境変数の値を展開することもできます。
特定のプログラムを実行するために、いちいち OS の環境変数を設定するのを嫌がるユーザーはたくさんいます。 あなたのプログラムが何らかの環境変数を必要としているのであれば、.env ファイルによる設定手段も提供しておくと親切です。 .env の仕組みは Python に限ったものではなく、いろいろな言語で採用されています。
参考: Node.js プログラムで .env ファイルを使用する python-dotenv モジュールのインストール python-dotenv モジュールは pip コマンドでインストールできます。
$ python3 -m pip install python-dotenv システム全体の Python 実行環境を汚したくない場合は、次のように 仮想環境を作成してインストール しましょう。
$ python3 -m venv ~/venv $ source ~/venv/bin/activate (venv) $ python3 -m pip install python-dotenv 仮想環境は次のように抜けられます。
(venv) $ deactivate python-dotenv の使い方 .env ファイルの内容を環境変数に反映する .env ファイルを読み込むのはとても簡単で、load_dotenv() を呼び出すだけです。 次の Python スクリプトでは、同じディレクトリ（あるいは、より上位のディレクトリ）に置かれた .</description></item><item><title>Python の実行環境を切り替えて使用する (venv) Python3.3以降</title><link>https://maku77.github.io/p/wozpogm/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wozpogm/</guid><description>venv モジュールは、Python の仮想実行環境を作成するための標準モジュールです。 Python 3.2 までは virtualenv という外部パッケージを使用していましたが、Python 3.3 以降は標準で同等機能を提供する venv パッケージ を使用できます。
なぜ仮想環境が必要か？ Python で作成されたプログラムは、pip install で外部モジュールをインストールすることを前提に作成されたものがたくさんあります。 Python プログラムを実行するために、何も考えずに pip install を繰り返していると、いろいろなバージョンのモジュールがインストールされてしまい、実行環境がぐちゃぐちゃになってしまいます。 あるプログラムを動作させるために pip install すると、別のプログラムが動作しなくなるといったことが起こります。
venv を使って仮想環境を作ると、その環境内に閉じて pip install することができるようになります。 例えば、app1 と app2 という 2 つの Python プログラム用に別々の仮想環境を作って、それぞれのプログラムに必要なパッケージをインストールするということができます。
（注意）以下、python3 というコマンドを使っていますが、これはバージョン 3 以降の Python を使用することを示しています。 環境によっては、python に置き換えて読んでください（Windows の場合は py だったりします）。
プロジェクト用の仮想環境を作成する／削除する 仮想環境を作成する 仮想環境を作成するには、次のようなコマンドを実行します。 仮想環境はディレクトリの形で作成され、その中に必要なファイルが自動生成されます。
仮想環境の作成 $ python3 -m venv &amp;lt;仮想環境ディレクトリ&amp;gt; プロジェクトごとに仮想環境を作成するのであれば、プロジェクトのルートに仮想環境ディレクトリを作成するのがよいでしょう。 例えば、myapp プロジェクト用の仮想環境を作るには次ようにします（仮想環境ディレクトリ名を .venv としています）。
$ mkdir ~/myapp $ cd ~/myapp $ python3 -m venv .</description></item><item><title>Python でドキュメンテーションコメント (docstring) を記述する</title><link>https://maku77.github.io/p/y2biqz7/</link><pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y2biqz7/</guid><description>Docstring とは？ Python のコードに docstring フォーマットでコメントを記述しておくと、いろいろなツールから API ドキュメントとして参照できるようになります。 例えば、Python 用の統合開発環境 (IDE) におけるコード補完時に、ヒントとして関数の使用方法が表示されます。
下記は PEP 257 &amp;ndash; Docstring Conventions に記述されている docstring の書き方の例です。
def complex(real=0.0, imag=0.0): &amp;#34;&amp;#34;&amp;#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) &amp;#34;&amp;#34;&amp;#34; if imag == 0.0 and real == 0.0: return complex_zero ... docstring はこのように 3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲んで記述します。 docstring コメントは関数の内部に記述する ところがポイントです。 このあたりは、関数の外側にドキュメンテーションコメントを記述する Java や C# などとは異なっています。</description></item><item><title>Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする</title><link>https://maku77.github.io/p/i4zkqye/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i4zkqye/</guid><description>リクエストごとにヘッダを設定する (Request) urllib.request.Request オブジェクトの add_header メソッドや、headers プロパティを使用すると、HTTP リクエスト時のヘッダ情報を設定することができます。 あとは、urllib.request.urlopen で HTTP リクエストを送信するとき、URL の代わりに Request オブジェクトを渡せば、ヘッダ付きのリクエストを送ることができます。
import urllib.request def create_request(): req = urllib.request.Request(&amp;#39;https://example.com/myapi&amp;#39;) req.add_header(&amp;#39;Referer&amp;#39;, &amp;#39;http://www.python.org/&amp;#39;) req.add_header(&amp;#39;User-Agent&amp;#39;, &amp;#39;Mozilla/5.0&amp;#39;) return req if __name__ == &amp;#39;__main__&amp;#39;: req = create_request() with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) 上記の例では、Request#add_header() メソッドを使って、ヘッダ情報を 1 つずつ付加しています。 Request#headers プロパティを使用すれば、複数のヘッダ情報をディクショナリ形式でまとめて設定することができます。
req.headers = { &amp;#39;Referer&amp;#39;: &amp;#39;http://www.python.org/&amp;#39;, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0&amp;#39;, } すべてのリクエストに共通のヘッダを設定する (OpenerDirector) Request オブジェクトは URL まで含んでいるため、アクセス先の URL が変わるたびに生成しなおす必要があります。 一方、OpenerDirector を使用すると、リクエスト時のヘッダ情報などはそのままで、URL だけを変更してアクセスすることができます。
import urllib.request def create_opener(): opener = urllib.</description></item><item><title>Python の実行環境を切り替えて使用する (virtualenv) Python3.2まで</title><link>https://maku77.github.io/p/yqjs3aw/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yqjs3aw/</guid><description>virtualenv コマンドを使用すると、仮想的な Python の実行環境を作成することができます。 （追記）Python 3.3 以降は、virtualenv と同様の機能を提供する venv モジュールが標準搭載されたので、そちらを使うようにしましょう。
Python の実行環境を切り替えて使用する (venv) virtualenv とは Virtualenv Python 製のツールを使おうとすると、使用可能な Python のバージョンが制限されていたり、依存する Python パッケージを pip コマンドでたくさんインストールしなければいけなかったりします。 こういったツールを実行するために、パッケージをどんどんインストールしていくと、PC 内の Python 環境がぐちゃぐちゃになってしまいます（システムの site-packages ディレクトリに大量のパッケージがインストールされて管理できなくなる）。
そこで便利なのが、独立した Python 環境を作成することができる virtualenv コマンドです。 virtualenv で作成した仮想環境の中では、特定のバージョンの Python を使用することができ、閉じた環境内に Python パッケージをインストール (pip install) することができます。 もし、その環境が必要なくなったら、仮想環境ごと削除してしまえば、PC 内のグローバルな Python 実行環境はクリーンなままです。
例えば、何らかの Python 製ツール app があったとして、そのツールを使用するにはいくつかの Python パッケージをインストールしなければならないとします。 virtualenv を使用して、その Python 製ツールを使用するための環境を作る流れは以下のようになります。
app ディレクトリに移動する (cd app) app 用の Python 仮想環境を作成する (virtualenv 環境名) 仮想環境に入る (source 環境名/bin/activate) app に必要な Python パッケージをインストールする (pip install XXX) app を使う (python app.</description></item><item><title>Python で連番からなる NumPy 配列を作成する (numpy.arange)</title><link>https://maku77.github.io/p/htducs9/</link><pubDate>Mon, 27 Feb 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/htducs9/</guid><description>numpy.arange 関数を使用して、連番からなる NumPy 配列 (ndarray) を生成することができます。 開始番号 (start) や、1 ステップあたりの変化数 (step) を指定することもできます。
連番の ndarray を生成する &amp;gt;&amp;gt;&amp;gt; import numpy as np &amp;gt;&amp;gt;&amp;gt; np.arange(5) array([0, 1, 2, 3, 4]) &amp;gt;&amp;gt;&amp;gt; np.arange(3, 10) array([3, 4, 5, 6, 7, 8, 9]) &amp;gt;&amp;gt;&amp;gt; np.arange(2, 10, 2) array([2, 4, 6, 8]) &amp;gt;&amp;gt;&amp;gt; np.arange(10, 0, -1) array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 関数名は arrange ではなく、arange であることに注意してください（array range の略です）。</description></item><item><title>Python の Pandas でラベル付き 1 次元データを扱う (pandas.Series)</title><link>https://maku77.github.io/p/wbudtbr/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wbudtbr/</guid><description>Python の pandas ライブラリは、データ操作および分析を容易にするためのデータ型および関数群を提供します。 pandas ライブラリの内部では、NumPy ライブラリの多次元配列 (ndarray) や数値演算関数が使用されています。
pandas.Series はラベル付き 1 次元配列 pandas.Series は、1 次元の NumPy 配列 (ndarray) に、インデックス用のラベルを付加したデータ型です。 通常の配列データは 0、1、2 というインデックスで各要素にアクセスしますが、pandas.Series では各インデックスに意味のあるラベルを付けることができます。
pandas.Series を生成する pandas.Series コンストラクタで、次のように初期データだけを指定すると、通常の配列と同様にインデックスとして 0、1、2 が割り振られます。
sample.py import pandas as pd s = pd.Series([100, 200, 300]) print(s) 実行結果 0 100 1 200 2 300 dtype: int64 各インデックスにラベルを設定する pandas.Series コンストラクタで index パラメータを追加指定すると、明示的に各インデックスのラベルを設定することができます。
import pandas as pd s = pd.Series([100, 200, 300], index=[&amp;#39;aaa&amp;#39;, &amp;#39;bbb&amp;#39;, &amp;#39;ccc&amp;#39;]) print(s) 実行結果 aaa 100 bbb 200 ccc 300 dtype: int64</description></item><item><title>Python の pandas でラベル付き 2 次元データを扱う (pandas.DataFrame)</title><link>https://maku77.github.io/p/watbs9p/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/watbs9p/</guid><description>pandas.DataFrame はラベル付き 2 次元配列 Python の pandas ライブラリが提供する pandas.DataFrame 型は、テーブル形状のデータを表す 2 次元データ型です。 内部では NumPy ライブラリの ndarray が利用されていますが、pandas.DataFrame を使うと、X 軸（列）、Y 軸（行）の各インデックスに任意のラベルを付けることができます （1 次元データを表現する pandas.Series 型も用意されています）。 この pandas.DataFrame 型は、pandas によるデータ解析の要となるデータ形式です。
pandas.DataFrame を生成する pandas.DataFrame コンストラクタで、次のように初期値となる 2 次元データだけを渡すと、X 軸と Y 軸のラベルとして、0、1、2 という連番が割り振られます。 pandas.DataFrame オブジェクトを print 関数に渡すと、見やすい形で出力してくれます。
sample.py import pandas as pd data = [[100, 200, 300], [400, 500, 600], [700, 800, 900]] df = pd.DataFrame(data) print(df) 実行結果 0 1 2 0 100 200 300 1 400 500 600 2 700 800 900 各インデックスにラベルを設定する pandas.</description></item><item><title>Python の pandas.DataFrame から部分データを抽出する</title><link>https://maku77.github.io/p/8j4k3iy/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8j4k3iy/</guid><description>Python の pandas ライブラリが提供する pandas.DataFrame はテーブル形式データを保持していますが、ここから部分的なデータを抽出する方法がたくさん用意されています。
サンプルデータ 最初に、後述の説明のためにサンプルデータを用意しておきます。 次のコードでは、10 行 3 列のデータを持つ pandas.DataFrame を生成しています。
import numpy as np import pandas as pd data = np.random.randn(10, 3) # 10 行 3 列の乱数データ (numpy.ndarray) を生成 indices = pd.date_range(&amp;#34;2010-01-01&amp;#34;, periods=10) # 日付の連番からなるインデックスを生成 columns = (&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;) # カラム名 my_dataframe = pd.DataFrame(data, index=indices, columns=columns) print(my_dataframe) 実行結果 A B C 2010-01-01 -1.083348 0.780602 -1.249351 2010-01-02 -0.421893 1.417954 2.196932 2010-01-03 -1.129684 -0.751984 0.920735 2010-01-04 -0.668949 -2.</description></item><item><title>Python の NumPy 配列 (ndarray) で行列を扱う</title><link>https://maku77.github.io/p/jwfxfvd/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jwfxfvd/</guid><description>NumPy 配列を生成する（numpy.array 関数） NumPy には配列（行列）を高速に扱うための ndarray クラスが用意されています。 ndarray インスタンスは、numpy.array 関数で生成することができます（よく np という別名でインポートするので、np.array と記述されていることが多いです）。 下記の例では、2 行 3 列の行列を表現する ndarray インスタンスを生成しています。
2x3 の ndarray を生成 &amp;gt;&amp;gt;&amp;gt; import numpy as np &amp;gt;&amp;gt;&amp;gt; a = np.array([[1, 2, 3], [4, 5, 6]]) &amp;gt;&amp;gt;&amp;gt; a array([[1, 2, 3], [4, 5, 6]]) &amp;gt;&amp;gt;&amp;gt; type(a) &amp;lt;type &amp;#39;numpy.ndarray&amp;#39;&amp;gt; NumPy 配列の形状（各次元のサイズ）は、shape 属性を参照することで調べることができます。
ndarray の形状を調べる &amp;gt;&amp;gt;&amp;gt; a.shape (2, 3) # 2 行 3 列ということ 行列として扱うには、各行のサイズ（列数）は揃えておく必要があります。 次のように、異なるサイズで初期化してしまうと、リストオブジェクトを要素に持つ一次元の配列として扱われてしまいます。
&amp;gt;&amp;gt;&amp;gt; a = np.array([[1, 2, 3], [4, 5]]) &amp;gt;&amp;gt;&amp;gt; a array([[1, 2, 3], [4, 5]], dtype=object) &amp;gt;&amp;gt;&amp;gt; a.</description></item><item><title>Python でモジュールやパッケージを作成する</title><link>https://maku77.github.io/p/n4n5m3i/</link><pubDate>Fri, 16 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/n4n5m3i/</guid><description>モジュールとパッケージ Python では、再利用可能な関数などを集めたスクリプトファイルのことをモジュールと呼びます。 さらに、同系列のモジュールを集めたものをパッケージと呼びます。
モジュール &amp;hellip; 再利用可能なスクリプト (.py) パッケージ &amp;hellip; 上記のモジュールをディレクトリに集めたもの モジュールやパッケージを作成しておくと、他のファイルから import して使用することができます。
☝️ Node.js も同じ名前 モジュールやパッケージといった名称は、言語によって使われ方が様々ですが、Node.js に関してはほぼ同じ意味で使われています。 Node.js では、.js ファイルのことをモジュール、それらをまとめたものをパッケージと読んでいます。 モジュールを作成する 下記は、簡単な関数（add と sub）を提供する mymath モジュールを定義する例です。 といっても、単純に関数を定義するだけです。 モジュールは、モジュール名.py というファイル名で作成する必要があります。
mymath.py（モジュールの実装例） def add(a, b): &amp;#34;&amp;#34;&amp;#34;Return the sum of a and b.&amp;#34;&amp;#34;&amp;#34; return a + b def sub(a, b): &amp;#34;&amp;#34;&amp;#34;Subtract b from a.&amp;#34;&amp;#34;&amp;#34; return a - b 上記の mymath.py で定義されている関数を使用するには、Python 標準のモジュールと同様に、import mymath という形でインポートします。
main.py（モジュールの使用例） import mymath if __name__ == &amp;#39;__main__&amp;#39;: print(mymath.</description></item><item><title>NumPy / pandas / Matplotlib の概要とインストール</title><link>https://maku77.github.io/p/qs6iv8j/</link><pubDate>Tue, 13 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qs6iv8j/</guid><description>NumPy / pandas / Matplotlib とは NumPy、pandas、Matplotlib などのライブラリは組み合わせて使用することの多いライブラリで、それぞれ下記のような特徴を持っています。
NumPy - 数値計算ライブラリ (numpy.org) C で実装された高速な多次元配列である ndarray（通称 NumPy 配列）、及び関連メソッドを扱うことができます。 Python のみで行列を表現しようとすると、配列の配列（要素ごとに可変長）を作ることになりますが、NumPy 配列ではn x m の固定サイズ、単一タイプのデータとして扱うことで非常に高速な計算処理を行えるようになっています。 pandas &amp;ndash; 数値解析ライブラリ (pandas.pydata.org) R 言語のような数値解析を行うことができるライブラリです。 データファイルの読み込み、加工、集計、可視化までを総合的に行うことができます。 データのプロットには内部で Matplotlib を使用しており、pd.DataFrame.plot() がラッパーとして提供されています。 Matplotlib &amp;ndash; グラフ描画ライブラリ (matplotlib.org) 単独でグラフを描画するために使用できるライブラリですが、pandas による計算結果を描画するために内部で使用されています。 NumPy / pandas / Matplotlib のインストール Python 3.4 以降はパッケージ管理のための pip コマンドが標準で搭載されているので、これを使って NumPy と pandas と Matplotlib をインストールするのがお手軽です。 まずは、pip コマンド自体を最新にアップグレードします。
$ pip install --upgrade pip 引き続き、NumPy と Matplotlib のインストールを行います。
$ pip install numpy $ pip install pandas $ pip install matplotlib これで、import numpy、import pandas、import matplotlib といった感じでインポートできるようになります。</description></item><item><title>Windows で pydoc コマンドを使用できるようにする</title><link>https://maku77.github.io/p/6h2izfh/</link><pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6h2izfh/</guid><description>pydoc コマンドを使用すると、下記のように Python の API ドキュメントを手軽に参照できます。
$ pydoc list.sort Help on method_descriptor in list: list.sort = sort(...) L.sort(key=None, reverse=False) -&amp;gt; None -- stable sort *IN PLACE* Windows では Python をインストールしただけでは pydoc コマンドは使用できませんが、実装自体は Lib/pydoc.py というスクリプトとしてインストールされます。 下記のようなバッチファイルを python.exe と同じディレクトリに作成しておけば、Windows でも pydoc コマンドを使用できるようになります。
pydoc.cmd @python %~dp0\Lib\pydoc.py %* 実行例 C:\&amp;gt; pydoc dict.update Help on method_descriptor in dict: dict.update = update(...) D.update([E, ]**F) -&amp;gt; None. Update D from dict/iterable E and F. If E is present and has a .</description></item><item><title>Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP)</title><link>https://maku77.github.io/p/6k5m4jy/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6k5m4jy/</guid><description>python コマンドを単独で実行したときのインタラクティブシェルは、環境変数 PYTHONSTARTUP に指定したスタートアップ・スクリプトを最初に実行します。 これを利用して、日常的に使用したい関数などを自動的に定義することができます。
例えば、下記の例では、ホームディレクトリにある .pythonstartup スクリプトを読み込むように設定しています。
~/.bash_profile (Linux や Mac OSX の場合） export PYTHONSTARTUP=~/.pythonstartup Windows の場合は、システムのプロパティから環境変数を設定してください（~/ という表記は使用できないので、スタートアップ・スクリプトの位置はフルパスで指定する必要があります）。 コマンドラインから環境変数を設定することもできます。
C:\&amp;gt; setx PYTHONSTARTUP D:/x/myconf/pythonstartup.py （コマンドプロンプトを再起動して反映） 下記のスタートアップ・スクリプトでは、モジュールのソースコードをさくっと確認するための DEV.code 関数を定義しています。DEV.file 関数の方は、指定したモジュールのコードを Vim エディタで開きます。
~/.pythonstartup class DEV: @staticmethod def code(obj): import inspect print(inspect.getsource(obj)) @staticmethod def file(obj): import inspect import os os.system(&amp;#39;gvim &amp;#39; + inspect.getfile(obj)) あとは、Python のインタラクティブシェルを起動すれば、上記の関数が定義された状態で起動します。
$ python ... &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; DEV.code(os.path.split) def split(p): &amp;#34;&amp;#34;&amp;#34;Split a pathname. Return tuple (head, tail) where tail is everything after the final slash.</description></item><item><title>Python の関数やクラスのソースコードを確認する (inspect)</title><link>https://maku77.github.io/p/xbucsaq/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xbucsaq/</guid><description>関数のコードを表示する Python のプログラムを作成しているときに、ある関数のソースコードを確認したくなったときは、inspect モジュールの getsource 関数を使用して簡単に調べることができます。
次の例では、Python の対話型シェル（python3 コマンド）を起動して、os.path.abspath 関数の実装コードを確認しています。
例: os.path.abspath の実装コードを確認する &amp;gt;&amp;gt;&amp;gt; import inspect &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; print(inspect.getsource(os.path.abspath)) def abspath(path): &amp;#34;&amp;#34;&amp;#34;Return an absolute path.&amp;#34;&amp;#34;&amp;#34; path = os.fspath(path) if not isabs(path): if isinstance(path, bytes): cwd = os.getcwdb() else: cwd = os.getcwd() path = join(cwd, path) return normpath(path) （おまけ）シェルスクリプト化しておく 次のようなシェルスクリプト (pycode) を作っておくと、Python の関数の実装コードを簡単に確認できるようになります。 このシェルスクリプトは、PATH の通ったディレクトリに置いて、chmod +x pycode で実行権限を付けておきます。
/Users/maku/bin/pycode #!/bin/bash # # pycode - Python の関数やクラスの実装コードを表示します # # Usage: # $ pycode &amp;lt;モジュール名&amp;gt; &amp;lt;関数名|クラス名&amp;gt; # # 使用例: # $ pycode os path.</description></item><item><title>Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve)</title><link>https://maku77.github.io/p/5zj72ei/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5zj72ei/</guid><description>urllib.request によるファイルのダウンロード urllib.request.urlretrieve を使用すると、簡単に Web 上のファイルをダウンロードしてローカルファイルとして保存することができます。
urllib.request.urlretrieve 関数 下記の download_file 関数は、指定した URL のファイルをカレントディレクトリにダウンロードします。
import urllib.request import os.path def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; urllib.request.urlretrieve(url, filename) if __name__ == &amp;#39;__main__&amp;#39;: download_file(&amp;#39;https://example.com/&amp;#39;) ローカルに作成されるファイル名は、os.path.basename を使用して、URL の末尾から切り出しています。 URL の末尾にファイル名らしきものが見つからない場合は、デフォルトファイル名として index.html で保存するようにしています。
テンポラリファイルとしてダウンロードする urllib.request.urlretrieve の 2 番目のパラメータ (filename) を省略すると、テンポラリディレクトリに適当なファイル名で保存されます。 このファイルパスは、戻り値で返されるタプルの先頭に格納されています。
path, headers = urllib.request.urlretrieve(&amp;#39;http://example.com/sample.png&amp;#39;) print(path) #=&amp;gt; c:\users\maku\appdata\local\temp\tmpgujizj urlretrieve により作成された一時ファイルを確実に削除するには、下記のように後始末しておきます。
urllib.request.urlcleanup() このファイルはテンポラリディレクトリに作成されるファイルなので、それほど厳密に削除する必要はないかと思いますが、大量のテンポラリファイルが作られるような場合は実行しておいた方がよいでしょう。
ダウンロード時の HTTP レスポンスヘッダの取得 urllib.request.urlretrieve により、ファイルをダウンロードした際に、ついでに HTTP レスポンスヘッダを取得したい場合 は、下記のように 戻り値のタプルの 2 番目の要素 から取得できます。
path, headers = urllib.</description></item><item><title>Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler)</title><link>https://maku77.github.io/p/4yiygwe/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4yiygwe/</guid><description>urllib.request モジュールを使って Basic 認証の設定された Web サイトにアクセスすると、デフォルトでは下記のようなエラーが発生します。
Basic 認証エラー urllib.error.HTTPError: HTTP Error 401: Authorization Required HTTPBasicAuthHandler を使用すると、各 Web サイトにアクセスするときのユーザ名と、パスワード情報を設定することができます。 具体的には、Basic 認証のかかった Web サイトにアクセスした場合に Web サーバから返される realm 情報 と、ベースとなる URI 情報 に対して、使用するユーザ名とパスワードを関連付けます。
下記のサンプルでは、http://example.com/secret/ 以下にアクセスする際に、Basic 認証のユーザ名、パスワードとして、user1、pass1 を利用するように設定しています。 ここでは、realm 情報は無視し、URI 情報だけに関連付けるようにするため、HTTPPassswordMgrWithDefaultRealm を使用しています。
Basic 認証の付いたサイトにアクセスする import urllib.request import os.path def setup_basic_auth(base_uri, user, password): password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password( realm=None, uri=base_uri, user=user, passwd=password) auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr) opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; print(&amp;#39;Downloading .</description></item><item><title>Python で HTML をパースする (HTMLParser)</title><link>https://maku77.github.io/p/nqz8fnu/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nqz8fnu/</guid><description>HTMLParser で HTML を処理する Python に標準搭載されている HTML パーサである html.parser.HTMLParser は、イベントドリブンな HTML パーサです。
HTMLParser クラスを継承して独自のパーサを作成し、feed メソッドに HTML テキストを渡すことによってパースを開始します。 下記のサンプルコードでは、開始タグ、終了タグ、テキストデータ、コメントが見つかったときに、それぞれ内容を出力しています。
sample.py from html.parser import HTMLParser # HTMLParser を継承してパーサクラスを作成する class MyParser(HTMLParser): def handle_starttag(self, tag, attrs): print(&amp;#34;START :&amp;#34;, tag, attrs) def handle_endtag(self, tag): print(&amp;#34;END :&amp;#34;, tag) def handle_data(self, data): print(&amp;#34;DATA :&amp;#34;, data) def handle_comment(self, comment): print(&amp;#34;COMMENT:&amp;#34;, comment) # パーサのインスタンスを生成してパースを実行 parser = MyParser() parser.feed(&amp;#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;#39; &amp;#39;&amp;lt;div class=&amp;#34;class1&amp;#34; id=&amp;#34;id1&amp;#34;&amp;gt;Hello World&amp;lt;/div&amp;gt;&amp;#39; &amp;#39;&amp;lt;!-- I am a comment --&amp;gt;&amp;#39; &amp;#39;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;) 実行結果 START : html [] START : body [] START : div [(&amp;#39;class&amp;#39;, &amp;#39;class1&amp;#39;), (&amp;#39;id&amp;#39;, &amp;#39;id1&amp;#39;)] DATA : Hello World END : div COMMENT: I am a comment END : body END : html HTMLParser は、単純に HTML 要素を前から順番に処理していくだけなので、現在の要素がどのようなコンテキストで記述されているかは、パーサクラス内で判断していくように実装する必要があります。</description></item><item><title>Python の requests パッケージによる HTTP リクエスト</title><link>https://maku77.github.io/p/r7q8q7o/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r7q8q7o/</guid><description>requests パッケージのインストール オープンソースの requests パッケージ を使用すると、Python 3 標準の urllib.request よりも簡単に HTTP リクエストを扱うことができます。 例えば、以下のような処理をシンプルなコードで扱うことができます。
Basic 認証、ダイジェスト認証 ファイルのアップロード クッキー SSL 検証 エンコーディング形式の自動判別 コンテンンツが圧縮されていた場合の自動展開 requests パッケージは、pip コマンドで簡単にインストールできます。
request パッケージのインストール $ pip install requests requests モジュールによる HTTP GET リクエスト requests.get 関数を使うと、HTTP GET リクエストでインターネット上のコンテンツをダウンロードすることができます。 requests.get は、戻り値として requests.models.Response オブジェクトを返します。
Web コンテンツのダウンロード import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) type(res) #=&amp;gt; &amp;lt;class &amp;#39;requests.models.Response&amp;#39;&amp;gt; Response オブジェクトから、ステータスコードや、取得したコンテンツの内容を取得することができます。
requests.get のレスポンスを詳しく見る import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) print(res.status_code) #=&amp;gt; 200 print(res.status_code == requests.codes.ok) #=&amp;gt; True print(res.</description></item><item><title>Python で HTML をパースする (Beautiful Soup)</title><link>https://maku77.github.io/p/r4m4k2i/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r4m4k2i/</guid><description>Beautiful Soup とは Python 標準の html.parser モジュールは、SAX 形式のイベントドリブンなパーサなため、若干扱いにくいところがあります。 Beautiful Soup ライブラリを使用することで、HTML の要素に簡単にアクセスすることができるようになります。
Beautiful Soap Documentation Beautiful Soup パッケージは次のようにインストールできます。
$ pip install beautifulsoup4 HTML をパースする 最初に、HTML 文字列や HTML ファイルから bs4.BeautifulSoup オブジェクトを生成する必要があります。
HTML 文字列から soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(&amp;#34;&amp;lt;html&amp;gt;Hello&amp;lt;/html&amp;gt;&amp;#34;, features=&amp;#34;html.parser&amp;#34;) HTML ファイルから soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(open(&amp;#34;input.html&amp;#34;), features=&amp;#34;html.parser&amp;#34;) Beautiful Soup 自体には Web 上のリソースをダウンロードする機能は備わっていないので、そのようなケースでは、requests モジュールなどで HTML リソースをダウンロードしておいて、BeautifulSoup コンストラクタに渡してやります。
Web 上の HTML リソースから soup を作成（requests モジュールを使用） from bs4 import BeautifulSoup import requests res = requests.</description></item><item><title>Python で HTTP を扱う方法いろいろ</title><link>https://maku77.github.io/p/k5p4axo/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k5p4axo/</guid><description>Python3 の標準 HTTP ライブラリ Python3 には HTTP を扱う、下記のような標準ライブラリが用意されています。
http.client
HTTP (RFC 2616) を実装する 低レベルライブラリ。 urllib.request
上記を利用した 高レベルライブラリ。認証やリダイレクトをサポートしています。 オープンソースの HTTP ライブラリ Python に標準で付属している urllib.request パッケージは、比較的低レベルな処理を行うように設計されているため、手っ取り早く HTTP リクエストでデータを取得したい場合は、オープンソースの requests パッケージ を使うとよいでしょう。 requests パッケージは、Python の公式サイトでも推奨されています。
requests パッケージ</description></item><item><title>Python のパッケージ管理ツール (pip) の使い方</title><link>https://maku77.github.io/p/7o9q8p6/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7o9q8p6/</guid><description>pip とは Python のパッケージ管理ツールである pip コマンドは、従来の setuptools で提供されていた easy_install コマンドを置き換えるものです。 pip コマンドは、主に Python Package Index からパッケージをダウンロードしてインストールします。
pip のインストール Python 3.4 以降の Python インストーラを使用すると、pip コマンドは標準でインストールされます。 下記のいずれかの方法ですでにインストールされているか確認しましょう。
$ pip --version $ python -m pip --version $ python3 -m pip --version 単体でインストールする必要がある場合は、基本的には下記のサイトに従ってインストールします。
Installation - pip documentation pip 1.5.1 までは、setuptools の easy_install コマンドを使用してインストールしていましたが、現在は get-pip.py スクリプトを使ってどの OS 環境でも統一された方法で簡単にインストールすることができます。
pip コマンドのインストール $ curl -kL https://bootstrap.pypa.io/get-pip.py | python3 プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。
pip によるパッケージのインストール、アンインストール $ pip install &amp;lt;package&amp;gt; $ pip install -U &amp;lt;package&amp;gt; # パッケージを最新版にアップグレード $ pip install -I &amp;lt;package&amp;gt; # パッケージをインストールしなおす $ pip uninstall &amp;lt;package&amp;gt; # パッケージのアンインストール プロキシ環境で使用する場合は、--proxy=proxy.</description></item><item><title>Python で JSON 形式のテキストファイルを読み書きする (json.load, json.dump)</title><link>https://maku77.github.io/p/xhyhzfv/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xhyhzfv/</guid><description>JSON ファイルを読み込む (json.load) Python に付属している json ライブラリが提供する json.load 関数を使用すると、JSON 形式のテキストファイルを読み込んで、Python のオブジェクトを生成することができます。 json.load 関数のパラメーターには、ファイル名ではなく、ファイルオブジェクト（read 関数を持つオブジェクト）を渡すことに注意してください。
入力ファイル (input.json) { &amp;#34;aaa&amp;#34;: 100, &amp;#34;bbb&amp;#34;: 200, &amp;#34;ccc&amp;#34;: 300 } sample.py import json def load_json(filename): &amp;#34;&amp;#34;&amp;#34;JSON ファイルを読み込んで Python オブジェクトとして返します。&amp;#34;&amp;#34;&amp;#34; with open(filename, encoding=&amp;#39;utf-8&amp;#39;) as f: return json.load(f) # テスト obj = load_json(&amp;#34;input.json&amp;#34;) print(obj[&amp;#39;aaa&amp;#39;]) #=&amp;gt; 100 print(obj[&amp;#39;bbb&amp;#39;]) #=&amp;gt; 200 print(obj[&amp;#39;ccc&amp;#39;]) #=&amp;gt; 300 JSON ファイル内の各要素は、次のような対応付けで Python オブジェクトに変換されます。
JSON の型 Python の型 object dict array list string str number int / float true / false True / False null None JSON ファイルではなく、JSON 形式の文字列を読み込みたいときは、json.</description></item><item><title>Python で XML をパースする (ElementTree)</title><link>https://maku77.github.io/p/cp9q7n5/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cp9q7n5/</guid><description>ElementTree XML API Python 2.5 以降には、XML を扱うための標準 API として、ElementTree XML API が用意されています。
The ElementTree XML API ElementTree では、パースした XML を DOM オブジェクトとしてメモリ上に保持するため、XML データを読み込んだあとは、各 XML 要素へ柔軟にアクセスすることができます。
XML ファイルをパースする ElementTree モジュールが提供している ElementTree.parse 関数を使って、XML ファイルを読み込むことができます。 ElementTree.parse 関数は、読み込んだ XML をパースして ElementTree オブジェクトとして返します。 ElementTree オブジェクトは、XML ツリー全体を表現するオブジェクトです。 XML ツリーの先頭要素を表す Element オブジェクトは、ElementTree#getroot() メソッドで取得することができます。
input.xml（テスト用の XML ファイル） &amp;lt;tree name=&amp;#34;hello&amp;#34;&amp;gt; &amp;lt;trunk&amp;gt;...&amp;lt;/trunk&amp;gt; &amp;lt;/tree&amp;gt; main.py from xml.etree import ElementTree # XML ファイルから ElementTree オブジェクトを生成 tree = ElementTree.parse(&amp;#39;input.xml&amp;#39;) # 先頭要素を表す Element オブジェクトを取得 elem = tree.</description></item><item><title>Python で XML を扱う方法いろいろ</title><link>https://maku77.github.io/p/pt6fpx8/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pt6fpx8/</guid><description>Python には下記のように、標準の XML パーサが複数搭載されています。
xml.etree.ElementTree &amp;hellip; The ElementTree XML API xml.dom &amp;hellip; The Document Object Model API xml.dom.minidom &amp;hellip; Minimal DOM implementation xml.sax &amp;hellip; Support for SAX2 parsers 通常はシンプルな xml.etree.ElementTree を使い、DOM 標準の API を使いたい場合は xml.dom を使用すればよいでしょう。 巨大な XML ファイルを効率的に読み込みたい場合は、SAX API を提供する xml.sax を選択できます。
参考: 20. Structured Markup Processing Tools Beautiful Soup などの 3rd パーティライブラリでも XML を扱うことはできますが、Beautiful Soup はどちらかというと HTML のパースに向いています。 XML のパースは、ほとんどの場合 Python 標準の ElementTree で十分です。</description></item><item><title>Python で XPath を使って XML 要素を参照する (ElementTree)</title><link>https://maku77.github.io/p/fufwevc/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fufwevc/</guid><description>Python 2.5 以降に搭載されている ElementTree XML API は、XPath による要素アクセスをサポートしています。
The Element Tree XML API - XPath support 次の例では、country という名前の要素をすべて取得し、再帰的に子要素を表示しています。
countries.xml（入力ファイル） &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;data&amp;gt; &amp;lt;country name=&amp;#34;Liechtenstein&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;1&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2008&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;141100&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Austria&amp;#34; direction=&amp;#34;E&amp;#34;/&amp;gt; &amp;lt;neighbor name=&amp;#34;Switzerland&amp;#34; direction=&amp;#34;W&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;country name=&amp;#34;Singapore&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;4&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;59900&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Malaysia&amp;#34; direction=&amp;#34;N&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;country name=&amp;#34;Panama&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;68&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;13600&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Costa Rica&amp;#34; direction=&amp;#34;W&amp;#34;/&amp;gt; &amp;lt;neighbor name=&amp;#34;Colombia&amp;#34; direction=&amp;#34;E&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;/data&amp;gt; sample.py from xml.etree import ElementTree def dump_node(node, indent=0): print(&amp;#39; &amp;#39; * indent, node.tag, node.</description></item><item><title>Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen)</title><link>https://maku77.github.io/p/o2e43ct/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o2e43ct/</guid><description>ここでは、Python の組み込みモジュールである urllib.request を使った HTTP アクセスの例を示します。
urlopen による GET/POST リクエストの基本 urllib.request.urlopen 関数は、http.client.HTTPResponse オブジェクトを返します。 HTTPResponse オブジェクトの read メソッドを呼ぶことで、HTTP レスポンスを取得することができます。
https://example.com のコンテンツ (HTML) を取得する from urllib.request import urlopen with urlopen(&amp;#39;https://example.com/&amp;#39;) as res: text = res.read().decode(&amp;#39;utf-8&amp;#39;) print(text) read メソッドが返すデータはバイナリデータ (bytes) なので、テキストとして扱う場合は、エンコーディング形式（utf-8 など）を指定してデコードする必要があります。
urlopen 関数で取得した HTTPResponse オブジェクトは、リソース解放のために明示的に close() することが推奨されているのですが、上記のように Python 3 の with 文を使用すると、close() 処理を自動化できます。
urlopen の引数に、URL 文字列ではなく、urllib.request.Request オブジェクトを渡すこともできます。 Request オブジェクトを使うと、HTTP ヘッダー情報やプロキシ、HTTP メソッド（GET や POST）の指定などを行えます。
HTTP ヘッダーやプロキシを指定したリクエスト import urllib.request URL = &amp;#39;http://example.com/&amp;#39; req = urllib.</description></item><item><title>Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする</title><link>https://maku77.github.io/p/ogq5hdy/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ogq5hdy/</guid><description>urllib.request を使用した HTTP アクセスは、デフォルトでシステムに設定されたプロキシ設定（http_proxy、https_proxy、ftp_proxy 環境変数など）でアクセスが行われます。 これらのプロキシ設定をそのまま使用してもよいし、Python のコード内で明示的にプロキシを設定することもできます。
現在のプロキシ設定を確認する (getproxies) 現在、システムにどのようなプロキシ設定が反映されているかを調べるには、urllib.request.getproxies 関数を使用します。
import urllib.request print(urllib.request.getproxies()) 実行結果 {&amp;#39;http&amp;#39;: &amp;#39;http://proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;: &amp;#39;https://proxy.example.com:8080&amp;#39;, &amp;#39;ftp&amp;#39;: &amp;#39;ftp://proxy.example.com:8080&amp;#39;} リクエストごとにプロキシを設定する (Request) HTTP リクエストごとに使用するプロキシを明示的に指定したい場合は、Request オブジェクトを作成し、set_proxy メソッドでプロキシを指定します。 あとは、その Request オブジェクトを urllib.request.urlopen() に渡して HTTP リクエストを送信します。
リクエスト単位でのプロキシ設定 import urllib.request req = urllib.request.Request(&amp;#39;https://example.com/&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;http&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;) with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) Request#set_proxy() でプロキシサーバーを指定するときは、http:// や https:// といったスキーム名は省略することに注意してください。 スキーム名を記述してしまうと、プロキシがうまく認識されず、次のような DNS エラーになったりします。
urlopen error [Errno 11001] getaddrinfo failed Request オブジェクトは生成時に URL を指定する必要があるため、アクセス先が変わるごとに生成する必要があることに注意してください。</description></item><item><title>Python のワンライナーコマンドで JSON ファイルを整形する (json.tool)</title><link>https://maku77.github.io/p/an8o6m4/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/an8o6m4/</guid><description>json.tool の基本 Python 2.6 以降には json モジュールが標準搭載されていて、これはコマンドラインからも便利に利用することができます。 下記は、json.tool モジュール を使って JSON 形式のテキスト出力を、きれいに整形しなおして出力するワンライナーの例です。
$ python -mjson.tool input.json # あるいは $ cat input.json | python -mjson.tool ここでは、次のような JSON ファイルを使って試してみます。 スペースはわざとぐちゃぐちゃに入れています。
input.json（入力ファイル） {&amp;#34;ccc&amp;#34; : 300, &amp;#34;aaa&amp;#34;:100, &amp;#34;bbb&amp;#34;:200, &amp;#34;data&amp;#34;: [1,2,3]} 実行例 $ python -mjson.tool input.json { &amp;#34;ccc&amp;#34;: 300, &amp;#34;aaa&amp;#34;: 100, &amp;#34;bbb&amp;#34;: 200, &amp;#34;data&amp;#34;: [ 1, 2, 3 ] } キー名でソートして出力する (&amp;ndash;sort-keys) Python 3.7 以降で、キーの順序は入力ファイルのものが保持されるようになりました（内部的に辞書オブジェクト (dict) のキー挿入順序が保持されるようになりました）。 キー順序をアルファベット順にソートして出力したいときは、--sort-keys オプションを指定します。
キー順にソートする $ python -mjson.tool --sort-keys input.json { &amp;#34;aaa&amp;#34;: 100, &amp;#34;bbb&amp;#34;: 200, &amp;#34;ccc&amp;#34;: 300, &amp;#34;data&amp;#34;: [ 1, 2, 3 ] } インデントサイズを指定する (&amp;ndash;indent=N) バージョン 3.</description></item><item><title>Python コードの実行時間を計測する (datetime.now)</title><link>https://maku77.github.io/p/ubtbs9p/</link><pubDate>Thu, 01 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ubtbs9p/</guid><description>下記は datetime モジュールを使って、Python コードの一部の実行時間を計測する例です。
main.py from datetime import datetime start = datetime.now() # ここに実行時間を計測したい処理を記述する print(datetime.now() - start) 実行結果 $ python3 main.py 00:00:01.547393</description></item><item><title>JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps)</title><link>https://maku77.github.io/p/gwfweub/</link><pubDate>Wed, 22 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gwfweub/</guid><description>Python には JSON フォーマットを扱うための json モジュールが標準搭載（Python 2.6 以降）されており、JSON 形式のテキストと、Python のオブジェクトを相互に変換することができます。
JSON 文字列 → Python オブジェクト (json.loads) JSON 形式の文字列データから、Python オブジェクトを作成するには json.loads 関数 を使用します。
import json data = json.loads(&amp;#39;{&amp;#34;key&amp;#34;:&amp;#34;value&amp;#34;}&amp;#39;) print(data[&amp;#39;key&amp;#39;]) #=&amp;gt; &amp;#39;value&amp;#39; json.loads と似た関数に、json.load 関数がありますが、こちらは文字列ではなく JSON ファイルを読み込みます。 loads の末尾の s は、文字列を受け取ることを示しています。
参考: JSON 形式のテキストファイルを Python オブジェクトとして読み込む (json.load) Python オブジェクト → JSON 文字列 (json.dumps) 逆に、Python オブジェクトから JSON 形式のテキストを生成するには、json.dumps 関数 を使用します。
import json obj = {&amp;#39;aaa&amp;#39;:100, &amp;#39;bbb&amp;#39;:200} json_str = json.dumps(obj) print(json_str) 実行結果 {&amp;#34;bbb&amp;#34;: 200, &amp;#34;aaa&amp;#34;: 100} 整形して出力する (indent=2) 改行を入れた形で見やすく出力したい場合は、json.</description></item><item><title>Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer)</title><link>https://maku77.github.io/p/rr3cmu5/</link><pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rr3cmu5/</guid><description>Python がインストールされた環境であれば、コマンドラインから下記のように実行することで簡易 HTTP サーバを立てることができます。
（Python3 の場合）ポート 8000 で HTTP サーバーを起動 $ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... （Python2 の場合）ポート 8000 で HTTP サーバーを起動 $ python -m SimpleHTTPServer 8000 Serving HTTP on 0.0.0.0 port 8000 ... これで、http://localhost:8000/ にアクセスすれば、カレントディレクトリ内のファイルの一覧が表示されます。 開発環境での HTTP 開通テストや、LAN 内の一時的なファイル共有サーバとして使用することができます。</description></item><item><title>Python でユニットテストを記述する (unittest)</title><link>https://maku77.github.io/p/fueucsa/</link><pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fueucsa/</guid><description>Python でユニットテストを書くには、unittest モジュール を使用します。 unittest モジュールは、Python 2.1 以降に標準で搭載されています。
テストケースを作成するには、unittest.TestCase を継承したクラスを作成し、test で始まる名前のテストメソッドを記述するだけで OK です。 unittest.main 関数を呼び出すことにより、それらのテストメソッドが自動的に実行されます。
sample.py import unittest class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def decrement(self): self.count -= 1 def get_count(self): return self.count class CounterTest(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def test_increment(self): c = Counter() c.increment() self.assert_(c.get_count() == 1) c.increment() self.assert_(c.get_count() == 2) def test_decrement(self): c = Counter() c.decrement() self.assert_(c.get_count() == -1) c.decrement() self.</description></item><item><title>Python で XML を構築する (minidom)</title><link>https://maku77.github.io/p/m2k3jyg/</link><pubDate>Fri, 08 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m2k3jyg/</guid><description>下記は、Python の minidom モジュールが提供する DOM インタフェースを使用して XML を構築し、XML ファイルとして保存するサンプルです。
sample.py import codecs from xml.dom import minidom def create_xmldoc(): doc = minidom.Document() tree = doc.createElement(&amp;#39;tree&amp;#39;) doc.appendChild(tree) branch = doc.createElement(&amp;#39;branch&amp;#39;) tree.appendChild(branch) leaf = doc.createElement(&amp;#39;leaf&amp;#39;) leaf.setAttribute(&amp;#39;id&amp;#39;, &amp;#39;001&amp;#39;) branch.appendChild(leaf) text = doc.createTextNode(&amp;#39;This is a leaf&amp;#39;) leaf.appendChild(text) return doc def save_xmldoc(xmldoc, filepath): f = codecs.open(filepath, &amp;#39;wb&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) # Text encoding xmldoc.writexml(f, &amp;#39;&amp;#39;, &amp;#39; &amp;#39;*2, &amp;#39;\n&amp;#39;, encoding=&amp;#39;UTF-8&amp;#39;) # XML header&amp;#39;s encoding f.close() if __name__ == &amp;#39;__main__&amp;#39;: doc = create_xmldoc() save_xmldoc(doc, &amp;#39;output.</description></item><item><title>Python で XML をパースする (minidom)</title><link>https://maku77.github.io/p/guducs9/</link><pubDate>Mon, 04 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/guducs9/</guid><description>Python 2.0 以降では、Document Object Model インタフェース (DOM API) の最小の実装として、xml.dom.minidom が搭載されています。 DOM 標準の API を使って操作する必要のない場合は、よりシンプルなインターフェースを提供している ElementTree モジュールを使用する のがよいでしょう。
Document オブジェクトを取得する minidom を使用して、XML の各要素にアクセスするためには、まずは DOM 全体を表現する xml.dom.minidom.Document オブジェクトを取得する必要があります。 データソースとしては、XML ファイル、XML 文字列、Web 上のリソースなどを利用できます。
XML ファイルを扱う場合 from xml.dom import minidom doc = minidom.parse(&amp;#34;input.xml&amp;#34;) print(doc.toxml()) XML 文字列を扱う場合 from xml.dom import minidom xml = &amp;#34;&amp;#34;&amp;#34; &amp;lt;tree&amp;gt; &amp;lt;branch&amp;gt; &amp;lt;leaf id=&amp;#39;1&amp;#39;&amp;gt;Leaf 1&amp;lt;/leaf&amp;gt; &amp;lt;leaf id=&amp;#39;2&amp;#39;&amp;gt;Leaf 2&amp;lt;/leaf&amp;gt; &amp;lt;leaf id=&amp;#39;3&amp;#39;&amp;gt;Leaf 3&amp;lt;/leaf&amp;gt; &amp;lt;/branch&amp;gt; &amp;lt;/tree&amp;gt;&amp;#34;&amp;#34;&amp;#34; doc = minidom.parseString(xml) print(doc.toxml()) Web 上の XML リソースを扱う場合 urllib モジュールを組み合わせて使えば、Web 上の XML も簡単にパースできます。</description></item><item><title>Python でモジュールを import する方法のまとめ</title><link>https://maku77.github.io/p/zdxfvct/</link><pubDate>Thu, 19 Nov 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zdxfvct/</guid><description>Python でモジュールをインポートする際に使用される import 構文は、複数の指定方法があるため、初めはやや混乱するかもしれません。 以下に、import のさまざまな指定方法をまとめておきます。 Python のモジュールとパッケージの基本については下記の記事を参考にしてください。
Python でモジュールやパッケージを作成する モジュール単位でのインポート まずは基本から。 モジュール名でインポートする方法です。 この方法でモジュールをインポートした場合は、内部の関数などを参照するときは、モジュール名をプレフィックスとして付けます。
mymod モジュールをインポートする import mymod mymod.hello() パッケージ内のモジュールをインポートするときは、次のいずれかの方法で記述しますが、モジュール内のメンバーを参照するときのプレフィックスが変わってきます。
mypkg パッケージ内の mymod モジュールをインポートする # 方法1 import mypkg.mymod mypkg.mymod.hello() # 方法2 from mypkg import mymod mymod.hello() 2 階層以上のパッケージになっても同様です。
# 方法1 import mypkg.sub.mymod mypkg.sub.mymod.hello() # 方法2 from mypkg.sub import mymod mymod.hello() 特定のメンバーのみをインポート from モジュール名 import 関数名 という構文で、モジュール内の特定の関数だけインポートすれば、モジュール名を指定せずにその関数を直接呼び出せるようになります。
mymod モジュールの hello 関数のみをインポートする from mymod import hello hello() パッケージ内のモジュールに関しても同様です。
mypkg パッケージの mymod モジュールの hello 関数のみをインポートする from mypkg.</description></item><item><title>Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe)</title><link>https://maku77.github.io/p/kyj2izf/</link><pubDate>Tue, 10 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kyj2izf/</guid><description>py2exe を使用すると、Python のスクリプトから Windows 上で実行可能な .exe ファイルを作成することができます。
基本的な使い方 変換対象のスクリプト hello.py と、変換設定ファイル setup.py を用意します。
hello.py print &amp;#39;Hello&amp;#39; setup.py from distutils.core import setup import py2exe setup(console=[&amp;#39;test.py&amp;#39;]) コマンドラインから、次のように実行すると、dist ディレクトリに hello.exe と、必要なライブラリが生成されます。
C:\&amp;gt; python setup.py py2exe 配布するときは、dist ディレクトリの中身をすべてまとめて配布します。
（応用）wxPython などの GUI アプリケーションの場合 setup.py from distutils.core import setup import py2exe setup(windows=[&amp;#39;test.py&amp;#39;]) GUI を持つアプリケーションで、実行時にコマンドプロンプトを表示したくない場合は、setup メソッドのパラメータとして、console の代わりに windows を指定します。</description></item><item><title>Python の対話型シェルで使える小技</title><link>https://maku77.github.io/p/dsbsaq7/</link><pubDate>Wed, 07 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsbsaq7/</guid><description>Python のインタラクティブシェルで _（アンダースコア）を使用すると、 前回評価した値を参照することができます。
&amp;gt;&amp;gt;&amp;gt; [1, 2, 3] [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; len(_) 3</description></item><item><title>Python のコーディングスタイル</title><link>https://maku77.github.io/p/pyk3j2h/</link><pubDate>Tue, 06 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pyk3j2h/</guid><description>Python のコーディングスタイルは、PEP 8 や PEP 257 で指針が示されています。
PEP 8 &amp;ndash; Style Guide for Python Code PEP 257 &amp;ndash; Docstring Conventions このページでは主に上記の内容についてまとめていますが、実際に Python のプロジェクトにコーディングスタイルを適用するときは、Black などの Python フォーマッターを導入 することをおすすめします。 Black は、PEP 8 や PEP 257 と若干異なるところがありますが、理にかなったスタイルを強制的に適用してくれます。
命名規則 大文字／小文字 パッケージ名は小文字のみ（例: mypackage） クラス名は大文字で始める（例: MyClass） 関数、あるいは public メソッドは小文字（例: my_public_method） protected メソッドはアンダースコア 1 つで始める（例: _my_protected_method） private メソッドはアンダースコア 2 つで始める（例: __my_private_method） 定数名はすべて大文字（例: MY_CONSTANT） Python の name mangling の仕組みによって、アンダースコア 2 つで始まる名前は、クラス外部、あるいはサブクラスからその名前ではアクセスできないようになっています（正確には _ClassName__method という名前でアクセスできますが）。 この特性を利用して、private メソッドをアンダースコア 2 つで始めるようにするのがよい、ということです。
グローバル領域でのアンダースコアの使用について トップレベルに定義するクラスや関数で、モジュール（ファイル）内に閉じて外部に公開しないものは、プレフィックスとして 1 つのアンダースコアを付けます。 こうすることで、from M import * の形での自動インポートを防ぐことができます。</description></item></channel></rss>