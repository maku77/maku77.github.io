<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on 天才まくまくノート</title><link>https://maku77.github.io/python/</link><description>Recent content in Python on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 08 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/python/index.xml" rel="self" type="application/rss+xml"/><item><title>pandas で DataFrame をループ処理する (iterrows, items)</title><link>https://maku77.github.io/p/rfduqhx/</link><pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rfduqhx/</guid><description>pandas の DataFrame にはブロードキャストによる演算機能が備わっているため、ほとんどの場合はループ処理を記述する必要はありませんが、明示的にループ処理することも可能です。
行のループ処理 (iterrows) df.iterrows() メソッドを使用すると、各行をイテレート処理できます。
import pandas as pd # サンプルデータ df = pd.DataFrame({ &amp;#34;Name&amp;#34;: [&amp;#34;Alice&amp;#34;, &amp;#34;Bob&amp;#34;, &amp;#34;Charlie&amp;#34;], &amp;#34;Age&amp;#34;: [25, 30, 35], &amp;#34;City&amp;#34;: [&amp;#34;New York&amp;#34;, &amp;#34;San Francisco&amp;#34;, &amp;#34;Los Angeles&amp;#34;], }) # DataFrame の各行をループ処理 for i, row in df.iterrows(): print(f&amp;#34;{i}: Name={row[&amp;#39;Name&amp;#39;]}, Age={row[&amp;#39;Age&amp;#39;]}, City={row[&amp;#39;City&amp;#39;]}&amp;#34;) 実行結果 0: Name=Alice, Age=25, City=New York 1: Name=Bob, Age=30, City=San Francisco 2: Name=Charlie, Age=35, City=Los Angeles 列のループ処理 (items) df.items() メソッドを使用すると、各列をイテレート処理できます。 ループごとに、各列のラベル名と Series オブジェクトのタプルを取得できます（ラベル名は series.name でも取得できるんですけどね^^）。</description></item><item><title>python コマンドのバージョンを切り替える (pyenv, py)</title><link>https://maku77.github.io/p/x4z298a/</link><pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x4z298a/</guid><description>互換性の問題のために、少し古いバージョンの python コマンドを使わなければいけないことがあります（機械学習系のライブラリなど）。 そのようなケースでは、次のようなツールを使って python コマンド自体のバージョンを切り替えると便利です。
pyenv &amp;hellip; Linux または macOS 用の python バージョン切り替えコマンドです。Windows 用の移植もありますが、シェルスクリプトで作られているので、本質的には Linux または macOS 用です。 Python ランチャー (py) &amp;hellip; Windows 用の Python インストーラーを使うと、Python ランチャー（py コマンド）をインストールすることができます。 pyenv コマンド インストール macOS の場合 (Homebrew) $ brew update $ brew install pyenv Linux の場合 $ curl https://pyenv.run | bash チートシート コマンド 説明 pyenv versions インストール済みの Python バージョンの一覧を表示します。現在選択しているバージョンには * 印が付きます。 pyenv version 現在選択している Python のバージョンを表示します。 pyenv install --list インストール可能な Python のバージョンを表示します。 pyenv install 3.</description></item><item><title>Python の dictionary（辞書）のチートシート</title><link>https://maku77.github.io/p/2tyvjmh/</link><pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2tyvjmh/</guid><description>コード 説明 d = {}
d = dict() dictionary の作成 d = {&amp;quot;key1&amp;quot;: 100}
d = dict(key1=100) dictionary の作成と初期化 d = dict(zip([&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;], [1, 2, 3])) キーのリストと値のリストから dictionary を作成 len(d) 要素数 d[&amp;quot;key&amp;quot;] = 100 要素を追加・上書き val = d[&amp;quot;key&amp;quot;] 要素を取得（キーが存在しないときは KeyError） val = d.get(&amp;quot;key&amp;quot;, default=0) 要素を取得（キーが存在しないときはデフォルト値を返す） val = d.setdefault(&amp;quot;key&amp;quot;, 0) 要素を取得（キーが存在しないときはデフォルト値をセットして返す） keys = d.keys() キーのリストを取得 vals = d.values() 値のリストを取得 items = d.items() (キー, 値) のリストを取得 if &amp;quot;key&amp;quot; in d: キーが存在するか調べる del d[&amp;quot;key&amp;quot;] 要素を削除する（キーが存在しないときは KeyError） for key in d: キーでループ for key, val in d.</description></item><item><title>Python の requests パッケージのチートシート</title><link>https://maku77.github.io/p/succ4mb/</link><pubDate>Tue, 28 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/succ4mb/</guid><description>インストールとインポート requests パッケージのインストール $ pip install requests requests パッケージのインポート import requests リクエスト コード説明 res = requests.get(URL) GET リクエスト res = requests.get(URL, headers={"key": "val"}) ヘッダーの設定 res = requests.get(URL, params={"key": "val"}) クエリパラメータの設定 res = requests.get(URL, cookies={"key": "val"}) クッキーの設定 res = requests.get(URL, auth=("user", "pass")) Basic 認証 res = requests.get(URL, auth=requests.auth.HTTPDigestAuth("user", "pass")) Digest 認証 res = requests.post(URL, data={"key": "val"}) POST リクエストでペイロード送信（key=val というテキスト） data = {"key": "value"} res = requests.post( "https://example.com", headers={"Content-Type": "application/json"}, data=json.dumps(data) ) POST リクエストでペイロード送信（JSON 形式のテキスト） session = requests.</description></item><item><title>Python の dictionary（辞書）の基本</title><link>https://maku77.github.io/p/zpdyxso/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zpdyxso/</guid><description>Python の dictionary（辞書）は、キーと値のペアで構成されたオブジェクトです。 他の言語では、マップやハッシュと呼ばれていたりします。
dictionary オブジェクトを生成する ({}, dict) dictionary は {} あるいは、dict() を使って生成できます。 Python の dictionary は、JavaScript のオブジェクトにそっくりです。
空の dictionary を作成する d = {} # 空の辞書を作成する d = dict() # 別の方法 print(type(d)) #=&amp;gt; &amp;lt;class: &amp;#39;dict&amp;#39;&amp;gt; print(len(d)) #=&amp;gt; 0 初期値を持つ dictionary を作成する dictionary オブジェクトを生成するときに、キーと値のペアを列挙することで、初期値を設定できます。 {} を使った初期化用の構文を使うか、dict() 関数にキーワード引数の形で初期値を指定します。
d = {&amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2} # 初期値を持つ辞書を作成する d = dict(one=1, two=2) # 別の方法 print(d[&amp;#39;one&amp;#39;]) #=&amp;gt; 1 print(d[&amp;#39;two&amp;#39;]) #=&amp;gt; 2 print(d[&amp;#39;three&amp;#39;]) #=&amp;gt; KeyError dictionary の要素を参照・変更する ([], get) Python で dictionary オブジェクトの要素を参照するには下記のように [] でキーを指定します。 キーが存在しない場合は、KeyError が発生します。</description></item><item><title>MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists)</title><link>https://maku77.github.io/p/849syej/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/849syej/</guid><description>MNIST とは MNIST (Modified National Institute of Standards and Technology) は、手書き数字認識のためのデータセット で、0 から 9 までの単一の数字が手書きされた 28x28 ピクセルのグレースケール画像が含まれています。 各画像は対応する数字のラベルを持っており、機械学習や深層学習のアルゴリズムのトレーニングやテストに使用されます。
MNIST データの取得 MNIST のデータは、Python の keras.datasets パッケージを使って簡単に取得することができます。
MNIST のデータを取得 import math from keras.datasets import mnist # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # データ形状を確認 print(&amp;#34;X_train: {}&amp;#34;.format(X_train.shape)) print(&amp;#34;y_train: {}&amp;#34;.format(y_train.shape)) print(&amp;#34;X_test: {}&amp;#34;.format(X_test.shape)) print(&amp;#34;y_test: {}&amp;#34;.format(y_test.shape)) 実行結果 X_train: (60000, 28, 28) y_train: (60000,) X_test: (10000, 28, 28) y_test: (10000,) mnist.load_data() が返す MNIST データは、学習用のデータとテスト用のデータに分かれており、それぞれ下記のような内容の NumPy 配列になっています。</description></item><item><title>Python の関数をキーワード引数を使って呼び出す</title><link>https://maku77.github.io/p/jf6kyao/</link><pubDate>Sun, 12 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jf6kyao/</guid><description>位置引数とキーワード引数 Python の関数を呼び出すときの引数の指定方法には、下記の 2 種類があります。
位置引数 (positional argument) &amp;hellip; 定義された順序通りに引数を渡す方法。 キーワード引数 (keyword argument) &amp;hellip; 引数名=値 のように引数名と値のペアで渡す方法。他の言語だと「名前付き引数」と呼ばれていたりします。 次の例では、2 つの文字列引数を受け取る show_book 関数を、それぞれの引数指定方法で呼び出しています。
def show_book(title: str, author: str) -&amp;gt; None: print(f&amp;#34;{title} by {author}&amp;#34;) # 位置引数 (positional argument) による関数呼び出し show_book(&amp;#34;The Hobbit&amp;#34;, &amp;#34;J.R.R. Tolkien&amp;#34;) # キーワード引数 (keyword argument) による関数呼び出し show_book(author=&amp;#34;J.R.R. Tolkien&amp;#34;, title=&amp;#34;The Hobbit&amp;#34;) 位置引数による呼び出しの方が短く記述できますが、このように同じ型 (str) の引数が複数ある場合は、キーワード引数を使った方が呼び出し順序の間違いによる不具合が入りにくくなります。 後者の呼び出し方を見るとわかるように、キーワード引数を使うと、任意の順番で引数を記述できます。
位置引数とキーワード引数を混ぜて呼び出すこともできますが、すべての位置引数をキーワード引数よりも前に配置する必要があります。
show_book(&amp;#34;The Hobbit&amp;#34;, author=&amp;#34;J.R.R. Tolkien&amp;#34;) # OK show_book(title=&amp;#34;The Hobbit&amp;#34;, &amp;#34;J.R.R. Tolkien&amp;#34;) # Syntax Error ちなみに、キーワード引数を使う場合、= の前後にはスペースを入れないのが慣例です。
デフォルト引数との組み合わせ キーワード引数による関数呼び出しの真価が発揮されるのは、引数にデフォルト値が設定されているときです。 次の draw_rect 関数は、3 つの引数を取りますが、それらすべてにデフォルト値が設定されています。 このような場合、キーワード引数を使って関数を呼び出すことで、任意の引数を省略することができます（位置引数を使うと、後方にある引数しか省略できません）。</description></item><item><title>scikit-image の data パッケージに含まれるテスト画像を使用する</title><link>https://maku77.github.io/p/nz8zoxu/</link><pubDate>Fri, 10 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nz8zoxu/</guid><description>scikit-image の data パッケージ scikit-image の data パッケージには、画像処理のテストに使えるテスト画像データが含まれています。
画像データを読み込むには、画像ごとに用意された関数を呼び出します。 次の例では、data.astronaut() 関数で宇宙飛行士の画像データを取得しています。 画像データは NumPy 配列データ (ndarray) として返されます。
from skimage import data # 画像データを読み込む img = data.astronaut() # 画像データの形式を調べる print(type(img)) #=&amp;gt; &amp;lt;class &amp;#39;numpy.ndarray&amp;#39;&amp;gt; print(img.shape) #=&amp;gt; (512, 512, 3) この画像データのサイズは 512x512 で、カラー画像（3 チャネル）であることが分かります。
読み込んだ画像データを表示する matplotlib パッケージを使えば、画像データ（NumPy 配列）を画面上に出力することができます。
図: skimage.data.astronaut() の画像データ from matplotlib import pyplot as plt from skimage import data # 画像データを読み込む img = data.astronaut() # matplotlib で画面に表示 fig, ax = plt.subplots(figsize=(4, 4), dpi=72) ax.</description></item><item><title>Python の scikit-image で画像処理</title><link>https://maku77.github.io/p/apkiihk/</link><pubDate>Wed, 08 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/apkiihk/</guid><description>scikit-image とは scikit-image は Pytyon 用の画像処理パッケージで、画像の入出力、変換、表示まで 1 パッケージで容易に行うことができます。 読み込んだ画像データは NumPy 配列として保持されるため、NumPy 配列の各種メソッドを使用して画素値を直接処理することができます。
高速な画像処理が可能なライブラリとして OpenCV などもありますが、scikit-image は OpenCV よりも学習が容易です。 科学的な画像処理には scikit-image、リアルタイムでのコンピュータービジョンタスクには OpenCV、と使い分けるとよさそうです。
scikit-image のインストール scikit-image パッケージは pip install コマンドで簡単にインストールできます（最新バージョンへの更新を兼ねるには -U オプションを付けます）。 依存する numpy、scipy、pillow などのパッケージもまとめてインストールされます。 できれば、venv 環境 にインストールすることをお勧めします。
scikit-image のインストール $ python -m pip install -U scikit-image 画面上に画像を表示する関数 (io.imshow()) を使用する場合は、matplotlib パッケージもインストールしておく必要があります。
matplotlib のインストール $ python -m pip install -U matplotlib Python コードからインポートするパッケージの名前は scikit-image ではなく、skimage なので注意してください。 skimage の機能は、次のようにサブパッケージとして分けられています。
io &amp;hellip; 画像の読み書きや、画面への表示 transform &amp;hellip; 回転などの画像変換処理 color &amp;hellip; 色空間の変換 data &amp;hellip; テスト用の画像データ img = data.</description></item><item><title>pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes)</title><link>https://maku77.github.io/p/pa2us3b/</link><pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pa2us3b/</guid><description>Pandas の DataFrame から、数値タイプ（int64 や float64）のカラムだけを抽出するには、df.select_dtypes() メソッドを使用します。 次の例では、サンプルの DataFrame から数値タイプのカラム名を抽出して列挙しています。
import numpy as np import pandas as pd # サンプルの DataFrame を作成 data = { &amp;#39;列1&amp;#39;: [1, 2, 3], &amp;#39;列2&amp;#39;: [1.1, 2.2, 3.3], &amp;#39;列3&amp;#39;: [&amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;] } df = pd.DataFrame(data) # 数値タイプのカラムを抽出してカラム名のリストを取得 numerical_columns = df.select_dtypes(include=[np.number]).columns # 結果表示 print(numerical_columns) for col in numerical_columns: print(col) 実行結果 Index([&amp;#39;列1&amp;#39;, &amp;#39;列2&amp;#39;], dtype=&amp;#39;object&amp;#39;) 列1 列2 なお、上の例では数値型として np.number を指定していますが、&amp;quot;number&amp;quot; という文字列でも大丈夫です。</description></item><item><title>pandas の DataFrame のカラムのデータ型を変更する (df.astype)</title><link>https://maku77.github.io/p/fk2e74z/</link><pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fk2e74z/</guid><description>Series と DataFrame の astype メソッド pandas の Series/DataFrame オブジェクトのデータ型を変換するには、astype() メソッドを使用します。
参考: pandas.Series.astype 参考: pandas.DataFrame.astype Series の astype() メソッドは、指定したデータ型に変換された新しい Series オブジェクトを返します。
Series のデータ型変換 ser1 = pd.Series([1, 2, 3], dtype=&amp;#34;int64&amp;#34;) # = np.int64 ser2 = ser1.astype(&amp;#34;float64&amp;#34;) # = np.float64 print(ser1.dtype) # int64 print(ser2.dtype) # float64 DataFrame の astype() メソッドを使用すると、複数カラムのデータ型をまとめて変換することができます。
DataFrame のデータ型変換 data = { &amp;#34;列1&amp;#34;: [1, 2, 3, 4], &amp;#34;列2&amp;#34;: [1.5, 2.8, 3.1, 4.3], } df1 = pd.DataFrame(data) df2 = df1.astype({&amp;#34;列1&amp;#34;: &amp;#34;float64&amp;#34;, &amp;#34;列2&amp;#34;: &amp;#34;int32&amp;#34;}) print(df2.</description></item><item><title>scikit-learn 組み込みのデータセットを扱う (sklearn.dataset)</title><link>https://maku77.github.io/p/o7qnbeg/</link><pubDate>Wed, 18 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o7qnbeg/</guid><description>scikit-learn の sklearn.datasets モジュールは、組み込みのデータセットをロードする関数 (load_*) や、インターネット上のデータセットを取得する関数 (fetch_*) を提供しています。 scikit-learn の各種モジュールの振る舞いを学ぶときは、これらのデータセットをサンプルデータとして使うと便利です。
組み込みのデータセット load_ で始まる関数を使用すると、scikit-learn に組み込まれているデータセットを読み込むことができます。 データ数は少ないですが、実験には十分です。
使用例 from sklearn.datasets import load_diabetes diabetes = load_diabetes() 関数名 用途 説明 load_diabetes 回帰 糖尿病 (diabetes) 患者の診断データです。このデータセットは、糖尿病患者の臨床データからなり、主に糖尿病の進行を予測するための回帰分析に使用されます。データには患者の年齢、性別、平均血圧、BMI（Body Mass Index）、血清の 6 つの生化学的特徴（血清中の濃度など）などの特徴が含まれています。1 年後の糖尿病の進行を示す数値を予測します。 load_linnerud 回帰 体力トレーニングの効果に関する 2 つのデータセットです。Physical Exercise Data: このデータセットには、20 人の被験者の体力トレーニングに関する情報が含まれています。特徴量には、腕立て伏せ、仰向けの上体起こし、スクワットの回数が含まれており、これらの情報はトレーニングの効果を示すものです。Physiological Data: このデータセットには、20人の被験者の生理学的データが含まれており、特徴量には体重、腕立て伏せ、仰向けの上体起こし、腕立て伏せと仰向けの上体起こしの最大心拍数などが含まれています。 load_breast_cancer 分類 乳がん (breast cancer) 患者の腫瘍に関するデータで、主に乳がんの分類タスクに使用されます。データには腫瘍の特性に関する情報（腫瘍の半径、テクスチャ、周囲の腫瘍の平滑度など）が含まれており、それぞれのサンプルが「良性」または「悪性」のいずれかに分類されています。 load_digits 分類 手書き数字認識のための画像データです。0 から 9 までの手書き数字の画像が含まれており、各画像は 8x8 ピクセルのグレースケール画像として表現されています。機械学習アルゴリズムを使用して手書き数字を識別するために使用できます。 load_iris 分類 アヤメ（iris）の計測データです。iris データセットは、機械学習の教育と実験用に広く使用されるデータセットの一つです。3 つの異なる種類のアヤメの花の特性が含まれており、各花の 4 つの特徴量が記録されています。これらの特徴量は、がく片（sepal）と花弁（petal）の長さと幅に関するもので、アヤメの種類を分類するために使用できます。 load_wine 分類 ワインの化学的特性に関するデータセットです。異なる種類のワインの特性に関する情報が含まれており、主にワインの分類タスクや品質評価に使用されます。データにはアルコール濃度、酸度、フェノール類の濃度、色の強さ、色の濃さなど、ワインの化学的特性に関する 13 の特徴量が含まれています。各サンプルは 3 つの異なるワインクラス（種類）に属しています。 load_sample_image 画像 指定した画像のデータセットを numpy array として取得できます。&amp;quot;china&amp;quot;: 中国の風景画像で、機械学習のコンピュータビジョンタスクなどで使用されます。&amp;quot;flower&amp;quot;: 花の画像で、画像処理や画像分類のタスクに使用されます。 ダウンロード可能なデータセット fetch_ で始まる関数を使うと、インターネット上で公開されている有名なデータセットを読み込むことができます。</description></item><item><title>pandas で CSV/TSV ファイルを出力する (pd.to_csv)</title><link>https://maku77.github.io/p/ioj6bqf/</link><pubDate>Sat, 14 Oct 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ioj6bqf/</guid><description>参考 pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) pandas で DataFrame オブジェクトの内容を CSV/TSV ファイルに出力するには、DataFrame#to_csv() メソッドを使用します。
テスト用の DataFrame ここでは、出力用の DataFrame オブジェクトを次のように作成しておきます。 インデックス名に idx1〜idx3、カラム名に col1〜col3 をセットしています。
import numpy as np import pandas as pd np.random.seed(12345) # 乱数の再現性を確保 df = pd.DataFrame({ &amp;#34;col1&amp;#34;: np.random.randint(10, size=3), &amp;#34;col2&amp;#34;: np.random.randint(10, size=3), &amp;#34;col3&amp;#34;: [&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;], }, index=[&amp;#34;idx1&amp;#34;, &amp;#34;idx2&amp;#34;, &amp;#34;idx3&amp;#34;]) print(df) 実行結果 col1 col2 col3 idx1 2 4 AAA idx2 5 9 BBB idx3 1 5 CCC CSV/TSV に出力する to_csv() メソッドの基本 パラメーターなしで to_csv() メソッドを呼び出すと、インデックス名やカラム名（CSV のヘッダー行）も含めて出力されます。 これは、パラメーターのデフォルト値が index=True, header=True になっているからです。</description></item><item><title>pandas チートシート - DataFrame の欠損値 (NaN) の扱い方まとめ</title><link>https://maku77.github.io/p/rtc38u8/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rtc38u8/</guid><description>チートシート（DataFrame の欠損値の扱い） 概要 コード 欠損値を表現する np.nan 欠損値部分を True、それ以外を False にする df2 = df.isnull() 欠損値以外の True、それ以外を True にする df2 = df.notnull() 欠損値を数える df.isnull().sum()df.isnull().sum(axis=1) 非欠損値を数える df.notnull().sum()df.count()df.info() 欠損値がある列／行を探す df.isnull().any()df.isnull().any(axis=1) 欠損値を含む「行」を削除する df.dropna()df.dropna(axis=0)df.dropna(axis=&amp;quot;index&amp;quot;) 欠損値を含む「列」を削除する df.dropna(axis=1)df.dropna(axis=&amp;quot;columns&amp;quot;) 欠損値を補完する df[&amp;quot;列&amp;quot;] = df[&amp;quot;列&amp;quot;].fillna(値)df[&amp;quot;列&amp;quot;].fillna(値, inplace=True) isnull() は isna() のエイリアスです。 Python コードでの欠損値 (NaN) の表現方法 pandas では、値が存在しないことを欠損値 (NaN: Not a Number) が存在すると表現します（プログラム的には何らかの値で「値がない」ことを表現しないといけないため）。 欠損値は、NumPy の np.nan で表現することができます。
import numpy as np print(np.nan) # nan print(type(np.nan)) # &amp;lt;class &amp;#39;float&amp;#39;&amp;gt; ちなみに、CSV ファイルを pd.read_csv() で読み込んだ場合、何も記述されていない部分に欠損値 (np.nan) が格納されます。</description></item><item><title>pandas チートシート - DataFrame のデータ加工方法まとめ</title><link>https://maku77.github.io/p/m4ggdkx/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m4ggdkx/</guid><description>DataFrame 加工のチートシート 作成／追加 df["列"] = スカラー値 新しいカラムの作成（すべて同じ値） df["列"] = シリーズdf.assign(列=シリーズ) 新しいカラムの作成（Series の代入） df2 = df.copy() # shallow copydf2 = df.copy(deep=True) DataFrame のコピー df["列2"] = df["列1"] + 10df["列2"] = df.apply(lambda r: r["列1"] + 10, axis=1) 既存カラムの値を使って新しいカラムを作成 df2 = df[["列1", "列2", "列3"]] カラムの抽出 結合 (concat, merge) new_df = pd.concat([df1, df2]) 複数の DataFrame を縦結合 new_df = pd.merge(df1, df2, on="列", how="inner") 2 つの DataFrame を横結合 削除 (drop, drop_duplicates) df2 = df.drop(columns="列")
df2 = df.drop("列", axis=1) 指定したカラムを削除 df.</description></item><item><title>pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table)</title><link>https://maku77.github.io/p/78ns8r5/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/78ns8r5/</guid><description>参考 pandas で CSV/TSV ファイルを出力する (pd.to_csv) pandas で CSV ファイルを読み込んで DataFrame オブジェクトを生成するには、pd.read_csv() 関数を使用します。 read_csv() 関数は、任意のセパレーター (sep) を指定できるので、CSV ファイルだけでなく、TSV ファイルなども読み込むことができます。
ヘッダーの有無の指定 (header) import pandas as pd # ヘッダー有りの CSV ファイルを読み込む df = pd.read_csv(&amp;#34;input.csv&amp;#34;) # ヘッダー無しの CSV ファイルを読み込む df = pd.read_csv(&amp;#34;input.csv&amp;#34;, header=None) # ヘッダーが 2 行目にある場合 df = pd.read_csv(&amp;#34;input.csv&amp;#34;, header=1) TSV ファイルを読み込む タブ区切りファイル (TSV) を読み込む場合は、pd.read_csv() 関数でセパレーター文字 (sep) を指定するか、pd.read_table() 関数を使用します。
TSV ファイルを読み込む df = pd.read_csv(&amp;#34;input.tsv&amp;#34;, sep=&amp;#34;\t&amp;#34;) df = pd.read_table(&amp;#34;input.tsv&amp;#34;) # 同上 カラム名を設定する (names) CSV/TSV ファイルから DataFrame オブジェクトを生成するときに names 引数を指定すると、明示的にカラム名をセットすることができます。 この場合、CSV/TSV ファイルの最初の行からデータが始まっているとみなされるため、ヘッダー行を含む CSV/TSV ファイルを読み込む場合、ヘッダー行をうまいこと無視する必要があります。 header=0 を指定して 1 行目がヘッダー行であることを伝えるか、skiprows=1 で単純に 1 行スキップする方法が使えます。</description></item><item><title>pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix)</title><link>https://maku77.github.io/p/3g687f5/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3g687f5/</guid><description>pandas の DataFrame のカラム名やインデックス名を変更方法のまとめです。
カラム名を一括で置き換える (columns) 既存の DataFrame のカラム名（列名）を丸ごと置き換えるには、columns プロパティにカラム名のリストを代入します。
df.columns = [&amp;#34;列名1&amp;#34;, &amp;#34;列名2&amp;#34;, &amp;#34;列名3&amp;#34;] この操作は、既存の DataFrame のカラム名を直接変更します。
カラム名にプレフィックスやサフィックスを追加する (add_prefix, add_suffix) # 全てのカラム名の先頭に X_ を付ける f2 = df.add_prefix(&amp;#34;X_&amp;#34;) # 全てのカラム名の末尾に _X を付ける df2 = df.add_suffix(&amp;#34;_X&amp;#34;) どちらの関数も、カラム名が変更された新しい DataFrame を返します。 元の DataFrame のカラム名は変更されませんが、データ自体は同じメモリ上の値を参照しています。
特定のカラムやインデックスの名前を変更する (rename) カラム名（列名）の変更 df2 = df.rename( columns={ &amp;#34;既存の列名1&amp;#34;: &amp;#34;新しい列名1&amp;#34;, &amp;#34;既存の列名2&amp;#34;: &amp;#34;新しい列名2&amp;#34;, &amp;#34;既存の列名3&amp;#34;: &amp;#34;新しい列名3&amp;#34; } ) インデックス名（行名）の変更 df2 = df.rename( index={ &amp;#34;既存の行名1&amp;#34;: &amp;#34;新しい行名1&amp;#34;, &amp;#34;既存の行名2&amp;#34;: &amp;#34;新しい行名2&amp;#34;, &amp;#34;既存の行名3&amp;#34;: &amp;#34;新しい行名3&amp;#34; } ) DataFrame#rename() 関数は、カラム名やインデックス名が変更された新しい DataFrame を返します。 元の DataFrame のカラム名やインデックス名は変更されませんが、データ自体は同じメモリ上の値を参照しています。</description></item><item><title>pandas チートシート - DataFrame のデータ抽出方法まとめ</title><link>https://maku77.github.io/p/rnai4ko/</link><pubDate>Sun, 27 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rnai4ko/</guid><description>pandas の DataFrame から部分データを抽出する方法のまとめです。
指定した行と列の抽出 基本的に、行と列の 「名称」による抽出には loc プロパティを使い、「数値」による抽出には iloc プロパティを使用します。 下記の例では、インデックス名（行名）に Y1 〜 Y5、カラム名（列名）に X1 〜 X5 が設定されているものとします。
カテゴリ コード 抽出のイメージ 戻り値の型 スカラー値 df.loc["Y3", "X2"]
df.iloc[2, 1] numpy.float64
など 1 行の抽出 df.loc["Y2"]
df.loc["Y2", :]
df.iloc[1]
df.iloc[1, :] Series df.loc[["Y2"]]
df.loc[["Y2"], :]
df.iloc[[1]]
df.iloc[[1], :] DataFrame 複数行の抽出 df.loc["Y2":"Y4"]
df.iloc[1:4]
df["Y2":"Y4"]
df[1:4] DataFrame df.head(2) DataFrame df.tail(2) DataFrame 1 列の抽出 df.loc[:, "X2"]
df.iloc[:, 1]
df["X2"] Series df.loc[:, ["X2"]]
df.iloc[:, [1]]
df[["X2"]] DataFrame 複数列の抽出 df.</description></item><item><title>Matplotlib の Axes、Figure、pyplot の関係を理解する</title><link>https://maku77.github.io/p/59ruo5m/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/59ruo5m/</guid><description>Figure と Axes Matplotlib の基本的な描画要素として、Figure と Axes があり、Figure の中に複数の Axes を配置できるようになっています。 次のプロット画像には、1 つの Figure の中に、2 つの Axes を配置しています。
図: Figure と Axes の関係 上記画像のコード import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] # Figure の作成 fig = plt.figure(facecolor=&amp;#34;lightskyblue&amp;#34;, layout=&amp;#34;tight&amp;#34;, dpi=72, figsize=(6, 3)) fig.suptitle(&amp;#34;Figure&amp;#34;) # Axes によるプロット ax = fig.subplots(1, 2) ax[0].set_title(&amp;#34;Axes 1&amp;#34;, loc=&amp;#34;left&amp;#34;, fontstyle=&amp;#34;oblique&amp;#34;, fontsize=&amp;#34;medium&amp;#34;) ax[0].plot(x, y) ax[1].set_title(&amp;#34;Axes 2&amp;#34;, loc=&amp;#34;left&amp;#34;, fontstyle=&amp;#34;oblique&amp;#34;, fontsize=&amp;#34;medium&amp;#34;) ax[1].</description></item><item><title>Python の dataclass デコレーターで簡単にデータクラスを定義する</title><link>https://maku77.github.io/p/xqkgvb6/</link><pubDate>Tue, 20 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xqkgvb6/</guid><description>dataclass デコレーターによるデータクラス定義の基本 Python の標準ライブラリが提供している dataclasses モジュールの dataclass デコレーターを使うと、少ないコードでデータクラス（データを扱うクラス）を定義することができます。
下記の NamedCounter クラスは 2 つのインスタンス変数（name と counter）を持つクラスの実装例ですが、通常はこのようにコンストラクタ（__init__ メソッド）の中でインスタンス変数を初期化すると思います。
通常のクラス定義方法 class NamedCounter: def __init__(self, name): self.name = name self.count = 0 def increment(self): self.count += 1 def __str__(self): return f&amp;#34;{self.name}: {self.count}&amp;#34; if __name__ == &amp;#34;__main__&amp;#34;: counter = NamedCounter(&amp;#34;hello&amp;#34;) print(counter) # hello: 0 counter.increment() print(counter) # hello: 1 これくらいならよいのですが、インスタンス変数（フィールド）が増えてくると、コンストラクタの記述が面倒になってきます。 クラス定義時に dataclass デコレーターを付けると、このような __init__ の定型処理を自動生成してくれます。 次の例では、dataclass デコレーターを使って、2 つのインスタンス変数 (name, count) を持つクラスを定義しています。 name と count はクラス変数（クラス属性）と同様の記法で定義していますが、dataclass デコレーターを付けた場合はインスタンス変数の定義とみなされることに注意してください。 つまり、name と count の値は、NamedCounter のインスタンスごとに異なる値を保持できます。</description></item><item><title>Python でハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (`hashlib`)</title><link>https://maku77.github.io/p/gn4cn3s/</link><pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gn4cn3s/</guid><description>Python の hashlib 標準ライブラリを使用すると、いろいろなタイプのハッシュ値を求めることができます。
バイトデータのハッシュ値を求める あるバイトデータのハッシュ値を求めるには、hashlib.sha1 や hashlib.sha256 などのコンストラクタでハッシュオブジェクトを生成し、hexdigest メソッドで 16 進数表記のハッシュ値を取得します。 次の例では、MD5、SHA-1、SHA-256 アルゴリズムを使って、b&amp;quot;HelloWorld&amp;quot; というバイトデータのハッシュ値を計算しています。
バイトデータのハッシュ値を求める import hashlib print(hashlib.md5(b&amp;#34;HelloWorld&amp;#34;).hexdigest()) print(hashlib.sha1(b&amp;#34;HelloWorld&amp;#34;).hexdigest()) print(hashlib.sha256(b&amp;#34;HelloWorld&amp;#34;).hexdigest()) 実行結果 68e109f0f40ca72a15e05cc22786f8e6 db8ac1c259eb89d4a131b253bacfca5f319d54f2 872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4 ハッシュ計算に使用するバイトデータは、update メソッドで追加していくことができます。
hash = hashlib.sha1() hash.update(b&amp;#34;Hello&amp;#34;) hash.update(b&amp;#34;World&amp;#34;) print(hash.hexdigest()) # =&amp;gt; db8ac1c259eb89d4a131b253bacfca5f319d54f2 # 以下のようにバイトデータを結合してから update しても結果は同じ hash = hashlib.sha1() hash.update(b&amp;#34;Hello&amp;#34; + b&amp;#34;World&amp;#34;) print(hash.hexdigest()) # =&amp;gt; db8ac1c259eb89d4a131b253bacfca5f319d54f2 文字列のハッシュ値を求める 文字列のハッシュ値を求めるには、エンコーディング形式を指定して、どのようなバイトデータとして扱うかを明確にする必要があります。 次の例では、文字列の encode メソッドで UTF-8 形式のバイトデータを取得しています。
文字列のハッシュ値を求める import hashlib str = &amp;#34;HelloWorld&amp;#34; bytes = str.encode(encoding=&amp;#34;utf-8&amp;#34;) print(hashlib.md5(bytes).hexdigest()) print(hashlib.sha1(bytes).hexdigest()) print(hashlib.sha256(bytes).hexdigest()) 実行結果 68e109f0f40ca72a15e05cc22786f8e6 db8ac1c259eb89d4a131b253bacfca5f319d54f2 872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4 ファイルのハッシュ値を求める 以下の file_sha256 関数は、指定したファイルの内容からハッシュ値を求めています。 ハッシュ値の計算にはバイトデータが必要なので、ファイルオープン時にバイトモード (&amp;quot;b&amp;quot;) を指定するのがポイントです。</description></item><item><title>Python でパスを指定したディレクトリからの相対パスに変換する (os.path.relpath)</title><link>https://maku77.github.io/p/o4a37zc/</link><pubDate>Fri, 02 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o4a37zc/</guid><description>os.path.relpath の使い方 Python 標準の os.path.relpath 関数 を使うと、パスを表す文字列を、特定のディレクトリからの相対パスに変換することができます。
import os # 元が絶対パスの場合 print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/&amp;#34;)) # =&amp;gt; a/b/c print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a&amp;#34;)) # =&amp;gt; b/c print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/&amp;#34;)) # =&amp;gt; b/c print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/b&amp;#34;)) # =&amp;gt; c print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/b/&amp;#34;)) # =&amp;gt; c print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/b/c&amp;#34;)) # =&amp;gt; . print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/b/c/&amp;#34;)) # =&amp;gt; . print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/b/c/d&amp;#34;)) # =&amp;gt; .. print(os.path.relpath(&amp;#34;/a/b/c&amp;#34;, &amp;#34;/a/b/c/d/e&amp;#34;)) # =&amp;gt; ../.. # 元が相対パスの場合（基本的に同上） print(os.path.relpath(&amp;#34;a/b/c&amp;#34;, &amp;#34;a&amp;#34;)) # =&amp;gt; b/c print(os.path.relpath(&amp;#34;a/b/c&amp;#34;, &amp;#34;a/&amp;#34;)) # =&amp;gt; b/c print(os.path.relpath(&amp;#34;a/b/c&amp;#34;, &amp;#34;a/b&amp;#34;)) # =&amp;gt; c print(os.</description></item><item><title>Python でテンポラリファイル／ディレクトリを作成する (tempfile)</title><link>https://maku77.github.io/p/co7o5k2/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/co7o5k2/</guid><description>テンポラリディレクトリを作成する 自動削除されるテンポラリディレクトリ (TemporaryDirectory) Python の tempfile モジュールが提供する TemporaryDirectory クラスを使用して、テンポラリディレクトリを作成することができます。 TemporaryDirectory オブジェクトを with 文に渡すと、as 節の変数として、作成されたテンポラリディレクトリのパスを取得できます。
テンポラリディレクトリの作成 import os import tempfile with tempfile.TemporaryDirectory() as dirname: print(dirname) # =&amp;gt; /tmp/tmp98olubfz print(os.path.isdir(dirname)) # =&amp;gt; True # with を抜けるとテンポラリディレクトリは既に削除されている print(os.path.isdir(dirname)) # =&amp;gt; False テンポラリディレクトリは、with ブロックの実行コンテキストを抜けるときに自動的に削除されることに注意してください（__exit__ メソッドの実装で cleanup メソッドが呼ばれており、自動的にディレクトリが削除される仕組みになっています）。 よって、Python プログラムの中で、明示的にテンポラリディレクトリを削除する必要はありません。
自動削除されないテンポラリディレクトリ (mkdtemp) 実行コンテキストを抜けても自動削除されないテンポラリディレクトリを作成したい場合は、tempfile.TemporaryDirectory クラスの代わりに、tempfile.mkdtemp 関数を使用します。 作成されたテンポラリディレクトリは、プログラムを終了してからユーザーが手動で削除しなければいけないので、分かりやすいディレクトリに作成しておいた方がよいでしょう。 次の例では、カレントディレクトリ (.) に、.tmp サフィックスの付いたテンポラリディレクトリを作成しています。
（自動削除されない）テンポラリディレクトリの作成 import tempfile dirname = tempfile.mkdtemp(dir=&amp;#34;.&amp;#34;, suffix=&amp;#34;.tmp&amp;#34;) print(dirname) # =&amp;gt; ./tmpu57g67kg.tmp この Python プログラムを実行終了した後にも、テンポラリディレクトリが残っていることを確認してください。 ちなみに、dir、prefix, suffix といったパラメーターは、tempfile.</description></item><item><title>Python の argparse モジュールでコマンライン引数を扱う</title><link>https://maku77.github.io/p/o6q8p6m/</link><pubDate>Thu, 01 Jun 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o6q8p6m/</guid><description>Python が標準ライブラリとして提供している argparse モジュール を使用すると、複雑なコマンドライン引数を扱うスクリプトをシンプルに実装することができます。 単純に sys.argv を使ってコマンドライン引数を扱う方法と比べ、argparse を使うと次のような利点があります。
Linux スタイルの短いオプション (-o) や長いオプション (--output) を簡単に定義できます ユーザーが入力した値を直感的なプロパティとして参照できます（例: args.output）。 ヘルプメッセージを自動で構築してくれます（-h (--help) オプションはデフォルトで生成してくれます） 各オプションの型を定義できます（数値型オプションに文字列が指定されたときに自動でエラーにしてくれます） サブコマンドを簡単に実装できます（例: sample.py &amp;lt;サブコマンド&amp;gt; &amp;lt;引数1&amp;gt; &amp;lt;引数2&amp;gt;） ArgumentParser の基本 argparse モジュールは、次のような流れで使用します。
ArgumentParser クラスのインスタンスを生成する add_argument メソッドでコマンドライン引数の定義を追加していく parse_args メソッドでパースして Namespace オブジェクトを取得する Namespace オジェクトのプロパティでユーザー入力を参照する 次のスクリプトでは、-i (--input) オプションと、-o (--output) オプションを定義しています。
main.py import argparse # コマンドライン引数の仕様を定義してユーザー入力をパースする parser = argparse.ArgumentParser() parser.add_argument(&amp;#34;-i&amp;#34;, &amp;#34;--input&amp;#34;, help=&amp;#34;input file&amp;#34;) parser.add_argument(&amp;#34;-o&amp;#34;, &amp;#34;--output&amp;#34;, help=&amp;#34;output file&amp;#34;, default=&amp;#34;out.txt&amp;#34;) args = parser.parse_args() # =&amp;gt; argparse.Namespace # ユーザーが入力した値を表示する print(f&amp;#34;Input file: {args.</description></item><item><title>Python の import 時のモジュールの検索パスを調べる (sys.path)</title><link>https://maku77.github.io/p/o4m4jyg/</link><pubDate>Mon, 29 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o4m4jyg/</guid><description>モジュールの検索パスのリストは sys.path Python でモジュールをインポートするには、import モジュール名 のように記述しますが、このときにどのディレクトリのモジュールが検索されるかは、sys.path 変数の値を見ると分かります。 sys.path は検索パスを示す文字列のリスト (list[str]) です。
モジュールの検索パスを列挙する import sys import pprint pprint.pprint(sys.path) 実行結果 [&amp;#39;/Users/maku/myapp&amp;#39;, &amp;#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python310.zip&amp;#39;, &amp;#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10&amp;#39;, &amp;#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload&amp;#39;, &amp;#39;/Users/maku/myapp/.venv/lib/python3.10/site-packages&amp;#39;] sys.path にはどのような検索パスが含まれているか？ sys.path 変数には、自動的に次のようなパスが登録されます。
起動したスクリプトと同じディレクトリ（ただし、python をインタラクティブモードで起動したときは、カレントディレクトリを示す空文字 '' になります） 環境変数 PYTHONPATH に指定したディレクトリ Python インストーラに応じたデフォルトディレクトリ（標準ライブラリのパスなど） 注目すべきは、sys.path の先頭に追加されるパスで、これは起動されたスクリプトが格納されているディレクトリのパスになっています。 例えば、python ~/myapp/main.py と実行したときは、自動的に ~/myapp が検索パスに追加されるため、~/myapp 以下に配置したモジュール (*.py) をインポートできるようになっています。
main.py import mymod # ~/myapp/mymod.py が検索される モジュールの検索パスを追加する PYTHONPATH 環境変数を設定する方法 PYTHONPATH 環境変数に設定したディレクトリパスは、自動的に sys.path に反映されてモジュールの検索パスとして使われます。
Linux や macOS の場合 $ export PYTHONPATH=/path/to/lib1:/path/to/lib2:$PYTHONPATH パスの区切り文字は Linux や macOS ではコロン (:) ですが、Windows の場合はセミコロン (;) になることに注意してください（PATH 環境変数の指定方法と同じです）。</description></item><item><title>HTML ファイルや Markdown ファイルをプレーンテキストに変換する (unstructured)</title><link>https://maku77.github.io/p/uivwecs/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uivwecs/</guid><description>unstructured ライブラリとは Python の unstructured ライブラリは、様々な形式のデータを機械学習システムに投入する前の変換処理などを行ってくれるライブラリです。 例えば、非構造化データ（HTML や Markdown）には、機械学習には必要のないタグが含まれていたりしますが、unstructured を使ってテキストだけを取り出すことができます。
Unstructured-IO/unstructured: Open source libraries and APIs to build custom preprocessing pipelines for labeling, training, or production machine learning pipelines. 現在、ChatGPT などの大規模言語モデル (LLM) を利用したチャットシステムが注目を浴びていますが、社内ドキュメントなどの情報と統合するためには、ユーザー入力から類似ドキュメントを検索する仕組みが必要になります。 このために使用されるのが、テキスト間の類似度に基づいた検索システムであるベクトル検索 DB などです。 そこに登録するドキュメントのベクトルデータ（Embeddings）は、できるだけクリーンなテキストから生成することが望ましいのですが、unstructured ライブラリを使えば、様々な形式のデータからそういったテキストを作成できます。
unstructured ライブラリのインストール unstructured の Installation マニュアル に従って、必要なライブラリをインストールします。
unstructured ライブラリのインストール $ pip install unstructured 後述のプログラムを実行したときに、tabulate が足りないと言われたので入れました。 このあたりは試行錯誤です。
$ pip install tabulate HTML ファイルをプレーンテキストに変換してみる サンプルの入力ファイルとして、次のような HTML ファイルを用意します。 html や body タグを省略していますが、これも正しい HTML5 文書です。
input.html（入力ファイル） &amp;lt;!</description></item><item><title>Python で URL 文字列を各パートに分割する (urllib.parse.urlparse)</title><link>https://maku77.github.io/p/rr2ahpx/</link><pubDate>Fri, 26 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rr2ahpx/</guid><description>Python の標準ライブラリの urllib.parse.urlparse 関数を使用すると、URL 形式の文字列から ParseResult オブジェクトを生成することができます。 ParseResult オブジェクトの各プロパティを参照することで、URL の各パート（スキーム、ドメイン、パス、クエリ文字列など）を取り出すことができます。
sample.py（URL 文字列を解析する） from urllib.parse import urlparse url = &amp;#34;https://example.com/p/abcdefg/?foo=1&amp;amp;bar=2#top&amp;#34; parsed_url = urlparse(url) # ParseResult オブジェクトを生成する print(parsed_url.scheme) # =&amp;gt; https print(parsed_url.netloc) # =&amp;gt; example.com print(parsed_url.path) # =&amp;gt; /p/abcdefg/ print(parsed_url.query) # =&amp;gt; foo=1&amp;amp;bar=2 print(parsed_url.fragment) # =&amp;gt; top</description></item><item><title>Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する</title><link>https://maku77.github.io/p/bp9q8p6/</link><pubDate>Thu, 25 May 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bp9q8p6/</guid><description>サイトマップとは？ Web サイトのサイトマップファイル (sitemap.xml) には、次のような形で全ページの URL 情報が記載されています。 このファイルは、主に Google などの検索エンジンのために提供されています。
sitemap.xml &amp;lt;urlset xmlns=&amp;#34;http://www.sitemaps.org/schemas/sitemap/0.9&amp;#34; xmlns:xhtml=&amp;#34;http://www.w3.org/1999/xhtml&amp;#34;&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page1/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2021-01-01&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page2/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2022-02-02&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;url&amp;gt; &amp;lt;loc&amp;gt;http://example.com/page3/&amp;lt;/loc&amp;gt; &amp;lt;lastmod&amp;gt;2023-03-03&amp;lt;/lastmod&amp;gt; &amp;lt;/url&amp;gt; &amp;lt;/urlset&amp;gt; sitemap.xml から URL の一覧を取得する 次の Python スクリプトは、上記のような sitemap.xml ファイルから、すべての URL 情報を抽出します。 sitemap.xml ファイル自体のダウンロードには urlopen を使用し、XML のパースには ElementTree を使用しています。
extract-urls.py from urllib.request import urlopen from xml.etree import ElementTree url = &amp;#34;https://example.com/sitemap.xml&amp;#34; def fetch(url: str) -&amp;gt; str: &amp;#34;&amp;#34;&amp;#34;指定した URL のリソースを文字列で取得します。&amp;#34;&amp;#34;&amp;#34; with urlopen(url) as res: return res.</description></item><item><title>Python でファイルやディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move)</title><link>https://maku77.github.io/p/wyxzbdw/</link><pubDate>Tue, 10 Aug 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wyxzbdw/</guid><description>ファイルやディレクトリのコピーや移動を行うには、Python 標準ライブラリの shutil モジュール が提供する高水準のファイル操作 API を利用するのが簡単です。
ファイルをコピーする (shutil.copyfile, shutil.copy) shutil.copyfile 関数 shutil.copyfile 関数 で単一のファイルをコピーできます。
import shutil import sys try: shutil.copyfile(&amp;#39;src.txt&amp;#39;, &amp;#39;dst.txt&amp;#39;) except Exception as e: print(&amp;#39;Error: {0}&amp;#39;.format(e), file=sys.stderr) 同名のファイルがすでに存在する場合（上記の場合は dst.txt）は上書きされます。 shutil.copyfile 関数は次のようなエラーを発生させる可能性があります。
IsADirectoryError &amp;hellip; コピー先として指定したファイル名と同名のディレクトリが存在する場合。 OSError &amp;hellip; 指定したファイル名で書き込めない場合（バージョン 3.3 以降）。 SameFileError &amp;hellip; コピー元とコピー先のファイル名が同じ場合（バージョン 3.4 以降）。 FileNotFoundError &amp;hellip; 存在しないディレクトリ階層（aaa/bbb/dst.txt など）にコピーしようとした場合。 shutil.copy 関数 既存のディレクトリ以下に同じファイル名でコピーしたいときは、shutil.copyfile の代わりに shutil.copy 関数 を使用します。
# dst という名前でコピー、あるいは dst ディレクトリ以下にコピー shutil.copy(&amp;#39;src.txt&amp;#39;, &amp;#39;dst&amp;#39;) 上記のように実行すると、dst ディレクトリがない場合は dst というファイル名でコピーされ、dst ディレクトリが存在する場合は dst/src.txt としてコピーされます。</description></item><item><title>Python の dictionary の内部的な要素順序を変更する (dict, OrderedDictionary)</title><link>https://maku77.github.io/p/vexfweu/</link><pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vexfweu/</guid><description>dict が保持する要素の順序 Python の辞書オブジェクト (dict) は要素の追加順序を保持しており、要素のイテレート時や print での出力時はこの順序で出力されるようになっています（Python 3.7 以降）。
sample.py book = { &amp;#39;id&amp;#39;: &amp;#39;123&amp;#39;, &amp;#39;authors&amp;#39;: [&amp;#39;Author 1&amp;#39;], &amp;#39;title&amp;#39;: &amp;#39;Title 1&amp;#39; } print(book) 出力結果 {&amp;#39;id&amp;#39;: &amp;#39;123&amp;#39;, &amp;#39;authors&amp;#39;: [&amp;#39;Author 1&amp;#39;], &amp;#39;title&amp;#39;: &amp;#39;Title 1&amp;#39;} 単純にキー名のアルファベット順にループ処理したい場合は、例えば次のようにします。
キーのリストをソート for key in sorted(book.keys()): print(&amp;#39;%s: %s&amp;#39; % (key, book[key])) でもこれは、出力時に一時的なキーリストをソートしているだけで、辞書オブジェクト内部の要素順序を制御しているわけではありません。 次のようにすれば、あるキーの要素を辞書オブジェクト内で末尾に持ってくることができます。
book[&amp;#39;id&amp;#39;] = book.pop(&amp;#39;id&amp;#39;) 単純に id キーの要素を取り出して、再度辞書オブジェクトに追加しているだけです (^^;
この後、print(book) とすると、id 要素が最後に出力されます。 もっといい方法があるかもしれませんが、この仕組みだけである程度柔軟な並び替えが可能です。 例えば、次の sort_dict 関数は、辞書オブジェクト内部の要素をキー名順に並び替える関数ですが、priority_keys 引数でキー名のリストを渡すと、それらのキーは優先的にその順番で先頭に並べられます。
sort_dict 関数の実装例 def sort_dict(d, priority_keys=()): &amp;#34;&amp;#34;&amp;#34; 辞書オブジェクト d の要素を内部的にキー名でソートします。 ただし、priority_keys にキー名のリストが指定されたときは、 そのキーを優先的に先頭に並べます。 &amp;#34;&amp;#34;&amp;#34; keys1 = list(filter(lambda k: k in d, priority_keys)) keys2 = sorted(d.</description></item><item><title>Python でテキストファイルを書き込む (write, writelines)</title><link>https://maku77.github.io/p/nmv4cjr/</link><pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nmv4cjr/</guid><description>テキストファイルを一行ずつ書き込む (write) Python でファイル書き込み用のファイルオブジェクトを作成するには、open 関数 の mode パラメータで下記のいずれかの値を設定してファイルをオープンします。
文字 意味 ファイルが存在しない場合の動き ファイルが存在する場合の動き w 上書き 新規作成 内容をクリアして上書き a 追記 新規作成 末尾にテキストを追加 x 排他生成 新規作成 オープンに失敗する (FileExistsError) 最もよく使うのは、w による上書き用のオープンです。 次の例では、output.txt という名前のファイルを作成（あるいは上書き）して、2 つの行を書き込んでいます。
テキストファイルの作成 f = open(&amp;#39;output.txt&amp;#39;, mode=&amp;#39;w&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;, newline=&amp;#39;\n&amp;#39;) f.write(&amp;#39;Hello\n&amp;#39;) f.write(&amp;#39;World\n&amp;#39;) f.close() エンコーディング形式 (encoding) は、省略するとプラットフォーム依存になるので、明示的に utf-8 を指定しておいた方がよいでしょう。
改行の扱い方 (newline) は、省略すると write() 関数での \n の書き込みが、プラットフォーム依存の改行コードの書き込みという扱いになります。 必ず Unix の改行コード (LF) で書き込みたいということであれば、上記のように \n あるいは '' を指定しておきましょう。 この指定により、write() 関数での \n が LF、\r\n が CR+LF として書き込まれるようになります。
ファイルオブジェクトは最後に close() してリソースを解放する必要がありますが、 with を使って close() を自動化することができます。 基本的にはこの書き方をしておけばよいです。</description></item><item><title>Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する</title><link>https://maku77.github.io/p/wewevcs/</link><pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wewevcs/</guid><description>urllib.request.urlopen() が返した HTTPResponse オブジェクトの info() メソッドを呼び出すと、HTTP レスポンスのヘッダ情報を取得することができます。 ヘッダ情報は HTTPMessage オブジェクト として返されますが、これは通常の辞書オブジェクトと同様に使用することができます。 詳しくは、HTTPMessage の親クラスである email.message.Message の定義を参照してください。
次の例では、Web サイトにアクセスしたときの HTTP レスポンスヘッダーを取得して表示しています。
sample.py import urllib.request url = &amp;#39;https://yahoo.co.jp/&amp;#39; try: with urllib.request.urlopen(url) as res: # HTTP レスポンスのヘッダ情報を取得 headers = res.info() print(type(headers)) #=&amp;gt; http.client.HTTPMessage print() print(headers) # 下記は Body 部分の取得 # text = res.read().decode(&amp;#39;utf-8&amp;#39;) # print(text) except urllib.error.URLError as err: print(&amp;#39;Could not access: %s&amp;#39; % url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) 実行結果 &amp;lt;class &amp;#39;http.client.HTTPMessage&amp;#39;&amp;gt; Cache-Control: private, no-cache, no-store, must-revalidate Content-Type: text/html; charset=UTF-8 Date: Mon, 01 Jun 2020 06:07:42 GMT Expires: -1 Pragma: no-cache Set-Cookie: B=1sg6o4tfd96pe&amp;amp;b=3&amp;amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.</description></item><item><title>Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode)</title><link>https://maku77.github.io/p/w7p7n4j/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w7p7n4j/</guid><description>Python の標準モジュールとして提供されている urllib.parse を使用すると、任意の文字列を URL 内で扱えるようにエンコード／デコードすることができます。 ユーザーが入力したテキストや、日本語を含むテキストをエスケープ処理して URL として扱いたいときに使用できます。
文字列を URL エンコードする (quote) 任意の文字列を URL として扱いたいときは、urllib.parse.quote 関数 を使うと、エスケープすべき文字を %xx という形に変換してくれます。
from urllib.parse import quote print(quote(&amp;#39;あ&amp;#39;)) #=&amp;gt; &amp;#39;%E3%81%82&amp;#39; print(quote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(quote(&amp;#39;A B C&amp;#39;)) #=&amp;gt; &amp;#39;A%20B%20C&amp;#39; print(quote(&amp;#39;A/B/C&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; 上記の結果からわかるように、quote 関数はデフォルトではスラッシュ (/) をエスケープしません。 これは、変換しない文字を示すオプションパラメータ safe のデフォルト値が '/' になっているからです。 次のようにすると、スラッシュが %2F にエスケープされるようになります。
print(quote(&amp;#39;A/B/C&amp;#39;, safe=&amp;#39;&amp;#39;)) #=&amp;gt; &amp;#39;A%2FB%2FC&amp;#39; URL の特定階層のパス名をユーザーに入力させるようなケースで使用できます。
URL をデコードする (unquote) 逆に、URL エンコードされた文字列をデコードして元に戻すには、urllib.parse.unquote 関数 を使用します。
from urllib.parse import unquote print(unquote(&amp;#39;%E3%81%82&amp;#39;)) #=&amp;gt; &amp;#39;あ&amp;#39; print(unquote(&amp;#39;ABC&amp;#39;)) #=&amp;gt; &amp;#39;ABC&amp;#39; print(unquote(&amp;#39;A%20B%20C&amp;#39;)) #=&amp;gt; &amp;#39;A B C&amp;#39; print(unquote(&amp;#39;A%2FB%2FC&amp;#39;)) #=&amp;gt; &amp;#39;A/B/C&amp;#39; クエリ文字列を作成する (urlencode) HTTP の GET リクエストを送るときに、URL の末尾に次のようにクエリ文字列を付加したいことがあります。</description></item><item><title>.env ファイルで環境変数を設定する (python-dotenv)</title><link>https://maku77.github.io/p/gzo8d7y/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gzo8d7y/</guid><description>python-dotenv モジュールの概要 python-dotenv モジュールを使用すると、Python プログラム実行時に次のような .env ファイルを読み込んで、環境変数を設定することができます。
.env MYAPP_USER=maku MYAPP_PASS=makupass MYAPP_CONFIG=${HOME}/${MYAPP_USER}/config 上記の例のように、${HOME} という形で環境変数の値を展開することもできます。
特定のプログラムを実行するために、いちいち OS の環境変数を設定するのを嫌がるユーザーはたくさんいます。 あなたのプログラムが何らかの環境変数を必要としているのであれば、.env ファイルによる設定手段も提供しておくと親切です。 .env の仕組みは Python に限ったものではなく、いろいろな言語で採用されています。
参考: Node.js プログラムで .env ファイルを使用する python-dotenv モジュールのインストール python-dotenv モジュールは pip コマンドでインストールできます。
$ python3 -m pip install python-dotenv ☝️ venv 仮想環境を使う システム全体の Python 実行環境を汚したくない場合は、次のように venv 仮想環境を作成 して、そこにインストールしましょう。
$ python3 -m venv venv $ source venv/bin/activate (venv) $ pip install python-dotenv 仮想環境は次のように抜けられます。
(venv) $ deactivate python-dotenv の使い方 .env ファイルの内容を環境変数に反映する .env ファイルを読み込むのはとても簡単で、load_dotenv() を呼び出すだけです。 次の Python スクリプトでは、同じディレクトリ（あるいは、より上位のディレクトリ）に置かれた .</description></item><item><title>Python の実行環境を venv で切り替える</title><link>https://maku77.github.io/p/wozpogm/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wozpogm/</guid><description>venv モジュールは、Python の仮想実行環境を作成するための標準モジュールです。 Python 3.2 までは virtualenv という外部パッケージを使用していましたが、Python 3.3 以降は標準で同等機能を提供する venv パッケージ を使用できます。
なぜ仮想環境が必要か？ Python で作成されたプログラムは、pip install で外部モジュールをインストールすることを前提に作成されたものがたくさんあります。 Python プログラムを実行するために、何も考えずに pip install を繰り返していると、いろいろなバージョンのモジュールがインストールされてしまい、実行環境がぐちゃぐちゃになってしまいます。 あるプログラムを動作させるために pip install すると、別のプログラムが動作しなくなるといったことが起こります。
venv を使って仮想環境を作ると、その環境内に閉じて pip install することができるようになります。 例えば、app1 と app2 という 2 つの Python プログラム用に別々の仮想環境を作って、それぞれのプログラムに必要なパッケージをインストールするということができます。
プロジェクト用の仮想環境を作成する／削除する 仮想環境を作成する 仮想環境を作成するには、次のようなコマンドを実行します。 仮想環境はディレクトリの形で作成され、その中に必要なファイルが自動生成されます。 ここでは、python3 を使っていますが、環境によっては python に置き換えてください（Windows の場合は py だったりします）。
仮想環境の作成 $ python3 -m venv &amp;lt;仮想環境ディレクトリ&amp;gt; 仮想環境ディレクトリの名前としては、一般的に venv や .venv が使われます。 このディレクトリは Git にコミットするものではないので、好きな方を選べばよいです。 プロジェクトごとに仮想環境を作成するのであれば、プロジェクトのルートに仮想環境ディレクトリを作成するのがよいでしょう。 例えば、myapp プロジェクト用の仮想環境を作るには次のようにします。
仮想環境ディレクトリ venv を作成 $ mkdir ~/myapp $ cd ~/myapp $ python3 -m venv venv この仮想環境ディレクトリには、次のようなファイル群が格納されていて、仮想環境内でインストールしたパッケージなどはこの中で管理されます。</description></item><item><title>Python で環境変数を参照する (os.getenv, os.environ)</title><link>https://maku77.github.io/p/y8hs5w6/</link><pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y8hs5w6/</guid><description>指定した環境変数を取得する Python で OS の環境変数を取得するには、os.getenv 関数を呼び出すか、os.environ 辞書オブジェクトを参照します。
例: 環境変数 PATH の値を表示 import os print(os.getenv(&amp;#34;PATH&amp;#34;)) print(os.environ[&amp;#34;PATH&amp;#34;]) 両者の違いは、存在しないキーを指定した場合に os.getenv がデフォルトで None を返すのに対し、os.environ は KeyError 例外を投げるという点です（辞書オブジェクト参照時の共通の振る舞いです）。 通常は os.getenv 関数を使った方が、例外をハンドルせずに済むのでシンプルなコードになります。
環境変数が設定されているかどうかで分岐 import os key = os.getenv(&amp;#34;ACCESS_KEY&amp;#34;) if key: print(&amp;#34;環境変数が見つかった場合の処理&amp;#34;) if not key: print(&amp;#34;環境変数が見つからない場合の処理&amp;#34;) ただし、複数の環境変数を参照する場合は、os.environ を使って一度に例外処理した方が分かりやすくなることがあります。
いずれかの環境変数が設定されていない場合に終了する try: openai.api_base = os.environ[&amp;#34;OPENAI_API_BASE&amp;#34;] openai.api_key = os.environ[&amp;#34;OPENAI_API_KEY&amp;#34;] except KeyError as e: sys.exit(f&amp;#34;Environment variable not set: {e}&amp;#34;) os.getenv 関数の第 2 パラメータ (default) では、キーが存在しな場合のデフォルト値を指定することが可能です。
環境変数が設定されていないときにデフォルト値を使う import os env = os.getenv(&amp;#34;MYAPP_ENV&amp;#34;, default=&amp;#34;development&amp;#34;) print(env) ちなみに、os.</description></item><item><title>Python で 2 つのリストに重複する要素を抽出する (set と &amp;)</title><link>https://maku77.github.io/p/58ctg7k/</link><pubDate>Mon, 25 Nov 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/58ctg7k/</guid><description>Python では 2 つの set インスタンス同士で &amp;amp; 演算を行うと、両方のセットに含まれる要素を抽出することができます（積集合）。
s1 = {1, 2, 3, 4} s2 = {3, 4, 5, 6} print(s1 &amp;amp; s2) #=&amp;gt; {3, 4} 参考: set オブジェクトで集合演算を行う リストやタプルにはこのような演算子は実装されていないため、リストやタプル同士でこういった演算を行うには、一度 set オブジェクトに変換する必要があります。
l1 = [1, 2, 3, 4] l2 = [3, 4, 5, 6] s1 = set(l1) s2 = set(l2) print(s1 &amp;amp; s2) #=&amp;gt; {3, 4} 重複要素があるかのチェックだけを行いたい場合は、&amp;amp; 演算の結果求められたセットを条件式として評価すれば OK です（Python では空のセットを偽、それ以外のセットを真として扱います）。
if s1 &amp;amp; s2: print(&amp;#34;重複要素があります&amp;#34;)</description></item><item><title>Python で ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive)</title><link>https://maku77.github.io/p/euevcsa/</link><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/euevcsa/</guid><description>Python の標準ライブラリである shutil を使用すると、複数のファイルを含むディレクトリから ZIP アーカイブを簡単に作成することができます（1 ファイル単位でアーカイブに追加するファイルを細かく制御したいときは、zipfile モジュールを使用します）。
ディレクトリを ZIP 圧縮する ZIP ファイルの作成 shutil.make_archive 関数 を使用すると、指定したディレクトリ内のファイルを丸ごと ZIP 圧縮できます。 次の例では、src ディレクトリ内のファイルを backup.zip ファイルに圧縮しています。
zip.py（src ディレクトリから backup.zip を作成） import shutil import sys try: shutil.make_archive(&amp;#39;backup&amp;#39;, format=&amp;#39;zip&amp;#39;, root_dir=&amp;#39;src&amp;#39;) except Exception as e: print(e, file=sys.stderr) ZIP ファイルの上書き確認をする shutil.make_archive 関数は、すでに ZIP ファイルがある場合には、問答無用で上書き保存してしまうようです。 下記の create_zip 関数は、同名の ZIP ファイルが存在している場合に確認プロンプトを表示するようにしています。
上書き確認付きの ZIP アーカイブ化関数 import shutil import sys import os def create_zip(zip_filename, src_dir): &amp;#34;&amp;#34;&amp;#34; src_dir ディレクトリ内のファイル群を、 zip_filename で指定した名前の ZIP ファイルにアーカイブします。 すでに同名の ZIP ファイルが存在する場合は、確認プロンプトを表示します。 &amp;#34;&amp;#34;&amp;#34; # 上書き確認 if os.</description></item><item><title>Python でドキュメンテーションコメント (docstring) を記述する</title><link>https://maku77.github.io/p/y2biqz7/</link><pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/y2biqz7/</guid><description>Docstring とは？ Python のコードに docstring フォーマットでコメントを記述しておくと、いろいろなツールから API ドキュメントとして参照できるようになります。 例えば、Python 用の統合開発環境 (IDE) におけるコード補完時に、ヒントとして関数の使用方法が表示されます。
下記は PEP 257 &amp;ndash; Docstring Conventions に記述されている docstring の書き方の例です。
def complex(real=0.0, imag=0.0): &amp;#34;&amp;#34;&amp;#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) &amp;#34;&amp;#34;&amp;#34; if imag == 0.0 and real == 0.0: return complex_zero ... docstring はこのように 3 つのクォート (&amp;quot;&amp;quot;&amp;quot;) で囲んで記述します。 docstring コメントは関数の内部に記述する ところがポイントです。 このあたりは、関数の外側にドキュメンテーションコメントを記述する Java や C# などとは異なっています。</description></item><item><title>Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする</title><link>https://maku77.github.io/p/i4zkqye/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i4zkqye/</guid><description>リクエストごとにヘッダを設定する (Request) urllib.request.Request オブジェクトの add_header メソッドや、headers プロパティを使用すると、HTTP リクエスト時のヘッダ情報を設定することができます。 あとは、urllib.request.urlopen で HTTP リクエストを送信するとき、URL の代わりに Request オブジェクトを渡せば、ヘッダ付きのリクエストを送ることができます。
import urllib.request def create_request(): req = urllib.request.Request(&amp;#39;https://example.com/myapi&amp;#39;) req.add_header(&amp;#39;Referer&amp;#39;, &amp;#39;http://www.python.org/&amp;#39;) req.add_header(&amp;#39;User-Agent&amp;#39;, &amp;#39;Mozilla/5.0&amp;#39;) return req if __name__ == &amp;#39;__main__&amp;#39;: req = create_request() with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) 上記の例では、Request#add_header() メソッドを使って、ヘッダ情報を 1 つずつ付加しています。 Request#headers プロパティを使用すれば、複数のヘッダ情報をディクショナリ形式でまとめて設定することができます。
req.headers = { &amp;#39;Referer&amp;#39;: &amp;#39;http://www.python.org/&amp;#39;, &amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.0&amp;#39;, } すべてのリクエストに共通のヘッダを設定する (OpenerDirector) Request オブジェクトは URL まで含んでいるため、アクセス先の URL が変わるたびに生成しなおす必要があります。 一方、OpenerDirector を使用すると、リクエスト時のヘッダ情報などはそのままで、URL だけを変更してアクセスすることができます。
import urllib.request def create_opener(): opener = urllib.</description></item><item><title>Python で標準エラー出力へ出力する (sys.stderr)</title><link>https://maku77.github.io/p/m3si4w6/</link><pubDate>Sun, 14 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m3si4w6/</guid><description>標準エラー出力への出力 Python の print の出力先を標準エラー出力 (STDERR) にするには、file オプションで sys.stderr を指定します。
標準エラー出力への出力 import sys # ... if not is_valid_config(): print(&amp;#34;Error: invalid configuration&amp;#34;, file=sys.stderr) sys.exit(1) ちなみに、file 引数には write メソッドを持っているオブジェクトを渡せるようになっています。 sys.stderr オブジェクトも write メソッドを持っているので、上記のように file 引数に渡すことができます。
上記の例では、標準エラーにメッセージ出力をして、さらに sys.exit(1) でプログラムをエラー終了させていますが、実はこの処理は、sys.exit 関数にエラーメッセージを渡すことで 1 行で記述できます。
標準エラーへ出力してエラー終了する sys.exit(&amp;#34;Error: invalid configuration&amp;#34;) コラム: Python2 までの方法 Python2 までは下記のように標準エラー出力に出力することができました。
古い Python2 のやり方 import sys print &amp;gt;&amp;gt; sys.stderr, &amp;#39;エラーメッセージ&amp;#39;</description></item><item><title>Python の実行環境を virtualenv で切り替える（Python 3.2 以前）</title><link>https://maku77.github.io/p/yqjs3aw/</link><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yqjs3aw/</guid><description>virtualenv コマンドを使用すると、仮想的な Python の実行環境を作成することができます。 （追記）Python 3.3 以降は、virtualenv と同様の機能を提供する venv モジュールが標準搭載されたので、そちらを使うようにしましょう。
Python の実行環境を切り替えて使用する (venv) virtualenv とは Virtualenv Python 製のツールを使おうとすると、使用可能な Python のバージョンが制限されていたり、依存する Python パッケージを pip コマンドでたくさんインストールしなければいけなかったりします。 こういったツールを実行するために、パッケージをどんどんインストールしていくと、PC 内の Python 環境がぐちゃぐちゃになってしまいます（システムの site-packages ディレクトリに大量のパッケージがインストールされて管理できなくなる）。
そこで便利なのが、独立した Python 環境を作成することができる virtualenv コマンドです。 virtualenv で作成した仮想環境の中では、特定のバージョンの Python を使用することができ、閉じた環境内に Python パッケージをインストール (pip install) することができます。 もし、その環境が必要なくなったら、仮想環境ごと削除してしまえば、PC 内のグローバルな Python 実行環境はクリーンなままです。
例えば、何らかの Python 製ツール app があったとして、そのツールを使用するにはいくつかの Python パッケージをインストールしなければならないとします。 virtualenv を使用して、その Python 製ツールを使用するための環境を作る流れは以下のようになります。
app ディレクトリに移動する (cd app) app 用の Python 仮想環境を作成する (virtualenv 環境名) 仮想環境に入る (source 環境名/bin/activate) app に必要な Python パッケージをインストールする (pip install XXX) app を使う (python app.</description></item><item><title>Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re)</title><link>https://maku77.github.io/p/xwog7ip/</link><pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xwog7ip/</guid><description>replace_files.py 複数のテキストファイル内の文字列を一気に置換してしまう Python スクリプトの実装例を紹介します。 ここでは、カレントディレクトリ以下の Markdown ファイル (.md) 内の時刻情報を書き換えてみます。 置換対象のテキストは、下記のような日付情報を表すテキストです（created: の部分を date: に置き換えます）。
（置換前のテキスト）created: &amp;quot;2018-01-01&amp;quot; （置換後のテキスト）date: &amp;quot;2018-01-01&amp;quot; replace_files.py import glob import re GLOB = &amp;#39;**/*.md&amp;#39; REPLACE_FROM = re.compile(r&amp;#39;created: (\d{4}-\d{2}-\d{2})&amp;#39;) REPLACE_TO = r&amp;#39;date: &amp;#34;\1&amp;#34;&amp;#39; def write_lines(filename, lines): with open(filename, &amp;#39;w&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) as f: f.write(lines) def read_lines(filename): with open(filename, encoding=&amp;#39;utf-8&amp;#39;) as f: return f.read() def process_file(filename): src_lines = read_lines(filename) dst_lines = REPLACE_FROM.sub(REPLACE_TO, src_lines) if src_lines == dst_lines: print(filename) else: write_lines(filename, dst_lines) print(filename + &amp;#39;: CHANGED&amp;#39;) if __name__ == &amp;#39;__main__&amp;#39;: for filename in glob.</description></item><item><title>NumPy 配列 (ndarray) の作成方法まとめ</title><link>https://maku77.github.io/p/htducs9/</link><pubDate>Mon, 27 Feb 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/htducs9/</guid><description>NumPy 配列 (ndarray) は、np.array() 関数を使って次のように生成するのが基本ですが、
import numpy as np # 1 次元の場合 a = np.array([1, 2, 3]) print(a[0]) #=&amp;gt; 1 # 2 次元の場合 a = np.array([[1, 2, 3], [4, 5, 6]]) print(a[0]) #=&amp;gt; [1 2 3] print(a[0][2]) #=&amp;gt; 3 NumPy は ndarray インスタンス生成用の様々なユーティリティ関数を提供しています。
全要素が 0 の NumPy 配列 (np.zeros) 零ベクトル np.zeros() 関数で、すべての要素が 0 の配列データ（ベクトル）を作成できます。 データタイプ (dtype) はデフォルトで float64 になりますが、dtype パラメーターで変更することが可能です。
&amp;gt;&amp;gt;&amp;gt; np.zeros(3) array([0., 0., 0.]) &amp;gt;&amp;gt;&amp;gt; np.zeros(3, dtype=&amp;#34;int64&amp;#34;) array([0, 0, 0], dtype=int64) 零行列 すべての要素（成分）が 0 である行列のことを零行列（ゼロ行列; zero matrix）と呼びます。 NumPy で零行列を生成するには、np.</description></item><item><title>Python の Pandas でラベル付き 1 次元データを扱う (pandas.Series)</title><link>https://maku77.github.io/p/wbudtbr/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wbudtbr/</guid><description>Python の Pandas ライブラリは、データ操作および分析を容易にするためのデータ型および関数群を提供します。 Pandas ライブラリの内部では、NumPy ライブラリの多次元配列 (ndarray) や数値演算関数が使用されています。 先に NumPy に慣れておくと理解が早くなります。
参考: NumPy 配列 (ndarray) の基本 pandas.Series はラベル付き 1 次元配列 pandas.Series は、1 次元の NumPy 配列 (ndarray) に、インデックス用のラベルを付加したデータ型です。 通常の配列データは 0、1、2 というインデックスで各要素にアクセスしますが、pandas.Series では各インデックスに意味のあるラベルを付けることができます。
pandas.Series を生成する pandas.Series コンストラクタで、次のように初期データだけを指定すると、通常の配列と同様にインデックスとして 0、1、2 が割り振られます。
sample.py import pandas as pd s = pd.Series([100, 200, 300]) print(s) 実行結果 0 100 1 200 2 300 dtype: int64 各インデックスにラベルを設定する pandas.Series コンストラクタで第 2 引数 (index) を追加指定すると、明示的に各インデックスのラベルを設定することができます。
import pandas as pd s = pd.</description></item><item><title>Python の Pandas でラベル付き 2 次元データを扱う (pandas.DataFrame)</title><link>https://maku77.github.io/p/watbs9p/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/watbs9p/</guid><description>pandas.DataFrame はラベル付き 2 次元配列 Python の Pandas ライブラリが提供する pandas.DataFrame 型は、テーブル形状のデータを表す 2 次元データ型で、Pandas によるデータ解析の要となるデータ形式です。
内部では NumPy ライブラリの ndarray が利用されていますが、pandas.DataFrame を使うと、X 軸（列）、Y 軸（行）の各インデックスに任意のラベルを付けることができます （1 次元データを表現する pandas.Series 型も用意されています）。 NumPy の ndarray は同じデータタイプの値しか持てませんが、pandas.DataFrame であれば、列ごとに異なるデータタイプの値を保持することができます。
pandas.DataFrame を生成する pandas.DataFrame コンストラクタで、次のように初期値となる 2 次元データだけを渡すと、行と列のラベルとして、0、1、2 という連番が割り振られます。 pandas.DataFrame オブジェクトを print 関数に渡すと、見やすい形で出力してくれます。
sample.py import pandas as pd data = [[100, 200, 300], [400, 500, 600], [700, 800, 900]] df = pd.DataFrame(data) print(df) 実行結果 0 1 2 0 100 200 300 1 400 500 600 2 700 800 900 各インデックスにラベルを設定する pandas.</description></item><item><title>Python の pandas.DataFrame から部分データを抽出する</title><link>https://maku77.github.io/p/8j4k3iy/</link><pubDate>Mon, 23 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8j4k3iy/</guid><description>Python の pandas ライブラリが提供する pandas.DataFrame はテーブル形式データを保持していますが、ここから部分的なデータを抽出する方法がたくさん用意されています。
サンプルデータ 最初に、後述の説明のためにサンプルデータを用意しておきます。 次のコードでは、10 行 3 列のデータを持つ pandas.DataFrame を生成しています。
import numpy as np import pandas as pd data = np.random.randn(10, 3) # 10x3 の NumPy 配列を生成（標準正規分布の乱数） indices = pd.date_range(&amp;#34;2010-01-01&amp;#34;, periods=10) # 日付の連番からなるインデックスを生成 columns = (&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;) # カラム名 my_dataframe = pd.DataFrame(data, index=indices, columns=columns) print(my_dataframe) 実行結果 A B C 2010-01-01 -1.083348 0.780602 -1.249351 2010-01-02 -0.421893 1.417954 2.196932 2010-01-03 -1.129684 -0.751984 0.920735 2010-01-04 -0.668949 -2.082924 -0.018011 2010-01-05 1.</description></item><item><title>Python の NumPy 配列 (ndarray) の基本</title><link>https://maku77.github.io/p/jwfxfvd/</link><pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/jwfxfvd/</guid><description>NumPy 配列 (ndarray) とは Python の NumPy ライブラリ (numpy) は、多次元配列を高速かつ便利に扱うための ndarray クラスを提供しています（n-dimensional array の略）。 ndarray は Python 標準のリストと比べて次のような違いがあります。
内部実装に C 言語などの低レベル言語が利用されており、処理が高速でメモリ効率がよい C 言語の配列と同様、単一のデータタイプ で 固定サイズ の配列である（サイズ変更は新しい ndarray の生成になる） 全要素に対するブロードキャスト演算や、行列（ベクトル）演算など、便利な演算方法 が提供されている NumPy はこのような特徴を持つため、次のように様々なライブラリで利用されています。
データ解析ライブラリ: Pandas 画像処理ライブラリ: OpenCV 科学計算ライブラリ: SciPy 機械学習ライブラリ: TensorFlow、scikit-learn プロットライブラリ: Matplotlib つまり、ほとんどの数学的、科学的な処理を行うライブラリは NumPy を利用していると考えられます。
NumPy 配列を生成する（numpy.array 関数） ndarray インスタンスは、numpy.array() 関数で生成することができます。 実際には、numpy ライブラリは np という別名でインポートするのが慣例となっているので、コード中では numpy.array() ではなく np.array() と記述されることが多いです。
1 次元の ndarray 次の例では、1 次元の ndarray インスタンスを生成しています。
1 次元の ndarray を生成 &amp;gt;&amp;gt;&amp;gt; import numpy as np &amp;gt;&amp;gt;&amp;gt; a = np.</description></item><item><title>Python でモジュールやパッケージを作成する</title><link>https://maku77.github.io/p/n4n5m3i/</link><pubDate>Fri, 16 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/n4n5m3i/</guid><description>モジュールとパッケージ Python では、再利用可能な関数などを集めたスクリプトファイルのことをモジュールと呼びます。 さらに、同系列のモジュールを集めたものをパッケージと呼びます。
モジュール &amp;hellip; 再利用可能なスクリプト (.py) パッケージ &amp;hellip; 上記のモジュールをディレクトリに集めたもの モジュールやパッケージを作成しておくと、他のファイルから import して使用することができます。
☝️ Node.js も同じ名前 モジュールやパッケージといった名称は、言語によって使われ方が様々ですが、Node.js に関してはほぼ同じ意味で使われています。 Node.js では、.js ファイルのことをモジュール、それらをまとめたものをパッケージと読んでいます。 モジュールを作成する 下記は、簡単な関数（add と sub）を提供する mymath モジュールを定義する例です。 といっても、単純に関数を定義するだけです。 モジュールは、モジュール名.py というファイル名で作成する必要があります。
mymath.py（モジュールの実装例） def add(a, b): &amp;#34;&amp;#34;&amp;#34;Return the sum of a and b.&amp;#34;&amp;#34;&amp;#34; return a + b def sub(a, b): &amp;#34;&amp;#34;&amp;#34;Subtract b from a.&amp;#34;&amp;#34;&amp;#34; return a - b 上記の mymath.py で定義されている関数を使用するには、Python 標準のモジュールと同様に、import mymath という形でインポートします。
main.py（モジュールの使用例） import mymath if __name__ == &amp;#39;__main__&amp;#39;: print(mymath.</description></item><item><title>NumPy / pandas / Matplotlib の概要とインストール</title><link>https://maku77.github.io/p/qs6iv8j/</link><pubDate>Tue, 13 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qs6iv8j/</guid><description>NumPy / pandas / Matplotlib とは NumPy、pandas、Matplotlib などのライブラリは組み合わせて使用することの多いライブラリで、それぞれ下記のような特徴を持っています。
NumPy - 数値計算ライブラリ (numpy.org) C で実装された高速な多次元配列である ndarray（通称 NumPy 配列）、及び関連メソッドを扱うことができます。 Python のみで行列を表現しようとすると、配列の配列（要素ごとに可変長）を作ることになりますが、NumPy 配列ではn x m の固定サイズ、単一タイプのデータとして扱うことで非常に高速な計算処理を行えるようになっています。 pandas &amp;ndash; 数値解析ライブラリ (pandas.pydata.org) R 言語のような数値解析を行うことができるライブラリです。 データファイルの読み込み、加工、集計、可視化までを総合的に行うことができます。 データのプロットには内部で Matplotlib を使用しており、pd.DataFrame.plot() がラッパーとして提供されています。 Matplotlib &amp;ndash; グラフ描画ライブラリ (matplotlib.org) 単独でグラフを描画するために使用できるライブラリですが、pandas による計算結果を描画するために内部で使用されています。 NumPy / pandas / Matplotlib のインストール Python 3.4 以降はパッケージ管理のための pip コマンドが標準で搭載されているので、これを使って NumPy と pandas と Matplotlib をインストールするのがお手軽です。 まずは、pip コマンド自体を最新にアップグレードします。
$ pip install --upgrade pip 引き続き、NumPy と Matplotlib のインストールを行います。
$ pip install numpy $ pip install pandas $ pip install matplotlib これで、import numpy、import pandas、import matplotlib といった感じでインポートできるようになります。</description></item><item><title>Windows で pydoc コマンドを使用できるようにする</title><link>https://maku77.github.io/p/6h2izfh/</link><pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6h2izfh/</guid><description>pydoc コマンドを使用すると、下記のように Python の API ドキュメントを手軽に参照できます。
$ pydoc list.sort Help on method_descriptor in list: list.sort = sort(...) L.sort(key=None, reverse=False) -&amp;gt; None -- stable sort *IN PLACE* Windows では Python をインストールしただけでは pydoc コマンドは使用できませんが、実装自体は Lib/pydoc.py というスクリプトとしてインストールされます。 下記のようなバッチファイルを python.exe と同じディレクトリに作成しておけば、Windows でも pydoc コマンドを使用できるようになります。
pydoc.cmd @python %~dp0\Lib\pydoc.py %* 実行例 C:\&amp;gt; pydoc dict.update Help on method_descriptor in dict: dict.update = update(...) D.update([E, ]**F) -&amp;gt; None. Update D from dict/iterable E and F. If E is present and has a .</description></item><item><title>Python で ZIP/JAR ファイルの内容を読み込む (zipfile)</title><link>https://maku77.github.io/p/gxajt4d/</link><pubDate>Tue, 06 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gxajt4d/</guid><description>Python に標準搭載されている zipfile モジュール を使用すると、ZIP ファイルや JAR ファイルの読み書きを手軽に行うことができます。
ZIP ファイル内のファイル一覧を取得する 下記のサンプルでは、指定した ZIP ファイル内のファイルリストとその（展開後の）サイズを出力します。 zipfile.ZipFile コンストラクタで ZipFile オブジェクトを生成し、infolist メソッドで ZIP 内のファイル情報 (ZipInfo) を取得できます。
dump_zip.py import zipfile with zipfile.ZipFile(&amp;#34;sample.zip&amp;#34;, &amp;#34;r&amp;#34;) as zf: for info in zf.infolist(): if info.is_dir(): continue # ディレクトリ情報は出力せずにスキップ print(f&amp;#34;{info.filename} ({info.file_size} bytes)&amp;#34;) 実行結果 $ python dump_zip.py data/sample1.txt (4560 bytes) data/sample2.txt (2284 bytes) data/sample3.txt (5712 bytes) README.txt (1417 bytes) ファイル名でソートして出力したい場合は、下記のようにいったんリストにしてソートしてしまえば OK です。
with zipfile.ZipFile(&amp;#34;sample.zip&amp;#34;, &amp;#34;r&amp;#34;) as zf: arr = list(zf.infolist()) arr.sort(key=lambda x: x.</description></item><item><title>Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP)</title><link>https://maku77.github.io/p/6k5m4jy/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6k5m4jy/</guid><description>python コマンドを単独で実行したときのインタラクティブシェルは、環境変数 PYTHONSTARTUP に指定したスタートアップ・スクリプトを最初に実行します。 これを利用して、日常的に使用したい関数などを自動的に定義することができます。
例えば、下記の例では、ホームディレクトリにある .pythonstartup スクリプトを読み込むように設定しています。
~/.bash_profile (Linux や Mac OSX の場合） export PYTHONSTARTUP=~/.pythonstartup Windows の場合は、システムのプロパティから環境変数を設定してください（~/ という表記は使用できないので、スタートアップ・スクリプトの位置はフルパスで指定する必要があります）。 コマンドラインから環境変数を設定することもできます。
C:\&amp;gt; setx PYTHONSTARTUP D:/x/myconf/pythonstartup.py （コマンドプロンプトを再起動して反映） 下記のスタートアップ・スクリプトでは、モジュールのソースコードをさくっと確認するための DEV.code 関数を定義しています。DEV.file 関数の方は、指定したモジュールのコードを Vim エディタで開きます。
~/.pythonstartup class DEV: @staticmethod def code(obj): import inspect print(inspect.getsource(obj)) @staticmethod def file(obj): import inspect import os os.system(&amp;#39;gvim &amp;#39; + inspect.getfile(obj)) あとは、Python のインタラクティブシェルを起動すれば、上記の関数が定義された状態で起動します。
$ python ... &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; DEV.code(os.path.split) def split(p): &amp;#34;&amp;#34;&amp;#34;Split a pathname. Return tuple (head, tail) where tail is everything after the final slash.</description></item><item><title>Python の関数やクラスのソースコードを確認する (inspect)</title><link>https://maku77.github.io/p/xbucsaq/</link><pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xbucsaq/</guid><description>関数のコードを表示する Python のプログラムを作成しているときに、ある関数のソースコードを確認したくなったときは、inspect モジュールの getsource 関数を使用して簡単に調べることができます。
次の例では、Python の対話型シェル（python3 コマンド）を起動して、os.path.abspath 関数の実装コードを確認しています。
例: os.path.abspath の実装コードを確認する &amp;gt;&amp;gt;&amp;gt; import inspect &amp;gt;&amp;gt;&amp;gt; import os &amp;gt;&amp;gt;&amp;gt; print(inspect.getsource(os.path.abspath)) def abspath(path): &amp;#34;&amp;#34;&amp;#34;Return an absolute path.&amp;#34;&amp;#34;&amp;#34; path = os.fspath(path) if not isabs(path): if isinstance(path, bytes): cwd = os.getcwdb() else: cwd = os.getcwd() path = join(cwd, path) return normpath(path) （おまけ）シェルスクリプト化しておく 次のようなシェルスクリプト (pycode) を作っておくと、Python の関数の実装コードを簡単に確認できるようになります。 このシェルスクリプトは、PATH の通ったディレクトリに置いて、chmod +x pycode で実行権限を付けておきます。
/Users/maku/bin/pycode #!/bin/bash # # pycode - Python の関数やクラスの実装コードを表示します # # Usage: # $ pycode &amp;lt;モジュール名&amp;gt; &amp;lt;関数名|クラス名&amp;gt; # # 使用例: # $ pycode os path.</description></item><item><title>Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve)</title><link>https://maku77.github.io/p/5zj72ei/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5zj72ei/</guid><description>urllib.request によるファイルのダウンロード urllib.request.urlretrieve を使用すると、簡単に Web 上のファイルをダウンロードしてローカルファイルとして保存することができます。
urllib.request.urlretrieve 関数 下記の download_file 関数は、指定した URL のファイルをカレントディレクトリにダウンロードします。
import urllib.request import os.path def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; urllib.request.urlretrieve(url, filename) if __name__ == &amp;#39;__main__&amp;#39;: download_file(&amp;#39;https://example.com/&amp;#39;) ローカルに作成されるファイル名は、os.path.basename を使用して、URL の末尾から切り出しています。 URL の末尾にファイル名らしきものが見つからない場合は、デフォルトファイル名として index.html で保存するようにしています。
テンポラリファイルとしてダウンロードする urllib.request.urlretrieve の 2 番目のパラメータ (filename) を省略すると、テンポラリディレクトリに適当なファイル名で保存されます。 このファイルパスは、戻り値で返されるタプルの先頭に格納されています。
path, headers = urllib.request.urlretrieve(&amp;#39;http://example.com/sample.png&amp;#39;) print(path) #=&amp;gt; c:\users\maku\appdata\local\temp\tmpgujizj urlretrieve により作成された一時ファイルを確実に削除するには、下記のように後始末しておきます。
urllib.request.urlcleanup() このファイルはテンポラリディレクトリに作成されるファイルなので、それほど厳密に削除する必要はないかと思いますが、大量のテンポラリファイルが作られるような場合は実行しておいた方がよいでしょう。
ダウンロード時の HTTP レスポンスヘッダの取得 urllib.request.urlretrieve により、ファイルをダウンロードした際に、ついでに HTTP レスポンスヘッダを取得したい場合 は、下記のように 戻り値のタプルの 2 番目の要素 から取得できます。
path, headers = urllib.</description></item><item><title>Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler)</title><link>https://maku77.github.io/p/4yiygwe/</link><pubDate>Thu, 19 Nov 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4yiygwe/</guid><description>urllib.request モジュールを使って Basic 認証の設定された Web サイトにアクセスすると、デフォルトでは下記のようなエラーが発生します。
Basic 認証エラー urllib.error.HTTPError: HTTP Error 401: Authorization Required HTTPBasicAuthHandler を使用すると、各 Web サイトにアクセスするときのユーザ名と、パスワード情報を設定することができます。 具体的には、Basic 認証のかかった Web サイトにアクセスした場合に Web サーバから返される realm 情報 と、ベースとなる URI 情報 に対して、使用するユーザ名とパスワードを関連付けます。
下記のサンプルでは、http://example.com/secret/ 以下にアクセスする際に、Basic 認証のユーザ名、パスワードとして、user1、pass1 を利用するように設定しています。 ここでは、realm 情報は無視し、URI 情報だけに関連付けるようにするため、HTTPPassswordMgrWithDefaultRealm を使用しています。
Basic 認証の付いたサイトにアクセスする import urllib.request import os.path def setup_basic_auth(base_uri, user, password): password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password( realm=None, uri=base_uri, user=user, passwd=password) auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr) opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) def download_file(url): filename = os.path.basename(url) or &amp;#39;index.html&amp;#39; print(&amp;#39;Downloading .</description></item><item><title>Python で指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob)</title><link>https://maku77.github.io/p/6vpyp4z/</link><pubDate>Fri, 30 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6vpyp4z/</guid><description>指定した拡張子を持つファイルを列挙する ここでは、Python でカレントディレクトリ以下の .java ファイルを列挙する例を示します。
glob を使用する方法（オススメ） glob.iglob 関数や glob.glob 関数を使用すると、いわゆるグロブ（シェルのワイルドカード）によるパターン指定でファイルを列挙することができます。 glob.iglob はジェネレーターで、glob.glob は通常の関数です。 つまり、glob.iglob は for ループでイテレート処理したいとき、glob.glob はリストで取得したいときに使います。
glob.iglob でファイル列挙 import glob for name in glob.iglob(&amp;#34;*.java&amp;#34;): print(name) Python 3.5 以降では、ディレクトリを再帰的にたどるための ** も使用できます。 この場合は recursive パラメータを True に設定します。
glob.iglob で再帰的なファイル列挙 import glob for name in glob.iglob(&amp;#34;**/*.java&amp;#34;, recursive=True): print(name) 実はオブジェクト指向的な方法でファイルパスを扱うための pathlib.Path クラス にも glob メソッドが用意されていて、同様の方法でファイルパスを列挙できます。 この glob メソッドは glob.glob 関数とは異なり、再帰的にディレクトリをたどるようにデフォルトで設定されており、ジェネレーターを返すようになっています。 ややこしいですね。
Path#glob メソッドで再帰的なファイル列挙 from pathlib import Path for name in Path(&amp;#34;.&amp;#34;).glob(&amp;#34;**/*.java&amp;#34;): print(name) os.</description></item><item><title>Python で HTML をパースする (HTMLParser)</title><link>https://maku77.github.io/p/nqz8fnu/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nqz8fnu/</guid><description>HTMLParser で HTML を処理する Python に標準搭載されている HTML パーサである html.parser.HTMLParser は、イベントドリブンな HTML パーサです。
HTMLParser クラスを継承して独自のパーサを作成し、feed メソッドに HTML テキストを渡すことによってパースを開始します。 下記のサンプルコードでは、開始タグ、終了タグ、テキストデータ、コメントが見つかったときに、それぞれ内容を出力しています。
sample.py from html.parser import HTMLParser # HTMLParser を継承してパーサクラスを作成する class MyParser(HTMLParser): def handle_starttag(self, tag, attrs): print(&amp;#34;START :&amp;#34;, tag, attrs) def handle_endtag(self, tag): print(&amp;#34;END :&amp;#34;, tag) def handle_data(self, data): print(&amp;#34;DATA :&amp;#34;, data) def handle_comment(self, comment): print(&amp;#34;COMMENT:&amp;#34;, comment) # パーサのインスタンスを生成してパースを実行 parser = MyParser() parser.feed(&amp;#39;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;#39; &amp;#39;&amp;lt;div class=&amp;#34;class1&amp;#34; id=&amp;#34;id1&amp;#34;&amp;gt;Hello World&amp;lt;/div&amp;gt;&amp;#39; &amp;#39;&amp;lt;!-- I am a comment --&amp;gt;&amp;#39; &amp;#39;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;#39;) 実行結果 START : html [] START : body [] START : div [(&amp;#39;class&amp;#39;, &amp;#39;class1&amp;#39;), (&amp;#39;id&amp;#39;, &amp;#39;id1&amp;#39;)] DATA : Hello World END : div COMMENT: I am a comment END : body END : html HTMLParser は、単純に HTML 要素を前から順番に処理していくだけなので、現在の要素がどのようなコンテキストで記述されているかは、パーサクラス内で判断していくように実装する必要があります。</description></item><item><title>Python の requests パッケージによる HTTP リクエストの例</title><link>https://maku77.github.io/p/r7q8q7o/</link><pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r7q8q7o/</guid><description>参考: requests パッケージのチートシート
requests パッケージのインストール オープンソースの requests パッケージ を使用すると、Python 3 標準の urllib.request よりも簡単に HTTP リクエストを扱うことができます。 例えば、以下のような処理をシンプルなコードで扱うことができます。
Basic 認証、ダイジェスト認証 ファイルのアップロード クッキー SSL 検証 エンコーディング形式の自動判別 コンテンンツが圧縮されていた場合の自動展開 requests パッケージは、pip コマンドで簡単にインストールできます。
request パッケージのインストール $ pip install requests requests モジュールによる HTTP GET リクエスト requests.get 関数を使うと、HTTP GET リクエストでインターネット上のコンテンツをダウンロードすることができます。 requests.get は、戻り値として requests.models.Response オブジェクトを返します。
Web コンテンツのダウンロード import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) type(res) #=&amp;gt; &amp;lt;class &amp;#39;requests.models.Response&amp;#39;&amp;gt; Response オブジェクトから、ステータスコードや、取得したコンテンツの内容を取得することができます。
requests.get のレスポンスを詳しく見る import requests res = requests.get(&amp;#39;http://google.com/&amp;#39;) print(res.status_code) #=&amp;gt; 200 print(res.status_code == requests.</description></item><item><title>Python で HTML をパースする (Beautiful Soup)</title><link>https://maku77.github.io/p/r4m4k2i/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r4m4k2i/</guid><description>Beautiful Soup とは Python 標準の html.parser モジュールは、SAX 形式のイベントドリブンなパーサなため、若干扱いにくいところがあります。 Beautiful Soup ライブラリを使用することで、HTML の要素に簡単にアクセスすることができるようになります。
Beautiful Soap Documentation Beautiful Soup パッケージは次のようにインストールできます。
$ pip install beautifulsoup4 HTML をパースする 最初に、HTML 文字列や HTML ファイルから bs4.BeautifulSoup オブジェクトを生成する必要があります。
HTML 文字列から soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(&amp;#34;&amp;lt;html&amp;gt;Hello&amp;lt;/html&amp;gt;&amp;#34;, features=&amp;#34;html.parser&amp;#34;) HTML ファイルから soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(open(&amp;#34;input.html&amp;#34;), features=&amp;#34;html.parser&amp;#34;) Beautiful Soup 自体には Web 上のリソースをダウンロードする機能は備わっていないので、そのようなケースでは、requests モジュールなどで HTML リソースをダウンロードしておいて、BeautifulSoup コンストラクタに渡してやります。
Web 上の HTML リソースから soup を作成（requests モジュールを使用） from bs4 import BeautifulSoup import requests res = requests.</description></item><item><title>Python で HTTP を扱う方法いろいろ</title><link>https://maku77.github.io/p/k5p4axo/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k5p4axo/</guid><description>Python3 の標準 HTTP ライブラリ Python3 には HTTP を扱う、下記のような標準ライブラリが用意されています。
http.client
HTTP (RFC 2616) を実装する 低レベルライブラリ。 urllib.request
上記を利用した 高レベルライブラリ。認証やリダイレクトをサポートしています。 オープンソースの HTTP ライブラリ Python に標準で付属している urllib.request パッケージは、比較的低レベルな処理を行うように設計されているため、手っ取り早く HTTP リクエストでデータを取得したい場合は、オープンソースの requests パッケージ を使うとよいでしょう。 requests パッケージは、Python の公式サイトでも推奨されています。
requests パッケージ</description></item><item><title>Python のパッケージ管理ツール (pip) の使い方</title><link>https://maku77.github.io/p/7o9q8p6/</link><pubDate>Sun, 17 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7o9q8p6/</guid><description>pip とは Python のパッケージ管理ツールである pip コマンドは、従来の setuptools で提供されていた easy_install コマンドを置き換えるものです。 pip コマンドは、主に Python Package Index からパッケージをダウンロードしてインストールします。
pip のインストール Python 3.4 以降の Python インストーラを使用すると、pip コマンドは標準でインストールされます。 下記のいずれかの方法ですでにインストールされているか確認しましょう。
$ pip --version $ python -m pip --version $ python3 -m pip --version 単体でインストールする必要がある場合は、基本的には下記のサイトに従ってインストールします。
Installation - pip documentation pip 1.5.1 までは、setuptools の easy_install コマンドを使用してインストールしていましたが、現在は get-pip.py スクリプトを使ってどの OS 環境でも統一された方法で簡単にインストールすることができます。
pip コマンドのインストール $ curl -kL https://bootstrap.pypa.io/get-pip.py | python3 プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。
pip によるパッケージのインストール、アンインストール $ pip install &amp;lt;package&amp;gt; $ pip install -U &amp;lt;package&amp;gt; # パッケージを最新版にアップグレード $ pip install -I &amp;lt;package&amp;gt; # パッケージをインストールしなおす $ pip uninstall &amp;lt;package&amp;gt; # パッケージのアンインストール プロキシ環境で使用する場合は、--proxy=proxy.</description></item><item><title>Python で JSON 形式のテキストファイルを読み書きする (json.load, json.dump)</title><link>https://maku77.github.io/p/xhyhzfv/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xhyhzfv/</guid><description>JSON ファイルを読み込む (json.load) Python に付属している json ライブラリが提供する json.load 関数を使用すると、JSON 形式のテキストファイルを読み込んで、Python のオブジェクトを生成することができます。 json.load 関数のパラメーターには、ファイル名ではなく、ファイルオブジェクト（read 関数を持つオブジェクト）を渡すことに注意してください。
入力ファイル (input.json) { &amp;#34;aaa&amp;#34;: 100, &amp;#34;bbb&amp;#34;: 200, &amp;#34;ccc&amp;#34;: 300 } sample.py import json def load_json(filename): &amp;#34;&amp;#34;&amp;#34;JSON ファイルを読み込んで Python オブジェクトとして返します。&amp;#34;&amp;#34;&amp;#34; with open(filename, encoding=&amp;#39;utf-8&amp;#39;) as f: return json.load(f) # テスト obj = load_json(&amp;#34;input.json&amp;#34;) print(obj[&amp;#39;aaa&amp;#39;]) #=&amp;gt; 100 print(obj[&amp;#39;bbb&amp;#39;]) #=&amp;gt; 200 print(obj[&amp;#39;ccc&amp;#39;]) #=&amp;gt; 300 JSON ファイル内の各要素は、次のような対応付けで Python オブジェクトに変換されます。
JSON の型 Python の型 object dict array list string str number int / float true / false True / False null None JSON ファイルではなく、JSON 形式の文字列を読み込みたいときは、json.</description></item><item><title>Python で XML をパースする (ElementTree)</title><link>https://maku77.github.io/p/cp9q7n5/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cp9q7n5/</guid><description>ElementTree XML API Python 2.5 以降には、XML を扱うための標準 API として、ElementTree XML API が用意されています。
The ElementTree XML API ElementTree では、パースした XML を DOM オブジェクトとしてメモリ上に保持するため、XML データを読み込んだあとは、各 XML 要素へ柔軟にアクセスすることができます。
XML ファイルをパースする ElementTree モジュールが提供している ElementTree.parse 関数を使って、XML ファイルを読み込むことができます。 ElementTree.parse 関数は、読み込んだ XML をパースして ElementTree オブジェクトとして返します。 ElementTree オブジェクトは、XML ツリー全体を表現するオブジェクトです。 XML ツリーの先頭要素を表す Element オブジェクトは、ElementTree#getroot() メソッドで取得することができます。
input.xml（テスト用の XML ファイル） &amp;lt;tree name=&amp;#34;hello&amp;#34;&amp;gt; &amp;lt;trunk&amp;gt;...&amp;lt;/trunk&amp;gt; &amp;lt;/tree&amp;gt; main.py from xml.etree import ElementTree # XML ファイルから ElementTree オブジェクトを生成 tree = ElementTree.parse(&amp;#39;input.xml&amp;#39;) # 先頭要素を表す Element オブジェクトを取得 elem = tree.</description></item><item><title>Python で XML を扱う方法いろいろ</title><link>https://maku77.github.io/p/pt6fpx8/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pt6fpx8/</guid><description>Python には下記のように、標準の XML パーサが複数搭載されています。
xml.etree.ElementTree &amp;hellip; The ElementTree XML API xml.dom &amp;hellip; The Document Object Model API xml.dom.minidom &amp;hellip; Minimal DOM implementation xml.sax &amp;hellip; Support for SAX2 parsers 通常はシンプルな xml.etree.ElementTree を使い、DOM 標準の API を使いたい場合は xml.dom を使用すればよいでしょう。 巨大な XML ファイルを効率的に読み込みたい場合は、SAX API を提供する xml.sax を選択できます。
参考: 20. Structured Markup Processing Tools Beautiful Soup などの 3rd パーティライブラリでも XML を扱うことはできますが、Beautiful Soup はどちらかというと HTML のパースに向いています。 XML のパースは、ほとんどの場合 Python 標準の ElementTree で十分です。</description></item><item><title>Python で XPath を使って XML 要素を参照する (ElementTree)</title><link>https://maku77.github.io/p/fufwevc/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fufwevc/</guid><description>Python 2.5 以降に搭載されている ElementTree XML API は、XPath による要素アクセスをサポートしています。
The Element Tree XML API - XPath support 次の例では、country という名前の要素をすべて取得し、再帰的に子要素を表示しています。
countries.xml（入力ファイル） &amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt; &amp;lt;data&amp;gt; &amp;lt;country name=&amp;#34;Liechtenstein&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;1&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2008&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;141100&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Austria&amp;#34; direction=&amp;#34;E&amp;#34;/&amp;gt; &amp;lt;neighbor name=&amp;#34;Switzerland&amp;#34; direction=&amp;#34;W&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;country name=&amp;#34;Singapore&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;4&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;59900&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Malaysia&amp;#34; direction=&amp;#34;N&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;country name=&amp;#34;Panama&amp;#34;&amp;gt; &amp;lt;rank&amp;gt;68&amp;lt;/rank&amp;gt; &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt; &amp;lt;gdppc&amp;gt;13600&amp;lt;/gdppc&amp;gt; &amp;lt;neighbor name=&amp;#34;Costa Rica&amp;#34; direction=&amp;#34;W&amp;#34;/&amp;gt; &amp;lt;neighbor name=&amp;#34;Colombia&amp;#34; direction=&amp;#34;E&amp;#34;/&amp;gt; &amp;lt;/country&amp;gt; &amp;lt;/data&amp;gt; sample.py from xml.etree import ElementTree def dump_node(node, indent=0): print(&amp;#39; &amp;#39; * indent, node.tag, node.</description></item><item><title>Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen)</title><link>https://maku77.github.io/p/o2e43ct/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o2e43ct/</guid><description>ここでは、Python の組み込みモジュールである urllib.request を使った HTTP アクセスの例を示します。
urlopen による GET/POST リクエストの基本 urllib.request.urlopen 関数は、http.client.HTTPResponse オブジェクトを返します。 HTTPResponse オブジェクトの read メソッドを呼ぶことで、HTTP レスポンスを取得することができます。
https://example.com のコンテンツ (HTML) を取得する from urllib.request import urlopen with urlopen(&amp;#39;https://example.com/&amp;#39;) as res: text = res.read().decode(&amp;#39;utf-8&amp;#39;) print(text) read メソッドが返すデータはバイナリデータ (bytes) なので、テキストとして扱う場合は、エンコーディング形式（utf-8 など）を指定してデコードする必要があります。
urlopen 関数で取得した HTTPResponse オブジェクトは、リソース解放のために明示的に close() することが推奨されているのですが、上記のように Python 3 の with 文を使用すると、close() 処理を自動化できます。
urlopen の引数に、URL 文字列ではなく、urllib.request.Request オブジェクトを渡すこともできます。 Request オブジェクトを使うと、HTTP ヘッダー情報やプロキシ、HTTP メソッド（GET や POST）の指定などを行えます。
HTTP ヘッダーやプロキシを指定したリクエスト import urllib.request URL = &amp;#39;http://example.com/&amp;#39; req = urllib.</description></item><item><title>Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする</title><link>https://maku77.github.io/p/ogq5hdy/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ogq5hdy/</guid><description>urllib.request を使用した HTTP アクセスは、デフォルトでシステムに設定されたプロキシ設定（http_proxy、https_proxy、ftp_proxy 環境変数など）でアクセスが行われます。 これらのプロキシ設定をそのまま使用してもよいし、Python のコード内で明示的にプロキシを設定することもできます。
現在のプロキシ設定を確認する (getproxies) 現在、システムにどのようなプロキシ設定が反映されているかを調べるには、urllib.request.getproxies 関数を使用します。
import urllib.request print(urllib.request.getproxies()) 実行結果 {&amp;#39;http&amp;#39;: &amp;#39;http://proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;: &amp;#39;https://proxy.example.com:8080&amp;#39;, &amp;#39;ftp&amp;#39;: &amp;#39;ftp://proxy.example.com:8080&amp;#39;} リクエストごとにプロキシを設定する (Request) HTTP リクエストごとに使用するプロキシを明示的に指定したい場合は、Request オブジェクトを作成し、set_proxy メソッドでプロキシを指定します。 あとは、その Request オブジェクトを urllib.request.urlopen() に渡して HTTP リクエストを送信します。
リクエスト単位でのプロキシ設定 import urllib.request req = urllib.request.Request(&amp;#39;https://example.com/&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;http&amp;#39;) req.set_proxy(&amp;#39;proxy.example.com:8080&amp;#39;, &amp;#39;https&amp;#39;) with urllib.request.urlopen(req) as res: html = res.read().decode(&amp;#39;utf-8&amp;#39;) print(html) Request#set_proxy() でプロキシサーバーを指定するときは、http:// や https:// といったスキーム名は省略することに注意してください。 スキーム名を記述してしまうと、プロキシがうまく認識されず、次のような DNS エラーになったりします。
urlopen error [Errno 11001] getaddrinfo failed Request オブジェクトは生成時に URL を指定する必要があるため、アクセス先が変わるごとに生成する必要があることに注意してください。</description></item><item><title>Python のワンライナーコマンドで JSON ファイルを整形する (json.tool)</title><link>https://maku77.github.io/p/an8o6m4/</link><pubDate>Fri, 28 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/an8o6m4/</guid><description>json.tool の基本 Python 2.6 以降には json モジュールが標準搭載されていて、これはコマンドラインからも便利に利用することができます。 下記は、json.tool モジュール を使って JSON 形式のテキスト出力を、きれいに整形しなおして出力するワンライナーの例です。
$ python -mjson.tool input.json # あるいは $ cat input.json | python -mjson.tool ここでは、次のような JSON ファイルを使って試してみます。 スペースはわざとぐちゃぐちゃに入れています。
input.json（入力ファイル） {&amp;#34;ccc&amp;#34; : 300, &amp;#34;aaa&amp;#34;:100, &amp;#34;bbb&amp;#34;:200, &amp;#34;data&amp;#34;: [1,2,3]} 実行例 $ python -mjson.tool input.json { &amp;#34;ccc&amp;#34;: 300, &amp;#34;aaa&amp;#34;: 100, &amp;#34;bbb&amp;#34;: 200, &amp;#34;data&amp;#34;: [ 1, 2, 3 ] } キー名でソートして出力する (&amp;ndash;sort-keys) Python 3.7 以降で、キーの順序は入力ファイルのものが保持されるようになりました（内部的に辞書オブジェクト (dict) のキー挿入順序が保持されるようになりました）。 キー順序をアルファベット順にソートして出力したいときは、--sort-keys オプションを指定します。
キー順にソートする $ python -mjson.tool --sort-keys input.json { &amp;#34;aaa&amp;#34;: 100, &amp;#34;bbb&amp;#34;: 200, &amp;#34;ccc&amp;#34;: 300, &amp;#34;data&amp;#34;: [ 1, 2, 3 ] } インデントサイズを指定する (&amp;ndash;indent=N) バージョン 3.</description></item><item><title>Python の関数で可変長引数を扱う (*args, **kwargs)</title><link>https://maku77.github.io/p/rcaip63/</link><pubDate>Mon, 02 Jun 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rcaip63/</guid><description>可変長引数 関数に任意の数の引数を渡せるようにするには、パラメーター名の前にアスタリスク (*) を付けます。 下記の print_lines 関数には、任意の数（0 個以上）の文字列を渡すことができます。
def print_lines(*lines: str) -&amp;gt; None: for line in lines: print(line) # 使用例 print_lines(&amp;#34;Hello&amp;#34;, &amp;#34;World&amp;#34;, &amp;#34;Python&amp;#34;) 実行結果 Hello World Python 関数内では、lines パラメーターは文字列型 (str) のタプルとして参照できます。
任意のキーワード引数を渡せるようにする パラメーター名の前に 2 つのアスタリスク (**) を付けると、任意のキーワード引数を受け取れる関数になります。 パラメーター名には慣例としてよく kwargs が使われます（keyword arguments の略）。
def process_data(**kwargs) -&amp;gt; None: for key, value in kwargs.items(): print(f&amp;#34;{key}: {value}&amp;#34;) # 使用例 process_data(name=&amp;#34;John&amp;#34;, age=30, city=&amp;#34;New York&amp;#34;) process_data(subject=&amp;#34;Python&amp;#34;, level=&amp;#34;Intermediate&amp;#34;, duration=5) 実行結果 name: John age: 30 city: New York subject: Python level: Intermediate duration: 5 関数内では、kwargs パラメーターは辞書オブジェクトとして参照できます。</description></item><item><title>Python コードの実行時間を計測する (datetime.now)</title><link>https://maku77.github.io/p/ubtbs9p/</link><pubDate>Thu, 01 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ubtbs9p/</guid><description>下記は datetime モジュールを使って、Python コードの一部の実行時間を計測する例です。
main.py from datetime import datetime start = datetime.now() # ここに実行時間を計測したい処理を記述する print(datetime.now() - start) 実行結果 $ python3 main.py 00:00:01.547393</description></item><item><title>Python でコマンドライン引数を扱う (sys.argv)</title><link>https://maku77.github.io/p/ybxfwev/</link><pubDate>Sun, 20 Oct 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ybxfwev/</guid><description>ここでは、sys.argv でコマンドライン引数を参照する初歩的な方法を説明しますが、ある程度複雑なコマンドライン引数を扱いたいときは、Python の標準ライブラリの argparse モジュールを使う ことをおすすめします。
コマンドライン引数を参照する Python スクリプト起動時にコマンドライン引数として渡された値は、sys.argv で文字列リストの形で参照することができます。 先頭の要素 sys.argv[0] には、python コマンドで指定したスクリプト自身の名前が格納されています。
コマンドライン引数を参照する (sample.py) import sys print(sys.argv) print(len(sys.argv)) 実行例 $ python sample.py aaa bbb ccc [&amp;#39;sample.py&amp;#39;, &amp;#39;aaa&amp;#39;, &amp;#39;bbb&amp;#39;, &amp;#39;ccc&amp;#39;] 4 sys.argv の先頭にスクリプト自身の名前が入っているので、len(sys.argv) は少なくとも 1 以上の値になります。
コマンドライン引数が正しく指定されていないときに Usage 表示する 下記は、コマンドライン引数を 1 つも指定せずにスクリプトを実行した場合に使い方 (usage) を表示して終了するサンプルです。
コマンドライン引数が不正なときに終了する (hello.py) import sys import os if len(sys.argv) &amp;lt; 2: # コマンドライン引数が指定されなかった場合は終了 print(f&amp;#34;Usage: python {os.path.basename(sys.argv[0])} &amp;lt;name&amp;gt;&amp;#34;) sys.exit(1) print(f&amp;#34;Hello, {sys.argv[1]}!&amp;#34;) 実行例 $ python hello.py Usage: python hello.</description></item><item><title>Python で dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault)</title><link>https://maku77.github.io/p/bq6yzpr/</link><pubDate>Sat, 15 Jun 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bq6yzpr/</guid><description>Python の dictionary に値をセットするときに、まだそのキーが存在しない場合だけ新しい値をセットしたい場合は、dict.setdefault() メソッドを使用します。 setdefault() メソッドは、既にキーが存在している場合は格納されている値、存在しない場合は第 2 引数で指定した値を返します。
val = d.setdefault(&amp;#39;key&amp;#39;, &amp;#39;default_value&amp;#39;) つまり、dict.setdefault() は、dict.get() を行いつつ、存在しないキーを指定した場合は、値のセットまで行う という振る舞いをします。
典型的な使用例として、dictionary 要素の値としてリストを格納するというユースケースがあります。 次のように、キーに対応するリストを取り出すときに setdefault() を使えば、キーがまだ存在しないときに自動的に空のリストを生成し、dictionary に登録してくれます。
d = {} l = d.setdefault(&amp;#39;key&amp;#39;, []) # このキーは存在しないので初期値として空リストを格納し、さらにその参照を返す l.append(100) # d[&amp;#39;key&amp;#39;] が [100] になる もう一度、同じキー key で参照しようとすると、今度はすでに dictionary に格納されているリストへの参照を取得することができます。
l = d.setdefault(&amp;#39;key&amp;#39;, []) # このキーは既に存在しているので、格納されているリスト [100] の参照を返す l.append(200) # d[&amp;#39;key&amp;#39;] は [100, 200] になる 上記のコードは、次のように get() メソッドでデフォルト値を指定しておく方法と似ています。 ただし、このようにした場合は、get() によって返された新規リストオブジェクトを忘れずに dictionary に格納しなければいけません。
setdefault() を使わないとちょっと面倒になる l = d.get(&amp;#39;key&amp;#39;, []) l.</description></item><item><title>JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps)</title><link>https://maku77.github.io/p/gwfweub/</link><pubDate>Wed, 22 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gwfweub/</guid><description>Python には JSON フォーマットを扱うための json モジュールが標準搭載（Python 2.6 以降）されており、JSON 形式のテキストと、Python のオブジェクトを相互に変換することができます。
JSON 文字列 → Python オブジェクト (json.loads) JSON 形式の文字列データから、Python オブジェクトを作成するには json.loads 関数 を使用します。
import json data = json.loads(&amp;#39;{&amp;#34;key&amp;#34;:&amp;#34;value&amp;#34;}&amp;#39;) print(data[&amp;#39;key&amp;#39;]) #=&amp;gt; &amp;#39;value&amp;#39; json.loads と似た関数に、json.load 関数がありますが、こちらは文字列ではなく JSON ファイルを読み込みます。 loads の末尾の s は、文字列を受け取ることを示しています。
参考: JSON 形式のテキストファイルを Python オブジェクトとして読み込む (json.load) Python オブジェクト → JSON 文字列 (json.dumps) 逆に、Python オブジェクトから JSON 形式のテキストを生成するには、json.dumps 関数 を使用します。
import json obj = {&amp;#39;aaa&amp;#39;:100, &amp;#39;bbb&amp;#39;:200} json_str = json.dumps(obj) print(json_str) 実行結果 {&amp;#34;bbb&amp;#34;: 200, &amp;#34;aaa&amp;#34;: 100} 整形して出力する (indent=2) 改行を入れた形で見やすく出力したい場合は、json.</description></item><item><title>Python でファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir)</title><link>https://maku77.github.io/p/tr3cmu5/</link><pubDate>Wed, 08 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tr3cmu5/</guid><description>ファイルあるいはディレクトリが存在するかを調べる Python で、指定した名前のファイル、あるいはディレクトリが存在しているかを調べるには、os.path.exists 関数 を使用します。 シンボリックリンクに対して実行した場合、os.path.exists 関数は、リンク先のファイルの有無を調べます。
sample.txt という名前のファイルかディレクトリが存在するかを調べる import os if os.path.exists(&amp;#39;sample.txt&amp;#39;): print(&amp;#39;Found!&amp;#39;) ファイルの存在、ディレクトリの存在を調べる 前述の os.path.exists は、ファイルあるいはディレクトリの存在を調べますが、ファイルのみ、ディレクトリのみに絞って存在を調べたいときは、os.path.isfile 関数 や os.path.isdir 関数 を使用します。
import os if os.path.isfile(&amp;#39;sample&amp;#39;): print(&amp;#39;sample というファイルが見つかりました&amp;#39;) if os.path.isdir(&amp;#39;sample&amp;#39;): print(&amp;#39;sample というディレクトリが見つかりました&amp;#39;)</description></item><item><title>Python でリストを昇順ソート／降順ソートする (list.sort/sorted)</title><link>https://maku77.github.io/p/cqtwqgx/</link><pubDate>Thu, 25 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cqtwqgx/</guid><description>リストを昇順／降順ソートする (list.sort) 昇順ソート list オブジェクトの sort() メソッドを呼び出すと、要素が昇順ソートされます。
a = [3, 5, 2, 1, 4] a.sort() print(a) #=&amp;gt; [1, 2, 3, 4, 5] sort() メソッドを使用すると、リスト自身の内容が変更されることに注意してください（破壊的メソッドです）。 なお、タプルは不変なので sort() メソッドは使えません（後述の sorted() 関数を使います）。
降順ソート sort() メソッドの reverse=True オプションを指定すると、降順ソートすることができます。
a = [3, 5, 2, 1, 4] a.sort(reverse=True) print(a) #=&amp;gt; [5, 4, 3, 2, 1] ソート結果を新しいリストで取得する (sorted) list.sort メソッドの代わりに sorted 関数を使用すると、元のリストを変更せずに、ソートされた新しいリストを生成することができます。
&amp;gt;&amp;gt;&amp;gt; a = [3, 5, 2, 1, 4] &amp;gt;&amp;gt;&amp;gt; b = sorted(a) &amp;gt;&amp;gt;&amp;gt; a [3, 5, 2, 1, 4] &amp;gt;&amp;gt;&amp;gt; b [1, 2, 3, 4, 5] sorted 関数は、immutable なタプルに対しても適用することができます。</description></item><item><title>Python で dictionary の要素をソートして出力する (sorted)</title><link>https://maku77.github.io/p/qqkggoz/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qqkggoz/</guid><description>キーでソートして出力 Python の dictionary の要素をキー順に取り出すには、dict.keys() メソッドで dictionary からキーの一覧を取り出し、それを sorted() 関数で昇順ソートしてループ処理します。 つまり、キーのリストをソートしているだけです。
キー名で昇順ソート &amp;gt;&amp;gt;&amp;gt; d = {&amp;#39;BBB&amp;#39;: 200, &amp;#39;AAA&amp;#39;: 300, &amp;#39;CCC&amp;#39;: 100} &amp;gt;&amp;gt;&amp;gt; for key in sorted(d.keys()): ... print(key, d[key]) AAA 300 BBB 200 CCC 100 キー名で降順ソートしたいときは、sorted() 関数に reverse=True パラメーターを指定します。
キー名で降順ソート &amp;gt;&amp;gt;&amp;gt; d = {&amp;#39;BBB&amp;#39;: 200, &amp;#39;AAA&amp;#39;: 300, &amp;#39;CCC&amp;#39;: 100} &amp;gt;&amp;gt;&amp;gt; for key in sorted(d.keys(), reverse=True): ... print(key, d[key]) CCC 100 BBB 200 AAA 300 値でソートして出力 sorted() 関数の key パラメーターをうまく使うと、dictionary の「値」によりソートされたキーを列挙できます。 次の例では、値の昇順 (100, 200, 300) でループ処理しています。</description></item><item><title>Python の set オブジェクトで集合演算を行う</title><link>https://maku77.github.io/p/h3jqpp9/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/h3jqpp9/</guid><description>Python では、set オブジェクト同士を &amp;amp; や | で演算することによって、簡単に集合演算を行うことができます。
a = {1, 2, 3, 4, 5} b = {3, 4, 5, 6, 7} # 両方に含まれるもの（積集合） s1 = a &amp;amp; b # =&amp;gt; {3, 4, 5} # いずれかに含まれるもの（和集合） s2 = a | b # =&amp;gt; {1, 2, 3, 4, 5, 6, 7} # a にだけ含まれるもの s3 = a - b # =&amp;gt; {1, 2} # b にだけ含まれるもの s4 = b - a # =&amp;gt; {6, 7} # どちらか一方にだけ含まれるもの s5 = a ^ b # =&amp;gt; {1, 2, 6, 7} 参考: 2 つのリストに重複する要素を抽出する（set と &amp;amp;）</description></item><item><title>Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer)</title><link>https://maku77.github.io/p/rr3cmu5/</link><pubDate>Sun, 09 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rr3cmu5/</guid><description>Python がインストールされた環境であれば、コマンドラインから下記のように実行することで簡易 HTTP サーバを立てることができます。
（Python3 の場合）ポート 8000 で HTTP サーバーを起動 $ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... （Python2 の場合）ポート 8000 で HTTP サーバーを起動 $ python -m SimpleHTTPServer 8000 Serving HTTP on 0.0.0.0 port 8000 ... これで、http://localhost:8000/ にアクセスすれば、カレントディレクトリ内のファイルの一覧が表示されます。 開発環境での HTTP 開通テストや、LAN 内の一時的なファイル共有サーバとして使用することができます。</description></item><item><title>Python でユニットテストを記述する (unittest)</title><link>https://maku77.github.io/p/fueucsa/</link><pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fueucsa/</guid><description>Python でユニットテストを書くには、unittest モジュール を使用します。 unittest モジュールは、Python 2.1 以降に標準で搭載されています。
テストケースを作成するには、unittest.TestCase を継承したクラスを作成し、test で始まる名前のテストメソッドを記述するだけで OK です。 unittest.main 関数を呼び出すことにより、それらのテストメソッドが自動的に実行されます。
sample.py import unittest class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def decrement(self): self.count -= 1 def get_count(self): return self.count class CounterTest(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def test_increment(self): c = Counter() c.increment() self.assert_(c.get_count() == 1) c.increment() self.assert_(c.get_count() == 2) def test_decrement(self): c = Counter() c.decrement() self.assert_(c.get_count() == -1) c.decrement() self.</description></item><item><title>Python で文字列を置換する (str.replace, re.sub, re.subn)</title><link>https://maku77.github.io/p/wnpquuy/</link><pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wnpquuy/</guid><description>Python の文字列オブジェクトの replace メソッドを使うと、その文字列の内容を置換することができます。 正規表現を使った高度な置換を行うには、re モジュールを使用します。
単純な置換 (str.replace) 例: すべての AA を xx に置換する s = &amp;#39;AABBCCAABBCC&amp;#39; s = s.replace(&amp;#39;AA&amp;#39;, &amp;#39;xx&amp;#39;) #=&amp;gt; &amp;#39;xxBBCCxxBBCC&amp;#39; 置換した結果は戻り値として返されるので、元の文字列を変更したい場合は、自分自身に代入する必要があります。 デフォルトではパターンに一致した全ての文字列が置換されます。
例: 最初に見つかった AA を xx に置換 s = &amp;#39;AABBCCAABBCC&amp;#39; s = s.replace(&amp;#39;AA&amp;#39;, &amp;#39;xx&amp;#39;, 1) #=&amp;gt; &amp;#39;xxBBCCAABBCC&amp;#39; 第 3 引数 (count) で、最大いくつまで置換するかを指定 することも可能です。 上記の例では、count=1 と設定することで、最初に一致した部分だけを置換しています。
正規表現を使った置換 (re.sub, re.subn) re モジュールを使うと、正規表現を使った高度な置換を行えるようになります。 正規表現を含む文字列リテラルを記述する場合は、r プレフィックス付けた raw string 記法 (r'...') を使用することで、記号類のエスケープ処理が不要になります。
例: &amp;lsquo;&amp;lt;&amp;rsquo; と &amp;lsquo;&amp;gt;&amp;rsquo; で囲まれた数値を &amp;lsquo;#&amp;rsquo; に置換 import re s = re.</description></item><item><title>Python で XML を構築する (minidom)</title><link>https://maku77.github.io/p/m2k3jyg/</link><pubDate>Fri, 08 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/m2k3jyg/</guid><description>下記は、Python の minidom モジュールが提供する DOM インタフェースを使用して XML を構築し、XML ファイルとして保存するサンプルです。
sample.py import codecs from xml.dom import minidom def create_xmldoc(): doc = minidom.Document() tree = doc.createElement(&amp;#39;tree&amp;#39;) doc.appendChild(tree) branch = doc.createElement(&amp;#39;branch&amp;#39;) tree.appendChild(branch) leaf = doc.createElement(&amp;#39;leaf&amp;#39;) leaf.setAttribute(&amp;#39;id&amp;#39;, &amp;#39;001&amp;#39;) branch.appendChild(leaf) text = doc.createTextNode(&amp;#39;This is a leaf&amp;#39;) leaf.appendChild(text) return doc def save_xmldoc(xmldoc, filepath): f = codecs.open(filepath, &amp;#39;wb&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) # Text encoding xmldoc.writexml(f, &amp;#39;&amp;#39;, &amp;#39; &amp;#39;*2, &amp;#39;\n&amp;#39;, encoding=&amp;#39;UTF-8&amp;#39;) # XML header&amp;#39;s encoding f.close() if __name__ == &amp;#39;__main__&amp;#39;: doc = create_xmldoc() save_xmldoc(doc, &amp;#39;output.</description></item><item><title>Python のクラス定義の基本 (class)</title><link>https://maku77.github.io/p/ru9mxam/</link><pubDate>Thu, 07 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ru9mxam/</guid><description>class キーワードを使って、Python のクラスを定義することができます。
コンストラクタとインスタンスメソッド メソッドは通常の関数と同様に def キーワードで定義していくのですが、__init__ という名前のメソッドを定義すると、インスタンス生成時（クラス名()）に呼び出されるコンストラクタとして扱われます。 コンストラクタの中では、自分自身のインスタンスを参照するための self を使って、属性の初期化などを行います。
Person クラスを定義してみる class Person: &amp;#34;&amp;#34;&amp;#34;クラスの説明をここに書く&amp;#34;&amp;#34;&amp;#34; def __init__(self, name: str): &amp;#34;&amp;#34;&amp;#34;コンストラクタの説明をここに書く&amp;#34;&amp;#34;&amp;#34; self.name = name def hello(self): &amp;#34;&amp;#34;&amp;#34;メソッドの説明をここに書く&amp;#34;&amp;#34;&amp;#34; print(f&amp;#34;Hello, {self.name}!&amp;#34;) コンストラクタやメソッドの第 1 引数には、必ず自分自身のインスタンスを参照するための self 引数を配置します。 実際には、名前は何でもよいのですが、公式のスタイルガイドで self という名前を使うことが推奨されています（参考: PEP 8）。
上記のように定義したクラスは、次のように使用することができます。
person = Person(&amp;#34;maku&amp;#34;) # インスタンスを生成する person.hello() # メソッドを呼び出す 実行例 $ python main.py Hello, maku! クラス属性 (class attribute) クラス属性 は、インスタンスを生成せずにアクセスできる属性です。 次のクラスは、num というクラス属性を持っています。 クラス属性には、クラス名.クラス属性名 という形でアクセスできます。
クラス属性を定義する # クラス属性を持つクラス class Holder: num: int = 0 # クラス属性を参照する print(Holder.</description></item><item><title>Python で XML をパースする (minidom)</title><link>https://maku77.github.io/p/guducs9/</link><pubDate>Mon, 04 Jun 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/guducs9/</guid><description>Python 2.0 以降では、Document Object Model インタフェース (DOM API) の最小の実装として、xml.dom.minidom が搭載されています。 DOM 標準の API を使って操作する必要のない場合は、よりシンプルなインターフェースを提供している ElementTree モジュールを使用する のがよいでしょう。
Document オブジェクトを取得する minidom を使用して、XML の各要素にアクセスするためには、まずは DOM 全体を表現する xml.dom.minidom.Document オブジェクトを取得する必要があります。 データソースとしては、XML ファイル、XML 文字列、Web 上のリソースなどを利用できます。
XML ファイルを扱う場合 from xml.dom import minidom doc = minidom.parse(&amp;#34;input.xml&amp;#34;) print(doc.toxml()) XML 文字列を扱う場合 from xml.dom import minidom xml = &amp;#34;&amp;#34;&amp;#34; &amp;lt;tree&amp;gt; &amp;lt;branch&amp;gt; &amp;lt;leaf id=&amp;#39;1&amp;#39;&amp;gt;Leaf 1&amp;lt;/leaf&amp;gt; &amp;lt;leaf id=&amp;#39;2&amp;#39;&amp;gt;Leaf 2&amp;lt;/leaf&amp;gt; &amp;lt;leaf id=&amp;#39;3&amp;#39;&amp;gt;Leaf 3&amp;lt;/leaf&amp;gt; &amp;lt;/branch&amp;gt; &amp;lt;/tree&amp;gt;&amp;#34;&amp;#34;&amp;#34; doc = minidom.parseString(xml) print(doc.toxml()) Web 上の XML リソースを扱う場合 urllib モジュールを組み合わせて使えば、Web 上の XML も簡単にパースできます。</description></item><item><title>python コマンドでワンライナーを実行する (python -c)</title><link>https://maku77.github.io/p/oi67p5c/</link><pubDate>Fri, 13 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oi67p5c/</guid><description>python コマンドを実行するときに -c オプションを指定すると、コマンドラインで指定した Python コードを直接実行することができます。 このように 1 行で記述したコードは、ワンライナーと呼ばれています。
python のワンライナー実行の例 # Hello World $ python -c &amp;#34;print(&amp;#39;Hello World&amp;#39;)&amp;#34; Hello World # 連番の表示 $ python -c &amp;#34;print([x for x in range(5)])&amp;#34; [0, 1, 2, 3, 4] # 現在時刻の表示 $ python -c &amp;#34;import datetime; print(datetime.datetime.now())&amp;#34; 2023-11-23 16:22:37.530499 # JSON ファイルの特定のキーの値を取得する $ python -c &amp;#34;import json; print(json.load(open(&amp;#39;file.json&amp;#39;))[&amp;#39;key&amp;#39;])&amp;#34; value # CSV ファイルの特定の列を表示する $ python -c &amp;#34;import csv; print([row[&amp;#39;col1&amp;#39;] for row in csv.DictReader(open(&amp;#39;file.csv&amp;#39;))])&amp;#34; [&amp;#39;100&amp;#39;, &amp;#39;200&amp;#39;, &amp;#39;300&amp;#39;]</description></item><item><title>Python でモジュールを import する方法のまとめ</title><link>https://maku77.github.io/p/zdxfvct/</link><pubDate>Thu, 19 Nov 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zdxfvct/</guid><description>Python でモジュールをインポートする際に使用される import 構文は、複数の指定方法があるため、初めはやや混乱するかもしれません。 以下に、import のさまざまな指定方法をまとめておきます。 Python のモジュールとパッケージの基本については下記の記事を参考にしてください。
Python でモジュールやパッケージを作成する モジュール単位でのインポート まずは基本から。 モジュール名でインポートする方法です。 この方法でモジュールをインポートした場合は、内部の関数などを参照するときは、モジュール名をプレフィックスとして付けます。
mymod モジュールをインポートする import mymod mymod.hello() パッケージ内のモジュールをインポートするときは、次のいずれかの方法で記述しますが、モジュール内のメンバーを参照するときのプレフィックスが変わってきます。
mypkg パッケージ内の mymod モジュールをインポートする # 方法1 import mypkg.mymod mypkg.mymod.hello() # 方法2 from mypkg import mymod mymod.hello() 2 階層以上のパッケージになっても同様です。
# 方法1 import mypkg.sub.mymod mypkg.sub.mymod.hello() # 方法2 from mypkg.sub import mymod mymod.hello() 特定のメンバーのみをインポート from モジュール名 import 関数名 という構文で、モジュール内の特定の関数だけインポートすれば、モジュール名を指定せずにその関数を直接呼び出せるようになります。
mymod モジュールの hello 関数のみをインポートする from mymod import hello hello() パッケージ内のモジュールに関しても同様です。
mypkg パッケージの mymod モジュールの hello 関数のみをインポートする from mypkg.</description></item><item><title>Python でキーボードからのユーザ入力を取得する (input, getpass)</title><link>https://maku77.github.io/p/bfev6xf/</link><pubDate>Wed, 18 Nov 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bfev6xf/</guid><description>input 関数と getpass 関数 Python 組み込み関数の input 関数を使用すると、画面上にプロンプトを表示して、キーボードからの入力を促すことができます。
name = input(&amp;#34;Please input your name: &amp;#34;) print(&amp;#34;Hello,&amp;#34;, name) パスワードを入力させるときなど、入力した文字を画面上に表示したくない場合は、input 関数の代わりに、getpass モジュールの getpass 関数を使用します。
from getpass import getpass password = getpass(&amp;#34;Password: &amp;#34;) 使用例: 処理を継続するかの確認 ファイルの削除など、危険なコマンドを実行する前に Are you sure? 的な確認メッセージを表示するサンプルコードです。 ユーザーが y あるいは Y 以外の文字を入力すると、そこで処理を打ち切ります。
confirm.py import sys answer = input(&amp;#34;Are you sure? (y/n): &amp;#34;) if (answer.lower() != &amp;#34;y&amp;#34;): sys.exit(0) print(&amp;#34;処理を継続します&amp;#34;) 実行例 $ python confirm.py Are you sure? (y/n): Y 処理を継続します 使用例: 入力したユーザー名とパスワードのチェック 下記のサンプルコードでは、ユーザに「ユーザ名」と「パスワード」のペアを入力させて、それらがあらかじめ登録されたペアと一致しているかをチェックしています。</description></item><item><title>Python のオブジェクトを print 関数で出力できるようにする (__str__)</title><link>https://maku77.github.io/p/uatcsaq/</link><pubDate>Sat, 06 Jun 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uatcsaq/</guid><description>クラスを定義するときに特殊メソッド __str__ を実装しておくと、print() や str() にそのオブジェクトを渡したときの出力をカスタマイズすることができます。
sample.py class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f&amp;#34;Name={self.name}, Age={self.age}&amp;#34; if __name__ == &amp;#34;__main__&amp;#34;: p = Person(&amp;#34;Maku&amp;#34;, 14) print(p) 実行結果 $ python sample.py name=Maku, age=14</description></item><item><title>Python でディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob)</title><link>https://maku77.github.io/p/thhwr4b/</link><pubDate>Tue, 06 Jan 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/thhwr4b/</guid><description>ファイルを列挙する（再帰なし） Python の os.listdir 関数を使うと、指定したディレクトリ内のファイルやディレクトリのパスをリストで取得できます。 カレントディレクトリや親ディレクトリを表す . や .. は、列挙の対象に含まれません。 列挙されたパスが、ディレクトリかどうかを調べたいときは os.path.isdir(path)、ファイルかどうかを調べたいときは os.path.isfile(path) で確認できます。
カレントディレクトリ内のディレクトリとファイルを列挙（1 階層のみ） import os for x in os.listdir(&amp;#39;.&amp;#39;): if os.path.isdir(x): print(&amp;#39;DIR:&amp;#39;, x) else: print(&amp;#39;FILE:&amp;#39;, x) ファイルを列挙する（再帰あり） os.listdir で列挙する方法 os.listdir 関数で列挙した要素がディレクトリだった場合に、そのディレクトリに対しても os.listdir 関数を呼び出すようにすれば、ディレクトリ内のすべてのファイルを再帰的に列挙することができます。
import os def enum_files(dir): entries = os.listdir(dir) for x in entries: path = os.path.join(dir, x) if os.path.isdir(path): for _ in enum_files(path): yield _ else: yield path if __name__ == &amp;#39;__main__&amp;#39;: for path in enum_files(&amp;#39;.&amp;#39;): print(path) # print(os.</description></item><item><title>Python でファイルやディレクトリの名前を変更する (os.rename, os.renames)</title><link>https://maku77.github.io/p/9aqzppe/</link><pubDate>Fri, 09 Nov 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9aqzppe/</guid><description>os.rename / os.renames 関数 os.rename 関数 を使用して、ファイルやディレクトリの名前を変更することができます。 次の例では、src.txt という名前のファイルを dst.txt という名前にリネームしています。
import os try: os.rename(&amp;#39;src.txt&amp;#39;, &amp;#39;dst.txt&amp;#39;) except Exception as e: print(&amp;#39;Error: {0}&amp;#39;.format(e), file=sys.stderr) os.rename 関数は次のようなエラーを発生させる可能性があります。 通常の使用時にも発生し得るものなので、エラーハンドル処理はちゃんと記述しておくことをお勧めします。
FileExistsError &amp;hellip; Windows で dst がすでに存在する場合。 IsADirectoryError &amp;hellip; Unix で、src がファイルで dst が（存在する）ディレクトリの場合。 NotADirectoryError &amp;hellip; Unix で、src がディレクトリで dst が（存在する）ファイルの場合。 OSError &amp;hellip; Unix で、src がディレクトリで dst が（存在する）ディレクトリで、かつ、dst が空でない場合。dst が空のディレクトリであれば、dst へのリネームは成功します（dst に src の中身が移動した状態になる）。 深いディレクトリ階層にファイルを移動させたいときは、os.renames 関数 を使うのが便利です。 os.renames 関数は、移動先のディレクトリが存在しない場合に自動的に作成してくれます。
os.renames(&amp;#34;src.txt&amp;#34;, &amp;#34;aaa/bbb/ccc/dst.txt&amp;#34;) 上記のようにすると、aaa/bbb/ccc というディレクトリ階層を作ってからファイルを移動してくれます。 os.renames ではなく、os.rename を使用した場合は、aaa/bbb/ccc というディレクトリが存在しないときにエラーになります。</description></item><item><title>Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe)</title><link>https://maku77.github.io/p/kyj2izf/</link><pubDate>Tue, 10 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kyj2izf/</guid><description>py2exe を使用すると、Python のスクリプトから Windows 上で実行可能な .exe ファイルを作成することができます。
基本的な使い方 変換対象のスクリプト hello.py と、変換設定ファイル setup.py を用意します。
hello.py print &amp;#39;Hello&amp;#39; setup.py from distutils.core import setup import py2exe setup(console=[&amp;#39;test.py&amp;#39;]) コマンドラインから、次のように実行すると、dist ディレクトリに hello.exe と、必要なライブラリが生成されます。
C:\&amp;gt; python setup.py py2exe 配布するときは、dist ディレクトリの中身をすべてまとめて配布します。
（応用）wxPython などの GUI アプリケーションの場合 setup.py from distutils.core import setup import py2exe setup(windows=[&amp;#39;test.py&amp;#39;]) GUI を持つアプリケーションで、実行時にコマンドプロンプトを表示したくない場合は、setup メソッドのパラメータとして、console の代わりに windows を指定します。</description></item><item><title>Python でクラスの属性に名前でアクセスする (getattr, setattr)</title><link>https://maku77.github.io/p/r3m4k2h/</link><pubDate>Sat, 31 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r3m4k2h/</guid><description>Python でオブジェクトの属性にアクセスするには、通常 obj.属性名 という構文を使用しますが、次のような仕組みを使うと、属性名を文字列で指定してアクセスすることができます。
ビルトイン関数の getattr / setattr 関数 オブジェクトの __dict__ 属性 変数などに格納した属性名を使えるようになるため、属性名のリストをループ処理したり、あらかじめ属性名が決められない場合に後付けで属性を追加したりすることができます。
getattr/setattr 関数を使う方法 ビルトイン関数の getattr や setattr を使うと、任意のオブジェクトの属性に次のような形式でアクセスできます。
getattr(object, name [, default]) # 属性値の取得 setattr(object, name, value) # 属性値の設定 getattr 関数で指定した名前の属性が見つからない場合は、default 引数で指定した値が返されます。 default 引数が指定されていないと AttributeError が発生するので、できるだけ default 引数は指定しておくのが安全です。
次の例では、属性名のタプル (&amp;quot;name&amp;quot;, &amp;quot;age&amp;quot;) をループ処理して、対応する属性値を順番に取り出しています。
例: person オブジェクトの name 属性と age 属性を参照する class Person: def __init__(self, name: str, age: int): self.name = name self.age = age person = Person(name=&amp;#34;Maku&amp;#34;, age=14) for attr_name in (&amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;): attr_val = getattr(person, attr_name) print(f&amp;#34;{attr_name} = {attr_val}&amp;#34;) 実行結果 name = Maku age = 14 __dict__ 属性を使用する方法 特殊属性の __dict__ でも属性値にアクセスできます。 この属性は辞書オブジェクトになっているので、__dict__[&amp;quot;属性名&amp;quot;] という形で参照します。</description></item><item><title>Python の対話型シェルで使える小技</title><link>https://maku77.github.io/p/dsbsaq7/</link><pubDate>Wed, 07 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsbsaq7/</guid><description>Python のインタラクティブシェルで _（アンダースコア）を使用すると、 前回評価した値を参照することができます。
&amp;gt;&amp;gt;&amp;gt; [1, 2, 3] [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; len(_) 3</description></item><item><title>Python でテキストファイルを読み込む (open, read, readline, readlines)</title><link>https://maku77.github.io/p/f4ckt29/</link><pubDate>Tue, 06 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f4ckt29/</guid><description>テキストファイルを 1 行ずつ読み込む for-in ループで 1 行ずつ処理する方法 Python の open 関数で生成したファイルオブジェクトを for-in ループでイテレートすることで、テキストファイルを 1 行ずつ読み込むことができます。 Python 2.5 以降であれば、open するときに、with キーワードを使用することによって close 処理を自動化することができます。 ファイルを使用している区間が明示的になるので、この方法を使うのがオススメです。
テキストファイルを 1 行ずつ処理 with open(&amp;#39;input.txt&amp;#39;, encoding=&amp;#39;utf-8&amp;#39;) as f: for line in f: line = line.rstrip(&amp;#39;\r\n&amp;#39;) # 改行文字の削除 print(line) # 改行付きで出力 line には改行コードを含むので、line.rstrip('\r\n') で末尾の改行系文字を削除しています。 別の方法としては、line 内の改行はそのままで、print(line, end='') として出力時の改行を抑制する方法あります（Python 2.x の頃は print line, のように最後にカンマを付ければ改行抑制できました）。
with によってインデントが深くなってしまうのが嫌な場合は、下記のようにユーティリティ関数を用意しておくのもよいです。
def each_line(filename): with open(filename, encoding=&amp;#39;utf-8&amp;#39;) as f: for line in f: yield line.rstrip(&amp;#39;\r\n&amp;#39;) for line in each_line(&amp;#39;input.</description></item><item><title>Python のコーディングスタイル</title><link>https://maku77.github.io/p/pyk3j2h/</link><pubDate>Tue, 06 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pyk3j2h/</guid><description>Python のコーディングスタイルは、PEP 8 や PEP 257 で指針が示されています。
PEP 8 &amp;ndash; Style Guide for Python Code PEP 257 &amp;ndash; Docstring Conventions このページでは主に上記の内容についてまとめていますが、実際に Python のプロジェクトにコーディングスタイルを適用するときは、Black などの Python フォーマッターを導入 することをおすすめします。 Black は、PEP 8 や PEP 257 と若干異なるところがありますが、理にかなったスタイルを強制的に適用してくれます。
命名規則 大文字／小文字 パッケージ名は小文字のみ（例: mypackage） クラス名は大文字で始める（例: MyClass） 関数、あるいは public メソッドは小文字（例: my_public_method） protected メソッドはアンダースコア 1 つで始める（例: _my_protected_method） private メソッドはアンダースコア 2 つで始める（例: __my_private_method） 定数名はすべて大文字（例: MY_CONSTANT） Python の name mangling の仕組みによって、アンダースコア 2 つで始まる名前は、クラス外部、あるいはサブクラスからその名前ではアクセスできないようになっています（正確には _ClassName__method という名前でアクセスできますが）。 この特性を利用して、private メソッドをアンダースコア 2 つで始めるようにするのがよい、ということです。
グローバル領域でのアンダースコアの使用について トップレベルに定義するクラスや関数で、モジュール（ファイル）内に閉じて外部に公開しないものは、プレフィックスとして 1 つのアンダースコアを付けます。 こうすることで、from M import * の形での自動インポートを防ぐことができます。</description></item><item><title>Python で SQLite データベースを扱う</title><link>https://maku77.github.io/p/g5xg2nc/</link><pubDate>Thu, 25 Jan 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/g5xg2nc/</guid><description>Python は標準ライブラリとして sqlite3 モジュールを備えています。
SQLite3 データベースへの接続 sqlite3.connect 関数でデータベースファイルを指定すると、SQLite3 データベースへの接続（sqlite3.Connection オブジェクト）を取得できます。 指定したデータベースファイルが存在しない場合は新規に作成されます。
SQLite DB へ接続する import sqlite3 # Create a Connection object. conn = sqlite3.connect(&amp;#34;sample.db&amp;#34;) テーブルの作成 SQL コマンドを実行するには、Connection#cursor メソッドで sqlite3.Cursor オブジェクトを作成し、execute メソッドを呼び出します。 次の例では、データベースに新しい memo テーブルを作成しています。
memo テーブルを作成する # Create a Cursor object from Connection object. cur = conn.cursor() # Create a table cur.execute(&amp;#34;&amp;#34;&amp;#34;CREATE TABLE memo (date TEXT, title TEXT, body TEXT)&amp;#34;&amp;#34;&amp;#34;) テーブルにレコードを追加 テーブルを作成するのと同様に、Cursor#execute メソッドを使ってレコードを追加できます。
レコードを追加する # Insert a record cur.execute(&amp;#34;&amp;#34;&amp;#34;INSERT INTO memo VALUES(&amp;#39;2007-01-01&amp;#39;, &amp;#39;Memo1&amp;#39;, &amp;#39;Body1&amp;#39;)&amp;#34;&amp;#34;&amp;#34;) DB-API の ?</description></item><item><title>Python で 2 つの dictionary をマージする (update)</title><link>https://maku77.github.io/p/ds9wgfz/</link><pubDate>Thu, 20 Oct 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ds9wgfz/</guid><description>dictionary に別の dictionary をマージする Python で 2 つの dictionary オブジェクトをマージするには dict.update() メソッドを使用します。 例えば、d1 という dictionary オブジェクトに、d2 という dictionary オブジェクトの内容をマージするには次のようにします。
&amp;gt;&amp;gt;&amp;gt; d1 = {&amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2, &amp;#39;org&amp;#39;: &amp;#39;d1&amp;#39;} &amp;gt;&amp;gt;&amp;gt; d2 = {&amp;#39;three&amp;#39;: 3, &amp;#39;four&amp;#39;: 4, &amp;#39;org&amp;#39;: &amp;#39;d2&amp;#39;} &amp;gt;&amp;gt;&amp;gt; d1.update(d2) &amp;gt;&amp;gt;&amp;gt; d1 {&amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2, &amp;#39;org&amp;#39;: &amp;#39;d2&amp;#39;, &amp;#39;three&amp;#39;: 3, &amp;#39;four&amp;#39;: 4} &amp;gt;&amp;gt;&amp;gt; d2 {&amp;#39;three&amp;#39;: 3, &amp;#39;four&amp;#39;: 4, &amp;#39;org&amp;#39;: &amp;#39;d2&amp;#39;} ポイント d1 の内容は変化しますが、d2 の内容は変化しません。 d1 と d2 に同じキーが存在する場合、d2 の値で上書きされます（上記の例では d1['org'] の値が上書きされています）。 もとの ditionary の内容を変化させずに新しい dictionary を作る 2 つの dictionary オブジェクト（dict1 と dict2）の内容を変化させずに内容をマージするには、** 演算子を使って、次のように新しい dictionary オブジェクトを作成します。 同じキーが存在する場合は、後ろに記述した dictionary の値が優先されます。</description></item><item><title>Python で dictionary からキーや値のリストを作成する (keys, values, items)</title><link>https://maku77.github.io/p/83e3wrw/</link><pubDate>Thu, 20 Oct 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/83e3wrw/</guid><description>Python の dictionary オブジェクトから、「キーのリスト」、「値のリスト」、「キーと値をペアにしたリスト」を取り出すには、それぞれ下記のようなメソッドを使用します。
d.keys() &amp;hellip; キーのリスト（戻り値は dict_keys オブジェクト） d.values() &amp;hellip; 値のリスト（戻り値は dict_values オブジェクト） d.items() &amp;hellip; (キー, 値) というタプルのリスト（戻り値は dict_items オブジェクト） &amp;gt;&amp;gt;&amp;gt; d = {&amp;#39;one&amp;#39;:1, &amp;#39;two&amp;#39;:2, &amp;#39;three&amp;#39;:3} &amp;gt;&amp;gt;&amp;gt; d.keys() dict_keys([&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;]) &amp;gt;&amp;gt;&amp;gt; d.values() dict_values([1, 2, 3]) &amp;gt;&amp;gt;&amp;gt; d.items() dict_items([(&amp;#39;one&amp;#39;, 1), (&amp;#39;two&amp;#39;, 2), (&amp;#39;three&amp;#39;, 3)]) [(&amp;#39;three&amp;#39;, 3), (&amp;#39;two&amp;#39;, 2), (&amp;#39;one&amp;#39;, 1)] それぞれの戻り値は dict_* という型のオブジェクトになっており、元のディクショナリ内のデータを参照するためのビューとして働きます。 このビューを介してディクショナリの内容を変更することはできませんが、ディクショナリ側の変更はビューに反映されます。 それぞれのオブジェクトは for ループでイテレートできます。
&amp;gt;&amp;gt;&amp;gt; for k in d.keys(): ... print(k) ... one two three &amp;gt;&amp;gt;&amp;gt; for k, v in d.</description></item><item><title>Python でキーのリストと値のリストを組み合わせて dictionary を生成する (zip)</title><link>https://maku77.github.io/p/cmy6ar3/</link><pubDate>Thu, 20 Oct 2005 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cmy6ar3/</guid><description>Python の zip 関数と dict 関数を組み合わせることで、「キーのリスト」と「値のリスト」から、新しい dictionary オブジェクトを生成することができます。
&amp;gt;&amp;gt;&amp;gt; keys = [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;] &amp;gt;&amp;gt;&amp;gt; values = [1, 2, 3] &amp;gt;&amp;gt;&amp;gt; d = dict(zip(keys, values)) &amp;gt;&amp;gt;&amp;gt; d {&amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2, &amp;#39;three&amp;#39;: 3} 2 つのリストの要素数が異なる場合は、少ない方に合わせて生成されます。
&amp;gt;&amp;gt;&amp;gt; keys = [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;three&amp;#39;] &amp;gt;&amp;gt;&amp;gt; values = [1, 2] &amp;gt;&amp;gt;&amp;gt; d = dict(zip(keys, values)) &amp;gt;&amp;gt;&amp;gt; d {&amp;#39;one&amp;#39;: 1, &amp;#39;two&amp;#39;: 2}</description></item></channel></rss>