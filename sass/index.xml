<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sass on 天才まくまくノート</title><link>https://maku77.github.io/sass/</link><description>Recent content in Sass on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sun, 30 Dec 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/sass/index.xml" rel="self" type="application/rss+xml"/><item><title>Sassメモ: SCSS 内でのループ処理 (@for, @while)</title><link>https://maku77.github.io/p/ka8a3uc/</link><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ka8a3uc/</guid><description>Sass スクリプトで @for ディレクティブや @while ディレクティブを使用すると、数値によるループ処理を行うことができます。 主に、シンプルな数値のインクリメント（あるいはデクリメント）によるループには @for ディレクティブを使用し、より複雑なループ処理が必要な場合には @while ディレクティブを使用します。
@for ディレクティブ @for ディレクティブは下記のいずれかの構文で使用します。
@for 変数 from 開始値 through 終了値 { 処理（スタイル定義など） } @for 変数 from 開始値 to 終了値 { 処理（スタイル定義など） } いずれも 変数 の値が 開始値 から 終了値 に向かってインクリメント（あるいはデクリメント）されながらループ処理されますが、through を使った場合に 終了値 を含む値まで処理されるのに対し、to を使った場合は 終了値 に達する手前の値までしか処理されません。 下記の例を見ると、その違いが分かると思います。
入力 (SCSS) @for $i from 1 through 3 { .foo-#{$i} { width: 10px * $i; } } @for $i from 1 to 3 { .</description></item><item><title>Sassメモ: SCSS 内での条件分岐処理 (@if-else, if関数)</title><link>https://maku77.github.io/p/rkk224q/</link><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rkk224q/</guid><description>@if ディレクティブ Sass スクリプトの中で @if、@else、@else if ディレクティブを使用することで、条件分岐処理を記述することができます。
下記の例では、変数 $fruit の値によってスタイルの出力を分岐させています。
入力 (SCSS) $fruit: banana; p { @if $fruit == apple { color: red; } @else if $fruit == banana { color: yellow; } @else { color: blue; } } 出力 (CSS) p { color: yellow; } 比較演算子としては、==、!=、&amp;gt;、&amp;gt;=、&amp;lt;、&amp;lt;= などを使用することができます。 論理演算子としては、and、or、not などを使用することができます（&amp;amp;&amp;amp; や || などはありません）。
@if ディレクティブは、Mixin や関数に渡されたパラメータを使って分岐処理したいときによく使用されます。
入力 (SCSS) @mixin highlight($inverted: false) { @if $inverted { color: white; background: red; } @else { color: red; background: white; } } strong { @include highlight(); } em { @include highlight(true); } 出力 (CSS) strong { color: red; background: white; } em { color: white; background: red; } if 関数 @if ディレクティブに似たものに、if 関数があります。 if 関数は第1パラメータの値が真 (true) の場合に第2パラメータで指定した値を返し、偽 (false) の場合に第3パラメータで指定した値を返します。 Java や C 言語の三項演算子のように使用するものです。</description></item><item><title>Sassメモ: 色（カラー値）を扱う</title><link>https://maku77.github.io/p/7pq84ye/</link><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7pq84ye/</guid><description>Color 型変数の定義方法 CSS では下記のような色の指定方法があります。
color: red; // 定数名で指定 color: #ff0000; // 16進数で指定 color: rgb(255, 0, 0); // 10進数で指定 color: rgba(255, 0, 0, 0.3); // 10進数で指定（α値あり） color: hsl(0, 100%, 50%); // HSL指定 color: hsla(0, 100%, 50%, 0.3); // HSL指定（α値あり） CSS の rgba 関数は、上記のように4つのパラメータをとりますが、Sass の rgba 関数はより柔軟なパラメータ指定が可能になっています。
color: rgba(red, 0.3); // 定数名 + α値 color: rgba(#ff0000, 0.3); // 16進数 + α値 また、Sass では名前付きパラメータを使って値を指定できるので、各パラメータの意味を明確にすることができます。
color: hsl($hue: 0, $saturation: 100%, $lightness: 50%); // 赤になる 色を表す定数の一覧 Sass スクリプトの中で色を表現する方法としては、#ff00ff のような16進数での指定方法以外にも、下記のように色を表す定数を使用する方法があります。</description></item><item><title>Sassメモ: 関数を定義する (@function)</title><link>https://maku77.github.io/p/3htu3om/</link><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3htu3om/</guid><description>Sass (SCSS) で独自関数を定義するには、下記のような構文の @function ディレクティブを使用します。
@function 関数名($引数1, $引数2) { @return 戻り値; } 関数名は、組み込みの関数とコンフリクトしないように、何らかのプレフィックスを付けることが推奨されています。 ライブラリなどを作っているのでなければ、my- とか x- とか付けておけば大丈夫だと思います。 関数には f- プレフィックス、Mixin には m- プレフィックスを付ける、といったルールを決めておくと分かりやすいかもしれません。
関数は Mixin と似ているように思われるかもしれませんが、Mixin がひとまとまりのルールセットを呼び出し側にインクルードするのに対し、関数は何らかの値を受け取って、その演算結果を値として返すために使用します（関数の方が粒度が小さい）。
下記の my-hover-color 関数は、パラメータで指定された色より若干明る目の色を返します。 ボタン要素にマウスカーソルを重ねたときの背景色を作成するために使用しています。
入力 (SCSS) $LIGHTEN_RATE: 20%; @function my-hover-color($color) { @return lighten($color, $LIGHTEN_RATE); } button { color: white; background: black; &amp;amp;:hover { background: my-hover-color(black); } } 出力 (CSS) button { color: white; background: black; } button:hover { background: #333333; } Mixin と同様に、パラメータは名前付き引数として設定することができます。 パラメータが複数あるときは、この形式で呼び出すようにすると可読性を上げられるかもしれません。</description></item><item><title>Sassメモ: Mixin でスタイルを組み合わせる (@mixin, @include)</title><link>https://maku77.github.io/p/awmebxk/</link><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/awmebxk/</guid><description>Sass のもっとも強力な機能とされている Mixin 機能を使用すると、部分的なスタイル定義をインクルードして使用できるようになります。
Mixin の基本 Sass の Mixin 機能は、ひとまとまりのスタイルを Mixin として定義 (@mixin) しておき、複数の場所からそのスタイルをインクルード (@include) して使用する仕組みです。 Mixin は、スタイルセットを提供する関数のようなものと考えるとわかりやすいです。
便利な Mixin を SCSS ファイルにまとめて定義しておけば、再利用可能な Sass ライブラリとして使用できます。 定義した Mixin は @include して使用しない限り CSS に出力されることはないので、Sass ライブラリの中の Mixin 定義が増えても、最終的な CSS が肥大化する心配はありません。
下記の例では、round-box という名前の Mixin を定義して、pre 要素と .ad-widget クラスのスタイル定義からインクルードしています。
入力 (SCSS) @mixin round-box { border: solid 1px gray; border-radius: 5px; padding: 10px; } pre { @include round-box; line-height: 1.3; } .ad-widget { @include round-box; background: #ccc; } 出力 (CSS) pre { border: solid 1px gray; border-radius: 5px; padding: 10px; line-height: 1.</description></item><item><title>Sassメモ: エクステンドでスタイルを継承する (@extend)</title><link>https://maku77.github.io/p/nkv6w5b/</link><pubDate>Wed, 19 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nkv6w5b/</guid><description>Sass (SCSS) の @extend ディレクティブを使用すると、他のセレクタに適用されているスタイル定義を継承して使用することができます。
@extend の基本 例えば、.sample クラスのスタイル定義の中で下記のように @extend ディレクティブを使用すると、
.sample { @extend &amp;lt;セレクタ名&amp;gt;; } 指定したセレクタに設定されているスタイル定義を、.sample クラスに継承させることができます。 セレクタ名には、クラス名 (.foo) や HTML のタグ名 (em) などを引用符で囲まずに指定します。
下記の例では、.warn クラスに対して設定したスタイルを、.error に継承させています。
入力 (SCSS) .warn { font-weight: bolder; border: solid 3px orange; color: orange; } .error { @extend .warn; border-color: red; color: red; } 出力 (CSS) .warn, .error { font-weight: bolder; border: solid 3px orange; color: orange; } .error { border-color: red; color: red; } これで、.</description></item><item><title>Sassメモ: SCSS でマップ変数を使用する</title><link>https://maku77.github.io/p/rm99r8j/</link><pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rm99r8j/</guid><description>マップ変数を作成する Sass においてマップはリストの特殊バージョンで、リストの各要素がキー＆バリューの形 (key1:value1) になったものです。 マップを定義するには、キー＆バリューをカンマで並べ、全体を括弧 () で囲みます。 リストを定義するときは、全体の括弧を省略できるケースがありますが、マップの場合は必ず全体を括弧で囲む必要があります。
マップ変数を定義する マップ変数を定義する $map: (key1: value1, key2: value2, key3: value3); 空のマップを作成したいときは、空のリストを作成するときと同様に () を使用します。 空のマップを作成しておいて、動的に要素を追加していくという使い方ができます。
空のマップ変数を定義する（リストでもある） 空のマップ変数を定義する（リストでもある） $map: (); マップの要素をループで処理する (@each) マップの要素もリストの要素と同様に @each ディレクティブを使用してループ処理することができます。 あるルール定義の中で、マップの要素を使用してスタイル定義を出力するために使用します。
入力 (SCSS) $headers: (h1: 1.6rem, h2: 1.4rem, h3: 1.3rem, h4: 1.2rem); @each $tag, $size in $headers { #{$tag} { font-size: $size; } } 出力 (CSS) h1 { font-size: 1.6rem; } h2 { font-size: 1.4rem; } h3 { font-size: 1.</description></item><item><title>Sassメモ: SCSS でリスト変数を使用する</title><link>https://maku77.github.io/p/gm47at8/</link><pubDate>Tue, 18 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gm47at8/</guid><description>Sass (SCSS) には、複数の値をまとめて管理するためのデータタイプとして list 型が用意されています。
リスト型の表現方法 リスト型変数の基本 CSS でリスト型の値を定義するときは、スペース区切りかカンマ区切りで複数の値を列挙します。 例えば、次のようなプロパティを表現するために使用されます。
CSS .sample { margin: 10px 15px 0 0; font-family: Helvetica, Arial, sans-serif; } SCSS の変数には、このようなリストもそのまま格納することができます。
SCSS $my-margin: 10px 15px 0 0; $my-font: Helvetica, Arial, sans-serif; .sample { margin: $my-margin; font-family: $my-font; } リストのリスト リストの要素としてリストを含めることもできます。 下記の例では、1px 2px と 3px 4px の 2 つのリストを含むリスト変数を定義しています。
$my-list1: 1px 2px, 3px 4px; $my-list2: (1px 2px) (3px 4px); 空リストと要素が1つだけのリスト 空のリストを定義するときは、() という表現方法を使用します。
$my-list: (); Sass では、() は空のリストであり、空のマップでもあります。マップは実質的には、キー＆バリューのペア値を格納した「リスト」として扱われるためです。 要素が 1 つだけのリストを表現するには、次のように、要素の後ろにカンマ (,) を記述します。</description></item><item><title>Sassメモ: SCSS で変数を使用する ($var-name, !default)</title><link>https://maku77.github.io/p/vd4ym66/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/vd4ym66/</guid><description>変数定義の基本 SCSS ファイル内で変数を定義するには、下記のような構文を使用します。
$変数名: 初期値; 下記はカラー値を変数として定義する簡単な例です。
入力 (SCSS) $main-color: #333; body { color: $main-color; } 出力 (CSS) body { color: #333; } 変数の値をそのままプロパティの値として使用する場合は、上記のように $変数名 の形で参照できます。 何らかのキーワードの一部（セレクタ名の一部など）や、コメントの中で変数の値を参照する場合は、インターポレーションの形式 (#{$変数名}) で参照する必要があります。 インターポレーションで文字列変数の値を参照すると、引用符は削除されて展開されます。
入力 (SCSS) $prefix: &amp;#34;.maku&amp;#34;; #{$prefix}-shout { font-size: larger; } 出力 (CSS) .maku-shout { font-size: larger; } 変数のスコープ（ローカル変数） 入れ子になったルール定義の中で変数を定義すると、その変数はそのブロック内でのみ参照可能なローカル変数となります。 グローバル変数と同じ名前のローカル変数を定義した場合、ローカル変数が優先されます。
入力 (SCSS) $color: black; // グローバル変数の定義 body { color: $color; // グローバル変数の参照 } main { $color: red; // ローカル変数の定義 color: $color; // ローカル変数の参照 } 出力 (CSS) body { color: black; } main { color: red; } 変数名のハイフンとアンダースコアは同一視される 歴史的な理由により、SCSS の中で定義した変数名に含まれるハイフン (-) と、アンダースコア (_) は同一のものとして扱われます。 例えば、$main-color という名前で定義した変数は、$main_color という名前でも参照できます。</description></item><item><title>Sassメモ: SCSS ファイルから別の SCSS ファイルをインポートする (@import)</title><link>https://maku77.github.io/p/hqpo9s9/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hqpo9s9/</guid><description>インポートの基本 SCSS の @import ディレクティブを使用すると、SCSS ファイルから別の SCSS ファイルをインポートすることができます。
入力 (SCSS) @import &amp;#34;colors.scss&amp;#34;; // 拡張子は省略可能 main { color: $main-color; } インポートされるファイル (colors.scss) // 色の定義 $main-color: black; 出力 (CSS) main { color: black; } 複数の SCSS ファイルをインポートしたいときは、複数行に分けて @import ディレクティブを記述してもよいですし、次のようにカンマ区切りでまとめてインポートすることもできます。
@import &amp;#34;foo&amp;#34;, &amp;#34;bar&amp;#34;, &amp;#34;hoge&amp;#34;; CSS 標準の @import ディレクティブとして使用する @import ディレクティブ自体は、通常の CSS に搭載されている機能であり、上記のように SCSS ファイルをその場所にインポートして展開する機能は、Sass によって追加された拡張機能です。
次のような一定のルールに従って @import ディレクティブを使用すると、従来の CSS の @import ディレクティブとして使用されたとみなされ、@import の行がそのまま出力されます（インポートしたファイルの内容がインライン展開されません）。
入力 (SCSS) // 拡張子が .css である @import &amp;#34;colors.css&amp;#34;; // メディアクエリが付いている @import &amp;#34;colors&amp;#34; screen; // URLで指定されている @import &amp;#34;http://example.</description></item><item><title>Sassメモ: SCSS ファイルでのコメントの書き方</title><link>https://maku77.github.io/p/katvaa5/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/katvaa5/</guid><description>SCSS の2種類のコメント形式 CSS のコメントは /* と */ で囲む1種類のコメント形式しかありませんが、SCSS では、一行コメント (//) と、複数行コメント (/* ～ */) の2種類のコメントを使用することができます。 SCSS でのみ使用可能な一行コメント (//) の方は、CSS に変換される際に削除されます。
複数行コメント（/* から */ まで） &amp;hellip; CSS への変換後もそのままコメントとして残る 一行コメント（// から行末まで） &amp;hellip; CSS への変換時に削除される 入力 (SCSS) /* * このコメントスタイルでは、 * 複数行をコメントアウトすることができます。 * CSS への変換後もコメントとして残ります。 */ body { color: black; } // これらの一行コメントは、 // CSS へ変換する際に削除されます。 strong { color: red; } 出力 (CSS) /* * このコメントスタイルでは、 * 複数行をコメントアウトすることができます。 * CSS への変換後もコメントとして残ります。 */ body { color: black; } strong { color: red; } TODO コメントなど、開発時にのみ参照したいコメントは一行コメントで記述しておくとよいでしょう。</description></item><item><title>Sassメモ: 文字列変数の引用符の展開ルール</title><link>https://maku77.github.io/p/by8fhor/</link><pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/by8fhor/</guid><description>引用符で囲まれた文字列、囲まれていない文字列 Sass の文字列変数には、引用符で囲まれた文字列と、囲まれていない文字列の 2 種類があります。 文字列変数を $変数 の形で参照すると、変数定義時の引用符のありなしがそのまま反映されて展開されます。
入力 (SCSS) $family1: &amp;#34;Lucida Grande&amp;#34;; $family2: &amp;#39;Lucida Sans&amp;#39;; $family3: sans-serif; main { font-family: $family1, $family2, $family3; } 出力 (CSS) main { font-family: &amp;#34;Lucida Grande&amp;#34;, &amp;#34;Lucida Sans&amp;#34;, sans-serif; } インターポレーション セレクタ名やコメント、文字列の中で文字列変数を参照する場合は、#{$変数} のようなインターポレーション形式で参照する必要があります。
入力 (SCSS) $name: &amp;#34;maku&amp;#34;; /* これはコメントです by #{$name} */ .note-#{$name} { content: &amp;#34;I am #{$name}&amp;#34; } 出力 (CSS) @charset &amp;#34;UTF-8&amp;#34;; /* これはコメントです by maku */ .note-maku { content: &amp;#34;I am maku&amp;#34;; } 入力ファイルのエンコーディング形式を判別して、@charset ディレクティブまで自動で挿入してくれるみたいですね。</description></item><item><title>Sassメモ: Sass とは／sassコマンドのインストール／sassコマンドの使い方</title><link>https://maku77.github.io/p/tx93n26/</link><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tx93n26/</guid><description>Sass とは Sass は CSS (Cascading Style Sheets) ファイルを効率的に作成するための変換ツールで、Hampton Catlin (ハンプトン・キャトリン) と Nathan Weizenbaum (ネイサン・バイゼンバウム) によって作成されました。 従来の CSS には存在しない変数の仕組みや、ループ処理、モジュールの仕組みなどを使用できるため、効率的に CSS ファイルを作成することができます。 変数の仕組みなどは、CSS のバージョンアップとともにネイティブでサポートされつつありますが、Web ブラウザによって対応状況がまちまちだったりするため、Sass を使って多くのブラウザがサポートしている CSS フォーマットに変換するという方法はまだまだ有効です。
SASS 記法と SCSS 記法 Sass へのインプットに使用するファイルは、「SASS フォーマット」 あるいは 「SCSS フォーマット」 で記述します。 どちらも変換後は CSS ファイルになるのですが、記述方法が若干異なります。
SASS 記法: .sass 拡張子でファイルを作成する。Jade や Python のようにインデントによって構造化する。昔使われていた記法。 SCSS 記法: .scss 拡張子でファイルを作成する。CSS と同様に括弧 ({ と }) で構造化する。Sassy CSS の略で、Sass 3.0 で導入された。現在主流の記法。 現在は、CSS と互換性のある SCSS フォーマットで記述するのが主流です。 CSS ファイルは SCSS ファイルとしても正しい文法とみなせるため、とりあえず .scss 拡張子のファイルに従来の CSS フォーマットでスタイル定義しておいて、徐々に SCSS の機能を使って内容を充実させていく、といった使い方が可能です。</description></item><item><title>Sassメモ: SCSS ファイルの書き方の基本</title><link>https://maku77.github.io/p/34uu8u7/</link><pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/34uu8u7/</guid><description>Sass (SCSS) を使用すると、CSS では扱えないネスト構造でのスタイル記述が可能になります。 Sass には多くの機能がありますが、このネストの仕組みだけでも Sass 導入の価値があります。
入れ子構造 従来の CSS は、一階層のセレクタブロック（{ ～ }）でしかルールセットを記述できませんが、SCSS では下記のような入れ子構造で定義していくことができます。
入力 (SCSS) #main { width: 97%; p, div { font-size: 2em; a { font-weight: bold; } } pre { font-size: 3em; } } 上記のような入れ子構造は子孫セレクタを表現しているとみなされ、Sass プロセッサにより、下記のようにフラットな構造の CSS に展開されます。
出力 (CSS) #main { width: 97%; } #main p, #main div { font-size: 2em; } #main p a, #main div a { font-weight: bold; } #main pre { font-size: 3em; } 子孫セレクタ以外のセレクタシーケンス（子セレクタ (&amp;gt;) や隣接セレクタ (+)）なども、同様に入れ子の形で定義することができます。</description></item></channel></rss>