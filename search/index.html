<!doctype html><html lang=ja-jp><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>サイト内全文検索 - まくまく 天才まくまくノート ノート</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-X5962TDYXS"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-X5962TDYXS")</script><link rel=icon sizes="16x16 32x32 48x48 64x64" href=../assets/img/favicon/favicon.ico><link rel=icon sizes=192x192 href=../assets/img/favicon/192x192.png><link rel=apple-touch-icon href=../assets/img/favicon/180x180.png><meta name=twitter:card content="summary"><meta property="og:site_name" content="天才まくまくノート"><meta property="og:title" content="サイト内全文検索"><meta property="og:type" content="article"><meta property="og:url" content="https://maku77.github.io/search/"><meta property="og:locale" content="ja_JP"><meta property="og:image" content="https://maku77.github.io/img/site-logo.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:description" content="天才星人まくのメモ"><meta property="fb:app_id" content="447708168769292"><link rel=stylesheet href=../css/mm/all.min.55136530d1029180b33591c195c59106ff22cd97524a5d0f34c9d40d913a30ed.css><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6317852277883092" crossorigin=anonymous></script>
<link rel=stylesheet href=../css/all.min.61015e2ae0c42ebe399aca4284093225dd0ab0aa2c37fd097135ef990d488b8e.css><meta name=robots content="noindex,nofollow"></head><body><div class=l-pageHeader></div><div class=l-withSidebar><div class=l-withSidebar__sidebarLeft><style>#tocStub{position:-webkit-sticky;position:sticky;top:2rem;margin-top:2rem;line-height:1.5;max-height:calc(100vh - 4rem);overflow-y:auto;-webkit-overflow-scrolling:touch}#tocStub ul{font-size:.9em;list-style:none;padding:0;border-top:solid 1px #ccc}#tocStub li{border:solid 1px #ccc;border-right:none;margin-top:-1px}#tocStub a{color:#666;padding:.6em .3em .6em .5em;display:block;text-decoration:none;font-weight:400}.level-2{margin-left:.8em}.level-3{padding-left:1.6em}</style><div id=tocStub></div><script>document.addEventListener("DOMContentLoaded",()=>{function e(e){const t=document.createElement("a");return t.setAttribute("id",e),t}function t(t,n){n.parentNode.insertBefore(e(t),n)}function n(e,t,n){const s=document.createElement("li");return s.classList.add("level-"+e),s.innerHTML='<a href="#'+t+'">'+n+"</a>",s}function s(){const e=document.createElement("ul");return document.querySelectorAll("h2, h3").forEach((s,o)=>{const i="section-"+o;t(i,s);const a=s.tagName.charAt(1)-1;e.appendChild(n(a,i,s.textContent))}),e}document.getElementById("tocStub").appendChild(s())})</script></div><div class=l-withSidebar__content><style>#xSearchBox input{margin:.5em .8em;color:#ff1493;font-size:1.2em;font-weight:bolder}#xSearchBox input::-webkit-input-placeholder{color:pink}#result{margin:1em}.item_title{text-decoration:none;color:#36f;font-weight:bolder}.item_excerpt{background:#fff;margin:.5em 2em 1em;padding:.5em;border:dashed 1px #d3d3d3;font-size:smaller}.item_excerpt b{background:pink}</style><article style="padding:1rem 0"><h2>サイト内全文検索</h2><div id=xSearchBox><input id=query onkeyup='location.replace("#"+this.value)' size=15 autocomplete=off autofocus placeholder=検索ワード>
<span id=inputWord></span> <span id=resultCount></span></div><div id=result></div></article><script>const data=[{url:"/rust/",title:"Rust",date:"2024-02-21T00:00:00Z",body:"Rust はじめに（Rust の実行環境） Rust プログラミングを始める（rustc と cargo コマンド） Rust で自作したプログラムをシステムにインストールする (cargo install) Rust の文法 制御構文 (if, match, while, loop, for) 配列 (array) とタプル (tuple) 構造体 (struct) とタプル構造体 (tuple struct) 所有権 (ownership) と借用 (borrow) 列挙型 (enum) の定義と match, if let による照合 パニック (panic) の扱いについて ジェネリクス構造体・関数を定義する（任意の型を扱えるようにする） オブジェクトのライフタイム（生存期間）を理解する ('static, 'a) 標準ライブラリが提供する型 Option 型の基本 ─ 値の有無を表現する型 Result 型の基本 ─ 成功と失敗を表現する型 (Result::Ok, Result::Error) 各種ライブラリのエラー型と Error トレイト Result 型エイリアスでコードを簡潔にする Result オブジェクトを消費せずに参照する (as_ref, as_mut) ? 演算子でエラーを伝搬させる コレクション ベクター型 (Vec) を扱う ハッシュマップ型 (HashMap) を扱う プロジェクト構成（パッケージ／クレート／モジュール） モジュールを定義する (mod) 文字列と数値 数値 複数の数値の中から最小値・最大値を見つける (min, max) 数値を特定の範囲に収まるように修正する (clamp, min, max) 入出力 (I/O)、ファイル ユーザー入力 コマンドライン引数を扱う (1) std::env::args コマンドライン引数を扱う (2) clap クレート キーボードからの入力を取得する (std::io::Stdin) ファイル／ディレクトリ／パス情報 ディレクトリ内のファイルを列挙する (std::fs::read_dir) ファイルやディレクトリの名前を変更（移動）する (std::fs::rename) ディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all) ファイルやディレクトリのパス文字列を構築／分割する (std::io::Path, PathBuf) ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf) ファイルの読み書き JSON フォーマットを扱う (serde) Excel ファイルを読み込む (calamine) Rust の非同期ランタイム tokio の使い方 (async, await, Future) Web / データベース Rust で HTTP サーバーを作る (axum) Rust で MongoDB を扱う (mongodb) その他 正規表現を扱う (regex) 型の名前を取得する (std::any::type_name) おすすめ書籍 『Programming Rust』 Rust 文法を正しく理解するのに最適な本です。 『Rust for Rustaceans』 Rustacean（Rust プログラマー）としてよりよいコードを記述するための本です。"},{url:"/p/6nce7nw/",title:"Rust の ? 演算子でエラーを伝搬させる",date:"2024-02-21T00:00:00Z",body:"Rust の ? 演算子でエラーを伝搬させる エラーの伝搬 (propagating errors) とは Rust でエラーを返す可能性のある関数（Result を返す関数）を呼び出すとき、その戻り値を受けて直ちにエラー処理を行うことは少なく、多くの場合は呼び出し元にエラーを返す（Error 値を伝搬させる）ことになると思います。 let book = match get_book(123) { Ok(book) =\u0026gt; book, Err(err) =\u0026gt; return Err(err.into()), // 呼び出し元にエラーを伝搬 }; このようなケースで、毎回 match を使った条件分岐コードを記述していると、冗長なコードで溢れかえってしまいます。 そこで、Rust はエラーを呼び出し元に伝搬させるための ? 演算子を用意しています（Rust 1.13 以降）。 ? 演算子の使い方 let book = get_book(123)?; このように記述すると、get_book() 関数の戻り値が Result::Ok だった場合はそれを unwrap() した値が book 変数に格納され、戻り値が Result::Err だった場合はそのエラーをそのまま return してくれます。 つまり、前述の match を使ったコードと同じ振る舞いを 1 行で表現することができます。 ? 演算子は、Option を戻り値として返す関数の中でも使用することができます。 その場合、エラー発生時は Option::None を返すという振る舞いになります。 main 関数での具体的な使用例 main() 関数の戻り値の型が、Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; になっているのを見たことがあるかもしれません。 Box\u0026lt;dyn std::error::Error\u0026gt; という型は、Error トレイトを実装したあらゆる型を保持することができる Box 型です。 このような表現にしておくことで、その関数はあらゆる Error 型を返す可能性があることを示すことができます。 例えば、下記の main() 関数は戻り値として汎用的な Result 型を返すように定義しています。 この関数の中では、どんなエラーを返す関数呼び出しでも ? 演算子を使うことができます。 main() 関数の中から、明示的に独自のエラーを返すこともできます。 src/main.rs use std::{env, fs::File, io::Read}; // どんなエラーも扱える Result 型 type Result = std::result::Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt;; fn main() -\u0026gt; Result { let args: Vec\u0026lt;String\u0026gt; = env::args().collect(); if args.len() \u0026lt; 2 { eprintln!(\u0026#34;Usage: {} \u0026lt;file\u0026gt;\u0026#34;, args[0]); return Err(\u0026#34;No file specified\u0026#34;.into()); } // ファイルを開いて読み込む let filename = \u0026amp;args[1]; let mut file = File::open(filename)?; // エラーの可能性 let mut buf = String::new(); file.read_to_string(\u0026amp;mut buf)?; // エラーの可能性 // ファイルの内容を出力 println!(\u0026#34;{}\u0026#34;, \u0026amp;buf); Ok(()) } 実行結果 $ cargo run -q -- hoge.txt Error: Os { code: 2, kind: NotFound, message: \u0026#34;指定されたファイルが見つかりません。\u0026#34; }"},{url:"/p/z6e9or8/",title:"Rust の非同期ランタイム tokio の使い方 (async, await, Future)",date:"2024-02-17T00:00:00Z",body:"Rust の非同期ランタイム tokio の使い方 (async, await, Future) tokio とは tokio は、Rust 用の非同期処理ランタイムです。 さらに、ネットワークアプリケーションの構築に必要な TCP ソケットなどのライブラリも含まれています。 Rust 言語には、コード上で非同期処理を表現するための async/await 構文が用意されていますが、実際に非同期処理を動かすためのランタイムは標準搭載されていません。 非同期処理用の代表的なランタイムが tokio クレートです。 Rust の async は、ソフトウェアにより非同期処理を実現する仕組みであり、スレッド (std::thread) と比べてコンテキストスイッチのコストがかからないという利点があります。 非同期ランタイムの tokio はサードパーティライブラリとして提供されていますが、非同期処理で使われる Future トレイトなどは Rust に標準搭載されています。 tokio の依存関係の追加 tokio を使用するには、cargo add コマンドで Rust プロジェクトに依存関係を追加します。 ここでは、tokio のすべての機能を有効化するために --features full オプションを指定しています。 $ cargo new myapp # （必要があれば）新規プロジェクトを作成 $ cd myapp $ cargo add tokio --features full cargo add コマンドを使用する代わりに、次のように Cargo.toml ファイルに依存関係を記述しても OK です。 Cargo.toml [dependencies] tokio = { version = \u0026#34;1.36.0\u0026#34;, features = [\u0026#34;full\u0026#34;] } async/await による非同期処理 下記は Rust の async/await 構文の基本的な使い方です。 src/main.rs // 非同期関数は async fn で定義する async fn say_world() { println!(\u0026#34;World\u0026#34;); } #[tokio::main] async fn main() { let future = say_world(); // Future インスタンスが返される println!(\u0026#34;Hello\u0026#34;); // say_world() より先に実行される future.await; // ここで say_world() が実行される } 実行結果 $ cargo run -q Hello World 非同期実行する関数を定義するには、async fn という構文を使用します。 上記の say_world 関数と main 関数は両方とも非同期関数として定義されています。 非同期関数は say_world() のように通常の関数と同じ形で呼び出せますが、このタイミングでは実行されず、代わりに Future インスタンス（Future トレイトを実装した型）を返します。 Future インスタンスが指す非同期関数が実際に実行されるのは、.await を呼び出したときです。 結果として、上記の main 関数を実行すると、Hello、World の順番で出力されます。 .await の呼び出しは、非同期関数 (async fn) の中でしか許可されていません。 上記の main 関数は非同期関数として定義されているので、.await の呼び出しが可能です。 main 関数は非同期処理が可能なコンテキスト（＝ランタイム）で実行されなければいけないので、#[tokio::main] というアノテーションをつけて、非同期処理ランタイムの tokio で実行するよう指示しています。 tokio::spawn で非同期処理をすぐに開始する 前述の例からもわかるように、Future インスタンスの .await を呼び出すまでは、非同期関数の実行は開始されません（これは他の言語とは異なる部分かもしれません）。 でも、これだと、その非同期処理が終わるまでそこで待機してしまうので、他の非同期関数を並行して動かすことができません。 Future が指し示す非同期関数を直ちに実行開始するには、tokio::spawn() に Future インスタンスを渡します。 次の例では、実行完了までに 3 秒かかる関数 (process) を、2 回連続して呼び出しています。 src/main.rc use tokio::time::{sleep, Duration}; // 実行に 3 秒かかる非同期処理 async fn process(name: \u0026amp;str) -\u0026gt; String { println!(\u0026#34;START: {}\u0026#34;, name); sleep(Duration::from_secs(3)).await; println!(\u0026#34;END: {}\u0026#34;, name); format!(\u0026#34;result from {}\u0026#34;, name) } #[tokio::main] async fn main() { // 2 つの Future を取得 let future1 = process(\u0026#34;process-1\u0026#34;); let future2 = process(\u0026#34;process-2\u0026#34;); // Future が示す非同期処理を開始する let task1 = tokio::spawn(future1); let task2 = tokio::spawn(future2); // 非同期処理が完了するのを待つ let result1: String = task1.await.unwrap(); println!(\u0026#34;{}\u0026#34;, result1); let result2: String = task2.await.unwrap(); println!(\u0026#34;{}\u0026#34;, result2); } 実行結果 $ cargo run -q START: process-1 START: process-2 （3 秒待つ） END: process-2 END: process-1 result from process-1 result from process-2 3 秒かかる 2 つの処理を同期実行したら 6 秒かかるところですが、ここでは spawn() で 2 つの非同期処理をほぼ同時に実行開始しているので、合計で 3 秒しかかかりません。 spawn() で開始した非同期処理が完了するのを待機するには、spawn() が返す JoinHandle の .await を呼び出します。 2 つ以上の非同期処理がすべて完了するまで待機したいときは、JoinHandle の .await を個別に呼び出すのではなく、tokio::try_join!() にすべての JoinHandle を渡します。 それぞれの非同期処理の結果はタプルとしてまとめて返されます。 // すべての非同期処理が完了するのを待つ let results = tokio::try_join!(task1, task2).unwrap(); println!(\u0026#34;{}, {}\u0026#34;, results.0, results.1);"},{url:"/p/q49pmjt/",title:"Rust で HTTP サーバーを作る (axum)",date:"2024-02-16T00:00:00Z",body:"Rust で HTTP サーバーを作る (axum) axum とは axum は Rust 用の Web フレームワークです。 Repo: https://github.com/tokio-rs/axum/ Docs: https://docs.rs/axum/latest/axum/ axum は Rust の非同期処理ランタイムの代表格である tokio のサブプロジェクトとして公開されました。 そのため、axum を使ったアプリケーション実装では、tokio が提供するフレームワークを組み合わせて使用します。 参考: Rust の非同期ランタイム tokio の使い方 (async/await) Rust 用の Web フレームワークには、他にも Actix Web (actix-web) や Rocket (rocket) などがありますが、axum は後発の Web フレームワークで、公開直後の 2022 年頃から利用者が急増しています。 この人気っぷりは、やはり tokio ファミリーのプロジェクトであることが大きいのでしょう。 axum は、他のフレームワークと違って、get や post マクロなどを使わないのが特徴的で、マクロ疲れしている人にはぴったりです。 その代わりに、リクエストをハンドルする関数に、extractor と呼ばれる引数を配置することで、リクエストの情報を抽出します。 例えば、次のような extractor を、ハンドラー関数の引数として任意の数だけ配置できます。 axum::extract::Path \u0026hellip; パスパラメーター（URL 内のパスの部分的なセグメント）を抽出する axum::extract::Query \u0026hellip; URL の末尾のクエリパラメーターを抽出する axum::extract::Json \u0026hellip; POST メソッドのペイロードとして送られてきた JSON データを抽出する axum::extract::Request \u0026hellip; リクエスト全体を抽出する http::header::Method \u0026hellip; リクエストメソッドを抽出する http::header::HeaderMap \u0026hellip; リクエストヘッダーを抽出する String \u0026hellip; リクエスト本文をそのまま utf-8 文字列で取得する 下記はリクエストに使われた HTTP メソッドとヘッダー、本文（ペイロード）を参照するハンドラー関数の引数の例です。 use axum::http::{Method, HeaderMap}; async fn handler( method: Method, // メソッドを取得したいときはこの引数を配置 headers: HeaderMap, // ヘッダーを取得したいときはこの引数を配置 body: String, // 本文を取得したいときはこの引数を配置 ) { // ... } ここでは、axum を使ってシンプルな HTTP サーバーを実装してみます。 プロジェクトの作成 まず、Rust のプロジェクトを作成します。 ここでは、http-server という名前にします。 プロジェクトの作成 $ cargo new http-server $ cd http-server 必要なライブラリの依存関係を追加します。 通常は、非同期ランタイムの tokio や JSON を扱うための serde も必要になります。 依存情報の追加 $ cargo add axum $ cargo add tokio --features full # 非同期ランタイム $ cargo add serde --features derive # シリアライズ＆デシリアライズ $ cargo add serde_json まずは Hello World サーバーを作ってみる 下記は、Hello, World! というテキストを返すだけの、シンプルな Web サーバーの実装例です。 src/main.rs use axum::{routing::get, Router}; use tokio::net::TcpListener; #[tokio::main] async fn main() { let app = Router::new().route(\u0026#34;/\u0026#34;, get(root)); let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } // 文字列だけを返すハンドラーは、ステータスコード `200 OK` の // `content-type: text/plain; charset=utf-8` のレスポンスになる。 async fn root() -\u0026gt; \u0026amp;\u0026#39;static str { \u0026#34;Hello, World!\u0026#34; } 処理の流れはほとんど明らかだと思いますが、URL のルートパス / に GET メソッドでアクセスしたら root という名前のハンドラー関数が呼ばれる、という実装ですね。 次のようにして Web サーバーを起動できます。 $ cargo run Web サーバーを起動した状態で、別のターミナルや Web ブラウザから http://localhost:8080 にアクセスして、メッセージが返ってきたら成功です。 $ curl localhost:8080 Hello, World! シンプル！ リクエスト時のパスを取得する (axum::extract::Path) リクエストされた URL に含まれるパス情報（例: example.com/users/123 の 123 の部分）を取得したいときは、axum の extractor のひとつである axum::extract::Path を使用します。 次の例では、/users/:id というパスに対するハンドラー関数 get_user() を定義し、:id の位置で指定されたパス文字列を取得しています。 src/main.rs use axum::{extract::Path, routing::get, Router}; use tokio::net::TcpListener; #[tokio::main] async fn main() { let app = Router::new().route(\u0026#34;/users/:id\u0026#34;, get(get_user)); let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn get_user(Path(id): Path\u0026lt;String\u0026gt;) -\u0026gt; String { format!(\u0026#34;User ID: {}\u0026#34;, id) } 実行結果 $ curl 127.0.0.1:8080/users/123 User ID: 123 ちなみに、/users/:user_id/team/:team_id のように 2 つ以上のパスパラメーターを抽出するときは、次のようにタプルを使います。 async fn users_teams_create( Path((user_id, team_id)): Path\u0026lt;(String, String)\u0026gt;, ) { // ... } リクエスト時のクエリ文字列を取得する (axum::extract::Query) 同様に、URL の末尾に指定されたクエリ文字列（例: example.com/search?genre=ACT\u0026amp;year=2000 の genre=ACT\u0026amp;year=2000 の部分）を取得したいときは、axum::extract::Query を使用します。 serde のデシリアライズ機能を使うことで、クエリパラメーターを構造体の形で参照できます。 src/main.rs use axum::{extract::Query, routing::get, Router}; use serde::Deserialize; use tokio::net::TcpListener; #[tokio::main] async fn main() { let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app_router()).await.unwrap(); } fn app_router() -\u0026gt; Router { // クエリパラメーターの型 #[derive(Deserialize, Debug)] #[allow(dead_code)] struct SearchQuery { genre: Option\u0026lt;String\u0026gt;, year: Option\u0026lt;usize\u0026gt;, } // クエリパラメーターのデフォルト値 impl Default for SearchQuery { fn default() -\u0026gt; Self { Self { genre: None, year: None, } } } async fn search(query: Option\u0026lt;Query\u0026lt;SearchQuery\u0026gt;\u0026gt;) -\u0026gt; String { // いずれかのクエリパラメーターが不正な型だった場合は、すべてデフォルト値になる let Query(search_query) = query.unwrap_or_default(); format!(\u0026#34;{:?}\u0026#34;, search_query) } Router::new().route(\u0026#34;/search\u0026#34;, get(search)) } 下記はいろいろなクエリパラメーターでリクエストしたときの、レスポンスの例です。 パラメーターの型が不正なとき（例: year=ABC）は、すべてのパラメーターをデフォルト値（今回はすべて None）として扱っています。 実行結果 $ curl \u0026#34;127.0.0.1:8080/search\u0026#34; SearchQuery { genre: None, year: None } $ curl \u0026#34;127.0.0.1:8080/search?genre=RPG\u0026#34; SearchQuery { genre: Some(\u0026#34;RPG\u0026#34;), year: None } $ curl \u0026#34;127.0.0.1:8080/search?genre=RPG\u0026amp;year=2000\u0026#34; SearchQuery { genre: Some(\u0026#34;RPG\u0026#34;), year: Some(2000) } $ curl \u0026#34;127.0.0.1:8080/search?genre=ACT\u0026amp;year=ABC\u0026#34; SearchQuery { genre: None, year: None } リクエストのメソッドやヘッダー情報を取得する HTTP リクエストに使われたメソッド（GET や POST）を取得したいときは、ハンドラー関数の引数として Method を追加します。 同様に、リクエストヘッダー情報を取得したいときは、ハンドラー関数の引数として HeaderMap を追加します。 src/main.rs use axum::{ http::{HeaderMap, Method}, routing::get, Router, }; use tokio::net::TcpListener; #[tokio::main] async fn main() { // パス `/` で GET と POST の両方をハンドルする let app = Router::new().route(\u0026#34;/\u0026#34;, get(handler).post(handler)); let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn handler( method: Method, // メソッドの extractor headers: HeaderMap, // ヘッダーの extractor ) { println!(\u0026#34;{:?}\u0026#34;, method); println!(\u0026#34;{:?}\u0026#34;, headers); } 下記は、curl コマンドで HTTP リクエストを送ったときのサーバー側の出力を示しています。 実行結果 $ curl \u0026#34;127.0.0.1:8080\u0026#34; GET {\u0026#34;host\u0026#34;: \u0026#34;127.0.0.1:8080\u0026#34;, \u0026#34;user-agent\u0026#34;: \u0026#34;curl/7.79.1\u0026#34;, \u0026#34;accept\u0026#34;: \u0026#34;*/*\u0026#34;} $ curl -X \u0026#34;127.0.0.1:8080\u0026#34; POST {\u0026#34;host\u0026#34;: \u0026#34;127.0.0.1:8080\u0026#34;, \u0026#34;user-agent\u0026#34;: \u0026#34;curl/7.79.1\u0026#34;, \u0026#34;accept\u0026#34;: \u0026#34;*/*\u0026#34;} $ curl \u0026#34;localhost:8080\u0026#34; -H \u0026#34;key:value\u0026#34; GET {\u0026#34;host\u0026#34;: \u0026#34;localhost:8080\u0026#34;, \u0026#34;user-agent\u0026#34;: \u0026#34;curl/7.79.1\u0026#34;, \u0026#34;accept\u0026#34;: \u0026#34;*/*\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;} ステートを保持する (with_state) HTTP はステートレスなプロトコルなので、基本的に各リクエストは独立したものになりますが、Router.with_state() メソッドを使うと、リクエスト間で任意のステート情報を共有することができます。 例えば、次のような用途で使用できます。 アプリケーションの共通設定 データベース接続のプール セッション管理、認証情報の保持 ロードに時間がかかるデータのキャッシュ 次の例では、ステートとして AppState 構造体の値を保持しています。 Router.with_state() でセットしたステート情報は、各ハンドラーの引数として State extractor を配置することで受け取ることができます。 src/main.rs use axum::extract::State; use axum::{routing::get, Router}; use std::sync::Arc; use tokio::net::TcpListener; use tokio::sync::Mutex; // リクエスト間で共有するステートの型 struct AppState { message: String, counter: Mutex\u0026lt;u64\u0026gt;, } #[tokio::main] async fn main() { // ステートの初期化 let app_state = Arc::new(AppState { message: String::from(\u0026#34;Welcome!\u0026#34;), counter: Mutex::new(0), }); let app = Router::new() .route(\u0026#34;/\u0026#34;, get(root)) .with_state(app_state); // ルーター内でステートを共有 let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } // ハンドラーの引数としてステートを受け取る async fn root(State(app_state): State\u0026lt;Arc\u0026lt;AppState\u0026gt;\u0026gt;) -\u0026gt; String { let mut counter = app_state.counter.lock().await; *counter += 1; format!(\u0026#34;{} {}\u0026#34;, app_state.message, *counter) } ハンドラーの中でステートの counter 値をインクリメントしているので、curl や Web ブラウザーでアクセスするたびに次のように出力が変わります。 実行結果 $ curl 127.0.0.1:8080 Welcome! 1 $ curl 127.0.0.1:8080 Welcome! 2 $ curl 127.0.0.1:8080 Welcome! 3 POST リクエストで送られた JSON データを取得する POST メソッドで送られてきた本文を単純な utf-8 文字列として取得するだけであれば、次のようにハンドラー関数に String 型の引数を追加するだけですみます。 async fn handler(body: String) { println!(\u0026#34;{}\u0026#34;, body); } ただ、REST API などを実装しているときは、本文として送られてくるデータは JSON 形式になっていることがほとんどなので、このデータを構造体インスタンスとして参照できると便利です。 axum の JSON extractor と、serde の Deserialize 属性を使うことでこれを実現できます。 次の例では、本文として送られてきた JSON データを CreateTodoPayload 構造体として参照しています。 src/main.rs use axum::{extract::Json, routing::post, Router}; use serde::Deserialize; use tokio::net::TcpListener; #[derive(Debug, Deserialize)] struct CreateTodoPayload { title: String, // 必須のフィールド note: Option\u0026lt;String\u0026gt;, // 省略可能なフィールド } #[tokio::main] async fn main() { let app = Router::new().route(\u0026#34;/todos\u0026#34;, post(create_todo)); let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn create_todo(Json(payload): Json\u0026lt;CreateTodoPayload\u0026gt;) -\u0026gt; String { let title = payload.title; let note = payload.note.unwrap_or_default(); // 省略時は空文字列とする format!(\u0026#34;Created: title={}, note={}\u0026#34;, title, note) } 実行結果 $ curl -X POST \u0026#39;localhost:8080/todos\u0026#39; \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ --data \u0026#39;{\u0026#34;title\u0026#34;: \u0026#34;Title-1\u0026#34;, \u0026#34;note\u0026#34;: \u0026#34;Note-1\u0026#34;}\u0026#39; Created: title=Title-1, note=Note-1 レスポンスとして JSON データを返す 構造体データを JSON 形式のレスポンスとして返したいときは、ハンドラー関数の戻り値で axum::Json を返します（axum::reponse::Json でも OK）。 Json コンストラクターには、serde の Serialize 属性をつけた構造体インスタンスを渡します。 src/main.rs use axum::{extract::Path, routing::get, Json, Router}; use serde::Serialize; use tokio::net::TcpListener; #[derive(Debug, Serialize)] struct UserInfo { id: String, name: String, } #[tokio::main] async fn main() { let app = Router::new().route(\u0026#34;/users/:id\u0026#34;, get(get_user)); let listener = TcpListener::bind(\u0026#34;0.0.0.0:8080\u0026#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn get_user(Path(user_id): Path\u0026lt;String\u0026gt;) -\u0026gt; Json\u0026lt;UserInfo\u0026gt; { // 本当はデータベースなどからユーザー情報を取得する let user_info = UserInfo { id: user_id.clone(), name: format!(\u0026#34;User-{}\u0026#34;, user_id), }; // JSON 形式のレスポンスとして返す Json(user_info) } 実行結果 $ curl \u0026#39;127.0.0.1:8080/users/123\u0026#39; {\u0026#34;id\u0026#34;:\u0026#34;123\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;User-123\u0026#34;}"},{url:"/p/4xyn2kv/",title:"Matplotlib によるプロットの例（散布図）",date:"2024-02-09T00:00:00Z",body:"Matplotlib によるプロットの例（散布図） Python の Matplotlib によるプロットの例です。 すぐに忘れてしまうのでメモメモ( ..)φ 散布図 (scatter diagram) 2 つの特徴量を X/Y 座標値としてプロット 図: 散布図の例 テスト用のサンプルデータ（アヤメの分類データ） def load_data(): from sklearn import datasets iris = datasets.load_iris() # 各サンプルの特徴量には下記の 4 つが含まれている # - sepal length (cm) # - sepal width (cm) # - petal length (cm) # - petal width (cm) features = iris.data # 各サンプルの正解ラベルとして下記のいずれかが含まれている # - 0: setosa # - 1: versicolor # - 2: virginica targets = iris.target return features, targets import matplotlib.pyplot as plt features, targets = load_data() # 2 つの特徴量を X/Y 座標値とした散布図を描画 fig, ax = plt.subplots(figsize=(6, 4), layout=\u0026#34;tight\u0026#34;) ax.set_xlabel(\u0026#34;speal length (cm)\u0026#34;) ax.set_ylabel(\u0026#34;sepal width (cm)\u0026#34;) ax.scatter(x=features[:, 0], y=features[:, 1]) fig.savefig(\u0026#34;img-scatter.svg\u0026#34;) plt.show() Matplotlib で散布図を描画するには、scatter 関数を使用します。 散布図のどの座標に点を打つかは、x、y 引数に、X 軸と Y 軸の座標値リストを渡すことで指示します。 ここでは、features[:, 0] で「speal length (cm)」のリスト、features[:, 1] で「speal width (cm)」のリストを取り出して渡しています。 各点に意味を持たせる 図: 散布図の例 (2) scatter 関数に X/Y 座標値だけを渡すと、前述の例のように、すべての点が同じ記号で表示されます。 c 引数で、各点の値のリストを渡すことで、異なる色で点を打つことができます。 import matplotlib.pyplot as plt features, targets = load_data() # 2 つの特徴量を X/Y 座標値とした散布図を描画 fig, ax = plt.subplots(figsize=(6, 4), layout=\u0026#34;tight\u0026#34;) ax.set_xlabel(\u0026#34;speal length (cm)\u0026#34;) ax.set_ylabel(\u0026#34;sepal width (cm)\u0026#34;) scatter = ax.scatter(x=features[:, 0], y=features[:, 1], c=targets) ax.legend(*scatter.legend_elements()) # 各点の値の凡例を表示 fig.savefig(\u0026#34;img-scatter-2.svg\u0026#34;) plt.show() ちなみに、c 引数で渡している targets 変数には、次のような正解ラベル (0, 1, 2) が含まれています。 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]"},{url:"/python/",title:"Python",date:"2024-02-09T00:00:00Z",body:"Python はじめに／基本 コーディングスタイル／ドキュメンテーション コーディングスタイル Python のコーディングスタイル Visual Studio Code で Python 用のフォーマッター (Black) を使う ドキュメンテーション ドキュメンテーションコメント (docstring) を記述する Windows で pydoc コマンドを使用できるようにする 関数やクラスのソースコードを確認する (insepct) 開発ツール／デバッグ／ユニットテスト 実行環境／仮想環境 python コマンドのバージョンを切り替える (pyenv, py) Python の実行環境を venv で切り替える（仮想環境） Python の実行環境を virtualenv で切り替える（仮想環境）（Python 3.2 以前） パッケージ Python のパッケージ管理ツール (pip) の使い方 Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe) 対話型シェル Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP) Python の対話型シェルで使える小技 テスト Python でユニットテストを記述する (unittest) パフォーマンス Python コードの実行時間を計測する (datetime.now) python コマンド／実行環境 python コマンドでワンライナーを実行する Python スクリプトの中で Python のバージョンを確認する (sys.version) 拡張子に関連付けられたアプリケーションでファイルを開く (os.system) Python の最大再帰数を調べる／変更する Python から外部プログラムを起動する (subprocess.run) 環境変数 環境変数を参照する (os.getenv, os.environ) .env ファイルで環境変数を設定する (python-dotenv) 構文 モジュール / パッケージ Python でモジュールやパッケージを作成する Python でモジュールを import する方法のまとめ import 時のモジュールの検索パスを調べる (sys.path) 型 / 変数 Python の型の一覧、ある値の型を調べる (type) Python で定数を定義する 制御構文 Python の if 構文 Python の switch 構文 range による数値のループ処理いろいろ 三項演算子（条件演算子）を扱う 全てが真 (all)、少なくとも一つが真 (any) かどうか調べる メソッド / 関数 Python の関数をキーワード引数を使って呼び出す Python の関数で可変長引数を扱う (*args, **kwargs) クラス クラス定義の基本 (class) オブジェクトを print 関数で出力できるようにする (__str__) オブジェクトの属性に名前でアクセスする (getattr, setattr) dataclass デコレーターで簡単にデータクラスを定義する 型 数値 2進数、8進数、16進数の数値リテラル 数値と文字（文字列）を変換する (chr, ord, int, hex, oct, bin) 整数の割り算の結果を整数 or 少数点数で取得する 小数点以下を四捨五入する／切り捨てる／切り上げる 独自オブジェクトの配列から最小値、最大値を求める (min_by/max_by) リスト要素の合計値を求める (sum) ランダムな数値（乱数）を生成する (randrange, randint, random, uniform) 階乗を求める (math.factorial) 順列の数 (nPr) を求める 組み合わせの数 (nCr) を求める 文字列 Python の文字列リテラルいろいろ 文字列の中で変数を展開する（書式文字列によるフォーマット） (str#format, % 演算子) 同じ文字列を繰り返した文字列を作成する 文字列の長さを調べる (len) 文字列がある文字列で始まっている／終わっているかを調べる 文字列が正規表現に完全一致するか調べる (re.fullmatch) 文字列内の部分文字列を検索する／抽出する（正規表現） 文字列を置換する (str.replace, re.sub, re.subn) 分割 文字列をデリミタで分割する (split) 文字列を改行で分割して 1 行ずつのリストにする (splitlines) 文字列を 1 文字ずつに分割してリストにする リスト内の要素を結合して文字列にする (join) 文字列を逆順にする（反転させる） ランダムな文字列を生成する (random.choice) Python で UUID を生成する (uuid.uuid4) JSON JSON テキスト ⇔ Python オブジェクトの相互変換 (json.loads, json.dumps) シーケンス (Lists and Tuples) リストとタプルの違い リストとタプルの生成 リストやタプルをサイズを指定して作成する (［］＊ N) 連番からなるリストを生成する (range) リストに要素を追加する／リストを結合する (append, extend, +) リスト／タプルをループで処理する リスト／タプルのサイズを取得する (len) リスト／タプル内の要素をランダムで取得する (random.choice, random.choices, random.sample) リストを昇順ソート／降順ソートする (list.sort/sorted) リストをシャッフルする (random.shuffle) リストから特定の値を持つ要素を削除する (list.remove) リストをフィルタして条件に一致する要素を抽出する (filter) リスト内の特定の値を持つ要素の数を数える (list.count) リスト内の条件に一致する要素の数を数える リスト内の要素をまとめて変更する (map) 二次元配列を作成する 二次元配列をソートする 2 つのリストに重複する要素を抽出する（set と \u0026amp;） 辞書・ディクショナリ (Dictionary) dictionary（辞書）チートシート dictionary（辞書）の基本 dictionary オブジェクトを作成する ({}, dict) dictionary の要素を参照・変更する ([], get) dictionary の要素数を取得する (len) dictionary に指定したキーが存在するか調べる (in) dictionary の要素を削除する (del) dictionary をループ処理する (items, enumerate) dictionary の要素をソートして出力する (sorted) キーでソートしてループ（昇順/降順） 値でソートしてループ（昇順/降順） キーのリストと値のリストを組み合わせて dictionary を生成する (zip) dictionary からキーや値のリストを作成する (keys, values, items) 2 つの dictionary をマージする (update) dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault) dictionary の内部的な要素順序を変更する (dict, OrderedDictionary) セット (Set) set オブジェクトの基本 set オブジェクトで集合演算を行う 入出力 (I/O) コマンドライン引数／標準入力／標準エラー出力 コマンドライン引数 コマンドライン引数を扱う (sys.argv) argparse モジュールでコマンライン引数を扱う キーボードからのユーザ入力を取得する (input, getpass) print print 関数の改行を抑制する print 関数に複数のパラメータを渡した時の接続文字を変更する 標準入力から読み込む (sys.stdin, fileinput) 標準エラー出力へ出力する (sys.stderr) 任意のオブジェクトを見やすく整形して出力する (pprint) パス 実行中のスクリプトのファイル名やパスを取得する パスからファイル名だけを取り出す (basename) パスを結合する (join) パスを指定したディレクトリからの相対パスに変換する (os.path.relpath) ファイル／ディレクトリ 列挙 ディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob) 指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob) コピー／移動／リネーム ファイル／ディレクトリの名前を変更する (os.rename, os.renames) ファイル／ディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move) 作成／削除 ディレクトリを作成する (os.mkdir, os.makedirs) ディレクトリを削除する (os.rmdir) ファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir) Python スクリプトが格納されているディレクトリのパスを取得する テンポラリファイル／ディレクトリを作成する (tempfile) ファイルの読み書き 基本的なファイル読み書き テキストファイルを読み込む (open, read, readline, readlines) テキストファイルを書き込む (open, write, writelines) CSV/TSV CSV ファイルや TSV ファイルを読み込む (csv.reader) JSON ファイル JSON 形式のテキストファイルを読み書きする (json.load, json.dump) Python のワンライナーコマンドで JSON ファイルを整形する (json.tool) YAML ファイル YAML ファイルを扱う HTML ファイル HTML をパースする (HTMLParser) HTML をパースする (BeautifulSoup) XML ファイル XML を扱う方法いろいろ XML をパースする (ElementTree) XML をパースする (minidom) XPath を使って XML 要素を参照する (ElementTree) XML を構築する (minidom) Excel ファイル Excel ファイルを読み込む (xlrd) ZIP/JAR ファイル ZIP/JAR ファイルの内容を読み込む (zipfile) ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive) その他のファイル、応用サンプル HTML ファイルや Markdown ファイルやプレーンテキストに変換する (unstructured) Java や C/C++ のコード中のコメントを削除する 複数ファイルの文字列をまとめて置換する (glob, re) 複数ファイルをまとめて grep する Web / HTTP URL URL 文字列を各パートに分割する (urllib.parse.urlparse) 文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode) HTTP リクエスト Python で HTTP を扱う方法いろいろ urllib.request urllib による HTTP 通信 (1) GET/POST リクエスト (urllib.request.urlopen) urllib による HTTP 通信 (2) プロキシ経由でアクセスする ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve) urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler) urllib による HTTP 通信 (5) ヘッダを付けてリクエストする urllib による HTTP 通信 (6) レスポンスヘッダを取得する requests パッケージのチートシート requests パッケージによる HTTP 通信の例 サンプルコード Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する HTTP サーバー Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) 未分類 ハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (hashlib) データベース / SQL Python で SQLite データベースを使用する 日時（日付／時刻） Python で日時（日付／時刻）の情報を扱う (datetime, date, time, timedelta) 現在時刻から YYYY-MM-DD のような日付文字列を生成する (strftime) 画像処理 scikit-image scikit-image で画像処理 scikit-image の data パッケージに含まれるテスト画像を使用する OpenCV OpenCV: 画像を閾値で二値化（白黒画像化）する (cv2.threshold) keras MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists) NumPy / pandas / Matplotlib / scikit-learn 共通 NumPy / pandas / Matplotlib の概要とインストール NumPy NumPy 配列 (ndarray) の基本 NumPy 配列 (ndarray) の作成方法まとめ pandas pandas でラベル付き 1 次元データを扱う (Series) pandas でラベル付き 2 次元データを扱う (DataFrame) pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) pandas で CSV/TSV ファイルを出力する (pd.to_csv) pandas で DataFrame をループ処理する (iterrows, items) pandas チートシート DataFrame のデータ抽出方法まとめ 具体例 DataFrame のデータ加工方法まとめ DataFrame の欠損値 (NaN) の扱い方まとめ pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix) pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes) pandas の DataFrame のカラムのデータ型を変更する (df.astype) Matplotlib Matplotlib の Axes、Figure、pyplot の関係を理解する Matplotlib によるプロットの例（散布図） scikit-learn scikit-learn 組み込みのデータセットを扱う (sklearn.dataset) wxPython 基本ウィンドウとレイアウト wxPython によるウィンドウ表示の基本 wxPython - Dialog（ダイアログ） wxPython - Frame（フレーム） wxPython - Layout（レイアウト） wxPython - SplitterWindow（スプリッターウィンドウ） 各種コンポーネント wxPython - Button（ボタン） wxPython - CheckBox（チェックボックス） wxPython - CheckListBox（チェック付きリストボックス） wxPython - Choice（プルダウンボックス） wxPython - ComboBox（コンボボックス） wxPython - Gauge（プログレスバー） wxPython - Grid（グリッド） wxPython - HtmlWindow（HTML ウィンドウ） wxPython - ListBox（リストボックス） wxPython - Menu（メニュー） wxPython - RadioButton（ラジオボタン） wxPython - Slider（スライダー） wxPython - SpinCtrl（スピンコントロール） wxPython - StaticText（変更不可のラベル） wxPytnon - StatusBar（ステータスバー） wxPython - TextCtrl（テキスト入力用） その他の wxPython メモ wxPython のイベントハンドラを理解する wxPython アプリケーションのエラー出力方法を理解する wxPython によるグラフィックス処理を理解する wxPython でマウスカーソル関連のイベントを処理する wxPython のコンポーネントをドラッグで動かせるようにする wxPython 関連コラム コラム Python 開発の歴史 Python のインデントによる構造化に慣れる Python のリスト内包表記に慣れる"},{url:"/docker/",title:"Docker",date:"2024-01-31T00:00:00Z",body:"Docker Docker をはじめる（インストールと設定） Docker をインストールする (Docker Desktop / Docker Engine) Docker のプロキシ設定 一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録） Docker の基本的な使い方 Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run) Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach) Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs) Docker Compose の基本（docker コマンドを使いやすくする） Docker コマンドによる操作 Docker チートシート／Docker コマンドの一覧 イメージ (docker image) Docker のコンテナイメージを作成する (docker image build, docker container commit) Docker のコンテナイメージを削除する (docker image rm/prune) （応用）リポジトリ名のついていない Docker イメージをすべて削除する (docker image rm) Docker のコンテナイメージを Docker Hub に登録する (docker image push) Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する Docker Hub のイメージを検索する (docker search) コンテナ (docker container) Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top) Docker コンテナの詳細情報を表示する (docker container inspect) Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port) すべての Docker コンテナを停止／削除する (docker container stop/rm) Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp) ネットワーク (docker network) Docker のネットワークについて理解する (none, host, bridge) Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal) Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh) マウント（ボリューム、バインドマウント、tmpfs マウント） Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfsマウント） Docker Compose Docker Compose の基本 (docker compose up) Docker Compose をデタッチモードで起動する (docker compose up -d) Docker Compose で環境変数を使用する (env_file, environment) Docker コンテキスト (docker context) Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する その他 サーバー再起動時に Docker コンテナを自動起動する トラブルシューティング Docker で apt-get install するときに TERM 系のエラーが出る Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき （旧）Android ビルド環境を構築するための Dockerfile"},{url:"/p/rh8qm2n/",title:"サーバー再起動時に Docker コンテナを自動起動する",date:"2024-01-31T00:00:00Z",body:"サーバー再起動時に Docker コンテナを自動起動する VPS などのサーバーを再起動したときに Docker コンテナを自動起動するには、docker container run コマンドでコンテナを起動するときに、--restart フラグを付けて 再起動ポリシー を設定します。 $ docker run -d --restart always redis Docker Compose ファイルを使う場合は次のように記述します。 docker-compose.yml version: \u0026#39;3.8\u0026#39; services: redis: image: redis container_name: redis restart: always 起動方法 $ docker compose up -d 正確には VPS サーバーの再起動時というより、Docker デーモンの再起動時に、コンテナの再起動ポリシーによりコンテナが再起動されるという流れになります。 VPS サーバーが起動したときに Docker デーモンを自動起動するようにする設定は、systemd などのプロセスマネージャーで別途設定しておく必要があります。 ☝️ ワンポイント VPS サーバー再起動時の Docker コンテナー自動起動の流れ: プロセスマネージャー (systemd) により Docker デーモンが起動する Docker の再起動ポリシーによりコンテナが起動する"},{url:"/p/tzwio3y/",title:"corepack で yarn や pnpm などのパッケージマネージャーを管理する",date:"2024-01-25T00:00:00Z",body:"corepack で yarn や pnpm などのパッケージマネージャーを管理する corepack とは Node.js の実行環境には、パッケージマネージャーとして標準で npm コマンドが搭載されていますが、npm の代わりに yarn や pnpm などを導入しているプロジェクトが多くあります。 従来は、これらのコマンドを npm install -g pnpm のように別途インストールする必要がありましたが、Node.js に標準搭載された corepack を使用すると、初めからインストールされているかのようにyarn や pnpm コマンドを実行できるようになります。 また、使用するパッケージマネージャーを、package.json の packageManager プロパティで管理することができるので、プロジェクト内で使用するパッケージマネージャーとそのバージョンを統一できます。 corepack を有効化する corepack コマンドは Node.js 環境に組み込まれていますが、Node.js 21 の時点ではまだ実験段階 (experimental status) のため、corepack enable コマンドを実行して明示的に有効化 (Opt-in) しておく必要があります。 このコマンドは、システム内で一度だけ実行すれば大丈夫です。 corepack によるパッケージマネージャー管理を有効化 $ corepack enable このコマンドを実行することで、node コマンドの実行ファイルが置かれたディレクトリ内に、yarn や pnpm などのシンボリックリンクが生成されます。 これで、システム全体で yarn や pnpm コマンドを実行できるようになります。 もし、npm install や brew でグローバルインストールした yarn や pnpm がある場合は、もう必要ないのでアンインストールしておきましょう。 不要な yarn や pnpm はアンインストール $ npm uninstall -g yarn $ brew uninstall yarn 各パッケージマネージャーのコマンド（シンボリックリンク）が、node と同じ場所に存在していれば、おそらくうまくいっています。 $ which node npm yarn pnpm /Users/maku/.nvm/versions/node/v21.6.1/bin/node /Users/maku/.nvm/versions/node/v21.6.1/bin/npm /Users/maku/.nvm/versions/node/v21.6.1/bin/yarn /Users/maku/.nvm/versions/node/v21.6.1/bin/pnpm corepack で yarn や pnpm を使用するよう設定する corepack 経由の yarn や pnpm を使用する場合、package.json ファイルの packageManager プロパティで、使用するパッケージマネージャーとそのバージョンを定義しておくことができます。 ここでは、テスト用の Node.js アプリを使って設定してみます。 テスト用のアプリを新規作成 $ mkdir myapp \u0026amp;\u0026amp; cd myapp $ npm init -y プロジェクト内で使用するパッケージマネージャーは、corepack use コマンドで指定します。 使用するパッケージマネージャーを定義 $ corepack use npm@* # npm の最新版を使う場合 $ corepack use npm@10 # npm バージョン 10.x.x を使う場合 $ corepack use yarn@* # yarn の最新版を使う場合 $ corepack use yarn@4 # yarn バージョン 4.x.x を使う場合 $ corepack use pnpm@* # pnpm の最新版を使う場合 $ corepack use pnpm@9 # pnpm バージョン 9.x.x を使う場合 例えば、パッケージマネージャーとして pnpm を使うよう指定した場合、package.json ファイルに次のように記録されます。 package.json { \u0026#34;name\u0026#34;: \u0026#34;myapp\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, // ... \u0026#34;packageManager\u0026#34;: \u0026#34;pnpm@9.0.0-alpha.0+sha256.73ada1a82ae5a6...（省略）...\u0026#34; } あとは、通常通り yarn や pnpm コマンドを使って Node パッケージをインストールしていけば OK です。 $ pnpm install dotenv 使用する pnpm のバージョンは package.json に記述されているので、チーム内の他のメンバーが pnpm コマンドを実行するときも同じバージョンが使われるようになります。 他のメンバー（や CI/CD）の環境でビルドするとき $ corepack enable # （システム内で一度だけ実行） $ pnpm install # 指定された pnpm バージョンを使って依存パッケージをインストール $ pnpm build # build スクリプトの実行"},{url:"/nodejs/",title:"Node.js",date:"2024-01-25T00:00:00Z",body:"Node.js Node.js 実行環境など Node.js とは - Node.js をインストールする nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager) corepack で yarn や pnpm などのパッケージマネージャーを管理する Node.js スクリプトにシェバング (#!) を付けてコマンドとして起動できるようにする Node.js で assert を使用する Node.js で環境変数を参照する (process.env) 環境変数の代わりに .env ファイルを使用する (dotenv) Node.js がどのバージョンの V8 エンジンで動作しているか調べる nodemon で Node.js サーバの再起動を自動化する モジュール／パッケージ Node.js 用モジュールの作り方（require でロード可能な Node モジュールを作成する） Node.js が require() で検索するパスのまとめ 外部の JSON ファイルを読み込む (require) モジュール自身のコードにテストコードを記述する (require.main) npm (Node Package Manager) npm コマンドで Node.js のパッケージをインストール／アンインストールする (npm install, uninstall) npm コマンドでインストールされている Node.js 用パッケージの一覧を表示する (npm list, ll) npm コマンドでインストール可能なパッケージを検索する (npm search) npm コマンド用に HTTP プロキシを設定する (npm config) npm でインストール可能なパッケージのバージョンを調べる npm run で任意のコマンドを実行する (npm run, npm start) npm run のスクリプトの中でファイルのコピーを行う (cpx) npm run のスクリプトの中でディレクトリの削除を行う (rimraf) npm run のスクリプトを連続実行・並列実行する (npm-run-all) package.json package.json ファイルを作成する (npm init) package.json ファイルで依存パッケージを管理する package.json の書式、説明を確認する (npm help json) 入出力 (I/O) 標準出力 (stdout)、標準エラー出力 (stderr) への出力 コマンドライン引数（パラメータ）を取得する (process.argv) キーボードからの入力を取得する (reaqline.question) 外部プログラムを実行してその出力を取得する ファイル／ディレクトリ 実行中の JavaScript ファイルのパスやディレクトリ名を取得する (__filename, __dirname) エントリポイントとなった JavaScript ファイルのパスやディレクトリ名を取得する (require.main.filename) パスを結合する (path.join) 指定したパスがディレクトリかどうか調べる カレントディレクトリ以下のファイルを列挙する CSV CSV ファイルを読み込む Yaml Yaml ファイルを読み書きする (js-yaml) SQLite データベース SQLite を使用する (1) node-sqlite3 のインストール SQLite を使用する (2) node-sqlite3 による逐次処理 SQLite を使用する (3) SELECT 文を実行する MongoDB データベース mongoose (1) mongoose をインストールする mongoose (2) データベースへ接続する mongoose (3) モデルクラスを作成する mongoose (4-1) DB にドキュメントを追加する mongoose (4-2) DB からドキュメントを検索する mongoose (4-3) DB のドキュメントを更新する mongoose (4-4) DB からドキュメントを削除する mongoose と Express で RESTful Web API を作成する mongojs で MongoDB を扱う デバッグ／テスト プログラムの実行時間を計測する (console.time, console.timeEnd) 現在位置のスタックトレースを出力する (console.trace) ネットワーク URL Node.js で URL のパスを結合する (url-join) HTTP 通信 / HTTP サーバ http 標準モジュールを使用して HTTP サーバを立てる http 標準モジュールを使用して HTTP 通信を行う node-fetch モジュールを使用して HTTP 通信を行う request モジュールを使用して HTTP 通信を行う (deprecated) request-promise モジュールを使用して HTTP 通信を行う (deprecated) プロキシ経由の HTTP 通信を行う（global-agent モジュール） プロキシ経由の HTTP 通信を行う（request モジュール） WebSocket 通信 WebSocket のクライアントを作成する Node.js で WebSocket サーバを作る（簡単な echo サーバ） Node.js で WebSocket サーバを作る（chat サーバ） WebSocket サーバに接続してきたクライアントの情報を調べる Web サーバ (Express) Express の特徴 Express をインストールする Express で Web サーバを作成する GET/POST メソッドで送られてきたデータを取得する Express のルート定義の URL のパラメータで数字のみを受け付けるようにする Express で next() により次のハンドラへ処理を委譲する RESTful API として検索用の URL を定義する (req.query) jQuery クライアントと Express サーバで JSON データを送受信する Express サーバの HTTP アクセスログを表示する (express.logger() / morgan) Express サーバの Internal Server Error を分かりやすく HTTP ページで表示する Express の動作環境を切り替える（NODE_ENV 変数） Express で静的ファイル（static ファイル）をホスティングする リバースプロキシ経由で Express サーバにアクセスしたときのクライアントのアドレスを取得する Express でテンプレートエンジンとして Jade を使用する Express で Basic 認証を有効にする Express で CORS の設定を行う（クロスドメインでの Ajax を許可） リバースプロキシ Node.js でお手軽リバースプロキシを作る Node.js の制御構文 例外処理 try ～ catch による例外処理 Uncaught Exception（未捕捉例外）をハンドルする ドメインごとに Uncaught Exception（未捕捉例外）をハンドルする 非同期処理 util.promisify でコールバックベースの関数を Promise 化する async.js による非同期処理 非同期処理のフロー制御を行う (1) async.js を使う準備 非同期処理のフロー制御を行う (2) 複数の非同期処理の結果を同時に取得 (async.parallel) 非同期処理のフロー制御を行う (3) 複数の非同期処理を指定した順に実行する (async.series, async.waterfall)"},{url:"/p/rfduqhx/",title:"pandas で DataFrame をループ処理する (iterrows, items)",date:"2024-01-08T00:00:00Z",body:"pandas で DataFrame をループ処理する (iterrows, items) pandas の DataFrame にはブロードキャストによる演算機能が備わっているため、ほとんどの場合はループ処理を記述する必要はありませんが、明示的にループ処理することも可能です。 行のループ処理 (iterrows) df.iterrows() メソッドを使用すると、各行をイテレート処理できます。 import pandas as pd # サンプルデータ df = pd.DataFrame({ \u0026#34;Name\u0026#34;: [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;], \u0026#34;Age\u0026#34;: [25, 30, 35], \u0026#34;City\u0026#34;: [\u0026#34;New York\u0026#34;, \u0026#34;San Francisco\u0026#34;, \u0026#34;Los Angeles\u0026#34;], }) # DataFrame の各行をループ処理 for i, row in df.iterrows(): print(f\u0026#34;{i}: Name={row[\u0026#39;Name\u0026#39;]}, Age={row[\u0026#39;Age\u0026#39;]}, City={row[\u0026#39;City\u0026#39;]}\u0026#34;) 実行結果 0: Name=Alice, Age=25, City=New York 1: Name=Bob, Age=30, City=San Francisco 2: Name=Charlie, Age=35, City=Los Angeles 列のループ処理 (items) df.items() メソッドを使用すると、各列をイテレート処理できます。 ループごとに、各列のラベル名と Series オブジェクトのタプルを取得できます（ラベル名は series.name でも取得できるんですけどね^^）。 import pandas as pd # サンプルデータ df = pd.DataFrame({ \u0026#34;Name\u0026#34;: [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;], \u0026#34;Age\u0026#34;: [25, 30, 35], \u0026#34;City\u0026#34;: [\u0026#34;New York\u0026#34;, \u0026#34;San Francisco\u0026#34;, \u0026#34;Los Angeles\u0026#34;], }) # DataFrame の各列をループ処理 for label, series in df.items(): print(f\u0026#34;{label}: {series.values}\u0026#34;) 実行結果 Name: [\u0026#39;Alice\u0026#39; \u0026#39;Bob\u0026#39; \u0026#39;Charlie\u0026#39;] Age: [25 30 35] City: [\u0026#39;New York\u0026#39; \u0026#39;San Francisco\u0026#39; \u0026#39;Los Angeles\u0026#39;]"},{url:"/hugo/",title:"Hugo",date:"2023-12-28T00:00:00Z",body:"Hugo 高速な静的サイトジェネレータ Hugo の使い方です。 Go 言語に関する記事はこちらへ分離しました。 はじめに Hugo とは／Hugo をインストールする Hugo で新規の Web サイトを作成する 記事の作成 Hugo で記事を作成する Hugo でドラフトページを作成する Hugo でドラフトページの一覧を簡単に確認できるようにする Hugo のテーマを設定する Hugo で独自のテーマを作成する Hugo Themes（Hugo テーマの一覧サイト） hugo コマンドと設定ファイル hugo コマンド カレントディレクトリを気にせずに hugo コマンドを実行する (hugo server -s) ポート番号を指定して Hugo サーバーを起動する (hugo server -p) Hugo サーバーで記事生成のキャッシュを無効にする (hugo server --ignoreCache) 複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる 複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir) 使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates) 設定ファイル (config) 日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage) コンフィグファイルに設定した情報を参照する Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics) ページ内に Tex 形式の数式を埋め込めるようにする (MathJax) リンクをページからの相対パスで出力するようにする (relativeurls) Hugo Modules Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する ショートコード (Shortcode) ショートコードの使い方と作り方 ショートコードで本文内に HTML スニペットを埋め込む 独自のショートコードを作成する ショートコードの中からフロントマターのパラメータを参照する ($.Page.Params) ショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params) ソースコードをハイライト表示する (highlight) ショートコードをエスケープ処理してそのまま表示する あるショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode) ショートコードで本文とパラメーターの有無で処理を分岐する ショートコードの例 ローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する SVG ファイルをインラインで埋め込む svg ショートコードを作成する クリックで開閉する accordion ショートコードを作成する Youtube の動画を表示する youtube ショートコード（Hugo 組み込み） テンプレート テンプレートによるレイアウトの基本 レイアウト用のテンプレートの種類を理解する 記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout) サイトのヘッダーとフッターをパーシャルファイルに分離する (partials/header.html, partials/footer.html) ベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html) Hugo のテンプレート文法 Hugo テンプレート内にコメントを記述する ({{/* ... */}}) Hugo テンプレート内で変数を扱う ({{ $x := ... }}) Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range) Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range) Hugo テンプレート内で if や with で分岐処理する Hugo テンプレートで数値によるループ処理を行う (range, seq) Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき） Hugo のパーシャルテンプレートから値を返す（関数化）(return) セクションとページリスト Hugo のセクション機能の基本（記事を階層化する） セクションテンプレート (section.html) の中でセクションのタイトルを表示する セクションの階層構造を取得する (.CurrentSection、.Parent、.Sections) ページタイトルに自動でセクションプレフィックスを付ける ページの階層構造を取得する関数を作成する (get-hierarchy) 一覧表示のサンプルコード サイト内の全ページの一覧を表示する (.Site.Pages) サイト内の全セクションの一覧を表示する (.Site.Sections) カレントセクション直下のページ／セクションの一覧を表示する セクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages) サイト内の全ページの一覧をセクションの階層構造に従って表示する サイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示） 最近更新された記事（新着記事）のリストを表示する ページリスト（記事一覧）に列挙されないページを作る (_build.list) セクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight) タクソノミー（タグとカテゴリー） タクソノミーの基本（タグやカテゴリなど） タクソノミー関連のテンプレートを定義する サイト全体のターム一覧（タグ一覧）を表示する 記事ページに付けられたターム一覧（タグ一覧）を表示する 記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする data ディレクトリ 全ページから参照できるデータを用意する（data ディレクトリ） 参照するデータファイルをショートコードのパラメータで切り替える ページャー（ページネーター） ページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする その他 パンくずリストを表示する JSON-LD のパンくずリストを出力する（SEO 対策） 各ページに目次を表示する (.TableOfContents) ホームページの Page オブジェクトを取得する 各種ページにおいて .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧 次のページ、前のページへのリンクを表示する ファイルが存在する場合のみ処理するコードを記述する (fileExists) Markdown (.md) ファイルのパス情報を取得する Markdown (.md) ファイルを VS Code で開くリンクを表示する Markdown ファイルに本文が記述されていない場合だけ特別な出力をする テンプレートの中で絵文字を使用する (emojify) Hugo 応用 図／画像 画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle) 大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing) favicon.ico をサイトのルートに置く (static) mermaid.js で Markdown 中に UML 図を埋め込む 検索／サーチエンジン 全文検索（インクリメンタルサーチ）の機能を付ける Google カスタム検索を設置して記事を検索できるようにする サーチエンジン用に robots.txt や sitemap.xml ファイルを配置する アドレス／リンク サイト構造を変えてもページの URL が変わらないようにする (Permalink) ページ内リンク（アンカー）を張る 「このページを編集 (Edit this page)」のリンクを表示する 新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo) Sass/SCSS スタイルシートを使用する 特定の記事を常にリスト上方に表示する（weight プロパティ） Python で Markdown ファイルのフロントマターの記述が正しいかチェックする Facebook や Twitter の SNS で URL をシェアするときの表示設定 (OGP: Open Graph Protocol) hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする Hugo のテンプレートやショートコードでランダムな文字列を生成する 記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する トラブルシューティング ドラフト指定したセクションが公開されてしまう Markdown ファイルに記述した HTML コードが削除されてしまう Hugo サーバーで記事の変更内容が反映されない (hugo server --ignoreCache)"},{url:"/p/b9jivoi/",title:"Hugo のショートコードで本文とパラメーターの有無で処理を分岐する",date:"2023-12-28T00:00:00Z",body:"Hugo のショートコードで本文とパラメーターの有無で処理を分岐する Hugo のショートコードを呼び出すときに値を渡す方法としては、本文（コンテンツ）として渡す方法と、引数（パラメーター）として渡す方法があります。 次のショートコードは、本文や引数の有無によって処理を分岐する方法を示しています。 layouts/shortcodes/my-shortcode.html \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;本文: {{ with .Inner }}{{ . }}{{ else }}（なし）{{ end }}\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;引数: {{ with .Get 0 }}{{ . }}{{ else }}（なし）{{ end }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; このショートコードは、Markdown ファイル内で次のように呼び出します。 content/page.md（抜粋） \u0026lt;h3\u0026gt;本文だけある場合\u0026lt;/h3\u0026gt; {{\u0026lt; my-shortcode \u0026gt;}}これは本文{{\u0026lt; /my-shortcode \u0026gt;}} \u0026lt;h3\u0026gt;引数だけある場合\u0026lt;/h3\u0026gt; {{\u0026lt; my-shortcode \u0026#34;これは引数\u0026#34; /\u0026gt;}} \u0026lt;h3\u0026gt;本文と引数の両方がある場合\u0026lt;/h3\u0026gt; {{\u0026lt; my-shortcode \u0026#34;これは引数\u0026#34; \u0026gt;}}これは本文{{\u0026lt; /my-shortcode \u0026gt;}} 出力結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;本文: これは本文\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;引数: （なし）\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h3\u0026gt;引数だけある場合\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;本文: （なし）\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;引数: これは引数\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h3\u0026gt;本文と引数の両方がある場合\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;本文: これは本文\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;引数: これは引数\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ☝️ self-closed エラー ショートコードの呼び出し時に引数だけを指定する場合は、self-closed というちょっと特殊な書き方をしなければいけないようです（末尾をスラッシュで終わる）。 これは、ショートコードの中で .Inner（本文）を参照している場合の仕様のようです。 末尾のスラッシュを省略すると、実際には .Inner の値を出力していないのにも関わらず、次のようなエラーが発生してしまいます。 shortcode \u0026#34;my-shortcode\u0026#34; must be closed or self-closed この仕様はちょっとわかりにくいので、Hugo 側で変更して欲しいなぁ。。。"},{url:"/p/nzi6xbm/",title:"Rust で MongoDB を扱う (mongodb)",date:"2023-12-23T00:00:00Z",body:"Rust で MongoDB を扱う (mongodb) Rust プログラムから MongoDB にアクセスするには、mongodb クレート を使用します。 各種クレートのインストール cargo add コマンドを使って、次のようなクレートをインストールします。 mongodb \u0026hellip; MongoDB を扱うためのクレート serde \u0026hellip; MongoDB 内の BSON データと Rust の struct を相互変換（シリアライズ／デシリアライズ）するためのクレート tokio \u0026hellip; Rust の async 処理用のランタイム実装を提供するクレート futures \u0026hellip; TryStream と呼ばれる非同期ストリームを操作するための拡張メソッドを使うため（サンプルコード内の cursor.try_next() の部分に必要） # （必要に応じて）プロジェクトの作成 $ cargo new myapp $ cd myapp # クレートのインストール $ cargo add mongodb serde tokio futures Cargo.toml に次のような感じで依存関係が追加されていれば準備 OK です。 Cargo.toml [dependencies] futures = \u0026#34;0.3.29\u0026#34; mongodb = \u0026#34;2.8.0\u0026#34; serde = \u0026#34;1.0.193\u0026#34; tokio = \u0026#34;1.35.1\u0026#34; MongoDB サーバーの準備 接続先の MongoDB サーバーはローカルで起動しておくか、MongoDB Atlas などのクラウドサービスで用意しておいてください。 参考: MongoDB 関連記事｜まくろぐ 以下の説明では、localhost:27017 で MongoDB サーバーが稼働していることを想定しています。 サンプルコード データベースの一覧を取得する 下記のコードは、MongoDB サーバーに接続して、データベースの一覧を列挙する例です。 databases.rs use mongodb::Client; const URI: \u0026amp;str = \u0026#34;mongodb://127.0.0.1:27017\u0026#34;; #[tokio::main] async fn main() -\u0026gt; mongodb::error::Result\u0026lt;()\u0026gt; { // MongoDB サーバーに接続して Client インスタンスを取得 let client = Client::with_uri_str(URI).await?; // データベースを列挙 for db_name in client.list_database_names(None, None).await? { println!(\u0026#34;{}\u0026#34;, db_name); } } 実行結果 $ cargo run -q admin config local コレクション内のドキュメント操作 次の例では、mydb データベース内の books コレクションにドキュメントをいくつか追加し、それらを取り出しています。 ここでは、各ドキュメントを表現する struct として Book 型を定義しています。 books.rs use futures::TryStreamExt; use mongodb::{bson::oid::ObjectId, Client}; use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { #[serde(rename = \u0026#34;_id\u0026#34;, skip_serializing)] id: Option\u0026lt;ObjectId\u0026gt;, title: String, price: i32, } const URI: \u0026amp;str = \u0026#34;mongodb://127.0.0.1:27017\u0026#34;; #[tokio::main] async fn main() -\u0026gt; mongodb::error::Result\u0026lt;()\u0026gt; { // MongoDB サーバーに接続して Client インスタンスを取得 let client = Client::with_uri_str(URI).await?; // books コレクションのハンドルを取得する let books_coll = client.database(\u0026#34;mydb\u0026#34;).collection::\u0026lt;Book\u0026gt;(\u0026#34;books\u0026#34;); // コレクション内のドキュメントをすべて削除する books_coll.drop(None).await?; // コレクションにドキュメントを追加する let books = vec![ Book { id: None, title: \u0026#34;Title-1\u0026#34;.to_string(), price: 1000, }, Book { id: None, title: \u0026#34;Title-2\u0026#34;.to_string(), price: 2000, }, Book { id: None, title: \u0026#34;Title-3\u0026#34;.to_string(), price: 3000, }, ]; books_coll.insert_many(books, None).await?; // コレクション内のすべてのドキュメントを取得する let mut cursor = books_coll.find(None, None).await?; while let Some(book) = cursor.try_next().await? { println!(\u0026#34;{:?}, {}, {}\u0026#34;, book.id, book.title, book.price); } Ok(()) } 実行結果 $ cargo run -q Some(ObjectId(\u0026#34;658721862f9a5832444f7833\u0026#34;)), Title-1, 1000 Some(ObjectId(\u0026#34;658721862f9a5832444f7834\u0026#34;)), Title-2, 2000 Some(ObjectId(\u0026#34;658721862f9a5832444f7835\u0026#34;)), Title-3, 3000 関連リンク Deno で MongoDB を扱う Golang で MongoDB を扱う (go.mongodb.org/mongo-driver)"},{url:"/p/x4z298a/",title:"python コマンドのバージョンを切り替える (pyenv, py)",date:"2023-12-19T00:00:00Z",body:"python コマンドのバージョンを切り替える (pyenv, py) 互換性の問題のために、少し古いバージョンの python コマンドを使わなければいけないことがあります（機械学習系のライブラリなど）。 そのようなケースでは、次のようなツールを使って python コマンド自体のバージョンを切り替えると便利です。 pyenv \u0026hellip; Linux または macOS 用の python バージョン切り替えコマンドです。Windows 用の移植もありますが、シェルスクリプトで作られているので、本質的には Linux または macOS 用です。 Python ランチャー (py) \u0026hellip; Windows 用の Python インストーラーを使うと、Python ランチャー（py コマンド）をインストールすることができます。 pyenv コマンド インストール macOS の場合 (Homebrew) $ brew update $ brew install pyenv Linux の場合 $ curl https://pyenv.run | bash チートシート コマンド 説明 pyenv versions インストール済みの Python バージョンの一覧を表示します。現在選択しているバージョンには * 印が付きます。 pyenv version 現在選択している Python のバージョンを表示します。 pyenv install --list インストール可能な Python のバージョンを表示します。 pyenv install 3.10 指定したバージョンの Python をインストールします。マイナーバージョンやパッチバージョンは省略できます。 pyenv uninstall 3.10.13 指定したバージョンの Python をアンインストールします。バージョンは省略できません。 pyenv global 3.10 Python のバージョンを切り替えます（グローバル設定）。 pyenv local 3.10 Python のバージョンを切り替えます（カレントディレクトリ以下）。 pyenv shell 3.10 Python のバージョンを切り替えます（現在のシェルのみ）。 使用例 まず、pyenv versions コマンドで、現在インストールされている Python のバージョン一覧を調べます。 $ pyenv versions system * 3.12.0 (set by /Users/maku/.pyenv/version) system と 3.12.0 がインストールされていることが分かります。 system の方は、pyenv の外の世界でインストールされた python コマンドを示しており、pyenv 管轄の python コマンドを使う場合は使用しません。 3.12.0 の横には * 印が付いているので、この状態で python コマンドを実行すると、バージョン 3.12.0 の Python が起動します。 $ python --version Python 3.12.0 ここで、少し古い Python 3.10.X を使いたくなった場合は、次のように pyenv install コマンドでインストールします。 $ pyenv install 3.10 インストールが終わったら、もう一度 pyenv versions コマンドを実行して、正しくインストールされていることを確認します。 $ pyenv versions system 3.10.13 * 3.12.0 (set by /Users/maku/.pyenv/version) 次に、pyenv global コマンドを使って、使用する Python バージョンを切り替えます。 $ pyenv global 3.10 $ pyenv versions system * 3.10.13 (set by /Users/maku/.pyenv/version) 3.12.0 $ python --version Python 3.10.13 無事 python コマンドの実体が、Python 3.10 に切り替わっていることを確認できました。 上記の例では、pyenv global コマンドを使って python コマンドのバージョンを切り替えましたが、他にも pyenv local や pyenv shell で切り替えることができます。 切り替え方法によって、次のように有効期間が異なります。 pyenv global \u0026hellip; グローバルに python コマンドのバージョンを切り替えます。別のシェルを開いた場合にも有効です。バージョン情報は、~/.pyenv/version に保存されます。 pyenv local \u0026hellip; カレントディレクトリ以下で使用する python コマンドのバージョンを切り替えます。バージョン情報は、カレントディレクトリの .python-version ファイルに保存されます。 pyenv shell \u0026hellip; カレントシェルでのみ python コマンドのバージョンを切り替えます。 Python ランチャー（py コマンド） Windows の Python 環境では Python ランチャー (py) を使って python コマンドのバージョンを切り替えることができます。 チートシート コマンド 説明 py --list インストール済みの Python バージョンの一覧を表示します。現在選択しているバージョンには * 印が付きます。 py --list-paths 各バージョンの python.exe のフルパスを表示します。 py -3.8 Python 3.8 を起動します。 py -3.8 -m pip install pandas Python 3.8 の環境にパッケージをインストールします。 py -3.8 -m venv venv Python 3.8 の環境で venv 仮想環境を作成します。"},{url:"/js/",title:"JavaScript",date:"2023-12-01T00:00:00Z",body:"JavaScript はじめに JavaScript のコーディングスタイル 最初から Strict モードを有効にすべし (ECMAScript 5) JavaScript の 6 つの型 静的解析ツール （旧）JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint) （旧）JSLint で JavaScript コードの静的解析を行う （旧）JSHint で JavaScript コードの静的解析を行う ESLint で JavaScript コードの静的解析を行う（オススメ） デバッグ デバッグ出力用の print 関数の統一について ある処理を 1 秒間に何回実行できるかプロファイリングする 数値／文字列 (Number/String) 数値 実数の小数点数以下を丸めて整数に変換する (floor, ceil, round) 数値の小数点以下 N 桁までに丸めて表示する (toFixed) 文字列 new String は避ける テンプレート文字列の機能で文字列リテラル中の変数を展開する (template literal) (ECMAScript 2015) == と === による文字列比較の違い 文字列を大小比較すると何が起こるか 文字列と文字列、数値を結合する 文字列と数値を変換する 文字列の小文字と大文字を変換する (toLowerCase, toUpperCase) 検索 文字列の中から文字列を検索する (String#search, RegExp#test) 文字列内に NG ワード（禁止語句）が含まれていないか調べる (RegExp#test) 分割／抽出 文字列をデリミタで分割する／1文字ずつに分割する (String#split) 文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec) 置換 文字列を置換する (String#replace, String#replaceAll) 編集 文字列の先頭と末尾の空白を削除する (String#trim) (ECMAScript 2015) 文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd) 文字列の長さを取得する (length) 部分文字列を取得する (substring, slice) 文字列内の1文字を取得する／1文字ずつループ処理する (charAt) 全角文字と半角文字を含んだ文字列を正規化して表記ゆれを吸収する (normalize) (ECMAScript2015) 文字列内のひらがなとカタカナを変換する 旧記事 テンプレートを使ってテキストを生成する (Underscore.js) 配列／連想配列 (Array) 配列の基本 配列に要素を追加・挿入する (push, unshift, splice) 配列と配列を結合する (\u0026hellip;スプレッド演算子, concat) 配列から部分配列を取得する (slice, splice) 配列をコピーする 配列をループで処理する (for, forEach, for-of) 配列をソートする (sort, reverse) 配列にある要素が存在するか調べる (includes, indexOf) 配列の長さを切り詰める (length, splice) 連想配列にキーが存在するか調べる (in) 連想配列の要素（キー）を削除する (delete) 連想配列の要素数を調べる 配列要素をランダムで取り出す 配列の各要素に対して同じ処理を行う (map) 配列の分割代入で複数の値を同時に代入する (Array destructuring) 日時／タイマー (Date/Timer) 日時 Date オブジェクト（日時情報）の作成方法いろいろ Date オブジェクトをいろいろな文字列表現に変換する 他の国のローカルタイム（現地時刻）を文字列形式で取得する Date オブジェクトの日付を加算／減算する Date オブジェクト同士の差分を取る タイマー／パフォーマンス タイマーで任意の関数を呼び出す (setTimeout, setInterval) 精度の高いタイムスタンプを取得する (performance.now()) 処理速度を計測する (performance) 構文 関数 関数を定義する デフォルト引数を扱う関数を定義する (Default parameters) (ECMAScript 2015) 可変長引数を扱う関数を定義する (arguments) 関数の仮引数の数を取得する 渡されたパラメータが関数かどうか調べる 関数オブジェクトから関数名を取得する アロー関数で関数を定義する (ECMAScript 2015) 変数／定数／名前空間 変数定義には var ではなく let や const を使用する (ECMAScript 2015) JavaScript で定数を定義する (const) JavaScript ではグローバル変数も関数も全てプロパティ 関数内からしか参照できないプライベート関数を定義する 分割代入 (Destructuring assignment) 分割代入によりオブジェクトの特定のプロパティだけを単独変数に取得する (Object destructuring) (ECMAScript 2015) オブジェクト オブジェクトの基本 オブジェクトのプロパティを列挙する (for-in) 2つのオブジェクトのプロパティをマージする（\u0026hellip;スプレッド演算子、Object.assign） Property Shorthand の記法で複数の変数をひとつのオブジェクトにまとめる (ECMAScript 2015) クラス クラスを定義する (class) (ECMAScript 2015) クラス定数／クラス変数／クラスメソッドを定義する あるオブジェクトが特定のクラスのインスタンスであるかを調べる (instanceof, constructor) クラスに toString() メソッドを実装する JavaScript 独自拡張 式クロージャ (Expression Closure) その他 JavaScript において偽 (false) と評価される値 入れ子になったループを一度に抜ける（多重ループからの break） ある変数が初期化済みかどうか確認する 外部スクリプトはなぜ (function(){})(); のような書き方をするのか？ 非同期処理 Promise オブジェクトで連続するコールバック処理を簡潔に記述する (ECMAScript 2015) Promise な非同期処理を async/await でさらに読みやすくする (ECMAScript 2017) HTML/DOM 操作 要素 HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索 HTML の DOM 要素を取得する (2) 親要素、子要素、兄弟要素を検索 HTML の DOM ツリーに要素を追加する HTML 要素に独自の data 属性（カスタム属性）を設定する HTML 要素の class 属性の値を追加・削除・トグルする ページ内のヘッダ要素 (h2/h3/h4) から自動的にメニュー (TOC) を生成する HTML 要素のサイズを取得する HTML 要素の位置を取得する ウィンドウ Web ブラウザのページ表示位置を調べる（スクロール位置を取得する） 画像／イメージ 複数の画像ファイルが読み込まれるのを待機する 音声/オーディオ オーディオファイル (mp3) を再生する I/O（入出力） キーボードからの入力を取得する テキストボックスでキー入力したときのイベントをハンドルする (onkeyup) ボタンを押したときのイベントをハンドルする (onclick) プルダウンリストから項目を選択したときのイベントをハンドルする (onchange) jQuery jQuery 本体のロード方法いろいろ jQuery 関連用語 jQuery で Hello World jQuery で要素を追加、移動、コピーする (append, prepend) jQuery で動的にリスト項目 (li) を追加する jQuery でテーブルに動的にレコード (tr) を追加する jQuery で要素を削除する (remove) jQuery の ajax/get/post メソッドが動作しない jQuery でフォームに入力した値を取得する HTML5 Canvas HTML5 Canvas のサイズ指定について HTML5 Canvas でテキストを描画する HTML5 Canvas に矩形や円を描画する HTML5 Canvas に画像ファイルを描画する HTML5 Canvas 内のマウスドラッグで、描画オブジェクト全体を移動させる HTML5 Canvas のまわりにテレビの枠画像を表示してそれっぽく見せる ウィンドウサイズに応じて HTML5 Canvas のサイズを変更する HTML5 Canvas の描画領域全体をクリアする IE 8 以下でも canvas タグを使用できるようにする Web サイト URL エンコード／デコードを行う (encodeURI, encodeURIComponent) URL 内のハッシュフラグメントの値を扱う (hashchange, location.hash) URL からクエリ文字列を取り出す (window.location.search, URLSearchParams) 実行環境 CORS - Cross-Origin Resource Sharing とは？ Chrome で Ajax (XMLHttpRequest) によるクロスドメイン通信の制約をなくす 使用している Web ブラウザが IE (Internet Explorer) かどうか判別する Node.js ⇒ まくまく Node.js ノート"},{url:"/p/buatano/",title:"JavaScript で文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd)",date:"2023-12-01T00:00:00Z",body:"JavaScript で文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd) padStart と padEnd の基本 JavaScript の String#padStart() および String#padEnd() メソッドを使うと、指定した文字数になるまで文字列を拡張してくれます。 どのような文字で埋め合わせるかは、第 2 引数で指定します。 左側にパディング const s = \u0026#34;ABC\u0026#34;; console.log(s.padStart(2, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABC\u0026#34; console.log(s.padStart(3, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABC\u0026#34; console.log(s.padStart(4, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;xABC\u0026#34; console.log(s.padStart(5, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;xxABC\u0026#34; console.log(s.padStart(6, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;xxxABC\u0026#34; 右側にパディング const s = \u0026#34;ABC\u0026#34;; console.log(s.padEnd(2, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABC\u0026#34; console.log(s.padEnd(3, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABC\u0026#34; console.log(s.padEnd(4, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABCx\u0026#34; console.log(s.padEnd(5, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABCxx\u0026#34; console.log(s.padEnd(6, \u0026#34;x\u0026#34;)); //=\u0026gt; \u0026#34;ABCxxx\u0026#34; 第 2 引数に 2 文字以上の文字列を指定すると、各文字が順番に使われます。 const s = \u0026#34;ABC\u0026#34;; console.log(s.padStart(10, \u0026#34;xyz\u0026#34;)); //=\u0026gt; \u0026#34;xyzxyzxyzxABC\u0026#34; 使用例 byte 数値を二進数文字列にする（8 桁になるまで 0 パディング） function toBinaryString(byteNum) { return byteNum.toString(2).padStart(8, \u0026#34;0\u0026#34;); } console.log(toBinaryString(0)); //=\u0026gt; \u0026#34;00000000\u0026#34; console.log(toBinaryString(3)); //=\u0026gt; \u0026#34;00000011\u0026#34; console.log(toBinaryString(255)); //=\u0026gt; \u0026#34;11111111\u0026#34; コンソール出力用の右寄せ（スペースでパディング） function alignRight(s) { return s.padStart(5); // デフォルトでスペースでパディングされます } console.log(alignRight(\u0026#34;AAA\u0026#34;)); //=\u0026gt; \u0026#34; AAA\u0026#34; console.log(alignRight(\u0026#34;BBBB\u0026#34;)); //=\u0026gt; \u0026#34; BBBB\u0026#34; console.log(alignRight(\u0026#34;CCCCC\u0026#34;)); //=\u0026gt; \u0026#34;CCCCC\u0026#34; console.log(alignRight(\u0026#34;DDDDDD\u0026#34;)); //=\u0026gt; \u0026#34;DDDDDD\u0026#34; 末尾の 4 文字以外を隠す（カード番号や電話番号などに） function hideAllButTheEnd(s) { const last4Chars = s.slice(-4); const maskedStr = last4Chars.padStart(s.length, \u0026#34;*\u0026#34;); return maskedStr; } const cardNumber = \u0026#34;2034399002125581\u0026#34;; console.log(hideAllButTheEnd(cardNumber)); //=\u0026gt; \u0026#34;************5581\u0026#34; ちなみに上記のコードは、MDN の padStart() のドキュメント で紹介されているものです。"},{url:"/p/2tyvjmh/",title:"Python の dictionary（辞書）のチートシート",date:"2023-11-28T00:00:00Z",body:"Python の dictionary（辞書）のチートシート コード 説明 d = {} d = dict() dictionary の作成 d = {\u0026quot;key1\u0026quot;: 100} d = dict(key1=100) dictionary の作成と初期化 d = dict(zip([\u0026quot;one\u0026quot;, \u0026quot;two\u0026quot;, \u0026quot;three\u0026quot;], [1, 2, 3])) キーのリストと値のリストから dictionary を作成 len(d) 要素数 d[\u0026quot;key\u0026quot;] = 100 要素を追加・上書き val = d[\u0026quot;key\u0026quot;] 要素を取得（キーが存在しないときは KeyError） val = d.get(\u0026quot;key\u0026quot;, default=0) 要素を取得（キーが存在しないときはデフォルト値を返す） val = d.setdefault(\u0026quot;key\u0026quot;, 0) 要素を取得（キーが存在しないときはデフォルト値をセットして返す） keys = d.keys() キーのリストを取得 vals = d.values() 値のリストを取得 items = d.items() (キー, 値) のリストを取得 if \u0026quot;key\u0026quot; in d: キーが存在するか調べる del d[\u0026quot;key\u0026quot;] 要素を削除する（キーが存在しないときは KeyError） for key in d: キーでループ for key, val in d.items(): キーと値でループ for i, key in enumerate(d): 連番とキーでループ for key in sorted(d.keys()): for key in sorted(d.keys(), reverse=True): キーでソートしてループ（昇順/降順） for key in sorted(d, key=lambda x:d[x]): for key in sorted(d, reverse=True, key=lambda x:d[x]): 値でソートしてループ（昇順/降順） d1.update(d2) d1 に d2 をマージ d3 = {**d1, **d2} d1 と d2 をマージした d3 を作成"},{url:"/p/succ4mb/",title:"Python の requests パッケージのチートシート",date:"2023-11-28T00:00:00Z",body:'Python の requests パッケージのチートシート インストールとインポート requests パッケージのインストール $ pip install requests requests パッケージのインポート import requests リクエスト コード説明 res = requests.get(URL) GET リクエスト res = requests.get(URL, headers={"key": "val"}) ヘッダーの設定 res = requests.get(URL, params={"key": "val"}) クエリパラメータの設定 res = requests.get(URL, cookies={"key": "val"}) クッキーの設定 res = requests.get(URL, auth=("user", "pass")) Basic 認証 res = requests.get(URL, auth=requests.auth.HTTPDigestAuth("user", "pass")) Digest 認証 res = requests.post(URL, data={"key": "val"}) POST リクエストでペイロード送信（key=val というテキスト） data = {"key": "value"} res = requests.post( "https://example.com", headers={"Content-Type": "application/json"}, data=json.dumps(data) ) POST リクエストでペイロード送信（JSON 形式のテキスト） session = requests.Session() res = session.post(URL1, data=data) res = session.get(URL2) セッションを考慮したリクエスト（URL1 のレスポンスに Set-Cookie ヘッダーが含まれていたら、次の URL2 へのリクエストに自動で Cookie ヘッダーが付く） テスト用には下記のアドレスを使うと便利です。どのようなデータが送信されたかを、JSON 形式のレスポンスとして返してくれます。 GET メソッド用: https://httpbin.org/get POST メソッド用: https://httpbin.org/post レスポンス コード 説明 res.status_code ステータスコード（例: 200） res.ok ステータスコードが 400 未満であれば True（クライアントエラー 4xx もサーバーエラー 5xx も発生していない） res.headers レスポンスヘッダー（dictionary 形式） res.content コンテンツのバイトデータ (bytes) res.text コンテンツのテキストデータ (str) res.json() コンテンツのテキストを JSON フォーマットとみなして Python オブジェクトに変換 with open(\u0026quot;file.txt\u0026quot;, \u0026quot;wb\u0026quot;) as f: f.write(res.content) コンテンツをファイルに保存（ダウンロード） 参考 requests パッケージによる HTTP 通信の例'},{url:"/p/zpdyxso/",title:"Python の dictionary（辞書）の基本",date:"2023-11-23T00:00:00Z",body:"Python の dictionary（辞書）の基本 Python の dictionary（辞書）は、キーと値のペアで構成されたオブジェクトです。 他の言語では、マップやハッシュと呼ばれていたりします。 dictionary オブジェクトを生成する ({}, dict) dictionary は {} あるいは、dict() を使って生成できます。 Python の dictionary は、JavaScript のオブジェクトにそっくりです。 空の dictionary を作成する d = {} # 空の辞書を作成する d = dict() # 別の方法 print(type(d)) #=\u0026gt; \u0026lt;class: \u0026#39;dict\u0026#39;\u0026gt; print(len(d)) #=\u0026gt; 0 初期値を持つ dictionary を作成する dictionary オブジェクトを生成するときに、キーと値のペアを列挙することで、初期値を設定できます。 {} を使った初期化用の構文を使うか、dict() 関数にキーワード引数の形で初期値を指定します。 d = {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2} # 初期値を持つ辞書を作成する d = dict(one=1, two=2) # 別の方法 print(d[\u0026#39;one\u0026#39;]) #=\u0026gt; 1 print(d[\u0026#39;two\u0026#39;]) #=\u0026gt; 2 print(d[\u0026#39;three\u0026#39;]) #=\u0026gt; KeyError dictionary の要素を参照・変更する ([], get) Python で dictionary オブジェクトの要素を参照するには下記のように [] でキーを指定します。 キーが存在しない場合は、KeyError が発生します。 val = d[\u0026#39;key\u0026#39;] # 要素を参照する d[\u0026#39;key\u0026#39;] = val # 要素を追加する キーが存在しない場合に、デフォルト値を返したい場合は get() メソッドを使用します。 val = d.get(\u0026#39;key\u0026#39;, default=None) 応用: dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault) dictionary の要素数を取得する (len) Python で dictionary オブジェクトの要素数を調べるには、組み込み関数の len() を使用します。 len() 関数は dictionary のメソッドではないことに注意してください。 \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; len(d) 3 ちなみに、list や tuple オブジェクトの要素数や、文字列 (str) の文字数を調べる場合も、同様に組み込み関数の len() を使用します。 dictionary に指定したキーが存在するか調べる (in) Python の dictionary オブジェクトが、指定したキーを持っているかを判別するには、in キーワードを使用します。 if \u0026#39;key1\u0026#39; in d: print(\u0026#39;key1 が存在します\u0026#39;) ☝️ has_key メソッドはなくなった Python 2 の頃は、下記のように has_key() メソッドを使用することができましたが、Python 3 以降は in キーワードしか使用できなくなりました。 if d.has_key(\u0026#39;key1\u0026#39;): print(\u0026#39;key1 が存在します\u0026#39;) dictionary の要素を削除する (del) Python の dictionary から指定したキーの要素を削除するには、del キーワードを使用します。 del d[\u0026#39;key\u0026#39;] 次のサンプルでは、実際に要素が削除されているかを in で確認しています。 \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;key1\u0026#39;: 100, \u0026#39;key2\u0026#39;: 200} \u0026gt;\u0026gt;\u0026gt; \u0026#39;key1\u0026#39; in d True \u0026gt;\u0026gt;\u0026gt; del d[\u0026#39;key1\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;key1\u0026#39; in d False 削除済みの要素を参照しようとするとエラー (KeyError) になります。 \u0026gt;\u0026gt;\u0026gt; d[\u0026#39;key1\u0026#39;] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; KeyError: \u0026#39;key1\u0026#39; dictionary をループ処理する 単純なループ dictionary オブジェクトを for-in ステートメントに渡すと、ループ処理でキーを 1 つずつ取り出すことができます。 \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; for key in d: ... print(key, d[key]) ... two 2 three 3 one 1 キーと値のペアを取り出しながらループ (items) dictionary オブジェクトをループ処理するときに、キーと値を同時に取り出しながら処理したい時は items() メソッドを使用します。 \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; for key, val in d.items(): ... print(key, val) ... two 2 three 3 one 1 ちなみに、Python 2 の頃は iteritems() メソッドを使用できましたが、Python 3 からは items() メソッドのみ使用可能です。 連番を振りながらループ (enumerate) enumerate と組み合わせることで、0 から始まる連番を振りながらループ処理することができます（list オブジェクトも同様のループ処理が可能です）。 \u0026gt;\u0026gt;\u0026gt; for i, key in enumerate(d): ... print(\u0026#39;[{}] {}: {}\u0026#39;.format(i, key, d[key])) ... [0] one: 1 [1] two: 2 [2] three: 3 キーでソートしてループ処理する dictionary の要素をソートして出力する"},{url:"/git/",title:"Git",date:"2023-11-15T00:00:00Z",body:"Git GitHub Pull Request のコードレビューワーを自動でアサインする GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages) GitHub Pages で独自の 404 ページを用意する GitHub の Organization を構成したときのチームの権限について理解する GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する GitHub の Markdown でメールアドレスへのリンクを記述する （旧）GitHub のプランと GitHub ライクなツールの比較など GitHub の REST API を使用する GitHub の REST API で Issue 情報を取得する方法いろいろ GitHub の REST API を Python から使用する GitHub で管理している社内リポジトリをトピックで分類する (topics) GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink) GitHub Actions GitHub Actions で GitHub wiki ページを自動更新する GitHub Actions のワークフローをローカルで実行する (act) Git の基本 Git の作業ツリーを作成する (git init, git clone) Git でファイルの変更をステージする（コミットの印をつける） Git で変更をローカルリポジトリにコミットする コミット対象になっているファイルを確認する (git status) Git コマンドの長いオプション名を省略して入力する Git の設定 git config で設定すべき一般的な設定項目まとめ Git 設定のスコープ (local/global/system) を理解する Git の設定値がどのファイルで設定されているか調べる (config \u0026ndash;show-origin) git config による設定を削除する (config \u0026ndash;unset) コミット時に使用するユーザ名とメールアドレスを設定する (user.name, user.email) コミット、チェックアウト時に改行コードを自動変換する (core.autocrlf, core.safecrlf) コミット時にコメント記述に使用するエディタを設定する (core.editor) Git コマンドの出力をカラフルにする (color.ui) Git コマンドのエイリアスを作成する (alias.xxx) Git コマンドで使用するプロキシを設定する (http.proxy) Windows の git diff で改行コードが \u0026ldquo;^M\u0026rdquo; で表示される問題を解決する (core.whitespace) git diff や git status での日本語の文字化けを防ぐ (core.page, core.quotepath) Windowsでパーミッションの違いで diff が表示されてしまうのを防ぐ (core.filemode) .gitignore ファイルで Git にバージョン管理させないファイルを指定する bash のプロンプトにカレントブランチ名を表示する (PS1) msysGit で \u0026ldquo;terminal is not fully functional\u0026rdquo; と怒られる場合の対策 git プロトコルではなく強制的に https プロトコルで git clone するようにする (url.xxx) Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf) コミット／履歴の書き換え Git やり直し: 直前のコミットのコメントを修正する Git やり直し: 直前のコミットを取り消す Git やり直し: main ブランチに入れてしまったコミットを別のブランチに移す Git やり直し: 最近のコミットを歴史から抹消する Git やり直し: コミット履歴を書き換えてディレクトリ階層を変更する 変更の一部だけをコミットする ログ (git log) コミットログ表示の基本 コミットログの書き方 コミットログを絞り込んで表示する コミットログにファイル名や変更行数を表示する コミットログの出力形式をカスタマイズする (git log \u0026ndash;pretty, \u0026ndash;date) コミットログにある文字列が含まれているコミットを検索する (git log \u0026ndash;grep) 変更内容にある文字列が含まれているコミットを検索する (git log -G/-S) 指定したディレクトリ以下の変更に関連するコミットログのみ表示する ブランチ間の差分を調べる リモートブランチとローカルブランチの差分を調べる コミットログを標準出力へ出力する 統計情報 ユーザーごとのコミット統計を出力する (git shortlog) あるバージョン間の変更行数（追加＆削除）を集計する (git diff \u0026ndash;stat, git log \u0026ndash;numstat) grep 検索 (git grep) Git リポジトリ内のコードを grep 検索する (git grep) ブランチ (git branch) ブランチを作成する (git branch) ブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) ブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) ブランチを削除する (git branch -d/D) ブランチ名を変更する (git branch -m) ブランチやタグの作者を調べる (git for-each-ref) 他の人が作成したブランチ上で作業する リモートブランチを削除する (git push origin :xxx, git fetch --prune) 他のブランチの最新ファイルを現在のブランチにコピーする (git checkout) detached HEAD 状態へのチェックアウトとは マージ (git merge, git cherry-pick) ブランチでの変更をマージする（直接マージ、スカッシュマージ、チェリーピック） マージ時のコンフリクトを解決する 別ブランチへの複数のコミットを１つのコミットとしてマージする (squash merge) マージのためのコミットを revert する（取り消す） マージ作業に失敗したときにやり直す マージで競合解決が必要なファイルを調べる マージベースとなったコミットを見つける（fast-forward の関係になっているか調べる） 別の Git リポジトリの内容を強引にマージする 差分・パッチファイル (git diff / patch) git diff でファイルの差分を調べる git diff で改行コードの違いを無視する git diff で単語単位で差分を表示する git diff の出力で相対パスを使うようにする git diff で package-lock.json の差分が表示されるのを防ぐ Git でパッチファイルを作成する ファイル操作 git clean で追跡されていないファイルを削除する ファイルを削除せずに Git によるバージョン管理の対象から外す (git rm \u0026ndash;cached) コミットからファイルをチェックアウトする（ファイルを元に戻す） インデックスからファイルをチェックアウトする（ファイルを元に戻す） 特定のバージョンのファイルの内容を確認する (cat-file) タグ (git tag) コミットに対してタグをつけて中央リポジトリにプッシュする (git tag) タグの名前を変更する リポジトリ／サーバー／バックアップ 共有リポジトリを作成する git-daemon による読み取り専用リポジトリの公開 Git リポジトリを移行する リポジトリ内のディレクトリを別リポジトリに切り出す ローカルディレクトリをリモートリポジトリとして使用する リモートリポジトリに略称を付ける 共有リポジトリからの fetch と push ソースコードのアーカイブを作成する hook スクリプト Git の update フックの基本 特定のユーザのみ git push できるように制限する その他 Git 用語集 Git で N 個前のコミットを表現する Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当） git pull の引数省略の仕組み 二要素認証を設定した後に git コマンドが Authentication failed になる場合 Git サブモジュールで別リポジトリの内容を組み込む (git submodule) GitLab（GitHub クローン） GitLab をインストールする GitLab 関連サービスを起動／停止する GitLab のデータをバックアップ／リストアする 起動中の GitLab 関連サービスを調べる GitLab からの通知メールを設定する GitLab リポジトリの Clone URL として表示されるホスト名を変更する GitLab 用 nginx サーバの設定ファイルの場所 GitLab が使用する Unicorn 用のポート番号を変更する GitLab サーバのアクセスログを調べる オワコン情報 (Subversion とか CVS とか） git-svn を使って Git と Subversion を連携する CVS のファイルのパーミッションの扱いについて .svn ディレクトリをまとめて削除する"},{url:"/p/2c29gvn/",title:"Git リポジトリ内のコードを grep 検索する (git grep)",date:"2023-11-15T00:00:00Z",body:"Git リポジトリ内のコードを grep 検索する (git grep) git grep とは Git に組み込まれている git grep コマンドを使うと、Git リポジトリ内のコードを対象にした grep 検索を行うことができます。 Linux の grep コマンドを使うのと比べて、次のような利点があります。 OS に依存しない grep コマンドとして使用できる .gitignore で指定されているファイルを無視して検索してくれる ある時点のコードを対象に検索できる（コミットハッシュの指定） ある文字列を含む関数を検索できる（-p オプション） git grep の基本 カレントディレクトリ以下を検索する $ git grep \u0026#34;検索文字列\u0026#34; カレントディレクトリ以下のファイルを対象として git grep するには、上記のように単純に検索文字列を指定するだけで OK です。 もちろん、Git 管理されているディレクトリ以下で実行する必要があります。 検索対象のディレクトリやファイルを指定するには、次のように -- で区切ってからディレクトリ名やファイル名のパターンを指定します。 src ディレクトリ以下を検索する $ git grep \u0026#34;検索文字列\u0026#34; -- src src ディレクトリ以下の .py ファイルを検索する $ git grep \u0026#34;検索文字列\u0026#34; -- \u0026#34;src/**.py\u0026#34; ワイルドカードを指定してファイル名のパターンを指定するときは、\u0026quot;src/**.py\u0026quot; のようにダブルクォートで囲む必要があることに注意してください。 これは、git grep にパラメーターが渡される前にシェルがファイルグロブとして展開してしまうのを防ぐためです。 特定のディレクトリやファイルを検索対象外にしたいときは、:^ というプレフィックスを付けます。 .github ディレクトリや package.json を検索対象外にする $ git grep react -- :^.github \u0026#34;:^package*.json\u0026#34; 拡張正規表現を使って検索したいときは、-E オプションを指定します。 正規表現を使って検索する $ git grep -E \u0026#34;https?://\u0026#34; 特定のコミットハッシュやブランチ、タグのコードを検索対象としたいときは、検索文字列の後ろにコミットハッシュなどを指定します。 コミットハッシュを指定して検索する $ git grep \u0026#34;検索文字列\u0026#34; ba17d26 複数の検索パターンを AND や OR で組み合わせたいときは、-e 検索文字列（または -E 拡張正規表現）というパターン指定を、--and や --or で繋げて指定します。 AND 検索（game と book を両方含む行を検索） $ git grep -e \u0026#34;game\u0026#34; --and -e \u0026#34;book\u0026#34; OR 検索（game または book を含む行を検索） $ git grep -e \u0026#34;game\u0026#34; --or -e \u0026#34;book\u0026#34; git grep の応用的な使い方 git grep のその他のオプションは、git grep -h で確認することができます。 例えば、次のようなオプションが用意されています。 -i, --ignore-case \u0026hellip; 大文字・小文字を区別しない 例: git grep -i \u0026quot;github\u0026quot; -n, --line-number \u0026hellip; 行番号を表示する 例: git grep -n \u0026quot;foobar\u0026quot; -w, --word-regexp \u0026hellip; 単語境界を考慮する 例: git grep -w \u0026quot;Git\u0026quot;__ （Git にはヒットし、GitHub にはヒットしなくなります） -p, --show-function \u0026hellip; ヒットした行を含む関数の先頭行も表示する 例: git grep -p \u0026quot;findUsers\u0026quot; -- \u0026quot;*.ts\u0026quot; （findUsers を呼び出している関数を探すことができます） -h \u0026hellip; 各行の先頭にファイル名を表示しない --recurse-submodules \u0026hellip; サブモジュールのコードも含めて検索する 関数名を検索できる -p, --show-function オプションなどは面白いですね。"},{url:"/p/849syej/",title:"MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists)",date:"2023-11-12T00:00:00Z",body:"MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists) MNIST とは MNIST (Modified National Institute of Standards and Technology) は、手書き数字認識のためのデータセット で、0 から 9 までの単一の数字が手書きされた 28x28 ピクセルのグレースケール画像が含まれています。 各画像は対応する数字のラベルを持っており、機械学習や深層学習のアルゴリズムのトレーニングやテストに使用されます。 MNIST データの取得 MNIST のデータは、Python の keras.datasets パッケージを使って簡単に取得することができます。 MNIST のデータを取得 import math from keras.datasets import mnist # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # データ形状を確認 print(\u0026#34;X_train: {}\u0026#34;.format(X_train.shape)) print(\u0026#34;y_train: {}\u0026#34;.format(y_train.shape)) print(\u0026#34;X_test: {}\u0026#34;.format(X_test.shape)) print(\u0026#34;y_test: {}\u0026#34;.format(y_test.shape)) 実行結果 X_train: (60000, 28, 28) y_train: (60000,) X_test: (10000, 28, 28) y_test: (10000,) mnist.load_data() が返す MNIST データは、学習用のデータとテスト用のデータに分かれており、それぞれ下記のような内容の NumPy 配列になっています。 X_train 学習用の画像（データ数: 60,000、サイズ: 28x28）。各要素には 0〜255 の輝度値が含まれており、X_train[画像Index][行Index][列Index] で参照できます。 y_train 学習用のラベル（データ数: 60,000）。各要素には 0〜9 の正解ラベルが含まれており、y_train[画像Index] で参照できます。 X_test テスト用の画像（データ数: 10,000、サイズ: 28x28）。各要素には 0〜255 の輝度値が含まれており、X_test[画像Index][行Index][列Index] で参照できます。 y_test テスト用のラベル（データ数: 10,000）。各要素には 0〜9 の正解ラベルが含まれており、y_test[画像Index] で参照できます。 ちなみに、X_train や X_test の X が大文字になっているのは、多次元ベクトルであることを示すための慣例です。 逆に正解ラベルである y_train や y_test は 1 次元データなので y を小文字にしています。 MNIST の手書き画像を表示する matplotlib などを使って、MNIST の画像データを表示することができます。 次の例では、学習用データの先頭の 15 個を表示しています。 図: MNIST に含まれる手書き数字 MNIST の手書き数字を表示する import math from keras.datasets import mnist from matplotlib import pyplot as plt # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # 画像をまとめて表示 def show_images(images, ncols=5): nrows = math.ceil(len(images) / ncols) _, ax = plt.subplots(nrows, ncols, tight_layout=True, figsize=(ncols*1.5, nrows*1.5)) for i, img in enumerate(images): x = i % ncols y = i // ncols axis = ax[x] if nrows == 1 else ax[y][x] axis.set_title(i) axis.imshow(img, cmap=\u0026#34;gray\u0026#34;) plt.show() # 先頭の 15 個の画像を表示 show_images(X_train[:15]) サンプルコード内の show_images 関数は、任意の数の画像を表示できるようにしてあります。 （おまけ）CNN による学習 Keras で CNN モデルを構築して手書き数字画像を学習する実装例です。 from keras.datasets import mnist from keras.models import Sequential from keras.layers import Conv2D, Dense, Dropout, Flatten, MaxPooling2D from keras.optimizers import RMSprop from keras.utils import to_categorical # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # サイズ情報 WIDTH, HEIGHT = X_train[0].shape # 画像の横幅と高さを取得 CHANNELS = 1 # 画像のチャネル数はグレースケールなので 1 INPUT_SHAPE = (HEIGHT, WIDTH, CHANNELS) OUTPUT_SIZE = 10 # CNN への入力用に三次元データに変換し、画素値を 0〜1 に正規化 X_train = X_train.reshape(-1, HEIGHT, WIDTH, CHANNELS) #=\u0026gt; (60000, 28, 28, 1) X_train = X_train.astype(\u0026#34;float32\u0026#34;) / 255 X_test = X_test.reshape(-1, HEIGHT, WIDTH, CHANNELS) #=\u0026gt; (10000, 28, 28, 1) X_test = X_test.astype(\u0026#34;float32\u0026#34;) / 255 # 正解ラベルを one-hot ベクトル化 y_train = to_categorical(y_train.astype(\u0026#34;int32\u0026#34;), OUTPUT_SIZE) #=\u0026gt; (60000, 10) y_test = to_categorical(y_test.astype(\u0026#34;int32\u0026#34;), OUTPUT_SIZE) #=\u0026gt; (10000, 10) # CNN モデルを作成 model = Sequential() model.add(Conv2D(32, kernel_size=(3, 3), activation=\u0026#34;relu\u0026#34;, input_shape=INPUT_SHAPE)) model.add(Conv2D(64, kernel_size=(3, 3), activation=\u0026#34;relu\u0026#34;)) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Dropout(0.25)) model.add(Flatten()) model.add(Dense(128, activation=\u0026#34;relu\u0026#34;)) model.add(Dropout(0.5)) model.add(Dense(OUTPUT_SIZE, activation=\u0026#34;softmax\u0026#34;)) # モデルのコンパイル model.compile(loss=\u0026#34;categorical_crossentropy\u0026#34;, optimizer=RMSprop(), metrics=[\u0026#34;accuracy\u0026#34;]) # 学習 hist = model.fit(X_train, y_train, batch_size=128, epochs=6, verbose=1, validation_data=(X_test, y_test)) # 評価 score = model.evaluate(X_test, y_test, verbose=1) print(\u0026#34;accuracy={}, loss={}\u0026#34;.format(score[1], score[0])) # epochs=1 で accuracy=0.983 くらい # epochs=3 で accuracy=0.988 くらい # epochs=6 で accuracy=0.991 くらい"},{url:"/p/jf6kyao/",title:"Python の関数をキーワード引数を使って呼び出す",date:"2023-11-12T00:00:00Z",body:"Python の関数をキーワード引数を使って呼び出す 位置引数とキーワード引数 Python の関数を呼び出すときの引数の指定方法には、下記の 2 種類があります。 位置引数 (positional argument) \u0026hellip; 定義された順序通りに引数を渡す方法。 キーワード引数 (keyword argument) \u0026hellip; 引数名=値 のように引数名と値のペアで渡す方法。他の言語だと「名前付き引数」と呼ばれていたりします。 次の例では、2 つの文字列引数を受け取る show_book 関数を、それぞれの引数指定方法で呼び出しています。 def show_book(title: str, author: str) -\u0026gt; None: print(f\u0026#34;{title} by {author}\u0026#34;) # 位置引数 (positional argument) による関数呼び出し show_book(\u0026#34;The Hobbit\u0026#34;, \u0026#34;J.R.R. Tolkien\u0026#34;) # キーワード引数 (keyword argument) による関数呼び出し show_book(author=\u0026#34;J.R.R. Tolkien\u0026#34;, title=\u0026#34;The Hobbit\u0026#34;) 位置引数による呼び出しの方が短く記述できますが、このように同じ型 (str) の引数が複数ある場合は、キーワード引数を使った方が呼び出し順序の間違いによる不具合が入りにくくなります。 後者の呼び出し方を見るとわかるように、キーワード引数を使うと、任意の順番で引数を記述できます。 位置引数とキーワード引数を混ぜて呼び出すこともできますが、すべての位置引数をキーワード引数よりも前に配置する必要があります。 show_book(\u0026#34;The Hobbit\u0026#34;, author=\u0026#34;J.R.R. Tolkien\u0026#34;) # OK show_book(title=\u0026#34;The Hobbit\u0026#34;, \u0026#34;J.R.R. Tolkien\u0026#34;) # Syntax Error ちなみに、キーワード引数を使う場合、= の前後にはスペースを入れないのが慣例です。 デフォルト引数との組み合わせ キーワード引数による関数呼び出しの真価が発揮されるのは、引数にデフォルト値が設定されているときです。 次の draw_rect 関数は、3 つの引数を取りますが、それらすべてにデフォルト値が設定されています。 このような場合、キーワード引数を使って関数を呼び出すことで、任意の引数を省略することができます（位置引数を使うと、後方にある引数しか省略できません）。 def draw_rect(width: int = 10, height: int = 3, char: str = \u0026#34;*\u0026#34;) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;指定したサイズの矩形を描画します。\u0026#34;\u0026#34;\u0026#34; assert len(char) == 1, \u0026#34;char argument must be a single character\u0026#34; for _ in range(height): print(char * width) draw_rect() draw_rect(char=\u0026#34;o\u0026#34;) draw_rect(width=20, height=2) draw_rect(char=\u0026#34;x\u0026#34;, width=15) 実行結果 ********** ********** ********** oooooooooo oooooooooo oooooooooo ******************** ******************** xxxxxxxxxxxxxxx xxxxxxxxxxxxxxx xxxxxxxxxxxxxxx シーケンスや辞書オブジェクトを展開して関数に渡す 引数として渡す値を、リストや辞書の形でまとめて定義しておいて、関数呼び出し時に展開して渡すことができます。 リストの内容を位置引数として関数に渡すには、リストオブジェクトの前に * プレフィックスを付けます。 リスト（シーケンス）を位置引数として渡す args = [5, 2, \u0026#34;x\u0026#34;] draw_square(*args) # draw_square(5, 2, \u0026#34;x\u0026#34;) と同様 辞書の内容をキーワード引数として関数に渡すには、辞書オブジェクトの前に ** プレフィックスを付けます。 辞書をキーワード引数として渡す kwargs = {\u0026#34;char\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;height\u0026#34;: 2} draw_square(**kwargs) # draw_square(char=\u0026#34;x\u0026#34;, height=2) と同様 これらを組み合わせて使用する場合は、引数の基本ルール通り、位置引数を先に配置する必要があります。 args = [3] kwargs = {\u0026#34;char\u0026#34;: \u0026#34;x\u0026#34;} draw_square(5, *args, **kwargs) # draw_square(5, 3, char=\u0026#34;x\u0026#34;) と同様 キーワード引数による呼び出しを強制する 関数のパラメーターとして * とだけ記述すると、それ以降のパラメーターは、関数呼び出し時にキーワード引数の形でしか指定できなくなります。 本質的にオプショナルなパラメーターなどに使うとよさそうです。 次の例では、delay 引数の値を指定するときは、必ず delay=1 のようなキーワード引数の形で指定するよう強制しています。 import time def greet(name: str, *, delay: int = 0) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Greets someone with a delay.\u0026#34;\u0026#34;\u0026#34; time.sleep(delay) print(f\u0026#34;Hello, {name}!\u0026#34;) # 使用例 greet(\u0026#34;Alice\u0026#34;) # OK greet(\u0026#34;Bob\u0026#34;, delay=1) # OK greet(\u0026#34;Carol\u0026#34;, 1) # Error! ちなみに、上記の delay パラメーターのように、キーワード引数での呼び出しを強制したものを、公式ドキュメントでは keyword-only parameters と呼んでいます。 関数定義で、最初のパラメーターに * を配置すれば、すべてのパラメーターを keyword-only parameters にすることができます。 次の show_book 関数を呼び出すには、すべての引数をキーワード引数の形で指定する必要があります。 def show_book(*, title: str, author: str) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Shows book information.\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;{title} by {author}\u0026#34;) # 使用例 show_book(title=\u0026#34;The Hobbit\u0026#34;, author=\u0026#34;J.R.R. Tolkien\u0026#34;) # OK show_book(author=\u0026#34;J.R.R. Tolkien\u0026#34;, title=\u0026#34;The Hobbit\u0026#34;) # OK show_book(\u0026#34;The Hobbit\u0026#34;, \u0026#34;J.R.R. Tolkien\u0026#34;) # Error! この仕組みを使えば、関数の呼び出し時に引数の指定順序を間違える心配はなくなります（そもそも位置引数が使えなくなるので）。 もちろん、使いすぎは可読性を損なうので要注意です。 （おまけ）デフォルト引数は一度しか初期化されない 引数のデフォルト値としてイミュータブル（可変）なオブジェクトを設定している場合は、関数呼び出し時にそのオブジェクトが使いまわされることに注意してください。 下記の関数の buffer 引数に設定しているデフォルト値 ([]) に値を追加すると、2 度目以降の関数呼び出し時にもその値が残っています。 from typing import List def append_and_dump(val: int, buffer: List[int] = []) -\u0026gt; None: buffer.append(val) # 次の関数呼び出しにも影響する print(buffer) append_and_dump(1) # =\u0026gt; [1] append_and_dump(2) # =\u0026gt; [1, 2] append_and_dump(3) # =\u0026gt; [1, 2, 3] このような振る舞いを防ぐには、引数が省略されたときに明示的に新しいオブジェクトを作成するようにします。 from typing import List def append_and_dump(val: int, buffer: List[int] = None) -\u0026gt; None: if buffer is None: buffer = [] buffer.append(val) print(buffer) append_and_dump(1) # =\u0026gt; [1] append_and_dump(2) # =\u0026gt; [2] append_and_dump(3) # =\u0026gt; [3] 参考 Python の関数で可変長引数を扱う (*args, **kwargs)"},{url:"/p/nz8zoxu/",title:"scikit-image の data パッケージに含まれるテスト画像を使用する",date:"2023-11-10T00:00:00Z",body:"scikit-image の data パッケージに含まれるテスト画像を使用する scikit-image の data パッケージ scikit-image の data パッケージには、画像処理のテストに使えるテスト画像データが含まれています。 画像データを読み込むには、画像ごとに用意された関数を呼び出します。 次の例では、data.astronaut() 関数で宇宙飛行士の画像データを取得しています。 画像データは NumPy 配列データ (ndarray) として返されます。 from skimage import data # 画像データを読み込む img = data.astronaut() # 画像データの形式を調べる print(type(img)) #=\u0026gt; \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; print(img.shape) #=\u0026gt; (512, 512, 3) この画像データのサイズは 512x512 で、カラー画像（3 チャネル）であることが分かります。 読み込んだ画像データを表示する matplotlib パッケージを使えば、画像データ（NumPy 配列）を画面上に出力することができます。 図: skimage.data.astronaut() の画像データ from matplotlib import pyplot as plt from skimage import data # 画像データを読み込む img = data.astronaut() # matplotlib で画面に表示 fig, ax = plt.subplots(figsize=(4, 4), dpi=72) ax.imshow(img) plt.show() # （別の書き方） # plt.figure(figsize=(4, 4), dpi=72) # plt.imshow(img) # plt.show() 他の画像データ scikit-image の data パッケージは他にもいくつかの画像データを提供しています。 下記は汎用的に使える画像データの一覧です（詳しくはこちらの公式ドキュメント）。 イメージ データ取得関数 shape 色 data.astronaut() (512, 512, 3) カラー data.binary_blobs() (512, 512) グレースケール data.brick() (512, 512) グレースケール data.colorwheel() (370, 371, 3) カラー data.camera() (512, 512) グレースケール data.cat() (300, 451, 3) カラー data.checkerboard() (200, 200) グレースケール data.clock() (300, 400) グレースケール data.coffee() (400, 600, 3) カラー data.coins() (303, 384) グレースケール data.grass() (512, 512) グレースケール data.gravel() (512, 512) グレースケール data.horse() (328, 400) グレースケール data.logo() (500, 500, 4) カラー data.page() (191, 384) グレースケール data.text() (172, 448) グレースケール data.rocket() (427, 640, 3) カラー （おまけ）上記の一覧を出力するコード import matplotlib.pyplot as plt from skimage import data images = (\u0026#39;astronaut\u0026#39;, \u0026#39;binary_blobs\u0026#39;, \u0026#39;brick\u0026#39;, \u0026#39;colorwheel\u0026#39;, \u0026#39;camera\u0026#39;, \u0026#39;cat\u0026#39;, \u0026#39;checkerboard\u0026#39;, \u0026#39;clock\u0026#39;, \u0026#39;coffee\u0026#39;, \u0026#39;coins\u0026#39;, \u0026#39;grass\u0026#39;, \u0026#39;gravel\u0026#39;, \u0026#39;horse\u0026#39;, \u0026#39;logo\u0026#39;, \u0026#39;page\u0026#39;, \u0026#39;text\u0026#39;, \u0026#39;rocket\u0026#39;) for name in images: # 画像データの読み込み caller = getattr(data, name) # 関数名から関数を取得 img = caller() # 出力 print(\u0026#34;{} {}\u0026#34;.format(name, img.shape)) plt.figure(figsize=(3, 0.8)) plt.axis(\u0026#39;off\u0026#39;) cmap = plt.cm.gray if img.ndim == 2 else None plt.imshow(img, cmap=cmap) plt.show()"},{url:"/p/apkiihk/",title:"Python の scikit-image で画像処理",date:"2023-11-08T00:00:00Z",body:"Python の scikit-image で画像処理 scikit-image とは scikit-image は Pytyon 用の画像処理パッケージで、画像の入出力、変換、表示まで 1 パッケージで容易に行うことができます。 読み込んだ画像データは NumPy 配列として保持されるため、NumPy 配列の各種メソッドを使用して画素値を直接処理することができます。 高速な画像処理が可能なライブラリとして OpenCV などもありますが、scikit-image は OpenCV よりも学習が容易です。 科学的な画像処理には scikit-image、リアルタイムでのコンピュータービジョンタスクには OpenCV、と使い分けるとよさそうです。 scikit-image のインストール scikit-image パッケージは pip install コマンドで簡単にインストールできます（最新バージョンへの更新を兼ねるには -U オプションを付けます）。 依存する numpy、scipy、pillow などのパッケージもまとめてインストールされます。 できれば、venv 環境 にインストールすることをお勧めします。 scikit-image のインストール $ python -m pip install -U scikit-image 画面上に画像を表示する関数 (io.imshow()) を使用する場合は、matplotlib パッケージもインストールしておく必要があります。 matplotlib のインストール $ python -m pip install -U matplotlib Python コードからインポートするパッケージの名前は scikit-image ではなく、skimage なので注意してください。 skimage の機能は、次のようにサブパッケージとして分けられています。 io \u0026hellip; 画像の読み書きや、画面への表示 transform \u0026hellip; 回転などの画像変換処理 color \u0026hellip; 色空間の変換 data \u0026hellip; テスト用の画像データ img = data.astronaut() のようにテスト画像データで簡単にお試しできます。 画像ファイルを読み込む 図: 画像ファイル (cat-64x64.jpg) scikit-image で画像ファイルを読み込むには、io.imread() 関数を使用します。 読み込んだ画像データは、NumPy 配列 (numpy.ndarray) として保持されます。 次の例では、64x64 サイズのカラー画像を読み込んでいます。 from skimage import io img = io.imread(\u0026#34;cat-64x64.jpg\u0026#34;) print(type(img)) # =\u0026gt; \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; print(img.shape) # =\u0026gt; (64, 64, 3) NumPy 配列の値を出力してみると、各画素値 (R, G, B) の値が格納されていることを確認できます。 print(img) 実行結果 [[[215 238 232] [216 236 234] [219 234 237] ... [119 80 81] [124 88 92] [133 98 102]] ... NumPy 配列は 3 次元ベクトルの形で、[行, 列, チャネル] という構成になっているので、例えば次のようにして画素値を取り出すことができます。 print(img[0, 0]) # =\u0026gt; [215 238 232] （左上の 1 ピクセルの RGB 値） print(img[0, 0, :]) # =\u0026gt; 同上 print(img[0, 0, 0]) # =\u0026gt; 215 （左上 の 1 ピクセルの R 値） print(img[0, 0, 1]) # =\u0026gt; 238 （左上 の 1 ピクセルの G 値） print(img[0, 0, 2]) # =\u0026gt; 232 （左上 の 1 ピクセルの B 値） print(img[0, :, 0]) # =\u0026gt; [215 216 219 ... 133] （1 行目のすべての列のピクセルの R 値） print(img[:, 0, 0]) # =\u0026gt; [215 219 227 ... 146] （1 列目のすべての行のピクセルの R 値） io.imread() で画像を読み込むときに、as_gray=True オプションを指定すると、グレースケール化された NumPy 配列データを取得することができます。 この場合、RGB の 3 チャネルではなく、1 チャネルのデータになるので、NumPy 配列は 2 次元データになります。 img = io.imread(\u0026#34;cat-64x64.jpg\u0026#34;, as_gray=True) print(type(img)) # =\u0026gt; \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; print(img.shape) # =\u0026gt; (64, 64) print(img[0, 0]) # =\u0026gt; 0.9124701960784314（左上の画素値） 画像を表示する NumPy 配列として保持している画像データを、画面上に表示するには im.imshow() 関数を使用します。 Jupyter Notebook などの GUI 環境を使用していない場合は、続けて im.show() を実行して、各種 OS (Windows/macOS/Linux) のウィンドウを表示する必要があります。 from skimage import io img = io.imread(\u0026#34;cat-64x64.jpg\u0026#34;) io.imshow(img) io.show() 図: io.imshow() による画像表示 画像を表示するだけであれば、実は次のように直接ファイル名を指定するだけで表示できます。 io.imshow(\u0026#34;cat-64x64.jpg\u0026#34;) io.show() 次のように明示的に matplotlib.pyplot モジュールをインポートして使う方法もあります。 matplotlib で細かい出力制御をしたいときは、こちらの方法を使うとよいです。 from matplotlib import pyplot as plt from skimage import io img = io.imread(\u0026#34;cat-64x64.jpg\u0026#34;) plt.imshow(img) plt.show() RGB の各成分を取り出す 図: RGB 各成分の強度をグレースケールで表示 画像データ（NumPy 配列）の 3 次元目には、各画素の RGB 成分が含まれています。 次のように配列スライスを使って、各チャネルの成分を抽出することができます。 RGB の各チャネルを抽出 import matplotlib.pyplot as plt from skimage import io img = io.imread(\u0026#34;cat-64x64.jpg\u0026#34;) img_r = img[:, :, 0] # 全ピクセルの R 成分 img_g = img[:, :, 1] # 全ピクセルの G 成分 img_b = img[:, :, 2] # 全ピクセルの B 成分 # 画像の表示 fig, ax = plt.subplots(1, 4, figsize=(8, 2), dpi=72, layout=\u0026#34;tight\u0026#34;) ax[0].set_title(\u0026#34;RGB\u0026#34;) ax[0].imshow(img) ax[1].set_title(\u0026#34;R\u0026#34;) ax[1].imshow(img_r, cmap=\u0026#34;gray\u0026#34;) ax[2].set_title(\u0026#34;G\u0026#34;) ax[2].imshow(img_g, cmap=\u0026#34;gray\u0026#34;) ax[3].set_title(\u0026#34;B\u0026#34;) ax[3].imshow(img_b, cmap=\u0026#34;gray\u0026#34;) for a in ax: a.set_axis_off() # 軸を表示しない plt.show() 上の例では、imshow() 関数の cmap でカラーマップを gray に指定したので、画素値 0 が黒、画素値 255 が白になるように表示されています。 カラーマップを変更することで、各成分の強度を異なる色表現で表示することができます（参考: Choosing Colormaps in Matplotlib）。 例えば、Grays（あるいは Greys）を使うと、画素値 0 が白、画素値 255 が黒となるようなグレースケールで表示されます。 図: カラーマップに Grays を指定した場合 ax[1].imshow(img_r, cmap=\u0026#34;Grays\u0026#34;) ax[2].imshow(img_g, cmap=\u0026#34;Grays\u0026#34;) ax[3].imshow(img_b, cmap=\u0026#34;Grays\u0026#34;) カラーマップとして Reds、Greens、Blues を指定すると、各チャネルの強度を直感的な色で表示できます。 図: カラーマップに Reds/Greens/Blues を指定した場合 ax[1].imshow(img_r, cmap=\u0026#34;Reds\u0026#34;) ax[2].imshow(img_g, cmap=\u0026#34;Greens\u0026#34;) ax[3].imshow(img_b, cmap=\u0026#34;Blues\u0026#34;)"},{url:"/p/pa2us3b/",title:"pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes)",date:"2023-10-23T00:00:00Z",body:"pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes) Pandas の DataFrame から、数値タイプ（int64 や float64）のカラムだけを抽出するには、df.select_dtypes() メソッドを使用します。 次の例では、サンプルの DataFrame から数値タイプのカラム名を抽出して列挙しています。 import numpy as np import pandas as pd # サンプルの DataFrame を作成 data = { \u0026#39;列1\u0026#39;: [1, 2, 3], \u0026#39;列2\u0026#39;: [1.1, 2.2, 3.3], \u0026#39;列3\u0026#39;: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] } df = pd.DataFrame(data) # 数値タイプのカラムを抽出してカラム名のリストを取得 numerical_columns = df.select_dtypes(include=[np.number]).columns # 結果表示 print(numerical_columns) for col in numerical_columns: print(col) 実行結果 Index([\u0026#39;列1\u0026#39;, \u0026#39;列2\u0026#39;], dtype=\u0026#39;object\u0026#39;) 列1 列2 なお、上の例では数値型として np.number を指定していますが、\u0026quot;number\u0026quot; という文字列でも大丈夫です。"},{url:"/p/fk2e74z/",title:"pandas の DataFrame のカラムのデータ型を変更する (df.astype)",date:"2023-10-23T00:00:00Z",body:`pandas の DataFrame のカラムのデータ型を変更する (df.astype) Series と DataFrame の astype メソッド pandas の Series/DataFrame オブジェクトのデータ型を変換するには、astype() メソッドを使用します。 参考: pandas.Series.astype 参考: pandas.DataFrame.astype Series の astype() メソッドは、指定したデータ型に変換された新しい Series オブジェクトを返します。 Series のデータ型変換 ser1 = pd.Series([1, 2, 3], dtype=\u0026#34;int64\u0026#34;) # = np.int64 ser2 = ser1.astype(\u0026#34;float64\u0026#34;) # = np.float64 print(ser1.dtype) # int64 print(ser2.dtype) # float64 DataFrame の astype() メソッドを使用すると、複数カラムのデータ型をまとめて変換することができます。 DataFrame のデータ型変換 data = { \u0026#34;列1\u0026#34;: [1, 2, 3, 4], \u0026#34;列2\u0026#34;: [1.5, 2.8, 3.1, 4.3], } df1 = pd.DataFrame(data) df2 = df1.astype({\u0026#34;列1\u0026#34;: \u0026#34;float64\u0026#34;, \u0026#34;列2\u0026#34;: \u0026#34;int32\u0026#34;}) print(df2.dtypes) # int64 float64 print(df2.dtypes) # floay64 int32 もちろん、次のように DataFrame から個々の列を Series として取り出してから変換するのもありです。 df[\u0026#34;列\u0026#34;] = df[\u0026#34;列\u0026#34;].astype(\u0026#34;float64\u0026#34;) 整数にするときの切り捨て／切り上げ／四捨五入 astype() メソッドを使って浮動小数点数型 (float) のデータを整数型 (int) のデータに変換する場合、デフォルトでは少数点数以下は切り捨てられます。 少数点数以下を切り上げたり、四捨五入したい場合は、先に Series オブジェクトに対して、np.ceil() や np.round() などの NumPy 関数を適用しておきます。 df[\u0026#34;列\u0026#34;] = df[\u0026#34;列\u0026#34;].astype(int) # 切り捨て（デフォルト） df[\u0026#34;列\u0026#34;] = np.floor(df[\u0026#34;列\u0026#34;]).astype(int) # 切り捨て（同上） df[\u0026#34;列\u0026#34;] = np.ceil(df[\u0026#34;列\u0026#34;]).astype(int) # 切り上げ df[\u0026#34;列\u0026#34;] = np.round(df[\u0026#34;列\u0026#34;]).astype(int) # 四捨五入 具体例 次の例では、サンプルの DataFrame を作成して、その中の数値カラムの型を変換しています。 DataFrame のデータタイプ変換 import pandas as pd # サンプルの DataFrame を作成 data = { \u0026#34;col-1\u0026#34;: [1, 2, 3, 4], \u0026#34;col-2\u0026#34;: [1.5, 2.8, 3.1, 4.3], \u0026#34;col-3\u0026#34;: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;] } df = pd.DataFrame(data) print(\u0026#34;変換前 ====================\u0026#34;) print(df.dtypes) print() print(df) # col-1 列を浮動小数点数 (float64)、col-2 列を整数 (int64) に変換 df = df.astype({\u0026#34;col-1\u0026#34;: \u0026#34;float64\u0026#34;, \u0026#34;col-2\u0026#34;: \u0026#34;int64\u0026#34;}) print(\u0026#34;\\n変換後 ====================\u0026#34;) print(df.dtypes) # カラムのデータ型を確認 print() print(df) 実行結果 変換前 ==================== col-1 int64 col-2 float64 col-3 object dtype: object col-1 col-2 col-3 0 1 1.5 A 1 2 2.8 B 2 3 3.1 C 3 4 4.3 D 変換後 ==================== col-1 float64 col-2 int64 col-3 object dtype: object col-1 col-2 col-3 0 1.0 1 A 1 2.0 2 B 2 3.0 3 C 3 4.0 4 D`},{url:"/p/o7qnbeg/",title:"scikit-learn 組み込みのデータセットを扱う (sklearn.dataset)",date:"2023-10-18T00:00:00Z",body:"scikit-learn 組み込みのデータセットを扱う (sklearn.dataset) scikit-learn の sklearn.datasets モジュールは、組み込みのデータセットをロードする関数 (load_*) や、インターネット上のデータセットを取得する関数 (fetch_*) を提供しています。 scikit-learn の各種モジュールの振る舞いを学ぶときは、これらのデータセットをサンプルデータとして使うと便利です。 組み込みのデータセット load_ で始まる関数を使用すると、scikit-learn に組み込まれているデータセットを読み込むことができます。 データ数は少ないですが、実験には十分です。 使用例 from sklearn.datasets import load_diabetes diabetes = load_diabetes() 関数名 用途 説明 load_diabetes 回帰 糖尿病 (diabetes) 患者の診断データです。このデータセットは、糖尿病患者の臨床データからなり、主に糖尿病の進行を予測するための回帰分析に使用されます。データには患者の年齢、性別、平均血圧、BMI（Body Mass Index）、血清の 6 つの生化学的特徴（血清中の濃度など）などの特徴が含まれています。1 年後の糖尿病の進行を示す数値を予測します。 load_linnerud 回帰 体力トレーニングの効果に関する 2 つのデータセットです。Physical Exercise Data: このデータセットには、20 人の被験者の体力トレーニングに関する情報が含まれています。特徴量には、腕立て伏せ、仰向けの上体起こし、スクワットの回数が含まれており、これらの情報はトレーニングの効果を示すものです。Physiological Data: このデータセットには、20人の被験者の生理学的データが含まれており、特徴量には体重、腕立て伏せ、仰向けの上体起こし、腕立て伏せと仰向けの上体起こしの最大心拍数などが含まれています。 load_breast_cancer 分類 乳がん (breast cancer) 患者の腫瘍に関するデータで、主に乳がんの分類タスクに使用されます。データには腫瘍の特性に関する情報（腫瘍の半径、テクスチャ、周囲の腫瘍の平滑度など）が含まれており、それぞれのサンプルが「良性」または「悪性」のいずれかに分類されています。 load_digits 分類 手書き数字認識のための画像データです。0 から 9 までの手書き数字の画像が含まれており、各画像は 8x8 ピクセルのグレースケール画像として表現されています。機械学習アルゴリズムを使用して手書き数字を識別するために使用できます。 load_iris 分類 アヤメ（iris）の計測データです。iris データセットは、機械学習の教育と実験用に広く使用されるデータセットの一つです。3 つの異なる種類のアヤメの花の特性が含まれており、各花の 4 つの特徴量が記録されています。これらの特徴量は、がく片（sepal）と花弁（petal）の長さと幅に関するもので、アヤメの種類を分類するために使用できます。 load_wine 分類 ワインの化学的特性に関するデータセットです。異なる種類のワインの特性に関する情報が含まれており、主にワインの分類タスクや品質評価に使用されます。データにはアルコール濃度、酸度、フェノール類の濃度、色の強さ、色の濃さなど、ワインの化学的特性に関する 13 の特徴量が含まれています。各サンプルは 3 つの異なるワインクラス（種類）に属しています。 load_sample_image 画像 指定した画像のデータセットを numpy array として取得できます。\u0026quot;china\u0026quot;: 中国の風景画像で、機械学習のコンピュータビジョンタスクなどで使用されます。\u0026quot;flower\u0026quot;: 花の画像で、画像処理や画像分類のタスクに使用されます。 ダウンロード可能なデータセット fetch_ で始まる関数を使うと、インターネット上で公開されている有名なデータセットを読み込むことができます。 関数名 用途 説明 fetch_california_housing 回帰 カリフォルニアの住宅価格に関するデータセットで、カリフォルニア州の異なる地域（ブロックグループ）に関する住宅価格の情報とその地域の特徴に関する情報を含みます。具体的には、以下の特徴量が含まれています:住宅価格の中央値収入の中央値住宅の年齢の中央値部屋数の中央値寝室数の中央値人口の中央値世帯数の中央値地理的な位置情報（緯度と経度）このデータセットは、住宅価格の回帰分析や予測モデルをトレーニングするために使用されます。 fetch_20newsgroups 分類 20 Newsgroups データセットは、ニュースグループのメッセージからなるテキストデータセットで、クラスタリングやテキスト分類などの自然言語処理タスクのために使用されます。20 の異なるニュースグループが含まれており、それぞれのニュースグループに関するテキストメッセージが含まれています。このデータセットは、カテゴリ分類やテキスト処理の実験に広く使用されます。 fetch_20newsgroups_vectorized 分類 fetch_20newsgroups と同様ですが、ニュース記事がベクトルデータ（特徴量）化されています。 fetch_covtype 分類 木の種類を予測するためのデータセットで、土壌の種類や、標高、傾斜などの情報が含まれています。 fetch_kddcup99 分類 KDD99 のネットワーク侵入検知のコンペで用いられたデータで、持続時間やプロトコルなどの情報から攻撃の種類を予測します。 fetch_lfw_people 分類 LFW（Labeled Faces in the Wild）データセットは、多くの有名人や一般の人々の顔画像です。主に顔認識や顔検出などのコンピュータビジョンタスクの評価に使用されます。顔画像のピクセル値とそれに対応するラベル（各画像の人物の名前）が含まれています。 fetch_lfw_pairs 分類 異なる顔写真のペアで、同じ人物の場合と、異なる人物の場合があります。顔認識モデルのトレーニング、人物の同一性認識、シャッフルされた同一性認識など、さまざまなコンピュータビジョンタスクに使用できます。 fetch_olivetti_faces 分類 Olivetti Research Laboratory が収集した顔画像 (Olivetti Faces) データセットです。40 人の異なる被写体に対する顔画像のコレクションで、各被写体について、10 枚の異なる表情やポーズの画像が含まれています。画像は白黒で、サイズは 64x64 ピクセルです。このデータセットは、顔認識、顔検出、表情認識、顔の特徴量抽出など、さまざまなコンピュータビジョンタスクのトレーニングおよび評価に使用されます。 fetch_rcv1 分類 Reuters Corpus Volume I（RCV1）はニュース記事のコレクションで、カテゴリ分類タスクやトピックモデリングなどの自然言語処理タスクに使用できる大規模なテキストデータセットです。RCV1 データセットには、ニュース記事の本文や関連するカテゴリ情報が含まれています。 fetch_openml その他 OpenML プロジェクトからデータセットをダウンロードします。OpenML は、機械学習コミュニティに対して多くの機械学習データセットを提供するプラットフォームです。OpenML のデータセットは、分類、回帰、クラスタリング、異常検出など、さまざまな機械学習タスクに使用できます。 データセットを pandas のデータフレームにする dataset モジュールが返すデータは numpy.ndarray 形式になっているので、pandas でデータ処理したいときは、DataFrame 形式に変換する必要があります。 diabetes データセットからデータフレームを作成する import pandas as pd from sklearn.datasets import load_diabetes # 糖尿病のデータセットをロード diabetes = load_diabetes() # DataFrame 形式にする df = pd.DataFrame(data=diabetes.data, columns=diabetes.feature_names) print(df.head(3)) # 目的変数（糖尿病の進行状況） print(diabetes.target[:3]) 実行結果 age sex bmi bp s1 s2 s3 \\ 0 0.038076 0.050680 0.061696 0.021872 -0.044223 -0.034821 -0.043401 1 -0.001882 -0.044642 -0.051474 -0.026328 -0.008449 -0.019163 0.074412 2 0.085299 0.050680 0.044451 -0.005670 -0.045599 -0.034194 -0.032356 s4 s5 s6 0 -0.002592 0.019907 -0.017646 1 -0.039493 -0.068332 -0.092204 2 -0.002592 0.002861 -0.025930 [151. 75. 141.] wine データセットからデータフレームを作成する import pandas as pd from sklearn.datasets import load_wine # ワインのデータセットをロード wine = load_wine() # DataFrame 形式にする df = pd.DataFrame(data=wine.data, columns=wine.feature_names) print(df.head(3)) # 目的変数（ワインの種類） print(wine.target[:3]) 実行結果 alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols \\ 0 14.23 1.71 2.43 15.6 127.0 2.80 1 13.20 1.78 2.14 11.2 100.0 2.65 2 13.16 2.36 2.67 18.6 101.0 2.80 flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue \\ 0 3.06 0.28 2.29 5.64 1.04 1 2.76 0.26 1.28 4.38 1.05 2 3.24 0.30 2.81 5.68 1.03 od280/od315_of_diluted_wines proline 0 3.92 1065.0 1 3.40 1050.0 2 3.17 1185.0 [0 0 0]"},{url:"/p/ioj6bqf/",title:"pandas で CSV/TSV ファイルを出力する (pd.to_csv)",date:"2023-10-14T00:00:00Z",body:"pandas で CSV/TSV ファイルを出力する (pd.to_csv) 参考 pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) pandas で DataFrame オブジェクトの内容を CSV/TSV ファイルに出力するには、DataFrame#to_csv() メソッドを使用します。 テスト用の DataFrame ここでは、出力用の DataFrame オブジェクトを次のように作成しておきます。 インデックス名に idx1〜idx3、カラム名に col1〜col3 をセットしています。 import numpy as np import pandas as pd np.random.seed(12345) # 乱数の再現性を確保 df = pd.DataFrame({ \u0026#34;col1\u0026#34;: np.random.randint(10, size=3), \u0026#34;col2\u0026#34;: np.random.randint(10, size=3), \u0026#34;col3\u0026#34;: [\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;], }, index=[\u0026#34;idx1\u0026#34;, \u0026#34;idx2\u0026#34;, \u0026#34;idx3\u0026#34;]) print(df) 実行結果 col1 col2 col3 idx1 2 4 AAA idx2 5 9 BBB idx3 1 5 CCC CSV/TSV に出力する to_csv() メソッドの基本 パラメーターなしで to_csv() メソッドを呼び出すと、インデックス名やカラム名（CSV のヘッダー行）も含めて出力されます。 これは、パラメーターのデフォルト値が index=True, header=True になっているからです。 df.to_csv(\u0026#34;output.csv\u0026#34;) output.csv ,col1,col2,col3 idx1,2,4,AAA idx2,5,9,BBB idx3,1,5,CCC ちなみに、DataFrame にインデックス名が明示的にセットされていない場合は、次のように 0, 1, 2 という連番が振られます。 output.csv ,col1,col2,col3 0,2,4,AAA 1,5,9,BBB 2,1,5,CCC TSV 形式で出力する (sep) セパレーター文字はデフォルトでカンマ (,) ですが、sep パラメーターで任意のセパレーター文字を設定できます。 タブ (\\t) を指定すれば、TSV ファイルとして出力できます。 TSV 形式で出力する df.to_csv(\u0026#34;output.tsv\u0026#34;, sep=\u0026#34;\\t\u0026#34;) output.tsv col1	col2	col3 idx1	2	4	AAA idx2	5	9	BBB idx3	1	5	CCC インデックス列やヘッダー行を出力しない (index, header) インデックス列を出力したくないときは、index=False パラメーターを指定します。 同様に、ヘッダー行（カラム名）を出力したくないときは、header=False パラメーターを指定します。 インデックス列を出力しない df.to_csv(\u0026#34;output.csv\u0026#34;, index=False) col1,col2,col3 2,4,AAA 5,9,BBB 1,5,CCC インデックス列もヘッダー行も出力しない df.to_csv(\u0026#34;output.csv\u0026#34;, index=False, header=False) 2,4,AAA 5,9,BBB 1,5,CCC インデックス列のカラム名を指定する (index_label) インデックス列のカラム名（ラベル）を指定するには、index_label パラメーターを指定します。 デフォルトでは空文字列になってしまうので、カラム列を出力する場合は、この index_label も設定しておくことをお勧めします。 インデックス列に id というラベルを付ける df.to_csv(\u0026#34;output.csv\u0026#34;, index=True, index_label=\u0026#34;id\u0026#34;) id,col1,col2,col3 idx1,2,4,AAA idx2,5,9,BBB idx3,1,5,CCC"},{url:"/p/rtc38u8/",title:"pandas チートシート - DataFrame の欠損値 (NaN) の扱い方まとめ",date:"2023-09-06T00:00:00Z",body:"pandas チートシート - DataFrame の欠損値 (NaN) の扱い方まとめ チートシート（DataFrame の欠損値の扱い） 概要 コード 欠損値を表現する np.nan 欠損値部分を True、それ以外を False にする df2 = df.isnull() 欠損値以外の True、それ以外を True にする df2 = df.notnull() 欠損値を数える df.isnull().sum()df.isnull().sum(axis=1) 非欠損値を数える df.notnull().sum()df.count()df.info() 欠損値がある列／行を探す df.isnull().any()df.isnull().any(axis=1) 欠損値を含む「行」を削除する df.dropna()df.dropna(axis=0)df.dropna(axis=\u0026quot;index\u0026quot;) 欠損値を含む「列」を削除する df.dropna(axis=1)df.dropna(axis=\u0026quot;columns\u0026quot;) 欠損値を補完する df[\u0026quot;列\u0026quot;] = df[\u0026quot;列\u0026quot;].fillna(値)df[\u0026quot;列\u0026quot;].fillna(値, inplace=True) isnull() は isna() のエイリアスです。 Python コードでの欠損値 (NaN) の表現方法 pandas では、値が存在しないことを欠損値 (NaN: Not a Number) が存在すると表現します（プログラム的には何らかの値で「値がない」ことを表現しないといけないため）。 欠損値は、NumPy の np.nan で表現することができます。 import numpy as np print(np.nan) # nan print(type(np.nan)) # \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; ちなみに、CSV ファイルを pd.read_csv() で読み込んだ場合、何も記述されていない部分に欠損値 (np.nan) が格納されます。 逆に値が存在することは、Non-null（非欠損値）と表現したりします。 欠損値部分とそれ以外の要素を True/False 値に変換する (isnull, notnull) DataFrame の isnull() メソッドを使うと、各データが欠損値かどうかを True/False の形で取得できます。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ \u0026#34;title\u0026#34;: [\u0026#34;Title-1\u0026#34;, \u0026#34;Title-2\u0026#34;, np.nan, \u0026#34;Title-4\u0026#34;, \u0026#34;Title-5\u0026#34;], \u0026#34;price\u0026#34;: [1000, np.nan, 3000, 4000, np.nan] }) print(df.isnull()) 実行結果 title price 0 False False 1 False True 2 True False 3 False False 4 False True isnull() の代わりに notnull() を使うと、True/False が反転した結果を得られます。 print(df.notnull()) 実行結果 title price 0 True True 1 True False 2 False True 3 True True 4 True False 欠損値・非欠損値を数える (isnull, notnull, sum, count, info) 欠損値 (NaN) を数える df.isnull() を実行すると、欠損値部分だけが True になった DataFrame を生成できます。 その True の数を sum() で集計すれば、欠損値 (NaN) の数を数えることができます。 \u0026gt;\u0026gt;\u0026gt; df.isnull().sum() title 1 price 2 dtype: int64 これで、title 列には欠損値が 1 つ、price 列には欠損値が 2 つ存在することが分かりました。 特定の列の欠損値 (NaN) の数をスカラー値（整数）で取得するには次のようにします。 例: price 列の欠損値 (NaN) の数を取得 \u0026gt;\u0026gt;\u0026gt; df[\u0026#34;price\u0026#34;].isnull().sum() 2 多くの場合、欠損値は列方向で集計しますが、sum(axis=1) とすることで、行ごとの欠損値数を取得することもできます。 \u0026gt;\u0026gt;\u0026gt; df.isnull().sum(axis=1) 0 0 1 1 2 1 3 0 4 1 dtype: int64 非欠損値 (Non-null) を数える DataFrame の count() メソッドを使うと、各カラムの Non-null 値（非欠損値）の数を簡単に調べることができます。 \u0026gt;\u0026gt;\u0026gt; df.count() # あるいは df.notnull().sum() title 4 price 3 dtype: int64 特定の列の非欠損値 (Non-null) の数をスカラー値（整数）で取得するには次のようにします。 例: price 列の非欠損値 (Non-null) 値の数を取得 \u0026gt;\u0026gt;\u0026gt; df[\u0026#34;title\u0026#34;].count() # あるいは df[\u0026#34;title\u0026#34;].nonnull().sum() 4 非欠損値の数は、info() メソッドの出力の Non-Null Count 列でも確認できます。 \u0026gt;\u0026gt;\u0026gt; df.info() \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; RangeIndex: 5 entries, 0 to 4 Data columns (total 2 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 title 4 non-null object 1 price 3 non-null float64 dtypes: float64(1), object(1) memory usage: 208.0+ bytes 欠損値がある列／行を探す df.isnull() による欠損値の抽出結果に対して、any() メソッドを適用することで、欠損値の存在する列を調べることができます。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ \u0026#34;title\u0026#34;: [\u0026#34;Title-1\u0026#34;, \u0026#34;Title-2\u0026#34;, \u0026#34;Title-3\u0026#34;], \u0026#34;price\u0026#34;: [1000, np.nan, np.nan], }) print(df.isnull().any()) 実行結果 title False price True dtype: bool この結果から、price 列に欠損値が存在することが分かります。 欠損値の有無を行ごとに調べたいときは、any() メソッドの軸オプションで行方向 axis=1 を指定します。 print(df.isnull().any(axis=1)) 実行結果 0 False 1 True 2 True dtype: bool 欠損値を含む「行」を削除する 欠損値を 1 つでも含む行を削除するには、df.dropna() を使用します（あるいは df.dropna(axis=0) や df.dropna(axis=\u0026quot;index\u0026quot;) でも同様）。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ \u0026#34;title\u0026#34;: [\u0026#34;Title-1\u0026#34;, \u0026#34;Title-2\u0026#34;, np.nan, \u0026#34;Title-4\u0026#34;, \u0026#34;Title-5\u0026#34;], \u0026#34;price\u0026#34;: [1000, np.nan, 3000, 4000, np.nan] }) df2 = df.dropna() print(df2) 実行結果 title price 0 Title-1 1000.0 3 Title-4 4000.0 欠損値の有無を調べる列を絞るには、subset=[\u0026quot;列1\u0026quot;, \u0026quot;列2\u0026quot;] のようなオプションパラメーターで指定します。 指定する列が 1 つだけの場合は、リストではなく subset=\u0026quot;列1\u0026quot; のように指定することもできます。 title 列に欠損値を含む行を削除 \u0026gt;\u0026gt;\u0026gt; df.dropna(subset=[\u0026#34;title\u0026#34;]) title price 0 Title-1 1000.0 1 Title-2 NaN 3 Title-4 4000.0 4 Title-5 NaN 欠損値を含む「列」を削除する 欠損値を 1 つでも含むカラム（列）を丸ごと削除するには、df.dropna(axis=1)（あるいは df.dropna(axis=\u0026quot;columns\u0026quot;)）を使います。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ \u0026#34;col1\u0026#34;: [\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;, \u0026#34;DDD\u0026#34;, \u0026#34;EEE\u0026#34;], \u0026#34;col2\u0026#34;: [100, np.nan, 300, 400, 500], \u0026#34;col3\u0026#34;: [1.0, 2.0, np.nan, 4.0, 5.0] }) df2 = df.dropna(axis=1) print(df2) col2 列と col3 列には欠損値 (NaN) が含まれているので、それらの列が丸ごと削除されます。 実行結果 col1 0 AAA 1 BBB 2 CCC 3 DDD 4 EEE col1 列だけの DataFrame になってしまいました。。。 欠損値を補完する Series#fillna(値) メソッドは、Series 内の欠損値 (NaN) 部分を指定した値に置き換えた Series を返します。 DataFrame#fillna(値) メソッドも使えますが、通常は特定列の Series データに対して使うことになると思います。 機械学習において、欠損値が含まれている行をすべて削除 (dropna()) してしまうと、学習に使用するデータ数が不足してしまうことがあります。 そのような場合は、欠損値を平均値や中央値で補完するというテクニックがあります。 age 列の欠損値部分に 0 を入れる df[\u0026#34;age\u0026#34;].fillna(0, inplace=True) df[\u0026#34;age\u0026#34;] = df[\u0026#34;age\u0026#34;].fillna(0) // 同上 age 列の欠損値を平均値 (mean) で補う df[\u0026#34;age\u0026#34;].fillna(df[\u0026#34;age\u0026#34;].mean(), inplace=True) df[\u0026#34;age\u0026#34;] = df[\u0026#34;age\u0026#34;].fillna(df[\u0026#34;age\u0026#34;].mean()) // 同上 age 列の欠損値を中央値 (mode) で補う df[\u0026#34;age\u0026#34;].fillna(df[\u0026#34;age\u0026#34;].mode(), inplace=True) df[\u0026#34;age\u0026#34;] = df[\u0026#34;age\u0026#34;].fillna(df[\u0026#34;age\u0026#34;].mode()) // 同上"},{url:"/p/m4ggdkx/",title:"pandas チートシート - DataFrame のデータ加工方法まとめ",date:"2023-09-04T00:00:00Z",body:`pandas チートシート - DataFrame のデータ加工方法まとめ DataFrame 加工のチートシート 作成／追加 df["列"] = スカラー値 新しいカラムの作成（すべて同じ値） df["列"] = シリーズdf.assign(列=シリーズ) 新しいカラムの作成（Series の代入） df2 = df.copy() # shallow copydf2 = df.copy(deep=True) DataFrame のコピー df["列2"] = df["列1"] + 10df["列2"] = df.apply(lambda r: r["列1"] + 10, axis=1) 既存カラムの値を使って新しいカラムを作成 df2 = df[["列1", "列2", "列3"]] カラムの抽出 結合 (concat, merge) new_df = pd.concat([df1, df2]) 複数の DataFrame を縦結合 new_df = pd.merge(df1, df2, on="列", how="inner") 2 つの DataFrame を横結合 削除 (drop, drop_duplicates) df2 = df.drop(columns="列") df2 = df.drop("列", axis=1) 指定したカラムを削除 df.drop(columns="列", inplace=True) df.drop("列", axis=1, inplace=True) del df["列"] ※非推奨 df.pop("列") 指定したカラムを削除（自分自身を変更） df2 = df.drop(index="行") df2 = df.drop("行", axis=0) 指定した行を削除 df.drop(index="行", inplace=True) df.drop("行", axis=0, inplace=True) 指定した行を削除（自分自身を変更） df2 = df[df["列"] != 値] 条件に一致する行を削除 df.drop_duplicates() 重複する行を削除 df.drop_duplicates(keep="last") 重複する行を削除（最初ではなく最後の行を残す） df.drop_duplicates(subset=["X1", "X2"]) 重複する行を削除（指定列の値が等しい行を削除） 置換 (replace) df["列"].replace(置換前の値, 置換後の値) df["列"].replace([前1, 前2, 前3], [後1, 後2, 後3]) 値の置換 ソート (sort_values) df2 = pd.sort_values(by="列") 特定のカラムでソート（昇順） df2 = df.sort_values(by="列", ascending=False) 特定のカラムでソート（降順） カテゴリ変数 (get_dummies) new_df = df.select_dtypes(include="object") カテゴリ変数を抽出した DataFrame を作成 new_df = df.select_dtypes(exclude="object") カテゴリ変数を削除した DataFrame を作成 df2 = pd.get_dummies(df) df2 = pd.get_dummies(df, columns=["列1", "列2"]) 値ごとに 0/1 表現の列を作成 カラム名／インデックス名 (columns, index, rename) df.columns = [...] df2 = df.rename(colums={...}) カラム名の変更 df.index = [...] df2 = df.rename(index={...}) インデックス名の変更 データ型 (astype) df.loc[:, "列1"] = df.loc[:, "列1].astype(float) df["列1"] = df["列1"].astype(float) 列1のデータ型を変更 df2 = df.astype({"列1": "int64", "列2": "float64"}) 列1と列2のデータ型を変更 数値変換いろいろ y = y.astype("float32") / 255.0 0〜255 (int) の値を 0.0〜1.0 (float) に正規化 y = (y \u003e 0.5).astype(int) 閾値を基準にして 0 or 1 の数値に変換 X -= X.mean(axis=0) 平均値が 0 になるよう値を平行移動 新しいカラムの作成（あるいは上書き） # 値が 0 の新しい列 X1 を作成する（あるいは上書き） df[\u0026#34;X1\u0026#34;] = 0 # 列 X1 の値をもとに新しい列 X2 を作成する（あるいは上書き） df[\u0026#34;X2\u0026#34;] = df[\u0026#34;X1\u0026#34;] + 100 # 既存の DataFrame を変更する場合 df2 = df.assign(X2=df[\u0026#34;X1\u0026#34;] + 100) # 新しい DataFrame を作る場合 # 列 X1 と X2 の値をもとに新しい列 X3 を作成する（あるいは上書き） df[\u0026#34;X3\u0026#34;] = df[\u0026#34;X1\u0026#34;] + df[\u0026#34;X2\u0026#34;] # 既存の DataFrame を変更する場合 df.assign(X3=df[\u0026#34;X1\u0026#34;] + df[\u0026#34;X2\u0026#34;]) # 新しい DataFrame を作る場合 # 任意の変換関数を適用する（下記は np.sqrt 関数で平方根を生成する例） df[\u0026#34;X2\u0026#34;] = df[\u0026#34;X1\u0026#34;].apply(np.sqrt) 複数の DataFrame を縦結合する (pd.concat) 複数の DataFrame を縦方向に結合する（行を増やす）には、pd.concat() 関数に DataFrame のリストを渡します。 import pandas as pd # テストデータ df1 = pd.DataFrame({\u0026#34;col1\u0026#34;: [1, 2, 3], \u0026#34;col2\u0026#34;: [4, 5, 6]}) df2 = pd.DataFrame({\u0026#34;col1\u0026#34;: [7, 8, 9], \u0026#34;col3\u0026#34;: [10, 11, 12]}) # DataFrame を連結する new_df = pd.concat([df1, df2]) print(new_df) 実行結果 col1 col2 col3 0 1 4.0 NaN 1 2 5.0 NaN 2 3 6.0 NaN 0 7 NaN 10.0 1 8 NaN 11.0 2 9 NaN 12.0 片方の DataFrame にしか存在しないカラムの値には NaN が設定されます。 デフォルトでは上記のように、それぞれの DataFrame のもとのインデックス名が保持されます。 インデックス名を振り直すには、ignore_index=True オプションを指定します。 # インデックスを振り直す場合 new_df = pd.concat([df1, df2], ignore_index=True) print(new_df) 実行結果 col1 col2 col3 0 1 4.0 NaN 1 2 5.0 NaN 2 3 6.0 NaN 3 7 NaN 10.0 4 8 NaN 11.0 5 9 NaN 12.0 複数の DataFrame を横結合する (pd.merge) 複数の DataFrame を横方向に結合する（列を増やす）には、pd.merge() 関数を使用します。 引数として、どの列の値で対応づけるか (on) と、どのような結合アルゴリズムを使うか (how) を指定する必要があります。 結合アルゴリズムには次のようなものを指定できます。 内部結合 (how=\u0026quot;inner\u0026quot;) （デフォルト） 両方に同じ値が含まれる行のみを残します（AND のイメージ）。例えば、2 つの DataFrame において、商品 ID が一致する行があれば、その行だけをマージして新しいデータを作成します。 完全外部結合 (how=\u0026quot;outer\u0026quot;) 両方に同じ値が含まれる行があれば、それらは 1 つの行としてマージされ、その他の行はそのまま残されます（OR のイメージ）。片方にしか存在しない項目は欠損値 (NaN) で埋められます。 左外部結合 (how=\u0026quot;left\u0026quot;) 左側（第 1 引数）で指定した DataFrame の行だけが残されます。 右外部結合 (how=\u0026quot;right\u0026quot;) 右側（第 2 引数）で指定した DataFrame の行だけが残されます。 下記のサンプルコードでは、それぞれの結合アルゴリズムでどのような結果になるかを確認しています。 import pandas as pd # サンプルデータ df1 = pd.DataFrame({\u0026#34;Id\u0026#34;: [1, 2, 3], \u0026#34;Name\u0026#34;: [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;]}) df2 = pd.DataFrame({\u0026#34;Id\u0026#34;: [2, 3, 4], \u0026#34;Age\u0026#34;: [25, 30, 35]}) print(\u0026#34;=== INNER JOIN ===\u0026#34;) result_inner = pd.merge(df1, df2, on=\u0026#34;Id\u0026#34;, how=\u0026#34;inner\u0026#34;) print(result_inner) print(\u0026#34;\\n=== OUTER JOIN ===\u0026#34;) result_outer = pd.merge(df1, df2, on=\u0026#34;Id\u0026#34;, how=\u0026#34;outer\u0026#34;) print(result_outer) print(\u0026#34;\\n=== LEFT JOIN ===\u0026#34;) result_left = pd.merge(df1, df2, on=\u0026#34;Id\u0026#34;, how=\u0026#34;left\u0026#34;) print(result_left) print(\u0026#34;\\n=== RIGHT JOIN ===\u0026#34;) result_right = pd.merge(df1, df2, on=\u0026#34;Id\u0026#34;, how=\u0026#34;right\u0026#34;) print(result_right) 実行結果 === INNER JOIN === Id Name Age 0 2 Bob 25 1 3 Charlie 30 === OUTER JOIN === Id Name Age 0 1 Alice NaN 1 2 Bob 25.0 2 3 Charlie 30.0 3 4 NaN 35.0 === LEFT JOIN === Id Name Age 0 1 Alice NaN 1 2 Bob 25.0 2 3 Charlie 30.0 === RIGHT JOIN === Id Name Age 0 2 Bob 25 1 3 Charlie 30 2 4 NaN 35 一致する値を置換する (replace) Series あるいは DataFrame オブジェクトの replace() メソッドを使うと、値の一括置換を行えます。 通常は DataFrame には列ごとに性質の異なるデータが格納されているはずなので、値の置換を行う場合は Series オブジェクト（列）単位で置換します。 次の例では、Class 列の \u0026quot;A\u0026quot; と \u0026quot;B\u0026quot; という値を、それぞれ 0 と 1 に置換しています。 import pandas as pd # サンプルデータ df = pd.DataFrame({ \u0026#34;Price\u0026#34;: [100, 200, 300, 400], \u0026#34;Class\u0026#34;: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;] }) # Class 列のカテゴリ変数 (A, B) を数値 (0, 1) に置き換え df[\u0026#34;Class\u0026#34;].replace([\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;], [0, 1], inplace=True) print(df) 実行結果 Price Type 0 100 0 1 200 1 2 300 0 3 400 1 replace() メソッドで regex=True フラグを指定すると、正規表現 を使った置換が可能です。 次の例では、電話番号を表すフィールドから数値以外の文字を削除しています。 import pandas as pd # サンプルデータ df = pd.DataFrame({ \u0026#34;Name\u0026#34;: [\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Charlie\u0026#34;], \u0026#34;Phone\u0026#34;: [\u0026#34;123-4567-8901\u0026#34;, \u0026#34;(0120) 111-2222\u0026#34;, \u0026#34;111 2222 3333\u0026#34;] }) # 数値以外の文字 (\`\\D\`) をすべて削除する df[\u0026#34;Phone\u0026#34;].replace(r\u0026#34;\\D\u0026#34;, \u0026#34;\u0026#34;, regex=True, inplace=True) print(df) 実行結果 Name Phone 0 Alice 12345678901 1 Bob 01201112222 2 Charlie 11122223333 既存カラムの値を使って新しいカラムを作成 既存のカラムのデータ (Series) に対して演算を行うことで、新しいカラム用のデータを作成することができます。 次の例では、姓 カラムと 名 カラムの値をくっつけた 氏名 カラムを作成しています。 import pandas as pd # サンプルデータ df = pd.DataFrame({ \u0026#34;姓\u0026#34;: [\u0026#34;佐藤\u0026#34;, \u0026#34;鈴木\u0026#34;, \u0026#34;田中\u0026#34;], \u0026#34;名\u0026#34;: [\u0026#34;太郎\u0026#34;, \u0026#34;花子\u0026#34;, \u0026#34;次郎\u0026#34;] }) # \u0026#34;姓\u0026#34; と \u0026#34;名\u0026#34; を結合した \u0026#34;氏名\u0026#34; 列を作成 df[\u0026#34;氏名\u0026#34;] = df[\u0026#34;姓\u0026#34;] + df[\u0026#34;名\u0026#34;] print(df) 実行結果 姓 名 氏名 0 佐藤 太郎 佐藤太郎 1 鈴木 花子 鈴木花子 2 田中 次郎 田中次郎 上記のように、+ や - を使ったブロードキャスト演算で新しいカラムを作成してしまうのが一番簡単ですが、より複雑な加工処理を行いたい時は df.apply() メソッドに加工処理を行う関数を渡します（行ごとに処理することを示す axis=1 オプションも付けてください）。 次の例では、メールアドレス（mail カラム）からドメイン部分を抽出した domain カラムを作成しています。 ここでは値の加工に str#split() メソッドを使用しているので、ブロードキャスト演算が使えません。 import pandas as pd # サンプルデータ df = pd.DataFrame({ \u0026#34;mail\u0026#34;: [\u0026#34;host@example.com\u0026#34;, \u0026#34;host@test.org\u0026#34;, \u0026#34;host@sample.net\u0026#34;] }) # \u0026#34;mail\u0026#34; 列からドメイン部分を抽出して新しい列 \u0026#34;domain\u0026#34; を作成する df[\u0026#34;domain\u0026#34;] = df.apply(lambda r: r[\u0026#34;mail\u0026#34;].split(\u0026#34;@\u0026#34;)[1], axis=1) print(df) 実行結果 mail domain 0 host@example.com example.com 1 host@test.org test.org 2 host@sample.net sample.net 特定の列だけを抜き出した DataFrame を作成する ある DataFrame から特定の列だけを抽出した DataFrame を作成したいときは次のようにします。 df2 = df[[\u0026#34;列1\u0026#34;, \u0026#34;列2\u0026#34;, \u0026#34;列3\u0026#34;]] メモリ効率のため、データの実体は共有されることに注意してください（df2 側で値を変更すると、df にも影響します）。 新しいメモリ領域にコピーする場合は、copy() を組み合わせて使用します。 df2 = df[[\u0026#34;列1\u0026#34;, \u0026#34;列2\u0026#34;, \u0026#34;列3\u0026#34;]].copy() 参考: pandas.DataFrame からのデータ抽出方法のチートシート カラムの削除 (drop, del, pop) df.drop() メソッドを使うと、指定したカラムを削除した新しい DataFrame を取得できます。 drop によるカラムの削除 import pandas as pd # テストデータ df = pd.DataFrame({\u0026#34;A\u0026#34;: [1, 2, 3], \u0026#34;B\u0026#34;: [4, 5, 6], \u0026#34;C\u0026#34;: [7, 8, 9]}) # A カラムを削除 df2 = df.drop(columns=\u0026#34;A\u0026#34;) df2 = df.drop(\u0026#34;A\u0026#34;, axis=1) # 同上 # A カラムと B カラムを削除 df2 = df.drop(columns=[\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;]) df2 = df.drop([\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;], axis=1) # 同上 Python のリスト API である del や pop でもカラムの削除を行うことができますが、これらは元の DataFrame を変更します（破壊的操作）。 pop は削除した列を Series として返します。 del と pop によるカラムの削除 # A カラムを削除 （df 自身を変更） del df[\u0026#34;A\u0026#34;] # 同上だが削除したカラムを Series として返す series = df.pop(\u0026#34;A\u0026#34;) ☝️ pop の使用例 pop によるカラムの削除は、機械学習用のデータセットから正解ラベルを分離するときに使われたりします。 # 正解ラベルの列 Price を分離 train_X = train.copy() train_y = train_X.pop(\u0026#34;Price\u0026#34;) df.drop() はデフォルトでは新しい DataFrame を返しますが、inplace=True を指定すれば、元の DataFrame を変更できます。 この場合、戻り値は None になります。 # 元の DataFrame 自身を変更する df.drop(columns=[\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;], inplace=True) 行の削除 (drop) 指定した行を削除 drop による行の削除 import pandas as pd # テストデータ df = pd.DataFrame({\u0026#34;A\u0026#34;: [1, 2, 3], \u0026#34;B\u0026#34;: [4, 5, 6], \u0026#34;C\u0026#34;: [7, 8, 9]}) # 先頭行を削除（インデックスラベルが設定されてない場合） df2 = df.drop(0) df2 = df.drop(0, axis=0) # 同上 df2 = df.drop(index=0) # 同上 # 先頭行を削除（インデックスラベルが設定されている場合） df2 = df.index = [\u0026#34;idx1\u0026#34;, \u0026#34;idx2\u0026#34;, \u0026#34;idx3\u0026#34;] df2 = df.drop(\u0026#34;idx1\u0026#34;) df2 = df.drop(\u0026#34;idx1\u0026#34;, axis=0) # 同上 df2 = df.drop(index=\u0026#34;idx1\u0026#34;) # 同上 # 複数の行をまとめて削除することも可能 df2 = df.drop(index=[0, 1, 2]) df2 = df.drop(index=[\u0026#34;idx1\u0026#34;, \u0026#34;idx2\u0026#34;, \u0026#34;idx3\u0026#34;]) df.drop() はデフォルトでは新しい DataFrame を返しますが、inplace=True を指定すると元の DataFrame を変更できます。 この場合、戻り値は None になります。 # 先頭の行を削除 （元の df 自身を変更） df.drop(index=0, inplace=True) 重複する行を削除 DataFrame#drop_duplicates() メソッドを使うと、同じデータを持つ行を取り除いた DataFrame を作成することができます。 次の例では、1 行目と 3 行目のデータが (100, \u0026quot;x\u0026quot;, 500) で完全に一致しているので、3 行目が削除されています。 import pandas as pd df = pd.DataFrame({ \u0026#34;A\u0026#34;: [100, 100, 100, 200, 300], \u0026#34;B\u0026#34;: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;x\u0026#34;], \u0026#34;C\u0026#34;: [500, 600, 500, 600, 700], }) new_df = df.drop_duplicates() print(new_df) 実行結果 A B C 0 100 x 500 1 100 y 600 3 200 y 600 4 300 x 700 特定のカラムだけに着目して重複行を判断したいときは、subset=[列, 列, ...] オプションを指定します。 次の例では、少なくとも B 列と C 列の値が等しい行を重複行として取り除いています（部分的に一致する行を削除します）。 new_df = df.drop_duplicates(subset=[\u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;]) print(new_df) 実行結果 A B C 0 100 x 500 1 100 y 600 4 300 x 700 ☝️ 重複している行を確認する df.duplicated() で各行が重複しているかを示すフラグ (True/False) の Series オブジェクトを取得できます。 これを使って元のデータフレームをフィルタすると、重複している行だけを抽出 することができます。 import pandas as pd df = pd.DataFrame({ \u0026#34;A\u0026#34;: [100, 100, 100, 200, 300], \u0026#34;B\u0026#34;: [\u0026#34;x\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;], }) dup_df = df[df.duplicated(keep=False)] print(dup_df) このコードを実行すると、最初の 3 つの行が重複していることを確認できます。 A B 0 100 x 1 100 x 2 100 x df.duplicated() の戻り値は、デフォルトでは削除すべき行だけが True となります。 例えば、3 つの行が重複している場合、削除すべき 2 つの行のみ True になります。 上記コードのように、df.duplicated() に keep=False オプションを付けることで、3 つの行すべてを True にすることができます。 条件に一致する行を削除 これは発想の転換ですが、「ある列の値が A 以外である行を抽出する」という操作は、「ある列の値が A である行を削除する」という操作になります。 import pandas as pd # テストデータ df = pd.DataFrame({ \u0026#34;grade\u0026#34;: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;], \u0026#34;point\u0026#34;: [100, 80, 50, 70, 90, 75] }) # grade 列が A であるものを削除 （= A でないものを抽出する） new_df = df[df[\u0026#34;grade\u0026#34;] != \u0026#34;A\u0026#34;] print(new_df) 実行結果 grade point 1 B 80 2 C 50 3 B 70 5 B 75 特定のカラムでソート テストデータ import numpy as np import pandas as pd df = pd.DataFrame({ \u0026#39;grade\u0026#39;: [\u0026#39;C\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, np.nan, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;], \u0026#39;price\u0026#39;: [50, 100, 150, 70, 30, 200] }) grade カラムでソート \u0026gt;\u0026gt;\u0026gt; df.sort_values(by=\u0026#34;grade\u0026#34;) grade price 1 A 100 5 A 200 2 B 150 4 B 30 0 C 50 3 NaN 70 欠損値 (NaN) を先頭に持ってくる \u0026gt;\u0026gt;\u0026gt; df.sort_values(by=\u0026#34;grade\u0026#34;, na_position=\u0026#34;first\u0026#34;) grade price 3 NaN 70 1 A 100 5 A 200 2 B 150 4 B 30 0 C 50 price カラムで降順ソート \u0026gt;\u0026gt;\u0026gt; df.sort_values(by=\u0026#34;price\u0026#34;, ascending=False) grade price 5 A 200 2 B 150 1 A 100 3 NaN 70 0 C 50 4 B 30 複数カラムでソート \u0026gt;\u0026gt;\u0026gt; df.sort_values(by=[\u0026#34;grade\u0026#34;, \u0026#34;price\u0026#34;], ascending=[True, False]) grade price 5 A 200 1 A 100 2 B 150 4 B 30 0 C 50 3 NaN 70 ソート後にインデックス (0, 1, 2, ...) を振り直す \u0026gt;\u0026gt;\u0026gt; df.sort_values(by=\u0026#34;price\u0026#34;).reset_index() index grade price 0 4 B 30 1 0 C 50 2 3 NaN 70 3 1 A 100 4 2 B 150 5 5 A 200 元のインデックスは index という新規カラムに格納されます。 index カラムが不要な場合は reset_index() メソッドに drop=True を指定します。 カテゴリ変数 カテゴリ変数を抽出／取り除いて DataFrame を作成 df.select_dtypes() を使って、カテゴリ変数の列のみを抽出した DataFrame を作成することができます。 NaN はカテゴリ変数とはみなされません。 import pandas as df # テストデータ df = pd.DataFrame({ \u0026#34;col1\u0026#34;: [\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;, \u0026#34;DDD\u0026#34;], \u0026#34;col2\u0026#34;: [\u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, \u0026#34;Z\u0026#34;, np.nan], \u0026#34;col3\u0026#34;: [100, 200, 300, 400], \u0026#34;col4\u0026#34;: [1.0, 2.0, 3.0, np.nan], }) # カテゴリ変数だけの DataFrame を作成 new_df = df.select_dtypes(include=[\u0026#34;object\u0026#34;]) print(new_df) print(new_df.columns.to_list()) 実行結果 col1 col2 0 AAA X 1 BBB Y 2 CCC Z 3 DDD NaN [\u0026#39;col1\u0026#39;, \u0026#39;col2\u0026#39;] include パラメーターの代わりに、exclude パラメーターを使うと、指定したタイプの列だけを取り除くことができます。 次の例では、上記の例とは逆に、カテゴリ変数を取り除いた（数値変数のみの）DataFrameを作成しています。 # カテゴリ変数を取り除いた DataFrame を作成 new_df = df.select_dtypes(exclude=[\u0026#34;object\u0026#34;]) print(new_df) print(new_df.columns.to_list()) 実行結果 col3 col4 0 100 1.0 1 200 2.0 2 300 3.0 3 400 NaN [\u0026#39;col3\u0026#39;, \u0026#39;col4\u0026#39;] 値ごとに True/False (0/1) のカラムを生成 pd.get_dummies() 関数を使うと、カテゴリ変数（典型的には文字列型）のカラムを True or False (0 or 1) 情報のカラムに変換した DataFrame を生成できます。 ロジスティック回帰モデルなどを使用した機械学習において、入力データを数値に変換する際に pd.get_dummies() 関数を使うと便利です。 次の例では、col1 カラムを col1_AAA、col1_BBB、col1_CCC という 3 つのカラムに変換し、col2 カラムを col2_X、col2_Y という 2 つのカラムに変換しています。 df = pd.DataFrame({ \u0026#34;col1\u0026#34;: [\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;AAA\u0026#34;], \u0026#34;col2\u0026#34;: [\u0026#34;X\u0026#34;, \u0026#34;Y\u0026#34;, np.nan, \u0026#34;X\u0026#34;, np.nan] }) df2 = pd.get_dummies(df) print(df2) 実行結果 col1_AAA col1_BBB col1_CCC col2_X col2_Y 0 True False False True False 1 False True False False True 2 False False True False False 3 False True False True False 4 True False False False False 欠損値 (NaN) のカラムも生成するには、dummy_na=True パラメーターを追加します。 \u0026gt;\u0026gt;\u0026gt; pd.get_dummies(df, dummy_na=True) col3 col1_AAA col1_BBB col1_CCC col1_nan col2_X col2_Y col2_nan 0 1 True False False False True False False 1 2 False True False False False True False 2 3 False False True False False False True 3 4 False True False False True False False 4 5 True False False False False False True デフォルトでは上記のように bool 型のカラムに変換されますが、dtype=int を指定することで、int 型 (0 or 1) のカラムに変換することができます。 \u0026gt;\u0026gt;\u0026gt; pd.get_dummies(df, dtype=int) col3 col1_AAA col1_BBB col1_CCC col2_X col2_Y 0 1 1 0 0 1 0 1 2 0 1 0 0 1 2 3 0 0 1 0 0 3 4 0 1 0 1 0 4 5 1 0 0 0 0`},{url:"/p/78ns8r5/",title:"pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table)",date:"2023-09-04T00:00:00Z",body:"pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) 参考 pandas で CSV/TSV ファイルを出力する (pd.to_csv) pandas で CSV ファイルを読み込んで DataFrame オブジェクトを生成するには、pd.read_csv() 関数を使用します。 read_csv() 関数は、任意のセパレーター (sep) を指定できるので、CSV ファイルだけでなく、TSV ファイルなども読み込むことができます。 ヘッダーの有無の指定 (header) import pandas as pd # ヘッダー有りの CSV ファイルを読み込む df = pd.read_csv(\u0026#34;input.csv\u0026#34;) # ヘッダー無しの CSV ファイルを読み込む df = pd.read_csv(\u0026#34;input.csv\u0026#34;, header=None) # ヘッダーが 2 行目にある場合 df = pd.read_csv(\u0026#34;input.csv\u0026#34;, header=1) TSV ファイルを読み込む タブ区切りファイル (TSV) を読み込む場合は、pd.read_csv() 関数でセパレーター文字 (sep) を指定するか、pd.read_table() 関数を使用します。 TSV ファイルを読み込む df = pd.read_csv(\u0026#34;input.tsv\u0026#34;, sep=\u0026#34;\\t\u0026#34;) df = pd.read_table(\u0026#34;input.tsv\u0026#34;) # 同上 カラム名を設定する (names) CSV/TSV ファイルから DataFrame オブジェクトを生成するときに names 引数を指定すると、明示的にカラム名をセットすることができます。 この場合、CSV/TSV ファイルの最初の行からデータが始まっているとみなされるため、ヘッダー行を含む CSV/TSV ファイルを読み込む場合、ヘッダー行をうまいこと無視する必要があります。 header=0 を指定して 1 行目がヘッダー行であることを伝えるか、skiprows=1 で単純に 1 行スキップする方法が使えます。 カラム名を設定する # CSV ファイルにヘッダー行が存在しない場合 df = pd.read_csv(\u0026#34;input.csv\u0026#34;, names=[\u0026#34;COL1\u0026#34;, \u0026#34;COL2\u0026#34;, \u0026#34;COL3\u0026#34;]) # CSV ファイルにヘッダー行が存在する場合 df = pd.read_csv(\u0026#34;input.csv\u0026#34;, names=[\u0026#34;COL1\u0026#34;, \u0026#34;COL2\u0026#34;, \u0026#34;COL3\u0026#34;], header=0) df = pd.read_csv(\u0026#34;input.csv\u0026#34;, names=[\u0026#34;COL1\u0026#34;, \u0026#34;COL2\u0026#34;, \u0026#34;COL3\u0026#34;], skiprows=1) もちろん、DataFrame 生成後にカラム名を変更する方法でも OK です。 df = pd.read_csv(\u0026#34;input.csv\u0026#34;) df.columns = [\u0026#34;COL1\u0026#34;, \u0026#34;COL2\u0026#34;, \u0026#34;COL3\u0026#34;] 参考: DataFrame のカラム名やインデックス名を変更する カンマの後ろのスペースを削除する (skipinitialspace) CSV ファイル内のデータが、次のように「カンマ + スペース」で区切られている場合、デフォルトではスペースもデータの一部として扱われます。 input.csv col1, col2, col3 100, AAA, 300 400, BBB, 600 700, CCC, 900 たとえば、2 つ目のカラム名は \u0026quot;col2\u0026quot; ではなく \u0026quot; col2\u0026quot; とみなされてしまいます。 read_csv() 関数の引数として skipinitialspace=True を指定すると、カンマの後のスペースを無視してくれます。 df = pd.read_csv(\u0026#34;input.csv\u0026#34;, skipinitialspace=True) 特定の列をインデックス列として扱う (index_col) 例えば、CSV ファイルの先頭列に次のようにデータの ID (1, 2, 3, \u0026hellip;) が付いているとします。 input.csv ID,col1,col2,col3 1,100,AAA,300 2,400,BBB,600 3,700,CCC,900 pd.read_csv() 関数の index_col パラメーターでカラム名を指定すると、そのカラムを DataFrame のインデックスとして取り込むことができます。 \u0026gt;\u0026gt;\u0026gt; df = pd.read_csv(\u0026#34;input.csv\u0026#34;, index_col=\u0026#34;ID\u0026#34;) \u0026gt;\u0026gt;\u0026gt; df col1 col2 col3 ID 1 100 AAA 300 2 400 BBB 600 3 700 CCC 900 上記ではカラムの名前（文字列）を指定していますが、次のように数値で指定することもできます。 df = pd.read_csv(\u0026#34;input.csv\u0026#34;, index_col=0) 特定の列だけを読み込む (usecols) 多数の列がある CSV ファイルを読み込む場合、必要な列だけを読み込むようにすればメモリ効率がよくなります。 読み込む列を列番号で指定する（0 始まり） df = pd.read_csv(\u0026#34;input.csv\u0026#34;, usecols=[0, 1, 3]) 読み込む列を列名で指定する df = pd.read_csv(\u0026#34;input.csv\u0026#34;, usecols=[\u0026#34;col1\u0026#34;, \u0026#34;col2\u0026#34;, \u0026#34;col4\u0026#34;]) 各カラムのデータタイプを指定する (dtype) 各カラムのデータタイプは CSV に含まれている実際のデータから推測されますが、dtype パラメーターでカラムごとに明示することができます。 適切なデータタイプを設定することで、メモリ使用量の節約に繋がります。 例えば、次のような 3 つのカラムを持つ CSV ファイルを読み込むとします。 input.csv col1,col2,col3 100,A,120.5 200,B,236.3 300,C,398.2 400,A,437.8 500,B,525.8 600,C,671.1 まずは dtype パラメーターなしで CSV ファイルを読み込んで、DataFrame の各カラムのデータタイプや、全体のメモリ使用量を df.info() で確認してみます。 \u0026gt;\u0026gt;\u0026gt; df = pd.read_csv(\u0026#34;input.csv\u0026#34;) \u0026gt;\u0026gt;\u0026gt; df.info() \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; RangeIndex: 6 entries, 0 to 5 Data columns (total 3 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 col1 6 non-null int64 1 col2 6 non-null object 2 col3 6 non-null float64 dtypes: float64(1), int64(1), object(1) memory usage: 272.0+ bytes データタイプ (dtype) を明示せずに読み込むと、上記のように、整数が int64 型、テキストが object 型、少数点数が float64 型と推測されて DataFrame が生成されます。 実際には、col1 列と col3 列の数値を表現するのに 64 ビットも必要ないかもしれませんし、col2 列は汎用的な object 型ではなく category 型（カテゴリカルデータ）として扱いたいかもしれません。 そのような場合は、dtype で次のようにデータタイプを指定します。 \u0026gt;\u0026gt;\u0026gt; df = pd.read_csv(\u0026#34;input.csv\u0026#34;, dtype={ ... \u0026#34;col1\u0026#34;: \u0026#34;int32\u0026#34;, ... \u0026#34;col2\u0026#34;: \u0026#34;category\u0026#34;, ... \u0026#34;col3\u0026#34;: \u0026#34;float32\u0026#34; ... }) \u0026gt;\u0026gt;\u0026gt; df.info() \u0026lt;class \u0026#39;pandas.core.frame.DataFrame\u0026#39;\u0026gt; RangeIndex: 6 entries, 0 to 5 Data columns (total 3 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 col1 6 non-null int32 1 col2 6 non-null category 2 col3 6 non-null float32 dtypes: category(1), float32(1), int32(1) memory usage: 206.0 bytes 適切なデータタイプを指定することにより、メモリ使用量を 272 バイトから 206 バイトまで減らすことができました。 巨大な CSV ファイルを読み込むときは、この dtype パラメーターと usecols パラメーター を適切に指定することで、メモリ使用量を大幅に削減できます。 ちなみに、上記の例ではカラムごとにデータタイプを指定しましたが、dtype=str のように指定することで、すべてのカラムを文字列データとして扱うことができます。"},{url:"/p/3g687f5/",title:"pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix)",date:"2023-09-04T00:00:00Z",body:"pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix) pandas の DataFrame のカラム名やインデックス名を変更方法のまとめです。 カラム名を一括で置き換える (columns) 既存の DataFrame のカラム名（列名）を丸ごと置き換えるには、columns プロパティにカラム名のリストを代入します。 df.columns = [\u0026#34;列名1\u0026#34;, \u0026#34;列名2\u0026#34;, \u0026#34;列名3\u0026#34;] この操作は、既存の DataFrame のカラム名を直接変更します。 カラム名にプレフィックスやサフィックスを追加する (add_prefix, add_suffix) # 全てのカラム名の先頭に X_ を付ける f2 = df.add_prefix(\u0026#34;X_\u0026#34;) # 全てのカラム名の末尾に _X を付ける df2 = df.add_suffix(\u0026#34;_X\u0026#34;) どちらの関数も、カラム名が変更された新しい DataFrame を返します。 元の DataFrame のカラム名は変更されませんが、データ自体は同じメモリ上の値を参照しています。 特定のカラムやインデックスの名前を変更する (rename) カラム名（列名）の変更 df2 = df.rename( columns={ \u0026#34;既存の列名1\u0026#34;: \u0026#34;新しい列名1\u0026#34;, \u0026#34;既存の列名2\u0026#34;: \u0026#34;新しい列名2\u0026#34;, \u0026#34;既存の列名3\u0026#34;: \u0026#34;新しい列名3\u0026#34; } ) インデックス名（行名）の変更 df2 = df.rename( index={ \u0026#34;既存の行名1\u0026#34;: \u0026#34;新しい行名1\u0026#34;, \u0026#34;既存の行名2\u0026#34;: \u0026#34;新しい行名2\u0026#34;, \u0026#34;既存の行名3\u0026#34;: \u0026#34;新しい行名3\u0026#34; } ) DataFrame#rename() 関数は、カラム名やインデックス名が変更された新しい DataFrame を返します。 元の DataFrame のカラム名やインデックス名は変更されませんが、データ自体は同じメモリ上の値を参照しています。 変換関数を指定する方法 rename メソッドの columns 引数（あるいは index 引数）に名前の変換関数を指定すると、すべてのカラム名やインデックス名をまとめて置換できます。 次の例では、変換関数として str.lower を指定しています。 全てのカラム名（列名）を小文字にする df2 = df.rename(columns=str.lower) df2 = df.rename(mapper=str.lower, axis=1) # 同上 全てのインデックス名（行名）を小文字にする df2 = df.rename(index=str.lower) df2 = df.rename(mapper=str.lower, axis=0) # 同上 次の例では、変換関数としてラムダ関数を指定しています。 デフォルトの行番号 (0, 1, 2, ...) から Y1, Y2, Y3, ... のような行名を生成 df2 = df.rename(index=lambda y: \u0026#34;Y{}\u0026#34;.format(y + 1))"},{url:"/p/rnai4ko/",title:"pandas チートシート - DataFrame のデータ抽出方法まとめ",date:"2023-08-27T00:00:00Z",body:`pandas チートシート - DataFrame のデータ抽出方法まとめ pandas の DataFrame から部分データを抽出する方法のまとめです。 指定した行と列の抽出 基本的に、行と列の 「名称」による抽出には loc プロパティを使い、「数値」による抽出には iloc プロパティを使用します。 下記の例では、インデックス名（行名）に Y1 〜 Y5、カラム名（列名）に X1 〜 X5 が設定されているものとします。 カテゴリ コード 抽出のイメージ 戻り値の型 スカラー値 df.loc["Y3", "X2"] df.iloc[2, 1] numpy.float64 など 1 行の抽出 df.loc["Y2"] df.loc["Y2", :] df.iloc[1] df.iloc[1, :] Series df.loc[["Y2"]] df.loc[["Y2"], :] df.iloc[[1]] df.iloc[[1], :] DataFrame 複数行の抽出 df.loc["Y2":"Y4"] df.iloc[1:4] df["Y2":"Y4"] df[1:4] DataFrame df.head(2) DataFrame df.tail(2) DataFrame 1 列の抽出 df.loc[:, "X2"] df.iloc[:, 1] df["X2"] Series df.loc[:, ["X2"]] df.iloc[:, [1]] df[["X2"]] DataFrame 複数列の抽出 df.loc[:, ["X2", "X4", "X5"]] df.iloc[:, [1, 3, 4]] df[["X2", "X4", "X5"]] DataFrame 組み合わせ df.loc["Y3":"Y5", "X2"] df.iloc[2:5, 1] Series df.loc["Y3":"Y5", ["X2"]] df.iloc[2:5, [1]] DataFrame df.loc["Y3":"Y5", "X2":"X4"] df.iloc[2:5, 1:4] DataFrame df.loc["Y3":"Y5", ["X2", "X4"]] df.iloc[2:5, [1, 3]] DataFrame 参考: pandas.DataFrame から部分データを抽出する 条件指定による行の抽出 コード 説明 df[df["X1"] \u003e= 10] df.query("X1 \u003e= 10") X1 列の値が 10 以上の行を抽出 df[df["X1"] == 10] df.query("X1 == 10") X1 列の値が 10 の行を抽出 df[df["X1"] != 10] df.query("X1 != 10") X1 列の値が 10 ではない行を抽出 df[df["X1"] == "AAA"] df.query("X1 == 'AAA'") X1 列の値が "AAA" の行を抽出 df[df["X1"].isin(["AAA", "BBB"])] X1 列の値が "AAA" または "BBB" である行を抽出 df[~df["X1"].isin(["AAA", "BBB"])] X1 列の値が "AAA" でも "BBB" でもない行を抽出 df[df["X1"].str.contains("AAA")] X1 列に "AAA" を含む行を抽出 df[~df["X1"].str.contains("AAA")] X1 列に "AAA" を含まない行を抽出 df[df["X1"].notna()] X1 列に値が存在する行を抽出 df[(df["X1"] \u003e= 0) \u0026 (df["X1"] \u003c 10)] AND 条件で行を抽出 df[(df["X1"] == 0) | (df["X2"] == "AAA")] OR 条件で行を抽出 df.loc[df["X1"] \u003e 0, ["X1", "X2", "X3"]] 行を抽出して、ついでに列を絞り込む （おまけ）テストデータ 上記の処理を試すための 5 行 5 列のテストデータです。 import numpy as np import pandas as pd data = np.arange(1, 26).reshape((5, 5)) # 5x5 の連番データを作成 columns = [\u0026#34;X%d\u0026#34; % i for i in range(1, 6)] # カラム名 index = [\u0026#34;Y%d\u0026#34; % i for i in range(1, 6)] # インデックス名 df = pd.DataFrame(data, columns=columns, index=index) Python の対話シェルに上記をコピペして DataFrame を作成すれば、df[\u0026quot;X1\u0026quot;] などの結果を調べることができます。 \u0026gt;\u0026gt;\u0026gt; df X1 X2 X3 X4 X5 Y1 1 2 3 4 5 Y2 6 7 8 9 10 Y3 11 12 13 14 15 Y4 16 17 18 19 20 Y5 21 22 23 24 25 \u0026gt;\u0026gt;\u0026gt; df.loc[\u0026#34;Y1\u0026#34;:\u0026#34;Y3\u0026#34;, \u0026#34;X3\u0026#34;:\u0026#34;X5\u0026#34;] X3 X4 X5 Y1 3 4 5 Y2 8 9 10 Y3 13 14 15`},{url:"/p/59ruo5m/",title:"Matplotlib の Axes、Figure、pyplot の関係を理解する",date:"2023-08-04T00:00:00Z",body:"Matplotlib の Axes、Figure、pyplot の関係を理解する Figure と Axes Matplotlib の基本的な描画要素として、Figure と Axes があり、Figure の中に複数の Axes を配置できるようになっています。 次のプロット画像には、1 つの Figure の中に、2 つの Axes を配置しています。 図: Figure と Axes の関係 上記画像のコード import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] # Figure の作成 fig = plt.figure(facecolor=\u0026#34;lightskyblue\u0026#34;, layout=\u0026#34;tight\u0026#34;, dpi=72, figsize=(6, 3)) fig.suptitle(\u0026#34;Figure\u0026#34;) # Axes によるプロット ax = fig.subplots(1, 2) ax[0].set_title(\u0026#34;Axes 1\u0026#34;, loc=\u0026#34;left\u0026#34;, fontstyle=\u0026#34;oblique\u0026#34;, fontsize=\u0026#34;medium\u0026#34;) ax[0].plot(x, y) ax[1].set_title(\u0026#34;Axes 2\u0026#34;, loc=\u0026#34;left\u0026#34;, fontstyle=\u0026#34;oblique\u0026#34;, fontsize=\u0026#34;medium\u0026#34;) ax[1].plot(x, y) fig.savefig(\u0026#34;img-001.svg\u0026#34;) Figure オブジェクトの subfigures メソッドや add_subfigure メソッドを使うと、Figure の入れ子構造を作ることができます。 Axes インターフェイスと pyplot インターフェイス Matplotlib を使ったプロット方法には、明示的 Axes インターフェイス を使う方法と、暗黙的 pyplot インターフェイス を使う方法があります。 明示的 Axes インターフェイス (explicit Axes interface) 最初に Figure や Axes オブジェクトの参照を取得し、それらのメソッドを明示的に呼び出して各種パラメーターを設定していく方法です。 オブジェクト指向インターフェイスと呼ばれています。 各オブジェクトを別々に制御できるため、柔軟性が高いです。 import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] fig = plt.figure() # Figure を作成 ax = fig.subplots() # Figure 内に Axes を作成 ax.plot(x, y) # Axes へのプロット # 次のように Figure と Axes をまとめて取得することも可能 # fig, ax = plt.subplots() # ax.plot(x, y) plt.show() Figure#subplots() メソッドあるいは pyplot.subplots() 関数の引数として、プロット領域の分割数（行数と列数）を渡すと、リストの形で Axes オブジェクトを取得することができます。 次のように、プロット先をインデックスで切り替えることができます。 fig, ax = plt.subplots(1, 2) # 1 行 2 列に分割されたプロット領域 (Axes) を作成 ax[0].plot(x, y) # 1 つ目の Axes にプロット ax[1].plot(x, y) # 2 つ目の Axes にプロット 暗黙的 pyplot インターフェイス (implicit pyplot interface) pyplot モジュールが提供する関数を連続して呼び出すことで、内部で描画情報を積み上げていく方法です。 コードとしては、plt.hogehoge() のような関数をたくさん呼び出すことになります。 内部的には Axes オブジェクトのプロット関連メソッドが呼び出されているわけですが、それらの呼び出しは隠蔽されるため、簡単な内容であれば、短いコードで記述することができます。 import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] plt.plot(x, y) # 内部で保持されている Axes にプロットする plt.show() ただし、分割されたチャートを描画するようなケースでは、前述の明示的な Axes を使った方が分かりやすいです。 pyplot インターフェイスを使う方法だと、内部的に現在どの Axes を操作しているのかを意識したコーディングを行う必要があります。 plt.subplot(1, 2, 1) # 1 行 2 列に分割した描画先の 1 つ目の Axes を選択 plt.plot(x, y) # 1 つ目の Axes にプロット plt.subplot(1, 2, 2) # 1 行 2 列に分割した描画先の 2 つ目の Axes を選択 plt.plot(x, y) # 2 つ目の Axes にプロット"},{url:"/p/zfhtasm/",title:"Rust のオブジェクトのライフタイム（生存期間）を理解する ('static, 'a)",date:"2023-07-11T00:00:00Z",body:"Rust のオブジェクトのライフタイム（生存期間）を理解する ('static, 'a) ライフタイムの基本 Rust のオブジェクトのライフタイム（生存期間）は、その名の通り、オブジェクトが有効な期間を表しています。 変数とその借用 (borrow) である参照は、異なるライフタイムを持っています。 変数のライフタイム 変数のライフタイムは、その変数が初期化されるときに開始し、スコープを抜けるときに終了します。 スコープを抜けるとき、その変数はドロップ（破棄）され、それ以降は使用できなくなります。 { let s = String::from(\u0026#34;Hello\u0026#34;); // 変数 s のライフタイムはここで終わり、ドロップされる } // 変数 s はここではもう使えない スコープはその変数を囲んでいるブロックであり、専門的には lexical scope と呼ばれます。 そのため、変数のライフタイムのことを lexical lifetime と呼ぶことがあります。 参照のライフタイム 一方で、参照（リファレンス）のライフタイムは、その参照を使う最後の文で終了します。 つまり、参照を使っているコード範囲がそのままライフタイムになるため、とてもシンプルです。 let s = String::from(\u0026#34;Hello\u0026#34;); let r = \u0026amp;s; // 参照 r のライフタイムはここから始まり println!(\u0026#34;{}\u0026#34;, r); // ここで終わる println!(\u0026#34;{}\u0026#34;, s); 参照は、ある変数を借用 (borrow) したものであり、参照のライフタイムが終了しても、その参照先の変数が破棄（ドロップ）されるようなことはありません。 ライフタイムは「変数＞参照」でなければいけない 変数とその参照のライフタイム関係は、次のような入れ子関係になっていなければいけないことは明らかです。 図: 正しいライフタイム関係 次のように、参照のライフタイムが、その参照先のオブジェクトのライフタイムを超えるのはおかしいからです。 図: 誤ったライフタイム関係 次のコードは、参照がライフタイム違反をしている例です。 間違った例 let r; { let num = 1; r = \u0026amp;num; } println!(\u0026#34;{}\u0026#34;, r); // NG! （参照先の num はすでにドロップされている） Rust コンパイラーは内部に borrow checker という仕組みを備えており、上記のような不正なライフタイム関係がないかを確認してくれます。 上記のコードをコンパイルしようとすると、次のようなコンパイルエラーになります。 error[E0597]: `num` does not live long enough このようなシンプルな例であれば、ライフタイム違反をしていることは簡単に分かりますが、関数の戻り値として参照を返す場合や、構造体のフィールドとして参照を持つような場合は、若干複雑になってきます。 以下、これらを順番に見ていきます。 関数の戻り値を参照にする 関数の戻り値として参照を返す場合、次のような種類の参照を返すことが考えられます。 定数オブジェクト（リテラル）の参照 引数として渡された参照に依存する参照 それぞれ、参照先のオブジェクトのライフタイムが、どのように戻り値の参照に影響するかをコンパイラに伝えてやる必要があります。 定数オブジェクト（リテラル）の参照を返す場合 文字列リテラルや数値リテラルなど、プログラムの実行時間とライフタイムが等しいデータを参照として返す場合はシンプルです。 参照を表す \u0026amp; の代わりに、\u0026amp;'static を付けてやれば OK です。 アポストロフィー (') は、それが ライフタイム識別子 (lifetime specifier) であることを示しています。 /// 文字列リテラルの参照を返す関数 fn get_str_ref() -\u0026gt; \u0026amp;\u0026#39;static str { \u0026#34;Hello, world!\u0026#34; } /// 数値リテラルの参照を返す関数 fn get_f64_ref() -\u0026gt; \u0026amp;\u0026#39;static f64 { \u0026amp;1.234 } /// 定数（数値）の参照を返す関数 const NUM: i32 = 777; fn get_const_ref() -\u0026gt; \u0026amp;\u0026#39;static i32 { \u0026amp;NUM } /// 定数（配列）の参照を返す関数 const ARRAY: [i32; 3] = [1, 2, 3]; fn get_array_ref() -\u0026gt; \u0026amp;\u0026#39;static [i32; 3] { \u0026amp;ARRAY } // 使用例 let s = get_str_ref(); //=\u0026gt; \u0026amp;str (\u0026#34;Hello, world!\u0026#34;) let f = get_f64_ref(); //=\u0026gt; \u0026amp;f64 (1.234) let i = get_const_ref(); //=\u0026gt; \u0026amp;i32 (777) let a = get_array_ref(); //=\u0026gt; \u0026amp;[i32; 3] ([1, 2, 3]) println!(\u0026#34;{:?}, {:?}, {:?}, {:?}\u0026#34;, s, f, i, a); 上記の例では、説明のためにすべて参照で返していますが、単純な数値のスカラー値 (i32 や f64) であれば、参照ではなく値として返した方がシンプルです。 引数で渡された参照に依存する参照を返す場合 関数の引数として渡された参照のライフタイムに依存する参照を戻り値として返す場合、そのライフタイムの関係を意識する必要があります。 次のように、参照のパラメーターが 1 つだけの場合、Rust は戻り値の参照もそれと同じライフタイム内で有効である判断してくれるので、問題なくコンパイルできます。 /// 文字列スライスの最初の n 文字を返す fn first_n_chars(text: \u0026amp;str, n: usize) -\u0026gt; \u0026amp;str { \u0026amp;text[..n] } // 以下の参照 r は s のライフタイム内でのみ有効 let s = String::from(\u0026#34;ABCDEF\u0026#34;); let r = first_n_chars(s.as_str(), 3); println!(\u0026#34;{:?}\u0026#34;, r); //=\u0026gt; \u0026#34;ABC\u0026#34; ☝️ 一時インスタンスは渡せない 上記の first_n_chars 関数を次のように呼び出すと、コンパイルエラーになります。 let r = first_n_chars(String::from(\u0026#34;ABCDEF\u0026#34;).as_str(), 3); // エラー！ println!(\u0026#34;{:?}\u0026#34;, r); // ここに到達する時点ですでに r は無効 なぜなら、String インスタンス (\u0026quot;ABCDEF\u0026quot;) のライフタイムが first_n_chars を呼び出している行で終了してしまい、戻り値の参照もその行までしか有効でないからです。 String インスタンスは変数で保持するようにして、その変数が所属するブロックの末尾までライフタイムを伸ばしてやる必要があります。 関数の引数として参照が 2 つ以上渡される場合は、そのまま次のように書くとコンパイルエラーになってしまいます。 fn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { // エラー！ if x.len() \u0026gt; y.len() { x } else { y } } なぜなら、戻り値の参照の有効期間が、参照 x によって決まるものなのか、参照 y によって決まるものなのかを判断できないからです。 Rust コンパイラーは、「戻り値の参照の有効期間を関数のシグネチャから判断できること」を要求します。 上記コードをコンパイルできるようにするには、次のようなライフタイム識別子 'a を付加します。 ライフタイム識別子は、ジェネリクスの型パラメーター (\u0026lt;T\u0026gt;) と同様の形式で宣言しますが、名前をアポストロフィー (') で始めて、小文字を使うところが異なります。 通常は、'a や 'b のような短い名前を使います。 /// 渡された文字列のうち長い方を返す fn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a str, y: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { if x.len() \u0026gt; y.len() { x } else { y } } // 使用例 let s1 = \u0026#34;AAA\u0026#34;; let s2 = String::from(\u0026#34;BBBBB\u0026#34;); let s3 = longest(s1, \u0026amp;s2); //=\u0026gt; \u0026#34;BBBBB\u0026#34; この longest 関数のシグネチャは、「戻り値の参照は、参照 x と参照 y の両方が有効な期間だけ有効である」 ことをコンパイラーに伝えています。 言い換えると、「戻り値の参照は、x と y のライフタイムのうち、短い方の期間だけ有効である」ということです。 上記の使用例では、s1 と s2（の文字列スライス）を引数として渡していますが、戻り値の参照の有効期間は、実質 s2 のライフタイムによって決まります。 s1 の方は、静的な文字列リテラルへの参照であり、明らかに s2 よりもライフタイムが長い（というより死なない）からです。 構造体のフィールドとして参照を持つ 参照フィールドには必ずライフタイムが必要 構造体のフィールドとして参照を持つ場合、ライフタイム識別子の指定が必要です。 次の Excerpt 構造体は、外部テキストの部分テキスト（の参照）を保持する構造体です。 // 参照フィールドを持つ構造体 struct Excerpt\u0026lt;\u0026#39;a\u0026gt; { part: \u0026amp;\u0026#39;a str, } // 使用例 let text = String::from(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXY\u0026#34;); let excerpt = Excerpt { part: \u0026amp;text[..5] }; println!(\u0026#34;{:?}\u0026#34;, excerpt.part); //=\u0026gt; \u0026#34;ABCDE\u0026#34; このライフタイム指定 ('a) は、Excerpt のインスタンスは part フィールドのライフタイム内でのみ有効 であることを示しています。 外部のテキストの一部を参照するわけですから、この関係性はすんなり理解できると思います。 上記の使用例では、他の変数 (text) が所有している文字列の中の、先頭 5 文字の部分テキストを excerpt インスタンス内に保持しています。 excerpt インスタンスは、text 変数のライフタイム内でのみ有効です。 ちなみに、フィールド名を持たないタプル構造体の場合も同様です。 下記のタプル構造体は、最初のフィールドが参照になっているため、ライフタイム識別子が必要です。 // 参照フィールドを持つタプル構造体 struct Excerpt\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;\u0026#39;a str, i32, i32); let text = String::from(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXY\u0026#34;); let excerpt = Excerpt(\u0026amp;text[..5], 0, 4); println!(\u0026#34;{:?}\u0026#34;, excerpt.0); //=\u0026gt; \u0026#34;ABCDE\u0026#34; 構造体のメソッドを実装する場合 ライフタイム識別子を持つ構造体のメソッドを impl ブロックで実装する場合、その書き出しは次のようになります。 ライフタイム識別子まで含めて構造体の型なので、このように記述する必要があります。 impl\u0026lt;\u0026#39;a\u0026gt; Excerpt\u0026lt;\u0026#39;a\u0026gt; { // ... } インスタンスメソッドの戻り値が参照の場合、その参照はデフォルトで、自分自身のインスタンス (self) のライフタイム内で有効とみなされます。 以下の first_n_chars メソッドは、自身が保持する part フィールドの部分文字列の参照を返していますが、このようなメソッドを定義する場合、ライフタイムの指定は省略することができます。 struct Excerpt\u0026lt;\u0026#39;a\u0026gt; { part: \u0026amp;\u0026#39;a str, } impl\u0026lt;\u0026#39;a\u0026gt; Excerpt\u0026lt;\u0026#39;a\u0026gt; { // 戻り値の参照は、デフォルトで構造体インスタンスが生きている間だけ有効 fn first_n_chars(\u0026amp;self, n: usize) -\u0026gt; \u0026amp;str { \u0026amp;self.part[..n] } } // 使用例 let text = String::from(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXY\u0026#34;); let excerpt = Excerpt { part: \u0026amp;text[..5] }; println!(\u0026#34;{:?}\u0026#34;, excerpt.first_n_chars(3)); //=\u0026gt; \u0026#34;ABC\u0026#34; 大体はこのパターンになるので、ほとんどのケースでは、構造体のインスタンスメソッドが参照を返すときにライフタイムの指定は必要ありません。 もちろん、構造体インスタンス自身のライフタイムと関係ない参照を返す場合は、次のようにライフタイムの指定が必要になります。 struct Switch { state: bool, } impl Switch { fn a_or_b\u0026lt;\u0026#39;a\u0026gt;(\u0026amp;self, a: \u0026amp;\u0026#39;a str, b: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { if self.state { a } else { b } } }"},{url:"/p/23fd7nv/",title:"Rust で数値を特定の範囲に収まるように修正する (clamp, min, max)",date:"2023-07-10T00:00:00Z",body:"Rust で数値を特定の範囲に収まるように修正する (clamp, min, max) clamp メソッド Rust である数値を指定した範囲に収まるように修正するには、clamp メソッドを使用します。 次の例では、いろいろな数値を「0 以上 5 以下」の範囲に収まるように修正しています。 println!(\u0026#34;{}\u0026#34;, (-3).clamp(0, 5)); //=\u0026gt; 0 println!(\u0026#34;{}\u0026#34;, 0.clamp(0, 5)); //=\u0026gt; 0 println!(\u0026#34;{}\u0026#34;, 2.clamp(0, 5)); //=\u0026gt; 2 println!(\u0026#34;{}\u0026#34;, 7.clamp(0, 5)); //=\u0026gt; 5 min / max メソッド clamp メソッドは、数値を指定した最小値と最大値の範囲に収まるようにするメソッドでしたが、最小値と最大値のいずれかを指定すればよい場合は、max や min メソッドを使用します。 // 0 以上になるように修正する println!(\u0026#34;{}\u0026#34;, (-5).max(0)); //=\u0026gt; 0 println!(\u0026#34;{}\u0026#34;, 0.max(0)); //=\u0026gt; 0 println!(\u0026#34;{}\u0026#34;, 10.max(0)); //=\u0026gt; 10 // 100 以下になるように修正する println!(\u0026#34;{}\u0026#34;, (-5).min(100)); //=\u0026gt; -5 println!(\u0026#34;{}\u0026#34;, (27).min(100)); //=\u0026gt; 27 println!(\u0026#34;{}\u0026#34;, (999).min(100)); //=\u0026gt; 100"},{url:"/p/be8u7sg/",title:"Rust でジェネリクス構造体・関数を定義する（任意の型を扱えるようにする）",date:"2023-07-09T00:00:00Z",body:"Rust でジェネリクス構造体・関数を定義する（任意の型を扱えるようにする） ジェネリクスの基本 Rust の ジェネリクス (generics) の仕組みを使うと、任意の型を扱う処理を 1 つのコードで記述することができます。 まずは、ジェネリクスを使っていないコードから見てみます。 次のサンプルコードでは、整数型 (i32) の座標値を表現する構造体 Point と、その浮動小数点数型 (f64) バージョンである PointF を定義しています。 ジェネリクスを使わない Point 構造体 /// 整数型の座表値 struct Point { x: i32, y: i32, } /// 浮動小数点数型の座標値 struct PointF { x: f64, y: f64, } // 使用例 fn main() { let p1 = Point { x: 0, y: 5 }; println!(\u0026#34;{}, {}\u0026#34;, p1.x, p1.y); let p2 = PointF { x: -1.2, y: 7.4 }; println!(\u0026#34;{}, {}\u0026#34;, p2.x, p2.y); } Rust では、数値だけでも様々なプリミティブ型 (u8, i128, f64, usize, \u0026hellip;) で区別して扱うので、このように扱う数値の種類によってコードを書き分けなければいけません。 一方の型（上記の例では PointF 構造体）だけで実装しようとすると、as を使ったキャストがいたるところに出てくることになります。 そこでジェネリクスの出番です。 ジェネリクスの仕組みでは、構造体や関数の定義時に 型パラメーター を宣言することで、（コンパイル時に決定される）任意の型を扱えるようになります。 次のコードは、ジェネリクス版の Point 構造体です。 汎用的な型パラメーターの名前としては、T を使うのが慣例となっています。 ジェネリクスを使う場合 struct Point\u0026lt;T\u0026gt; { x: T, y: T, } fn main() { let p1 = Point { x: 0, y: 5 }; // Point\u0026lt;i32\u0026gt; とみなされる println!(\u0026#34;{}, {}\u0026#34;, p1.x, p1.y); let p2 = Point { x: -1.2, y: 7.4 }; // Point\u0026lt;f64\u0026gt; とみなされる println!(\u0026#34;{}, {}\u0026#34;, p2.x, p2.y); } これで、様々な数値型の座標値を、Point というジェネリック構造体 1 つで表現できるようになりました！ 複数の型パラメーターを扱う 型パラメーターは任意の数だけカンマで並べて宣言できます。 次の Pair 構造体は、任意の型のフィールド first と second を持つ構造体です。 first と second はそれぞれ別の型の値を保持することができます。 ジェネリックな Pair 構造体 struct Pair\u0026lt;TFirst, TSecond\u0026gt; { first: TFirst, second: TSecond, } fn main() { let pair1 = Pair { first: \u0026#34;key1\u0026#34;, second: \u0026#34;val1\u0026#34; }; // Pair\u0026lt;\u0026amp;str, \u0026amp;str\u0026gt; とみなされる println!(\u0026#34;{:?}, {:?}\u0026#34;, pair1.first, pair1.second); //=\u0026gt; \u0026#34;key1\u0026#34;, \u0026#34;val1\u0026#34; let pair2 = Pair { first: [1, 2], second: 100 }; // Pair\u0026lt;[i32; 2], i32\u0026gt; とみなされる println!(\u0026#34;{:?}, {:?}\u0026#34;, pair2.first, pair2.second); //=\u0026gt; [1, 2], 100 } ジェネリクス関数 関数でも型パラメーターを使うことができます。 次の swap 関数は、2 つの値を受け取り、その順番を入れ替えたタプルを返します。 簡単なジェネリクス関数の例 /// 2 つの要素の順番を入れ替えたタプルを返す fn swap\u0026lt;T1, T2\u0026gt;(a: T1, b: T2) -\u0026gt; (T2, T1) { (b, a) } fn main() { let tuple = swap(100, \u0026#34;hello\u0026#34;); println!(\u0026#34;{:?}, {:?}\u0026#34;, tuple.0, tuple.1); //=\u0026gt; \u0026#34;hello\u0026#34;, 100 // Destructuring の構文でタプル要素を分解して受け取ることもできる let (x, y) = swap(100, \u0026#34;hello\u0026#34;); println!(\u0026#34;{:?}, {:?}\u0026#34;, x, y); //=\u0026gt; \u0026#34;hello\u0026#34;, 100 } ちなみに、Rust でプリミティブ型の値をスワップしたいときは、次のようにタプルの destructuring 構文を使うのが簡単です。 let mut a = 1; let mut b = 2; (b, a) = (a, b); // 値のスワップ"},{url:"/p/e3o2ra3/",title:"Rust で複数の数値の中から最小値・最大値を見つける (min, max)",date:"2023-07-09T00:00:00Z",body:"Rust で複数の数値の中から最小値・最大値を見つける (min, max) 2 つの数値から大きい方を取り出す Rust の標準ライブラリが提供しているジェネリクス関数 std::cmp::max を使うと、2 つの数値のうち大きい方の値を取り出すことができます。 let larger = std::cmp::max(2, 5); //=\u0026gt; 5 // 呼び出し時のコードを短くしたいときは次のように use 宣言します // use std::cmp::max; // let larger = max(2, 5); また、数値のプリミティブ型 (i32 や f64) は core::cmp::Ord トレイトを実装しているため、max メソッドでも上記と同様の処理を行えます。 let larger = 2.max(5); //=\u0026gt; 5 前者の関数型と比較して、後者のメソッド型は直感的に理解しにくいかもしれませんが、場面によっては便利です。 例えば、num.max(0) という表現は、num が負の値だったときに、0 になるよう修正する という処理になります。 参考: 数値を特定の範囲に収まるように修正する (clamp, min, max) 複数の数値の中から最大値を取り出す 数値型のベクターや配列から、最大の値を持つ値を取り出すには次のようにします。 Vec\u0026lt;i32\u0026gt; から最大値を取り出す let nums: Vec\u0026lt;i32\u0026gt; = vec![3, 1, 5, 2, 4]; // let nums: [i32; 5] = [3, 1, 5, 2, 4]; if let Some(max) = nums.iter().max() { println!(\u0026#34;Max value: {}\u0026#34;, max); } else { println!(\u0026#34;nums is empty\u0026#34;); } 実行結果 Max value: 5 この場合、max メソッドの戻り値は Option 型 になっており、ベクターや配列が空の場合は None を返すことに注意してください。"},{url:"/p/nfxwcc2/",title:"Rust のパニック (panic) の扱いについて",date:"2023-07-06T00:00:00Z",body:"Rust のパニック (panic) の扱いについて パニックとは Rust のパニックはプログラムに不具合があるときに発生するもので、パニックが発生すると、通常はプログラムの動作を継続することができません。 パニックは発生しないようにコーディングすべきです。 パニックを発生させる処理の例: 数値のゼロ除算 配列の範囲外アクセス Option 変数の値が None なのに unwrap したとき Result 変数の値が Err なのに unwrap したとき panic! マクロを呼び出したとき panic! マクロで意図的にパニックを発生させることができますが、プロダクトコードでは呼び出さないようにします（println! と同様の引数を渡すことができます）。 パニック発生時には、unwind the stack（スタック巻き戻し） あるいは、abort the process（プロセス強制終了） のいずれかの処理が実行されます。 unwind the stack（スタック巻き戻し） パニック発生時のデフォルトの動作です。 スタック上のデータが逆順に解放されて、ファイルなどのリソースが閉じられます。 このとき、ユーザー定義の drop メソッドも呼び出されます。 そして、最後に当該スレッドが終了します。 終了するのがメインスレッドであれば、プロセスが終了することになります。 このように、パニックはカレントスレッドに対して発生するものであり、本質的にはプロセス全体を止めるものではないことに注意してください。 abort the process（プロセス強制終了） パニック発生後の drop 中に別のパニックが発生すると、Rust はスタックの巻き戻し処理 (unwind the stack) をあきらめて、プロセスを強制終了します。 コンパイル時に -C panic=abort オプションを指定すると、最初のパニック発生時に、ただちにプロセスが終了するようになります。 エラーを表現する場合は Result 型を使うべし プログラムの実行中には様々なエラーが発生する可能性があります。 Rust で何らかの処理が成功、あるいは失敗（エラー）したことを表現するには、Result 型を使用します。 参考: Result 型の基本 ─ 成功と失敗を表現する型 例えば、ユーザーが指定したファイルを開こうとした際に、ファイルが存在しない場合、エラーとして扱われますが、これはプログラムの不具合ではないため、パニックを引き起こすのは不適切です。 このような一般的なユースケースで発生するエラーを処理する際には、Result 型の Err バリアントを使用してエラーを表現します。 Result 型を使用することで、エラーを適切にハンドルし、処理を続行することが可能です。"},{url:"/p/xqkgvb6/",title:"Python の dataclass デコレーターで簡単にデータクラスを定義する",date:"2023-06-20T00:00:00Z",body:"Python の dataclass デコレーターで簡単にデータクラスを定義する dataclass デコレーターによるデータクラス定義の基本 Python の標準ライブラリが提供している dataclasses モジュールの dataclass デコレーターを使うと、少ないコードでデータクラス（データを扱うクラス）を定義することができます。 下記の NamedCounter クラスは 2 つのインスタンス変数（name と counter）を持つクラスの実装例ですが、通常はこのようにコンストラクタ（__init__ メソッド）の中でインスタンス変数を初期化すると思います。 通常のクラス定義方法 class NamedCounter: def __init__(self, name): self.name = name self.count = 0 def increment(self): self.count += 1 def __str__(self): return f\u0026#34;{self.name}: {self.count}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: counter = NamedCounter(\u0026#34;hello\u0026#34;) print(counter) # hello: 0 counter.increment() print(counter) # hello: 1 これくらいならよいのですが、インスタンス変数（フィールド）が増えてくると、コンストラクタの記述が面倒になってきます。 クラス定義時に dataclass デコレーターを付けると、このような __init__ の定型処理を自動生成してくれます。 次の例では、dataclass デコレーターを使って、2 つのインスタンス変数 (name, count) を持つクラスを定義しています。 name と count はクラス変数（クラス属性）と同様の記法で定義していますが、dataclass デコレーターを付けた場合はインスタンス変数の定義とみなされることに注意してください。 つまり、name と count の値は、NamedCounter のインスタンスごとに異なる値を保持できます。 dataclass デコレーターを使ったクラス定義 from dataclasses import dataclass @dataclass class NamedCounter: name: str count: int = 0 def increment(self): self.count += 1 if __name__ == \u0026#34;__main__\u0026#34;: counter = NamedCounter(\u0026#34;hello\u0026#34;) print(counter) # NamedCounter(name=\u0026#39;hello\u0026#39;, count=0) counter.increment() print(counter) # NamedCounter(name=\u0026#39;hello\u0026#39;, count=1) 内部的には、次のような __init__ メソッドや __repr__ メソッドが生成されています。 各変数の出力順は、フィールド定義の順番に従います。 def __init__(self, name: str, count: int = 0): self.name = name self.count = count def __repr__(self) -\u0026gt; str: return f\u0026#34;NamedCounter(name=\u0026#39;{self.name}\u0026#39;, count={self.count})\u0026#34; クラス内に明示的に __init__ メソッドや __repr__ メソッドが定義されている場合は、そちらの実装が優先的に使われます。 比較可能なデータクラスを定義する dataclass デコレーターは、同値比較用の __eq__ メソッドもデフォルトで生成してくれます。 つまり、次のように == 演算子や != 演算子による比較が可能になります。 from dataclasses import dataclass @dataclass class Data: name: str count: int if __name__ == \u0026#34;__main__\u0026#34;: print(Data(\u0026#34;a\u0026#34;, 1) == Data(\u0026#34;a\u0026#34;, 1)) # True print(Data(\u0026#34;a\u0026#34;, 1) != Data(\u0026#34;a\u0026#34;, 1)) # False ただし、2 つのインスタンスを大小比較できるようにするには、dataclass デコレーターの order=True フラグを指定する必要があります。 from dataclasses import dataclass @dataclass(order=True) class Data: name: str count: int if __name__ == \u0026#34;__main__\u0026#34;: print(Data(\u0026#34;a\u0026#34;, 1) \u0026lt; Data(\u0026#34;a\u0026#34;, 1)) # False print(Data(\u0026#34;a\u0026#34;, 1) \u0026lt; Data(\u0026#34;b\u0026#34;, 1)) # True print(Data(\u0026#34;a\u0026#34;, 1) \u0026lt; Data(\u0026#34;a\u0026#34;, 2)) # True 不変なデータクラスを定義する (frozen=True) dataclass デコレーターに frozen=True フラグを付けると、そのクラスのインスタンスを不変 (immutable) にすることができます。 つまり、インスタンス生成後にフィールドへの代入ができなくなります。 from dataclasses import dataclass @dataclass(frozen=True) class Data: name: str count: int if __name__ == \u0026#34;__main__\u0026#34;: d = Data(name=\u0026#34;foo\u0026#34;, count=1) d.name = \u0026#34;bar\u0026#34; # dataclasses.FrozenInstanceError d.count = 2 # dataclasses.FrozenInstanceError データクラスのインスタンスを辞書（ディクショナリ）に変換する (asdict) データクラスのインスタンスを dataclasses.asdict 関数 に渡すと、簡単にディクショナリに変換することができます。 データクラスが入れ子になっている場合は、再帰的にディクショナリ化してくれます。 次の例では、Point のリストを保持する PointList のインスタンスをディクショナリに変換しています。 from dataclasses import asdict, dataclass @dataclass class Point: x: int y: int @dataclass class PointList: points: list[Point] if __name__ == \u0026#34;__main__\u0026#34;: points = PointList([Point(1, 2), Point(3, 4)]) d = asdict(points) print(d) # =\u0026gt; {\u0026#39;points\u0026#39;: [{\u0026#39;x\u0026#39;: 1, \u0026#39;y\u0026#39;: 2}, {\u0026#39;x\u0026#39;: 3, \u0026#39;y\u0026#39;: 4}]} print(d[\u0026#34;points\u0026#34;]) # =\u0026gt; [{\u0026#39;x\u0026#39;: 1, \u0026#39;y\u0026#39;: 2}, {\u0026#39;x\u0026#39;: 3, \u0026#39;y\u0026#39;: 4}] print(d[\u0026#34;points\u0026#34;][0]) # =\u0026gt; {\u0026#39;x\u0026#39;: 1, \u0026#39;y\u0026#39;: 2} print(d[\u0026#34;points\u0026#34;][0][\u0026#34;x\u0026#34;]) # =\u0026gt; 1 print(d[\u0026#34;points\u0026#34;][0][\u0026#34;y\u0026#34;]) # =\u0026gt; 2 他の方法として、Python 標準の vars 関数（= __dict__ 属性）でも同じようなディクショナリ変換はできますが、こちらは入れ子構造になったインスタンスを展開してくれません。 print(vars(points)) # =\u0026gt; {\u0026#39;points\u0026#39;: [Point(x=1, y=2), Point(x=3, y=4)]} print(points.__dict__) # =\u0026gt; {\u0026#39;points\u0026#39;: [Point(x=1, y=2), Point(x=3, y=4)]}"},{url:"/p/gn4cn3s/",title:"Python でハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (`hashlib`)",date:"2023-06-09T00:00:00Z",body:"Python でハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (`hashlib`) Python の hashlib 標準ライブラリを使用すると、いろいろなタイプのハッシュ値を求めることができます。 バイトデータのハッシュ値を求める あるバイトデータのハッシュ値を求めるには、hashlib.sha1 や hashlib.sha256 などのコンストラクタでハッシュオブジェクトを生成し、hexdigest メソッドで 16 進数表記のハッシュ値を取得します。 次の例では、MD5、SHA-1、SHA-256 アルゴリズムを使って、b\u0026quot;HelloWorld\u0026quot; というバイトデータのハッシュ値を計算しています。 バイトデータのハッシュ値を求める import hashlib print(hashlib.md5(b\u0026#34;HelloWorld\u0026#34;).hexdigest()) print(hashlib.sha1(b\u0026#34;HelloWorld\u0026#34;).hexdigest()) print(hashlib.sha256(b\u0026#34;HelloWorld\u0026#34;).hexdigest()) 実行結果 68e109f0f40ca72a15e05cc22786f8e6 db8ac1c259eb89d4a131b253bacfca5f319d54f2 872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4 ハッシュ計算に使用するバイトデータは、update メソッドで追加していくことができます。 hash = hashlib.sha1() hash.update(b\u0026#34;Hello\u0026#34;) hash.update(b\u0026#34;World\u0026#34;) print(hash.hexdigest()) # =\u0026gt; db8ac1c259eb89d4a131b253bacfca5f319d54f2 # 以下のようにバイトデータを結合してから update しても結果は同じ hash = hashlib.sha1() hash.update(b\u0026#34;Hello\u0026#34; + b\u0026#34;World\u0026#34;) print(hash.hexdigest()) # =\u0026gt; db8ac1c259eb89d4a131b253bacfca5f319d54f2 文字列のハッシュ値を求める 文字列のハッシュ値を求めるには、エンコーディング形式を指定して、どのようなバイトデータとして扱うかを明確にする必要があります。 次の例では、文字列の encode メソッドで UTF-8 形式のバイトデータを取得しています。 文字列のハッシュ値を求める import hashlib str = \u0026#34;HelloWorld\u0026#34; bytes = str.encode(encoding=\u0026#34;utf-8\u0026#34;) print(hashlib.md5(bytes).hexdigest()) print(hashlib.sha1(bytes).hexdigest()) print(hashlib.sha256(bytes).hexdigest()) 実行結果 68e109f0f40ca72a15e05cc22786f8e6 db8ac1c259eb89d4a131b253bacfca5f319d54f2 872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4 ファイルのハッシュ値を求める 以下の file_sha256 関数は、指定したファイルの内容からハッシュ値を求めています。 ハッシュ値の計算にはバイトデータが必要なので、ファイルオープン時にバイトモード (\u0026quot;b\u0026quot;) を指定するのがポイントです。 import hashlib def file_sha256(filename: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; ファイル内容の SHA-256 ハッシュ値を計算し、16 進数文字列として取得します。 \u0026#34;\u0026#34;\u0026#34; with open(filename, mode=\u0026#34;rb\u0026#34;) as f: binary = f.read() return hashlib.sha256(binary).hexdigest() # Python 3.11 以降では次のようにも記述できます # return hashlib.file_digest(f, \u0026#34;sha256\u0026#34;).hexdigest() print(file_sha256(\u0026#34;sample.py\u0026#34;)) 実行結果 d727c62744e193aa6a0d0728e2dc78c0221bd77da2599dc6f86d17a46aa0bea4 使用可能なアルゴリズムの一覧 alogrithms_guaranteed （必ず使えるアルゴリズム） すべてのプラットフォーム使用できることが保証されているアルゴリズムの一覧は、hashlib.algorithms_guaranteed で参照できます。 import hashlib for name in sorted(hashlib.algorithms_guaranteed): print(name) 実行結果（Python 3.10 の場合） blake2b blake2s md5 sha1 sha224 sha256 sha384 sha3_224 sha3_256 sha3_384 sha3_512 sha512 shake_128 shake_256 ここに列挙された名前を使って、hashlib.new(\u0026quot;sha256\u0026quot;) のようにハッシュオブジェクトを生成することができます。 ただし、hashlib.sha256() のような、専用のファクトリー関数が定義されている場合はそちらを使った方が効率的です。 algorithms_available （現在のシステムで使えるアルゴリズム） 現在のシステムで使用できることができるアルゴリズムの一覧は、hashlib.algorithms_available で参照できます。 前述の hashlib.algorithms_guaranteed に含まれているアルゴリズムは、この一覧にも必ず含まれています。 for name in sorted(hashlib.algorithms_available): print(name) 実行結果 blake2b blake2s md4 md5 md5-sha1 mdc2 ripemd160 sha1 sha224 sha256 sha384 sha3_224 sha3_256 sha3_384 sha3_512 sha512 sha512_224 sha512_256 shake_128 shake_256 sm3 whirlpool hashlib.algorithms_available にしか含まれていないアルゴリズムを抽出したい場合は、次のようにセット演算を行います（参考: set オブジェクトで集合演算を行う）。 import hashlib only_in_available = hashlib.algorithms_available - hashlib.algorithms_guaranteed for name in sorted(only_in_available): print(name) 実行結果 md4 md5-sha1 mdc2 ripemd160 sha512_224 sha512_256 sm3 whirlpool 関連リンク HMAC-SHA256 コードを生成する｜まくろぐ"},{url:"/p/o4a37zc/",title:"Python でパスを指定したディレクトリからの相対パスに変換する (os.path.relpath)",date:"2023-06-02T00:00:00Z",body:"Python でパスを指定したディレクトリからの相対パスに変換する (os.path.relpath) os.path.relpath の使い方 Python 標準の os.path.relpath 関数 を使うと、パスを表す文字列を、特定のディレクトリからの相対パスに変換することができます。 import os # 元が絶対パスの場合 print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/\u0026#34;)) # =\u0026gt; a/b/c print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a\u0026#34;)) # =\u0026gt; b/c print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/\u0026#34;)) # =\u0026gt; b/c print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/b\u0026#34;)) # =\u0026gt; c print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/b/\u0026#34;)) # =\u0026gt; c print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/b/c\u0026#34;)) # =\u0026gt; . print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/b/c/\u0026#34;)) # =\u0026gt; . print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/b/c/d\u0026#34;)) # =\u0026gt; .. print(os.path.relpath(\u0026#34;/a/b/c\u0026#34;, \u0026#34;/a/b/c/d/e\u0026#34;)) # =\u0026gt; ../.. # 元が相対パスの場合（基本的に同上） print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a\u0026#34;)) # =\u0026gt; b/c print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/\u0026#34;)) # =\u0026gt; b/c print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/b\u0026#34;)) # =\u0026gt; c print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/b/\u0026#34;)) # =\u0026gt; c print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/b/c\u0026#34;)) # =\u0026gt; . print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/b/c/\u0026#34;)) # =\u0026gt; . print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/b/c/d\u0026#34;)) # =\u0026gt; .. print(os.path.relpath(\u0026#34;a/b/c\u0026#34;, \u0026#34;a/b/c/d/e\u0026#34;)) # =\u0026gt; ../.. カレントディレクトリからの相対パス os.path.relpath 関数の第 2 引数 (start) を省略すると、カレントディレクトリからの相対パスを返します。 import os os.chdir(\u0026#34;C:/Users/maku\u0026#34;) # ホームディレクトリに移動しておく print(os.path.relpath(\u0026#34;C:/\u0026#34;)) # =\u0026gt; ..\\.. print(os.path.relpath(\u0026#34;C:/Users\u0026#34;)) # =\u0026gt; .. print(os.path.relpath(\u0026#34;C:/Users/\u0026#34;)) # =\u0026gt; .. print(os.path.relpath(\u0026#34;C:/Users/maku\u0026#34;)) # =\u0026gt; . print(os.path.relpath(\u0026#34;C:/Users/maku/a/b/c\u0026#34;)) # =\u0026gt; a\\b\\c 使用例 具体的な使用例としては、あるディレクトリ内のファイルを列挙するときに、そのディレクトリからの相対パスで出力するケースなどがあります。 os.walk でファイル列挙する場合 import os BASE_DIR = \u0026#34;my-dataset\u0026#34; for dirpath, dirs, files in os.walk(BASE_DIR): for name in files: # BASE_DIR ディレクトリからの相対パスを構築 path = os.path.relpath(os.path.join(dirpath, name), BASE_DIR) print(path) Path#glob によるファイル列挙 import os from pathlib import Path BASE_DIR = \u0026#34;my-dataset\u0026#34; for filename in Path(BASE_DIR).glob(\u0026#34;**/*.dat\u0026#34;): # BASE_DIR ディレクトリからの相対パスを構築 path = os.path.relpath(filename, BASE_DIR) print(path)"},{url:"/p/co7o5k2/",title:"Python でテンポラリファイル／ディレクトリを作成する (tempfile)",date:"2023-06-01T00:00:00Z",body:`Python でテンポラリファイル／ディレクトリを作成する (tempfile) テンポラリディレクトリを作成する 自動削除されるテンポラリディレクトリ (TemporaryDirectory) Python の tempfile モジュールが提供する TemporaryDirectory クラスを使用して、テンポラリディレクトリを作成することができます。 TemporaryDirectory オブジェクトを with 文に渡すと、as 節の変数として、作成されたテンポラリディレクトリのパスを取得できます。 テンポラリディレクトリの作成 import os import tempfile with tempfile.TemporaryDirectory() as dirname: print(dirname) # =\u0026gt; /tmp/tmp98olubfz print(os.path.isdir(dirname)) # =\u0026gt; True # with を抜けるとテンポラリディレクトリは既に削除されている print(os.path.isdir(dirname)) # =\u0026gt; False テンポラリディレクトリは、with ブロックの実行コンテキストを抜けるときに自動的に削除されることに注意してください（__exit__ メソッドの実装で cleanup メソッドが呼ばれており、自動的にディレクトリが削除される仕組みになっています）。 よって、Python プログラムの中で、明示的にテンポラリディレクトリを削除する必要はありません。 自動削除されないテンポラリディレクトリ (mkdtemp) 実行コンテキストを抜けても自動削除されないテンポラリディレクトリを作成したい場合は、tempfile.TemporaryDirectory クラスの代わりに、tempfile.mkdtemp 関数を使用します。 作成されたテンポラリディレクトリは、プログラムを終了してからユーザーが手動で削除しなければいけないので、分かりやすいディレクトリに作成しておいた方がよいでしょう。 次の例では、カレントディレクトリ (.) に、.tmp サフィックスの付いたテンポラリディレクトリを作成しています。 （自動削除されない）テンポラリディレクトリの作成 import tempfile dirname = tempfile.mkdtemp(dir=\u0026#34;.\u0026#34;, suffix=\u0026#34;.tmp\u0026#34;) print(dirname) # =\u0026gt; ./tmpu57g67kg.tmp この Python プログラムを実行終了した後にも、テンポラリディレクトリが残っていることを確認してください。 ちなみに、dir、prefix, suffix といったパラメーターは、tempfile.TemporaryDirectory クラスのコンストラクタにも指定できますが、あまり使用することはないでしょう（自動削除されるのでパスを知る必要がない）。 参考: Linuxコマンド: テンポラリディレクトリを作成する (mktemp) テンポラリファイルを作成する 自動削除されるテンポラリファイル (TemporaryFile) テンポラリファイルを作成するには、tempfile.TemporaryFile 関数を使用します。 この関数は、open 関数と同様にファイルオブジェクトを返します。 パラメーターにも open 関数と同様のものを指定できます。 次の例では、テキスト形式で読み書き可能なテンポラリファイルを作成しています。 同じファイルオブジェクトで書き込みと読み取りを行うため、mode パラメーターには \u0026quot;w+\u0026quot; を指定しています。 テンポラリファイルの作成 import tempfile with tempfile.TemporaryFile(mode=\u0026#34;w+\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;, newline=\u0026#34;\\n\u0026#34;) as fp: # テンポラリファイルへ書き込む fp.write(\u0026#34;Hello\\n\u0026#34;) fp.write(\u0026#34;World\\n\u0026#34;) # テンポラリファイルの内容を読み込む fp.seek(0) lines = fp.readlines() print(lines) # =\u0026gt; [\u0026#39;Hello\\n\u0026#39;, \u0026#39;World\\n\u0026#39;] TemporaryDirectory と同様に、TemporaryFile で作成したテンポラリファイルは、with 文の実行コンテキストを抜けるときに自動的に削除されることに注意してください。 パスを取得可能なテンポラリファイル (NamedTemporaryFile) テンポラリファイルの名前が必要な場合は、TemporaryFile の代わりに、NamedTemporaryFile を使用する必要があります。 こちらを使わないと、ファイルオブジェクトの name プロパティでファイル名を参照できません。 import tempfile def cat(filename: str) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;指定されたファイル名のファイルの内容を標準出力に出力する\u0026#34;\u0026#34;\u0026#34; with open(filename, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as fp: print(fp.read()) with tempfile.NamedTemporaryFile(mode=\u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;, newline=\u0026#34;\\n\u0026#34;) as fp: # テンポラリファイルへ書き込む fp.write(\u0026#34;Line 1\\n\u0026#34;) fp.write(\u0026#34;Line 2\\n\u0026#34;) fp.write(\u0026#34;Line 3\u0026#34;) fp.flush() # テンポラリファイルの名前を使って何らかの処理 cat(fp.name) 自動削除されないテンポラリファイル (mkstemp) 実行コンテキストを抜けても自動削除されないテンポラリファイルを作るには、tempfile.mkstemp 関数を使用します。 指定できるパラメーターは mkdtemp 関数によるディレクトリ作成とほぼ同様で、出力先のディレクトリ (dir) や、プレフィックス (prefix)、サフィックス (suffix) を指定できます。 mkstemp 関数は、戻り値としてテンポラリファイルのデスクリプター (int) とファイル名 (str) を返します。 （自動削除されない）テンポラリファイルの作成 - 方法 1 import tempfile # テンポラリファイルの生成 fd, filename = tempfile.mkstemp(dir=\u0026#34;.\u0026#34;, suffix=\u0026#34;.txt\u0026#34;) print(fd) # =\u0026gt; 3 print(filename) # =\u0026gt; /Users/maku/myapp/tmplal4nz7v.txt # 書き込み with open(filename, mode=\u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;, newline=\u0026#34;\\n\u0026#34;) as f: f.write(\u0026#34;Hello\\n\u0026#34;) f.write(\u0026#34;World\\n\u0026#34;) # 読み込み with open(filename, mode=\u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: print(f.readlines()) # =\u0026gt; [\u0026#39;Hello\\n\u0026#39;, \u0026#39;World\\n\u0026#39;] # 明示的に削除するなら # os.remove(filename) NamedTemporaryFile 関数で delete=False プロパティを指定することでも、自動削除されないテンポラリファイルを作成できるようです。 （自動削除されない）テンポラリファイルの作成 - 方法 2 import tempfile # テンポラリファイルの生成と書き込み with tempfile.NamedTemporaryFile( mode=\u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;, newline=\u0026#34;\\n\u0026#34;, dir=\u0026#34;.\u0026#34;, suffix=\u0026#34;.txt\u0026#34;, delete=False ) as fp: filename = fp.name fp.write(\u0026#34;Hello\\n\u0026#34;) fp.write(\u0026#34;World\\n\u0026#34;) # 自動削除しないように設定 (delete=False) したので、テンポラリファイルは残っている with open(filename, mode=\u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: print(f.readlines()) # =\u0026gt; [\u0026#39;Hello\\n\u0026#39;, \u0026#39;World\\n\u0026#39;]`},{url:"/p/o6q8p6m/",title:"Python の argparse モジュールでコマンライン引数を扱う",date:"2023-06-01T00:00:00Z",body:"Python の argparse モジュールでコマンライン引数を扱う Python が標準ライブラリとして提供している argparse モジュール を使用すると、複雑なコマンドライン引数を扱うスクリプトをシンプルに実装することができます。 単純に sys.argv を使ってコマンドライン引数を扱う方法と比べ、argparse を使うと次のような利点があります。 Linux スタイルの短いオプション (-o) や長いオプション (--output) を簡単に定義できます ユーザーが入力した値を直感的なプロパティとして参照できます（例: args.output）。 ヘルプメッセージを自動で構築してくれます（-h (--help) オプションはデフォルトで生成してくれます） 各オプションの型を定義できます（数値型オプションに文字列が指定されたときに自動でエラーにしてくれます） サブコマンドを簡単に実装できます（例: sample.py \u0026lt;サブコマンド\u0026gt; \u0026lt;引数1\u0026gt; \u0026lt;引数2\u0026gt;） ArgumentParser の基本 argparse モジュールは、次のような流れで使用します。 ArgumentParser クラスのインスタンスを生成する add_argument メソッドでコマンドライン引数の定義を追加していく parse_args メソッドでパースして Namespace オブジェクトを取得する Namespace オジェクトのプロパティでユーザー入力を参照する 次のスクリプトでは、-i (--input) オプションと、-o (--output) オプションを定義しています。 main.py import argparse # コマンドライン引数の仕様を定義してユーザー入力をパースする parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;-i\u0026#34;, \u0026#34;--input\u0026#34;, help=\u0026#34;input file\u0026#34;) parser.add_argument(\u0026#34;-o\u0026#34;, \u0026#34;--output\u0026#34;, help=\u0026#34;output file\u0026#34;, default=\u0026#34;out.txt\u0026#34;) args = parser.parse_args() # =\u0026gt; argparse.Namespace # ユーザーが入力した値を表示する print(f\u0026#34;Input file: {args.input}\u0026#34;) print(f\u0026#34;Output file: {args.output}\u0026#34;) 実行例 $ python main.py Input file: None Output file: out.txt $ python main.py -i input.txt -o output.txt Input file: input.txt Output file: output.txt ヘルプ表示用のオプション -h (--help) は自動で生成してくれます。 自動生成されたヘルプ $ python main.py -h usage: main.py [-h] [-i INPUT] [-o OUTPUT] options: -h, --help show this help message and exit -i INPUT, --input INPUT input file -o OUTPUT, --output OUTPUT output file ユーザーが間違った使い方をしたときは、Usage を表示して終了してくれます。 $ python main.py hoge usage: main.py [-h] [-i INPUT] [-o OUTPUT] main.py: error: unrecognized arguments: hoge $ python main.py -i usage: main.py [-h] [-i INPUT] [-o OUTPUT] main.py: error: argument -i/--input: expected one argument いろいろなコマンドライン引数を定義する ArgumentParser#add_argument メソッドの呼び出し方によって、様々な仕様のコマンドライン引数を定義することができます。 位置引数 (positional argument) parser.add_argument(\u0026#34;name\u0026#34;, type=str, help=\u0026#34;your name\u0026#34;) parser.add_argument(\u0026#34;age\u0026#34;, type=int, help=\u0026#34;your age\u0026#34;) # ... print(f\u0026#34;name={args.name}, age={args.age}\u0026#34;) $ python main.py Maku 14 name=Maku, age=14 順序通り指定しなければいけない単純なコマンドライン引数です。 引数を - や -- で始まらない名前にすると、この位置引数 (positional argument) として扱われます。 位置引数はデフォルトでユーザーによる入力が必須となりますが、nargs=\u0026quot;?\u0026quot; 指定によりオプショナル扱いとなり、さらに default=... 指定によりデフォルト値を設定できます。 デフォルト値は、help パラメーターの中で、%(default)s で参照できます。 parser.add_argument( \u0026#34;output\u0026#34;, nargs=\u0026#34;?\u0026#34;, default=\u0026#34;out.txt\u0026#34;, help=\u0026#34;output file (default: %(default)s)\u0026#34; ) 必須の引数 (required=True) parser.add_argument(\u0026#34;-i\u0026#34;, \u0026#34;--input\u0026#34;, help=\u0026#34;input file\u0026#34;, required=True) # ... print(f\u0026#34;Input file: {args.input}\u0026#34;) - や -- で始まる名前の引数は、デフォルトで省略可能なオプショナル扱いとなりますが、required=True フラグをつけると、ユーザーによる指定が必須になります。 上記の例であれば、ユーザーは -i (--input) オプションを必ず指定する必要があり、args.input には必ず値が入っていることが保証されます。 この required よりも、次の default を使えないかを先に検討してください。 デフォルト値 (default=\u0026hellip;) parser.add_argument( \u0026#34;-c\u0026#34;, \u0026#34;--config\u0026#34;, default=\u0026#34;app.toml\u0026#34;, help=\u0026#34;config file (default: %(default)s)\u0026#34; ) # ... print(f\u0026#34;Config file: {args.config}\u0026#34;) default=... パラメーターを指定すると、ユーザーがそのオプションを指定しなかったときのデフォルト値を設定できます。 上記の例であれば、ユーザーが -c (--config) オプションを省略した場合は app.toml を指定したものとみなされ、args.config には必ず値が入っていることが保証されます。 デフォルト値は、help パラメーターの中で、%(default)s で参照できます。 ユーザーの引数指定を必須にする required=True よりも、まずはこの default パラメーターを使うことを検討すべきです。 on/off フラグ (action=\u0026ldquo;store_true\u0026rdquo;) parser.add_argument( \u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;increase output verbosity\u0026#34; ) # ... print(args.verbose) $ python main.py False $ python main.py --verbose True action=\u0026quot;store_true\u0026quot; の指定により、True あるいは False の 2 値を表現するオプションを定義できます。 ユーザーが -v (--verbose) オプションを指定したときに、args.verbose の値が True になります。 action=\u0026quot;store_true\u0026quot; の代わりに action=\u0026quot;store_false\u0026quot; とすると、True と False の扱いが反転します（-v オプションを指定したときに args.verbose が False になります）。 選択肢 (choices=[\u0026hellip;]) parser.add_argument( \u0026#34;-t\u0026#34;, \u0026#34;--type\u0026#34;, choices=[\u0026#34;json\u0026#34;, \u0026#34;yaml\u0026#34;, \u0026#34;toml\u0026#34;], default=\u0026#34;json\u0026#34;, help=\u0026#34;file format (default %(default)s)\u0026#34; ) # ... print(args.type) $ python main.py json $ python main.py -t yaml yaml $ python main.py -t hoge usage: main.py [-h] [-t {json,yaml,toml}] main.py: error: argument -t/--type: invalid choice: \u0026#39;hoge\u0026#39; (choose from \u0026#39;json\u0026#39;, \u0026#39;yaml\u0026#39;, \u0026#39;toml\u0026#39;) choices=[...] で選択肢を列挙することによって、ユーザーは制約された選択肢の中からのみ値を指定することができるようになります。 ユーザーが何も入力しなかったときの値は None となりますが、default=\u0026quot;json\u0026quot; のようにデフォルト値を設定しておくこともできます。 上記の例では文字列の選択肢を定義していますが、数値の選択肢も同様に定義できます。 parser.add_argument(\u0026#34;--level\u0026#34;, type=int, choices=[1, 2, 3, 4, 5]) parser.add_argument(\u0026#34;--level\u0026#34;, type=int, choices=range(1, 6)) # 同上 同一オプションが何回指定されたかを取得する (action=\u0026ldquo;count\u0026rdquo;) parser.add_argument(\u0026#34;-v\u0026#34;, action=\u0026#34;count\u0026#34;, default=0, help=\u0026#34;increase output verbosity\u0026#34;) # ... print(args.v) $ python main.py 0 $ python main.py -v 1 $ python main.py -vvv 3 action=\u0026quot;count\u0026quot; とすると、そのオプション自体がユーザーによって何度指定されたかをカウントしてくれます。 冗長レベルを制御するための -v、-vv、-vvv といったオプションはたまに見かけますね。 排他的にしか指定できないオプション (add_mutually_exclusive_group) group = parser.add_mutually_exclusive_group() group.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;) group.add_argument(\u0026#34;-q\u0026#34;, \u0026#34;--quiet\u0026#34;, action=\u0026#34;store_true\u0026#34;) % python main.py -v -q usage: main.py [-h] [-v | -q] main.py: error: argument -q/--quiet: not allowed with argument -v/--verbose 同時に指定すると意味的に矛盾が生じるようなオプション項目は、排他グループを作成してそこに登録しておきます。 上記の例では、-v (--verbose) オプションと -q (--quiet) オプションは同じ排他グループに属しているため、どちらかしか指定できません。 ヘルプ表示のラベル名を変更する (metavar) parser.add_argument(\u0026#34;input\u0026#34;, metavar=\u0026#34;INPUT_FILE\u0026#34;, help=\u0026#34;input file path\u0026#34;) parser.add_argument(\u0026#34;output\u0026#34;, metavar=\u0026#34;OUTPUT_FILE\u0026#34;, help=\u0026#34;output file path\u0026#34;) $ python main.py -h usage: main.py [-h] INPUT_FILE OUTPUT_FILE ... matavar パラメーターで、ヘルプに表示されるプレースホルダー名を変更できます。 参照時のプロパティ名を変更する (dest) parser.add_argument( \u0026#34;-v\u0026#34;, dest=\u0026#34;verbose\u0026#34;, action=\u0026#34;count\u0026#34;, default=0, help=\u0026#34;increase output verbosity\u0026#34; ) # ... print(args.verbose) 通常、定義したオプション名はそのまま Namespace オブジェクトのプロパティ名となりますが、dest パラメーターでプロパティ名を変更できます。 上記の例では、-v オプションを定義しているので、通常は args.v で参照するところを、args.verbose で参照できるようにしています。 アプリケーションの説明文 ArgumentParser コンストラクタのパラメーターで、ヘルプメッセージで表示する詳細説明を追加できます。 main.py import argparse parser = argparse.ArgumentParser( description=\u0026#34;ヘルプの最初に表示されるプログラムの説明\u0026#34;, epilog=\u0026#34;ヘルプの最後に表示されるプログラムの説明\u0026#34;, ) args = parser.parse_args() 実行例 $ python main.py --help usage: main.py [-h] ヘルプの最初に表示されるプログラムの説明 options: -h, --help show this help message and exit ヘルプの最後に表示されるプログラムの説明 長いメッセージは、ターミナルの横幅に応じて適切な位置で改行して表示してくれるので、Python コード上ではどこで改行するかを気にせずに記述できます（ただし、単語の区切りがない日本語はうまくいきません）。 parser = argparse.ArgumentParser( description=\u0026#34;\u0026#34;\u0026#34; Long long long long long long long long long long long long long long long long long long long description \u0026#34;\u0026#34;\u0026#34; ) 整形済みのテキストとして、Python コード上での改行位置を保って出力するには、formatter_class として RawDescriptionHelpFormatter を指定します。 parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=textwrap.dedent( \u0026#34;\u0026#34;\u0026#34; Please do not mess up this text! -------------------------------- I have indented it exactly the way I want it \u0026#34;\u0026#34;\u0026#34; ), ) （おまけ）コマンドライン引数を扱うモジュールを切り出す 多くの機能を含む Python スクリプトは、コマンドライン引数の定義も複雑になりがちです。 argparse まわりの処理をモジュールと切り出しておくと、メインスクリプトのコードをシンプルに保つことができます。 args.py（コマンドライン引数を処理するモジュール） import argparse def get_args() -\u0026gt; argparse.Namespace: \u0026#34;\u0026#34;\u0026#34;コマンドライン引数の内容をパースして取得します。\u0026#34;\u0026#34;\u0026#34; # スクリプトの説明を定義 parser = argparse.ArgumentParser( description=\u0026#34;このスクリプトの説明をここに書く\u0026#34;, epilog=\u0026#34;このスクリプトの補足説明をここに書く\u0026#34;, ) # スクリプトの引数を定義 parser.add_argument(\u0026#34;input\u0026#34;, help=\u0026#34;input file\u0026#34;) parser.add_argument(\u0026#34;-o\u0026#34;, \u0026#34;--output\u0026#34;, help=\u0026#34;output file\u0026#34;, default=\u0026#34;out.txt\u0026#34;) return parser.parse_args() 上記のように切り出したモジュールは、メインスクリプトから次のように使用できます。 main.py import args if __name__ == \u0026#34;__main__\u0026#34;: args = args.get_args() print(args.input) print(args.output) すっきり ٩(๑❛ᴗ❛๑)۶"},{url:"/p/o4m4jyg/",title:"Python の import 時のモジュールの検索パスを調べる (sys.path)",date:"2023-05-29T00:00:00Z",body:"Python の import 時のモジュールの検索パスを調べる (sys.path) モジュールの検索パスのリストは sys.path Python でモジュールをインポートするには、import モジュール名 のように記述しますが、このときにどのディレクトリのモジュールが検索されるかは、sys.path 変数の値を見ると分かります。 sys.path は検索パスを示す文字列のリスト (list[str]) です。 モジュールの検索パスを列挙する import sys import pprint pprint.pprint(sys.path) 実行結果 [\u0026#39;/Users/maku/myapp\u0026#39;, \u0026#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python310.zip\u0026#39;, \u0026#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10\u0026#39;, \u0026#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload\u0026#39;, \u0026#39;/Users/maku/myapp/.venv/lib/python3.10/site-packages\u0026#39;] sys.path にはどのような検索パスが含まれているか？ sys.path 変数には、自動的に次のようなパスが登録されます。 起動したスクリプトと同じディレクトリ（ただし、python をインタラクティブモードで起動したときは、カレントディレクトリを示す空文字 '' になります） 環境変数 PYTHONPATH に指定したディレクトリ Python インストーラに応じたデフォルトディレクトリ（標準ライブラリのパスなど） 注目すべきは、sys.path の先頭に追加されるパスで、これは起動されたスクリプトが格納されているディレクトリのパスになっています。 例えば、python ~/myapp/main.py と実行したときは、自動的に ~/myapp が検索パスに追加されるため、~/myapp 以下に配置したモジュール (*.py) をインポートできるようになっています。 main.py import mymod # ~/myapp/mymod.py が検索される モジュールの検索パスを追加する PYTHONPATH 環境変数を設定する方法 PYTHONPATH 環境変数に設定したディレクトリパスは、自動的に sys.path に反映されてモジュールの検索パスとして使われます。 Linux や macOS の場合 $ export PYTHONPATH=/path/to/lib1:/path/to/lib2:$PYTHONPATH パスの区切り文字は Linux や macOS ではコロン (:) ですが、Windows の場合はセミコロン (;) になることに注意してください（PATH 環境変数の指定方法と同じです）。 Windows の場合 C:\\\u0026gt; set PYTHONPATH=C:\\path\\to\\lib1;C:\\path\\to\\lib2;%PYTHONPATH% sys.path 変数を変更する方法 sys.path 変数の内容はスクリプト内で変更可能なので、このリストに任意のパスを追加することで、モジュールの検索パスを動的に拡張できます。 sys.path.append(\u0026#34;/path/to/lib1\u0026#34;) sys.path.append(\u0026#34;/path/to/lib2\u0026#34;) モジュールやパッケージを ZIP 化したアーカイブのパスを指定することもできます。 sys.path.append(\u0026#34;./mypkg.zip\u0026#34;)"},{url:"/p/uivwecs/",title:"HTML ファイルや Markdown ファイルをプレーンテキストに変換する (unstructured)",date:"2023-05-26T00:00:00Z",body:"HTML ファイルや Markdown ファイルをプレーンテキストに変換する (unstructured) unstructured ライブラリとは Python の unstructured ライブラリは、様々な形式のデータを機械学習システムに投入する前の変換処理などを行ってくれるライブラリです。 例えば、非構造化データ（HTML や Markdown）には、機械学習には必要のないタグが含まれていたりしますが、unstructured を使ってテキストだけを取り出すことができます。 Unstructured-IO/unstructured: Open source libraries and APIs to build custom preprocessing pipelines for labeling, training, or production machine learning pipelines. 現在、ChatGPT などの大規模言語モデル (LLM) を利用したチャットシステムが注目を浴びていますが、社内ドキュメントなどの情報と統合するためには、ユーザー入力から類似ドキュメントを検索する仕組みが必要になります。 このために使用されるのが、テキスト間の類似度に基づいた検索システムであるベクトル検索 DB などです。 そこに登録するドキュメントのベクトルデータ（Embeddings）は、できるだけクリーンなテキストから生成することが望ましいのですが、unstructured ライブラリを使えば、様々な形式のデータからそういったテキストを作成できます。 unstructured ライブラリのインストール unstructured の Installation マニュアル に従って、必要なライブラリをインストールします。 unstructured ライブラリのインストール $ pip install unstructured 後述のプログラムを実行したときに、tabulate が足りないと言われたので入れました。 このあたりは試行錯誤です。 $ pip install tabulate HTML ファイルをプレーンテキストに変換してみる サンプルの入力ファイルとして、次のような HTML ファイルを用意します。 html や body タグを省略していますが、これも正しい HTML5 文書です。 input.html（入力ファイル） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Hello HTML!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;This is \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt; text.\u0026lt;/p\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;Ordered list item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Ordered list item 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; Ordered list item 3 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Unordered list item 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Unordered list item 2\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; このファイルを、unstructured ライブラリの partition 関数に渡すと、Element オブジェクトのリストに変換して返してくれます。 Element オブジェクトは、構造的なまとまりごとのテキストを保持しています。 例えば、1 つの段落内のテキストです。 main.py from unstructured.partition.auto import partition elems = partition(filename=\u0026#34;input.html\u0026#34;) #-\u0026gt; List[Element] text = \u0026#34;\\n\u0026#34;.join([str(e) for e in elems]) print(text) このプログラムを実行すると、うまくテキスト部分だけを抽出できていることが分かります。 出力結果 Hello HTML! This is bold text. Ordered list item 1 Ordered list item 2 Ordered list item 3 Unordered list item 1 Unordered list item 2 Markdown ファイルをプレーンテキストに変換してみる Markdown 形式のファイルも、HTML ファイルと同様に partition 関数で処理できます。 input.md（入力ファイル） --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2023-05-26\u0026#34; --- セクション 1 ---- 文章内には __強調されたテキスト__ も含まれています。 次のようなリストも含まれています。 - 項目 1 - 項目 1-1 - 項目 1-2 - 項目 2 - 項目 3 表も含まれていることがあるよ。 | カラム1 | カラム2 | カラム3 | | ---- | ---- | ---- | | A-1 | A-2 | A-3 | | B-1 | B-2 | B-3 | 先ほどのプログラムの入力ファイル名を input.md に変えるだけで OK です。 main.py from unstructured.partition.auto import partition elems = partition(filename=\u0026#34;input.md\u0026#34;) #-\u0026gt; List[Element] text = \u0026#34;\\n\u0026#34;.join([str(e) for e in elems]) print(text) 出力結果 title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2023-05-26\u0026#34; セクション 1 文章内には 強調されたテキスト も含まれています。 次のようなリストも含まれています。 項目 1 項目 1-1 項目 1-2 項目 2 項目 3 表も含まれていることがあるよ。 | カラム1 | カラム2 | カラム3 | | ---- | ---- | ---- | | A-1 | A-2 | A-3 | | B-1 | B-2 | B-3 | HTML や Markdown 専用の関数を使う方法 前述の例では、入力ファイルの種類を自動判別する unstructured.partition.auto.partition 関数を使用しましたが、次のようなファイルタイプ別の関数も用意されています。 HTML 用: unstructured.partition.html.partition_html 関数 Markdown 用: unstructured.partition.md.partition_md 関数 これらの関数を使うと、ファイル名ではなく、文字列や URL で入力データを指定することができます。 from unstructured.partition.html import partition_html from unstructured.partition.md import partition_md elems = partition_html(text=\u0026#34;\u0026lt;p\u0026gt;It is OK.\u0026lt;/p\u0026gt;\u0026#34;) # HTML 形式のテキスト elems = partition_html(url=\u0026#34;https://example.com\u0026#34;) # HTML を取得可能な URL elems = partition_md(text=markdown_text) # Markdown 形式のテキスト elems = partition_md(url=\u0026#34;https://example.com/1.md\u0026#34;) # Markdown を取得可能な URL"},{url:"/p/rr2ahpx/",title:"Python で URL 文字列を各パートに分割する (urllib.parse.urlparse)",date:"2023-05-26T00:00:00Z",body:"Python で URL 文字列を各パートに分割する (urllib.parse.urlparse) Python の標準ライブラリの urllib.parse.urlparse 関数を使用すると、URL 形式の文字列から ParseResult オブジェクトを生成することができます。 ParseResult オブジェクトの各プロパティを参照することで、URL の各パート（スキーム、ドメイン、パス、クエリ文字列など）を取り出すことができます。 sample.py（URL 文字列を解析する） from urllib.parse import urlparse url = \u0026#34;https://example.com/p/abcdefg/?foo=1\u0026amp;bar=2#top\u0026#34; parsed_url = urlparse(url) # ParseResult オブジェクトを生成する print(parsed_url.scheme) # =\u0026gt; https print(parsed_url.netloc) # =\u0026gt; example.com print(parsed_url.path) # =\u0026gt; /p/abcdefg/ print(parsed_url.query) # =\u0026gt; foo=1\u0026amp;bar=2 print(parsed_url.fragment) # =\u0026gt; top"},{url:"/p/bp9q8p6/",title:"Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する",date:"2023-05-25T00:00:00Z",body:"Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する サイトマップとは？ Web サイトのサイトマップファイル (sitemap.xml) には、次のような形で全ページの URL 情報が記載されています。 このファイルは、主に Google などの検索エンジンのために提供されています。 sitemap.xml \u0026lt;urlset xmlns=\u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34; xmlns:xhtml=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://example.com/page1/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2021-01-01\u0026lt;/lastmod\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://example.com/page2/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2022-02-02\u0026lt;/lastmod\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;http://example.com/page3/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2023-03-03\u0026lt;/lastmod\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;/urlset\u0026gt; sitemap.xml から URL の一覧を取得する 次の Python スクリプトは、上記のような sitemap.xml ファイルから、すべての URL 情報を抽出します。 sitemap.xml ファイル自体のダウンロードには urlopen を使用し、XML のパースには ElementTree を使用しています。 extract-urls.py from urllib.request import urlopen from xml.etree import ElementTree url = \u0026#34;https://example.com/sitemap.xml\u0026#34; def fetch(url: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;指定した URL のリソースを文字列で取得します。\u0026#34;\u0026#34;\u0026#34; with urlopen(url) as res: return res.read().decode(\u0026#34;utf-8\u0026#34;) def extract_urls(sitemap_xml: str) -\u0026gt; list[str]: \u0026#34;\u0026#34;\u0026#34;sitemap.xml の内容から URL を抽出します。\u0026#34;\u0026#34;\u0026#34; urls = [] root = ElementTree.fromstring(sitemap_xml) # \u0026lt;loc\u0026gt; タグの中身を取得する for loc in root.iter(\u0026#34;{http://www.sitemaps.org/schemas/sitemap/0.9}loc\u0026#34;): urls.append(loc.text) return urls if __name__ == \u0026#34;__main__\u0026#34;: sitemap_xml = fetch(url) urls = extract_urls(sitemap_xml) for url in urls: print(url) 実行結果 http://example.com/page1/ http://example.com/page2/ http://example.com/page3/ （おまけ）URL が示すリソースをまとめてダウンロードする 上記のように作成した URL リストを使って、まとめて HTML ファイルとしてダウンロードするサンプルコードです。 ダウンロードするときのファイル名を自動で生成するのは意外と面倒なので、ここでは単純に 1.html、2.html、3.html といった連番のファイル名で保存しています。 download-htmls.py import os import time from urllib.request import urlretrieve def download_all(urls: list[str], outdir=\u0026#34;out\u0026#34;) -\u0026gt; None: os.makedirs(outdir, exist_ok=True) count = 1 for url in urls: save_path = f\u0026#34;{outdir}/{count}.html\u0026#34; print(f\u0026#34;Downloading {url} =\u0026gt; {save_path}\u0026#34;) try: urlretrieve(url, save_path) count += 1 except Exception as e: # 1 つの URL で 404 エラーなどが発生しても処理は継続する print(e) time.sleep(0.5) # sleep を入れてサーバー負荷を下げる if __name__ == \u0026#34;__main__\u0026#34;: # 本来は sitemap.xml から抽出した URL リストを使う urls = [ \u0026#34;http://example.com/page1/\u0026#34;, \u0026#34;http://example.com/page2/\u0026#34;, \u0026#34;http://example.com/page3/\u0026#34;, ] download_all(urls) 実行結果 Downloading http://example.com/page1/ =\u0026gt; out/1.html Downloading http://example.com/page2/ =\u0026gt; out/2.html Downloading http://example.com/page3/ =\u0026gt; out/3.html"},{url:"/p/st6fpz9/",title:"Hugo で使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates)",date:"2023-04-25T00:00:00Z",body:"Hugo で使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates) Hugo で四苦八苦しながらテンプレートを開発していると、いつのまにか使われていないテンプレート（.html ファイル）が量産されていたりします。 Hugo サイトのビルド時に、未使用のテンプレートを検出するには、次のように --printUnusedTemplates オプションを付けて実行します。 $ hugo --printUnusedTemplates Start building sites … ...(省略)... WARN 2023/04/25 00:27:35 Template _default/section.backup.html is unused, source file /Users/maku/mysite/themes/maku/layouts/_default/section.backup.html WARN 2023/04/25 00:27:35 Template partials/debug/link-path.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/debug/link-path.html WARN 2023/04/25 00:27:35 Template partials/pager.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/pager.html WARN 2023/04/25 00:27:35 Template partials/top-menu.back.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/top-menu.back.html WARN 2023/04/25 00:27:35 Template shortcodes/anchor.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/anchor.html WARN 2023/04/25 00:27:35 Template shortcodes/mermaid.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/mermaid.html WARN 2023/04/25 00:27:35 Template shortcodes/script.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/script.html WARN 2023/04/25 00:27:35 Template shortcodes/workings-and-drafts.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/workings-and-drafts.html Total in 239 ms 上記の例では、8 つのテンプレートやショートコードが使われていないことが分かります。 内容を確認して、問題なければ削除してしまいましょう。"},{url:"/p/bqar8o6/",title:"Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する",date:"2023-04-01T00:00:00Z",body:'Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する Hugo Modules とは Hugo Modules の仕組みを使うと、異なるディレクトリに配置されたファイル群をまとめて、1 つの Hugo サイトを構成することができます。 Hugo Module の実体は、Hugo サイト用のファイルが格納されたディレクトリです。 Hugo Module は、ローカル PC 上のディレクトリであってもよいし、GitHub リポジトリ内のディレクトリであっても構いません（通常は GitHub で管理することになるでしょう）。 graph RL subgraph my-hugo-module-1 mod1("Hugo Module") end subgraph my-hugo-module-2 mod2("Hugo Module") end subgraph my-hugo-site mod1_imported("Hugo Module") mod2_imported("Hugo Module") end mod1 -- import --\u003e mod1_imported mod2 -- import --\u003e mod2_imported classDef classMod fill:#36f,color:white,stroke:none class mod1,mod2,mod1_imported,mod2_imported classMod この仕組みは、一見すると、Hugo テーマを Git サブモジュールとして取り込むのと同じように見えますが、Hugo Modules はより柔軟で、コンテンツを含むほとんどのファイルをインポートできます。 現状、下記の 7 つのディレクトリに格納されるファイルを、Hugo Module からインポートすることができます。 archetypes \u0026hellip; 複数サイトでコンテンツ作成用テンプレート (.md) を共有できます。 assets \u0026hellip; 複数サイトでビルド用のアセット（.scss など）を共有できます。 content \u0026hellip; 複数サイトでコンテンツファイル (.md) を共有できます。 data \u0026hellip; 複数サイトでデータ（.yml、.json など）を共有できます。複数の Hugo Module で定義されたデータをマージできます。 i18n \u0026hellip; 複数サイトで翻訳データ (.yml、.json など）を共有できます。複数の Hugo Module で定義された翻訳データをマージできます。 layouts \u0026hellip; 複数サイトでレイアウトやショートコード (.html) を共有できます。 static \u0026hellip; 複数サイトで静的なファイル（.js ファイルなど）を共有できます。 Hugo Modules の仕組みでテーマ系のファイル（assets、layouts、static など）をインポートするようにすれば、もう Git サブモジュールの仕組みを使う必要はありません。 Hugo Modules の特徴をまとめると次のような感じになります。 主に、従来の Git サブモジュールによるテーマ導入の仕組みとの比較です。 Hugo Modules を使えば、前述のような様々なファイルを柔軟に組み合わせることができます。テーマのように完全な layouts を用意する必要はなく、必要なファイルだけを個別にインポートできます。可能性は無限大です。 Hugo Modules を使えば、Git サブモジュールの複雑なコマンド (git submodule) を使う必要がありません。代わりに hugo mod コマンドを使う必要はありますが、Git サブモジュールの更新管理に比べれば分かりやすいです。 Git サブモジュールを使用している場合、git clone 時に --recurse-submodules フラグを指定するなどしてサブモジュールの取り込みを忘れないよう注意する必要がありますが、Hugo Modules の場合は、単純に git clone して hugo serve するだけで、自動的に依存モジュールをインポートしてくれます（GitHub などから取得してくれる）。 Hugo Module 内の各ディレクトリ（Golang 用語ではパッケージ）を、Hugo プロジェクト内のどのディレクトリに展開（マウント）するかを指定できます。Git サブモジュールの場合は、リポジトリ単位でしか展開先を指定できません。 Hugo Modules を使うには、Golang の環境をインストールしておく必要があります。Golang の Go Modules という仕組みをベースにしているので、Golang を使ったことがないと、若干のとっつきにくさはあるかもしれません。とはいえ、基本的には Golang の知識は必要ありません。 事前準備 Golang のインストール Hugo Modules の仕組みは、Golang（Go 言語）の Go Modules という仕組みを利用して提供されています。 Hugo Modules の仕組みを使用するには、Golang の実行環境をインストール しておく必要があります。 Download and install - The Go Programming Language Golang のインストールが完了すると、Hugo Modules 用のサブコマンド (hugo mod) などが正しく動作するようになります。 逆に、Golang がインストールされていない環境で Hugo Modules を使用する Hugo サイトをビルドしようとすると、go コマンドがないというエラーになります（例: Error: failed to download modules: binary with name \u0026quot;go\u0026quot; not found）。 Hugo プロジェクトの作成 テスト用に Hugo サイト（プロジェクト）を作成しておきます。 $ cd ~ $ hugo new site my-hugo-site Hugo サイトを Hugo Module 化する 既存の Hugo サイトで Hugo Modules の仕組みを使用するには、hugo mod init コマンドで、その Hugo サイト自体も Hugo Module として初期化しておく必要があります。 これにより、他の Hugo Module を GitHub などから自動取得できるようになります。 Hugo Module には、（Go Modules の仕組み上）一意のモジュール名 を設定しておく必要があり、通常は GitHub リポジトリのパスを github.com/USER/REPO のような感じで指定します（USER と REPO の部分は適切に置き換えてください）。 Hugo サイトを Hugo Module 化 $ cd ~/my-hugo-site $ hugo mod init github.com/USER/my-hugo-site ☝️ 実はモジュール名は何でもよい 上記の説明では、Hugo Module には github.com/\u0026lt;USER\u0026gt;/\u0026lt;REPO\u0026gt; のような一意の名前を付ける必要があると記述しましたが、正確に言うと、これはインポートされる側の Hugo Module の要件です。 なので、実際には Hugo サイト側（他の Hugo Module をインポートする側）のモジュール名は何でもよかったりします（単純に mysite など）。 Hugo Module 化といっても、このコマンドは、次のような go.mod というファイルを生成するだけです。 最初は、自身のモジュール名と使用した Golang バージョンくらいしか記述されていませんが、このあと Hugo Module を追加するたびにこのファイルに依存関係が追加されていきます。 go.mod module github.com/USER/my-hugo-site go 1.18 Hugo Modules の仕組みでテーマをインポートする GitHub 上で公開されている Hugo テーマ を Hugo Module としてインポートするには、Hugo の設定ファイル（hugo.toml や config.toml）内に次のような module セクションを追加します。 ここでは、PaperMod というテーマを使ってみます。 hugo.toml に追加 [module] [[module.imports]] path = \u0026#39;github.com/adityatelange/hugo-PaperMod\u0026#39; これにより、GitHub リポジトリ上のファイル群が Hugo サイトにマージされてビルドされることになるので、hugo.toml 内のテーマ名指定（theme = \'PaperMod\' など）は必要ありません。 もっと言うと、themes ディレクトリ自体必要ありません。 インポート対象の GitHub リポジトリ（Hugo テーマ）は、Hugo Module として初期化 (hugo mod init) されていなくてもインポートできるようになっています。 つまり、現在公開されている Hugo テーマは、すべてこの仕組みでインポートできます。 ただし、依存関係を正しく管理するため、Hugo テーマは Hugo Module として初期化しておく（つまり、go.mod を配置しておく）ことが推奨されています。 Hugo Module のインポート設定ができたら、Hugo サーバーを起動して正しく Hugo Module がダウンロードされるか確認します。 Hugo サーバーの起動 $ hugo serve http://localhost:1313 にアクセスして、次のように正しくテーマが反映されていれば成功です。 図: Hugo Modules の仕組みでテーマをインポートできた コンテンツを提供する Hugo Module を作ってみる 今度は、コンテンツ（.md ファイル）を提供する Hugo Module を新しく作成してインポートしてみます。 ここでは、最終的に GitHub の https://github.com/USER/my-hugo-module というリポジトリで管理するものとして、モジュール名を付けておきます。 共有可能な Hugo Module を作成する $ mkdir ~/my-hugo-module $ cd ~/my-hugo-module $ hugo mod init github.com/USER/my-hugo-module 次に、この Hugo Module が提供するコンテンツを作成します。 ~/my-hugo-module/content/posts/hello.md --- title: \u0026#34;Hello\u0026#34; date: \u0026#34;2023-04-01\u0026#34; --- Hello, Hugo Modules! これだけで、Hugo Module は完成です。 Hugo サイトの本体側 (my-hugo-site) から、この Hugo Module をインポートするよう設定します。 ~/my-hugo-site/hugo.toml（抜粋） [module] [[module.imports]] path = \u0026#39;github.com/adityatelange/hugo-PaperMod\u0026#39; [[module.imports]] path = \u0026#39;github.com/USER/my-hugo-module\u0026#39; この時点では、この Hugo Module はまだ GitHub 上で管理していないので、Hugo サイトをビルドしようとすると Hugo Module をダウンロードできないというエラーになります。 $ cd ~/my-hugo-site $ hugo ... remote: Repository not found. fatal: repository \u0026#39;https://github.com/USER/my-hugo-module/\u0026#39; not found そこで、一時的に GitHub の URL（モジュールパス）をローカル PC のディレクトリパスに置き換える、Go Modules の replacement 機能を使用します。 置換内容は、Hugo 専用の HUGO_MODULE_REPLACEMENTS 環境変数で設定できます。 ローカル PC 上の Hugo Module を参照して起動 $ export HUGO_MODULE_REPLACEMENTS=\u0026#34;github.com/USER/my-hugo-module -\u0026gt; /Users/maku/my-hugo-module\u0026#34; $ hugo serve 複数の置換設定を行いたいときは、カンマで区切って指定すれば OK です。 これで、正しくすべての Hugo Module をインポートできるようになり、Hugo サイトのビルドに成功するはずです。 今回のケースでは、http://localhost:1313/posts/hello/ にアクセスして記事が表示されれば成功です。 図: コンテンツ用の Hugo Module もインポートできた ちなみに、replacement の置換内容は、go.mod ファイル内の replace ディレクティブ でも設定可能ですが、最終的にはこの設定は削除して、正しく GitHub 上のリポジトリを参照するように戻さなければいけないので、HUGO_MODULE_REPLACEMENTS 環境変数を使った方が都合がよいと思います。 Hugo Module の依存関係を確認する hugo mod graph コマンドを使用すると、（Hugo Module 化した）Hugo サイトが依存している Hugo Module の一覧を確認できます。 Hugo Module の依存グラフを表示 $ cd ~/my-hugo-site $ hugo mod graph github.com/USER/my-hugo-site github.com/adityatelange/hugo-PaperMod@v0.0.0-20230331160356-2210bf20b365 github.com/USER/my-hugo-site /Users/maku/my-hugo-module この例では、Hugo サイト (my-hugo-site) が、2 つの Hugo Module（hugo-PaperMod と my-hugo-module）に依存していることが分かります。 Hugo Module の更新を取り込む GitHub 上で管理されている Hugo Module のファイルが更新された場合に、それを Hugo サイト側に反映するには、hugo mod get -u コマンドを使用します。 Hugo Module の更新 $ hugo mod get -u ./... # すべての Hugo Module を再帰的に更新 $ hugo mod get -u # すべての Hugo Module を更新 $ hugo mod get -u github.com/USER/my-hugo-module # 指定した Hugo Module を更新 $ hugo mod get -u github.com/USER/my-hugo-module@v.1.0.2 # バージョンを指定 （応用）各ディレクトリのマウント先を変更する Hugo Modules は、複数のディレクトリに散らばったファイルを集めて 1 つの Hugo サイトとしてビルドする仕組みなので、どうしてもファイル名の競合が発生してしまう可能性があります。 content ディレクトリ以下の記事ファイルや、static ディレクトリ以下の静的ファイルの名前が、複数の Hugo Module の間で競合してしまった場合、最初に見つかったファイルがビルド対象になります。 例えば、Hugo サイト本体 (my-hugo-site) から、2 つの Hugo Module（my-hugo-module-1、my-hugo-module-2）をインポートしているとして、それぞれが次のように競合する名前（パス）のファイルを持っているとすると、採用されるのは Hugo サイト本体に置かれたファイルだけです。 my-hugo-site/static/js/hello.js \u0026hellip; http://YOUR-SITE/js/hello.js で見えるのはこのファイル my-hugo-module-1/static/js/hello.js \u0026hellip; このファイルは見えなくなる my-hugo-module-2/static/js/hello.js \u0026hellip; このファイルも見えなくなる このように、インポートした Hugo Module のファイルが見えなくなると都合が悪い場合は、Hugo サイトの設定ファイル（hugo.toml や config.toml）の [[module.imports.mounts]] セクションで、ディレクトリ単位でマウント先を変更します。 hugo.toml（抜粋） [module] [[module.imports]] path = \u0026#39;github.com/USER/my-hugo-module-1\u0026#39; [[module.imports.mounts]] source = \u0026#39;static/js\u0026#39; target = \u0026#39;static/mod1/js\u0026#39; [[module.imports]] path = \u0026#39;github.com/USER/my-hugo-module-2\u0026#39; [[module.imports.mounts]] source = \u0026#39;static/js\u0026#39; target = \u0026#39;static/mod2/js\u0026#39; これで、各 Hugo Module のディレクトリが別々のディレクトリにマウントされ、次のような URL でアクセスできるようになります。 http://YOUR-SITE/js/hello.js \u0026hellip; Hugo サイト本体の JS ファイル http://YOUR-SITE/mod1/js/hello.js \u0026hellip; my-hugo-module-1 の JS ファイル http://YOUR-SITE/mod2/js/hello.js \u0026hellip; my-hugo-module-2 の JS ファイル 上記の設定例では、static/js ディレクトリのマウント先を変更していますが、親ディレクトリの static ディレクトリごとマウント先を変更してしまっても OK です。 （応用）GitHub Actions の設定 GitHub Actions を使って Hugo サイトをビルドしている場合は、ワークフロー内で Golang 環境をセットアップするよう指定しておく必要があります。 このセットアップを忘れると、hugo コマンドによるビルド時に次のようなエラーになります（サイト自体を Hugo Module として初期化していない場合も同様のエラーが発生します）。 Error: module \u0026#34;github.com/USER/my-hugo-module\u0026#34; not found; either add it as a Hugo Module or store it in \u0026#34;/home/runner/work/my-hugo-site/my-hugo-site/themes\u0026#34;.: module does not exist ワークフローファイルの中で、actions/setup-go アクションを指定するだけで、Golang の実行環境は簡単にインストールすることができます。 あとは、今まで通り Hugo によるビルドを行うだけで、依存する Hugo Module を自動でダウンロードしてビルドしてくれます。 .github/workflows/hugo-build.yml name: Build Hugo site on: push: branches: [main, master] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: \u0026#39;recursive\u0026#39; # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Go environment uses: actions/setup-go@v4.0.0 with: go-version: \u0026#39;^1.20\u0026#39; - name: Setup Hugo environment uses: peaceiris/actions-hugo@v2.6.0 with: hugo-version: \u0026#39;0.111.3\u0026#39; extended: true # Enable scss - name: Build Hugo site run: hugo --minify # ...'},{url:"/p/gxj4n7q/",title:"Rust でモジュールを定義する (mod)",date:"2023-03-05T00:00:00Z",body:"Rust でモジュールを定義する (mod) 規模の大きい Rust プログラムを作る場合、モジュール の仕組みを使ってコードを階層化すると見通しがよくなります。 Rust でモジュールを定義するときは、mod キーワードを使用します。 1 つの .rs ファイルの中にインライン形式でモジュールを定義することも、別ファイルに分けてモジュールを定義することもできます。 クレートとモジュール すべての Rust プログラムはクレート (crate) であり、バイナリクレート か ライブラリクレート のどちらかです。 クレートは、Rust におけるコンパイルの単位です。 バイナリクレート \u0026hellip; 1 つの実行ファイルを作り上げるもの。 ライブラリクレート \u0026hellip; 1 つのライブラリを作り上げるもの。 コンパイルはクレート単位で行われますが、コードレベルの実装では、モジュール という論理的な単位で分割／階層化できるようになっています。 クレートは 1 つ以上のモジュールで構成され、必ず 1 つの ルートモジュール（クレートルート） を持っています。 ルートモジュールのファイル名は決まっていて、バイナリクレートの場合は src/main.rs で、ライブラリクレートの場合は src/lib.rs です。 ルートモジュールはサブモジュールを含むことができ、さらに、サブモジュールも同様にサブモジュールを含むことができます。 クレートの論理的構造（ディレクトリ構造ではない） ルートモジュール (src/main.rs あるいは src/lib.rs) +-- サブモジュール | +-- サブサブモジュール | +-- ... +-- サブモジュール +-- サブサブモジュール +-- ... 上記のように、クレート内のモジュールはルートモジュールを起点とするツリー構造になるため、mod キーワードを使ってモジュールを定義するとき、それは必ず何らかの親モジュールのサブモジュールということになります。 モジュールの作り方 インラインモジュール mod ブロックを使ってサブモジュールを定義することができます。 サブモジュールの実装をブロック内に直接記述するので、インラインモジュール と呼ばれます。 次の例では、calc モジュールを定義して、その中に add 関数を定義しています。 src/main.rs // calc モジュールを定義する mod calc { pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } } fn main() { // calc モジュール内の add 関数を呼び出す println!(\u0026#34;{}\u0026#34;, calc::add(1, 2)); } モジュール内で定義した関数は、デフォルトでモジュール内からのみ参照可能 (private) になっているため、別モジュールから add 関数を呼び出せるようにするには pub キーワードを付けて公開設定しておく必要があります（pub の詳細は後述）。 親モジュール（ここではルートモジュール）から calc モジュールの add 関数にアクセスするには、calc::add というパスを使用します。 ファイルモジュール サブモジュールを別ファイルとして実装することもできます。 というより、大きなプロジェクトを管理する場合、こちらのファイルを使ったサブモジュール化が主な使い方になると思います。 例えば、ルートモジュール (main.rs) から呼び出すことのできる calc サブモジュールを作るには、main.rs と同じディレクトリに、calc.rs あるいは calc/mod.rs を配置します。 つまり、ディレクトリ構成は次のようになります。 calc モジュールの配置方法 (1) 2018 edition 以降 src/ +-- main.rs +-- calc.rs calc モジュールの配置方法 (2) 2015 edition 以降 src/ +-- main.rs +-- calc/ +-- mod.rs 別ファイルに分離した calc モジュールのコードは次のようになります。 先ほど mod calc ブロックの中に記述したコードと同じ内容です。 src/calc.rs pub fn add(a: i32, b: i32) -\u0026gt; i32 { a + b } これをルートモジュールから利用するには、次のように mod calc; というモジュール宣言を行うことで、src/calc.rs（あるいは src/calc/mod.rs）の内容を読み込むようコンパイラに指示します。 あとは、先ほどの例と同様、calc::add という形でモジュール内の関数を呼び出せます。 src/main.rs mod calc; // コンパイラに calc.rs（あるいは calc/mod.rs）が存在することを知らせる fn main() { println!(\u0026#34;{}\u0026#34;, calc::add(1, 2)); } サブサブモジュール サブモジュール内でさらに mod キーワードを使えば、ネストする形でサブモジュールを定義することができます（以下、サブサブモジュール）。 ここでは例として、sub という名前のサブモジュールと、subsub という名前のサブサブモジュールを作ることにします。 サブサブモジュールは、サブモジュールと同じ名前のディレクトリ名 (sub) に .rs ファイルを配置することで作成できます。 サブサブモジュールの配置 src/ +-- main.rs +-- sub.rs （サブモジュール） +-- sub/ +-- subsub.rs （サブサブモジュール） あるいは、mod.rs を使う場合は次のような配置になります。 src ディレクトリの一階層目をスッキリさせたいときは、こちらの配置の方がよいですね。 src/ +-- main.rs +-- sub/ +-- mod.rs （サブモジュール） +-- subsub.rs （サブサブモジュール） 以下、それぞれの .rs ファイルの実装例です。 pub キーワードで公開設定しなければいけないのは、サブサブモジュールでも同様です（ここでは文字列定数 MY_NAME を公開設定しています）。 main.rs（ルートモジュール） mod sub; // sub.rs の存在を知らせる fn main() { sub::hello(); //=\u0026gt; \u0026#34;Hello, Maku\u0026#34; } sub.rs（サブモジュール） mod subsub; // sub/subsub.rs の存在を知らせる pub fn hello() { println!(\u0026#34;Hello, {}\u0026#34;, subsub::MY_NAME); } sub/subsub.rs（サブサブモジュール） pub const MY_NAME: \u0026amp;str = \u0026#34;Maku\u0026#34;; デフォルトでは、サブモジュールには、その親モジュールからしかアクセスできないようになっています。 上記の例で言うと、ルートモジュール (main.rs) からの sub モジュールの参照や、sub モジュールからの subsub モジュールの参照は可能ですが、ルートモジュールから直接 subsub モジュールを参照することはできません。 sub モジュールの外から subsub モジュールにアクセスできるようにするには、次のように pub mod を使ってモジュールを公開設定します。 sub.rs pub mod subsub; ここまで、pub キーワードを付けて公開設定してきたのは、モジュール内のメンバー（関数や定数）でしたが、ネストされたモジュールの公開設定も同様の仕組みで行えるということですね。 下記のサンプルコードでは、ルートモジュール (main.rs) から、サブサブモジュールに直接アクセスしています（sub::subsub という階層化されたパスを使用します）。 main.rs（ルートモジュール） mod sub; fn main() { println!(\u0026#34;VALUE_1 = {}\u0026#34;, sub::VALUE_1); //=\u0026gt; 100 println!(\u0026#34;VALUE_2 = {}\u0026#34;, sub::VALUE_2); //=\u0026gt; 200 println!(\u0026#34;VALUE_3 = {}\u0026#34;, sub::subsub::VALUE_3); //=\u0026gt; 300 println!(\u0026#34;VALUE_4 = {}\u0026#34;, sub::subsub::VALUE_4); //=\u0026gt; 400 } sub.rs（サブモジュール） pub mod subsub; // subsub モジュールを公開設定 pub const VALUE_1: i32 = 100; pub const VALUE_2: i32 = 200; sub/subsub.rs（サブサブモジュール） pub const VALUE_3: i32 = 300; pub const VALUE_4: i32 = 400; ちなみに、sub::subsub::VALUE_3 と絶対パス指定している部分は、use を使って次のように省略記述 (subsub::VALUE_3) できるようになります。 main.rs mod sub; use sub::subsub; fn main() { // ... println!(\u0026#34;VALUE_3 = {}\u0026#34;, subsub::VALUE_3); } 公開範囲を制限する ここまでの例では、シンプルな pub 指定による公開設定をしていましたが、これは、正確には 外部のクレートにまで公開する という意味になります。 外部クレートに公開するといっても、実際には、サブモジュールを pub 修飾しない限り、サブモジュール内のメンバーには外からはアクセスできないので、それだけで情報がダダ漏れになるということはありません。 とはいえ、公開範囲はできるだけ絞った方がよく、次のような追加のパス指定で、細かく公開範囲を制御できるようになっています。 指定方法 意味 pub 外部のクレートにまで公開 pub(crate) カレントクレートに公開 pub(super) 親モジュールに公開 （おすすめ） pub(super::super) 親モジュールの親モジュールに公開 pub(in crate::my_mod) 指定したパスのモジュールに公開（上位のモジュールのみを指定可能） （指定なし） プライベート（モジュール内でのみ参照可能） pub(self) 同上（モジュール内でのみ参照可能） 上の指定方法の中でも使っていますが、モジュールパスは次のようなプレフィックスを組み合わせて指定することができます。 self:: \u0026hellip; 自分自身のモジュールからの相対パス super:: \u0026hellip; 親モジュールからの相対パス crate:: \u0026hellip; クレートルートからの絶対パス クレート内でのみ使用する要素には、pub(crate) 以上の公開範囲（つまり pub）を設定する必要はありません。 一般的に、モジュールの依存関係はツリー構造に従ったシンプルな構成になっていると保守しやすいので、まずは pub(super) で公開設定できないかを考えてみるとよいです。"},{url:"/p/22cnw7f/",title:"Rust の文法: 制御構文 (if, match, while, loop, for)",date:"2023-02-13T00:00:00Z",body:"Rust の文法: 制御構文 (if, match, while, loop, for) 条件分岐 if 文 (if statement) if n \u0026gt; 0 { println!(\u0026#34;{} is positive\u0026#34;, n); } else if n \u0026lt; 0 { println!(\u0026#34;{} is negative\u0026#34;, n); } else { println!(\u0026#34;{} is zero\u0026#34;, n); } C/C++ と異なり、条件式は () で囲む必要はありません。 ただし、ブロック部分は必ず {} で囲む必要があります。 if 式 (if expression) Rust の if は式として扱うことができるので、分岐後に評価した値を参照することができます（Kotlin などのモダンな言語と同様です）。 下記の変数 s には、n の値に応じて Good あるいは Bad が格納されます。 let s = if n \u0026gt; 0 { \u0026#34;Good\u0026#34; } else { \u0026#34;Bad\u0026#34; }; if を式として使う場合は、必ず else 句が必要なことに注意してください。 また、評価後の値（上記の例では \u0026quot;Good\u0026quot; や \u0026quot;Bad\u0026quot;）の後ろには、セミコロン (;) を付けてはいけません。 セミコロンを付けると、それは式ではなく値を持たない文とみなされてしまうので、if 式の評価結果が空（空タプル ()）になってしまいます。 ☝️ Rust に三項演算子はない Java や C/C++ には三項演算子 (a ? b : c) がありますが、Rust にはこのような三項演算子は存在しません。 if 式を使えば同様のことを表現できるからです。 match 式 (match expression) C/C++ や Java の switch に相当する分岐処理として、Rust では match を使用します。 各分岐処理において、if ... というガード (guard) を付加することで、柔軟な分岐処理を行うことができます。 let n = 5; match n { 0 =\u0026gt; println!(\u0026#34;zero\u0026#34;), // n が 0 の場合 _ if n \u0026lt; 0 =\u0026gt; println!(\u0026#34;negative\u0026#34;), // n が負の場合 _ if n \u0026lt; 10 =\u0026gt; println!(\u0026#34;single digit\u0026#34;), // n が 1 から 9 の場合 _ =\u0026gt; println!(\u0026#34;multiple digits\u0026#34;), // それ以外（n が 10 以上）の場合 } if と同様に、match は式として扱うことができるので、評価後の値を変数などで受け取ることができます。 /// ゲームのジャンル enum Genre { Action, Shooting, Table, Strategy, Rpg } let g = Genre::Action; // ジャンルの略称に変換する let abbr = match g { Genre::Action =\u0026gt; \u0026#34;ACT\u0026#34;, Genre::Shooting =\u0026gt; \u0026#34;STG\u0026#34;, Genre::Table =\u0026gt; \u0026#34;TBL\u0026#34;, _ =\u0026gt; \u0026#34;OTHER\u0026#34;, }; println!(\u0026#34;{}\u0026#34;, abbr); //=\u0026gt; ACT ちなみに、上記の例では列挙型 (enum) の値による分岐処理を行っています。 列挙型の詳細はこちら を参照してください。 ループ while ループ let mut n = 1; while n \u0026lt;= 3 { println!(\u0026#34;n = {n}\u0026#34;); n += 1; } if と同様、条件部分は () で囲まず、ブロック部分は {} で囲みます。 Rust には C/C++ のような do-while 構文はありませんが、break や continue は同様に使用できます。 無限ループにしたいときは、while true とする代わりに、下記の loop を使用します。 loop ループ Rust には、無限ループ用の loop が用意されています。 let mut n = 1; loop { println!(\u0026#34;n = {n}\u0026#34;); n += 1; if n \u0026gt; 3 { break; } } for-in ループ for-in ループは、イテレート可能なコレクション要素を 1 つずつ取り出すときに使用します。 配列要素を 1 つずつ取り出す let arr = [100, 200, 300]; for x in arr { println!(\u0026#34;The value is: {}\u0026#34;, x); } 範囲演算子（.. や ..=）で Range オブジェクトを作れば、数値範囲のループ処理を行えます。 1〜4 のループ (right-exclusive range operator) for i in 1..5 { print!(\u0026#34;{i} \u0026#34;) } 1〜5 のループ (right-inclusive range operator) for i in 1..=5 { print!(\u0026#34;{i} \u0026#34;) } 逆順にループ（5 → 1） for i in (1..=5).rev() { println!(\u0026#34;{i}\u0026#34;); } in の後ろの部分に式を記述した場合、ループの実行前に一度だけ評価されます。 例えば、下記の s.len() 部分は一度だけ実行されます。 for i in 0..s.len() { // ... } for の iteration variable（イテレーション変数）のスコープは for ステートメント内に限定されるので、外側で定義されている変数と同じ名前を使うことができます（推奨はされませんが）。 外側のループを抜ける \u0026#39;outer: loop { for i in 0..5 { println!(\u0026#34;{}\u0026#34;, i); if i == 2 { break \u0026#39;outer; } } } while、loop、for-in ループに 'ラベル名: という形でラベルを付けておくと、ネストされたループを break で抜けることができます。"},{url:"/p/4nx8hqy/",title:"Rust の文法: 所有権 (ownership) と借用 (borrow)",date:"2023-02-13T00:00:00Z",body:"Rust の文法: 所有権 (ownership) と借用 (borrow) 所有権 (ownership) Rust においてヒープ上で管理される値には 所有権 (ownership) という概念があり、必ず 1 つの変数だけが所有権を保持しています。 所有権を持つ変数が関数などのスコープから外れるときに、メモリが解放され、値が破棄されます。 この仕組み（制約）により、Rust では、ヒープ上に確保された値がどこで解放されるかをコンパイル時に決定できるようになっています（Java のようなガーベジコレクションが必要ありません）。 Rust で独特なのは、所有権が変数間で移動するところで、次のような操作を行ったときに所有権が移動します（この振る舞いを move と呼びます）。 代入演算子 (=) で別の変数に代入したとき 関数の引数として変数を渡したとき 関数の戻り値として変数を返したとき 代入による所有権の移動 // ヒープ上に String インスタンスが確保され、変数 s1 が所有者 (owner) となる let s1 = String::from(\u0026#34;Hello\u0026#34;); // s1 の所有権が s2 に移動 (move) し、s1 は無効化される let s2 = s1; // コンパイルエラー！（ここでは s1 はもう使えない） println!(\u0026#34;{}, {}\u0026#34;, s1, s2); 次のように clone メソッドで明示的なディープコピーを行えば、所有権は移動しません。 ヒープ上の新しい領域に値がコピーされ、それぞれの変数が別の値の所有者となるからです。 let s1 = String::from(\u0026#34;Hello\u0026#34;); let s2 = s1.clone(); // ディープコピー // s1 も s2 も独立した値の所有者なので両方アクセスできる println!(\u0026#34;{}, {}\u0026#34;, s1, s2); //=\u0026gt; Hello, Hello i32 型などのプリミティブ型に関しては、（ヒープではなく）スタック上 に値が配置されるので、所有権の概念を持ちません。 代入後もすべての変数が有効です。 スタック上に確保される値に所有権はない let a = 100; let b = a; // a も b も有効 println!(\u0026#34;{}, {}\u0026#34;, a, b); //=\u0026gt; 100, 100 プリミティブ型であっても、次のように Box 型でラップすることでヒープ上で管理することができます。 let x = Box::new(7); // x が Box\u0026lt;i32\u0026gt; を所有する let y = x; // 所有権が y に移動し、x は無効化される 借用 (borrow) 所有権の移動 (move) は、関数の引数として変数値を渡すときにも発生します。 下記のコードの calc_len 関数は、引数で渡した変数の所有権を奪ってしまいます。 関数を抜けるときに、その変数は破棄されることになるので、呼び出し元の変数は無効になります。 関数呼び出しにより所有権が奪われる（間違った例） fn calc_len(s: String) -\u0026gt; usize { s.len() } let s = String::from(\u0026#34;Hello\u0026#34;); let len = calc_len(s); // ここで s の所有権が奪われる println!(\u0026#34;{}, {}\u0026#34;, s, len); // エラー！（s はもう有効ではない） これでは変数の値をたかだか 1 回しか参照できなくなってしまうので、Rust は 借用 (borrow) という仕組みを用意することで、所有権を移動させずにその値を参照 できるようにしています。 ある変数に \u0026amp; を付けると、その変数の参照を取得（借用）することができます。 参照の型を表現するときも \u0026amp; プレフィックスを付けて表現します（例: String の参照型は \u0026amp;String）。 let s1: String = String::from(\u0026#34;Hello\u0026#34;); let s2: \u0026amp;String = \u0026amp;s1; // 借用 (borrow) // s1 も s2 も有効 println!(\u0026#34;{} {}\u0026#34;, s1, s2); この仕組みを利用すれば、前述の calc_len を改良して、呼び出し時に所有権を奪わないようにすることができます。 具体的には、次のようにパラメーターの型を参照型にし、呼び出し時に借用した参照を渡すようにします（どちらも \u0026amp; を付けます）。 所有権を奪わない関数の例 // パラメーターの型を参照にした（実際は `\u0026amp;str` の方がよい） fn calc_len(s: \u0026amp;String) -\u0026gt; usize { s.len() } let s = String::from(\u0026#34;Hello\u0026#34;); let len = calc_len(\u0026amp;s); // 借用により s の所有権は奪われない println!(\u0026#34;{}, {}\u0026#34;, s, len); //=\u0026gt; Hello, 5 関数内で作成したインスタンスを戻り値として返す場合は、参照ではなく通常の型で返すのが一般的です。 関数の終わりで所有権が移動するのは正しい振る舞いだからです。 戻り値の型は参照型にしない fn create_message() -\u0026gt; String { let s = String::from(\u0026#34;Hello\u0026#34;); s // 呼び出し側に所有権が移動する（想定通り） } 可変借用 (mutable borrow) 参照経由で値を変更するには、\u0026amp;mut を付けて 可変参照 を作成する必要があります。 ある変数の可変参照を取得することを 可変借用 (mutable borrow) と呼びます。 これと区別するために、通常の借用 (borrow) によって取得した参照のことを、不変参照とよぶことがあります。 // 可変参照で String を受け取って内容を変更する fn add_suffix(s: \u0026amp;mut String) { s.push_str(\u0026#34;BBB\u0026#34;) } let mut s = String::from(\u0026#34;AAA\u0026#34;); add_suffix(\u0026amp;mut s); // 可変借用 (mutable borrow) して作った可変参照を渡す println!(\u0026#34;{}\u0026#34;, s); //=\u0026gt; \u0026#34;AAABBB\u0026#34; 通常の参照 (\u0026amp;) とは異なり、ある変数の 可変参照 (\u0026amp;mut) は 1 度に 1 つまでしか作れない という制約があります。 これは、複数箇所からの同時変更による競合を防ぐための Rust の仕様です。 また、通常の借用で取得した不変参照を保持しているときも、可変参照を作ることはできません。 不変だと思って参照している値が、別の場所から変更されては困るからです。 逆に、可変参照が存在しない状況では、不変参照は同時にいくつでも作成できます。 このあたりの振る舞いは、一般的に Read-Write Lock と呼ばれているデザインパターンそのものです（書き込む人がいなければ、いろんな場所から同時に読み込んでも問題ない）。"},{url:"/p/h8kw8ju/",title:"Rust の文法: 構造体 (struct) とタプル構造体 (tuple struct)",date:"2023-02-13T00:00:00Z",body:"Rust の文法: 構造体 (struct) とタプル構造体 (tuple struct) 構造体の基本 Rust の構造体の定義とインスタンス化は直感的です。 構造体を定義するときは struct 構造体名 { ... }、定義済みの構造体をインスタンス化するときは 構造体名 { ... } という構文を使用します。 先頭に struct というキーワードが付くかどうかの違いしかないので、どちらの処理を行っているのか気を付けて読み取ってください。 // 構造体の定義（フィールド名と型を指定していく） struct User { name: String, email: String, active: bool, sign_in_count: u64, } // インスタンス化（フィ―ルド名と初期値を指定していく） let user = User { email: String::from(\u0026#34;maku@example.com\u0026#34;), name: String::from(\u0026#34;maku\u0026#34;), active: true, sign_in_count: 1, }; // フィールドの参照にはドットを使う println!(\u0026#34;{}\u0026#34;, user.name); 構造体のフィールドとして文字列を持ちたいときは、\u0026amp;str（文字列スライス）ではなく String 型を使うことで、構造体インスタンス自身が文字列の所有者になることができます（参考: 所有権と借用）。 構造体インスタンスの参照（借用）経由でフィールドにアクセスする場合もドットが使えます。 let user_ref = \u0026amp;user; // 借用 (borrow) して参照 (\u0026amp;User) を作成 println!(\u0026#34;{}\u0026#34;, user_ref.name); // 参照のフィールドもドットでアクセスする 可変な構造体 (mutable struct) インスタンス生成時に let の代わりに let mut を使うと、可変 (mutable) なインスタンスとなり、すべてのフィールドが再代入可能になります（一部のフィールドだけを再代入可能にすることはできません）。 let mut user = User { // ... }; // 各フィールドに別の値を代入可能 user.name = String::from(\u0026#34;puni\u0026#34;); user.active = false; 次のように、構造体インスタンスを丸ごと入れ替えることもできます。 user = User { email: String::from(\u0026#34;puni@example.com\u0026#34;), name: String::from(\u0026#34;puni\u0026#34;), active: false, sign_in_count: 777, }; フィールド初期化の省略記法 フィールド初期化時に、フィールド名と初期値とする変数名が同じ場合、フィールド名だけを記述する省略記法を使えます。 fn build_user(email: String, name: String) -\u0026gt; User { User { email, // email: email と書くのと同じ name, // name: name と書くのと同じ active: true, sign_in_count: 1, } } このような省略記法は TypeScript (JavaScript) でも採用されています。 部分的に異なるインスタンスを生成する 既存の構造体インスタンスがあるときに、一部のフィールドの値だけが異なる別のインスタンスを生成したいときは、次のように .. を使って残りのフィールドをコピーします。 let user1 = User { email: String::from(\u0026#34;maku@example.com\u0026#34;), name: String::from(\u0026#34;maku\u0026#34;), active: true, sign_in_count: 1, }; let user2 = User { email: String::from(\u0026#34;puni@example.com\u0026#34;), name: String::from(\u0026#34;puni\u0026#34;), ..user1 }; ..user1 の後ろにはカンマ (,) を付けないことに注意してください。 この構文もスプレッド演算子として TypeScript (JavaScript) に採用されています。 タプル構造体 (tuple struct) 構造体のフィールド名を省略した、タプル構造体 (tuple struct) を定義することができます。 通常のタプル に名前を付けたようなものと考えればよいです。 通常のタプルと同様に、各フィールドの値は、.0、.1 のようなインデックスで参照します。 // Point という名前のタプル構造体を定義する struct Point(i32, i32); // 基本的な使い方 let p = Point(100, 200); println!(\u0026#34;{}, {}\u0026#34;, p.0, p.1); //=\u0026gt; 100, 200 通常のタプルと同様に、各フィールドの値を別々の変数に展開することができます。 // 各フィールドの値を別々の変数（x と y）に展開 let Point(x, y) = p; println!(\u0026#34;{x}, {y}\u0026#34;); //=\u0026gt; 100, 200 構造体のデバッグ出力 構造体を定義するときに #[derive(Debug)] という属性を付けておくと（あるいは Debug トレイト を自力で実装しておくと）、println! マクロで、{:?} により構造体の内容をデバッグ出力できるようになります（複数行で整形して出力したいときは {:?} の代わりに {:#?} を使用します）。 #[derive(Debug)] struct Point { x: i32, y: i32, } let p = Point { x: 100, y: 200 }; println!(\u0026#34;{:?}\u0026#34;, p); println!(\u0026#34;{:#?}\u0026#34;, p); 出力結果 Point { x: 100, y: 200 } Point { x: 100, y: 200, } 構造体のメソッドを実装する 構造体のメソッドは、impl ブロック内で定義します。 メソッドの第 1 引数は、構造体インスタンスの参照を示す \u0026amp;self になります（Python の文法と似ています）。 構造体の型は明らかなので、\u0026amp;self に型を指定する必要はありません。 struct Rect { width: u32, height: u32, } // Rect のメソッドを実装する impl Rect { fn area(\u0026amp;self) -\u0026gt; u32 { self.width * self.height } } let r = Rect { width: 5, height: 2 }; println!(\u0026#34;{}\u0026#34;, r.area()); //=\u0026gt; 10 構造体のフィールドを変更したい場合は、メソッドの第 1 引数を \u0026amp;mut self にします。 このメソッドを呼び出す場合は、構造体のインスタンスを生成するときに let mut を使わなければいけないことに注意してください。 impl Rect { // 自身のフィールドの内容を変更するメソッド fn double(\u0026amp;mut self) { self.width *= 2; self.height *= 2; } } let mut r = Rect { width: 5, height: 2 }; r.double(); 関連関数 (associated function) impl ブロック内で \u0026amp;self（や \u0026amp;mut self）を第 1 引数に取らない関数を定義すると、その構造体の 関連関数 (associated function) として扱われます。 他の言語では static メソッドと呼ばれているもので、呼び出し時にインスタンスを必要としません。 関連関数を呼び出すには 構造体名::関数名 という構文を使用します（C++ の static メソッドと同様です）。 関連関数としてファクトリ関数を定義する struct Point { x: f64, y: f64, } impl Point { // 関連関数 (静的メソッド）の定義 fn origin() -\u0026gt; Point { Point { x: 0.0, y: 0.0 } } } // 関連関数を呼び出す let p = Point::origin(); 上の例では origin 関数の戻り値の型を Point としていますが、次のように Self というキーワードを使うことで、impl 対象の構造体の型が指定されたものとみなされます。 impl Point { fn origin() -\u0026gt; Self { Point { x: 0.0, y: 0.0 } } }"},{url:"/p/7r3cmv6/",title:"Rust の文法: 配列 (array) とタプル (tuple)",date:"2023-02-13T00:00:00Z",body:"Rust の文法: 配列 (array) とタプル (tuple) 配列 (array) 配列の基本 Rust の配列は、多くの言語と同様に [] を使って生成することができます。 配列の要素の型はすべて同一である必要があり、配列サイズ（要素数）は不変です。 要素数をあらかじめ固定できない場合は、配列の代わりに ベクター (Vec) 型 を使います。 let arr = [0, 1, 2]; // [i32; 3] let arr = [\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;]; // [\u0026amp;str; 3] let arr = [true, false, true]; // [bool; 3] 要素の参照は、C/C++ と同様に 0 始まりのインデックス指定で行えます (arr[0])。 配列のサイズ（要素数）は arr.len() で取得できます。 let arr = [\u0026#39;あ\u0026#39;, \u0026#39;い\u0026#39;, \u0026#39;う\u0026#39;]; println!(\u0026#34;{}, {}, {}\u0026#34;, arr[0], arr[1], arr[2]); // あ, い, う println!(\u0026#34;len={}\u0026#34;, arr.len()); // len=3 可変配列 (mutable array) 要素を変更可能にしたいときは、次のように let mut で配列を定義します。 可変というのは、ある位置の値を変更できるという意味であって、配列のサイズや型を変更することはできないことに注意してください。 let mut arr = [\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;]; arr[1] = \u0026#34;XXX\u0026#34;; println!(\u0026#34;{:?}\u0026#34;, arr); //=\u0026gt; [\u0026#34;AAA\u0026#34;, \u0026#34;XXX\u0026#34;, \u0026#34;CCC\u0026#34;] 次のように、すべての要素をまとめて入れ替えることもできますが、同じ型＆サイズの配列を代入しなければいけません。 let mut arr = [1, 2, 3]; // [i32; 3] 型の変数 println!(\u0026#34;{:?}\u0026#34;, arr); //=\u0026gt; [1, 2, 3] arr = [4, 5, 6]; // [i32; 3] 型の配列であれば代入できる println!(\u0026#34;{:?}\u0026#34;, arr); //=\u0026gt; [4, 5, 6] 配列のサイズを指定して初期化 セミコロン (;) を使った特殊な構文を使うと、要素の初期値とサイズを指定して配列を生成することができます。 初期値 ABCDE が 3 つ含まれる配列を生成 let arr = [\u0026#34;ABCDE\u0026#34;; 3]; println!(\u0026#34;{:?}\u0026#34;, arr); //=\u0026gt; [\u0026#34;ABCDE\u0026#34;, \u0026#34;ABCDE\u0026#34;, \u0026#34;ABCDE\u0026#34;] タプル (tuple) タプルの基本 タプルは任意の数のフィールドを持つことができる複合型です。 配列と似ていますが、タプルでは各フィールドの型が異なっていても構いません。 let t = (\u0026#34;AAA\u0026#34;, 100, \u0026#39;x\u0026#39;); // 型は推測されるので下記と同様 let t: (\u0026amp;str, i32, char) = (\u0026#34;AAA\u0026#34;, 100, \u0026#39;x\u0026#39;); 各フィールドを参照するには、t.0、t.1、t.2 のように、ドットの後にインデックス番号を指定します。 配列とは異なり、変数に格納されたインデックス番号を使用することはできません（t.index のようには書けません）。 println!(\u0026#34;{}, {}, {}\u0026#34;, t.0, t.1, t.2); //=\u0026gt; AAA, 100, x // まとめて出力する場合は次のようにすると楽 println!(\u0026#34;{:?}\u0026#34;, t); //=\u0026gt; (\u0026#34;AAA\u0026#34;, 100, x) 可変タプル (mutable tuple) 配列と同様、タプルも let mut を付けて定義することで、各フィールドの値を可変にすることができます。 ただし、各フィールドの「型」は変更できないことに注意してください。 let mut t = (\u0026#34;AAA\u0026#34;, 100, \u0026#39;x\u0026#39;); t.0 = \u0026#34;BBB\u0026#34;; t.1 = 200; t.2 = \u0026#39;y\u0026#39;; タプルの分解 次のようにして、タプルの各要素を別々の変数に格納することができます。 let t = (\u0026#34;AAA\u0026#34;, 100, \u0026#39;x\u0026#39;); let (x, y, z) = t; // タプルの分解 println!(\u0026#34;{}, {}, {}\u0026#34;, x, y, z); //=\u0026gt; AAA, 100, x 空タプル (empty tuple) = ユニット (unit) Rust では、値がないことを示す型（値）として、空タプル () が使われます。 これは、1 つもフィールドを持たないタプルで、値も型も () と記述します。 C/C++ void に相当するもので、ユニット (unit) とも呼ばれます。 戻り値を持たない関数は空タプルを返します。 空のブロック ({}) も空タプルを返します。 次の a、b、c はすべて空タプルになります。 let a = (); // 明示的な空タプル let b = {}; // 評価後の値がないブロック let c = (|| {})(); // 戻り値のないクロージャの呼び出し println!(\u0026#34;{:?} {:?} {:?}\u0026#34;, a, b, c); //=\u0026gt; () () () 戻り値を持たない関数を定義するとき戻り値の型は省略できますが、明示的に -\u0026gt; () と記述することもできます。 // 関数 foo と bar は戻り値を持たない （= 空タプルを返す） fn foo() {} fn bar() -\u0026gt; () {} println!(\u0026#34;{:?}\u0026#34;, foo()); // () println!(\u0026#34;{:?}\u0026#34;, bar()); // ()"},{url:"/p/w6cjckc/",title:"WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh)",date:"2023-02-01T00:00:00Z",body:"WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh) 別 PC から WSL2 内のサーバーへのアクセス Windows の WSL2 環境で Docker コンテナを動かしているとき、そこで起動した Web サーバーなどへは、LAN 内の別 PC からはデフォルトではアクセスできません。 LAN 内の別 PC ---\u0026gt; Windows ---\u0026gt; WSL2 (Docker) このようなアクセスを許可するには、Windows のコマンドプロンプトを管理者として実行し、次のように netsh interface portproxy コマンドでポートフォワード設定をしてやる必要があります。 netsh ユーティリティ（ネットワークサービスシェル）は、Windows 上の様々なネットワーク構成を設定／参照するためのコマンドです。 Windows のポートフォワード設定を追加する C:\\\u0026gt; netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=80 connectaddress=172.28.72.28 connectport=80 上記の例では、外部からの Windows の 80 番ポートへのアクセス (0.0.0.0:80) を、WSL2 の 80 番ポート（この例では 172.28.72.28:80）へ転送するように設定しています。 現在のポートフォワード設定 (portproxy) は次のように確認できます。 Windows のポートフォワード設定を確認する C:\\\u0026gt; netsh interface portproxy show all ipv4 をリッスンする: ipv4 に接続する: Address Port Address Port --------------- ---------- --------------- ---------- 0.0.0.0 80 172.28.72.28 80 必要のなくなったポートフォワード設定は、次のように削除できます（Windows を再起動することでも削除できます）。 削除するときは、転送元のアドレスとポートを指定するだけで OK です。 Windows のポートフォワード設定を削除する C:\\\u0026gt; netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=80 ちなみに、転送先となる WSL2 の IP アドレスは、WSL2 側の bash シェルで、ip a コマンドで調べることができます。 通常は eth0 デバイスに割り当てられた IPv4 アドレス (inet) の部分を参照すれば OK です。 WSL2 の IP アドレスを調べる maku@win:/mnt/c$ ip a show dev eth0 6: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:15:5d:93:85:2c brd ff:ff:ff:ff:ff:ff inet 172.28.72.28/20 brd 172.28.79.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::215:5dff:fe93:852c/64 scope link valid_lft forever preferred_lft forever Windows 側から直接実行したい場合は、wsl -e コマンドが使えます。 C:\\\u0026gt; wsl -e ip a show dev eth0 適当な Web サーバーコンテナを起動して試してみる 今回の構成で接続テストするには、次のように WSL2 側で軽量な nginx コンテナを立ち上げてしまうのがお手軽です。 # Windows から WSL2 の bash シェルを起動 C:\\\u0026gt; bash # WSL2 側で Docker デーモンを起動 maku@win:/mnt/c$ sudo service docker start # nginx コンテナを起動 maku@win:/mnt/c$ docker container run --rm -p 8000:80 nginx:alpine-slim ここでは、コンテナを -p 8000:80 オプション付きで起動し、ホスト側の localhost:8000 へのアクセスを、コンテナの 80 番ポートに転送するよう設定しています。 この状態で、Windows 上のブラウザから http://localhost:8000/ を開くと、WSL2 側の Web サーバーにアクセスできるはずです（WSL2 では、デフォルトで Windows 側の localhost へのアクセスを、WSL2 側に転送してくれるようになりました）。 ただし、この時点では、外部の PC からはまだアクセスできません。 次のように Windows 上でポートフォワード設定を追加する必要があります。 # 管理者権限でコマンドプロンプトを開いてポートフォワード設定 C:\\\u0026gt; netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=8000 connectaddress=172.28.72.28 connectport=8000 ここでのポイントは、転送先のポート番号を 8000 と指定するところです (connectport=8000)。 80 番ポートを使っているのは、あくまで WSL2 の中の Docker コンテナなので、外側からのアクセスには、コンテナ起動時に公開した 8000 番ポートの方を使う必要があります。 これで、外部の PC から WSL2 内の Docker サーバーへアクセスできます（例えば、192.168.1.100:8000 などで）。 ٩(๑❛ᴗ❛๑)۶ わーぃ 将来的には Windows のポートフォワード設定がいらなくなる？ 下記のマイクロソフトのページに、Microsoft は、このエクスペリエンスを改善する方法を検討しています という記載があります（2023-01 時点）。 毎回、netsh でポートフォワード設定を行うのはさすがに面倒なので、この改善が早く実装されるとよいですね。 WSL を使用したネットワーク アプリケーションへのアクセス | Microsoft Learn"},{url:"/p/eefwaa3/",title:"Rust でハッシュマップ型 (HashMap) を扱う",date:"2023-01-25T00:00:00Z",body:"Rust でハッシュマップ型 (HashMap) を扱う ハッシュマップの基本 Rust の標準ライブラリとして、キー＆バリューのコレクションを扱うハッシュマップ型 (HashMap\u0026lt;K, V\u0026gt;) が用意されています。 下記は、空のハッシュマップを作成し、キー＆バリューを追加／取得する例です。 use std::collections::HashMap; let mut map = HashMap::new(); map.insert(String::from(\u0026#34;AAA\u0026#34;), 100); map.insert(String::from(\u0026#34;BBB\u0026#34;), 200); map.insert(String::from(\u0026#34;CCC\u0026#34;), 300); println!(\u0026#34;{:?}\u0026#34;, map.get(\u0026#34;AAA\u0026#34;)); //=\u0026gt; Some(100) println!(\u0026#34;{:?}\u0026#34;, map.get(\u0026#34;ZZZ\u0026#34;)); //=\u0026gt; None 上記の例では、HashMap の型パラメーターを省略していますが、insert しているデータから、キーの型は String、値の型は i32 と推測されます。 HashMap のキーの型が String であっても、get メソッドの引数には \u0026amp;str を渡せるようになっています。 ハッシュマップの生成方法 空のハッシュマップを生成する (new, with_capacity) let mut map: HashMap\u0026lt;String, i32\u0026gt; = HashMap::new(); let mut map: HashMap\u0026lt;String, i32\u0026gt; = HashMap::with_capacity(100) 空のマップは new で生成できますが、あらかじめ格納する要素数を想定できるときは with_capacity を使うと効率的です。 HashMap 型には、Vec 型の vec! のようなインスタンス生成用のマクロは用意されていないので、これらの関数を使ってインスタンスを生成する必要があります。 空のハッシュマップには何らかのデータを詰める必要があるので、通常は mutable な変数として定義します。 コンパイラーが、格納するデータから型を推測してくれるので、ほとんどのケースで型情報 (: HashMap\u0026lt;String, i32\u0026gt;) を省略できます。 let mut map = HashMap::new(); let mut map = HashMap::with_capacity(100) タプル（キーと値）のベクターから生成する use std::collections::HashMap; let kv_pairs = vec![ (String::from(\u0026#34;AAA\u0026#34;), 100), (String::from(\u0026#34;BBB\u0026#34;), 200), (String::from(\u0026#34;CCC\u0026#34;), 300), ]; let map: HashMap\u0026lt;_, _\u0026gt; = kv_pairs.into_iter().collect(); このケースでは、collect メソッドに、HashMap 型としてまとめ上げることを知らせるために、HashMap\u0026lt;_, _\u0026gt; という型情報の指定が必要になります。 キーの型と値の型はコンパイラに推測してもらうので、_ とだけ記述しておけば OK です。 HashMap の extend メソッドを使う方法もあります。 use std::collections::HashMap; let vec = vec![(\u0026#34;AAA\u0026#34;, 100), (\u0026#34;BBB\u0026#34;, 200), (\u0026#34;CCC\u0026#34;, 300)]; let mut map = HashMap::new(); map.extend(vec); キーのベクターと値のベクターから生成する use std::collections::HashMap; let keys = vec![String::from(\u0026#34;AAA\u0026#34;), String::from(\u0026#34;BBB\u0026#34;), String::from(\u0026#34;CCC\u0026#34;)]; let values = vec![100, 200, 300]; let map: HashMap\u0026lt;_, _\u0026gt; = keys.iter().zip(values.iter()).collect(); 要素の追加と削除 (insert, remove) HashMap への要素の追加は insert、削除は remove メソッドで行います。 すでに存在するキーに対して insert を実行すると、古い値が上書きされます。 存在しないキーに対して remove を実行した場合は無視されます。 use std::collections::HashMap; let mut map = HashMap::new(); map.insert(String::from(\u0026#34;AAA\u0026#34;), 100); map.insert(String::from(\u0026#34;AAA\u0026#34;), 0); // 上書きする map.insert(String::from(\u0026#34;BBB\u0026#34;), 200); map.remove(\u0026#34;BBB\u0026#34;); // 削除する（BBB が削除される） map.remove(\u0026#34;CCC\u0026#34;); // 削除する（何も起こらない） println!(\u0026#34;{:?}\u0026#34;, map); //=\u0026gt; {\u0026#34;AAA\u0026#34;: 0} remove メソッドは、Option 型 を返すようになっており、削除されたキーに対応する値を取得することができます。 存在しないキーを指定した場合（何も削除されなかった場合）は、None を返します。 if let Some(val) = map.remove(\u0026#34;AAA\u0026#34;) { println!(\u0026#34;削除された値は {} です\u0026#34;, val); } キーに対応する値を取得する (get) HashMap#get メソッドで、指定したキーに対応する値を取得することができます。 戻り値は Option 型 で返されるため、指定されたキーが存在するかを調べつつ値を取り出すことができます。 // HashMap を作成する let mut map = HashMap::new(); map.insert(String::from(\u0026#34;AAA\u0026#34;), 100); // キーに対応する値を取得する let key = String::from(\u0026#34;AAA\u0026#34;); if let Some(val) = map.get(\u0026amp;key) { println!(\u0026#34;{} の値は {} です\u0026#34;, \u0026amp;key, val); } else { println!(\u0026#34;{} が見つかりません\u0026#34;, \u0026amp;key); } 全ての要素をループ処理する HashMap の要素（キー＆バリュー）を 1 つずつ取り出して処理したいときは、iter メソッドを使用します。 let mut map = HashMap::new(); map.insert(String::from(\u0026#34;AAA\u0026#34;), 100); map.insert(String::from(\u0026#34;BBB\u0026#34;), 200); map.insert(String::from(\u0026#34;CCC\u0026#34;), 300); // HashMap::iter() は (\u0026amp;\u0026#39;a key, \u0026amp;\u0026#39;a value) を順不同で返す for (key, value) in map.iter() { println!(\u0026#34;{} =\u0026gt; {}\u0026#34;, key, value); } 実行結果 CCC =\u0026gt; 300 AAA =\u0026gt; 100 BBB =\u0026gt; 200 ループしながら値を書き換えたいときは、iter の代わりに iter_mut を使用して、値への可変参照を取得します。 // HashMap::iter_mut() は (\u0026amp;\u0026#39;a key, \u0026amp;\u0026#39;a mut value) を順不同で返す for (key, value) in map.iter_mut() { *value += 1; println!(\u0026#34;{} の値に 1 を足して {} にしました\u0026#34;, key, value); } 実行結果 BBB の値に 1 を足して 201 にしました CCC の値に 1 を足して 301 にしました AAA の値に 1 を足して 101 にしました キーが見つからない場合に値をセットする (or_insert) // HashMap の作成 let mut map = HashMap::new(); map.insert(String::from(\u0026#34;AAA\u0026#34;), 100); // 指定したキーが存在しなければ新しい値をセットする map.entry(String::from(\u0026#34;AAA\u0026#34;)).or_insert(0); map.entry(String::from(\u0026#34;BBB\u0026#34;)).or_insert(0); println!(\u0026#34;{}\u0026#34;, map.get(\u0026#34;AAA\u0026#34;).unwrap()); //=\u0026gt; 100 println!(\u0026#34;{}\u0026#34;, map.get(\u0026#34;BBB\u0026#34;).unwrap()); //=\u0026gt; 0 or_insert は可変参照を返すので、取り出した値を利用して自分自身の値を書き換えることができます。 次の例では、単語の出現数をカウントしています。 let text = \u0026#34;AAA BBB CCC BBB AAA\u0026#34;; let mut word_count = HashMap::new(); for word in text.split_whitespace() { let count = word_count.entry(word).or_insert(0); *count += 1; } println!(\u0026#34;{:?}\u0026#34;, word_count); //=\u0026gt; {\u0026#34;AAA\u0026#34;: 2, \u0026#34;BBB\u0026#34;: 2, \u0026#34;CCC\u0026#34;: 1} 整数型 (i32) のデフォルト値は 0 なので、or_insert(0) の代わりに or_default() を使うこともできます。"},{url:"/p/4ye2eah/",title:"Rust で Excel ファイルを読み込む (calamine)",date:"2023-01-20T00:00:00Z",body:"Rust で Excel ファイルを読み込む (calamine) calamine とは Rust の calamine クレートは、Excel ファイルを読み込むためのライブラリです。 calamine - Rust tafia/calamine: A pure Rust Excel/OpenDocument SpeadSheets file reader: rust on metal sheets 読み込み専用 (read-only) のライブラリですが、ピュアな Rust 実装で軽量です。 作者の tafia (Johann Tuffe) 氏によると、「書き込み (write) はめっちゃ複雑だから対応しないよ。セルのアップデートくらいなら対応するかもね」とのこと。 Rust プロジェクトで次のように依存関係を追加すれば準備完了です。 $ cargo add calamine 以下、Excel ファイルを読み込むサンプルコードです。 ワークシート名のリストを取得する (Xlsx#sheet_names) open_workbook で Excel ファイルを開いて、Xlsx インスタンスを取得するところがすべての始まりです。 Xlsx#sheet_names メソッドで、ワークシート名の一覧を取得できます。 use calamine::{Reader, Xlsx}; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let workbook: Xlsx\u0026lt;_\u0026gt; = calamine::open_workbook(\u0026#34;sample.xlsx\u0026#34;)?; let sheet_names = workbook.sheet_names(); println!(\u0026#34;{:?}\u0026#34;, sheet_names); Ok(()) } 出力例 [\u0026#34;Sheet1\u0026#34;, \u0026#34;Sheet2\u0026#34;] ワークシートを読み込む (Xlsx#worksheet_range, worksheet_range_at) Xlsx#worksheet_range メソッドで、ワークシート内のデータ（セル）を読み込むことができます。 このようにデータを読み込む場合は、open_workbook で Excel ファイルを開くときに、mutable 変数で受け取る必要があることに注意してください（ワークシートの情報を内部に展開するため）。 use calamine::{Reader, Xlsx}; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { let mut workbook: Xlsx\u0026lt;_\u0026gt; = calamine::open_workbook(\u0026#34;sample.xlsx\u0026#34;)?; // Sheet1 という名前のワークシートを読み込む if let Some(Ok(range)) = workbook.worksheet_range(\u0026#34;Sheet1\u0026#34;) { println!(\u0026#34;{:?}\u0026#34;, range); // range は Range\u0026lt;DataType\u0026gt; インスタンス } Ok(()) } 出力例（A1～B2 のセルがある場合） Range { start: (0, 0), end: (1, 1), inner: [String(\u0026#34;A1セル\u0026#34;), String(\u0026#34;B1セル\u0026#34;), String(\u0026#34;A2セル\u0026#34;), String(\u0026#34;B2セル\u0026#34;)] } ワークシート名ではなく、インデックスでワークシートを指定したいときは、worksheet_range の代わりに worksheet_range_at メソッドを使います。 if let Some(Ok(range)) = workbook.worksheet_range_at(0) { println!(\u0026#34;{:?}\u0026#34;, range); } 値を持つセルの範囲を取得する (Range#get_size) Range#get_size メソッドで、ワークシート内のどの範囲（行／列）にセルが存在するかを調べることができます。 上記方法で、Range オブジェクトを取得済みと想定しています。 // range は Range\u0026lt;DataType\u0026gt; インスタンス println!(\u0026#34;rows = {}\u0026#34;, range.get_size().0); println!(\u0026#34;cols = {}\u0026#34;, range.get_size().1); 出力例 1000 30 1 行ずつループ処理する (Range#rows) ここで使用する Excel ファイル (sample.xlsx) の内容は、次のようになっていると想定します。 （空）と書いてあるのは空白セルです。 つまり、3 行 x 3 列で、歯抜けのセルが含まれたワークシートです。 A1セルB1セル（空） A2セルB2セルC2セル （空）B3セル（空） Range オブジェクトの rows メソッドを使って、次のように 1 行ずつループ処理することができます。 各行のカラム数は len() メソッドで取得できますが、この値は最も多くのカラムを含む行に合わせた値になるようです（今回の sample.xlsx では、すべての行のカラム数が 3 になる）。 let mut workbook: Xlsx\u0026lt;_\u0026gt; = calamine::open_workbook(\u0026#34;sample.xlsx\u0026#34;)?; if let Some(Ok(range)) = workbook.worksheet_range_at(0) { for row in range.rows() { println!(\u0026#34;len={}, row={:?}, row[0]={:?}\u0026#34;, row.len(), row, row[0]); } } 出力例 len=3, row=[String(\u0026#34;A1セル\u0026#34;), String(\u0026#34;B1セル\u0026#34;), Empty], row[0]=String(\u0026#34;A1セル\u0026#34;) len=3, row=[String(\u0026#34;A2セル\u0026#34;), String(\u0026#34;B2セル\u0026#34;), String(\u0026#34;C2セル\u0026#34;)], row[0]=String(\u0026#34;A2セル\u0026#34;) len=3, row=[Empty, String(\u0026#34;B3セル\u0026#34;), Empty], row[0]=Empty 空のセルは、DataType 列挙型の Empty バリアントとして表現されます。 ループ時に行のインデックスが欲しければ、enumerate と組み合わせて次のようにします。 for (row_index, row) in range.rows().enumerate() { println!(\u0026#34;{}: {:?}\u0026#34;, row_index, row); } 出力例 0: [String(\u0026#34;A1セル\u0026#34;), String(\u0026#34;B1セル\u0026#34;), Empty] 1: [String(\u0026#34;A2セル\u0026#34;), String(\u0026#34;B2セル\u0026#34;), String(\u0026#34;C2セル\u0026#34;)] 2: [Empty, String(\u0026#34;B3セル\u0026#34;), Empty] すべてのセルを取り出す (Range#cells) Range 内のセルを、行単位ではなくまとめて取得したいときは、Range#cells メソッドを使用します。 let cells = range.cells(); // Cells\u0026lt;DataType\u0026gt; println!(\u0026#34;セルの数 = {}\u0026#34;, cells.len()); for cell in cells { let row = cell.0; let col = cell.1; let data = cell.2; println!(\u0026#34;[{}, {}] = {}\u0026#34;, row, col, data); } 出力例 セルの数 = 9 [0, 0] = A1セル [0, 1] = B1セル [0, 2] = [1, 0] = A2セル [1, 1] = B2セル [1, 2] = C2セル [2, 0] = [2, 1] = B3セル [2, 2] = 各セルの値 (cell.2) は、DataType という列挙型で表現されており、各バリアントで異なるタイプのデータを保持するようになっています。 match 式を使えば、含まれているデータのタイプに応じて分岐処理することができます。 for cell in range.cells() { print!(\u0026#34;[{}, {}] = \u0026#34;, cell.0, cell.1); // セルの位置を表示 match cell.2 { DataType::Empty =\u0026gt; println!(\u0026#34;空っぽのセルです\u0026#34;), DataType::String(s) =\u0026gt; println!(\u0026#34;{} という文字列セルです\u0026#34;, s), DataType::Int(n) =\u0026gt; println!(\u0026#34;{} という整数値セルです\u0026#34;, n), DataType::Float(f) =\u0026gt; println!(\u0026#34;{} という浮動小数点数セルです\u0026#34;, f), DataType::Bool(b) =\u0026gt; println!(\u0026#34;{} という真偽値セルです\u0026#34;, b), DataType::DateTime(d) =\u0026gt; println!(\u0026#34;{} という日時セルです\u0026#34;, d), DataType::Error(e) =\u0026gt; println!(\u0026#34;ERROR: {}\u0026#34;, e), } } 出力例 [0, 0] = A1セル という文字列セルです [0, 1] = B1セル という文字列セルです [0, 2] = 空っぽのセルです [1, 0] = A2セル という文字列セルです [1, 1] = B2セル という文字列セルです [1, 2] = C2セル という文字列セルです [2, 0] = 空っぽのセルです [2, 1] = B3セル という文字列セルです [2, 2] = 空っぽのセルです 空セルや文字列セルかどうかを調べる専用のメソッドも用意されています。 let data = cell.2; println!(\u0026#34;is_empty = {}\u0026#34;, data.is_empty()); println!(\u0026#34;is_string = {}\u0026#34;, data.is_string()); 文字列セルの場合だけ、その文字列を取り出しつつ処理したい場合は、DataType#get_string メソッドで Option\u0026lt;\u0026amp;str\u0026gt; を取得します。 let data = cell.2; if let Some(s) = data.get_string() { println!(\u0026#34;文字列セルの値: {}\u0026#34;, s); } 単一のセルの値を取得する (Range#get_value, get) Range#get_value メソッドで、指定した行・列のセルの値を取得することができます。 戻り値は Option\u0026lt;\u0026amp;DataType\u0026gt; 型になっており、空セルの場合は Option::None が返されます。 let cell = range.get_value((0, 1)); // Option\u0026lt;\u0026amp;DataType\u0026gt; println!(\u0026#34;{:?}\u0026#34;, cell); //=\u0026gt; Some(String(\u0026#34;Hello\u0026#34;))"},{url:"/p/bdp2doy/",title:"Rust でコマンドライン引数を扱う (2) clap クレート",date:"2023-01-12T00:00:00Z",body:"Rust でコマンドライン引数を扱う (2) clap クレート clap とは？ clap クレート は、コマンドライン引数のパーサーライブラリで、次のような機能を備えています。 一般的なオプション形式（-a や --name val）や、サブコマンド形式の引数のパース ヘルプ出力 (usage) の自動生成 シェル用の入力補完スクリプト生成（clap_complete クレート） derive マクロにより多くのボイラプレートコードを自動生成してくれるので、コードをシンプルに保ちつつ、高度なコマンドライン引数処理を行うことができます。 clap を使う準備 clap クレートを使うために、最初に Cargo.toml に依存関係を追加しておきます。 clap クレートを使う準備 $ cargo add clap --features derive derive マクロを有効にするために、--features derive オプションが必要です。 次のように依存関係が追加されていれば OK です。 Cargo.toml [dependencies] clap = \u0026#34;4.0.32\u0026#34; clap の基本 任意の構造体定義に、clap が提供する #[derive(Parser)] マクロを付加することで、コマンドライン引数用のバッファとして使えるようになります。 src/main.rs use clap::Parser; /// ヘルプ出力の最初に表示されるテキスト #[derive(Parser)] struct Args { /// 1 番目のパラメーターの説明として表示されるテキスト first: String, /// 2 番目のパラメーターの説明として表示されるテキスト second: u32, } fn main() { let args = Args::parse(); println!(\u0026#34;{:?}, {:?}\u0026#34;, \u0026amp;args.first, \u0026amp;args.second); } 上記のように定義した Args 構造体は、自動的に parse メソッドを備えるようになり、これを main 関数で呼び出すことで、コマンドライン引数をパースしてフィールドに格納してくれます。 下記は、正しくコマンドライン引数を指定した場合の実行結果です。 実行例 $ ./myapp aaa 100 \u0026#34;aaa\u0026#34;, 100 ☝️ cargo コマンドで起動する場合 上記の実行例は、myapp という名前の実行ファイルを生成したと想定しています。 cargo コマンドで直接実行する場合は、次のような感じでコマンドライン引数を指定します。 $ cargo -q run -- aaa 100 -q オプションは Cargo の冗長なメッセージを抑制するもので、-- はそれ以降のコマンドライン引数をプログラム側に渡すことを示しています。 構造体の first フィールドに \u0026quot;aaa\u0026quot; という文字列が格納され、second フィールドに 100 という数値が格納されています。 second フィールドは、u32 型として定義されているので、ユーザーが数値以外を入力すると、clap はヘルプメッセージを出力してプログラムを終了 (Error#exit) します。 メッセージの内容は clap が自動生成してくれます。 不正なコマンドライン引数を指定した場合 $ ./myapp aaa bbb error: Invalid value \u0026#39;bbb\u0026#39; for \u0026#39;\u0026lt;SECOND\u0026gt;\u0026#39;: invalid digit found in string For more information try \u0026#39;--help\u0026#39; これだけでも十分に便利ですが、clap はさらに -h や --help オプションを自動で実装してくれます。 表示されるヘルプメッセージは、構造体のドキュメンテーションコメント (///) の記述から自動生成されます。 実行例 $ ./myapp --help ヘルプ出力の最初に表示されるテキスト Usage: myapp \u0026lt;FIRST\u0026gt; \u0026lt;SECOND\u0026gt; Arguments: \u0026lt;FIRST\u0026gt; 1 番目のパラメーターの説明として表示されるテキスト \u0026lt;SECOND\u0026gt; 2 番目のパラメーターの説明として表示されるテキスト Options: -h, --help Print help information Linux スタイルのコマンドライン引数 -f や --foo のような Linux スタイルのコマンドライン引数を定義するには、構造体のフィールドに #[arg(short, long)] 属性を付加します。 /// Simple program to greet a person #[derive(Parser)] struct Args { /// Name of the person to greet #[arg(short, long)] name: String, /// Number of times to greet #[arg(short, long)] count: u8, /// Run in debug mode #[arg(short, long)] debug: bool, } デフォルトでは、構造体のフィールド名 (name) から、-n や --name といったオプションが自動生成されます。 $ ./myapp --help Simple program to greet a person Usage: myapp --name \u0026lt;NAME\u0026gt; --count \u0026lt;COUNT\u0026gt; Options: -n, --name \u0026lt;NAME\u0026gt; Name of the person to greet -c, --count \u0026lt;COUNT\u0026gt; Number of times to greet -d, --debug Run in debug mode -h, --help Print help information 他にも次のような属性指定が可能です。 #[arg(short)] \u0026hellip; 短い形式のオプション (-n) のみ生成します。 #[arg(long)] \u0026hellip; 長い形式のオプション (--name) のみ生成します。 #[arg(short = 'x')] \u0026hellip; 短い形式のオプション名を -x に変更します。 #[arg(long = \u0026quot;xyz\u0026quot;)] \u0026hellip; 短い形式のオプション名を --xyz に変更します。 省略可能なパラメーターとデフォルト値 構造体のフィールドの型を Option 列挙型 として定義すると、そのコマンドライン引数は省略可能になります。 #[derive(Parser)] struct Args { /// Name of the person to greet #[arg(short, long)] name: Option\u0026lt;String\u0026gt;, /// Number of times to greet #[arg(short, long)] count: Option\u0026lt;u8\u0026gt;, /// Run in debug mode #[arg(short, long)] debug: Option\u0026lt;bool\u0026gt;, } ユーザーがコマンドライン引数を指定しなかった場合、対応するフィールドの値は Option::None となります。 fn main() { let args = Args::parse(); match \u0026amp;args.name { Some(name) =\u0026gt; println!(\u0026#34;Hello, {}\u0026#34;, name), None =\u0026gt; println!(\u0026#34;Who are you?\u0026#34;), } } bool 型のフィールドに関しては、Option 型にしなくても省略可能なフラグとして機能します。 ユーザーがこのフラグを指定しなかった場合は、デフォルト値として false が格納されます。 #[derive(Parser)] struct Args { /// Run in debug mode #[arg(short, long)] debug: bool, } 次のように default_value でデフォルト値を設定しておくこともできます。 この場合も、フィールドを Option 型にする必要はありません。 #[derive(Parser)] struct Args { /// Name of the person to greet #[arg(short, long, default_value = \u0026#34;John Doe\u0026#34;)] name: String, } Linux 形式ではないコマンドライン引数 (positional arguments) も通常は必須のコマンドライン引数として扱われますが、Optional 型にするか、デフォルト値を指定することで、省略可能にすることができます。 #[derive(Debug, Parser)] struct Args { /// Input file name input: Option\u0026lt;String\u0026gt;, /// Output file name #[arg(default_value = \u0026#34;output.txt\u0026#34;)] output: String, } 特定の値だけ指定できるようにする (ValueEnum) 決められた値のいずれかのみを指定できるオプションを定義するには、ValueEnum 使って次のようにします。 ここでは、--format オプションで json、yaml、toml のいずれかを指定できるように実装しています。 ユーザーが --format オプションを指定しなかった場合は、デフォルトで json が使われます。 use clap::{Parser, ValueEnum}; #[derive(Parser)] struct Args { /// Output format #[arg(short, long)] #[clap(value_enum, default_value_t=Format::Json)] format: Format, } #[derive(ValueEnum, Clone, Debug)] enum Format { Json, Yaml, Toml, } fn main() { let args = Args::parse(); println!(\u0026#34;format = {:?}\u0026#34;, args.format); } ヘルプもそれっぽい内容で表示してくれます。 $ ./myapp --help Usage: myapp [OPTIONS] Options: -f, --format \u0026lt;FORMAT\u0026gt; Output format [default: json] [possible values: json, yaml, toml] -h, --help Print help information ヘルプ表示のカスタマイズ 値のプレースホルダー名 (value_name) 値を持つパラメーターの場合、ヘルプ表示においてその値の部分は \u0026lt;フィールド名\u0026gt; というプレースホルダで表示されますが、その表示は value_name でカスタマイズできます。 #[derive(Parser)] struct Args { /// Input file name #[arg(short, long, value_name = \u0026#34;PATH\u0026#34;)] input: PathBuf, } 上記のように指定すると、ヘルプ表示で --input \u0026lt;INPUT\u0026gt; と表示されていた部分が、--input \u0026lt;PATH\u0026gt; という表示に変わります。 ヘルプ表示例 $ cargo fmt \u0026amp;\u0026amp; cargo -q run -- -h Usage: hello --input \u0026lt;PATH\u0026gt; Options: -i, --input \u0026lt;PATH\u0026gt; Input file name -h, --help Print help information 詳細説明 アプリケーションや各パラメーターの詳細説明は次のように記述します。 /// My app /// /// Long long long description. /// Long long long description. /// Long long long description. #[derive(Parser)] struct Args { /// Your name /// /// Long long long description. /// Long long long description. /// Long long long description. name: String, } この詳細説明を表示するには、--help オプションを指定してプログラムを起動します（-h では表示されません）。 $ ./myapp --help My app Long long long description. Long long long description. Long long long description. Usage: myapp \u0026lt;NAME\u0026gt; Arguments: \u0026lt;NAME\u0026gt; Your name Long long long description. Long long long description. Long long long description. Options: -h, --help Print help information (use `-h` for a summary)"},{url:"/p/xdyk5o8/",title:"Rust で JSON フォーマットを扱う (serde)",date:"2023-01-09T00:00:00Z",body:"Rust で JSON フォーマットを扱う (serde) Serde とは？ Rust の serde クレート は、Rust プログラム内で定義したユーザー型（struct や enum）を、JSON や YAML、BSON といった様々なデータ形式にシリアライズ／デシリアライズするためのライブラリです。 Serde という名前は、Serialize ＋ Deserialize から来ています。 発音は、すぁーでぃ です。 Serde website serde API documentation Serde を使う準備 Serde を使うためには、ベースとなる serde クレートに加えて、扱いたいデータフォーマット用のクレート（Serializer / Deserialize 実装）を依存関係に追加しておく必要があります。　例えば、JSON であれば serde_json、YAML であれば serde_yaml です。 serde 本体と各データフォーマット用の依存を追加 $ cargo add serde --features=derive $ cargo add serde_json # データフォーマットとして JSON を使う場合 Serde の derive マクロを有効にするために、--features=derive オプションを指定する必要があることに注意してください。 Cargo.toml に次のような依存関係が追加されていれば準備 OK です。 Cargo.toml [dependencies] serde = { version = \u0026#34;1.0.152\u0026#34;, features = [\u0026#34;derive\u0026#34;] } serde_json = \u0026#34;1.0.91\u0026#34; 基本的な使い方 (to_string, from_str) 次のサンプルコードでは、ユーザー定義の構造体 (Book) のインスタンスから JSON 文字列への変換（シリアライズ）と、その逆の、JSON 文字列から構造体インスタンスへの変換（デシリアライズ）を行っています。 注: コードのシンプル化ため、ここでは Result#unwrap メソッドを使っていますが、プロダクトコードでは正しく Result を処理してください（参考: Result の基本）。 src/main.rs use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { id: i32, title: String, } fn main() { // シリアライズ (構造体 → JSON 文字列) // 整形したいときは to_string の代わりに to_string_pretty を使えば OK let book = Book { id: 1, title: String::from(\u0026#34;Title-1\u0026#34;) }; let json = serde_json::to_string(\u0026amp;book).unwrap(); println!(\u0026#34;{}\u0026#34;, json); //=\u0026gt; {\u0026#34;id\u0026#34;:1,\u0026#34;title\u0026#34;:\u0026#34;Title-1\u0026#34;} // デシリアライズ (JSON 文字列 → 構造体) let json = r#\u0026#34;{\u0026#34;id\u0026#34;:2, \u0026#34;title\u0026#34;:\u0026#34;Title-2\u0026#34;}\u0026#34;#; let book: Book = serde_json::from_str(json).unwrap(); println!(\u0026#34;{}, {}\u0026#34;, book.id, book.title); //=\u0026gt; 2, Title-2 } ユーザー定義型（struct や enum）を、任意の Serializer / Deserializer 実装（serde_json など）で変換するには、その型に Serialize トレイト および Desrialize トレイト を実装しておく必要があります。 これは、ユーザー定義型を、Serde が処理できる汎用的なデータモデル に変換するための実装ですが、シンプルな構成の型であれば、上記のように #[derive(Serialize, Deserialize)] 属性を付加するだけで、デフォルト実装を提供してくれます。 ☝️ コンパイル時のコード生成 Serde が提供する derive マクロにより、Serialize と Deserialize の実装がコンパイル時に自動生成されます。 JSON ライブラリの設計によっては、アプリケーションの実行時にデータ型をリフレクションで処理するという方法も考えられますが、Serde は変換用の実装コードをコンパイル時に生成するという設計を採用しています。 これにより、実行時に高速かつ安全に動作することを保証しています。 必要に応じて、serde::ser::Serialize トレイトを実装することで、独自のシリアライズ処理 を提供することができます。 JSON ファイルへの保存と読み込み (to_writer, from_reader) serde_json クレートは、io::Write への書き込みを行う to_writer / to_writer_pretty 関数や、io::Read からの読み込みを行う from_reader 関数を提供しています。 これらの関数を利用して、ファイルやネットワークストリームに対して読み書きを行えます。 JSON ファイルへの保存 src/main.rs use std::{error::Error, fs::File, path::Path}; use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { id: i32, title: String, } fn save_book_to_json_file\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P, book: \u0026amp;Book) -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let file = File::create(path)?; // std::io::Error の可能性 serde_json::to_writer_pretty(file, book)?; // serde_json::Error の可能性 Ok(()) } fn main() { let book = Book { id: 1, title: String::from(\u0026#34;Title-1\u0026#34;) }; match save_book_to_json_file(\u0026#34;book.json\u0026#34;, \u0026amp;book) { Ok(_) =\u0026gt; println!(\u0026#34;JSON ファイルへの保存に成功しました\u0026#34;), Err(err) =\u0026gt; eprintln!(\u0026#34;JSON ファイルへの保存に失敗しました: {}\u0026#34;, err), } } JSON ファイルの読み込み src/main.ts use std::{error::Error, fs::File, io::BufReader, path::Path}; use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { id: i32, title: String, } fn load_book_from_json_file\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P) -\u0026gt; Result\u0026lt;Book, Box\u0026lt;dyn Error\u0026gt;\u0026gt; { let file = File::open(path)?; // std::io::Error の可能性 let reader = BufReader::new(file); // 読み込み時は明示的にバッファリング let book = serde_json::from_reader(reader)?; // serde_json::Error の可能性 Ok(book) } fn main() { match load_book_from_json_file(\u0026#34;book.json\u0026#34;) { Ok(book) =\u0026gt; { println!(\u0026#34;JSON ファイルの読み込みに成功しました\u0026#34;); println!(\u0026#34;内容: {}, {}\u0026#34;, book.id, book.title); } Err(err) =\u0026gt; eprintln!(\u0026#34;JSON ファイルの読み込みに失敗しました: {}\u0026#34;, err), } } フィールド名を変更する デフォルトでは JSON フィールド名は、Rust の構造体のフィールド名がそのまま使われますが、構造体の定義に #[serde(rename_all)] 属性を付けると、対応付ける JSON フィールド名のルールをまとめて変更できます。 JSON フィールド名を camelCase 形式にする #[derive(Serialize, Deserialize)] #[serde(rename_all = \u0026#34;camelCase\u0026#34;)] struct User { avatar_url: String, // JSON フィールド名は \u0026#34;avatarUrl\u0026#34; になる website_url: String, // JSON フィールド名は \u0026#34;websiteUrl\u0026#34; になる } rename_all の値として、他にも次のようなルールを指定できます。 \u0026quot;lowercase\u0026quot; \u0026quot;UPPERCASE\u0026quot; \u0026quot;PascalCase\u0026quot; \u0026quot;camelCase\u0026quot; \u0026quot;snake_case\u0026quot; \u0026quot;SCREAMING_SNAKE_CASE\u0026quot; \u0026quot;kebab-case\u0026quot; \u0026quot;SCREAMING-KEBAB-CASE\u0026quot; 構造体のフィールドに #[serde(rename = \u0026quot;別名\u0026quot;)] 属性を付けると、各フィールドを指定した名前でリネームすることができます。 JSON フィールド名を具体的に指定する #[derive(Serialize, Deserialize)] struct User { #[serde(rename = \u0026#34;id\u0026#34;)] user_id: String, // ... } デシリアライズ時に、別の JSON フィールド名でも読み込めるようにするには、#[serde(alias = \u0026quot;name\u0026quot;)] で別名を指定します。 これは、JSON へのシリアライズには影響しないことに注意してください。 別名は複数指定することができます。 この機能は恒久的には使うべきではないかもしれませんが、JSON ファイルのフォーマットを段階的に移行したいときに便利です。 JSON フィールド名が異なっていても読み込む #[derive(Serialize, Deserialize)] struct User { #[serde(alias = \u0026#34;id\u0026#34;, alias = \u0026#34;ID\u0026#34;, alias = \u0026#34;userId\u0026#34;)] user_id: String, // ... } 参考: Attributes · Serde 未知の JSON フィールドが見つかったらエラーにする デシリアライズしようとしている JSON データに、未知のフィールドが含まれているとき（Rust のユーザー定義型に対応するフィールドがないとき）、デフォルトではそのフィールドの値は無視されます。 つまり、構造体のインスタンスの生成は問題なく実行されます。 JSON データに未知のフィールドが含まれているときにエラーにしたい場合は、ユーザー定義型に deny_unknown_fields 属性 (container attribute) を付加します。 #[derive(Serialize, Deserialize)] #[serde(deny_unknown_fields)] struct Book { // ... } Nullable や存在しない JSON フィールドを扱う JSON の null 値を扱う Rust には null という概念は存在しませんが、値が存在しないかもしれないフィールドは Option 列挙型で表現できます。 例えば、JSON データの title フィールドの値として null が含まれている可能性がある場合は、対応する構造体の title フィールドを次のように Option 型にします。 #[derive(Serialize, Deserialize)] struct Book { id: i32, title: Option\u0026lt;String\u0026gt;, } これで、次のような null 値を含む JSON ファイルを読み込めます。 Rust 側で値を参照すると Option::None という値として参照できます。 book.json（title フィールドの値が null） { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: null } JSON にフィールドが存在しないとき 次のように、JSON データに対象のフィールド自体が存在しない場合も、Option 型でハンドルできます。 この場合も、Option::None という値が格納されます。 book.json（title フィールドが存在しない） { \u0026#34;id\u0026#34;: 1 } 構造体のフィールドを Option 型にする代わりに、#[serde(default)] 属性を付けて、その型のデフォルト値を入れることもできます。 次のように定義すると、JSON データに対応するフィールドが存在しないときに、String 型のデフォルト値である空文字列 (\u0026quot;\u0026quot;) が格納されます（#[serde(default = \u0026quot;func_name\u0026quot;)] として、任意のデフォルト値生成関数を呼び出すこともできます）。 #[derive(Serialize, Deserialize)] struct Book { id: i32, #[serde(default)] title: String, } ただし、これは、JSON にフィールドが存在しない場合のみ機能するもので、値として null が含まれている場合はエラーになることに注意してください（その場合は Option 型を使う必要があります）。 参考: Default value for a field · Serde シリアライズ／デシリアライズの対象外にする 特定の構造体フィールドを Serde のシリアライズ／デシリアライズの対象外にするには、次のような属性をフィールドに付加します。 #[serde(skip)] \u0026hellip; シリアライズとデシリアライズの対象外にする。 #[serde(skip_serializing)] シリアライズの対象外にする。 #[serde(skip_deserializing)] デシリアライズの対象外にする。 デシリアライズの対象外になっている構造体フィールドは、Default::default() が返すデフォルト値で初期化されます。 もし、#[serde(default = \u0026quot;func_name\u0026quot;)] という属性値がセットされている場合は、指定した関数がデフォルト値の生成のために呼び出されます。 他にも、属性を使って次のように細かな制御を行うことができます。 // Option 値が None のときは JSON フィールドを出力しない #[serde(skip_serializing_if = \u0026#34;Option::is_none\u0026#34;)] comment: Option\u0026lt;String\u0026gt;, // 文字列が空の場合は JSON のフィールドを出力しない、ただし、読み込み時は空文字列として初期化する #[serde(default, skip_serializing_if = \u0026#34;String::is_empty\u0026#34;)] serial: String, // ベクターが空の場合は JSON のフィールドを出力しない、ただし、読み込み時は空のベクターとして初期化する #[serde(default, skip_serializing_if = \u0026#34;Vec::is_empty\u0026#34;)] authors: Vec\u0026lt;String\u0026gt;, // マップが空の場合は JSON のフィールドを出力しない、ただし、読み込み時は空のマップとして初期化する #[serde(default, skip_serializing_if = \u0026#34;HashMap::is_empty\u0026#34;)] attributes: HashMap\u0026lt;String, String\u0026gt;, 形式の不明な JSON ファイルを読み込む (serde_json::Value) どのようなフィールドが含まれているかわからない JSON ファイルを読み込む場合は、任意の JSON データ型を示す serde_json::Value として読み込みます。 serde_json::Value は次のような定義の列挙型 (enum) で、JSON で表現できるデータ型がバリアントとして定義されています。 pub enum Value { Null, // null Bool(bool), // bool Number(Number), // 数値 String(String), // 文字列 Array(Vec\u0026lt;Value\u0026gt;), // 配列 Object(Map\u0026lt;String, Value\u0026gt;), // オブジェクト } ここでは、次のような JSON ファイルを読み込んでみます。 「オブジェクトの配列」の形になっているということまでは分かっているものとします。 games.json [ { \u0026#34;title\u0026#34;: \u0026#34;Final Fantasy\u0026#34;, \u0026#34;genre\u0026#34;: \u0026#34;RPG\u0026#34; }, { \u0026#34;title\u0026#34;: \u0026#34;Sqoon\u0026#34;, \u0026#34;genre\u0026#34;: \u0026#34;STG\u0026#34;, \u0026#34;price\u0026#34;: 4900 }, { \u0026#34;title\u0026#34;: \u0026#34;Gimmick\u0026#34;, \u0026#34;note\u0026#34;: \u0026#34;プレミア価格\u0026#34; } ] 次の例では、games.json を Value 型として読み込み、その内容を表示しています。 src/main.rs use serde_json::Value; use std::fs::File; use std::io::BufReader; // games.json を読み込んで Value 型で返す fn load_games() -\u0026gt; Value { let file = File::open(\u0026#34;games.json\u0026#34;).expect(\u0026#34;ファイルが開けませんでした。\u0026#34;); let reader = BufReader::new(file); serde_json::from_reader(reader).expect(\u0026#34;JSON の解析に失敗しました。\u0026#34;) } fn main() { let games_json: Value = load_games(); // JSON 全体は配列なので Value::Array として参照する if let Value::Array(games) = \u0026amp;games_json { for game in games { // 個々の要素は Value::Object として取り出す for (key, value) in game.as_object().unwrap() { println!(\u0026#34;{}: {}\u0026#34;, key, value); } println!(\u0026#34;--------------------\u0026#34;); } } else { println!(\u0026#34;JSON のルート要素は配列でなければいけません。\u0026#34;); } } 実行結果 $ cargo run -q genre: \u0026#34;RPG\u0026#34; title: \u0026#34;Final Fantasy\u0026#34; -------------------- genre: \u0026#34;STG\u0026#34; price: 4900 title: \u0026#34;Sqoon\u0026#34; -------------------- note: \u0026#34;プレミア価格\u0026#34; title: \u0026#34;Gimmick\u0026#34; -------------------- まず、下記の行で games.json ファイル全体を汎用的な Value 型として読み出しています。 let games_json: Value = load_games(); Value は列挙型なので、その内容を参照するには、if let 構文でどのバリアントなのかを判別してから参照する必要があります（参考: enum 型の使い方）。 今回の games.json は配列形式で記述されていると想定し、次のようにして Value::Array バリアント（内容は Vec\u0026lt;Value\u0026gt; 型）として参照しています。 if let Value::Array(games) = \u0026amp;games_json { // ... games を Vec\u0026lt;Value\u0026gt; 型として参照できる ... } Value::Array バリアントとして取り出した games は Vec\u0026lt;Value\u0026gt; 型なので、for-in ループで列挙することができます。 そして、games の中の個々の要素 game はオブジェクト形式なので、Value::Object バリアントとして参照することができます。 下記のコードでは、as_object() を使って Value::Object バリアントとして取り出していますが、ここでも if let を使って Value::Object バリアントかどうかを判別するのでも OK です。 for game in games { for (key, value) in game.as_object().unwrap() { println!(\u0026#34;{}: {}\u0026#34;, key, value); } } このようにすれば、どんなフィールドを持っているか不明な JSON ファイルを処理できますが、できればデータ型をちゃんと定義して扱いたいですね。"},{url:"/p/r7sdwgy/",title:"Rust で正規表現を扱う (regex)",date:"2023-01-08T00:00:00Z",body:"Rust で正規表現を扱う (regex) Rust の regex クレート を使うと、正規表現を使った様々な文字列処理を行うことができます。 Rust (Cargo) プロジェクト内で以下のように実行して Cargo.toml に依存関係を追加すれば regex の使用準備は完了です。 $ cargo add regex Cargo.toml [dependencies] regex = \u0026#34;1.7.0\u0026#34; パターンに一致するか調べる (is_match) Regex#is_match メソッドを使うと、引数で渡した文字列に、Regex のパターンに一致する部分文字列が含まれているかを調べることができます。 use regex::Regex; let re = Regex::new(r\u0026#34;\\d{4}-\\d{2}-\\d{2}\u0026#34;).unwrap(); let input = \u0026#34;Today\u0026#39;s date is 2023-01-07.\u0026#34;; if re.is_match(input) { println!(\u0026#34;日付らしき文字列が見つかりました\u0026#34;); } Regex#is_match メソッドは、パターンに一致する文字列が部分的にでも見つかれば true を返します。 文字列全体がパターンに一致するかどうかを調べたい場合は、パターンに ^（行頭）と $（行末）を含めて、r\u0026quot;^\\d{4}-\\d{2}-\\d{2}$\u0026quot; のようにします。 パターンに一致した位置を調べる (find, find_iter) Regex#find メソッドは、パターンに一致する部分文字列が見つかったときに regex::Match オブジェクトを返します。 見つからない場合は Option::None を返します。 Match のメソッドを使って、実際に一致した部分文字列や、その位置を取得できます。 連続する数値を探す let re = Regex::new(r\u0026#34;\\d+\u0026#34;).unwrap(); let input = \u0026#34;server: ok=100 changed=50 unreachable=0 failed=3\u0026#34;; match re.find(input) { Some(m) =\u0026gt; println!(\u0026#34;Found `{}` at {}-{}\u0026#34;, m.as_str(), m.start(), m.end()), None =\u0026gt; println!(\u0026#34;Not found\u0026#34;), } 実行結果 Found `100` at 11-14 Regex#find は最初に見つかった部分文字列だけを返しますが、複数回マッチさせたい場合は、代わりに Regex#find_iter メソッドで regex::Matches オブジェクトを取得します。 Matches は Iterator を実装しているので、ループ処理が可能です。 let re = Regex::new(r\u0026#34;\\d+\u0026#34;).unwrap(); let input = \u0026#34;server: ok=100 changed=50 unreachable=0 failed=3\u0026#34;; for m in re.find_iter(input) { println!(\u0026#34;Found `{}` at {}-{}\u0026#34;, m.as_str(), m.start(), m.end()); } 実行結果 Found `100` at 11-14 Found `50` at 23-25 Found `0` at 38-39 Found `3` at 47-48 グルーピングして部分文字列を抽出する (captures, captures_iter) Regex#captures メソッドは、パターン中の括弧 (()) でグルーピングされた部分を一度に抽出して、regex::Captures オブジェクトを返します。 Captures は Vec と同様にアクセス（[] や get）することができ、インデックス 0 には、パターンに一致した文字列全体が格納されています。 let re = Regex::new(r\u0026#34;(\\d{4})-(\\d{2})-(\\d{2})\u0026#34;).unwrap(); let input = \u0026#34;Eiichi Shibusawa was born on 1840-02-13 and died on 1931-11-11.\u0026#34;; match re.captures(input) { Some(caps) =\u0026gt; { println!(\u0026#34;年月日: {}\u0026#34;, \u0026amp;caps[0]); println!(\u0026#34;年: {}\u0026#34;, \u0026amp;caps[1]); println!(\u0026#34;月: {}\u0026#34;, \u0026amp;caps[2]); println!(\u0026#34;日: {}\u0026#34;, \u0026amp;caps[3]); } None =\u0026gt; println!(\u0026#34;Not found\u0026#34;), } 実行結果 年月日: 1840-02-13 年: 1840 月: 02 日: 13 複数回マッチさせたいときは、captures の代わりに captures_iter を使用します。 for caps in re.captures_iter(input) { println!(\u0026#34;年: {}, 月: {}, 日: {}\u0026#34;, \u0026amp;caps[1], \u0026amp;caps[2], \u0026amp;caps[3]); } 実行結果 年: 1840, 月: 02, 日: 13 年: 1931, 月: 11, 日: 11 正規表現パターンの中で、キャプチャグループに名前を付けるには (?P\u0026lt;name\u0026gt;exp) というシンタックスを使用します。 let re = Regex::new(r\u0026#34;(?P\u0026lt;year\u0026gt;\\d{4})-(?P\u0026lt;month\u0026gt;\\d{2})-(?P\u0026lt;day\u0026gt;\\d{2})\u0026#34;).unwrap(); let input = \u0026#34;Eiichi Shibusawa was born on 1840-02-13 and died on 1931-11-11.\u0026#34;; for caps in re.captures_iter(input) { println!( \u0026#34;年: {}, 月: {}, 日: {}\u0026#34;, \u0026amp;caps[\u0026#34;year\u0026#34;], \u0026amp;caps[\u0026#34;month\u0026#34;], \u0026amp;caps[\u0026#34;day\u0026#34;] ); } パターンに一致する部分を置換する (replace, replace_all) Regex#replace メソッドを使用すると、正規表現パターンに一致した部分を任意の文字列に置換できます。 最初に一致した部分だけでなく、一致した部分をすべて置換したいときは、Regex#replace_all メソッドを使用します。 let re = Regex::new(r\u0026#34;[m|M]aku\u0026#34;).unwrap(); let input = \u0026#34;I am maku. You are not Maku.\u0026#34;; let output = re.replace_all(input, \u0026#34;####\u0026#34;); println!(\u0026#34;{}\u0026#34;, output); //=\u0026gt; \u0026#34;I am ####. Your are not ####.\u0026#34; パターンの中で括弧 (()) を使ってキャプチャグループを構成しておけば、実際に一致した部分文字列を、置換文字列の中で $1 や $2 で参照できます。 ハイフン (-) で繋がった単語の前後を入れ替える let re = Regex::new(r\u0026#34;\\b(\\w+)-(\\w+)\\b\u0026#34;).unwrap(); let input = \u0026#34;AAA BBB-CCC DDD EEE-FFF GGG\u0026#34;; let output = re.replace_all(input, \u0026#34;$2-$1\u0026#34;); println!(\u0026#34;{}\u0026#34;, output); //=\u0026gt; \u0026#34;AAA CCC-BBB DDD FFF-EEE GGG\u0026#34;"},{url:"/p/z3gts64/",title:"Rust の Result オブジェクトを消費せずに参照する (as_ref, as_mut)",date:"2023-01-08T00:00:00Z",body:"Rust の Result オブジェクトを消費せずに参照する (as_ref, as_mut) 通常、Result オブジェクトを match や unwrap、ok メソッドなどでハンドルすると、その Result は消費されます（所有権が移動します）。 この振る舞いを防ぐには、as_ref や as_mut メソッドを使います。 std::result::Result のメソッド pub const fn as_ref(\u0026amp;self) -\u0026gt; Result\u0026lt;\u0026amp;T, \u0026amp;E\u0026gt; pub fn as_mut(\u0026amp;mut self) -\u0026gt; Result\u0026lt;\u0026amp;mut T, \u0026amp;mut E\u0026gt; as_ref メソッドで取得した Result オブジェクト経由で Ok/Err バリアントを参照すれば、それらのオブジェクトが消費されずに済みます。 let ok_opt = result.as_ref().ok(); // 借用 (borrow) // ... // ここでまだ result の Ok/Err は有効"},{url:"/p/ez9gpw5/",title:"Rust の Result 型エイリアスでコードを簡潔にする",date:"2023-01-08T00:00:00Z",body:"Rust の Result 型エイリアスでコードを簡潔にする Rust の std::io モジュールの関数は、戻り値として Result\u0026lt;T, std::io::Error\u0026gt; 型のオブジェクトを返すのですが、Result::Err バリアント部分の型は std::io::Error でいつも同じなので、簡潔に記述できるように、次のような std::io::Result というエイリアス型が定義されています。 std::io::Result pub type Result\u0026lt;T\u0026gt; = Result\u0026lt;T, Error\u0026gt;; // 後ろの Error は std::io::Error ここで定義している Result 型は、基礎となる std::result::Result とは別物なので注意してください。 std::io::Result という型を、std::result::Result と std::io::Error を組み合わせて定義しています。 std::io::Result を使うと、例えば、String を成功値 (Ok バリアントのフィールド) とする Result は、io::Result\u0026lt;String\u0026gt; と簡潔に記述することができます。 下記が具体的な使用例です。 use std::io; /// 標準入力から 1 行読み込みます fn get_string() -\u0026gt; io::Result\u0026lt;String\u0026gt; { let mut buffer = String::new(); io::stdin().read_line(\u0026amp;mut buffer)?; Ok(buffer) } 上記の get_string() 関数の戻り値の型 io::Result\u0026lt;String\u0026gt; は、実際には std::result::Result\u0026lt;String, std::io::Error\u0026gt; と同等です。 関数の処理が成功したときに値を返す必要がない（Ok バリアントのデータが必要ない）場合は、もっとシンプルに io::Result\u0026lt;()\u0026gt; という型になります。 fn foo() -\u0026gt; io::Result\u0026lt;()\u0026gt; { // ... Ok(()) } Result\u0026lt;()\u0026gt; といった表現が出てきた場合、どこかにこういったエイリアス型が定義されているはずです。"},{url:"/p/8amv5eo/",title:"Rust の各種ライブラリのエラー型と Error トレイト",date:"2023-01-08T00:00:00Z",body:"Rust の各種ライブラリのエラー型と Error トレイト いろんな Error 実装がある Rust には、成功と失敗を表現するための標準的な型である std::result::Result 型が用意されています。 std::result::Result enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } Result を返す関数内でエラーが発生した場合は、Err バリアントのフィールドに具体的なエラーオブジェクトを詰めて返すことになるのですが、このエラーオブジェクトの型として、各ライブラリが独自のエラー型を定義しています。 下記はその一例です。 std::io::Error std::fmt::Error std::str::Utf8Error std::num::ParseIntError 同じエラー型を使っているつもりでも、上記のように実体は異なる定義だったりするので注意してください。 Error トレイト Rust は共通のエラーインタフェースとして、次のような std::error::Error トレイト を定義しています。 前述の各種エラー型は、この Error トレイトを実装しています。 pub trait Error: Debug + Display { fn source(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;(dyn Error + \u0026#39;static)\u0026gt; { ... } fn description(\u0026amp;self) -\u0026gt; \u0026amp;str { ... } fn cause(\u0026amp;self) -\u0026gt; Option\u0026lt;\u0026amp;dyn Error\u0026gt; { ... } fn provide(\u0026amp;\u0026#39;a self, demand: \u0026amp;mut Demand\u0026lt;\u0026#39;a\u0026gt;) { ... } } Error は、Debug と Display も備えていることがわかります。 そのため、ほとんどのエラー型は、次のような共通のコードで解析することができます。 println!(\u0026#34;ERROR: {}\u0026#34;, err); // Display による簡潔なエラー情報 println!(\u0026#34;ERROR: {:?}\u0026#34;, err); // Debug によるデバッグ情報（技術的な情報） err.source() メソッドを使えば、そのエラー型の発生原因となったエラー型を取得できます。 戻り値は Option 型になっており、自分自身のエラー型がルートの発生源であれば、err.source() は None を返します。 ☝️ 独自のエラー型を定義する場合の推奨方法 Error トレイトを実装する std::error::Error トレイトを実装することで、共通のメソッドを使ってエラーを解析できるようになります。例えば、Error#source メソッドでエラーの発生源を調べることができます。 source の実装は、内部で保持している Error オブジェクトを返すだけで済みます。 Display と Debug を実装する これらを実装することで、クライアントがエラーの内容を出力できるようにしておきます（Error トレイトを実装するとき、自動的にこれらの実装も必要になります）。 Display の内容は、1 行で簡潔に「何が悪かったのか」分かるような表現にします。 他のレポートにネストされる形で表示されたりするので、基本的には すべて小文字 で、末尾のピリオドは付けない ようにします。 Debug が提供する情報は、Display よりも具体的になるようにします。例えば、オープンに失敗したファイルの名前や、ポート番号などの情報を含めます。多くのケースでは、#[derive(Debug)] を採用できます。 Send と Sync を実装する 可能であれば、スレッド境界を越えられるように Send と Sync を実装しておきます。エラー型がスレッドセーフになっていなければ、きっとそのクレートはマルチスレッドなコンテキストでは利用できません。 static なライフタイムを持たせる 'static にすることで、エラー情報を用意にコールスタックに乗せることができるようになります。"},{url:"/p/jku3biq/",title:"Rust でベクター型 (Vec) を扱う",date:"2023-01-07T00:00:00Z",body:"Rust でベクター型 (Vec) を扱う Vec 型とは？ Rust のベクター型 (Vec\u0026lt;T\u0026gt;) は、特定の型 (T) の要素を保持する可変長配列です。 サイズが固定であれば、通常の配列 (array) を使った方が効率的です。 次の例では、Vec::new 関数で空の Vec\u0026lt;i32\u0026gt; インスタンスを作成し、push メソッドにより動的に要素を追加しています。 let mut v: Vec\u0026lt;i32\u0026gt; = Vec::new(); // 型は推論されるので省略可能 v.push(10); v.push(20); v.push(30); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [10, 20, 30] 動的に要素を追加／削除するためには、Vec 変数は mut を付けて定義しておく必要があります。 この例の場合、push メソッドの使い方から、要素の型は i32 であることが推測されるので、Vec インスタンスの作成時に型注釈を省略することができます（ほとんどのケースでは省略できます）。 let mut v = Vec::new(); Vec インスタンスの作成方法 // 空の Vec を作成する let mut v: Vec\u0026lt;i32\u0026gt; = Vec::new(); // vec! マクロで初期値を指定して作成する let mut v: Vec\u0026lt;i32\u0026gt; = vec![]; let mut v = vec![10, 20, 30]; let mut v = vec![0; 3]; //=\u0026gt; [0, 0, 0] // Range を collect して連番の Vec を作成する let mut v: Vec\u0026lt;i32\u0026gt; = (0..3).collect(); //=\u0026gt; [0, 1, 2] let mut v: Vec\u0026lt;i32\u0026gt; = (0..=3).collect(); //=\u0026gt; [0, 1, 2, 3] let mut v: Vec\u0026lt;i32\u0026gt; = (0..=3).rev().collect(); //=\u0026gt; [3, 2, 1, 0] Vec の要素を参照する [] で参照する [] 演算子により、指定したインデックスの要素を取得することができます。 不正なインデックスを指定すると、panic が発生してプログラムが強制終了します。 let v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; let ch1 = v[0]; // \u0026#39;A\u0026#39; let ch2 = v[1]; // \u0026#39;B\u0026#39; let ch3 = v[2]; // \u0026#39;C\u0026#39; let ch4 = v[3]; // panic が発生！ get で参照する get メソッドを使うと、Option 型 で要素を取得することができます。 引数で正しいインデックスを指定すると、要素をデータとして持つ Some バリアントが返され、不正なインデックスを指定すると、None バリアントが返されます。 戻り値を match や if let でハンドルすることで、安全に要素を取得することができます。 let v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; // if let を使う方法 if let Some(elem) = v.get(0) { println!(\u0026#34;最初の要素は {} です\u0026#34;, elem); } // match を使う方法 match v.get(10) { Some(elem) =\u0026gt; println!(\u0026#34;要素の値は {} です\u0026#34;, elem), None =\u0026gt; println!(\u0026#34;不正なインデックスです\u0026#34;), } Vec 要素をループ処理する for in ループで Vec に格納された要素を 1 つずつ取り出すことができます。 ループ時に所有権の移動を防ぐため、\u0026amp; を付けて不変参照（スライス）を取得します。 let v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; for elem in \u0026amp;v { // v.iter() でも可 // elem は \u0026amp;char 型の不変参照 println!(\u0026#34;{}\u0026#34;, elem); } ループで各要素の可変参照を取得すると、要素の値を変更することができます。 let mut v = vec![100, 200, 300]; for elem in \u0026amp;mut v { // v.iter_mut() でも可 // elem は \u0026amp;mut i32 型の可変参照 *elem *= 2; } println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [200, 400, 600] enumerate と組み合わせると、インデックス番号を取得しながらループ処理できます。 let v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; for (index, elem) in v.iter().enumerate() { println!(\u0026#34;{}:{}\u0026#34;, index, elem); } Vec 要素を追加／削除する 末尾に要素を追加する (push) let mut v = vec![]; v.push(10); 末尾の要素を取り出して削除する (pop) let mut v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; // if let で 1 つ取り出す if let Some(elem) = v.pop() { println!(\u0026#34;{elem}\u0026#34;); } // while let で全部取り出す while let Some(elem) = v.pop() { println!(\u0026#34;{elem}\u0026#34;); } 指定したインデックスの要素を削除する (remove) let mut v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; v.remove(1); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;] 指定したインデックスの前に挿入する (insert) let mut v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; v.insert(1, \u0026#39;X\u0026#39;); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [\u0026#39;A\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] enum で複数の型の要素を保持する Vec\u0026lt;T\u0026gt; 型には、1 種類の型 T の要素しか格納できませんが、列挙型 (enum) の要素を保持するようにすれば、実質的に複数の型の要素を保持することができます。 Rust の列挙型は、各バリアントが異なる型のデータを持つことができるからです。 // 列挙型のバリアントで異なる型のデータを保持するようにする enum Cell { /// 整数値を保持するセル Int(i32), /// 浮動小数点数を保持するセル Float(f64), /// テキストを保持するセル Text(String), } // 各バリアントで必要なデータを保持して Vec 要素として格納する let cells = vec![ Cell::Int(7), Cell::Text(String::from(\u0026#34;AAA\u0026#34;)), Cell::Float(12.34), ]; // Vec の各要素（列挙型）をループ処理 for elem in \u0026amp;cells { match elem { Cell::Int(x) =\u0026gt; println!(\u0026#34;Int: {}\u0026#34;, x), Cell::Float(x) =\u0026gt; println!(\u0026#34;Float: {}\u0026#34;, x), Cell::Text(x) =\u0026gt; println!(\u0026#34;Text: {}\u0026#34;, x), } } その他の Vec 操作 ソートする (sort) let mut v = vec![3, 9, 1, 7, 5]; v.sort(); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [1, 2, 3, 4, 5] 逆順にする (reverse) let mut v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; v.reverse(); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [\u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;] 指定したインデックスの要素を入れ替える (swap) let mut v = vec![\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; v.swap(1, 2); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;B\u0026#39;] 連続する要素を 1 つにまとめる (dedup) let mut v: Vec\u0026lt;i32\u0026gt; = vec![5, 5, 2, 2, 2, 1, 4, 2]; v.dedup(); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [5, 2, 1, 4, 2] 条件に一致する要素だけ残して削除する (retain) 3 の倍数だけ残す let mut v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]; v.retain(|x| x % 3 == 0); println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [3, 6, 9] 条件に一致する要素を抽出して別の Vec として取得する (filter) 3 の倍数を抽出して Vec を作る let v1 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]; let v2: Vec\u0026lt;i32\u0026gt; = v1.into_iter().filter(|x| x % 3 == 0).collect(); println!(\u0026#34;{:?}\u0026#34;, v2); //=\u0026gt; [3, 6, 9] ループしながら要素を編集する Vec の各要素に 100 を足すいろいろな方法です。 for-in を使う方法（インデックスでループ） let mut v = vec![1, 2, 3]; for i in 0..v.len() { v[i] += 100; } println!(\u0026#34;{:?}\u0026#34;, v); //=\u0026gt; [101, 102, 103] 各要素を参照するためだけにインデックスを使うのはかっこよくないので、次のように各要素をイテレートするとよいです。 for-in \u0026#43; \u0026amp;mut でループ処理 for x in \u0026amp;mut v { *x += 100; } iter_mut メソッドの戻り値 (IterMut) を使って次のように書くこともできます。 for-in \u0026#43; iter_mut でループ処理 for x in v.iter_mut() { *x += 100; } iter_mut で取得したイテレーターの for_each メソッドを使うと、クロージャで変換処理をコンパクトに記述できます。 iter_mut \u0026#43; for_each でループ処理 v.iter_mut().for_each(|x| *x += 100); 不変の Vec インスタンスの内容から別の Vec インスタンスを生成するには、次のようにします。 iter \u0026#43; map \u0026#43; collect で新規 Vec を生成 let v1: Vec\u0026lt;i32\u0026gt; = vec![1, 2, 3]; let v2: Vec\u0026lt;i32\u0026gt; = v1.iter().map(|x| x + 100).collect();"},{url:"/p/ffqyajs/",title:"Rust で列挙型 (enum) を定義して match、if let で照合する",date:"2023-01-06T00:00:00Z",body:"Rust で列挙型 (enum) を定義して match、if let で照合する 列挙型は、あらかじ定義された値（列挙子やバリアントと呼びます）の内、いずれかの値をとることができる型です。 Rust の列挙型は、各バリアントに任意の値を保持することができるので非常に強力です。 列挙型は構造体 (struct) と同様に、impl ブロックを使ったメソッド定義を行えます。 列挙型の基本 列挙型は enum キーワードを使って定義します。 列挙型がとりうる値のことを バリアント (variant) と呼びます。 次の Fruit 列挙型は、バリアントとして Apple、Banana、Orange を持ちます。 enum 型を定義する // Fruit 列挙型を定義する #[derive(Debug)] enum Fruit { Apple, Banana, Orange, } // Fruit インスタンスを生成する let f = Fruit::Apple; println!(\u0026#34;{:?}\u0026#34;, f); //=\u0026gt; Apple println!(\u0026#34;{}\u0026#34;, f as i32); //=\u0026gt; 0 上記のように列挙型の定義時に #[derive(Debug)] 属性を付けておくと、println! マクロで列挙型変数の値を {:?} で参照できるようになります。 あるいは、as i32 を使って、バリアントが持つ 内部的な整数値を取り出す こともできます。 match による分岐 match 構文によりパターンマッチにより、列挙型変数の値に基づいて分岐処理を行うことができます。 次の例では 3 つのパターンで分岐していますが、これらのパターンごとの記述を Rust では アーム (arm) と呼びます。 各アームはカンマ (,) で区切って記述します。 match による分岐 let f = Fruit::Banana; match f { Fruit::Apple =\u0026gt; println!(\u0026#34;I like apples\u0026#34;), Fruit::Banana =\u0026gt; println!(\u0026#34;I like bananas\u0026#34;), Fruit::Orange =\u0026gt; println!(\u0026#34;I like oranges\u0026#34;), } Rust の match は式として扱われる ので、評価結果を変数などで受け取ることができます。 let message = match f { Fruit::Apple =\u0026gt; \u0026#34;I like apples\u0026#34;, Fruit::Banana =\u0026gt; \u0026#34;I like bananas\u0026#34;, Fruit::Orange =\u0026gt; \u0026#34;I like oranges\u0026#34;, }; println!(\u0026#34;{}\u0026#34;, message); ファットアロー (=\u0026gt;) の右側に複数の文を並べたいときは、全体を {} で囲んでブロック化します。 閉じ括弧の後ろにカンマを付ける必要はありません。 match f { Fruit::Apple =\u0026gt; { let msg = \u0026#34;I like apples\u0026#34;; println!(\u0026#34;{}\u0026#34;, msg); } Fruit::Banana =\u0026gt; println!(\u0026#34;I like bananas\u0026#34;), Fruit::Orange =\u0026gt; println!(\u0026#34;I like oranges\u0026#34;), } match で複数のバリアントや残り全てにマッチさせる match ブロックの中で、複数のバリアントで共通の処理を行いたい場合は、バリアントをパイプ記号 (|) で列挙します。 また、「その他のバリアントすべて」にマッチさせたいときは、アンダースコア (_) 記号を使います（これは、C/C++ や Java の default ケースに相当するものです）。 アンダースコアはすべての値に一致してしまうため、最後のアームとして配置する必要があります。 // トランプのスート（マーク）を表現する列挙型 enum Suit { Clubs, Spades, Diamonds, Hearts } let s = Suit::Clubs; match s { Suit::Clubs | Suit::Spades =\u0026gt; println!(\u0026#34;Its color is black\u0026#34;), _ =\u0026gt; println!(\u0026#34;Its color is red\u0026#34;), } 未使用バリアントの警告を抑制する アプリケーションの中で、使用していないバリアントがあると、Rust コンパイラーは次のような警告を出します。 warning: variants `Apple` and `Orange` are never constructed これは、デフォルトで #[warn(dead_code)] 属性が設定されており、未使用コードが警告されるようになっているからです。 未使用コードの警告を抑制するには、列挙型の定義時に、#[allow(dead_code)] 属性を追加します。 #[allow(dead_code)] enum Fruit { Apple, Banana, Orange } // Banana しか使っていないけど警告は出なくなる let f = Fruit::Banana; バリアントに値を持たせる enum 型の各バリアントは、任意の型のデータを保持することができます。 しかも バリアントごとに異なる型のデータを持つことができる ので、C/C++ の union（共用体）のような感覚で使用することができます。 enum Message { Quit, // データを持たない Move { x: i32, y: i32 }, // 無名の構造体データを持つ Write(String), // 1 つの String を持つ（タプル構造体） ChangeColor(i32, i32, i32), // 3 つの整数値を持つ（タプル構造体） } let m = Message::Quit; let m = Message::Move { x: 5, y: 2 }; let m = Message::Write(String::from(\u0026#34;Hello\u0026#34;)); let m = Message::ChangeColor(255, 255, 0); match による分岐時に、各バリアントに格納されているデータを取り出すことができます。 match m { Message::Quit =\u0026gt; println!(\u0026#34;Quit\u0026#34;), Message::Move { x, y } =\u0026gt; println!(\u0026#34;Move to: {}, {}\u0026#34;, x, y), Message::Write(s) =\u0026gt; println!(\u0026#34;Write: {}\u0026#34;, s), Message::ChangeColor(r, g, b) =\u0026gt; println!(\u0026#34;Change color to: {}, {}, {}\u0026#34;, r, g, b), } 上記の例では、各バリアントが持つデータを変数で取り出していますが、変数の代わりにリテラル値を指定すると、そのリテラル値に一致するデータが格納されている場合の処理を記述することができます。 また、格納されているデータを使用しない場合は、変数名の代わりにアンダースコア (_) を指定します。 match m { Message::Move { x: 0, y: 0 } =\u0026gt; println!(\u0026#34;Move to the origin\u0026#34;), Message::Move { x, y } =\u0026gt; println!(\u0026#34;Move to {}, {}\u0026#34;, x, y), Message::Write(_) =\u0026gt; println!(\u0026#34;Something written\u0026#34;), Message::ChangeColor(r, _, _) =\u0026gt; println!(\u0026#34;Red value is: {}\u0026#34;, r), _ =\u0026gt; (), // Nothing to do } 列挙値を if let で処理する 列挙型のすべてのバリアントを包括的に処理する必要がなく、特定のバリアントのみ興味がある場合は、match の代わりに if let 構文でパターンマッチを行うことができます。 マッチングのルールは match と同様です。 次の例では、Color 列挙型の変数の値が赤色を示す値かどうかを調べています。 #[allow(dead_code)] enum Color { Red, Blue, Rgb(u8, u8, u8), // タプルデータを持つ Hsv { h: u8, s: u8, v: u8 }, // 構造体データを持つ } let c = Color::Red; if let Color::Red = c { println!(\u0026#34;赤色です\u0026#34;); } let c = Color::Rgb(255, 0, 0); if let Color::Rgb(255, 0, 0) = c { println!(\u0026#34;これも赤色です\u0026#34;); } let c = Color::Hsv { h: 0, s: 100, v: 100 }; if let Color::Hsv { h: 0, s: 100, v: 100 } = c { println!(\u0026#34;またまたこれも赤色です\u0026#34;); } Color::Rgb や Color::Hsv のように、データを持つバリアントの場合は、if let で分岐処理するときに同時にそのデータを取り出すことができます。 このあたりの振る舞いも、match によるパターンマッチと同様です。 let c = Color::Rgb(255, 0, 0); if let Color::Rgb(r, g, b) = c { println!(\u0026#34;r={}, g={}, b={}\u0026#34;, r, g, b); } let c = Color::Hsv { h: 0, s: 100, v: 100 }; if let Color::Hsv { h, s, v } = c { println!(\u0026#34;h={}, s={}, v={}\u0026#34;, h, s, v); } バリアントが持つデータのうち、参照する必要がないフィールドがある場合は、変数名の代わりにアンダースコア (_) を配置しておきます。 let c = Color::Rgb(255, 255, 0); if let Color::Rgb(255, g, _) = c { // タプルの最初の値が 255 の場合のみ、2 番目の値を変数 g で取り出す println!(\u0026#34;g={}\u0026#34;, g); } let c = Color::Hsv { h: 0, s: 100, v: 100 }; if let Color::Hsv { h: 0, s, v: _ } = c { // フィールド h の値が 0 の場合のみ、フィールド s の値を取り出す println!(\u0026#34;s={}\u0026#34;, s); } 列挙型にメソッドを定義する 列挙型にも 構造体 (struct) と同様に、メソッドを定義することができます。 次の例では、WebEvent 列挙型に dump メソッドを定義しています。 メソッドの中では、自身の列挙型名 (WebEvent) の代わりに Self というエイリアスを使用できます。 enum 型にメソッドを追加する enum WebEvent { PageLoad, KeyPress(char), Click { x: u32, y: u32 }, } impl WebEvent { fn dump(\u0026amp;self) { match self { Self::PageLoad =\u0026gt; println!(\u0026#34;page loaded\u0026#34;), Self::KeyPress(c) =\u0026gt; println!(\u0026#34;pressed \u0026#39;{}\u0026#39;\u0026#34;, c), Self::Click { x, y } =\u0026gt; println!(\u0026#34;clicked at x={}, y={}\u0026#34;, x, y), } } } let e = WebEvent::Click { x: 5, y: 7 }; e.dump(); //=\u0026gt; \u0026#34;clicked at x=5, y=7\u0026#34; パラメーターのルールも構造体と同様で、第 1 引数に \u0026amp;self があれば、呼び出し時にインスタンスが必要な「メソッド」となり、\u0026amp;self がなければ、呼び出し時にインスタンスが必要ない「関連関数」となります。 それ以降のパラメーターは、メソッド（または関連関数）の呼び出し時に渡した引数を受け取るために使用します。 パラメーター有りのメソッドを追加する enum Operation { Add, Subtract, } impl Operation { /// バリアントに応じた演算を行う fn run(\u0026amp;self, a: i32, b: i32) -\u0026gt; i32 { return match self { Self::Add =\u0026gt; a + b, Self::Subtract =\u0026gt; a - b, }; } } let op = Operation::Add; println!(\u0026#34;{}\u0026#34;, op.run(1, 2)); //=\u0026gt; 3 バリアントが内部的に持つ整数値を取り出す C/C++ と同様に、Rust の列挙型のバリアントも、内部的には 0 始まりの整数値で管理されています。 この値は、as i32 で取り出すことができます。 enum Color { Red, Green, Blue, } println!(\u0026#34;{}\u0026#34;, Color::Red as i32); //=\u0026gt; 0 println!(\u0026#34;{}\u0026#34;, Color::Green as i32); //=\u0026gt; 1 println!(\u0026#34;{}\u0026#34;, Color::Blue as i32); //=\u0026gt; 2 let red = Color::Red; let green = Color::Green; let blue = Color::Blue; println!(\u0026#34;{}\u0026#34;, red as i32); //=\u0026gt; 0 println!(\u0026#34;{}\u0026#34;, green as i32); //=\u0026gt; 1 println!(\u0026#34;{}\u0026#34;, blue as i32); //=\u0026gt; 2 C/C++ と同様、この整数値は任意の値にオーバーライドすることができます。 enum Color { Red = 0xff0000, Green = 0x00ff00, Blue = 0x0000ff, } println!(\u0026#34;{:08x}\u0026#34;, Color::Red as i32); //=\u0026gt; 00ff0000 println!(\u0026#34;{:08x}\u0026#34;, Color::Green as i32); //=\u0026gt; 0000ff00 println!(\u0026#34;{:08x}\u0026#34;, Color::Blue as i32); //=\u0026gt; 000000ff"},{url:"/p/9m6m5m3/",title:"Rust の Option 型の基本 ─ 値の有無を表現する型",date:"2023-01-06T00:00:00Z",body:"Rust の Option 型の基本 ─ 値の有無を表現する型 Option 型とは？ 多くのオブジェクト指向言語には、オブジェクトが存在しないことを示す null という値が用意されていますが、Rust には null は存在しません。 Rust の設計者は、null という概念が不具合の温床となっていると判断しました。 その代わりに、Rust には std::option::Option という組み込みの列挙型 (enum) が用意されており、ある値が存在しているか を表現できるようになっています。 そして、この設計は null を使った表現よりも柔軟で、かつ安全です。 Option 型の定義はとてもシンプルで、次のような感じの列挙型 (enum) として定義されています。 Option 型の定義 pub enum Option\u0026lt;T\u0026gt; { Some(T), // T 型の何らかの値 None, // 値が存在しない } Some バリアントが「（任意の型 T の）値が存在する」ことを示し、None バリアントが「値が存在しない」ことを示します。 つまり、Some と None で値の有無を表現しつつ、値が存在する場合はその値を Some バリアントから取り出せるようになっています。 例えば、値が存在しないかもしれない String 型（他の言語では Nullable な String 型）は、Option\u0026lt;String\u0026gt; 型として表現することができ、その Some 値と None 値を次のように生成できます。 let some_val: Option\u0026lt;String\u0026gt; = Some(String::from(\u0026#34;Hello\u0026#34;)); let none_val: Option\u0026lt;String\u0026gt; = None; // 他の言語では null や nil に相当 こんな感じで別名を付けると理解しやすいでしょうか。 type NullableString = Option\u0026lt;String\u0026gt;; let some_val: NullableString = Some(String::from(\u0026#34;Hello\u0026#34;)); let none_val: NullableString = None; Option は単なる列挙型なので、本来はバリアントを参照するときに Option::Some や Option::None と記述しなければならないはずですが、デフォルトで Some や None と短く記述できるようになっています。 Option 型は頻繁に参照するので、そのシンボルが Rust の初期化処理 (prelude) でロードされるようになっており、このような省略記述が可能になっています。 Option 型の値を match で処理する 下記の関数は、引数で受け取った文字列を数値に変換し、Option\u0026lt;i32\u0026gt; 型の値として返しています。 つまり、Some\u0026lt;i32\u0026gt; あるいは None というバリアントを返します。 数値としてパースできない文字列が渡されたときは、None を返すようにしています（Rust 以外の言語であれば、null を返したり、例外を発生させたりするところです）。 /// 数値っぽい文字列を数値に変換します。 fn parse_num_str(s: \u0026amp;str) -\u0026gt; Option\u0026lt;i32\u0026gt; { match s { \u0026#34;one\u0026#34; | \u0026#34;一\u0026#34; =\u0026gt; Some(1), \u0026#34;two\u0026#34; | \u0026#34;二\u0026#34; =\u0026gt; Some(2), \u0026#34;three\u0026#34; | \u0026#34;三\u0026#34; =\u0026gt; Some(3), _ =\u0026gt; None, } } 戻り値の Option\u0026lt;i32\u0026gt; は列挙型の値なので、次のように match で分岐処理しつつ、Some バリアントに含まれている i32 値を取り出すことができます（参考: 列挙型 (enum) ）。 let num_opt = parse_num_str(\u0026#34;三\u0026#34;); match num_opt { Some(num) =\u0026gt; println!(\u0026#34;The number is {}\u0026#34;, num), None =\u0026gt; println!(\u0026#34;Could not parse\u0026#34;), } Option 型の値を if let で処理する Option 型の値として Some バリアントが返された場合のみ何らかの処理をしたいときは、match の代わりに if let 構文を使うとシンプルに記述できます。 Some が返された場合のみ処理する let num_opt = parse_num_str(\u0026#34;三\u0026#34;); if let Some(num) = num_opt { // ここで num は i32 型の値になっている println!(\u0026#34;The number is {}\u0026#34;, num); } match 構文と同様に、特定のリテラル値に一致するかどうかを調べることもできます。 let num_opt = parse_num_str(\u0026#34;三\u0026#34;); if let Some(3) = num_opt { println!(\u0026#34;Found: three\u0026#34;); } None かどうかをチェックする (is_none) Option 列挙型の値が None バリアントかどうかを確認したいときは、is_none() メソッドを使うのがシンプルです。 値が存在しないときに早期リターンしたいケースで使えるかもしれません。 逆に Some バリアントかどうかを調べる is_some() も用意されていますが、あまり使うことはないでしょう。 let num_opt = parse_num_str(\u0026#34;ほげ\u0026#34;); if num_opt.is_none() { eprintln!(\u0026#34;Parse error\u0026#34;); return; } // もちろん次のように書いても OK // if let None = num_opt { ... } Option 列挙型には、Some バリアントが保持するデータをダイレクトに取り出すための unwrap というメソッドが用意されていますが、このメソッドは None バリアントに対して呼び出すと panic が発生するので危険です。 ただ、上記のように None のケースを排除できていれば、安全に unwrap することができます。 // Some バリアントであることがわかっていれば unwrap で安全に値を取り出せる let num = num.unwrap(); println!(\u0026#34;The number is {}\u0026#34;, num); None だった場合に代替値を使う (unwrap_or, unwrap_or_else) Some バリアントが保持するデータを取り出す unwrap メソッドは、None バリアントに対して呼び出すと panic が発生してしまう危険なメソッドですが、代わりに unwrap_or メソッドを使うと、None だった場合に代替値を返すことができます。 次の例では、get_user_id 関数が返す Option 値が None だった場合に、代替値として -1 を使うようにしています。 fn get_user_id(name: \u0026amp;str) -\u0026gt; Option\u0026lt;i32\u0026gt; { match name { \u0026#34;root\u0026#34; =\u0026gt; Some(0), \u0026#34;maku\u0026#34; =\u0026gt; Some(1), _ =\u0026gt; None, } } let opt_id = get_user_id(\u0026#34;unknown\u0026#34;); let id = opt_id.unwrap_or(-1); // opt_id が None のとき -1 になる println!(\u0026#34;{}\u0026#34;, id); //=\u0026gt; -1 unwrap_or メソッドで指定する代替値は、メソッドの引数として渡すことになるので、そこに何らかの式を指定すると必ず評価されてしまうことに注意してください。 // get_default_id 関数は必ず呼び出されてしまう let id = opt_id.unwrap_or(get_default_id()); この振る舞いを防ぐには、unwrap_or の代わりに unwrap_or_else メソッドを使用して、None 時に呼び出す関数を渡すようにします。 次の例では、関数名を指定する代わりに匿名関数（ラムダ式）を渡しています。 // opt_id が None のときのみ get_default_id 関数が呼び出される let id = opt_id.unwrap_or_else(|| get_default_id()); 似たようなメソッドに、unwrap_or_default がありますが、こちらは代替値としてその型のデフォルト値（i32 なら 0、String なら \u0026quot;\u0026quot;、Vec なら vec![]）を返します。 場面によっては便利かもしれませんが、若干意図が伝わりにくい気がします。 let opt_id = get_user_id(\u0026#34;unknown\u0026#34;); let id = opt_id.unwrap_or_default(); //=\u0026gt; 0 unwrap_or 系のメソッドを使ったコードは、次のような if let でも同様のことを行えることに気がつくかもしれません。 ただ、このようなコードは可読性が悪いので、unwrap_or 系のメソッドをうまく使いこなしたいところです。 let id = if let Some(id) = opt_id { id } else { -1 }; 結局 Option 型の値はどうやってハンドルすればよいの？ 以上のように、Option 型の値はいろいろなハンドル方法がありますが、どのようにハンドルするかは、次のような優先度で考慮すればよいと思います。 match で Some と None の両方のケースをハンドルする match は Option のバリアントが包括的に処理されているかをコンパイル時に確認してくれるので安全です。 if let でハンドルする 特定の Some 値にしか興味がない場合は、if let でその値を取り出すことを考えます。ただし、想定外のバリアント値を見過ごすことがないように、else ブロックを配置しておくと安全です。 unwrap_or 系のメソッドでハンドルする データが存在しなかった場合にデフォルト値で済ませられる場合は、unwrap_or 系メソッドを使うと簡潔なコードになります。 その他のメソッドでハンドルする 十分に注意して Option 型のその他のメソッドを使用します。特に、panic を発生させる unwrap() メソッドなどは、プロダクトコードでは使わないようにするのが無難です。"},{url:"/p/wu6gqz9/",title:"Rust でコマンドライン引数を扱う (1) std::env::args",date:"2023-01-04T00:00:00Z",body:"Rust でコマンドライン引数を扱う (1) std::env::args Rust プログラムに渡されたコマンドライン引数を扱う方法として、std::env::args 関数 を使う方法を説明します。 この関数は標準で呼び出すことができるのでお手軽ですが、リッチなコマンドライン引数を提供したいときは、clap クレートを使う方法 がおすすめです。 std::env::args の基本 std::env::args 関数は、イテレート可能な std::env::Args オブジェクトを返します。 1 番目の要素には実行したファイルの名前（相対パス）が含まれており、2 番目以降にコマンドライン引数が格納されています。 src/main.rs use std::env; fn main() { // std::env::Args を取得してループ処理 for arg in env::args() { println!(\u0026#34;{arg}\u0026#34;); // arg は単純な String 型 } } cargo run でコマンドを実行する場合、プログラムに渡すコマンドライン引数は、次のように -- の後ろに指定します。 実行例 $ cargo -q run -- --aaa 100 200 target/debug/sample --aaa 100 200 -- というセパレーターを入れないと、--aaa オプションが、cargo 側のオプションとして渡されてしまうので注意してください。 Iterator トレイトの nth メソッド を使って、インデックス指定で参照することもできます。 ユーザーがコマンドライン引数を指定しなかった場合は、Option::None が返されることに注意してください。 let first_arg: String = std::env::args().nth(1).unwrap(); let second_arg: String = std::env::args().nth(2).unwrap(); ベクター型で処理する (collect) std::env::args 関数の戻り値 Args は、次のように Vec\u0026lt;String\u0026gt; 型に変換してしまうと扱いやすいです。 use std::env; fn main() { let args: Vec\u0026lt;String\u0026gt; = env::args().collect(); // すべての内容をダンプ println!(\u0026#34;{:?}\u0026#34;, args); // 各パートを取り出す println!(\u0026#34;The number of arguments is {}\u0026#34;, args.len()); println!(\u0026#34;My path is {}\u0026#34;, args[0]); println!(\u0026#34;The remaining arguments are {:?}\u0026#34;, \u0026amp;args[1..]); // 必須の引数を表現したい場合 if args.len() \u0026lt; 2 { eprintln!(\u0026#34;The dir_name argument is required\u0026#34;); std::process::exit(1); } let dir_name = args.get(1).unwrap(); println!(\u0026#34;dir_name = {}\u0026#34;, dir_name); } 次のステップ Rust でコマンドライン引数を扱う (2) clap クレート"},{url:"/p/owbo2dp/",title:"Rust で自作したプログラムをシステムにインストールする (cargo install)",date:"2023-01-02T00:00:00Z",body:"Rust で自作したプログラムをシステムにインストールする (cargo install) 何をするか？ Rust で自作したコマンドラインツール (CLI) は、プロジェクトのワーキングディレクトリ以下で cargo run で実行できますが、毎回ディレクトリを移動するのは面倒です。 cargo install コマンド で、パスの通ったディレクトリに実行ファイルをインストールすれば、どのディレクトリからでもコマンドを実行できるようになります。 自作コマンドをインストールする (cargo install) Rust のプロジェクトがなければ、次のように適当に作ってください。 ここでは、hello-rust という名前のプログラムを作成することにします。 $ cargo new ~/hello-rust $ cd ~/hello-rust ローカルで開発している Rust プログラムをシステムにインストールするには、次のように cargo install コマンドを実行します。 このとき、--path オプションで Cargo.toml ファイルがあるディレクトリを指定する必要があります。 自動的にリリースモードでビルド (cargo build -r) してからインストールしてくれるので、あらかじめビルドしておく必要はありません。 $ cargo install --path . Installing hello-rust v0.1.0 (/Users/maku/hello-rust) Compiling hello-rust v0.1.0 (/Users/maku/hello-rust) Finished release [optimized] target(s) in 0.35s Installing /Users/maku/.cargo/bin/hello-rust Installed package `hello-rust v0.1.0 (/Users/maku/hello-rust)` (executable `hello-rust`) 生成された実行ファイル (hello-rust) は、~/.cargo/bin ディレクトリにインストールされます（インストール先は --root オプションで変更できます）。 このディレクトリにパスが通っていれば、次のようにコマンド実行できるようになっているはずです。 $ hello-rust Hello, world! 自作コマンドをアンインストールする (cargo unintall) cargo install でインストールした自作コマンドをアンインストールするには、Cargo.toml ファイルのあるディレクトリで、cargo uninstall コマンドを実行します。 $ cd ~/hello-rust $ cargo uninstall Removing /Users/maku/.cargo/bin/hello-rust インストールされたプログラムは、~/.cargo/bin ディレクトリ以下に 1 つのバイナリファイルとして存在しているので、単純にそのファイルを削除するだけでも OK です。 $ rm ~/.cargo/bin/hello-rust"},{url:"/p/36hr2bj/",title:"ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf)",date:"2023-01-01T00:00:00Z",body:"ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf) Path と PathBuf Rust には、ファイルやディレクトリのパス情報を扱うための std::path::Path struct が用意されています。 Path の mutable 版（可変）である、std::path::PathBuf struct を使うと、パス情報を動的に組み立てていくことができます。 次の例では、パス形式の文字列リテラルから Path と PathBuf のインスタンスを生成しています。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(\u0026#34;/dir1/dir2/file.txt\u0026#34;); let path_buf = PathBuf::from(\u0026#34;/dir1/dir2/file.txt\u0026#34;); println!(\u0026#34;{:?}\u0026#34;, path); //=\u0026gt; \u0026#34;/dir1/dir2/file.txt\u0026#34; println!(\u0026#34;{:?}\u0026#34;, path_buf); //=\u0026gt; \u0026#34;/dir1/dir2/file.txt\u0026#34; } ☝️ パスを文字列で取り出す Path や PathBuf インスタンスから、パスを表現する文字列を取得したければ次のように記述できます。 let path = Path::new(\u0026#34;/aaa/bbb/ccc\u0026#34;); let s = path.to_string_lossy(); assert_eq!(s, \u0026#34;/aaa/bbb/ccc\u0026#34;); ただ、実際のプロダクトコード内でパス情報を扱うときは、Path オブジェクトのまま扱った方が都合がよいので、実際にこのような処理が必要になることはあまりありません。 例えば、ファイルを扱う std::fs モジュールの各種関数は、パスを表す文字列と Path インスタンスのどちらも扱えるようになっています。 パスを分解する Path や PathBuf の、次のようなメソッドを使うことで、/dir1/dir2/file.txt のようなパス文字列から、親ディレクトリ名や、ベースネーム、拡張子名などを抽出することができます。 メソッド 戻り値の型 意味 Path#parent() Option\u0026lt;\u0026amp;Path\u0026gt; 親ディレクトリ Path#file_name() Option\u0026lt;\u0026amp;OsStr\u0026gt; ファイル名 Path#file_stem() Option\u0026lt;\u0026amp;OsStr\u0026gt; ベースネーム（ファイル名から拡張子を除いたもの） Path#extension() Option\u0026lt;\u0026amp;OsStr\u0026gt; 拡張子 例: フルパスの場合 use std::ffi::OsStr; use std::path::Path; fn main() { let path = Path::new(\u0026#34;/dir1/dir2/file.txt\u0026#34;); assert_eq!(path.parent(), Some(Path::new(\u0026#34;/dir1/dir2\u0026#34;))); assert_eq!(path.file_name(), Some(OsStr::new(\u0026#34;file.txt\u0026#34;))); assert_eq!(path.file_stem(), Some(OsStr::new(\u0026#34;file\u0026#34;))); assert_eq!(path.extension(), Some(OsStr::new(\u0026#34;txt\u0026#34;))); } 拡張子が存在しない場合、Path#extension() の戻り値は（Option enum の）None になります。 例: ファイル名だけの場合 use std::ffi::OsStr; use std::path::Path; fn main() { let path = Path::new(\u0026#34;file\u0026#34;); assert_eq!(path.parent(), Some(Path::new(\u0026#34;\u0026#34;))); assert_eq!(path.file_name(), Some(OsStr::new(\u0026#34;file\u0026#34;))); assert_eq!(path.file_stem(), Some(OsStr::new(\u0026#34;file\u0026#34;))); assert_eq!(path.extension(), None); } パスを構築する パスを結合する PathBuf struct は、パスを動的に組み立てていくための push、pop、set_file_name、set_extension といったメソッドを備えています。 PathBuf::push メソッドを連続して使うと、各階層のディレクトリ名、ファイル名を末尾に繋げていくことができます。 use std::path::PathBuf; fn main() { let mut path = PathBuf::new(); path.push(\u0026#34;/\u0026#34;); path.push(\u0026#34;aaa\u0026#34;); path.push(\u0026#34;bbb\u0026#34;); path.push(\u0026#34;ccc.txt\u0026#34;); assert_eq!(path, PathBuf::from(\u0026#34;/aaa/bbb/ccc.txt\u0026#34;)); } Path struct は immutable（不変）なので、自分自身を変更する push メソッドは備えていませんが、代わりに、パス結合後の結果を戻り値として返す Path#join メソッドを備えています。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(\u0026#34;/aaa/bbb\u0026#34;); let path_buf = path.join(\u0026#34;ccc.txt\u0026#34;); assert_eq!(path_buf, PathBuf::from(\u0026#34;/aaa/bbb/ccc.txt\u0026#34;)); } Path から PathBuf を生成する (to_path_buf) Path#to_path_buf メソッドを使うと、同一のパスを表す PathBuf を生成することができます。 次の例では、Path から PathBuf を生成し、さまざまな編集メソッドを使って新しいパス情報を構築しています。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(\u0026#34;/aaa/bbb/ccc.txt\u0026#34;); let mut path_buf = path.to_path_buf(); // PathBuf を生成 path_buf.pop(); // 親ディレクトリへ (\u0026#34;/aaa/bbb\u0026#34;) path_buf.pop(); // 親ディレクトリへ (\u0026#34;/aaa\u0026#34;) path_buf.push(\u0026#34;xxx\u0026#34;); // パスを結合 (\u0026#34;/aaa/xxx\u0026#34;) path_buf.push(\u0026#34;yyy\u0026#34;); // パスを結合 (\u0026#34;/aaa/xxx/yyy\u0026#34;) path_buf.set_extension(\u0026#34;txt\u0026#34;); // 拡張子をセット (\u0026#34;/aaa/xxx/yyy.txt\u0026#34;) assert_eq!(path_buf, PathBuf::from(\u0026#34;/aaa/xxx/yyy.txt\u0026#34;)); } ファイル名／拡張子を置換する (PathBuf::set_file_name, Path::with_file_name) パスのファイル名部分だけを変更したいときは、PathBuf::set_file_name メソッドを使います。 このメソッドは、パスの末尾がファイル名であるか、ディレクトリ名であるかは考慮しないので注意してください。 use std::path::PathBuf; fn main() { let mut path_buf = PathBuf::from(\u0026#34;/aaa/bbb/ccc\u0026#34;); path_buf.set_file_name(\u0026#34;XXX.txt\u0026#34;); assert_eq!(path_buf, PathBuf::from(\u0026#34;/aaa/bbb/XXX.txt\u0026#34;)); } ファイル名部分の置換には、Path::with_file_name を使うこともできます。 Path インスタンスは immutable（不変）なので、置換結果は戻り値として返されます。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(\u0026#34;/aaa/bbb/ccc\u0026#34;); let path_buf = path.with_file_name(\u0026#34;XXX.txt\u0026#34;); assert_eq!(path_buf, PathBuf::from(\u0026#34;/aaa/bbb/XXX.txt\u0026#34;)); } 同様に使えるメソッドとして、拡張子部分だけを置換する PathBuf::set_extension や Path::with_extension も用意されています。"},{url:"/p/fbkt3ah/",title:"ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf)",date:"2023-01-01T00:00:00Z",body:"ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf) Path や PathBuf 構造体が備えている is_file メソッドや is_dir メソッドを使うと、そのそのパスに対応するファイルやディレクトリが存在するかを調べることができます。 他にも、パスが絶対パスか相対パスかを調べるメソッドなどが用意されています。 メソッド名 戻り値の型 意味 Path::is_file() bool そのパスが示す ファイルが存在するか を調べます。シンボリックリンクの場合は、リンク先のファイルが存在するかを調べます。ファイルのアクセス権がない場合は、false を返します。 Path::is_dir() bool そのパスが示す ディレクトリが存在するか を調べます。シンボリックリンクの場合は、リンク先のディレクトリが存在するかを調べます。ディレクトリのアクセス権がない場合は、false を返します。 Path::is_symlink() bool そのパスが示す シンボリックファイルが存在するか を調べます。リンク先のファイルやディレクトリが存在するかまではチェックしません（シンボリックリンクが壊れていても true を返します）。 Path::is_absolute() bool そのパスが 絶対パスか を調べます。 Path::is_relative() bool そのパスが 相対パスか を調べます。 Path::has_root() bool そのパスが ルートセパレーターを持つか を調べます（ほぼ is_absolute と同義）。 use std::path::Path; fn main() { // 存在するファイル（相対パス指定）の場合 let path = Path::new(\u0026#34;Cargo.toml\u0026#34;); assert_eq!(path.is_file(), true); assert_eq!(path.is_dir(), false); assert_eq!(path.is_symlink(), false); assert_eq!(path.is_absolute(), false); assert_eq!(path.is_relative(), true); assert_eq!(path.has_root(), false); // 存在しないファイル（絶対パス指定）の場合 let path = Path::new(\u0026#34;/nonexisting/file/path\u0026#34;); assert_eq!(path.is_file(), false); assert_eq!(path.is_dir(), false); assert_eq!(path.is_symlink(), false); assert_eq!(path.is_absolute(), true); assert_eq!(path.is_relative(), false); assert_eq!(path.has_root(), true); }"},{url:"/p/zju5eow/",title:"Rust でディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all)",date:"2022-12-30T00:00:00Z",body:"Rust でディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all) ディレクトリを作成する (create_dir) Rust でディレクトリを作成するには、std::fs::create_dir 関数 を使用します。 カレントディレクトリに aaa ディレクトリを作成 use std::fs; fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { fs::create_dir(\u0026#34;aaa\u0026#34;)?; Ok(()) } すでに同名のディレクトリが存在している場合など、ディレクトリを作成できない場合はエラーが発生します。 use std::fs; fn main() { match fs::create_dir(\u0026#34;aaa\u0026#34;) { Ok(_) =\u0026gt; println!(\u0026#34;ディレクトリを作成しました\u0026#34;), Err(_) =\u0026gt; eprintln!(\u0026#34;ディレクトリを作成できませんでした\u0026#34;), } } 複数階層のディレクトリを作成する (create_dir_all) 深い階層のディレクトリを一気に作成するには、create_dir の代わりに create_dir_all 関数 を使用します。 このメソッドは、すでに存在しているディレクトリを指定してもエラーにならない ので、create_dir より使い勝手はよいかもしれません。 aaa/bbb/ccc ディレクトリが存在しなければ作成する use std::fs; fn main() { fs::create_dir_all(\u0026#34;aaa/bbb/ccc\u0026#34;).unwrap(); // 成功する前提で unwrap } ディレクトリを削除する (remove_dir) 既存の（空の）ディレクトリを削除するには、std::fs::remove_dir 関数を使用します。 この関数は、Linux の rmdir コマンドと同様、空のディレクトリしか削除できないことに注意してください（DirectoryNotEmpty エラーが発生します）。 存在しないディレクトリを削除しようとした場合もエラーが発生します。 ディレクトリ aaa を削除する use std::fs; fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; { fs::remove_dir(\u0026#34;aaa\u0026#34;)?; Ok(()) } 空でないディレクトリを削除する (remove_dir_all) ディレクトリ内に含まれているファイルやディレクトリも含めて丸ごと削除してしまうには、remove_dir 関数の代わりに remove_dir_all 関数 を使用します。 この関数も、存在しないディレクトリを指定するとエラーになります。 次の例では、Path#is_dir 関数でディレクトリの存在を確認してから削除しています。 ディレクトリ aaa を中身も含めて削除する use std::{fs, path::Path}; fn main() { let dir_name = \u0026#34;aaa\u0026#34;; if Path::new(dir_name).is_dir() { // ディレクトリが存在するなら丸ごと削除 match fs::remove_dir_all(dir_name) { Ok(_) =\u0026gt; println!(\u0026#34;Directory `{}` has been removed\u0026#34;, dir_name), Err(e) =\u0026gt; eprintln!(\u0026#34;Failed to remove {}: {}\u0026#34;, dir_name, e), } } else { // ディレクトリは存在しなかった println!(\u0026#34;Directory {} does not exist\u0026#34;, dir_name); } } 参考 ファイルやディレクトリの名前を変更する (std::fs::rename)"},{url:"/p/2kv6eub/",title:"Rust でディレクトリ内のファイルを列挙する (fs::read_dir)",date:"2022-12-30T00:00:00Z",body:"Rust でディレクトリ内のファイルを列挙する (fs::read_dir) read_dir 関数の基本 Rust の標準モジュール std::fs の read_dir 関数 を使うと、ディレクトリ内のファイルやディレクトリを列挙することができます。 std::fs::read_dir 関数 pub fn read_dir\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P) -\u0026gt; Result\u0026lt;ReadDir\u0026gt; 列挙結果には、カレントディレクトリ (.) や親ディレクトリ (..) は含まれないので、自然な列挙が可能です。 src/main.rs use std::fs; fn main() { let entries = fs::read_dir(\u0026#34;.\u0026#34;).unwrap(); // ReadDir を取得 // ループで Result\u0026lt;DieEntry, Error\u0026gt; をひとつずつ処理 for entry in entries { // DirEntry#file_name() でファイル名（ディレクトリ名）を取得できる println!(\u0026#34;{:?}\u0026#34;, entry.unwrap().file_name()); } } 実行結果 \u0026#34;Cargo.toml\u0026#34; \u0026#34;target\u0026#34; \u0026#34;Cargo.lock\u0026#34; \u0026#34;.gitignore\u0026#34; \u0026#34;.git\u0026#34; \u0026#34;src\u0026#34; エラーチェックする 上記ではコードを簡素化するために Result#unwrap メソッドを使っていますが、万が一 Err 値が返された場合は panic が発生してしまうので、プロダクトコードでは unwrap メソッドは使うべきではありません。 Result が Ok 値を持っているかを調べつつ、その値を取り出すには、次のように if let 構文を使用できます。 他の実装例 use std::fs; fn main() { if let Ok(entries) = fs::read_dir(\u0026#34;.\u0026#34;) { for entry in entries { if let Ok(entry) = entry { println!(\u0026#34;{:?}\u0026#34;, entry.file_name()); } } } } Path インスタンスを取得する DirEntry#file_name() でファイル名 (OsString) を取得する代わりに、DirEntry#path() を使って PathBuf オブジェクトを取得できます。 PathBuf は、パス情報を扱ういろいろなメソッドを提供しています。 let path = entry.path(); // PathBuf を取得 println!(\u0026#34;file_name = {:?}\u0026#34;, entry.file_name()); println!(\u0026#34;is_file = {}\u0026#34;, path.is_file()); println!(\u0026#34;is_dir = {}\u0026#34;, path.is_dir()); println!(\u0026#34;is_absolute = {}\u0026#34;, path.is_absolute()); 参考: ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf) 参考: ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf) ディレクトリ内のファイルリストを Vec で取得する 前述のように、Rust でディレクトリ内のファイルを列挙しようとすうと、少し面倒なコードになります。 下記のユーティリティ関数 read_dir_entries を使うと、指定したディレクトリに含まれているファイルやディレクトリの名前 (PathBuf) を Vec 形式でまとめて取得できます。 use std::{ fs, io, path::{Path, PathBuf}, }; /** 指定したディレクトリ内のすべてのファイル（ディレクトリ）のパス情報を取得します。 */ fn read_dir_entries\u0026lt;P: AsRef\u0026lt;Path\u0026gt;\u0026gt;(path: P) -\u0026gt; io::Result\u0026lt;Vec\u0026lt;PathBuf\u0026gt;\u0026gt; { let mut entries = fs::read_dir(path)? .map(|res| res.map(|e| e.path())) .collect::\u0026lt;Result\u0026lt;Vec\u0026lt;_\u0026gt;, io::Error\u0026gt;\u0026gt;()?; entries.sort(); Ok(entries) } fn main() { match read_dir_entries(\u0026#34;.\u0026#34;) { Ok(entries) =\u0026gt; println!(\u0026#34;{:?}\u0026#34;, entries), Err(e) =\u0026gt; eprintln!(\u0026#34;ERROR: {}\u0026#34;, e), } } 実行結果 [\u0026#34;./.git\u0026#34;, \u0026#34;./.gitignore\u0026#34;, \u0026#34;./Cargo.lock\u0026#34;, \u0026#34;./Cargo.toml\u0026#34;, \u0026#34;./src\u0026#34;, \u0026#34;./target\u0026#34;]"},{url:"/p/raiqzbr/",title:"Rust でファイルやディレクトリの名前を変更（移動）する (std::fs::rename)",date:"2022-12-30T00:00:00Z",body:"Rust でファイルやディレクトリの名前を変更（移動）する (std::fs::rename) Rust でファイルやディレクトリの名前を変更するには、std::fs::rename 関数 を使用します。 rename 関数は、ファイルの移動にも使用できます。 ファイルの名前を変更する a.txt を b.txt にリネームする use std::{fs, io}; fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { fs::rename(\u0026#34;a.txt\u0026#34;, \u0026#34;b.txt\u0026#34;)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイル名の代わりにディレクトリ名を指定すれば、ディレクトリ名を変更することができます。 rename 関数には Path インスタンスを渡すこともできます。 use std::{fs, io, path::Path}; fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { let path_from = Path::new(\u0026#34;a.txt\u0026#34;); let path_to = Path::new(\u0026#34;b.txt\u0026#34;); fs::rename(\u0026amp;path_from, \u0026amp;path_to)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイルを移動する rename 関数の移動先パスとして、ディレクトリ階層を含むファイルパスを指定すれば、ファイルをそのディレクトリに移動することができます。 このとき、ファイル名を変更すれば、移動とファイル名の変更が同時に行われます（逆に言うと、移動だけしたいのであれば、同じファイル名を指定する必要があります）。 a.txt を aaa/bbb/ccc.txt として移動する use std::{fs, io}; fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { // 移動先のディレクトリが存在しなければ先に作成しておく fs::create_dir_all(\u0026#34;aaa/bbb\u0026#34;)?; // ファイルを移動＆リネームする fs::rename(\u0026#34;a.txt\u0026#34;, \u0026#34;aaa/bbb/ccc.txt\u0026#34;)?; Ok(()) } 移動先のディレクトリはあらかじめ存在していなければいけないので、上記では create_dir_all 関数で先にディレクトリを用意しています（すでに存在していれば無視されます）。 参考: ディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all) 次の move_file ユーティリティ関数は、移動先のディレクトリが存在していないときに自動的に作成してくれます。 use std::{fs, io, path::Path}; /// from が示すファイル／ディレクトリを、to のパスへ移動（とリネーム）します。 /// to には移動後のファイル／ディレクトリ名を含んでいる必要があります。 /// to が親ディレクトリを持つ場合、そのディレクトリを先に作成します。 fn move_file(from: \u0026amp;Path, to: \u0026amp;Path) -\u0026gt; io::Result\u0026lt;()\u0026gt; { // 移動先のディレクトリが存在しなければ先に作成しておく if let Some(parent) = to.parent() { fs::create_dir_all(parent)?; } // ファイルを移動＆リネームする fs::rename(\u0026amp;from, \u0026amp;to)?; Ok(()) } fn main() { let path_from = Path::new(\u0026#34;a.txt\u0026#34;); let path_to = Path::new(\u0026#34;aaa/bbb/ccc.txt\u0026#34;); match move_file(\u0026amp;path_from, \u0026amp;path_to) { Ok(_) =\u0026gt; println!(\u0026#34;Success!\u0026#34;), Err(err) =\u0026gt; eprintln!(\u0026#34;ERROR: {}\u0026#34;, err), } }"},{url:"/p/eamw7fp/",title:"Rust でキーボードからの入力を取得する",date:"2022-12-29T00:00:00Z",body:"Rust でキーボードからの入力を取得する std::io::Stdin の read_line 関数を使うと、ユーザーのキーボード入力を読み取ることができます。 main.rs use std::io::{self, Write}; fn main() { print!(\u0026#34;Please input your name: \u0026#34;); // プロンプトを表示して入力を促す io::stdout().flush().unwrap(); // 上記出力を強制フラッシュ let mut line = String::new(); // 入力用のバッファ io::stdin() .read_line(\u0026amp;mut line) // キーボードからの入力（標準入力）を 1 行読み込む .expect(\u0026#34;Failed to read line\u0026#34;); // 戻り値の Result が Err の場合は終了 println!(\u0026#34;Hi, {}!\u0026#34;, line.trim_end()); // 末尾の改行コードは trim_end で削除可能 } 実行例 Please input your name: Maku Hi, Maku!"},{url:"/p/m9vdtaq/",title:"Rust で型の名前を取得する (std::any::type_name)",date:"2022-12-29T00:00:00Z",body:"Rust で型の名前を取得する (std::any::type_name) std::any::type_name 関数を使うと、型パラメーターで指定した型の名前を、文字列表現で取得することができます。 次の例では、String 型の型名を取得しています。 let name = std::any::type_name::\u0026lt;String\u0026gt;(); println!(\u0026#34;{}\u0026#34;, name) //=\u0026gt; alloc::string::String 返される文字列の形式は明確には仕様化されておらず、Rust のバージョンごとに変わったりするので、この文字列に依存したビジネスロジックは記述すべきではない とされています（診断用にのみ使用できます）。 次のようなユーティリティ関数を作成すれば、任意のリテラル値や変数の型を簡単に調べることができます。 fn print_type_of\u0026lt;T\u0026gt;(_: T) { println!(\u0026#34;{}\u0026#34;, std::any::type_name::\u0026lt;T\u0026gt;()) } fn main() { print_type_of(0); //=\u0026gt; i32 print_type_of(0b1111); //=\u0026gt; i32 print_type_of(0i8); //=\u0026gt; i8 print_type_of(0u64); //=\u0026gt; u64 print_type_of(0.1); //=\u0026gt; f64 print_type_of(0.1e5); //=\u0026gt; f64 print_type_of(0.1f32); //=\u0026gt; f32 print_type_of(0.1e5f32); //=\u0026gt; f32 print_type_of(\u0026#39;a\u0026#39;); //=\u0026gt; char print_type_of(\u0026#34;Hello\u0026#34;); //=\u0026gt; \u0026amp;str }"},{url:"/p/us2ahpw/",title:"Rust の Result 型の基本 ─ 成功と失敗を表現する型",date:"2022-12-29T00:00:00Z",body:"Rust の Result 型の基本 ─ 成功と失敗を表現する型 Result 型とは？ Rust の標準ライブラリには、std::result::Result という列挙型 (enum) が用意されており、何らかの処理が「成功」したこと、あるいは「失敗」したことを表現するために使われます（仕組み的には、値の「有無」を表現する Option 型 と同様です）。 他の言語では、例外 (exception) の仕組みでエラーの発生を表現したりしますが、Rust では Result 型を使ってエラーを表現します（Rust には例外の仕組みが存在しません）。 Result 列挙型のバリアントとしては、次のように Ok と Err だけが定義されており、それぞれが何らかの処理の「成功」と「失敗」を表現します。 Result 型の定義 enum Result\u0026lt;T, E\u0026gt; { Ok(T), // T 型の成功値 Err(E), // E 型の失敗値 } 成功と失敗を表すだけであれば、bool 型だけで表現できそうですが、Result 型は Ok と Err というバリアントが任意の値を持つことができるようになっているので、成功した場合の結果や、失敗した場合の理由を表現することができます。 また、何らかのメソッドが Result 型を返すとき、その値を呼び出し側で利用していないと、コンパイラが警告を出してくれるため、エラーのハンドル忘れを防ぐ効果 があります。 Result 型の概念は、他のモダンな言語でも採用されています（例: Kotlin の Result 型）。 これらのシンボルはデフォルトでインポートされるようになっており、Result、Ok、Err と記述するだけで使用することができます（Result::Ok や Result::Err のように記述する必要はありません）。 Result を処理する Result インスタンスから Ok バリアントや Err バリアントの情報を取り出すには、match 式や if let 式を使います。 以下のサンプルコードでは、str::parse メソッドで、数値を含む文字列をパースして i32 値に変換しています。 パースに成功すると Ok バリアントが返されるので、そこからパース結果を取り出すことができます。 パースに失敗すると Err バリアントが返されるので、そこからエラー情報（ParseIntError など）を取り出すことができます。 match 式 Result 列挙型のバリアント（Ok と Err）を漏れなくハンドルしたいときは、match 式を使用します。 let result = \u0026#34;123\u0026#34;.parse::\u0026lt;i32\u0026gt;(); match result { Ok(num) =\u0026gt; println!(\u0026#34;数値 {} としてパースできました\u0026#34;, num), Err(err) =\u0026gt; println!(\u0026#34;パースできませんでした: {}\u0026#34;, err), } if let 式 処理の成功時に Ok バリアントが持つ値を取り出すだけでよければ、if let 構文を使うと簡潔に記述できます。 let result = \u0026#34;123\u0026#34;.parse::\u0026lt;i32\u0026gt;(); if let Ok(num) = result { println!(\u0026#34;数値 {} としてパースできました\u0026#34;, num); } is_ok / is_err メソッド 処理に成功したか、失敗したかだけを確認するには、is_ok や is_err メソッドを使用します。 if result.is_ok() { println!(\u0026#34;成功しました\u0026#34;); } if result.is_err() { println!(\u0026#34;失敗しました\u0026#34;); } unwrap 系メソッド Ok バリアントが含むデータをダイレクトに取り出したいときは、unwrap 系のメソッドを使用します。 ただし、unwrap メソッドは Result の値が Err のときに呼び出すとパニックが発生するので、ほとんどのケースでは使用を避けるべきです（即席の使い捨てプログラムを作るときは便利ですが）。 let result = \u0026#34;ほげ\u0026#34;.parse::\u0026lt;i32\u0026gt;(); // 成功時は i32 値を返し、失敗時はパニックが発生する let num = result.unwrap(); // unwrap の代わりに expect を使うと、パニック時のメッセージを指定できる let num = result.expect(\u0026#34;Failed to parse\u0026#34;); unwrap の代わりに unwrap_or メソッドを使用すると、Err のときに使用する代替値を指定できます。 こちらはパニックが発生しないので安全です。 let num = result.unwrap_or(0); // パースに失敗したときは 0 が返される let num = result.unwrap_or_default(); // 同上（整数型のデフォルト値 0 が使われる） 代替値の生成にコストがかかる場合は、unwrap_or_else メソッドを使って代替値を生成する関数を渡すようにします。 この関数は Err 時にしか呼び出されません。 次の例では、クロージャの形で代替値の生成処理を指定しています。 // パースに失敗したときは代替値生成用の関数を呼び出す let num = result.unwrap_or_else(|_| create_default_value()); // 代替値を生成する関数（本当はコストのかかる処理という想定） fn create_default_value() -\u0026gt; i32 { 999 } クロージャにはエラー値（この場合は ParseIntError）が渡されますが、今回は使わないのでアンダースコア (_) で受け取って無視しています。 Result 型を返す関数の実装例 下記の divide 関数は、整数値の割り算を行う関数です。 計算に成功すると、その結果 (i32) を含む Result::Ok を返し、計算に失敗すると、エラーメッセージ (\u0026amp;str) を含む Result::Err を返します。 fn divide(numerator: i32, denominator: i32) -\u0026gt; Result\u0026lt;i32, \u0026amp;\u0026#39;static str\u0026gt; { if denominator == 0 { return Err(\u0026#34;0 で割ることはできません\u0026#34;); } Ok(numerator / denominator) } match divide(5, 0) { Ok(num) =\u0026gt; println!(\u0026#34;割り算の結果: {}\u0026#34;, num), Err(err) =\u0026gt; println!(\u0026#34;エラー発生: {}\u0026#34;, err), } Result::Ok バリアントに値を設定する必要がないときは、値がないことを示す空タプル () を使って、Ok(()) を返すようにします。 main() 関数の実装でよく見ると思います。 fn perform(action: \u0026amp;str) -\u0026gt; Result\u0026lt;(), \u0026amp;\u0026#39;static str\u0026gt; { if action == \u0026#34;dance\u0026#34; { Ok(()) } else { Err(\u0026#34;実行できませんでした\u0026#34;) } } let result = perform(\u0026#34;sing\u0026#34;); match result { Ok(_) =\u0026gt; println!(\u0026#34;実行完了\u0026#34;), Err(err) =\u0026gt; println!(\u0026#34;エラー: {}\u0026#34;, err), } Result 型でエラーのハンドル忘れを防ぐことができるのはなぜか？ Result 型の定義には、次のように #[must_use] アノテーションが付いているため、何らかのメソッドが戻り値として Result を返したとき、その値を無視できないようになっています（参考: Result 型のコード）。 Result の実装（抜粋） // ... #[must_use = \u0026#34;this `Result` may be an `Err` variant, which should be handled\u0026#34;] pub enum Result\u0026lt;T, E\u0026gt; { // ... } 何らかのメソッドが返した Result を、match や if let で「消費」することで、この警告は表示されなくなります。 参考: The must_use attribute - The Rust Reference"},{url:"/p/96o6xfv/",title:"Rust プログラミングを始める（rustc と cargo コマンド）",date:"2022-12-11T00:00:00Z",body:"Rust プログラミングを始める（rustc と cargo コマンド） Rust 関連コマンドのインストール Rust のインストール Rust コンパイラ (rustc) や Rust 用のパッケージマネージャー (cargo) は、下記の公式サイトの手順で簡単にインストールできます。 推奨されている方法でインストールすると、Rust 関連のコマンドをアップデートするための rustup コマンドもインストールされます。 公式サイト: Rust をインストール - Rustプログラミング言語 Rust のインストール方法の例（Linux/macOS の場合） $ curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 標準構成でインストールすると、Rust 関連の各コマンドが ~/.cargo/bin/ ディレクトリにインストールされます。 Rust 関連コマンドの一覧 $ ls ~/.cargo/bin cargo* clippy-driver* rust-lldb* rustup* cargo-clippy* rls* rustc* cargo-fmt* rust-gdb* rustdoc* cargo-miri* rust-gdbgui* rustfmt* Rust のバージョンアップ 一度 rustup コマンドのインストールが済んでしまえば、上記の Rust 関連コマンド（Rust ツールチェイン）は次のようにまとめてアップデートできます。 Rust ツールチェインの更新 $ rustup update Rust のアンインストール Rust 関連コマンドを削除したいときも、rustup コマンドを使用します。 次のようにすると、rustup コマンドを含む、すべての Rust 関連コマンドがアンインストールされます（$HOME/.cargo/bin ディレクトリも削除されます）。 Rust ツールチェインのアンインストール $ rustup self uninstall rustc コマンドで Rust コードをビルドする 次の main.rs ファイルは、Rust 言語の Hello World プログラムです。 main.rs fn main() { println!(\u0026#34;Hello, world!\u0026#34;); } この main.rs ファイルをコンパイルするには、rustc コマンドを使用します。 デフォルトでは、.rs ファイルのベース名と同じ名前の実行ファイルが生成されます。 Rust コード (.rs) のコンパイル $ rustc main.rs $ ./main Hello, world! -o オプションで、生成する実行ファイル名を指定することもできます。 $ rustc -o hello main.rc $ ./hello Hello, world! 普段の開発では rustc コマンドを直接使うことは少なく、より包括的なパッケージングツールである cargo コマンドを使うのが一般的です。 cargo コマンドで Rust プロジェクトを作成する Rust のデフォルトのビルドシステムである cargo コマンドを使用すると、依存ライブラリの管理や、プロジェクトのパッケージング処理を行うことができます。 Rust プロジェクトの開発は、通常、この cargo コマンドを使って進めることになります。 プロジェクトの作成 (cargo new/init) cargo で新しいプロジェクト (cargo package) を作成するには、cargo new コマンドを使用します（既存のディレクトリを使う場合は、cargo init コマンドを使用します）。 Rust プロジェクトの新規作成 $ cargo new hello Created binary (application) `hello` package このように実行すると、新規プロジェクト用の hello ディレクトリが生成されます。 この中には、Rust プロジェクトの設定ファイルである Cargo.toml や、プログラムのエントリポイントとなる src/main.rs ファイルが含まれています。 また、Git リポジトリとしての初期化も済んでおり、すぐに git commit していけるようになっています。 hello/ ├── .git/ ├── .gitignore ├── Cargo.toml └── src/ └── main.rs ビルドと実行 (cargo run/build) プロジェクトのディレクトリ内で、cargo run コマンドを実行することで、プログラムを実行することができます。 プロジェクトのビルドと実行 $ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/hello` Hello, world! cargo のログ出力を抑制するには、-q (--quite) オプションを追加します。 $ cargo run -q Hello, world! ログ出力から分かるように、内部的にビルドされてできたプログラムは、target ディレクトリ以下に配置されます。 デフォルトではデバッグモードでビルドされるので、target/debug/\u0026lt;実行ファイル名\u0026gt; というパスで実行ファイルが生成されます。 -r (--release) オプションを付けてリリースモードでビルドすると、target/release/\u0026lt;実行ファイル名\u0026gt; というパスに生成されます。 ビルド関連の cargo サブコマンドには、次のようなものがあります。 コマンド 説明 cargo clean target ディレクトリの削除 cargo build ビルド（debug モード） cargo build -r ビルド（release モード） cargo run ビルド＆実行（debug モード） cargo run -r ビルド＆実行（release モード） これで、Rust でプログラミングを始める準備が整いました！ ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/iudtbr8/",title:"GitHub Actions のワークフローをローカルで実行する (act)",date:"2022-12-09T00:00:00Z",body:"GitHub Actions のワークフローをローカルで実行する (act) act とは？ act コマンド は、Casey Lee 氏 (@nektos) が作成した、GitHub Actions ワークフローをローカル実行するためのコマンドです。 nektos/act: Run your GitHub Actions locally 🚀 通常、GitHub Actions のワークフローを実行するには、ワークフローファイル (.github/workflows/*.yml) を作成して、GitHub へコミット＆プッシュする必要がありますが、act コマンドを使うと、ローカルのワークフローファイルをそのまま実行できます。 ローカルでの実行を主目的とした、タスクランナーとしての利用も可能です。 act コマンドは、GitHub Blog でも紹介されています。 Docker と act のインストール act はワークフローの実行環境として Docker コンテナを利用するので、Docker 環境はあらかじめインストールしておいてください。 Docker Desktop をインストールすれば、簡単に Docker 環境が整います。 Docker Desktop act コマンドは Go 言語で実装されており、各 OS 用の実行ファイルが提供されています。 下記の公式ページの説明に従って、OS ごとのパッケージ管理コマンドでインストールしてしまうのが簡単です。 nektos/act: Run your GitHub Actions locally 🚀 例えば、macOS であれば brew install act、Windows であれば choco install act-cli などでインストールできます。 インストールが終わって、次のように実行できるようになっていれば準備完了です。 $ act --version act version 0.2.34 act でワークフローを実行する ワークフローファイル (.yml) の準備 ワークフローファイルがないと始まらないので、まずは GitHub で管理されているリポジトリにワークフローファイルを用意します。 既存のワークフローファイルがなければ、次のように適当に作成してください。 .github/workflows/*.yml というパスで配置すれば、YAML ファイル名は何でも構いません。 .github/workflows/sample.yml name: GitHub Actions Demo run-name: ${{ github.actor }} is testing out GitHub Actions 🚀 on: [push] jobs: Explore-GitHub-Actions: runs-on: ubuntu-latest steps: - run: echo \u0026#34;🎉 The job was automatically triggered by a ${{ github.event_name }} event.\u0026#34; - run: echo \u0026#34;🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\u0026#34; - run: echo \u0026#34;🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\u0026#34; - name: Check out repository code uses: actions/checkout@v3 - run: echo \u0026#34;💡 The ${{ github.repository }} repository has been cloned to the runner.\u0026#34; - run: echo \u0026#34;🖥️ The workflow is now ready to test your code on the runner.\u0026#34; - name: List files in the repository run: ls ${{ github.workspace }} - run: echo \u0026#34;🍏 This job\u0026#39;s status is ${{ job.status }}.\u0026#34; お試し用の GitHub リポジトリの準備が面倒な場合は、下記リポジトリを clone してください。 $ git clone https://github.com/maku77/p-iudtbr8 act コマンドの実行 act コマンドは、デフォルトで push イベントを発生させる ので、上記のワークフロー定義のように、on: [push] トリガーが設定されたものが実行されます。 act の初回起動時には、実行環境とする Docker イメージの選択肢が表示されます。 今回のような簡単な処理であれば、一番小さなイメージ (Micro) を選択しておけば OK です。 $ act ? Please choose the default image you want to use with act: - Large size image: +20GB Docker image, includes almost all tools used on GitHub Actions (IMPORTANT: currently only ubuntu-18.04 platform is available) - Medium size image: ~500MB, includes only necessary tools to bootstrap actions and aims to be compatible with all actions - Micro size image: \u0026lt;200MB, contains only NodeJS required to bootstrap actions, doesn\u0026#39;t work with all actions Default image and other options can be changed manually in ~/.actrc (please refer to https://github.com/nektos/act#configuration for additional information about file structure) [Use arrows to move, type to filter, ? for more help] Large Medium \u0026gt; Micro 実行用の Docker イメージのダウンロードが完了すると、ワークフロー内のジョブが実行されます。 act コマンドの出力例 [GitHub Actions Demo/Explore-GitHub-Actions] 🚀 Start image=node:16-buster-slim [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker pull image=node:16-buster-slim platform= username= forcePull=false [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker create image=node:16-buster-slim platform= entrypoint=[\u0026#34;/usr/bin/tail\u0026#34; \u0026#34;-f\u0026#34; \u0026#34;/dev/null\u0026#34;] cmd=[] [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker run image=node:16-buster-slim platform= entrypoint=[\u0026#34;/usr/bin/tail\u0026#34; \u0026#34;-f\u0026#34; \u0026#34;/dev/null\u0026#34;] cmd=[] [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo \u0026#34;🎉 The job was automatically triggered by a push event.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/0] user= workdir= | 🎉 The job was automatically triggered by a push event. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo \u0026#34;🎉 The job was automatically triggered by a push event.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo \u0026#34;🐧 This job is now running on a Linux server hosted by GitHub!\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/1] user= workdir= | 🐧 This job is now running on a Linux server hosted by GitHub! [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo \u0026#34;🐧 This job is now running on a Linux server hosted by GitHub!\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo \u0026#34;🔎 The name of your branch is refs/heads/main and your repository is maku77/p-iudtbr8.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir= | 🔎 The name of your branch is refs/heads/main and your repository is maku77/p-iudtbr8. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo \u0026#34;🔎 The name of your branch is refs/heads/main and your repository is maku77/p-iudtbr8.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main Check out repository code [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker cp src=../mnt/d/y/gitwork/maku77/p-iudtbr8/. dst=/mnt/d/y/gitwork/maku77/p-iudtbr8 [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main Check out repository code [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo \u0026#34;💡 The maku77/p-iudtbr8 repository has been cloned to the runner.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/4] user= workdir= | 💡 The maku77/p-iudtbr8 repository has been cloned to the runner. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo \u0026#34;💡 The maku77/p-iudtbr8 repository has been cloned to the runner.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo \u0026#34;🖥️ The workflow is now ready to test your code on the runner.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/5] user= workdir= | 🖥️ The workflow is now ready to test your code on the runner. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo \u0026#34;🖥️ The workflow is now ready to test your code on the runner.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main List files in the repository [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/6] user= workdir= | README.md [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main List files in the repository [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo \u0026#34;🍏 This job\u0026#39;s status is success.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/7] user= workdir= | 🍏 This job\u0026#39;s status is success. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo \u0026#34;🍏 This job\u0026#39;s status is success.\u0026#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🏁 Job succeeded 何らかのコマンドが足りないというエラーが出たら、Docker の実行イメージを変えて実行してみてください。 使用する Docker イメージを変更する act のワークフロー実行に使用する Docker イメージを切り替えたくなったら、公式サイトの configuration の項目 に従って設定してください。 例えば、Medium Docker Image (ubuntu-latest) を使いたくなった場合は、カレントディレクトリ、あるいはホームディレクトリに .actrc というファイルを作成して、次のように記述すれば OK です。 これは、ワークフローファイルの中で、runs-on: ubuntu-latest と指定されたときに、具体的にどの Docker イメージを使用するかを示しています。 ~/.actrc -P ubuntu-latest=catthehacker/ubuntu:act-latest このファイルは、act コマンドに渡すデフォルトのオプションを列挙したものです。 act コマンド実行時に次のように直接オプション指定しても OK です。 $ act -P ubuntu-latest=catthehacker/ubuntu:act-latest いろんな使い方 push 以外のイベントを発生させる $ act pull_request act コマンドは、最初の引数でイベント名を受け取ります（デフォルトは pull）。 例えば上記のように実行すると、on: [pull_request] と定義されているワークフローが実行されます。 ワークフローの一覧 $ act --list Stage Job ID Job name Workflow name Workflow file Events 0 log-the-inputs log-the-inputs dispatch.yml dispatch.yml workflow_dispatch 0 specific_review_requested specific_review_requested pull.yml pull.yml pull_request 0 Explore-GitHub-Actions Explore-GitHub-Actions GitHub Actions Demo sample.yml push act コマンドの -l (--list) オプションで、ワークフローの定義一覧を表示できます（要するに、.github/workflows 以下の .yml ファイルの内容の一覧です）。 トリガーとなるイベントの一覧もここで確認できます。 シークレットを渡す $ act -s MY_SECRET1=value1 -s MY_SECRET2=value2 $ act --secret-file my.secrets GitHub 上で設定するシークレット変数をシミュレートするために、-s (--secret) オプションを使用できます。 あるいは、--secret-file オプションで、キー＆バリュー情報を列挙したシークレットファイルを読み込むことができます（このオプションを指定しなくても、act はデフォルトで .secrets という名前のファイルを読み込みます）。 シークレットファイルのフォーマットは .env と同等です。 my.secrets # この行はコメント MY_SECRET1=value1 MY_SECRET2=value2"},{url:"/p/q2k3j2h/",title:"Linux シェルスクリプト: echo の結果を標準エラー出力 (stderr) に出力する",date:"2022-12-05T00:00:00Z",body:"Linux シェルスクリプト: echo の結果を標準エラー出力 (stderr) に出力する 標準エラー出力への出力 echo コマンドの出力結果を、デフォルトの標準出力ではなく、標準エラー出力に出力するには、末尾で 1\u0026gt;\u0026amp;2 のようにリダイレクトします（\u0026gt;\u0026amp;2 という省略形でも OK）。 #!/bin/bash echo \u0026#34;Hello World\u0026#34; 1\u0026gt;\u0026amp;2 このように出力先を制御したプログラムは、実行結果をリダイレクトしたり、パイプ接続した場合の振る舞いに影響してきます。 sample.sh #!/bin/bash echo AAA echo BBB 1\u0026gt;\u0026amp;2 echo CCC 上記のプログラムの出力結果を out.txt というファイルにリダイレクトすると、ターミナル上には BBB という標準エラー出力のみが表示されます。 実行例 $ ./sample.sh \u0026gt; out.txt BBB out.txt の内容 AAA CCC cat の場合 cat コマンドによるヒアドキュメントでも、標準エラー出力に出力できます。 cat 1\u0026gt;\u0026amp;2 \u0026lt;\u0026lt;EOF AAA AAA AAA BBB BBB BBB CCC CCC CCC EOF シェルスクリプトの Usage 出力などに便利です。 usage() { cat 1\u0026gt;\u0026amp;2 \u0026lt;\u0026lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .) -v Use verbose output EOF exit -1 } その他の出力先制御 コマンドの出力をさまざまな形でリダイレクトすることで、本来の標準出力、標準エラー出力への出力を次のように振り分けることができます。 出力先の凡例 \u0026hellip; STDOUT: 標準出力、STDERR: 標準エラー出力、FILE: ファイル、─: 出力されない コマンド形式 標準出力 標準エラー出力 command STDOUT STDERR command \u0026gt;\u0026amp;2 command 1\u0026gt;\u0026amp;2 STDERR STDERR command 2\u0026gt;\u0026amp;1 STDOUT STDOUT command \u0026gt; /dev/null ─ STDERR command \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 ─ ─ command \u0026gt; file FILE STDERR command \u0026gt; file 2\u0026gt;\u0026amp;1 FILE FILE command 2\u0026gt;\u0026amp;1 \u0026gt; file FILE STDOUT 読み解き方: \u0026amp;1 \u0026hellip; 現在、標準出力 (1) に割り当てられている出力先 \u0026amp;2 \u0026hellip; 現在、標準エラー出力 (2) に割り当てられている出力先 1\u0026gt;\u0026amp;2 \u0026hellip; 標準出力 (1) の出力先を \u0026amp;2 に切り替える 2\u0026gt;\u0026amp;1 \u0026hellip; 標準エラー出力 (2) の出力先を \u0026amp;1 に切り替える \u0026gt; file \u0026hellip; 標準出力 (1) の出力先を file に切り替える"},{url:"/p/2fyizgw/",title:"Linux シェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts)",date:"2022-12-05T00:00:00Z",body:"Linux シェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts) Bash 組み込みの getopts コマンドを使用すると、シェルスクリプトに渡されたコマンドラインオプション (-a など）を解析することができます。 getopts は 1 文字のオプションしか扱えないことに注意してください。 引数なしのオプション 下記は getopts の基本的な使用例です。 getopts のオプション文字列として abc を指定することにより、このシェルスクリプトには、-a、-b、-c という 3 種類のオプションを受け取れるようになっています。 ユーザーが指定したオプションが、1 文字ずつ opt 変数に格納されるので、その値で case による分岐処理を行います。 sample.sh #!/bin/bash while getopts \u0026#39;abc\u0026#39; opt; do case \u0026#34;${opt}\u0026#34; in a) echo \u0026#34;オプション -a を指定しました\u0026#34; ;; b) echo \u0026#34;オプション -b を指定しました\u0026#34; ;; c) echo \u0026#34;オプション -c を指定しました\u0026#34; ;; esac done 実行例 $ ./sample.sh -a オプション -a を指定しました $ ./sample.sh -a -c オプション -a を指定しました オプション -c を指定しました $ ./sample.sh -x ./sample.sh: illegal option -- x 最後の実行例から分かるように、getopts は定義されていないオプション (-x) を指定したときに、自動的にエラーメッセージ (illegal option) を出力します。 このエラー出力を抑制するには、次のように、オプション文字列の先頭に : を付け、:abc のように指定します。 不正なオプションが指定された場合は、opt 変数の値が ? になるので、自分でエラー処理を行うことも可能です。 sample.sh #!/bin/bash while getopts \u0026#39;:abc\u0026#39; opt; do case \u0026#34;${opt}\u0026#34; in a) echo \u0026#34;オプション -a を指定しました\u0026#34; ;; b) echo \u0026#34;オプション -b を指定しました\u0026#34; ;; c) echo \u0026#34;オプション -c を指定しました\u0026#34; ;; ?) echo \u0026#34;不正なオプション\u0026#34; \u0026gt;\u0026amp;2 ;; esac done ちなみに、echo の末尾の \u0026gt;\u0026amp;2 は、標準エラー出力への出力を意味しています（参考: echo の結果を標準エラー出力 (stderr) に出力する）。 引数ありのオプション getopts では、次のような引数ありのオプションを扱うこともできます。 $ ./sample -b 100 -c 200 引数ありのオプションにしたいときは、オプション文字列の対象文字の後ろに : を付けます。 次の例では、-b オプションと -c オプションに引数を指定できるようにしています。 オプションに指定した引数の値は、$OPTARG 変数で参照できます。 sample.sh #!/bin/bash while getopts \u0026#39;ab:c:\u0026#39; flag; do case \u0026#34;${flag}\u0026#34; in a) echo \u0026#34;オプション -a を指定しました\u0026#34; ;; b) echo \u0026#34;オプション -b を指定しました（引数=${OPTARG}）\u0026#34; ;; c) echo \u0026#34;オプション -c を指定しました（引数=${OPTARG}）\u0026#34; ;; esac done 実行例 $ ./sample.sh -a -b 100 オプション -a を指定しました オプション -b を指定しました（引数=100） なお、引数ありのオプション（b: など）にした場合は、引数を指定しなかった場合はエラーになります。 $ ./sample.sh -b ./sample.sh: option requires an argument -- b getopts の実践的な使用例 sample.sh #!/bin/bash usage() { cat 1\u0026gt;\u0026amp;2 \u0026lt;\u0026lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .) -v Use verbose output EOF exit -1 } outdir=\u0026#39;.\u0026#39; verbose=\u0026#39;\u0026#39; while getopts \u0026#39;:d:vh\u0026#39; opt; do case \u0026#34;${opt}\u0026#34; in d) outdir=\u0026#34;${OPTARG}\u0026#34; ;; v) verbose=\u0026#39;true\u0026#39; ;; h) usage ;; ?) usage ;; esac done if [ ! -z \u0026#34;$verbose\u0026#34; ]; then echo \u0026#34;Verbose mode\u0026#34; fi echo Output directory is \u0026#34;${outdir}\u0026#34; 実行例 $ ./sample.sh Output directory is . $ ./sample.sh -d out -v Verbose mode Output directory is out $ ./sample.sh -h Usage: sample.sh [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .) -v Use verbose output"},{url:"/linux/",title:"Linux/Shell",date:"2022-12-05T00:00:00Z",body:"Linux/Shell シェルスクリプト / Bash プログラミング シェルスクリプトのコーディングスタイル 変数 変数の基本 定数を定義する (readonly) シェル変数/環境変数がセットされているか調べる Bash の変数展開機能を活用する（文字列の置換、デフォルト値など） 配列 配列を作成する 配列をループ処理する 配列のサイズ（要素数）を調べる 配列に要素を追加する 配列と配列を結合する 数値 数値変数を加算／減算する ランダムな数値を取得する ($RANDOM) 制御構文 if-else による分岐処理 case による分岐処理 for/while によるループ処理 ループ内での複数の出力をまとめてリダイレクト、パイプ処理する 起動時の処理 コマンドライン引数を取得する ($1, $@, $*) コマンドライン引数の数が正しいかチェックする ($#) 名前付きのコマンドラインオプションを扱う (getopts) ある環境変数が定義されているかチェックする (test -z) ある外部コマンドが使用できるかチェックする (type -P) 関数 関数を定義する (function) 関数へパラメータを渡す 関数内でローカル変数を扱う 関数から戻り値を返す 関数のデフォルト引数を定義する パス 絶対パスと相対パスの変換 (basename, dirname) 指定したファイルの絶対パスを取得する カレントディレクトリの絶対パスを取得する 実行中のシェルスクリプトのファイル名を取得する 実行中のシェルスクリプトがあるディレクトリの絶対パスを取得する 実行中のシェルスクリプトがあるディレクトリに移動する 入出力 (I/O) echo の結果を標準エラー出力 (stderr) に出力する (1\u0026gt;\u0026amp;2) echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ echo で出力する文字の色を変える ユーザ入力を取得する (read) ディレクトリ内のファイルを順に処理する (for, while) 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read) テキストファイルを 1 行ずつ読み込む (read) expect で外部コマンドの出力を待機する 日時 今日の日付から YYYYMMDD のような文字列を作成する (date) トラブルシューティング 改行コードが原因の関数定義の syntax error D-Bus D-Bus 全般 D-Bus 関連用語 D-Bus 関連リンクと関連ツール GDBus と dbus-glib dbus-glib dbus-glib 開発用ライブラリをインストールする dbus-glib で method call を実装する（ヘッダファイルの生成） dbus-glib で method call を実装する（サーバ側の実装） dbus-glib で method call を実装する（クライアント側の実装） GDBubs GDBus で簡単な P2P（クライアント＆サーバ）アプリを実装する GDBus サーバから signal を発行する GDBus でバイナリデータ（バイト配列）を受け取る方法 glib の GVariant を使ってみる D-Bus Java D-Bus Java をインストールする D-Bus Java で Session bus に接続してメソッドを呼び出す D-Bus Java で P2P D-Bus サーバに接続してメソッドを呼び出すサンプル dbus-python dbus-python の公式サンプルコード dbus-python で Session bus を使用するサーバ＆クライアントを実装する（単純なメソッドの実装） dbus-python で Session bus を使用するサーバ＆クライアントを実装する（シグナルの実装） dbus-python で D-Bus の P2P クライアントを実装する Linux システム／管理 コマンド Linux カーネル／OS のバージョンを調べる bash のバージョンを調べる ($BASH_VERSION) Linux の各種 ID（プロセス ID やユーザ ID など）についてのメモ カーネルに渡されたパラメータを調べる (/proc/cmdline) Linux のメモリ情報を調べるコマンド NTP でシステム時刻を設定する ディレクトリ内のファイルを zip ファイルにバックアップする Deep Learning や仮想通貨のマイニング時に CPU 使用率が 100% になってしまうのを防ぐ (cpulimit) プログラミング Linux システムコールを使用して core dump を吐かないようにする (setrlimit) Linux コマンド全般　Linuxコマンド: ファイルやディレクトリを検索する (find, grep) Windows で Linux 系のコマンドを使用できるようにする (Gow) rsync コマンドでディレクトリを同期する 行番号付きでテキストファイルの内容を出力する (cat -b) あるファイルがテキストファイルかどうか調べる (file) リダイレクトとパイプ処理のまとめ Linux でリダイレクトによってファイルが上書きされてしまうのを防ぐ ls コマンドが使えないときに echo コマンドで代用する いずれかの文字列を含むファイルだけを列挙する curl コマンド プロキシ経由で curl コマンドを実行する curl で HTTP のレスポンスヘッダのみを確認する"},{url:"/p/f2eggno/",title:"GitHub Actions で GitHub wiki ページを自動更新する",date:"2022-11-28T00:00:00Z",body:"GitHub Actions で GitHub wiki ページを自動更新する 何をするか？ GitHub で管理しているリポジトリに対してコミット＆プッシュが行われたときに、自動的に GitHub wiki 側のリポジトリの内容（Markdown ファイル）を更新するようにしてみます。 例えば、プロダクトのソースコードからドキュメントを自動生成して、開発者がいつでも GitHub wiki ページで参照できるようにしておくと便利です。 図: GitHub wiki ページの自動生成 wiki ページの更新には GitHub Actions のワークフローを使い、次のように自動実行されるよう設定します。 メインリポジトリを対象としたプッシュで GitHub Actions ワークフローを起動 メインリポジトリと wiki リポジトリのソースコードを取得 何らかの外部ツールを実行して Markdown ファイルを生成 Markdown ファイルを wiki リポジトリにコミット＆プッシュ ワークフローの中で GitHub wiki のリポジトリをチェックアウトしているので、あらかじめ対象リポジトリの wiki を作成しておいてください（トップページだけで OK）。 ワークフローファイルの作成 GitHub wiki を自動更新するための、Actions のワークフローファイルを作成します。 .yml 拡張子のファイルを .github/workflows ディレクトリ以下に配置してコミットすれば、GitHub サービス側でワークフローとして認識してくれます。 ここでは、update-wiki.yml というファイル名にしてみました。 .github/workflows/update-wiki.yml name: Update wiki pages on: push: branches: [ main, master ] workflow_dispatch: jobs: update-wiki: runs-on: ubuntu-latest timeout-minutes: 3 steps: - name: Check out main repo uses: actions/checkout@v3 - name: Check out wiki repo uses: actions/checkout@v3 with: repository: \u0026#34;${{ github.repository }}.wiki\u0026#34; path: .wiki - name: Update wiki pages run: echo -e \u0026#34;# Hello\\n\\n$(date)\u0026#34; \u0026gt; .wiki/hello.md - name: Stage and count changes working-directory: .wiki id: staging run: | git add . echo \u0026#34;NUM_OF_STAGED=$(git diff --staged --name-only | wc -l)\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT - name: Commit wiki pages working-directory: .wiki if: steps.staging.outputs.NUM_OF_STAGED \u0026gt; 0 run: | git config user.email \u0026#34;41898282+github-actions[bot]@users.noreply.github.com\u0026#34; git config user.name \u0026#34;github-actions[bot]\u0026#34; git commit -m \u0026#34;${GITHUB_WORKFLOW}\u0026#34; git push 定義しているジョブは、update-wiki というジョブ 1 つだけです。 以下、このジョブの各ステップを順番に見ていきます。 メインリポジトリのチェックアウト - name: Check out main repo uses: actions/checkout@v3 公式の actions/checkout アクションを使って、メインリポジトリのコードをチェックアウトしておきます。 実は今回のサンプルでは、メインリポジトリのコードは利用していないのですが、ソースコードをもとに wiki ページを生成するのであれば必要になるでしょう。 Markdown ファイルを生成するためのスクリプトが、メインリポジトリの tools ディレクトリなどに入っているかもしれません。 wiki リポジトリのチェックアウト - name: Check out wiki repo uses: actions/checkout@v3 with: repository: \u0026#34;${{ github.repository }}.wiki\u0026#34; path: .wiki wiki リポジトリの名前は、${{ github.repository }}.wiki で参照できるので、actions/checkout アクションでリポジトリ名を指定してチェックアウトします。 チェックアウト先として、.wiki という名前の作業ディレクトリを作成しています。 後のステップで、この中に Markdown ファイルを生成（修正）してコミットすることになります。 wiki ページ（Markdown ファイル）更新 - name: Update wiki pages run: echo -e \u0026#34;# Hello\\n\\n$(date)\u0026#34; \u0026gt; .wiki/hello.md ここが wiki ページ生成の本質的なステップで、.wiki ディレクトリの中に Markdown ファイルを生成（修正）します。 ここではシンプルに、Hello というタイトルと現在の日時が書き込まれた hello.md ファイルを作成していますが、通常はもっと複雑な更新作業になるので、外部ツールなどを呼び出して Markdown ファイルを生成することになります。 例えば、次のようにメインリポジトリ側のシェルスクリプトを呼び出します（引数で出力先ディレクトリ .wiki の絶対パスを渡しておくと親切です）。 - name: Update wiki pages run: ./tools/update-wiki.sh $GITHUB_WORKSPACE/.wiki ちなみに、シェルスクリプトを Windows でコミットするときは、次のようにして実行権限を付けてコミットします。 $ git update-index --add --chmod=+x tools/update-wiki.sh 変更内容のステージング - name: Stage and count changes working-directory: .wiki id: staging run: | git add . echo \u0026#34;NUM_OF_STAGED=$(git diff --staged --name-only | wc -l)\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT 前述のステップで生成した Markdown ファイルを、wiki リポジトリの方にステージング (git add) します。 ここでのポイントは、いくつのファイルがステージング状態になったか（変更されたか）を、$GITHUB_OUTPUT に出力しておくことです。 例えば、3 つのファイルが変更されている場合は、NUM_OF_STATE=3 のようなキー＆バリューを出力しておきます。 この値は、次のステップで使用します。 wiki リポジトリへのコミット＆プッシュ - name: Commit wiki pages working-directory: .wiki if: steps.staging.outputs.NUM_OF_STAGED \u0026gt; 0 run: | git config user.email \u0026#34;41898282+github-actions[bot]@users.noreply.github.com\u0026#34; git config user.name \u0026#34;github-actions[bot]\u0026#34; git commit -m \u0026#34;${GITHUB_WORKFLOW}\u0026#34; git push 最後に、自動生成した Markdown ファイルを wiki リポジトリへコミット＆プッシュします。 このステップは、前段のステップでセットした出力内容 steps.staging.outputs.NUM_OF_STAGED の値が 0 より大きいとき、つまり、コミットすべきファイルが存在するときのみ実行します。 wiki ページを変更する必要がない場合は、このステップはスキップされて、ワークフローの実行は終了します。 上記のように自力で git commit コマンドを呼び出す場合は、Git の user.email と user.name を設定しておかないとエラーになることに注意してください。 上記の例では、コミュニティで提案されている github-actions[bot] というユーザーを設定しています（参考: Set git user and email）。 このユーザーを指定しておくと、コミット履歴などで次のようなアイコンが表示されるようになります。 図: GitHub Actions ユーザーによる変更履歴 テスト ワークフローファイルを main ブランチにコミットし、GitHub へプッシュすると、自動的に Markdown ファイル (hello.md) が生成され、wiki リポジトリ側にコミットされます。 次のようなページが生成されていれば成功です。 図: GitHub Actions で自動生成された wiki ページ できたー ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/5f2j2hz/",title:"Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する",date:"2022-11-27T00:00:00Z",body:"Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する 何をするか？ 複数の Web アプリを 1 つの VPS（レンタルサーバー）でホスティングする場合、一般的にはリバースプロキシ（nginx など）を立てて、各 Web アプリのバックエンドに繋ぐことになります。 例えば、nginx のバーチャルホスト機能を使って、app1.example.com というアドレスと app2.example.com というアドレスでアクセスされたときに、それぞれ別の Web アプリサーバー（バックエンド）に処理を振り分けます。 ここでは、リバースプロキシと 2 つの Web アプリを別々の Docker Compose で立ち上げて連携する方法を説明します。 図: リバースプロキシによる Docker Compose 連携 1 セットの Web アプリであれば、1 つの Docker Compose 内に関連するコンテナをすべて含めてしまうのが楽ですが、ここでは、独立した 2 つの Web アプリを 1 つの物理サーバー (VPS) 上で運用することを考えているので、別々の Docker Compose に分けています。 もちろん、各アプリが使用する DB コンテナなどは、それぞれの Docker Compose 内にある想定ですが、上記の図では省略しています。 ここで紹介しているソースコードは GitHub に置いてあります。 テスト用の事前準備（hosts ファイル） 今回使用する nginx の設定ファイルでは、app1.example.com と app2.example.com という仮のドメインを使用していますが、本来は実在するドメインでなければいけません。 この設定のままテストしたい場合は、OS の hosts ファイルに次のようなエントリを追加して、ローカルホスト (127.0.0.1) を指すように設定しておきます。 # For development 127.0.0.1	app1.example.com 127.0.0.1	app2.example.com 例えば、macOS の場合は、次のように hosts ファイルを開いて編集します。 hosts ファイルを編集（macOS の場合） $ sudo vi /private/etc/hosts これで、Web ブラウザで http://app1.example.com/ や http://app2.example.com/ にアクセスしたときに、http://localhost/ にアクセスしたのと同じように振る舞うようになります。 ブリッジネットワークの作成 Docker Compose で起動したコンテナ群は、デフォルトで {ディレクトリ名}_default という名前のブリッジネットワークに接続されますが、ここでは reverse-proxy-network という名前のネットワークを生成して、そこにリバースプロキシと連携するすべてのコンテナを接続するようにします。 Docker ネットワークの作成 $ docker network create reverse-proxy-network ネットワーク名は Docker ホスト内で一意になっている必要がありますが、1 つの Docker ホスト (= VPS) 内に複数のリバースプロキシを立てることはあまりないでしょうし、この名前 (reverse-proxy-network) で大丈夫だと思います。 Web アプリ用の Docker Compose 2 つの Web アプリ用の docker-compose.yml ファイルと、テスト用の index.html ファイルを、次のようなディレクトリ構造で用意します。 - webapp1/ +-- docker-compose.yml +-- public/index.html （I am webapp1 と表示するだけ） - webapp2/ +-- docker-compose.yml +-- public/index.html （I am webapp2 と表示するだけ） 下記は、1 つ目の Web アプリの docker-compose.yml ファイルの設定例です。 2 つ目の Web アプリはほぼ同様の内容なので省略します（エイリアス名の app1-container というところが app2-container に変わるだけです）。 webapp1/docker-compose.yml services: app: image: nginx:alpine volumes: - ./public:/usr/share/nginx/html networks: default: reverse-proxy-network: aliases: - app1-container networks: reverse-proxy-network: external: true ポイントは、外部で定義したネットワーク reverse-proxy-network に、nginx コンテナを接続しているところです。 external: true を指定するのを忘れると、この Docker Compose 内に閉じたネットワーク (webapp1_reverse-proxy-network) が生成されてしまうので注意してください。 あと、バックエンド DB などのコンテナに接続できるようにするために、自動生成される default ネットワークにも繋いでおきます（実際のネットワーク名は webapp1_default などになります）。 さらに、リバースプロキシ側からこの nginx サーバーを参照しやすいように、コンテナのエイリアス名 app1-container を設定しています。 これを設定しなくても、webapp1-app-1 のようなディレクトリ名から自動生成されたコンテナ名でアクセスすることはできますが、ちょっと分かりにくいので、エイリアス名を付けておくことをおすすめします。 エイリアス名は、ネットワーク内で一意になっていれば十分です。 サービスのプロパティで container_name: app1-container のようにすると、コンテナ名自体を変更することができますが、コンテナ名は Docker ホスト内で一意でないといけないので、エイリアス名を使った方がよいでしょう。 ちなみに、この nginx サーバーは、同一ネットワーク内のリバースプロキシからのみ接続できれば良いので、Docker ホスト (VPS) 側へのポート公開設定は必要ありません。 リバースプロキシ用の Docker Compose リバースプロキシ用の Docker Compose は次のようなディレクトリ構成で作成します。 - reverse-proxy/ +-- docker-compose.yml +-- conf.d/example.com.conf （nginx の設定ファイル） リバースプロキシの Compose ファイルでも、Web アプリ側と同じ reverse-proxy-network に接続するように設定します。 こちらは特にコンテナのエイリアス名などは設定する必要はありませんが、インターネット経由でアクセスできるように、Docker ホストのポートフォワード設定 (80:80) をしておく必要があります。 reverse-proxy/docker-compose.yml services: reverse-proxy: image: nginx:alpine ports: - \u0026#34;80:80\u0026#34; volumes: - ./conf.d:/etc/nginx/conf.d networks: - reverse-proxy-network networks: reverse-proxy-network: external: true nginx の設定ファイルは、バインドマウントで下記のファイルを使用するように設定しています。 reverse-proxy/conf.d/example.com.conf server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app1.example.com; location / { proxy_pass http://app1-container/; } } server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app2.example.com; location / { proxy_pass http://app2-container/; } } この nginx のバーチャルホスト設定により、インターネット側からのアクセスが次のように各 Web アプリのコンテナに転送されるようになります。 http://app1.example.com/ でのアクセス → http://app1-container/ へ転送 http://app2.example.com/ でのアクセス → http://app2-container/ へ転送 Docker Compose の起動 2 つの Web アプリと、リバースプロキシの Docker Compose を次のように起動します。 すべての Docker Compose を起動 # webapp1 ディレクトリで $ docker compose up -d # webapp2 ディレクトリで $ docker compose up -d # reverse-proxy ディレクトリで $ docker compose up -d リバースプロキシ (nginx) の設定内で、Web アプリのコンテナ（エイリアス名）を参照しているため、上記のような順番で起動しなければいけないことに注意してください。 これで、Web ブラウザから http://app1.example.com/ というアドレスでアクセスしたときは I am webapp1、http://app2.example.com/ というアドレスでアクセスしたときは I am webapp2 と表示されるはずです。 できたー ٩(๑❛ᴗ❛๑)۶ わーぃ テストが終わって、Docker Compose をすべて停止したいときは、起動時と同様に各ディレクトリ内で docker compose down していくか、次のように -p オプションでプロジェクト名を指定して停止します。 あと片づけ $ docker compose -p reverse-proxy down $ docker compose -p webapp1 down $ docker compose -p webapp2 down おつかれ様でしたー。 （おまけ）コンテナ名ではなくポート番号で連携させる 上記の説明では、リバースプロキシとする nginx と、2 つの Web サーバーをコンテナ名で連携させましたが、Web サーバー側のポートを公開すれば、ポート番号で連携させることも可能です。 各 Web サーバーを単独で立ち上げてアクセスするケースがある場合は、こちらの方が都合がよいかもしれません。 例えば、2 つの Web サーバーをそれぞれ 8001 番、8002 番ポートで公開すれば、リバースプロキシからは次のようなアドレスでアクセスできます（参考: Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal)）。 host.docker.internal:8001 host.docker.internal:8002 この場合、リバースプロキシの設定は次のようになります。 reverse-proxy/conf.d/example.com.conf server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app1.example.com; location / { proxy_pass http://host.docker.internal:8001/; } } server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app2.example.com; location / { proxy_pass http://host.docker.internal:8002/; } } 各コンテナ用の Compose ファイルは次のようになります。 reverse-proxy/docker-compose.yml services: reverse-proxy: image: nginx:alpine ports: - \u0026#34;80:80\u0026#34; volumes: - ./conf.d:/etc/nginx/conf.d webapp1/docker-compose.yml services: app: image: nginx:alpine volumes: - ./public:/usr/share/nginx/html ports: - \u0026#34;${PORT:-8001}:80\u0026#34; webapp2/docker-compose.yml services: app: image: nginx:alpine volumes: - ./public:/usr/share/nginx/html ports: - \u0026#34;${PORT:-8002}:80\u0026#34; ☝️ Docker ポート公開に注意 現時点での Docker (ver.20) では、公開ポートの設定で 8001:80 と指定すると、iptables 設定に穴が開いてインターネット上にポート 8001 番が公開されてしまうことに注意してください。 内部的な設定の優先度の問題で、Ubuntu のファイアウォール (ufw) などで公開していないポートに関してもアクセス可能になってしまいます。 確実にホスト内からのアクセスに限定するには、ports フィールドの指定で、127.0.0.1:8001:80 のようにループバックアドレスを合わせて指定します。"},{url:"/p/qatbs9p/",title:"Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する",date:"2022-11-26T00:00:00Z",body:"Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する Docker コンテキストとは？ Docker コンテキストは、ひとことで言うと、Docker CLI で入力したコマンド (docker) の操作対象ホストを切り替えるための仕組みです。 図: Docker コンテキストの切り替え 例えば、Conoha などの VPS サーバー や、Azure (ACI)、AWS (ECS) といったクラウドサービス上の Docker エンジンに対して、ローカルホストから docker コマンドを実行できるようになります。 カレントコンテキストは、docker compose use コマンドで簡単に切り替えることができるので、ローカルでのコンテナのテストが終わったら、コンテキストを Azure (ACI) に切り替えてクラウド環境上で docker compose up するといったことが簡単にできます。 当然、接続先のコンテナサービスごとに接続プロトコルは異なるのですが、Docker は標準で Azure や AWS をターゲットとしたコンテキストの作成に対応しており、実際に docker コマンドを実行するときは接続プロトコルを意識しないで済むようになっています。 ここでは、より汎用的な SSH 接続を用いるコンテキストを作成し、リモートホスト上の Docker エンジンに対して Docker コマンドを実行してみます。 前提条件: リモートホストに Docker がインストールされていること リモートホストに SSH キーで SSH 接続できるようなっていること（参考: SSH の使い方） 接続先のユーザーが sudo なしで docker コマンドを実行できるようなっていること（参考: docker グループへの追加） デフォルト・コンテキスト Docker Desktop をインストールすると、デフォルトのコンテキストとして、default という名前のコンテキストが作成されます。 Docker コンテキストの一覧を表示するには、docker context ls コマンドを使用します。 Docker コンテキストの一覧を確認する $ docker context ls NAME TYPE DESCRIPTION DOCKER ENDPOINT KUBERNETES ENDPOINT ORCHESTRATOR default * moby Current DOCKER_HOST based configuration unix:///var/run/docker.sock swarm default コンテキストのエンドポイントは unix:///var/run/docker.sock となっており、これはローカルホスト上の Docker デーモンに対して Docker コマンドを実行することを示しています。 リモートホストへの SSH 接続設定 SSH 接続に使用するユーザー情報などは、~/.ssh/config ファイルにまとめて記述しておくと便利です。 というか、これを使わないと、細かい接続設定を行うのが困難なので作成しておきましょう。 ~/.ssh/config Host conoha Hostname example.com Port 22 User maku IdentityFile ~/.ssh/id_ed25519 ここでは、Conoha VPS を使う想定で、設定名を conoha にしましたが、このあたりは自由に決めてください。 SSH キー（秘密鍵）にパスフレーズが設定されている場合は、SSH agent に秘密鍵とそのパスフレーズを設定しておく必要があります。 SSH agent に秘密鍵を登録しておく $ ssh-add ~/.ssh/id_ed25519 Enter passphrase for /Users/maku/.ssh/id_ed25519: （秘密鍵のパスフレーズを入力） Identity added: /Users/maku/.ssh/id_ed25519 (maku@macbook.local) SSH 接続用の Docker コンテキストを作成する 新しい Docker コンテキストを作成するには、docker context create コマンドを使用します。 --docker オプションを次のように指定すると、SSH 接続用のコンテキストを作成できます。 Docker コンテキストを作成する $ docker context create --docker \u0026#34;host=ssh://conoha\u0026#34; my-context ssh://conoha という接続 URI では、前述の ~/.ssh/config で設定した名称を使用していることに注意してください。 ssh://maku@example.com:22 のように、明示的な URI を指定することもできます。 次のように実行すると、新しいコンテキスト my-context が作成されていることを確認できます。 $ docker context ls NAME TYPE DESCRIPTION DOCKER ENDPOINT KUBERNETES ENDPOINT ORCHESTRATOR default * moby Current DOCKER_HOST based configuration unix:///var/run/docker.sock swarm my-context moby ssh://conoha この段階では、まだカレントコンテキストは default のままです。 コンテキストを切り替えて Docker コマンドを実行する 使用する Docker コンテキストを切り替えるには、docker context use コマンドを使用します。 コンテキストを my-context に切り替える # コンテキストを切り替え $ docker context use my-context my-context # カレントコンテキストを確認（アクティブなコンテキストに * 印が付いている） $ docker context ls NAME ...(省略)... my-context * ...(省略)... default ...(省略)... # 次のようにカレントコンテキスト名だけ表示することも可能 $ docker context show my-context あとは、いつも通り docker コマンドを実行すると、SSH 接続先の Docker ホストで処理されるようになります。 $ docker container run --rm hello-world 例えば、リモートホスト側で次のような感じで Web サーバーを起動し、ローカルホスト側からアクセスできるようになります（もちろんポートが適切に開放されている必要があります）。 # リモートホスト上の Web サーバー（nginx コンテナ）を起動 $ docker container run --rm -d -p 8000:80 --name web nginx # ローカルホストからアクセス $ curl http://example.com:8000 # リモートホスト上の Web サーバーを停止 $ docker container stop web 上記の例では、あらかじめ docker context use コマンドで使用するコンテキストを切り替えておきましたが、docker コマンド実行時に --context オプションでコンテキスト名を指定することもできます。 次のように実行すれば、各コンテキストで使用する Docker ホストの詳細情報を確認できます。 コンテキストを明示して実行 $ docker --context default info # デフォルトコンテキスト（ローカルホスト）で実行 $ docker --context my-context info # 今回作成したコンテキスト（リモートホスト）で実行 本番環境用のコンテキストは常に選択していると危険なので、--context オプションでのみ使用した方がよいかもしれません。 $ docker --context production compose up -d Docker コンテキストを削除する 必要なくなった Docker コンテキストは、docker context rm コマンドで削除できます。 $ docker context use default # デフォルトコンテキストに戻しておく $ docker context rm my-context # 不要なコンテキストを削除 $ docker context ls # コンテキストの一覧を確認 NAME ...(省略)... default * ...(省略)... バインドマウント時の注意 Docker コンテキストとバインドマウントを組み合わせて使用するときは、マウント時の source パスの指定方法に注意する必要があります。 source パスを下記例の ./meili_data のように相対パスで記述すると、それは docker コマンドを実行する PC 上のカレントパスとして展開されます。 docker-compose.yml（バインドマウント） version: \u0026#34;3.9\u0026#34; services: meilisearch: image: \u0026#34;getmeili/meilisearch:v1.6\u0026#34; container_name: meilisearch ports: - \u0026#34;7700:7700\u0026#34; environment: - MEILI_ENV=production - MEILI_NO_ANALYTICS=true - MEILI_MASTER_KEY volumes: - type: bind source: ./meili_data target: /meili_data bind: create_host_path: true # ./meili_data が存在しなければ作成 例えば、カレントディレクトリが /Users/maku/myproject の状態で docker --context my-context compose up -d と実行すると、my-context コンテキストが指し示すリモートホスト上に /Users/maku/myproject というディレクトリが生成されてしまいます（存在しなければ）。 このパスは、おそらくリモートホスト上では意味を持ちません。 このような振る舞いを防ぐには、source パスを最初から絶対パスで指定する必要があります。 volumes: - type: bind source: /opt/meili_data # ターゲットホスト上の絶対パスを想定して記述 target: /meili_data bind: create_host_path: true あるいは、バインドマウントではなく、ボリュームマウント を使ってしまうのが手っ取り早いです。 ボリュームマウントを使用すると Docker のシステムがデータを一元管理してくれるため、ファイルシステム上のパスに関連する問題が発生しなくなります。 docker-compose.yml（ボリュームマウント） version: \u0026#34;3.9\u0026#34; services: meilisearch: image: \u0026#34;getmeili/meilisearch:v1.6\u0026#34; container_name: meilisearch ports: - \u0026#34;7700:7700\u0026#34; environment: - MEILI_ENV=production - MEILI_NO_ANALYTICS=true - MEILI_MASTER_KEY volumes: - type: volume # ボリュームマウントを使用する source: meili_data # 一番下で定義しているボリュームを指定 target: /meili_data volume: nocopy: true # ボリューム生成時にコンテナから内容をコピーしない # 作成するボリュームの定義 volumes: meili_data: # name: meili_data # プロジェクト名のプレフィックスを付けたくないとき"},{url:"/p/dsctaq7/",title:"Git サブモジュールで別リポジトリの内容を組み込む (git submodule)",date:"2022-11-13T00:00:00Z",body:"Git サブモジュールで別リポジトリの内容を組み込む (git submodule) Git サブモジュールとは Git サブモジュールは、既存の別リポジトリの内容を、サブディレクトリの形で参照できるようにする仕組みです。 例えば、次のようなディレクトリ構成のプロジェクトがあったとします。 my-project/ +-- src/ +-- my-libs/ ★別リポジトリをサブモジュールとして組み込む ここでは、別リポジトリで管理している共有ライブラリを my-libs サブディレクトリの形で参照できるようにしています。 NPM や Maven などのパッケージレジストリから共有ライブラリを取り込む方法もありますが、Git サブモジュールの仕組みを使うと、メインプロジェクトでの開発と共有ライブラリの開発を並行して進められる ようになります。 Git サブモジュールで特徴的なのは、メインプロジェクトからはサブモジュールの内容を コミットハッシュのみで追跡する ということです。 この振る舞いを理解してしまえば、Git サブモジュールを使いこなすのは難しくありません。 サブモジュール側の変更履歴は、あくまでサブモジュール側の Git リポジトリで管理されます。 つまり、サブモジュール側のリポジトリで大量のコミットが行われていたとしても、メインプロジェクト側のリポジトリサイズが増加していくということはありません。 メインプロジェクト側では、どの時点でのスナップショット（のコミットハッシュ）を参照するかを指定するだけです。 サブモジュールとして取り込む Git リポジトリの URL は柔軟に切り替えることができます。 Git サブモジュールの利用例 共有ライブラリ用のリポジトリがあるけれど、NPM や Maven などのパッケージリポジトリにはリリースしていないとき、サブモジュールとして共有ライブラリを取り込む。メインプロジェクト側の開発中に、並行して共有ライブラリのコードを修正したい場合も同様。 頻繁に更新されるファイルがあるけれど、メインプロジェクト側のコミット履歴には残したくないとき、別リポジトリでそのファイルを管理し、サブモジュールとして取り込む。 別リポジトリをサブモジュールとして追加する (git submodule add) 既存の別リポジトリの内容（前述の例では共有ライブラリ）を、カレントプロジェクトにサブモジュールとして組み込みたいときは、git submodule add コマンドを使用します。 $ git submodule add \u0026lt;別リポジトリのURL\u0026gt; [ローカルディレクトリ] 例えば次のように実行すると、 $ git submodule add https://github.com/maku77/my-libs ローカルに my-libs というディレクトリが作成されて、サブモジュールとして参照できるようになります。 別のディレクトリ名で取り込みたい場合は、末尾にディレクトリ名を追加で指定します。 初めてサブモジュールが追加されると、.gitmodules というメタ情報ファイルが作成されます。 ここには、サブモジュールごとのリポジトリ URL とローカルディレクトリのパスが記録されています。 このファイルをコミットすることで、他の開発者がサブモジュールとして管理されているファイルを取得できるようになります。 .gitmodules [submodule \u0026#34;my-libs\u0026#34;] path = my-libs url = https://github.com/maku77/my-libs 最初に説明した通り、サブモジュールの内容はコミットハッシュでのみ追跡されています。 各サブモジュールのディレクトリに、どのコミットハッシュの内容が取得されているかは、git submodule status コマンドで確認することができます。 $ git submodule status ffb0ef23b9cc39d05b860d2379977268b2f44194 my-libs (heads/main) あとは、今回作成された .gitmodules ファイルと my-libs ディレクトリを git commit すれば作業完了です。 ちなみに、サブモジュールとして追加された my-libs ディレクトリは、次のような特殊モード (160000) のファイルとして登録され、コミットハッシュのみが記録されています。 $ git diff --staged my-libs diff --git a/my-libs b/my-libs new file mode 160000 index 0000000..ffb0ef2 --- /dev/null +++ b/my-libs @@ -0,0 +1 @@ +Subproject commit ffb0ef23b9cc39d05b860d2379977268b2f44194 サブモジュールを含むリポジトリをクローンする (git submodule init, git submodule update) サブモジュールを含むリポジトリ（.gitmodules を含むリポジトリ）をクローンした直後は、サブモジュール用のディレクトリは空っぽになっています。 $ git clone https://github.com/maku77/my-project $ cd my-project $ ls my-libs （空っぽ） .gitmodules ファイルの内容に基づいてサブモジュールを利用し始めるには、git submodule init コマンドを実行します。 $ git submodule init Submodule \u0026#39;my-libs\u0026#39; (https://github.com/maku77/my-libs) registered for path \u0026#39;my-libs\u0026#39; これにより、ワーキングディレクトリ内の各サブモジュールディレクトリを、どのリポジトリ URL にマッピングすべきかが .git/config ファイルに保存されます。 この時点では、まだ my-libs ディレクトリは空っぽの状態で、実際にサブモジュールのファイル群を取得するには、git submodule update コマンドを実行する必要があります。 サブモジュールがさらに別のサブモジュールを含んでいる場合は、--recursive オプションを付けるとまとめて取得できます。 基本的には、このオプションは常に付けておけばよいでしょう。 サブモジュールのファイルを取得 $ git submodule update --recursive Cloning into \u0026#39;/Users/maku/y/gitwork/maku77/my-project/my-libs\u0026#39;... Submodule path \u0026#39;my-libs\u0026#39;: checked out \u0026#39;ffb0ef23b9cc39d05b860d2379977268b2f44194\u0026#39; これで、メインプロジェクト (my-project) からサブモジュール (my-libs) のファイルを参照できるようになります。 クローン直後に git submodule init と git submodule update を実行するのは、ほとんど定型作業になっているので、これらをまとめて実行する git submodule update --init コマンドが用意されています。 init と update を一気に実行 $ git submodule update --init --recursive Submodule \u0026#39;my-libs\u0026#39; (https://github.com/maku77/my-libs) registered for path \u0026#39;my-libs\u0026#39; Cloning into \u0026#39;/Users/maku/y/gitwork/maku77/my-project/my-libs\u0026#39;... Submodule path \u0026#39;my-libs\u0026#39;: checked out \u0026#39;ffb0ef23b9cc39d05b860d2379977268b2f44194\u0026#39; さらに、git clone と git submodule init、git submodule update を同時にやってしまう、git clone --recurse-submodules コマンドも用意されています。 サブモジュールを含むリポジトリをクローンする場合は、このコマンドを使えば一撃でクリア です。 クローンしてサブモジュールも取得 $ git clone --recurse-submodules https://github.com/maku77/my-project メインプロジェクト内でサブモジュールのファイルを修正する メインプロジェクトでの作業中に、サブモジュールのファイルを修正したくなった場合は、サブモジュールのディレクトリに移動して、サブモジュール側の Git リポジトリの修正作業を行います。 メインプロジェクト側ではサブモジュールの修正内容は管理しない（コミットハッシュだけ記録している）ので、サブモジュール側の修正は、サブモジュール側のリポジトリにコミット＆プッシュする必要があります。 典型的な作業順序は次のようになります。 サブモジュールのディレクトリに移動する サブモジュール内でブランチを切り替える サブモジュール内のファイルを修正＆コミット＆プッシュ メインプロジェクトに戻り、サブモジュールディレクトリをコミット（コミットハッシュの更新） あくまで 2 つのリポジトリで別々に修正作業を行う感じですね。 初期状態では、サブモジュール側のチェックアウト状態は detached HEAD（どのブランチも選択しておらず、特定のコミットハッシュを選択している状態）になっているので、作業対象となるブランチに切り替えてから修正作業を行います。 サブモジュール側のファイルを更新 $ cd my-libs $ git branch * (HEAD detached at bb1319a) main $ git switch main $ （何らかのファイル修正） $ git add . $ git commit $ git push ここでサブモジュール側の更新を（GitHub などへ）プッシュしておかないと、他の開発者がメインプロジェクト側で git submodule update しようとしたときに、対象のコミットハッシュが見つからない、といったことになるので注意してください。 サブモジュール側の修正が完了したら、メインプロジェクト側に戻り、参照するサブモジュールのコミットハッシュを最新のものに更新します。 $ cd .. # メインプロジェクトのルートへ戻る $ git add my-libs # サブモジュールの最新のコミットハッシュをステージング $ git commit $ git push メインプロジェクトの更新内容を確認してみると、コミットハッシュの更新のみになっていることが分かります。 $ git show ... -Subproject commit 540bb2831ae6478bf43ce6f8ab7aff09e23946b7 +Subproject commit fd80dfabbc154de89f12a9c617f0d76efbdb00eb git show コマンドや git log -p コマンドは、サブモジュール側の変更内容 (diff) として、上記のようなコミットハッシュしか表示してくれませんが、--submodule オプションを付けて実行すると、コミットハッシュの代わりにサブモジュールのコミットログを確認できます。 $ git show --submodule ... Submodule common 540bb28..fd80dfa: \u0026gt; Add sidebar component ☝️ プッシュしていないコミットハッシュを参照してしまうのを防ぐ サブモジュール側の変更をプッシュする前に、メインプロジェクト側でそのコミットを参照する変更をプッシュしてしまうと、最新コードがビルドできない状態になってしまいます（サブモジュールを git submodule update で取得できない）。 このような事態を防ぐために、git push コマンドには、--recurse-submodules というオプションが用意されています。 このオプションで check や on-demand といった値を指定すると、次のように振る舞いが変化します。 git push --recurse-submodules=check \u0026hellip; プッシュされていないサブモジュールのコミットを参照していたら、実行を中止する git push --recurse-submodules=on-demand \u0026hellip; プッシュされていないサブモジュールのコミットを参照していたら、サブモジュール側を先にプッシュする サブモジュール側のリポジトリの更新内容を取り込む (git submodule update \u0026ndash;remote) サブモジュールとして参照しているリポジトリに更新があった場合、その内容を取得するには、git submodule update --remote コマンドを使用します。 サブモジュールの内容を更新 $ git submodule update --remote --recursive --remote オプションを付けずに実行した場合は、カレントプロジェクトで記録されているコミットハッシュ値でファイルを取得するという意味になります。 なので、参照している共有ライブラリ側で独立して更新された内容を取り込むには、--remote オプションが必要です。 デフォルトではすべてのサブモジュールを更新しようとしますが、特定のサブモジュールだけ更新することもできます。 指定したサブモジュールのみ更新 $ git submodule update --remote --recursive lib1 lib2 lib3 上記のように git submodule update --remote を実行すると、サブモジュール側のチェックアウト状態は、ふたたび detached HEAD になります。 つまり、完全にリモートリポジトリ側 (GitHub) の最新のコミットを参照する状態に置き換えられます。 サブモジュール側に、まだプッシュされていないローカルコミットがあり、その内容とマージしたいときは、--merge オプションを付けて次のように実行します。 サブモジュールのローカルコミットにリモートコミットをマージ $ git submodule update --remote --recursive --merge --merge オプションを付けずに実行して、サブモジュールにローカルコミットした内容が見えなくなってしまっても慌てる必要はありません。 いかなる場合でもコミットログは残っている（git log --all ですべて確認できる）ので、適切なブランチに適切なコミットをマージするだけです。 $ cd my-libs # サブモジュールへ移動 $ git switch main # マージ先のブランチに切り替え $ git merge fd5ccb6 # リモート側の最新 (detached HEAD) をマージ $ git add . $ git commit $ git push とはいえ、git submodule update --remote を実行する前に、サブモジュール内で行った修正はコミット＆プッシュまで済ませておく、という手順にした方が混乱せずに済むでしょう。 他の開発者が行ったサブモジュールのコミットハッシュ更新を反映する (git pull \u0026ndash;recurse-submodules) メインプロジェクト内のサブモジュールを更新した場合（コミットハッシュ値を更新した場合）、他の開発者もそのコミットハッシュに対応するサブモジュールのコードを取得する必要があります。 そのためには、git pull でメインプロジェクトの更新内容を取り込んだ後に、git submodule update を実行します。 $ git pull $ git submodule update --recursive この作業も定型の操作になるので、まとめて実行する git pull --recurse-submodules というコマンドが用意されています。 $ git pull --recurse-submodules サブモジュールを削除する (git submodule deinit) サブモジュールが必要なくなったら、次のように登録情報やローカルに残ったファイルを削除できます。 # .git/config からエントリを削除（git submodule init で追加されたもの） $ git submodule deinit \u0026lt;ディレクトリ名\u0026gt; # .gitmodules ファイル内のセクションを削除（git submodule add で追加されたもの） $ git config -f .gitmodules --remove-section submodule.\u0026lt;ディレクトリ名\u0026gt; # ローカルに残ったディレクトリを削除 $ rm -rf \u0026lt;ディレクトリ名\u0026gt; $ rm -rf .git/modules/\u0026lt;ディレクトリ名\u0026gt; # 変更をコミット＆プッシュ $ git add . $ git commit $ git push 複数のサブモジュールをまとめて操作する (git submodule foreach) これまでに述べてきたように、Git サブモジュールはあくまで別リポジトリのリファレンスとして動作するため、メインプロジェクト上で git コマンドを実行しても、コミットハッシュくらいしか参照できません。 git submodule foreach COMMAND コマンドを使うと、各サブモジュール内で任意のコマンド (COMMAND) を実行したかのように振る舞わせることができます。 git submodule foreach の使用例 # すべてのサブモジュール内で git diff を実行 $ git submodule foreach \u0026#34;git diff\u0026#34; # すべてのサブモジュール内で git branch を実行 $ git submodule foreach \u0026#34;git branch\u0026#34; Git サブモジュール用の便利なエイリアス Git サブモジュールをうまく扱うには、Git コマンドに様々なオプションを付けて操作する必要があります。 次のように、よく使いそうなコマンドをエイリアスとして登録しておくと便利です。 $ git config --global alias.sclone \u0026#39;clone --recurse-submodules\u0026#39; $ git config --global alias.supdate \u0026#39;submodule update --remote --recursive --merge\u0026#39; $ git config --global alias.sdiff \u0026#39;!\u0026#39;\u0026#34;git diff \u0026amp;\u0026amp; git submodule foreach \u0026#39;git diff\u0026#39;\u0026#34; $ git config --global alias.spush \u0026#39;push --recurse-submodules=on-demand\u0026#39; git sclone \u0026hellip; git clone すると同時にサブモジュールの内容も取得する git supdate \u0026hellip; 全サブモジュールの最新バージョンのファイルを取得する（ローカルコミットがあればマージ） git sdiff \u0026hellip; 全サブモジュールの変更内容を含んだ diff を表示する git spush \u0026hellip; プッシュ時にサブモジュール側のコミットを先にプッシュする Git サブモジュール関連のコマンドのまとめ コマンド 説明 git clone --recurse-submodules \u0026lt;URL\u0026gt; git clone すると同時にサブモジュールも取得する git submodule add \u0026lt;URL\u0026gt; サブモジュールを追加する git submodule status サブモジュールのコミットハッシュを表示する git submodule init ローカルのインデックスでサブモジュールを管理し始める git submodule update --recursive コミットハッシュに従ってサブモジュールを取得する git submodule update --init --recursive init と update を同時に実行する git submodule update --remote --recursive サブモジュールの最新バージョンを取得する git pull --recurse-submodules git pull と同時に update を実行する git push --recurse-submodules=on-demand プッシュ時にサブモジュール側のコミットを先にプッシュする"},{url:"/windows/",title:"Windows",date:"2022-11-09T00:00:00Z",body:"Windows Windows バッチファイル 環境 Windows で Ruby や Python のスクリプトを組み込みコマンドのように使用する 環境変数が設定されているかどうか調べる (if defined) バッチファイルが管理者として実行されているか調べる 構文 バッチファイルの FOR ループ (1) 数値、ファイル集合、ディレクトリ集合のループ処理 バッチファイルの FOR ループ (2) テキストファイル、コマンド出力を 1 行ずつループ処理 バッチファイルを途中で終了する (exit /b) バッチファイルでサブルーチンを定義する、別のバッチファイルを呼び出す (call, setlocal) 長いコマンドを複数行に分けて記述する 入出力 (I/O) バッチファイルでコマンドライン引数を扱う バッチファイルでプロンプトを表示してユーザー入力を促す (set /p) 標準出力 (stdout) と標準エラー (stderr) への出力をファイルに保存する echo で改行だけ出力する／改行しないで出力する 複数のコマンドの出力をまとめてリダイレクトする バッチファイルでコマンドの実行結果を変数に格納する ファイル／ディレクトリ／パス バッチファイルのファイル名やディレクトリ名を取得する DIR コマンドでファイルやディレクトリを再帰的に検索する DIR コマンドでファイルやディレクトリを OR 検索する カレントディレクトリ以下のファイルやディレクトリを順に処理する findstr でファイル内の文字列を検索する 既にディレクトリが存在している場合の mkdir のエラーを抑制する 複数のファイルを連結する 日時 バッチファイル内で日時を出力する (%DATE%, %TIME%) バッチファイル内で日時を元にファイル名を作成する バッチファイル内で1日後の日時を取得する（時刻の演算） コマンドプロンプト コマンドプロンプトを管理者権限 (Administorator) で起動する コマンドプロンプトの文字色と背景色を変更する コマンドプロンプトのプロンプト表示を変更する コマンドプロンプトからウィンドウサイズを変更する doskey を使ってコマンドプロンプト用のマクロを登録する コマンドプロンプトから複数のコマンドを並列実行する (start) ファイル／ディレクトリ／パス カレントディレクトリのパスを取得する コマンドプロンプトでディレクトリ内のファイルをすべて削除する (del, rmdir) コマンドプロンプトからインターネット上のファイルをダウンロードする (bitsadmin) Windows の便利操作／ショートカット Windows でキーボード操作だけで様々なフォルダを素早く開く Windows の設定／管理／セキュリティ タスク管理 Windows で実行中のプロセス（タスク）の一覧を表示する (tasklist) Windows で実行中のプロセス（タスク）を終了 (kill) する (taskkill) Windows で任意のコマンド（タスク）を自動実行する (schtasks) Windows OS のバージョン情報をコマンドラインから調べる NIC に割り当てられた MAC アドレスを調べる (getmac) コマンドラインから Windows サービスを管理する Administrator で Windows にログオンできるようにする Windows のアカウント名を変更する ドメインユーザーにローカル PC の Administrator 権限を与える 日本語キーボードのノート PC で英字配列の USB キーボードを使用する Windows のユーザのパスワードの有効期限を無期限に設定する xcopy でディレクトリ内のファイルをバックアップする NTP による時刻同期情報を取得する (w32tm) ネットワーク Windows ファイアウォールで特定のポートを開放する ネットワーク切り替え時に PC 名ですぐに検索できるようにする（NetBios 名の再登録） Windows のログオフ時にネットワーク接続を維持する Windows の DNS キャッシュをクリアする MS Office Excel Excel のブック、ワークシート、セルの関係を理解する Excel の行・列の表示／非表示をショートカットキーで素早く切り替える Excel で点数などから順位を求める（RANK.EQ関数） Excel で順位セルの値通りに並び替えて表示する VBA マクロに関してはこちらを参照 PowerPoint PowerPoint で使いこなすとかっこいいショートカット SVG ファイルを EMF ファイルに変換して PowerPoint に貼り付ける PowerPoint プレゼン資料でおすすめのフォント設定 Word Word で章・節・項の見出しを作成する Word で章・節・項の「見出しマップ」を表示する Word で章・節・項の見出しの表示スタイルを変更する Word で章・節・項の見出しに連番（段落番号）を自動で振る Word で章・節・項の見出しから目次を作成する Outlook Outlook で返信メールのメッセージの行頭に引用記号 (\u0026gt;) を付ける Outlook の予定表を他のユーザから見えるようにする Windows API Legacy API プロセス・ハンドルについて Windows の静的ライブラリと動的ライブラリ 指定したウィンドウ (HWND) を確実にアクティブにする 現在使用中の Windows OS のバージョンを調べる Windows API ですべてのウィンドウを列挙し、特定の条件にマッチするウィンドウを取得する Windows API でスクリーンセーバーの起動時間を取得／設定する .NET 日付／時刻 .NET - 時刻部分をすべて 0 にした DateTime インスタンスを作成する .NET - DateTime インスタンスと文字列を相互に変換する .NET - 現地時刻（ローカルタイム）と世界協定時刻 (UTC) の扱いを理解する その他 .NET - System.Data.SQLite で SQLite データベースを使用する .NET - XML 形式の設定ファイルを XPath で操作するサンプル .NET - ツリーノードのドラッグ＆ドロップの流れ .NET - ツリーノードを右クリックしたときにそのノードを選択状態にする"},{url:"/p/2dn6njw/",title:"Windows のバッチファイルでプロンプトを表示してユーザー入力を促す (set /p)",date:"2022-11-09T00:00:00Z",body:"Windows のバッチファイルでプロンプトを表示してユーザー入力を促す (set /p) set /p コマンドの使い方 Windows のコマンドプロンプトで SET /P コマンドを実行すると、任意のプロンプトを表示して、ユーザーにキーボード入力を促すことができます。 SET /P 変数=[プロンプト文字列] ユーザーが入力したテキストは、指定した変数に格納されるので、後から %変数名% という形で参照することができます。 次の例では、ユーザーにプロジェクト名の入力を促し、入力結果を PjName という変数に格納しています。 sample.cmd @echo off setlocal set /p PjName=\u0026#34;Project name? \u0026#34; echo 入力したプロジェクト名は %PjName% です 実行例 Project name? HelloWorld 入力したプロジェクト名は HelloWorld です 具体的な使用例 set /p コマンドを実行する前に、入力候補を表示するという利用方法も考えられます。 次のサンプルバッチファイルは、Android のエミュレーター (AVD) を起動するためのものですが、起動可能なデバイス (AVD) の候補を表示して、ユーザーにどのデバイスを起動するかを選択させています。 emu.cmd @echo off setlocal echo Available AVDs: emulator -list-avds set /p AvdName=\u0026#34;Which AVD do you want to start? \u0026#34; if \u0026#34;%AvdName%\u0026#34;==\u0026#34;\u0026#34; ( echo ERROR: No AVD specified. exit /b ) emulator @%AvdName% 実行例 Available AVDs: phone-s phone-t tv-s tv-t Which AVD do you want to start? phone-t 参考: Windows のバッチファイルの実行を途中で終了する (exit /b)"},{url:"/android/",title:"Android",date:"2022-11-08T00:00:00Z",body:"Android Android アプリや Android デバイスの開発に役立つかもしれないノートです。 Tools protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions) パーミッショングループの一覧を表示する (pm list permission-groups) ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk) ADB から Backup Manager を走らせる (bmgr backup, bmgr restore) Activity の情報を表示する (dumpsys activity) メモリの使用状況を確認する (dumpsys meminfo) APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages) APK ファイルに署名する (keytool, jarsigner) APK ファイルの署名を確認する (jarsigner, openssl) Dex 形式の Shared library (JAR) を作成する (dx) パフォーマンス Android アプリのパフォーマンス改善のためのチェックリスト dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認） Choreographer で FPS を計測する（Fps クラスの実装） Android アプリのパフォーマンス改善に使用できるツール ADB で描画パフォーマンス計測のデバッグ機能を有効にする Perfetto でシステム全体のパフォーマンスを計測する Traceview でプロファイル情報を表示する 旧）Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd) 旧）Systrace の画面が真っ白になるときの対応方法 エミュレーター Android エミュレーター内のサーバーに外部からアクセスする (adb forward) Android エミュレーターをコマンドラインから操作する (emulator, adb emu) 外部ツールとの連携 Golang で Android 上で動く CLI コマンドを作成する (go build) Ruby で adb コマンドの出力結果を処理する 解析／デバッグ／ADB コマンド APK のパッケージ依存関係やクラス依存関係を調べる (jdeps, dex2jar) APK ファイルを逆コンパイルする (apktool) APK ファイルの情報を表示する (aapt) ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast) ADB で指定したアプリを強制終了する (am force-stop) ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts) ADB でディレクトリ内のファイルをすべて取得する (adb pull) ADB でスリープ状態に入る／スリープから抜ける ADB で WakeLock を強制的に外す ADB からキー入力やテキスト入力を行う (input text, input keyevent) ADB で Android 端末のバージョンや API レベルを調べる (getprop) ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages) TCP/IP で adb 接続する Android Studio で静的解析プラグインを使用する ANR の原因を突き止める ADB 経由でスクリーンキャプチャを取得する StrictMode を有効にして望ましくない実装を検出する StrictMode の違反メッセージを Toast で表示する (StrictModeToaster) 旧）各種デバイスの ADB 接続 Nexus7 (2013) に adb 接続する Xperia Tablet Z に adb 接続する Sony Tablet S に adb 接続する SHARP IS03 に adb 接続する Eclipse から Android SDK を使えるようにする (ADK) Logcat Logcat のログ出力をフィルタする ビルド関連 Gradle Android アプリ用の Gradle スクリプトの基本 リソース名に正しくプレフィックスが付いているか確認する Android Studio を使っているときの Gradle 関連ファイル BuildConfig クラスでアプリの動作を切り替える サブモジュールで使用する SDK バージョンを統一する 外部から提供された AAR ファイルを利用する APK ファイル名のサフィックスにバージョンを追加する Lint エラーが発生した場合もビルドを継続する Android アプリが使用している依存ライブラリをツリー構造で表示する（dependencies/androidDependencies タスク） Gradle 全般の説明は こちらを参照 Android Studio AAR 形式のファイルを作成する/使用する Android Studio に割り当てるメモリを増やす Android Studio で新規ファイル作成時に Copyright を自動挿入する Android Studio の便利なショートカット (1) コードの調査／メソッド間のジャンプ Android Studio の便利なショートカット (2) ブックマーク Android デバイス開発者向け（ベンダ向け情報） root ユーザで adb 接続する Sleep モードに遷移する 現在の Configuration を変更する LowMemoryKiller によるプロセス kill の優先順位の仕組み LowMemoryKiller の too many background によるプロセス kill の仕組み Android デバイスのパーティション構成概要 make 後の生成イメージが格納されるディレクトリを調べる インストールされた各 APK パッケージに割り当てられたユーザー ID を調べる android/build/core 以下の *.mk ファイルで定義されている関数 (define) のリスト ART/Dalvik VM のバージョンを調べる Locale を切り替える サポートされている Locale の一覧 (Android 4.0) 製品にパッケージングする APK を指定する Make 変数でビルド範囲を制御する システムプロパティのあれこれ findmakefile で Android.mkのあるディレクトリを調べる getevent/sendevent で入力デバイスへの入力情報を取得する／入力を行う libhardware.so が hardware サポートライブラリをロードする仕組み Android Framework/SDK Jetpack Compose の宣言型 (declarative) の UI 定義とは？ Activity の起動モードと起動フラグ（タスクとアフィニティ） SpeechRecognizer で音声入力を実現する リソース ID を示す変数やパラメータにアノテーションを付ける 設定 (SharedPreferences) SharedPreferences でアプリの設定値を保存する Preference フレームワークを使って設定画面を簡単に作成する Java レイヤ 特殊ディレクトリの情報を取得する AsyncTask による非同期処理と UI 更新処理 I/O（入出力） キーイベント (KeyEvent) を見やすく出力する タッチイベントをハンドルする Emulator での開発時にキーボードによるキー入力が長押しかどうかを判別する UI（描画） 常に画面の最前面に表示されたままになる View を作る (TYPE_APPLICATION_OVERLAY) Kotlin で OpenGL ES を使って 3D 表示するアプリを作る RecyclerView の基本 任意の View をフォーカスする ソフトウェアキーボードを常に表示する カスタムビューを作成する カスタムビューの子ビューがフォーカスを得たことを検出する カスタムビューでソフトウェア D-Pad を表示する ValueAnimator でアニメーションに使用する値を計算する ScrollView を一番下までスクロールさせる Canvas に複数行のテキストを描画する Canvas への描画時にアンチエイリアスを有効にする 数値／文字列 数値をある範囲内［min, max］に丸める (MathUtils.clamp) Service（サービス） 同じプロセス内のサービスへバインドする (Local Bind) 別プロセスのサービスへバインドする (Remote Bind) サービスからコールバックできるようにする 設定 (Settings) 画面消灯 (SCREEN OFF) までの時間を取得・設定する Native レイヤ RefBase によるスマートポインタ ネイティブサービスの実装 (1) Binder 関連のクラス ネイティブサービスの実装 (2) サービスの実装から利用まで ネイティブサービスの実装 (3) サービスのインタフェースを定義する ServiceManager 関連 ServiceManager に登録されたサービスを列挙する トラブルシューティング repo init でエラーが出る場合 その他 ネイティブライブラリの展開先 現在のスクリーンレイアウトサイズを取得する ネットワーク関連の情報を取得する"},{url:"/p/zgyhygw/",title:"Android エミュレーターをコマンドラインから操作する (emulator, adb emu)",date:"2022-11-08T00:00:00Z",body:"Android エミュレーターをコマンドラインから操作する (emulator, adb emu) emulator コマンドと adb コマンド Android SDK に付属している emulator コマンドや adb コマンドを使うことで、Android のエミュレーターを操作することができます。 emulator コマンド エミュレーター端末 (= AVD: Android Virtual Device) の一覧を表示したり、エミュレーター端末を起動したりするのに使うコマンドです。 adb コマンド エミュレーター端末が起動した後に、コマンドを送り込んで各種操作を行います。adb はエミュレーター専用のコマンドではありませんが、adb emu のようなエミュレーターに特化したサブコマンドがあります。 emulator コマンドは、Android SDK をインストールしたディレクトリの emulator ディレクトリに格納されています。 例えば次のようなパスにあります（ユーザー名が maku の場合）。 Windows の場合: C:\\Users\\maku\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe macOS の場合: /Users/maku/Library/Android/sdk/emulator/emulator 次のような感じで OS のパスを通しておくと、どこからでもコマンドを実行できるようになります。 ~/.zlogin（macOS で zsh の場合） export ANDROID_HOME=~/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin export PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/tools ☝️ emulator/emulator と tools/emulator tools ディレクトリにも同名の emulator コマンドがあったりしますが、こちらではなく、emuator ディレクトリの方にあるコマンドを使うのが正解のようです。 なので、パスを通すときは、emulator ディレクトリが先に来るように指定しておく必要があります。 emulator コマンドの使用例 AVD（エミュレーター端末）のリストを表示する (emulator -list-avds) $ emulator -list-avds phone-s phone-t tv-s tv-t AVD 名には、上記のようなシンプルな名前を付けておくのがおすすめです。 エミュレーターを起動するときに AVD を指定するのが楽になります。 エミュレーターを起動する (emulator) $ emulator @AVD_NAME $ emulator -avd AVD_NAME ここで指定する AVD 名は、前述の emulator -list-avds コマンドで表示されたものの中から選択します。 AVD 名の一覧を表示して、ユーザーに起動する AVD を選択させるバッチファイルなどを作っておくと便利です。 emu.cmd（AVD を選択して起動するバッチファイル） @echo off setlocal echo Available AVDs: emulator -list-avds set /p AvdName=\u0026#34;Which AVD do you want to start? \u0026#34; if \u0026#34;%AvdName%\u0026#34;==\u0026#34;\u0026#34; ( echo ERROR: No AVD specified. exit /b ) emulator @%AvdName% adb コマンドの使用例 稼働中のエミュレーターの一覧を表示する (adb devices) $ adb devices List of devices attached emulator-5554	device emulator-5556	device 上記の例では、2 つのエミュレーターが起動しており、それぞれのシリアル（識別子のようなもの）は emulator-5554 と emulator-5556 であることがわかります。 複数のエミュレーターが起動している場合、ほとんどのケースでは adb コマンド実行時に操作対処とするエミュレーターを -s オプションで指定する必要があります。 シリアルを指定して adb コマンド実行 $ adb -s emulator-5554 logcat adb devices コマンドで -l オプションを指定すると、さらに詳細な情報を表示できます。 $ adb devices -l List of devices attached emulator-5554 device product:sdk_gphone64_arm64 model:sdk_gphone64_arm64 device:emulator64_arm64 transport_id:1 emulator-5556 device product:sdk_google_atv64_amati_arm64 model:sdk_google_atv64_amati_arm64 device:emu64a transport_id:2 この出力の末尾には、各エミュレーター端末のトランスポート ID が表示されており、これをシリアルの代わりに使うことができます。 $ adb -t 1 logcat エミュレーターを停止する (adb emu kill) $ adb emu kill $ adb -s emulator-5554 emu kill # 複数のエミュレーターを起動している場合 画面上からエミュレーターが消えているのに、なぜかエミュレーターが起動し続けている（adb devices のリストから消えない）という状態になってしまった場合は、このコマンドを実行すれば確実に終了できます。 Android OS を再起動する / AVD を再起動する Android の再起動 $ adb reboot エミュレーター内で動作している Android を再起動します。 BOOT_COMPLETED インテントまわりのテストをするときに必要になったりします。 エミュレーター (AVD) 自体を再起動したいときは次のように実行します。 AVD (Emulator) の再起動 $ adb emu restart その他の adb emu サブコマンド $ adb emu rotate # 画面を回転 $ adb emu avd name # AVD 名を表示 $ adb emu avd status # AVD の状態を表示 $ adb emu avd bugreport # バグレポートを生成 adb emu コマンドにはあまりドキュメントがなかったりしますが、adb emu help-verbose で簡単なコマンド一覧を表示できます。 もしかすると便利なコマンドが見つかるかもしれません。"},{url:"/p/kziyhzg/",title:"fmt.Println による構造体の出力をカスタマイズする (Stringer)",date:"2022-11-05T00:00:00Z",body:`fmt.Println による構造体の出力をカスタマイズする (Stringer) Golang での構造体の出力 Golang の構造体の内容は、fmt パッケージの各種関数で出力できるようになっています。 次のコードでは、Game 構造体の内容をいくつかの方法で出力しています。 package main import \u0026#34;fmt\u0026#34; type Game struct { Title string Price int } func main() { g := \u0026amp;Game{Title: \u0026#34;ドンキーコング\u0026#34;, Price: 4500} fmt.Println(g) // \u0026amp;{ドンキーコング 4500} fmt.Printf(\u0026#34;%v\\n\u0026#34;, g) // \u0026amp;{ドンキーコング 4500} fmt.Printf(\u0026#34;%+v\\n\u0026#34;, g) // \u0026amp;{Title:ドンキーコング Price:4500} fmt.Printf(\u0026#34;%#v\\n\u0026#34;, g) // \u0026amp;main.Game{Title:\u0026#34;ドンキーコング\u0026#34;, Price:4500} } こういった出力で十分であればよいのですが、異なる出力が欲しいときは、次に説明する Stringer インタフェースを実装することで対応できます。 String 関数による出力のカスタマイズ fmt パッケージで構造体を文字列表現に変換するとき、内部で String 関数が呼び出されます。 String 関数は、fmt パッケージの Stringer インタフェースとして定義されています。 type Stringer interface { String() string } 例えば、Game 構造体の出力をカスタマイズしたいときは、次のように String() 関数を実装します。 type Game struct { Title string Price int } // Game 構造体の文字列表現 func (g Game) String() string { return fmt.Sprintf(\u0026#34;「%s」 %d円\u0026#34;, g.Title, g.Price) } すると、fmt パッケージの各種関数による出力は次のように変化します。 func main() { g := \u0026amp;Game{Title: \u0026#34;ドンキーコング\u0026#34;, Price: 4500} fmt.Println(g) // 「ドンキーコング」 4500円 fmt.Printf(\u0026#34;%v\\n\u0026#34;, g) // 「ドンキーコング」 4500円 fmt.Printf(\u0026#34;%+v\\n\u0026#34;, g) // 「ドンキーコング」 4500円 fmt.Printf(\u0026#34;%#v\\n\u0026#34;, g) // \u0026amp;main.Game{Title:\u0026#34;ドンキーコング\u0026#34;, Price:4500} } Golang のソースコード表現を表す %#v の出力だけは変化しないようです。 構造体の内容をきれいな JSON 形式で出力したければ、json パッケージを使って次のように実装できます（参考: Golang で JSON を扱う）。 func (g Game) String() string { bytes, err := json.MarshalIndent(g, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) if err != nil { // Cyclic data structures が見つかった時の対策 return g.Title } return string(bytes) } 出力例 { \u0026#34;Title\u0026#34;: \u0026#34;ドンキーコング\u0026#34;, \u0026#34;Price\u0026#34;: 4500 } ただ、デバッグ用途の出力であれば、素直に出力専用の関数を定義した方がよさそうです。 func PrintGame(g *Game) { bytes, _ := json.MarshalIndent(g, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) fmt.Println(string(bytes)) }`},{url:"/go/",title:"Golang",date:"2022-11-05T00:00:00Z",body:"Golang はじめに／実行環境 はじめに Go 言語とは？／Go をインストールする Go 言語で Hello World をコンパイル、実行する Go 言語のコーディングスタイル（コーディング規約） Go ツアーを起動して Go 言語の基本を勉強する go install のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin) （旧）GOPATH によるコードの一元管理 パッケージとモジュール パッケージの作成とインポート (import) Go でコマンドラインツールを作って GitHub で公開する （旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する Go の文法 型 Go 言語の組込み型一覧 変数を定義する (var)／ゼロ値について 配列とスライスを扱う マップを扱う (map) ポインタを扱う (＊) 定数を定義する (const) 組込み型に独自の型名を付ける (type) 型キャストと型アサーションによる型変換 制御構文 if による条件分岐 switch による条件分岐 for によるループ処理 関数を定義する (func) パニックによるエラー処理 (panic, recover) 構造体（クラス） 構造体を定義する (struct) 構造体のコンストラクタ（ファクトリ関数）を定義する メソッドを定義する（レシーバ付き関数） Go 言語のインタフェースの扱いを理解する (interface) インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding) 構造体にタグ情報を追加する (struct tags) fmt.Println による構造体の出力をカスタマイズする (Stringer) その他 ジェネリクスで複数の型を扱える関数を定義する (Generics) 標準パッケージ／外部パッケージの利用 文字列／数値 文字列の処理いろいろ 空文字列のチェック / 文字列の連結 / 文字列の分割 ファイル／ディレクトリ ファイルを読み書きする (os, io) JSON 形式の文字列やファイルを扱う (encoding/json) CSV 形式の文字列やファイルを扱う (encoding/csv) テンプレート機能を使用する (text/template, html/template) カレントディレクトリのパスを取得する (os.Getwd) サーバー HTTP サーバーを作成する (net/http) GraphQL サーバーを作成する (gqlgen) gqlgen で子フィールドの情報を返すリゾルバーを実装する データベース (DB) RDB（リレーショナルデーターベース）を扱う (database/sql) MongoDB を扱う (go.mongodb.org/mongo-driver) その他 コマンドライン引数を扱う (os.Args, flags) 時刻データを扱う (time) ベンチマークを行う (testing.B) 環境変数を扱う (os.Getenv, os.LookupEnv) ランダム値（乱数）を扱う (math/rand, crypto/rand)"},{url:"/p/xssnvmh/",title:"Golang の文字列操作いろいろ",date:"2022-11-04T00:00:00Z",body:"Golang の文字列操作いろいろ Go 言語の文字列操作に関するメモです。 空文字列と nil のチェック 文字列が空かどうか調べる var s string // s := \u0026#34;\u0026#34; と同じ（string のゼロ値は空文字列） fmt.Println(s == \u0026#34;\u0026#34;) //=\u0026gt; true fmt.Println(len(s) == 0) //=\u0026gt; true string 変数の内容が空文字列かどうかの確認は、s == \u0026quot;\u0026quot; と len(s) == 0 のどちらでも OK です。 文字列ポインタが nil あるいは空文字を指しているかを調べる golibs/strutil/strutil.go package strutil func NilOrEmpty(s *string) bool { return s == nil || *s == \u0026#34;\u0026#34; } 文字列を連結する 文字列同士の連結（\u0026#43; 演算子） s1 := \u0026#34;AAA\u0026#34; s2 := s1 + \u0026#34;BBB\u0026#34; //=\u0026gt; \u0026#34;AAABBB\u0026#34; 文字列同士の連結（\u0026#43;= 演算子） s := \u0026#34;AAA\u0026#34; s += \u0026#34;BBB\u0026#34; //=\u0026gt; \u0026#34;AAABBB\u0026#34; 文字列スライスの連結 (strings.Join) // import \u0026#34;strings\u0026#34; ss := []string{\u0026#34;AA\u0026#34;, \u0026#34;BB\u0026#34;, \u0026#34;CC\u0026#34;} result := strings.Join(ss, \u0026#34;-\u0026#34;) //=\u0026gt; \u0026#34;AA-BB-CC\u0026#34; 書式文字列で連結 (strings.Join) str := \u0026#34;ABC\u0026#34; num := 100 result := fmt.Sprintf(\u0026#34;%s%d\u0026#34;, str, num) //=\u0026gt; \u0026#34;ABC100\u0026#34; 効率のよい連続連結 (strings.Builder) // import \u0026#34;strings\u0026#34; var buf strings.Builder // bytes.Buffer buf.WriteString(\u0026#34;AAA\u0026#34;) buf.WriteString(\u0026#34;BBB\u0026#34;) buf.WriteRune(\u0026#39;X\u0026#39;) buf.WriteRune(\u0026#39;Y\u0026#39;) buf.WriteByte(90) // \u0026#39;Z\u0026#39; result := buf.String() //=\u0026gt; \u0026#34;AAABBBXYZ 繰り返し文字列 (string.Repeat) // import \u0026#34;strings\u0026#34; s := strings.Repeat(\u0026#34;X\u0026#34;, 4) //=\u0026gt; \u0026#34;XXXX\u0026#34; 文字列を分割する (strings.Split) 区切り文字列（セパレーター）で分割する (strings.Split) s := \u0026#34;AA, BB, CC\u0026#34; // 単純な分割 ss1 := strings.Split(s, \u0026#34;,\u0026#34;)) //=\u0026gt; [\u0026#34;AA\u0026#34;, \u0026#34; BB\u0026#34;, \u0026#34; CC\u0026#34;] // 単純な分割（最大分割数 N 個） ss2 := strings.SplitN(s, \u0026#34;,\u0026#34;, 2)) //=\u0026gt; [\u0026#34;AA\u0026#34;, \u0026#34; BB, CC\u0026#34;] // 区切り文字列を残す ss3 := strings.SplitAfter(s, \u0026#34;,\u0026#34;)) //=\u0026gt; [\u0026#34;AA,\u0026#34;, \u0026#34; BB,\u0026#34;, \u0026#34; CC\u0026#34;] // 区切り文字列を残す（最大分割数 N 個） ss4 := strings.SplitAfterN(s, \u0026#34;,\u0026#34;, 2) //=\u0026gt; [\u0026#34;AA,\u0026#34;, \u0026#34; BB, CC\u0026#34;] strings.SplitN の最大分割数 n に 0 を指定すると戻り値は nil になります。 n に負の値（-1 など）を指定すると、分割数を制限しません（strings.Split と同じ動作になります）。 分割後に区切り文字列（セパレーター）の前後のスペースを削除するには strings.TrimSpace 関数を使用します。 ss := strings.Split(\u0026#34;AA, BB, CC\u0026#34;, \u0026#34;,\u0026#34;) for i := range ss { ss[i] = strings.TrimSpace(ss[i]) } 区切り文字列として正規表現を使う (regexp.Regexp) 文字列をカンマで分割（カンマの後ろのスペースを削除） re := regexp.MustCompile(`,\\s*`) ss := re.Split(\u0026#34;AA, BB, CC\u0026#34;, -1) //=\u0026gt; [\u0026#34;AA\u0026#34;, \u0026#34;BB\u0026#34;, \u0026#34;CC\u0026#34;] (*Regexp) Split メソッドの第 2 引数には、strings.SplitN と同様に最大分割数を指定します。 最大分割数を制限しないのであれば、-1 を指定しておけば大丈夫です。 2 つに分割する (strings.Cut) 文字列を区切り文字（セパレーター）で高々 2 つに分割する場合は、strings.Split よりも strings.Cut の方が便利かもしれません。 strings.Cut を使うと、分割された 2 つの文字列と、セパレーターが見つかったかどうかを別々の変数で取得できます。 before, after, found := strings.Cut(\u0026#34;AAA, BBB\u0026#34;, \u0026#34;,\u0026#34;) fmt.Println(before) //=\u0026gt; \u0026#34;AAA\u0026#34; fmt.Println(after) //=\u0026gt; \u0026#34; BBB\u0026#34; fmt.Println(found) //=\u0026gt; true スペースや改行で分割する (strings.Fields) ss := strings.Fields(\u0026#34; AA BB\\t\\tCC\\nDD\u0026#34;) //=\u0026gt; [\u0026#34;AA\u0026#34;, \u0026#34;BB\u0026#34;, \u0026#34;CC\u0026#34;, \u0026#34;DD\u0026#34;] strings.Fields 関数は、文字列をスペース系の文字（スペース、タブ、改行）で分割します。 CLI ツール（コマンドラインツール）の出力を加工したいときなどに便利です。 連続するスペースは、1 つのセパレーターとして扱われます。 スペースとみなされる文字は unicode.IsSpace で true と判断される文字です。 文字単位で分割する ss := strings.Split(\u0026#34;ABCあへ\u0026#34;, \u0026#34;\u0026#34;)) //=\u0026gt; [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;あ\u0026#34;, \u0026#34;へ\u0026#34;] strings.Split の区切り文字列（セパレーター）に空文字列を指定すると、UTF-8 文字単位 で分割されます。"},{url:"/p/q6r98p8/",title:"Android エミュレーター内のサーバーに外部からアクセスする (adb forward)",date:"2022-10-21T00:00:00Z",body:"Android エミュレーター内のサーバーに外部からアクセスする (adb forward) Android エミュレーターへのポート転送 (adb forward) サーバー機能を持つ Android アプリをエミュレーターで動作させているときに、ホスト PC の外からエミュレーター内のサーバーにアクセスするには、adb forward コマンドによるポート転送の設定が必要です。 例えば、次のようにフォワード設定すると、ホスト PC の 9080 番ポートへのアクセスが、エミュレーターの 8080 番ポートへ転送されるようになります。 PC の 9080 ポートをエミュレーターの 8080 ポートへ転送 $ adb forward tcp:9080 tcp:8080 9080 次の図は、Android エミュレーターを動かしている開発用 PC (192.168.1.1) を経由して、エミュレーター内の Web サーバーにアクセスする構成を示しています。 図: adb forward によるポート転送 外部の端末（PC やスマホ）から見ると、開発 PC (192.168.1.1) 上で Web サーバーが動いているかのように見えます。 Web ブラウザーで http://192.168.1.1:9080 という URL を開けば、エミュレーター内の Web サーバーに繋がります。 開発 PC 上で Web ブラウザーを開いてアクセスする場合は、自分自身にアクセスする形になるので、http://localhost:9080 や http://127.0.0.1:9080 のようなループバックアドレスを指定します。 この構成は、Android アプリ内のサーバープログラムを、PC 上のツールを使ってデバッグしたいときに便利です。 正確に言うと、adb forward によるポート転送はエミュレーター専用というわけではないので、USB で接続されている Android 端末への転送も可能です。 ただ、通常、物理スマホなどは直接 LAN に繋がっていることが多いので、ポート転送が必要になるケースは少ないでしょう（adb shell ip addr で端末のアドレスを確認して直接アクセスした方が早い）。 ちなみに、現在のポート転送設定は adb forward --list コマンドで確認できます。 ポート転送設定の一覧 $ adb forward --list Y7HRR58M60D tcp:9080 tcp:8080 転送設定を削除したいときは、adb forward --remove/--remove-all コマンドを使用します。 ポート転送設定を削除 $ adb forward --remove tcp:9080 # 個別に削除 $ adb forward --remove-all # すべて削除 エミュレーターからホスト PC を参照する エミュレーター内で動くプログラムから、ホスト PC を IP アドレスで参照したいときは、10.0.2.2 という特殊なループバックアドレスを使用します。 localhost や 127.0.0.1 というアドレスは、エミュレーター内のデバイスのループバックアドレスであることに注意してください。 図: エミュレーターからホスト PC を参照する ホスト PC を参照した結果、そのポートが adb forward で転送設定されている場合は、そのパケットはさらに別のエミュレーターに転送されます。 例えば、以下の構成では、Emulator 2 からのホスト PC へのアクセス (10.0.2.2:9080) が、Emulator 1 へポート転送されるようになっているため、結果的にエミュレーター間の通信が実現できています。 図: エミュレーター間の通信 （おまけ）テスト用の Web サーバー実行ファイル 本記事の構成を試してみたいときは、コマンドラインで実行できる簡易 Web サーバーがあると便利です。 下記は、Golang 製の簡単な Web サーバーの実装例です。 ポート番号 8080 で待ち受け、Hello という文字列を返します。 IP アドレス部分に 0.0.0.0 を指定しているのは、外部のネットワークからのアクセスを許可するためです。 hello.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) // 0.0.0.0 の部分を省略すると、同一ネットワークからしかアクセスできないので注意 const addr = \u0026#34;0.0.0.0:8080\u0026#34; func main() { http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, _ *http.Request) { w.Write([]byte(\u0026#34;Hello\u0026#34;)) }) log.Printf(\u0026#34;Serving on: %s\\n\u0026#34;, addr) log.Fatal(http.ListenAndServe(addr, nil)) } 次のような感じでビルドして Android 端末に転送すれば、Web サーバーを起動できます。 $ GOOS=linux GOARCH=arm go build -o hello hello.go $ adb push hello /data/local/tmp $ adb shell /data/local/tmp/hello 2022/10/21 20:25:47 Serving on HTTP port: 8080 Web サーバーを停止したいときは、Ctrl + C で終了するだけで OK です。 ホスト PC 上で別のターミナルを開いて、ポート転送設定 (adb forward) すれば、ホスト PC の IP アドレスを使って Web サーバーにアクセスできるはずです。 $ adb forward tcp:9080 tcp:8080 9080 $ curl localhost:9080 Hello ネットワークまわりのテストをしたいときに便利です ٩(๑❛ᴗ❛๑)۶ わーぃ 参考: Golang で Android 上で動く CLI コマンドを作成する (go build)"},{url:"/p/ftducta/",title:"Golang で Android 上で動く CLI コマンドを作成する (go build)",date:"2022-10-21T00:00:00Z",body:"Golang で Android 上で動く CLI コマンドを作成する (go build) 何をするか？ Golang（Go 言語）のクロスコンパイル機能を使うと、Android 上で動作するコマンドラインツール (CLI) を簡単に作成することができます。 Android 端末上で何らかの解析をするときに、Android 組み込みの Linux コマンドだとちょっと足りないな、といったときに便利です。 ここでは、Golang で簡単な Hello World アプリをビルドして、Android 端末上で動かしてみます。 Go 言語全般に関してはこちらを参照 → まくまく Golang ノート Android 端末の CPU アーキテクチャを確認しておく Golang でのクロスコンパイル時に CPU アーキテクチャを指定する必要があるので、対象の Anrdoid 端末のアーキテクチャを先に確認しておきます。 adb shell で Android 端末にシェル接続して、uname -a コマンドの末尾あたりで確認してしまうのが手っ取り早いです。 $ adb shell uname -a Linux localhost 5.10.100 #1 SMP PREEMPT Thu Mar 17 17:10:36 UTC 2022 aarch64 arm や aarch という文字列が入っていたら、ARM アーキテクチャの CPU だと思ってよいです。 Golang プログラムをビルドする 下記は、Golang の Hello World プログラムです。 hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World\u0026#34;) } Android 端末上で動く実行ファイルを生成するために、GOOS 環境変数で linux、GOARCH 環境変数で arm を指定してビルドします。 ちなみに、エミュレーター用にビルドするのであれば、おそらくアーキテクチャの指定は必要ないです。 Anrdoid 用にビルド（Linux/macOS の場合） $ GOOS=linux GOARCH=arm go build -o hello hello.go Anrdoid 用にビルド（Windows の場合） \u0026gt; set GOOS=linux \u0026gt; set GOARCH=arm \u0026gt; go build -o hello hello.go これで、実行ファイル hello が生成されます。 Android 端末上で実行ファイルを起動する 作成した実行ファイル (hello) を adb push で Android 端末に転送し、Android 端末上で実行してみます。 転送先ディレクトリとしては、アクセス制限の緩い /data/local/tmp を使います。 # hello を転送する $ adb push hello /data/local/tmp # hello を実行する $ adb shell chmod +x /data/local/tmp/hello $ adb shell /data/local/tmp/hello Hello World うまく動きました ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/uft7jv9/",title:"Golang で MongoDB を扱う (go.mongodb.org/mongo-driver)",date:"2022-10-16T00:00:00Z",body:"Golang で MongoDB を扱う (go.mongodb.org/mongo-driver) Golang を使って MongoDB サーバーに接続する方法の説明です。 Golang 用の MongoDB ドライバー go.mongodb.org/mongo-driver/mongo モジュールは、Golang 用の MongoDB 公式ドライバーです。 Golang のプロジェクトをモジュールモードで初期化して、go get で依存関係を追加すれば MongoDB にアクセスする準備は完了です。 $ mkdir example-mongo $ cd example-mongo $ go mod init example-mongo $ go get go.mongodb.org/mongo-driver/mongo MongoDB サーバーの準備 接続先の MongoDB サーバーはローカルで起動しておくか、MongoDB Atlas などのクラウドサービスで用意しておいてください。 参考: MongoDB 関連記事｜まくろぐ 以下の説明では、localhost:27017 で MongoDB サーバーが稼働していることを想定しています。 MongoDB に接続する MongoDB へ接続するためのクライアント設定は、options.ClientOptions インスタンスで表現します。 このインスタンスは options.Client() 関数で生成できるので、あとは各種セッターメソッドでオプション指定していきます。 MongoDB Atlas などのサービスを使っているのであれば、接続文字列が提供されているはずなので、それをそのまま ApplyURI メソッドに渡してやるだけで最低限の接続設定は完了します（参考: 接続文字列の形式）。 main.go（localhost:27017 への接続例） package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) // MongoDB サーバーの接続文字列 const uri = \u0026#34;mongodb://localhost:27017\u0026#34; func main() { ctx := context.Background() // 接続文字列の設定 opt := options.Client().ApplyURI(uri) if err := opt.Validate(); err != nil { log.Fatal(err) } // MongoDB サーバーへの接続 client, err := mongo.Connect(ctx, opt) if err != nil { log.Fatal(err) } // 関数を抜けるときに自動クローズ defer func() { if err := client.Disconnect(ctx); err != nil { log.Fatal(err) } }() // Ping してみる if err := client.Ping(ctx, nil); err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Ping to MongoDB server succeeded\u0026#34;) } 実行結果 $ go run . Connected to MongoDB クラス化で見通しをよくする 次のように構造体で mongo.Client インスタンスを保持するようにすれば、コレクション操作などをメソッドの形にまとめることができます。 接続先のアドレスを MONGODB_URI のような環境変数で設定できるようにしておくと、様々な環境で実行できるプログラムになります。 db/mydb.go package db import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) type MyDb struct { client *mongo.Client } func (db *MyDb) getUri() (uri string) { uri = os.Getenv(\u0026#34;MONGODB_URI\u0026#34;) if uri == \u0026#34;\u0026#34; { log.Println(\u0026#34;Env variable `MONGODB_URI` is not set, use `mongodb://localhost:27017` instead.\u0026#34;) uri = \u0026#34;mongodb://localhost:27017\u0026#34; } return uri } func (db *MyDb) Connect(ctx context.Context) (err error) { opt := options.Client().ApplyURI(db.getUri()) if err = opt.Validate(); err != nil { return err } db.client, err = mongo.Connect(ctx, opt) return err } func (db *MyDb) Disconnect(ctx context.Context) error { return db.client.Disconnect(ctx) } // （テスト用）接続確認 func (db *MyDb) Ping(ctx context.Context) (err error) { if err = db.client.Ping(ctx, nil); err != nil { return err } fmt.Println(\u0026#34;Ping to MongoDB server succeeded\u0026#34;) return nil } main.go package main import ( \u0026#34;context\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; \u0026#34;example-mongo/db\u0026#34; ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() // MongoDB サーバーへの接続 mydb := \u0026amp;db.MyDb{} if err := mydb.Connect(ctx); err != nil { log.Fatal(err) } defer mydb.Disconnect(ctx) // Ping してみる if err := mydb.Ping(ctx); err != nil { log.Fatal(err) } } BSON 形式について MongoDB はコレクション内のドキュメントを、BSON 形式 で保存しています。 BSON は JSON をバイナリ形式にして効率的なやりとりを行えるようにしたフォーマットです。 Golang で MongoDB のデータ操作を行うには、次のような変換処理 (marshalling/unmarshalling) が必要です。 Marshalling \u0026hellip; 「Golang オブジェクト → BSON」の変換 Unmarshalling \u0026hellip; 「BSON → Golang オブジェクト」の変換 この変換処理には、MongoDB 公式の mongo-driver パッケージに含まれている bson モジュールが使用されます。 import \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; Golang の struct（構造体）を marshal/unmarshal しようとすると、公開された（大文字で始まる）フィールドのみ が変換対象になります。 また、BSON キー名は、struct のフィールド名を すべて小文字に変換したもの になります。 type Book struct { Title string // BSON キー名は \u0026#34;title\u0026#34; になる Authors []string // BSON キー名は \u0026#34;authors\u0026#34; になる } デフォルトの変換ルールでは不十分なときは、Golang の struct tags の仕組み を使うことで、ある程度カスタマイズできます。 type Student struct { FirstName string `bson:\u0026#34;first_name,omitempty\u0026#34;` LastName string `bson:\u0026#34;last_name,omitempty\u0026#34;` Address Address `bson:\u0026#34;inline\u0026#34;` Age int } 例えば上記のようにタグ指定しておけば、FirstName フィールドの BSON キー名は firstname ではなく first_name になり、ゼロ値のときは空文字列 (\u0026quot;\u0026quot;) が保存されるのではなく BSON キー自体が省略されます。 Address 構造体の各フィールドはフラット化されて、FirstName や LastName と同じ階層に保存されます。 コレクションを操作する MongoDB サーバーへの接続が済んだら、あとは mongo.Collection の各種メソッドを使って、コレクション内のドキュメントを操作できます。 コレクションにドキュメントを追加する (InsertOne) 次の例では、testdb データベースの books コレクションに、Book 構造体のデータを保存しています。 // MongoDB のコレクションに格納するドキュメントの型 type Book struct { Title string Authors []string `bson:\u0026#34;omitempty\u0026#34;` } // 追加するドキュメントを生成 book := \u0026amp;Book{Title: \u0026#34;Title-1\u0026#34;} // 追加を実行 (InsertOne) result, err := client.Database(\u0026#34;testdb\u0026#34;).Collection(\u0026#34;books\u0026#34;).InsertOne(ctx, book) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Book inserted %v\\n\u0026#34;, result) コレクションから 1 つのドキュメントを取得する (FindOne) 次の例では、books コレクションから、title キーが Title-1 に一致するドキュメントを検索しています。 FindOne メソッドは、指定した条件（フィルター）に一致するドキュメントが複数あっても、1 つのドキュメントのみを返します。 検索フィルターとして使っている bson.M 構造体は、マップ形式の BSON データを表現するためのものです。 // 検索フィルター filter := \u0026amp;bson.M{\u0026#34;title\u0026#34;: \u0026#34;Title-1\u0026#34;} // 検索を実行 (FindOne) result := client.Database(\u0026#34;testdb\u0026#34;).Collection(\u0026#34;books\u0026#34;).FindOne(filter) // 結果をデコードして Golang オブジェクトとして参照する var book Book if err := result.Decode(\u0026amp;book); err != nil { log.Fatal(err) } log.Printf(\u0026#34;%#v\\n\u0026#34;, book) コレクションから複数のドキュメントを取得する (Find) フィルターで指定した条件に一致するすべてのドキュメントを取得したいときは、FindOne の代わりに Find メソッドを使用します。 Find メソッドは、*mongo.Cursor オブジェクトを返すので、これを使って取得した複数のドキュメントを参照できます。 ドキュメント内のすべてのドキュメントを取得したいときは、Find メソッドに空っぽのフィルター (bson.D{}) を指定します。 // 検索フィルター（すべてのドキュメントを取得する場合） filter := \u0026amp;bson.D{} // 検索を実行 (Find) coll := client.Database(\u0026#34;testdb\u0026#34;).Collection(\u0026#34;books\u0026#34;) cursor, err := coll.Find(ctx, filter) // 結果をデコードして Golang オブジェクトとして参照する var books []Book if err := cursor.All(ctx, \u0026amp;books); err != nil { log.Fatal(err) } log.Printf(\u0026#34;%#v\\n\u0026#34;, books) 関連リンク Deno で MongoDB を扱う Rust で MongoDB を扱う (mongodb)"},{url:"/p/wdvdtap/",title:"gqlgen で子フィールドの情報を返すリゾルバーを実装する",date:"2022-10-05T00:00:00Z",body:"gqlgen で子フィールドの情報を返すリゾルバーを実装する 何をするか？ Golang の GraphQL ライブラリである gqlgen を使って、GraphQL スキーマからサーバー実装用のコードを自動生成するときに、オブジェクト型の子フィールド用のリゾルバーを生成する方法を説明します。 gqlgen の基本的な使い方は下記を参照してください。 参考: GraphQL サーバーを作成する (gqlgen) デフォルト設定でコード生成した場合 ここでは、入力用の GraphQL スキーマとして次のようなファイルを使うことにします。 オブジェクト型として Book と Author があり、Author は Book の author フィールドとしてのみ使用されています。 graph/schema.graphqls type Query { books: [Book!]! } type Book { id: ID! title: String! author: Author } type Author { id: ID! name: String! } gqlgen generate すると、次のようなモデル（型情報）コードが生成されます。 graph/model/models_gen.go // Code generated by github.com/99designs/gqlgen, DO NOT EDIT. package model type Author struct { ID string `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` } type Book struct { ID string `json:\u0026#34;id\u0026#34;` Title string `json:\u0026#34;title\u0026#34;` Author *Author `json:\u0026#34;author\u0026#34;` } さらに、リゾルバーのテンプレートコードとして次のようなメソッドが自動生成されるのですが、デフォルトの設定 (gqlgen.yml) では、Query 型のフィールドに対応するリゾルバーメソッドしか生成されません。 例えば、今回のスキーマの場合 books フィールドを取得するためのリゾルバーメソッドのみが生成されます。 graph/schema.resolvers.go（抜粋） // Books is the resolver for the books field. func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { panic(fmt.Errorf(\u0026#34;not implemented: Books - books\u0026#34;)) } ちなみに、上記メソッドシグネチャ内の、queryResolver と Books という名前は、「Query オブジェクト型の books フィールドを取得するためのリゾルバー」であることを示しています。 Book オブジェクト型の author フィールドを取得するためのリゾルバーは生成されないので、books フィールド用のリゾルバー実装だけで、すべての子フィールドのデータを返すように実装しなければいけません。 例えば、2 つの書籍データを返すリゾルバー実装は次のような感じになります（強引にハードコードしてます）。 func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { // フェイクデータ（本当は別パッケージ化して db.GetBooks() のようにすべき） books := []*model.Book{ { ID: \u0026#34;book-id-1\u0026#34;, Title: \u0026#34;Book title 1\u0026#34;, Author: \u0026amp;model.Author{ID: \u0026#34;author-id-1\u0026#34;, Name: \u0026#34;Author name 1\u0026#34;}, }, { ID: \u0026#34;book-id-2\u0026#34;, Title: \u0026#34;Book title 2\u0026#34;, Author: \u0026amp;model.Author{ID: \u0026#34;author-id-2\u0026#34;, Name: \u0026#34;Author name 2\u0026#34;}, }, } return books, nil } オブジェクト型のフィールドがこれくらいシンプルであれば何とかなるのですが、入れ子構造が深くなってくると、子孫フィールドをすべて処理しなければならず大変です。 また、上記の例では、クライアントから author フィールドが要求されているかどうかにかかわらず著者情報を DB からフェッチしており（今回はハードコードですが）、それも無駄です。 さらに、フィールドに検索やフィルタ用の引数が追加されたら、その引数に応じたデータフェッチ処理を行わなければならず、ますます複雑になってきます。 クライアントから実際に指定されたフィールド引数の値は、リゾルバーのパラメーターとして渡される context.Context オブジェクトを使って graphql.GetFieldContext(ctx) のようにすれば参照できるのですが、これはこれで大変です。 author フィールド用のリゾルバーを、別メソッドとして定義できれば、実装がぐっと楽になります。 フィールド用のリゾルバーを生成する やりたいことは、GraphQL スキーマで定義した Book オブジェクト型の author フィールドの専用リゾルバーを生成する、ということです。 そのためには、gqlgen の設定ファイル (gqlgen.yml) の models プロパティで次のように設定します。 gqlgen.yml（抜粋） models: Book: fields: author: resolver: true # ... 「Book 型のフィールドである author のリゾルバーを生成する」という設定です。 そのまんまですね。 このように設定した状態で、gqlgen generate を実行すると、リゾルバーのテンプレートとして次のようなコードが生成されるようになります。 graph/schema.resolvers.go（抜粋） // Author is the resolver for the author field. func (r *bookResolver) Author(ctx context.Context, obj *model.Book) (*model.Author, error) { panic(fmt.Errorf(\u0026#34;not implemented: Author - author\u0026#34;)) } // Books is the resolver for the books field. func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { panic(fmt.Errorf(\u0026#34;not implemented: Books - books\u0026#34;)) } Book オブジェクト型の author フィールドを処理するための専用のリゾルバーメソッド (*bookResolver) Author が生成されたので、books リゾルバー側の実装では author フィールドを処理する必要がなくなります。 下記はフェイクデータを使用したリゾルバー実装例です。 // Author is the resolver for the author field. func (r *bookResolver) Author(ctx context.Context, obj *model.Book) (*model.Author, error) { // author フィールド用のフェイクデータ（親オブジェクト型 Book の情報を利用して実装できる） author := \u0026amp;model.Author{ ID: \u0026#34;author-id-\u0026#34; + obj.ID, Name: \u0026#34;Author name of \u0026#34; + obj.Title, } return author, nil } // Books is the resolver for the books field. func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { // books フィールド用のフェイクデータ（ここで author フィールドのデータは返さなくてよい） books := []*model.Book{ {ID: \u0026#34;book-id-1\u0026#34;, Title: \u0026#34;Book title 1\u0026#34;}, {ID: \u0026#34;book-id-2\u0026#34;, Title: \u0026#34;Book title 2\u0026#34;}, } return books, nil } 前述の (*queryResolver) Books リゾルバーのみを使った実装よりも、だいぶ分かりやすくなったと思います。 もちろん、クライアントから author フィールドを要求されなかった場合は、(*bookResolver) Author リゾルバーが呼び出されることはないので、余計な DB フェッチが行われる心配もありません。 バッチシですね！ ちなみに、フィールド引数を扱うときもほぼ同様の実装で対応できます。 例えば、GraphQL スキーマの Book オブジェクト型の author フィールドに、次のような realName パラメータを追加したとします（本名を取得するためのフラグのつもり）。 graph/schema.graphqls type Book { id: ID! title: String! author(realName: Boolean = false): Author } すると、author フィールド用のリゾルバーメソッドのパラメーターにも realName が追加されるので、その情報を使ってリゾルバーを実装することができます。 graph/schema.resolvers.go（抜粋） // Author is the resolver for the author field. func (r *bookResolver) Author(ctx context.Context, obj *model.Book, realName *bool) (*model.Author, error) { // Book 型の author フィールドの値を構築（本当は DB などからフェッチ） name := \u0026#34;Author name of \u0026#34; + obj.Title if *realName { name += \u0026#34; (REAL NAME)\u0026#34; } author := \u0026amp;model.Author{ ID: \u0026#34;author-id-\u0026#34; + obj.ID, Name: name, } return author, nil } 言語仕様上、Golang 関数の realName パラメーターではデフォルト値が表現できていませんが、クライアントからのクエリで realName 引数が省略された場合は、ちゃんと GraphQL スキーマで定義されたデフォルト値（今回は false) を受け取れるようになっています（これは gqlgen フレームワーク側の仕組みです）。 完璧ですね！"},{url:"/p/cp8o6m2/",title:"Golang のジェネリクスで複数の型を扱える関数を定義する (generics)",date:"2022-09-25T00:00:00Z",body:"Golang のジェネリクスで複数の型を扱える関数を定義する (generics) Golang のジェネリクスを使用すると、複数の型を扱う関数を定義できます。 ジェネリクスは別の言語ではごく一般的な機能として提供されていますが、シンプルな言語仕様を理想としている Golang では当初提供されていませんでした。 ただ、ジェネリクスを望む声は多く、Golang ver 1.8 で導入されることになりました。 ジェネリクスを使わない場合 次のコードの SumInt64 関数と SumFloat64 関数は、両方とも数値スライスの要素を足し合わせる関数ですが、パラメーターの型が int64 と float64 で異なっているため、別々の関数として定義しています。 package main import \u0026#34;fmt\u0026#34; // int64 スライスの全要素を足し合わせた結果を返します。 func SumInt64(vals []int64) int64 { var sum int64 for _, v := range vals { sum += v } return sum } // float64 スライスの全要素を足し合わせた結果を返します。 func SumFloat64(vals []float64) float64 { var sum float64 for _, v := range vals { sum += v } return sum } func main() { fmt.Println(SumInt64([]int64{100, 200, 300})) //=\u0026gt; 600 fmt.Println(SumFloat64([]float64{0.1, 0.2, 0.3})) //=\u0026gt; 0.6 } でも、SumInt64 と SumFloat64 の実装はほぼ同じなので、別の関数として実装するのは無駄な気がします。 さらに悲しいことに、次のように定義された MyInt 型のスライスを SumInt64 関数に渡そうとしてもエラーになります。 type MyInt int64 fmt.Println(SumInt64([]MyInt{1, 2, 3})) // エラー（MyInt は int64 ではない） そこで、ジェネリクスの出番です。 ジェネリクスの基本 ジェネリクス対応の関数を定義するには、関数名の後ろにブラケット ([]) で囲んだ 型パラメーター (type parameters) を記述し、その型を関数内で使用します。 次の Sum 関数は、int64 と float64 のどちらの型のスライスでも引数に指定できるようにしています。 // 数値型スライスの全要素を足し合わせた結果を返します。 func Sum[T int64 | float64](vals []T) T { var sum T for _, v := range vals { sum += v } return sum } [T int64 | float64] という型パラメーターは、int64 と float64 のいずれかである型 T を定義しています。 型 T が実際にどの型として扱われるかは、コンパイル時に判断されます。 型 T は、関数のパラメータ、戻り値、本体の実装のどの部分でも使用することができます。 ジェネリクス対応した関数は、通常の関数と同じように呼び出すことができます。 ints := []int64{100, 200, 300} fmt.Println(Sum(ints)) //=\u0026gt; 600 floats := []float64{0.1, 0.2, 0.3} fmt.Println(Sum(floats)) //=\u0026gt; 0.6 めでたし、めでたし！ といきたいところですが、ここで注意しないといけないのは、[T int64 | float64] のような型パラメータは、正確に int64 型と float64 型のどちらかしか扱えないということです。 例えば、次のように定義した MyInt 型を使おうとするとエラーになります。 type MyInt int64 ints := []MyInt{100, 200, 300} fmt.Println(Sum(ints)) // エラー (ノ_・、) MyInt の本質的な型は int64 なのに、それを Sum 関数で受け取れないのは悲しすぎます。 この問題に対応するために、Golang は 基礎型 (underlying type) という概念を導入しました。 上記の場合、MyInt の underlying type は int64 です。 型パラメーターにおいて、underlying type が int64 である型を示すためには、前にチルダを付けて、~int64 のように表現します。 次の Sum 関数の型パラメーター T は、underlying type が int64 あるいは float64 である型を扱うことができます。 func Sum[T ~int64 | ~float64](vals []T) T { // ... } func main() { type MyInt int64 ints := []MyInt{100, 200, 300} fmt.Println(Sum(ints)) //=\u0026gt; 600（MyInt スライスを渡せた！） } 型パラメーターの定義するときは、利便性を考慮して underlying type で指定することが多くなると思います。 呼び出し時に型引数が必要な場合 前述のような型パラメーター T の実際の型はコンパイル時に自動的に判断（推測）されますが、呼び出し時に明示的に型を指定しないといけないケースがあります。 典型的には、引数から型パラメーターの型が推測できないケースです。 次のサンプルコードの MakeRandomSlice 関数は、指定したサイズのランダムなスライスを生成する関数ですが、生成すべきスライス要素の型 T は、size 引数からは推測できません。 そこで、呼び出し時に MakeRandomSlice[int32](3) のように、どの型のスライスを生成するかを明示してやる必要があります。 このブラケットで囲んだ [int32] の部分を、型引数 (type arguments) と呼びます。 package main import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; ) // 指定した型、サイズのランダムスライスを生成します。 func MakeRandomSlice[T ~int32 | ~float32](size int) []T { var vals = make([]T, 0, size) var v T for i := 0; i \u0026lt; size; i++ { binary.Read(rand.Reader, binary.LittleEndian, \u0026amp;v) vals = append(vals, v) } return vals } func main() { // int32 型のランダムスライスを生成する ints := MakeRandomSlice[int32](3) fmt.Println(ints) //=\u0026gt; [-717388130 -1507011086 854848415] // float32 型のランダムスライスを生成する floats := MakeRandomSlice[float32](3) fmt.Println(floats) //=\u0026gt; [4.4246736e+08 7.834249e-16 1.5574595e+29] } 制約インタフェース (constraint interface) 浮動小数点数を扱う型パラメーターは、次のような感じで定義できますが、複数の関数でこのような記述を毎回行うのは面倒です。 [T ~float32 | ~float64] 次のようなインタフェース型を定義しておくと、型パラメーターをシンプルに記述できるようになります。 Golang のチュートリアルでは、こういったインタフェースのことを、制約インタフェース (constraint interface) と呼んでいます。 type Float interface { ~float32 | ~float64 } このように定義した制約インタフェース Float は、次のように型パラメーター部分で使用できます。 func Max[T Float](a, b T) T { if a \u0026gt; b { return a } return b } 実は、こういった基本的な型の制約インタフェースは、公式の constraints パッケージ で定義されています。 type Signed interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 } type Unsigned interface { ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr } type Integer interface { Signed | Unsigned } type Float interface { ~float32 | ~float64 } type Complex interface { ~complex64 | ~complex128 } type Ordered interface { Integer | Float | ~string } 次のサンプルコードでは、constraints パッケージが提供する constraints.Ordered 制約インタフェースを使用しています。 このインタフェースは、大小比較が可能な基本型を表現しています（これには string 型も含まれます）。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/exp/constraints\u0026#34; ) func Max[T constraints.Ordered](a, b T) T { if a \u0026gt; b { return a } return b } func main() { fmt.Println(Max(100, 200)) //=\u0026gt; 200 fmt.Println(Max(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;)) //=\u0026gt; B } 複数の型パラメーター 1 つの関数で複数の型パラメーターを扱いたいときは、カンマ (,) で区切って並べます。 次の Sum 関数は、数値型の値を持つマップを受け取り、その値の合計値を返します。 package main import \u0026#34;fmt\u0026#34; type Number interface { ~int64 | ~uint64 | ~float64 } // マップの値を足し合わせます。 func Sum[K comparable, V Number](m map[K]V) V { var sum V for _, v := range m { sum += v } return sum } func main() { ints := map[string]int64{ \u0026#34;AAA\u0026#34;: 1, \u0026#34;BBB\u0026#34;: 2, \u0026#34;CCC\u0026#34;: 3, } fmt.Println(Sum(ints)) //=\u0026gt; 6 } comparable というのは、Golang 組み込みのインタフェース型であり、このように型パラメーター部分で使うことが想定されています。 comparable は、その値が == や != で比較することが可能であることを示しており、これはつまり、マップのキーとして扱える型であることを示しています。"},{url:"/p/graq8o5/",title:"Golang でランダム値（乱数）を扱う (math/rand, crypto/rand)",date:"2022-09-24T00:00:00Z",body:"Golang でランダム値（乱数）を扱う (math/rand, crypto/rand) Golang でランダム値を扱うパッケージは以下の 2 つが用意されています。 math/rand \u0026hellip; 擬似乱数生成器 (pseudo-random number generator)。初期化のための Seed によって生成される一連の乱数が決定するため、再現性がある。高速な生成が可能だが、生成されるランダム値が予測され得るため、暗号系技術での使用には適さない。 crypto/rand \u0026hellip; 暗号論的擬似乱数生成器（CSPRNG: cryptographically secure pseudo random number generator)。生成されるランダム値を予測するのが困難で、暗号系技術での使用に適している。例えば、秘密鍵の生成や、Nonce 値の生成に用いることができる。math/rand に比べ、crypto/rand でのランダム値生成は時間がかかる。 math/rand による乱数生成 math/rand パッケージのランダム生成器 (*rand.Rand) は、rand.New コンストラクタで生成します。 典型的には、現在時刻を元にしたシードを与えて初期化します。 *rand.Rand を生成する方法 seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) val := r.Float64() // 乱数を生成（rand.Rand のメソッド） あるいは、rand.Seed 関数で、トップレベル関数用のシードを設定することもできます。 こちらの方法を使う場合は、*rand.Rand インスタンスを生成する必要はありません。 トップレベル関数用のシードを設定する方法 seed := time.Now().UnixNano() rand.Seed(seed) val := rand.Float64() // 乱数を生成（rand のトップレベル関数） math/rand パッケージは、次のような乱数生成関数を提供しています。 メソッド 説明 戻り値の型 値の範囲 Int31() 0 以上の 31 ビット整数 int32 0 〜 2,147,483,647 Int31n(n) 0 以上 n 未満の 31 ビット整数 int32 0 〜 n（n ≧ 1） Uint32() 0 以上の 32 ビット整数 uint32 0 〜 4,294,967,295 Int63() 0 以上の 63 ビット整数 int64 0 〜 9,223,372,036,854,775,807 Int63n(n) 0 以上 n 未満の 63 ビット整数 int64 0 〜 n（n ≧ 1） Uint64() 0 以上の 64 ビット整数 uint64 0 〜 18,446,744,073,709,551,615 Int() 0 以上の整数（少なくとも 32 ビット） int 0 〜 システム依存 Intn(n) 0 以上 n 未満の整数（少なくとも 32 ビット） int 0 〜 n（n ≧ 1） Float32() 浮動小数点数（float32 型） float32 [0.0, 1.0)（0.0 以上 1.0 未満） Float64() 浮動小数点数（float64 型） float64 [0.0, 1.0)（0.0 以上 1.0 未満） math/rand による乱数生成の例 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) func main() { seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) fmt.Println(r.Int31()) // 1401608483 (int32) fmt.Println(r.Uint32()) // 3362137694 (uint32) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Println(r.Int63()) // 9200732467715261966 (int64) fmt.Println(r.Uint64()) // 17815840155156866386 (uint64) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Println(r.Float32()) // 0.34179267 (float32) fmt.Println(r.Float64()) // 0.7233553795829966 (float64) fmt.Println(\u0026#34;-------\u0026#34;) fmt.Println(r.Int31n(10000)) // 1451 (int32) fmt.Println(r.Int63n(10000)) // 7504 (int64) } Read(p []byte) メソッドを使用すると、任意の長さのバイト配列を生成することができます。 4 バイト分のランダム配列を生成 bytes := make([]byte, 4) r.Read(bytes) fmt.Println(bytes) // [231 52 121 45] crypto/rand による乱数生成 予測の難しい乱数値が欲しいときは、math/rand パッケージの代わりに crypto/rand を使用します。 パッケージ内部の乱数生成には、Linux 系 OS では /dev/urandom や getentropy(2)、Windows では RtlGenRandom API が使われています。 次の例では、rand.Int 関数を使って、0 以上 n 未満のランダム整数 (*big.Int) を生成しています。 シードによる初期化は必要ありません。 package main import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/big\u0026#34; ) func main() { // 0 以上 n 未満のセキュアなランダム整数を生成 var n int64 = 1_000_000_000 val, err := rand.Int(rand.Reader, big.NewInt(n)) if err != nil { panic(err) } fmt.Println(val.Int64()) //=\u0026gt; 721357881 } crypto/rand パッケージは、math/rand ほど柔軟なランダム生成関数を備えていませんが、encoding/binary パッケージと組み合わせて使用すると、任意の型にランダム値を詰めることができます。 package main import ( \u0026#34;crypto/rand\u0026#34; \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { var v int32 // 任意の型を指定可能 binary.Read(rand.Reader, binary.LittleEndian, \u0026amp;v) fmt.Println(v) //=\u0026gt; 2017071203 } math/rand と同様、crypto/rand でも指定した長さのバイト配列を生成することができます。 func main() { bytes := make([]byte, 4) rand.Read(bytes) fmt.Println(bytes) //=\u0026gt; [235 16 197 104] } （応用）crypto/rand で math/rand のシードを生成する 現在時刻を math/rand のシードに使うのは抵抗があるけど、crypto/rand ほどセキュアな乱数は必要ないという場合は、シードの生成のみを crypto/rand で行うという方法があります。 main.go package main import ( cryptorand \u0026#34;crypto/rand\u0026#34; \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) // 予測困難なシードで math/rand を初期化 func initRandomSeed() { var seed int64 if err := binary.Read(cryptorand.Reader, binary.LittleEndian, \u0026amp;seed); err != nil { panic(err) } rand.Seed(seed) } func main() { initRandomSeed() for i := 0; i \u0026lt; 20; i++ { fmt.Print(rand.Intn(10), \u0026#34; \u0026#34;) // 0 〜 9 のランダム整数を生成 } fmt.Println() } 実行結果 $ go run main.go 9 8 9 7 3 3 0 2 1 4 9 9 2 6 1 6 0 5 8 1 （応用）ランダムな文字列を生成する 次の RandomId 関数は、指定した長さのランダムな文字列を生成します（例: m6t2j7a）。 strutil/strutil.go package strutil import ( cryptorand \u0026#34;crypto/rand\u0026#34; \u0026#34;encoding/binary\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) func init() { initRandomSeed() } // 指定した長さのランダム文字列を生成します func RandomId(length int) string { const CANDIDATES = \u0026#34;23456789abcdefghijkmnopqrstuvwxyz\u0026#34; const LEN_CAND = len(CANDIDATES) bytes := make([]byte, 0, length) // 必要な capacity は明確 for i := 0; i \u0026lt; length; i++ { bytes = append(bytes, CANDIDATES[rand.Intn(LEN_CAND)]) } return string(bytes) } // 予測困難なシードで math/rand を初期化します func initRandomSeed() { var seed int64 if err := binary.Read(cryptorand.Reader, binary.LittleEndian, \u0026amp;seed); err != nil { fmt.Fprintln(os.Stderr, \u0026#34;WARN: Seed creation by crypto/rand failed, so current time was used instead\u0026#34;) seed = time.Now().UnixNano() } rand.Seed(seed) } main.go（使用例） package main import ( \u0026#34;fmt\u0026#34; \u0026#34;hello/strutil\u0026#34; ) func main() { fmt.Println(strutil.RandomId(7)) //=\u0026gt; \u0026#34;m6t2j7a\u0026#34; } 参考: ランダム ID 生成ツール｜まくろぐ"},{url:"/p/egs2bjt/",title:"Golang でカレントディレクトリ、実行ファイルのパスを取得する (os.Getwd, os.Executable)",date:"2022-09-23T00:00:00Z",body:"Golang でカレントディレクトリ、実行ファイルのパスを取得する (os.Getwd, os.Executable) カレントディレクトリのパス (os.Getwd) Golang でカレントディレクトリのパスを取得するには、os.Getwd 関数 を使用します。 戻り値は、カレントディレクトリを示す 絶対パス（フルパス） の文字列になります。 カレントディレクトリは、go run コマンドなどを実行したときのディレクトリのことであり、.go ファイルのあるパスではないことに注意してください。 main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { dir, err := os.Getwd() if err != nil { panic(err) } fmt.Println(dir) } 実行結果 $ cd /Users/maku/hello $ go run main.go /Users/maku/hello $ cd /Users/maku $ go run hello/main.go /Users/maku 実行中のファイルのパス (os.Executable) 実行中のファイル (executable) のフルパスを取得するには、os.Executable 関数 を使用します。 main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { path, err := os.Executable() if err != nil { panic(err) } fmt.Println(path) } 実行結果 $ cd ~/hello $ go build -o myexe main.go $ ./myexe /Users/maku/hello/myexe go run コマンドで .go ファイルを指定して実行した場合は、内部的にビルドされて生成された実行ファイルのパスが表示されます。 $ go run main.go /var/folders/g7/08g8xg4x7_lb3k_tgpwwdfmr0000gn/T/go-build9032354/b001/exe/main 応用例として、実行ファイルのあるディレクトリのパスを取得したい場合は、filepath.Dir 関数を組み合わせて使用します。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { exePath, err := os.Executable() if err != nil { panic(err) } exeDir := filepath.Dir(exePath) fmt.Println(exePath) //=\u0026gt; /Users/maku/hello/myexe fmt.Println(exeDir) //=\u0026gt; /Users/maku/hello } 実行ファイルと同じディレクトリにあるリソースファイルのパスを構築したければ、以下のように filepath.Join でパスを繋ぎます。 dataPath := filepath.Join(exeDir, \u0026#34;data.txt\u0026#34;) //=\u0026gt; /Users/maku/hello/data.txt とはいえ、前述の通り、os.Executable が返すパスは、go run main.go のように .go ファイルを指定して実行した場合はおそらく想定外のものになるので、リソースファイルのパスはコマンドライン引数や環境変数で指定するのが無難です。 参考: Golang でコマンドライン引数を扱う (os.Args, flags) 参考: Golang で環境変数を扱う (os.Getenv, os.LookupEnv)"},{url:"/p/6k5m3iz/",title:"Golang で CSV 形式の文字列やファイルを扱う (encoding/csv)",date:"2022-09-20T00:00:00Z",body:"Golang で CSV 形式の文字列やファイルを扱う (encoding/csv) Golang 標準パッケージの encoding/csv を使用すると、CSV 形式のテキストやファイルを Golang の string 配列で読み書きできます。 CSV はカンマ区切りの単純なフォーマットなので、自力でテキストファイルを読み書きすれば済んでしまいそうですが、改行やダブルクォート (\u0026quot;) 含むフィールドの扱い方 (RFC 4180) など、微妙に考慮しないといけない部分もあるので、やはり専用の Reader/Writer 実装を使った方が安心です。 import \u0026#34;encoding/csv\u0026#34; このパッケージは、主に次のクラスを提供しています。 csv.Reader \u0026hellip; CSV の読み出しに使用 csv.Writer \u0026hellip; CSV の書き込みに使用 パッケージ名に csv という名前が使われていますが、オプション指定によりタブ区切り形式の TSV データを扱うこともできます（後述）。 CSV ファイル／テキストを読み出す (csv.Reader) CSV 形式のファイルやテキストを読み出すには、csv.NewReader コンストラクタで csv.Reader を生成します。 func csv.NewReader(r io.Reader) *csv.Reader このコンストラクタは、データソースを読み出すための io.Reader を受け取るようになっているので、CSV テキストを扱いたいときは strings.Reader を、CSV ファイルを扱いたいときは os.File を渡してやれば OK です（どちらも io.Reader のメソッド Read を実装しています）。 あとは、次のようなメソッドで各レコードを文字列スライスとして読み出すことができます。 // 1 つのレコードを読み出す func (r *csv.Reader) Read() (record []string, err error) // すべてのレコードを読み出す func (r *csv.Reader) ReadAll() (records [][]string, err error) CSV ファイル読み出しの実装例 input.csv（入力ファイル） name,age,blood_type Asuka,14,A Maya,24,A Ritsuko,30,B main.go package main import ( \u0026#34;encoding/csv\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Open(\u0026#34;input.csv\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() reader := csv.NewReader(file) for { record, err := reader.Read() // CSV を 1 レコードずつ読み込み if err == io.EOF { break // 最後まで読み出した } if err != nil { log.Fatal(err) // 読み出し時にエラー発生 } // 1 レコード分のデータを出力（record は []string 型） fmt.Println(record) } } 実行結果 $ go run main.go [name age blood_type] [Asuka 14 A] [Maya 24 A] [Ritsuko 30 B] 2 次元スライスに一括で読み出す (os.ReadAll) (*csv.Reader) Read の代わりに (*csv.Reader) ReadAll メソッドを使用すると、CSV の全レコードを 2 次元スライス ([][]string) 変数に一括で読み出すことができます。 大きな CSV ファイルを扱わないことが分かっているのであれば、こちらを使った方が手っ取り早いかもしれません。 reader := csv.NewReader(file) records, err := reader.ReadAll() if err != nil { log.Fatal(err) } // records は [][]string 形式のデータ for _, fields := range records { fmt.Println(fields) // fields は []string（CSV の 1 レコード） } CSV テキストを扱う 文字列変数に格納された CSV 形式のテキストを扱いたいときは、文字列から生成した strings.Reader を csv.NewReader 関数に渡して、csv.Reader を生成します。 残りの処理は、CSV ファイルを扱う場合と同様です。 main.go text := `name,age,blood_type Asuka,14,A Maya,24,A Ritsuko,30,B ` reader := csv.NewReader(strings.NewReader(text)) 入力時のオプション csv.Reader の各種オプションプロパティで、CSV 読み込み時の振る舞いを制御できます。 これにより、TSV（タブ区切り）形式やコメント (#) 入りのファイルを扱うことができます。 reader := csv.NewReader(file) reader.Comma = \u0026#39;\\t\u0026#39; // 区切り文字（タブ文字を指定すれば TSV ファイルを扱える） reader.Comment = \u0026#39;#\u0026#39; // この文字で始まる行をコメント行とみなす reader.TrimLeadingSpace = true // 各フィールドの先頭の空白を削除する CSV ファイルを書き込む (csv.Writer) 文字列スライスを CSV ファイルに出力したいときは、書き込み用にオープン (os.Create) した os.File インスタンスを csv.NewWriter 関数に渡して、csv.Writer を生成します。 (*osv.Writer) Write メソッドを呼び出すごとに、1 つの文字列スライス（CSV レコード）を出力します。 ただし、出力処理は内部的にバッファリングされるので、最後に (*osv.Writer) Flush メソッドを呼び出す必要があることに注意してください。 次の例では、defer で呼び出すようにしています。 package main import ( \u0026#34;encoding/csv\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 出力用にファイルをオープン file, err := os.Create(\u0026#34;output.csv\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // CSV 形式でデータを書き込む writer := csv.NewWriter(file) defer writer.Flush() // 内部バッファのフラッシュは必須 writer.Write([]string{\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;}) writer.Write([]string{\u0026#34;100\u0026#34;, \u0026#34;200\u0026#34;, \u0026#34;300\u0026#34;}) writer.Write([]string{\u0026#34;XXX\u0026#34;, \u0026#34;YYY\u0026#34;, \u0026#34;ZZZ\u0026#34;}) } output.csv（出力結果） AAA,BBB,CCC 100,200,300 XXX,YYY,ZZZ 文字列の 2 次元スライスをまとめて書き出したい場合は、Write の代わりに WriteAll メソッドを使用します。 WriteAll を使う場合は内部で Flush を呼び出してくれるので、明示的に Flush を呼び出す必要はありません。 records := [][]string{ {\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;}, {\u0026#34;100\u0026#34;, \u0026#34;200\u0026#34;, \u0026#34;300\u0026#34;}, {\u0026#34;XXX\u0026#34;, \u0026#34;YYY\u0026#34;, \u0026#34;ZZZ\u0026#34;}, } writer := csv.NewWriter(file) writer.WriteAll(records) TSV 形式で出力したいときは、csv.Writer の Comma プロパティにタブ文字 (\\t) を指定してから Write / WriteAll メソッドを呼び出します。 writer := csv.NewWriter(file) writer.Comma = \u0026#39;\\t\u0026#39;"},{url:"/p/kgzfwdt/",title:"Golang で RDB（リレーショナルデーターベース）を扱う (database/sql)",date:"2022-09-17T00:00:00Z",body:"Golang で RDB（リレーショナルデーターベース）を扱う (database/sql) Golang の database/sql パッケージ を使用すると、Postgres、MariaDB (MySQL)、SQLite といった RDB 系のデータベースを共通のインタフェースで操作することができます。 database/sql を使ってコーディングしておけば、将来的な RDBMS の乗り換えが容易になります。 ドライバーのインストール database/sql はデータベース操作用の抽象化レイヤーを提供するだけなので、実際にデータベースに接続するには、それぞれのデータベースごとのドライバーが必要です。 ドライバーは SQLDrivers の一覧ページ から好きなものを選択します。 例えば、mattn 氏の SQLite 用ドライバーを使う場合は、次のように go.mod の依存関係を更新し、 $ go get github.com/mattn/go-sqlite3 Go プログラム内で次のようにインポートしておきます（先にインポート文を書いてから go get . とする方法もあります）。 import ( \u0026#34;database/sql\u0026#34; _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; ) ☝️ ブランク・インポートが必要 アプリケーションのコードの中でドライバーが提供する関数を直接参照しない場合は、上記のようにアンダースコアを使ったブランク・インポートを行い、go mod tidy 時にこの行が削除されないようにしておく必要があります。 インポート行が削除されてしまうと、database/sql パッケージがドライバーを見つけられれず、unknown driver \u0026quot;sqlite3\u0026quot; (forgotten import?) といったエラーが発生します。 データベースへの接続 (sql.Open, DB.Ping) データベースに接続（ドライバーをオープン）するには、sql.Open 関数 を使用します。 func Open(driverName, dataSourceName string) (*sql.DB, error) 第 1 引数には使用するドライバーの名前（例: mysql、sqlite3）、第 2 引数にはドライバーごとの接続文字列 (DSN: data source name) を指定します。 SQLite3 の場合は、接続文字列はデータベースファイル名なので、とてもシンプルです。 db, err := sql.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;./books.db\u0026#34;) sql.Open() が返す *sql.DB インスタンスを使って、データベースの各種操作を行うことになります。 package main import ( \u0026#34;database/sql\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; ) func main() { // データベースをオープン db, err := sql.Open(\u0026#34;sqlite3\u0026#34;, \u0026#34;./books.db\u0026#34;) if err != nil { log.Fatal(err) } defer db.Close() // ... データベースを操作 ... } SQLite の場合は接続文字列はシンプル（ファイル名のみ）ですが、MySQL や Postgres などでは複雑な接続文字列を指定する必要があります。 そのため、データベースドライバーによっては、接続文字列を構築するためのユーティリティ関数が提供されていることがあります。 MySQL 用の接続文字列を構築する // Specify connection properties. cfg := mysql.Config{ User: os.Getenv(\u0026#34;DB_USER\u0026#34;), Passwd: os.Getenv(\u0026#34;DB_PASS\u0026#34;), Net: \u0026#34;tcp\u0026#34;, Addr: \u0026#34;127.0.0.1:3306\u0026#34;, DBName: \u0026#34;sample\u0026#34;, } // Get a database handle. db, err = sql.Open(\u0026#34;mysql\u0026#34;, cfg.FormatDSN()) データベースのオープンに成功したら、(*sql.DB) Ping メソッドを実行することで、実際にデーターベースが操作可能な状態になっているかを確認できます（実際のアプリで Ping メソッドを呼び出す必要はありません）。 func checkIfDatabaseIsReady(db *sql.DB) { if err := db.Ping(); err != nil { log.Fatal(err) } log.Println(\u0026#34;Database is ready\u0026#34;) } CRUD 操作 (DB.Query, DB.Exec) データベースからレコードを取得するには (*sql.DB) Query 系メソッド、その他の更新操作には (*sql.DB) Exec 系メソッドを使用します。 レコードの取得 (SELECT) func (db *DB) Query(query string, args ...any) (*Rows, error) func (db *DB) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error) func (db *DB) QueryRow(query string, args ...any) *Row func (db *DB) QueryRowContext(ctx context.Context, query string, args ...any) *Row 更新操作 (CREATE TABLE, ALTER TABLE, DROP TABLE, INSERT, UDPATE, DELETE) func (db *DB) Exec(query string, args ...any) (Result, error) func (db *DB) ExecContext(ctx context.Context, query string, args ...any) (Result, error) CREATE TABLE 次の例では、簡単な books テーブルを作成しています。 更新操作なので、(*sql.DB) Exec / (*sql.DB) ExecContext メソッドを使用します。 func createBooksTable(db *sql.DB) { _, err := db.Exec(`CREATE TABLE IF NOT EXISTS books( id TEXT PRIMARY KEY NOT NULL, title TEXT NOT NULL, price INTEGER NOT NULL)`) if err != nil { log.Fatal(err) } } INSERT テーブルにレコードを追加するときも、(*sql.DB) Exec / (*sql.DB) ExecContext メソッドを使用します。 func insertSampleRecord(db *sql.DB) { // INSERT の実行 query := `INSERT INTO books (id, title, price) VALUES (?, ?, ?)` result, err := db.Exec(query, \u0026#34;id-1\u0026#34;, \u0026#34;Title 1\u0026#34;, 1000) if err != nil { log.Fatal(err) } // 挿入されたレコード数を取得 count, err := result.RowsAffected() if err != nil { log.Fatal(err) } log.Printf(\u0026#34;%d rows inserted\u0026#34;, count) } 同様のクエリで複数のレコードを登録する場合は、(*sql.DB) Prepare メソッドで、Prepared statement (sql.Stmt) を生成すると便利です。 func insertSampleRecords(db *sql.DB) { // Prepared statement を作成する stmt, err := db.Prepare(\u0026#34;INSERT INTO books (id, title, price) VALUES (?, ?, ?)\u0026#34;) if err != nil { log.Fatal(err) } defer stmt.Close() // 複数のレコードを追加する for i := 1; i \u0026lt;= 3; i++ { id := fmt.Sprintf(\u0026#34;id-%d\u0026#34;, i) title := fmt.Sprintf(\u0026#34;Title %d\u0026#34;, i) price := 1000 * i _, err := stmt.Exec(id, title, price) if err != nil { log.Fatal(err) } } } SELECT SELECT でレコードを取得するときは、(*sql.DB) Query / (*sql.DB) QueryContext メソッドを使用します。 戻り値の *sql.Rows で取得したレコードを参照できます。 func queryBooks(db *sql.DB) { // クエリ実行 rows, err := db.Query(\u0026#34;SELECT id, title, price FROM books\u0026#34;) if err != nil { log.Fatal(err) } defer rows.Close() // レコードを 1 件ずつ取り出す for rows.Next() { var id string var title string var price int64 if err := rows.Scan(\u0026amp;id, \u0026amp;title, \u0026amp;price); err != nil { log.Fatal(err) } log.Printf(\u0026#34;%s, %s, %d\\n\u0026#34;, id, title, price) } if err := rows.Err(); err != nil { log.Fatal(err) } } 取得するレコードが 1 件だけだとわかっている場合は、効率のよい (*sql.DB) QueryRow / (*sql.DB) QueryRowContext メソッドを使用します。 これらのメソッドは、1 件のレコードを参照するための *sql.Row を返します。 このメソッドは必ず成功し、エラーが発生することはありません（Scan 時のエラーを確認するだけで十分だからです）。 func queryBook(db *sql.DB) { bookId := \u0026#34;id-1\u0026#34; row := db.QueryRow(\u0026#34;SELECT title, price FROM books WHERE id = ?\u0026#34;, bookId) var title string var price int64 if err := row.Scan(\u0026amp;title, \u0026amp;price); err != nil { if err == sql.ErrNoRows { log.Fatalf(\u0026#34;Book not found (id=%s)\\n\u0026#34;, bookId) } log.Fatal(err) } log.Printf(\u0026#34;%s, %d\u0026#34;, title, price) } WHERE 条件に一致するレコードが複数ある場合は、(*sql.DB) QueryRow メソッドは最初のレコードのみを返します。 条件に一致するレコードが見つからない場合は、(*sql.Row) Scan を呼び出したときに sql.ErrNoRows が返されます。 トランザクション処理 (DB.BeginTx) データベースのトランザクションは、複数の更新要求をアトミックに処理するための仕組みです。 複数の更新処理を一括でコミットするか、すべてなかったことにすることができます（ロールバック）。 (*sql.DB) BeginTx メソッドを使うとトランザクション処理を実行するための *sqlTx インスタンスを取得できます。 func (*sql.DB).BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) レコードの更新を行うときに、(*sql.DB) Exec の代わりに (*sql.Tx) Exec を呼び出すことで、その更新処理は 1 つのトランザクション内での処理とみなされます。 func updateRecordsWithTransaction(db *sql.DB) error { tx, err := db.BeginTx(context.Background(), nil) if err != nil { return err } defer tx.Rollback() // コミットしなかった場合は自動でロールバック // 関連する更新処理をトランザクション内で実行する if _, err := tx.Exec(\u0026#34;...省略...\u0026#34;); err != nil { return err } if _, err := tx.Exec(\u0026#34;...省略...\u0026#34;); err != nil { return err } // トランザクション処理をコミット if err := tx.Commit(); err != nil { return err } return nil } 一連の処理が終わったあとに、(*sql.Tx) Commit メソッドか、(*sql.Tx) Rollback メソッドを呼び出す必要があります。 上記のようにトランザクション開始直後に Rollback を defer 呼び出ししておけば、関数内で Commit が呼ばれなかったときに自動でロールバックしてくれます（Commit が呼ばれた場合は、Rollback は実行されません）。 NULL 値を含むレコードを扱う テーブルスキーマで NOT NULL 宣言されていないカラムには、NULL 値が格納されている可能性があります。 NULL 値を含むレコードを Scan するときに、バッファーとして string や int64 などのプリミティブな変数を使用するとエラーが発生します。 Scan error on column index 2, name \u0026ldquo;price\u0026rdquo;: converting NULL to int64 is unsupported NULL 値を含む可能性があるレコードを Scan する場合は、次のような NULL 値を扱える専用の型を使用します。 sql.NullBool sql.NullFloat64 sql.NullInt32 sql.NullInt64 sql.NullString sql.NullTime これらの型は、値が NULL でないことを調べるための Valid プロパティを持っています。 Valid が true の場合は、各カラムの値を安全に参照できます。 func queryBook(db *sql.DB) error { id := \u0026#34;id-1\u0026#34; row := db.QueryRow(\u0026#34;SELECT title, price FROM books WHERE id = ?\u0026#34;, id) // NULL 値を考慮した Scan var title sql.NullString var price sql.NullInt64 if err := row.Scan(\u0026amp;title, \u0026amp;price); err != nil { return err } // Nullable な title カラムを参照する if title.Valid { log.Printf(\u0026#34;title = %s\\n\u0026#34;, title.String) } else { log.Println(\u0026#34;title is NULL\u0026#34;) } // Nullable な price カラムを参照する if price.Valid { log.Printf(\u0026#34;price = %d\\n\u0026#34;, price.Int64) } else { log.Println(\u0026#34;price is NULL\u0026#34;) } return nil }"},{url:"/p/hxyiu7g/",title:"Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf)",date:"2022-09-12T00:00:00Z",body:"Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf) 何をするか？ 会社用と個人用の GitHub ユーザーを使い分けている場合、リポジトリへのコミット時に正しいユーザーでコミットログを残すように注意しなければいけません。 多くのリポジトリを扱っている人は、次のような感じで GitHub organization ごとにディレクトリを分けて管理するなどの工夫をしていると思います（リポジトリ名だけだと重複するので）。 ~/gitwork/ +-- company/ ... 会社用のリポジトリ（会社用のユーザー Rei Ayanami を使いたい） | +-- repo1/ | +-- repo2/ | +-- repo3/ +-- maku77/ ... 個人用のリポジトリ（個人用のユーザー maku77 を使いたい） +-- repo4/ +-- repo5/ +-- repo6/ company は自分の会社で使っている GitHub organization 名、maku77 は自分の GitHub アカウント名だと考えてください。 ここでは、上記のようにディレクトリを階層化してリポジトリを管理しているときに、ディレクトリ単位で自動的に Git クライアントの設定を切り替える方法を示します。 具体的には、company ディレクトリ以下のリポジトリで作業しているときは、会社用の Git ユーザー名とメールアドレスを使い、maku77 ディレクトリ以下のリポジトリで作業しているときは、個人用のユーザー名とメールアドレスを使うようにします。 リポジトリごとに local 設定 (.git/config) をするのもよいのですが、扱うリポジトリが増えてくるといちいち設定するのが大変なので、親ディレクトリの company、maku77 単位でまるっと設定を入れ替えます。 参考: Git 設定のスコープ (local/global/system) を理解する 設定ファイルの自動切換え（includeIf ディレクティブ） Git クライアントの設定ファイル（~/.gitconfig など）には、もともと別の設定ファイルをインクルードする機能 (include ディレクティブ）があるのですが、Conditional includes（条件付きインクルード） の仕組みを使うと、指定した条件に一致したときのみ設定ファイルをインクルードすることができます。 この仕組みを利用して、次のような条件付きインクルードを行えば、Git のユーザー設定をディレクトリごとに自動で切り替えることができます。 ~/gitwork/company 以下のリポジトリであれば、~/.gitconfig-company をインクルードする ~/gitwork/maku77 以下のリポジトリであれば、~/.gitconfig-maku77 をインクルードする 条件付きインクルードを行うには、includeIf ディレクティブを使用します。 ここでは、ユーザー単位の global 設定でこの設定を行います。 ~/.gitconfig ファイルを開いて次のような感じで記述します（Windows では git config --edit --global コマンドで開いた方が安全かもしれません）。 ~/.gitconfig [includeIf \u0026#34;gitdir:~/gitwork/company/\u0026#34;] path = ~/.gitconfig-company [includeIf \u0026#34;gitdir:~/gitwork/maku77/\u0026#34;] path = ~/.gitconfig-maku77 ☝️ コマンドで設定する方法 ~/.gitconfig ファイルを直接編集せずに、次のようにコマンドラインから設定することもできます（たぶんファイルを直接編集した方が楽です）。 $ git config --global includeIf.\u0026#34;gitdir:~/gitwork/company/\u0026#34;.path \u0026#34;.gitconfig-company\u0026#34; $ git config --global includeIf.\u0026#34;gitdir:~/gitwork/maku77/\u0026#34;.path \u0026#34;.gitconfig-maku77\u0026#34; あとは、上記のファイルからインクルードしているファイルを次のような感じで作成します。 ~/.gitconfig-company [user] name = Rei Ayanami email = 会社用のメールアドレス ~/.gitconfig-maku77 [user] name = maku77 email = 個人用のメールアドレス これで設定は完了です。 対象リポジトリのディレクトリへ移動して、それぞれの設定ファイルの内容が反映されているかを確認しておきます。 $ cd ~/gitwork/company/repo1 $ git config --show-origin user.name file:C:/Users/maku/.gitconfig-company Rei Ayanami $ cd ~/gitwork/maku77/repo4 $ git config --show-origin user.name file:C:/Users/maku/.gitconfig-maku77 maku77 includeIf ディレクティブは、Git リポジトリとして初期化された（.git がある）ディレクトリ以下でのみ有効なことに注意してください。 今回の例でいうと、~/gitwork/company 直下で作業しているときは有効ではなく、~/gitwork/company/repo1 の下で作業しているときに有効になります。 （応用）デフォルト設定とオーバーライド ほとんどのリポジトリで使う設定を ~/.gitconfig に記述しておき、特定のリポジトリ用の設定だけを includeIf ディレクティブでインクルードするという方法もあります。 つまり、通常はデフォルト設定 (~/.gitconfig) を使い、必要に応じて設定をオーバーライド (~/.gitconfig-xxx) する方法です。 ~/.gitconfig（ほとんどのケースで使うデフォルト設定） [user] name = Rei Ayanami email = rei.ayanami@example.com [includeIf \u0026#34;gitdir:~/gitwork/maku77/\u0026#34;] path = ~/.gitconfig-maku77 ~/.gitconfig-maku77（個人用の設定） [user] name = maku77 email = maku77@example.com 参考 Git 設定のスコープ (local/global/system) を理解する Git の設定値がどのファイルで設定されているか調べる (config \u0026ndash;show-origin)"},{url:"/p/o8vbo2f/",title:"Golang でコマンドライン引数を扱う (os.Args, flags)",date:"2022-09-09T00:00:00Z",body:"Golang でコマンドライン引数を扱う (os.Args, flags) Golang でコマンドライン引数を扱うには、標準パッケージの os や flags を使用します。 os.Args \u0026hellip; 単純に文字列配列で参照する場合 flags パッケージ \u0026hellip; -key value スタイルのオプションを扱う場合 文字列配列でコマンドライン引数を参照する (os.Args) os.Args という文字列配列を参照すると、コマンド実行時に指定したファイル名と、コマンドライン引数を取得することができます。 次のサンプルコードでは、この配列のサイズと、各要素を出力しています。 main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { fmt.Printf(\u0026#34;Length = %d\\n\u0026#34;, len(os.Args)) for i, arg := range os.Args { fmt.Printf(\u0026#34;[%d] %s\\n\u0026#34;, i, arg) } } 実行例 $ go build -o hello.exe # ビルド $ hello AAA BBB \u0026#34;CCC DDD\u0026#34; Length = 4 [0] hello [1] AAA [2] BBB [3] CCC DDD 上記の \u0026quot;CCC DDD\u0026quot; のように、コマンドライン引数をダブルクォート (\u0026quot;) で囲むことで、1 つの引数として扱われます。 ちなみに、os.Args[0] に入る実行ファイルの名前は、コマンドラインで指定した通りの文字列になることに注意してください。 次のように呼び出し方を変えると、os.Args[0] の内容も変わります。 $ hello → hello $ ./hello → ./hello $ hello.exe → hello.exe $ .\\myapp\\hello.exe → .\\myapp\\hello.exe 実行ファイルの名前をフルパスで取得したいときは、os.Executable 関数 を使用できます。 オプション引数をパースする（flag パッケージ） flag パッケージの基本 Golang 標準の flag パッケージ を使用すると、次のような形式のオプション引数を扱うことができます。 -x -x 100 -aaa --aaa -aaa 100 -aaa=100 --aaa 100 --aaa=100 flag パッケージでは、次のような関数でオプションの定義と、値の取得を同時に行います。 オプションの型 (string, int, bool) によって関数が分かれています。 // 指定された値を戻り値で取得するバージョン func String(name string, value string, usage string) *string func Int(name string, value int, usage string) *int func Float64(name string, value float64, usage string) *float64 func Bool(name string, value bool, usage string) *bool // 第 1 引数に渡した変数に値を取得するバージョン func StringVar(p *string, name string, value string, usage string) func IntVar(p *int, name string, value int, usage string) func Float64Var(p *float64, name string, value float64, usage string) func BoolVar(p *bool, name string, value bool, usage string) 例えば、user という名前の文字列型のオプションを定義するには次のようにします。 2 番目のパラメーター (value) はデフォルト値で、3 番目のパラメーター (usage) はヘルプテキストです。 func main() { user := flag.String(\u0026#34;user\u0026#34;, \u0026#34;UNKNOWN\u0026#34;, \u0026#34;user name\u0026#34;) // *string flag.Parse() fmt.Println(*user) } ユーザーが入力した値は、関数の戻り値として取得できるのですが、実際に入力値がパースされるのは flag.Parse 関数を呼び出したときだということに注意してください。 flag.String 関数の戻り値がポインタ型になっているのは、このように後から値が設定されるためです。 flag.Parse 関数を呼び出す前に flag.Bool 関数の戻り値を参照すると、必ずデフォルト値（上記例では UNKNOWN）になってしまうので注意してください。 下記は、アプリケーションを myapp という名前でビルドして、いろいろな形でオプション指定した場合の結果です。 $ myapp UNKNOWN $ myapp --user maku maku $ myapp --user=hoge hoge flag パッケージを使うと、ヘルプメッセージを表示するための -h や --help オプションも暗黙的に定義されます。 $ myapp -h Usage of myapp: -user string user name (default \u0026#34;UNKNOWN\u0026#34;) 各オプションの使い方を間違えた場合は、そのオプションに関するヘルプメッセージを表示してくれます。 $ myapp --user flag needs an argument: -user Usage of myapp: -user string user name (default \u0026#34;UNKNOWN\u0026#34;) int 型のオプション (flag.Int) と bool 型のオプション (flag.Bool) は、次のような入力値が正しい値だと判断されます。 flag.Int() \u0026hellip; 1234, 0664, 0x1234, -1 flag.Bool() \u0026hellip; 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False 変数にオプション値を取得するバージョン 末尾に Var の付く次のようなバージョンの関数を使うと、第 1 引数で指定した変数にオプション値を取得することができます。 func StringVar(p *string, name string, value string, usage string) func IntVar(p *int, name string, value int, usage string) func Float64Var(p *float64, name string, value float64, usage string) func BoolVar(p *bool, name string, value bool, usage string) 次の例では、options 構造体の各フィールドに様々な型のオプション値を格納しています。 main.go package main import ( \u0026#34;flag\u0026#34; \u0026#34;fmt\u0026#34; ) var options struct { isDark bool targetEnv string retryCount int } func parseOptions() { flag.BoolVar(\u0026amp;options.isDark, \u0026#34;dark\u0026#34;, false, \u0026#34;enables dark mode\u0026#34;) flag.StringVar(\u0026amp;options.targetEnv, \u0026#34;env\u0026#34;, \u0026#34;development\u0026#34;, \u0026#34;target environment\u0026#34;) flag.IntVar(\u0026amp;options.retryCount, \u0026#34;retry\u0026#34;, 0, \u0026#34;how many times to retry\u0026#34;) } func main() { parseOptions() fmt.Printf(\u0026#34;%+v\\n\u0026#34;, options) } 実行例 $ myapp {isDark:false targetEnv:development retryCount:0} $ myapp --dark --env production --retry 100 {isDark:true targetEnv:production retryCount:100} $ myapp -h Usage of myapp: -dark enables dark mode -env string target environment (default \u0026#34;development\u0026#34;) -retry int how many times to retry オプション名のエイリアス オプション名としてロングバージョンとショートバージョンを設定したい場合（例: --port と -p）、flag.IntVar や flag.StringVar 関数を同じ変数に対して繰り返し適用します。 var options struct { port int } func parseOptions() { const ( defaultPort = 1234 portUsage = \u0026#34;port number\u0026#34; ) flag.IntVar(\u0026amp;options.port, \u0026#34;port\u0026#34;, defaultPort, portUsage) flag.IntVar(\u0026amp;options.port, \u0026#34;p\u0026#34;, defaultPort, portUsage+\u0026#34; (shorthand)\u0026#34;) flag.Parse() } ヘルプ表示は次のように分かれて表示されてしまうみたいですが、そこは目をつぶります。 $ myapp --help Usage of myapp: -p int port number (shorthand) (default 1234) -port int port number (default 1234)"},{url:"/p/dsbs9p5/",title:"Golang で JSON 形式の文字列やファイルを扱う (encoding/json)",date:"2022-09-04T00:00:00Z",body:"Golang で JSON 形式の文字列やファイルを扱う (encoding/json) Golang 標準パッケージの encoding/json を使用すると、Golang のオブジェクトと JSON テキストを相互に変換することができます。 import \u0026#34;encoding/json\u0026#34; Go と JSON の型を変換するとき、次のように対応付けられます（Channel など、一部扱えないデータはあります）。 Go の型 JSON の型 bool boolean float64 number string string []interface{} 配列 map[string]interface{} オブジェクト nil null デフォルトでは、Go の構造体のフィールド名がそのまま JSON のプロパティ名になりますが、構造体フィールドのタグで JSON のプロパティ名を指定する ことができます。 構造体のフィールドがポインタ型である場合は、ポインタが指す実際の値を使って JSON データに変換してくれます。 JSON のプロパティ名を指定する Golang の構造体は、各フィールドにタグという情報を追加 できるようになっています。 encoding/json パッケージは、構造体の json タグを読み取って、JSON データに変換したときのプロパティ名として使用するようになっています。 type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } 上記ように json タグ設定した構造体を、encoding/json パッケージの各種メソッドで JSON に変換すると、次のような感じの JSON データになります。 json タグで指定した通り、プロパティ名がすべて小文字になっていることが分かります。 {\u0026#34;name\u0026#34;:\u0026#34;まく\u0026#34;,\u0026#34;age\u0026#34;:14} さらに、json タグでは次のようなオプション指定もできるようになっています（omitempty や - の部分）。 type Book struct { Title string `json:\u0026#34;title\u0026#34;` // ベーシックな使い方 Price int `json:\u0026#34;price,omitempty\u0026#34;` // ゼロ値の場合はこのフィールドを出力しない Author string `json:\u0026#34;-\u0026#34;` // このフィールドは出力しない } 参考: Golang の構造体にタグ情報を追加する (struct tags) Go オブジェクト → JSON 文字列 json.Marshal 関数を使用すると、任意の Go オブジェクト（構造体）を JSON 形式の文字列データに変換できます。 func json.Marshal(v any) ([]byte, error) 構造体の 公開されたフィールド（大文字で始まるもの）のみ が JSON 出力されます。 変換後のデータは、具体的には UTF-8 エンコーディング形式のバイト配列 ([]byte) です。 次の例では、Person 構造体のデータを JSON 文字列に変換しています。 type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { p := Person{\u0026#34;まく\u0026#34;, 14} bytes, err := json.Marshal(p) if err != nil { log.Fatal(err) } fmt.Println(string(bytes)) //=\u0026gt; {\u0026#34;name\u0026#34;:\u0026#34;まく\u0026#34;,\u0026#34;age\u0026#34;:14} } 改行やインデントを含む整形された JSON テキストが欲しい場合は、json.Marshal の代わりに json.MarshalIndent 関数を使用します。 bytes, err := json.MarshalIndent(p, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) JSON 文字列 → Go オブジェクト JSON 形式の文字列データ ([]byte) を Go のオブジェクトに変換するには、json.Unmarshal 関数を使用します。 func json.Unmarshal(data []byte, v any) error 次の例では、JSON 文字列を Person 構造体のデータに変換しています。 type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { jsonBytes := []byte(`{\u0026#34;name\u0026#34;:\u0026#34;まく\u0026#34;,\u0026#34;age\u0026#34;:14}`) var p Person if err := json.Unmarshal(jsonBytes, \u0026amp;p); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%+v\\n\u0026#34;, p) //=\u0026gt; {name:まく age:14} fmt.Println(p.Name) //=\u0026gt; まく fmt.Println(p.Age) //=\u0026gt; 14 } Go オブジェクト → JSON ファイル Go の構造体を JSON ファイルに出力するには、os.File オブジェクトを json.NewEncoder に渡して Encoder を作成し、(*json.Encoder).Encode メソッドでデータを書き込みます。 func json.NewEncoder(w io.Writer) *json.Encoder func (*json.Encoder).Encode(v any) error 次の例では、Person 構造体の内容を person.json ファイルに出力しています。 main.go package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { // 書き込むデータ p := Person{\u0026#34;まく\u0026#34;, 14} // JSON ファイルを新規作成（既に存在する場合は上書き） file, err := os.Create(\u0026#34;person.json\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // JSON ファイルに書き込み encoder := json.NewEncoder(file) if err := encoder.Encode(p); err != nil { log.Fatal(err) } } 出力結果 (person.json) {\u0026#34;name\u0026#34;:\u0026#34;まく\u0026#34;,\u0026#34;age\u0026#34;:14} 改行やインデントを含む整形された JSON ファイルとして出力したい場合は、Encode メソッドで出力する前に、SetIndent メソッドでインデントの設定を行います。 encoder := json.NewEncoder(file) encoder.SetIndent(\u0026#34;\u0026#34;, \u0026#34; \u0026#34;) // スペース 2 文字をインデントに使う 出力結果 (person.json) { \u0026#34;name\u0026#34;: \u0026#34;まく\u0026#34;, \u0026#34;age\u0026#34;: 14 } 参考: Golang でファイルを読み書きする (os, io) JSON ファイル → Go オブジェクト JSON ファイルを読み込んで、Go のオブジェクトに変換するには、os.File オブジェクトを json.NewDecoder に渡して Decoder を作成し、(*json.Decoder).Decode メソッドで Go の変数へデータを展開します。 func json.NewDecoder(r io.Reader) *json.Decoder func (*json.Decoder).Decode(v any) error JSON のスキーマが完全に分かっている場合 次の例では、person.json ファイルの内容を Person 構造体に変換しています。 person.json（入力ファイル） { \u0026#34;name\u0026#34;: \u0026#34;まく\u0026#34;, \u0026#34;age\u0026#34;: 14 } main.go package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) type Person struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { // JSON ファイルを読み出し用にオープン file, err := os.Open(\u0026#34;person.json\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // JSON ファイルの内容を Person 構造体データとして読み出す var p Person decoder := json.NewDecoder(file) if err := decoder.Decode(\u0026amp;p); err != nil { log.Fatal(err) } log.Printf(\u0026#34;%+v\\n\u0026#34;, p) //=\u0026gt; {name:まく age:14} } JSON のスキーマが不明な場合 具体的な構造体の型を設定せずに、map[string]any 型の変数に JSON ファイルの内容を読み出すこともできます。 これは、キーの型が文字列で、値の型が不明 (any / interface{}) なマップです。 この場合、少なくとも JSON ルート階層のフィールドはキー名で参照できますが、その値は any 型になるので、実際に値を扱う段階で型アサーションにより具体的な型を指定する必要があります。 あるいは、リフレクションで各フィールドの情報を列挙することが可能です。 // JSON ファイルの内容を map 型の Go オブジェクトとして読み出す var rawJson map[string]any decoder := json.NewDecoder(file) if err := decoder.Decode(\u0026amp;rawJson); err != nil { log.Fatal(err) } // ルート階層のフィールドを参照する（値は any 型なので型アサーションして使う） name := rawJson[\u0026#34;name\u0026#34;].(string) age := rawJson[\u0026#34;age\u0026#34;].(float64) fmt.Println(name) fmt.Println(age) // リフレクションで内容を調べても OK refVal := reflect.ValueOf(rawJson) for it := refVal.MapRange(); it.Next(); { fmt.Printf(\u0026#34;key = %s\\n\u0026#34;, it.Key()) } 参考: Golang でファイルを読み書きする (os, io)"},{url:"/p/hxhzfbs/",title:"Golang の構造体にタグ情報を追加する (struct tags)",date:"2022-09-03T00:00:00Z",body:"Golang の構造体にタグ情報を追加する (struct tags) 構造体タグ (struct tags) の基本 Go 言語の構造体 (struct) では、各フィールドの末尾に、タグ (struct tags) と呼ばれるメタ情報を付加することができます。 JSON データを扱うプログラムの構造体で、`json:\u0026quot;id\u0026quot;` のような記述があるのを見かけたことがあるかもしれません。 下記の例は、タグを追加した Book 構造体の例です。 type Book struct { Title string `label:\u0026#34;タイトル\u0026#34;` Price int `label:\u0026#34;価格\u0026#34;` } 各タグは、タグ名:\u0026quot;タグ値\u0026quot; というフォーマットの文字列リテラルで設定します。 コロン (:) の前後にスペースを入れてはいけません。 Golang の言語仕様 (Struct types) では、任意の文字列リテラルを配置できると記述されていますが、VS Code などの Lint 系プラグインでは、上記のようなフォーマットで記述していないと警告が出たりするので、このフォーマットで記述しておくのが無難です。 通常はダブルクォート (\u0026quot;) のエスケープをしなくて済むように、バッククォート (`) で囲んだ Raw string literals（生文字列リテラル） を使います。 構造体タグを参照する 構造体の各フィールドに付加したタグを参照するには、reflect パッケージを使ったリフレクションを利用します。 次の例では、各フィールドの label タグの値を出力しています。 main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Book struct { Title string `label:\u0026#34;タイトル\u0026#34;` Price int `label:\u0026#34;価格\u0026#34;` } func main() { book := Book{Title: \u0026#34;Golang入門\u0026#34;, Price: 2000} // リフレクションで構造体の各フィールドをループ処理 t := reflect.TypeOf(book) for i := 0; i \u0026lt; t.NumField(); i++ { fieldName := t.Field(i).Name tag := t.Field(i).Tag fmt.Printf(\u0026#34;%s フィールドの label タグの値は「%s」だよ\\n\u0026#34;, fieldName, tag.Get(\u0026#34;label\u0026#34;)) } } 実行結果 $ go run main.go Title フィールドの label タグの値は「タイトル」だよ Price フィールドの label タグの値は「価格」だよ 上記の例では、タグ値の取得に tag.Get メソッドを使用していますが、設定されていないタグ名を指定すると、戻り値は空文字列 (\u0026quot;\u0026quot;) になります。 tag.Get の代わりに tag.Lookup メソッドを使用すると、タグの有無を判別することができます。 タグ値として空文字列を設定することに意味を持たせたい場合はこちらを使用します。 if label, ok := tag.Lookup(\u0026#34;label\u0026#34;); ok { fmt.Printf(\u0026#34;%s フィールドの label タグの値は「%s」だよ\\n\u0026#34;, fieldName, label) } else { fmt.Printf(\u0026#34;%s フィールドに label タグはないよ\\n\u0026#34;, fieldName) } 複数のタグ情報を設定する 1 つのフィールドに複数のタグ情報を設定したいときは、タグ名:\u0026quot;値\u0026quot; をスペースで区切って並べます。 type Book struct { Title string `json:\u0026#34;title\u0026#34; label:\u0026#34;タイトル\u0026#34;` Price int `json:\u0026#34;price\u0026#34; label:\u0026#34;価格\u0026#34;` } 各タグの値を参照するには、前述の例のように tag.Get あるいは tag.Lookup メソッドを使用します。 jsonTag := reflect.TypeOf(book).Field(0).Tag.Get(\u0026#34;json\u0026#34;) labelTag := reflect.TypeOf(book).Field(0).Tag.Get(\u0026#34;label\u0026#34;) タグ値の解釈方法は自由 タグ値は文字列形式の値ですが、この文字列をどのように解釈するかは自由です。 例えば、Golang の encoding/json 標準パッケージは、json タグに指定した文字列を JSON のプロパティ名として使用しますが、カンマで区切ってオプション設定を行えるようになっています。 type Book struct { Title string `json:\u0026#34;title\u0026#34;` // ベーシックな使い方 Price int `json:\u0026#34;price,omitempty\u0026#34;` // ゼロ値の場合はこのフィールドを出力しない Author string `json:\u0026#34;-\u0026#34;` // このフィールドは出力しない } 参考: Golang で JSON 形式の文字列やファイルを扱う"},{url:"/p/v48adgi/",title:"Golang で GraphQL サーバーを作成する (gqlgen)",date:"2022-08-20T00:00:00Z",body:"Golang で GraphQL サーバーを作成する (gqlgen) Go 言語用の GraphQL ライブラリ gqlgen を使って、GraphQL サーバーを作ってみます。 gqlgen は、スキーマファーストの設計を採用しており、最初に GraphQL スキーマを定義し、それに合わせて各クエリ用のリゾルバーを実装していきます。 リゾルバーの雛形は、gqlgen generate というコマンドで生成できます。 Go プロジェクトを作成して gqlgen コマンドをインストールする Go プロジェクトの作成 まずは、Go のプロジェクトを Go Modules として作成します。 モジュール名は適当に example.com/myapp としておきます。 $ mkdir myapp \u0026amp;\u0026amp; cd myapp $ go mod init example.com/myapp これで、myapp ディレクトリ内に go.mod ファイルが生成されます。 gqlgen コマンドのインストール gqlgen コマンドは github.com/99designs/gqlgen という Go モジュールとして提供されています。 Go 言語の慣例として、プロジェクトのビルドに必要なツールのモジュール依存情報は、tools.go というファイルに記述すべしとされているので、次のような内容で作成しておきます（参考: How can I track tool dependencies for a module?）。 tools.go //go:build tools package tools import ( _ \u0026#34;github.com/99designs/gqlgen\u0026#34; ) go get コマンドを実行して、プロジェクトの go.mod に gqlgen コマンド用のモジュール依存情報を追加します。 指定可能なバージョンは gqlgen の Release ページ で確認してください。 $ go get github.com/99designs/gqlgen@latest # 最新バージョンを使う場合（go get . でも OK） $ go get github.com/99designs/gqlgen@v0.17.14 # バージョンを指定する場合 次のように gqlgen コマンドを実行できるようになれば OK です。 $ go run github.com/99designs/gqlgen version v0.17.14 ☝️ なぜ tools.go が必要？ tools.go ファイルがなくても、go get コマンドで gqlgen 関連の依存情報を追加することはできます。 ただ、go mod tidy コマンドで依存情報を整理すると、Go コードから参照されていないモジュールの依存情報は go.mod ファイルから削除されてしまうので、何らかの Go コードで gqlgen コマンド用のモジュールをインポートしておかなければいけません。 そのために使われるファイルが tools.go です。 さらに、このファイルの先頭に、//go:build tools という特殊なタグ (Build Constraints) を記述しておくことで、アプリ本体のビルド時には tools.go は無視してくれるようになります。 gqlgen プロジェクトのスケルトンを生成する (gqlgen init) gqlgen init コマンドを使用すると、gqlgen プロジェクトのスケルトンコードを生成することができます。 ここから先は、本家のチュートリアル 通りにコードを修正していきます。 $ go run github.com/99designs/gqlgen init Creating gqlgen.yml Creating graph/schema.graphqls Creating server.go Generating... Exec \u0026#34;go run ./server.go\u0026#34; to start GraphQL server この時点で、次のようなディレクトリ構成になっているはずです。 ★ が付いているのが gqlgen init で生成されたファイルです。 go.mod go.sum gqlgen.yml ★ gqlgen の設定ファイル graph/ ★ GraphQL スキーマやそのリゾルバー実装は基本的にここに入れる generated/ ★ gqlgen が自動生成するファイル群 generated.go ★ 触らない model/ ★ GraphQL クエリで取得するデータの型情報 models_gen.go ★ schema.graphqls に基づいて自動生成される（触らない） resolver.go ★ GraphQL サーバーが読み込むリゾルバー。自力で実装する schema.graphqls ★ GraphQL のスキーマファイル。ここから定義していく schema.resolvers.go ★ 上記スキーマ用のリゾルバー実装。resolver.go から参照する server.go ★ GraphQL サーバー本体（main パッケージの main 関数） tools.go 生成された GraphQL スキーマファイルを覗いてみると、どうやら TODO を管理する API のサンプルになっているようです。 ルートクエリとして todos、mutation 用に createTodo が定義されています。 graph/schema.graphqls type Todo { id: ID! text: String! done: Boolean! user: User! } type User { id: ID! name: String! } type Query { todos: [Todo!]! } input NewTodo { text: String! userId: String! } type Mutation { createTodo(input: NewTodo!): Todo! } ちなみに、GraphQL スキーマファイルは、拡張子が .graphqls であれば、複数のファイルに分割されていても大丈夫です（gqlgen.yml 設定ファイルで、schema: [graph/*.graphqls] のように指定されているからです）。 ここで GraphQL サーバーを起動してみたいところですが、悲しいことに、スケルトンとして生成されたファイルはチュートリアル用で不完全なので、以下のようにリゾルバーの実装を少し修正する必要があります（サーバーの起動自体はできますが、クエリ時に panic が発生します）。 GraphQL リゾルバーの実装 graph/resolver.go resolver.go は、GraphQL リゾルバーのルート定義的なファイルです。 GraphQL サーバーが利用する Resolver 構造体の型を定義しておきます。 package graph import \u0026#34;example.com/myapp/graph/model\u0026#34; type Resolver struct { todos []*model.Todo } Resolver は、model.Todo のスライス (todos) を保持しています。 この値は GraphQL サーバーが動作している間だけメモリ上に保持されます（いわゆるステートです）。 サーバー本体 (server.go) の実装を見てみると、サーバー生成時に、\u0026amp;graph.Resolver{} といった感じで上記の struct 値が生成されていることがわかります。 肝心のリゾルバー関数の定義が見当たりませんが、それらは graph/schema.resolvers.go という別ファイルで定義するようになっています。 Go 言語の仕様上、同じパッケージ内であればどのファイルで定義してもよいのですが、graph/schema.graphqls というスキーマファイル名に対応するリゾルバーファイル名になっているようです（このあたりのファイル構成は gqlgen のバージョンによって変わるかもしれません）。 graph/schema.resolvers.go mutation 操作用の CreateTodo 関数と、query 操作用の Todos 関数の実装が空っぽになっているので、次のような感じで実装します。 // createTodo mutation 用のリゾルバー func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) { todo := \u0026amp;model.Todo{ Text: input.Text, ID: fmt.Sprintf(\u0026#34;T%d\u0026#34;, rand.Int()), User: \u0026amp;model.User{ID: input.UserID, Name: \u0026#34;user \u0026#34; + input.UserID}, } r.todos = append(r.todos, todo) return todo, nil } // todos query 用のリゾルバー func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) { return r.todos, nil } やっていることは単純で、CreateTodo 関数で model.Todo オブジェクトを生成して Resolver の todos スライスに追加し、Todos 関数でそのスライスの内容を返すように実装しています。 todos スライスの値はメモリ上に保持されるので、GraphQL サーバーを起動してから createTodo mutation を呼び出し、続けて todos query を呼び出せば、その値を取得できるはずです。 ここまで実装できたら、次のように GraphQL サーバーを起動します。 $ go run server.go 2022/08/20 22:59:26 connect to http://localhost:8080/ for GraphQL playground Web ブラウザで http://localhost:8080/ を開くと、次のように GraphiQL が起動して、任意のクエリをテストできます。 図: GraphiQL の画面 初期状態では Resolver の todos スライスが空っぽなので、todos クエリをかけても何も返って来ません。 次のように createTodo mutation で TODO を追加してから、 mutation createTodo { createTodo(input: { text: \u0026#34;ゴミ捨て\u0026#34;, userId: \u0026#34;1\u0026#34; }) { id text done } } 続けて次のように todos クエリを実行すると、 query findTodos { todos { id text done user { name } } } 次のような結果 (JSON) が返って来ます。 { \u0026#34;data\u0026#34;: { \u0026#34;todos\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;T5577006791947779410\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;ゴミ捨て\u0026#34;, \u0026#34;done\u0026#34;: false, \u0026#34;user\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;user 1\u0026#34; } } ] } } これでチュートリアル的な GraphQL サーバーの実装は完成です。 上記の TODO 情報は、サーバーを起動している間のみ有効です。 GraphQL サーバーを CORS 対応する Web ブラウザ上で動作させる JavaScript（クライアントサイド JS）から、GraphQL サーバーにアクセスする場合、おそらく GraphQL サーバー側で CORS（クロスドメインアクセス）用の対応が必要になります。 rs/cors パッケージを使うと簡単に CORS 対応のための HTTP レスポンスを返すことができます。 rs/cors パッケージの依存を追加 $ go get github.com/rs/cors 具体的には、HTTP サーバーのミドルウェアとして、cors.Cors オブジェクトが提供するハンドラー実装を挟むようにします。 server.go（抜粋） // import \u0026#34;github.com/rs/cors\u0026#34; func main() { // ... srv := handler.NewDefaultServer(generated.NewExecutableSchema( generated.Config{Resolvers: \u0026amp;graph.Resolver{}} )) handler := cors.Default().Handler(srv) // ★CORS レスポンス対応 http.Handle(\u0026#34;/query\u0026#34;, handler) log.Fatal(http.ListenAndServe(\u0026#34;:\u0026#34;+port, nil)) } CORS 対策はあくまで HTTP サーバーに必要なものであって、GraphQL サーバーを実装しているかどうかは本質的には関係ないことに注意してください。 参考: Golang で HTTP サーバーを作成する (net/http, rs/cors) スキーマファイル更新時の作業 スキーマファイル (graph/schema.graphqls) を更新した場合は、次のコマンドを実行して、自動生成された各種 .go ファイルを更新する必要があります。 スキーマの更新を Go コードに反映 $ go run github.com/99designs/gqlgen generate 上記コマンド実行後は、主に下記のファイルを見直す必要があります。 graph/model/models_gen.go \u0026hellip; スキーマの各オブジェクト型に対応する Golang 構造体が想定通り生成されているかを確認します。 graph/schema.resolvers.go \u0026hellip; スキーマの Query 型や Mutation 型の各フィールドに対応するリゾルバー関数のひな形が追加されているはずなので、それらの関数の本体を実装します。 スキーマファイルの更新のたびに、上記のような長い go run コマンドをタイプするのは面倒なので、graph/resolver.go あたりに、次のように //go:generate ディレクティブを記述しておくと便利です。 graph/resolver.go package graph //go:generate go run github.com/99designs/gqlgen generate import \u0026#34;example.com/myapp/graph/model\u0026#34; type Resolver struct { todos []*model.Todo } すると、次のように実行するだけで、.go ファイルの更新を行えるようになります（//go:generate ディレクティブは、Golang 標準の仕組みです）。 $ go generate ./... GraphQL スキーマの型と Golang の型の対応 gqlgen が GraphQL スキーマから Golang のコード (graph/model/models_gen.go) を生成するときに、どのように型をマッピングするかのまとめです。 GraphQL 標準の型 GraphQL 標準のスカラー型は ID、String、Boolean、Int、Float の 5 種類です。 下記はそれらと Golang の型の対応です。 GraphQL の型 Golang (gqlgen) 意味 ID! string ユニークな ID ID *string ユニークな ID (nullable) String! string 文字列 String *string 文字列 (nullable) Boolean! bool 真偽値 Boolean *bool 真偽値 (nullable) Int! int 整数 Int *int 整数 (nullable) Float! float64 浮動小数点数 Float *float64 浮動小数点数 (nullable) [String!]! []string 文字列の配列 [String!] []string 文字列の配列 (nullable) [String]! []*string 文字列 (nullable) の配列 [String] []*string 文字列 (nullable) の配列 (nullable) Golang のスライス型（[]string など）は、nil になり得るので、GraphQL スキーマの [String!]! も [String!] も、Golang の型にしたときは同じ []string になります（もちろん、GraphQL サーバーとしては、nil と空スライス []string{} は別データとして扱います）。 gqlgen パッケージの変換実装は このあたり にあります。 カスタムスカラー型 次のようにスキーマ内でカスタムスカラーを定義すると、デフォルトで Golang の String 型にマッピングされます。 GraphQL スキーマ \u0026#34;\u0026#34;\u0026#34; The International Standard Book Number (ISBN) is a numeric commercial book identifier that is intended to be unique. \u0026#34;\u0026#34;\u0026#34; scalar ISBN フォーマットの決まった文字列（日時、メールアドレス、URL など）は、とりあえずカスタムスカラー型としてスキーマ定義しておくとよさそうです。 フォーマットの検証などをしたくなったら、カスタムスカラー型に MarshalGQL / UnmarshalGQL メソッドを追加することで対応できます（参考: Custom scalars with user defined types — gqlgen）。 Enum 型 下記は、リストのソート順序を示す列挙型のスキーマ定義例です。 GraphQL スキーマ \u0026#34;\u0026#34;\u0026#34; Specifies how items in a list are sorted. \u0026#34;\u0026#34;\u0026#34; enum SortOrder { \u0026#34;Unordered (arbitrary order)\u0026#34; NONE \u0026#34;Ascending order\u0026#34; ASC \u0026#34;Descending order\u0026#34; DESC } これを gqlgen で Golang の型に変換すると、次のような SortOrder (≒ String) 型、および、その定数群として出力されます。 Golang には列挙型 (enum) というものは存在しないのでこうなるのですが、SortOrder 型の型チェックが働くのでこれで十分なのです。 models_gen.go（自動生成された Go コード） // Specifies how items in a list are sorted. type SortOrder string const ( // Unordered (arbitrary order) SortOrderNone SortOrder = \u0026#34;NONE\u0026#34; // Ascending order SortOrderAsc SortOrder = \u0026#34;ASC\u0026#34; // Descending order SortOrderDesc SortOrder = \u0026#34;DESC\u0026#34; ) あと、次のようなマーシャリング用のメソッド (MarshalGQL / UnmarshalGQL) も出力されます。 func (e SortOrder) IsValid() bool { switch e { case SortOrderNone, SortOrderAsc, SortOrderDesc: return true } return false } func (e SortOrder) String() string { return string(e) } func (e *SortOrder) UnmarshalGQL(v interface{}) error { str, ok := v.(string) if !ok { return fmt.Errorf(\u0026#34;enums must be strings\u0026#34;) } *e = SortOrder(str) if !e.IsValid() { return fmt.Errorf(\u0026#34;%s is not a valid SortOrder\u0026#34;, str) } return nil } func (e SortOrder) MarshalGQL(w io.Writer) { fmt.Fprint(w, strconv.Quote(e.String())) } 参考リンク gqlgen で子フィールドの情報を返すリゾルバーを実装する"},{url:"/p/goruwy4/",title:"Golang で HTTP サーバーを作成する (net/http, rs/cors)",date:"2022-08-20T00:00:00Z",body:`Golang で HTTP サーバーを作成する (net/http, rs/cors) Hugo 標準ライブラリの net/http パッケージ (src) は、HTTP クライアント／サーバーを作成するためのパッケージです。 ここでは、この net/http パッケージを使って、簡単な Web サーバーを実装してみます。 最小限の HTTP サーバーを作る main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // ポート番号 8080 で待ち受けを開始 log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } これがおそらく Golang における最小の HTTP サーバー実装です。 http.ListenAndServe 関数 で、指定したアドレスとポート番号で待ち受けを開始しています。 ここではポート番号 8080 だけを指定しているため、localhost:8080 で待ち受けることになります。 ☝️ log.Fatal で囲んでいるのはなぜ？ http.ListenAndServe 関数はサーバーの起動に失敗すると error オブジェクトを返します。 log.Fatal 関数で囲んでいるのは、エラーが発生した場合にその内容を出力してから終了するためです。 例えば、サーバーを 2 回続けて起動しようとしたときに、ポート番号が使用中であることを表示してくれます。 逆にサーバーの起動に成功した場合は、http.ListenAndServe 関数は戻ってこないので、log.Fatal 関数が実行されることはありません。 サーバーを Ctrl + C で終了したときも、log.Fatal 関数は実行されません。 このイディオムは、net/http パッケージのドキュメントでも使われています。 go run main.go でプログラムを起動してから、Web ブラウザで http://localhost:8080/ にアクセスするとレスポンスを確認できます。 ただし、まだ何もコンテンツを返していないので、404 page not found エラーが返ってきます。 サーバーを停止するときは、Ctrl + C と入力します。 ハンドラー関数を登録する (http.HandleFunc) Web サーバーがコンテンツを返すようにするには、リクエスト時の URL とレスポンスの内容を対応づける必要があります。 ここでは、次のようにコンテンツを返すようにしてみます。 http://localhost:8080/foo/ へのアクセス → Hello-1 というレスポンスを返す http://localhost:8080/bar/ へのアクセス → Hello-2 というレスポンスを返す 次のサンプルコードでは、特定のパスにアクセスされたときに呼び出されるハンドラー関数を設定しています。 main.go（全体のコード） package main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // ハンドラー関数を定義する handler1 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \u0026#34;Hello-1\\n\u0026#34;) } handler2 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \u0026#34;Hello-2\\n\u0026#34;) } // パスとハンドラー関数を結びつける http.HandleFunc(\u0026#34;/foo/\u0026#34;, handler1) http.HandleFunc(\u0026#34;/bar/\u0026#34;, handler2) // Web サーバーを起動する log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } HTTP リクエストを処理するハンドラー関数は、次のようなシグネチャの関数として実装します。 http.ResponseWriter と *http.Request を受け取る関数です。 type HandlerFunc func(ResponseWriter, *Request) 今回は次のようなハンドラー関数を定義しています。 レスポンスの内容（テキスト）を http.ResponseWriter に書き込むときには、io.WriteString や fmt.Fprint、fmt.Fprintf などを使用できます（これは、http.ResponseWriter が io.Writer インタフェースを実装しており、それを受け取る関数に渡せるようになっているからです）。 2 番目のパラメーター (*http.Request) は参照していないので、変数名を _ にしています。 handler1 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \u0026#34;Hello-1\\n\u0026#34;) // fmt.Fprint(w, \u0026#34;Hello-1\\n\u0026#34;) } handler2 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \u0026#34;Hello-2\\n\u0026#34;) // fmt.Fprint(w, \u0026#34;Hello-2\\n\u0026#34;) } HTTP リクエストを受信したときにこれらのハンドラー関数が呼び出されるようにするには、http.HandleFunc 関数 を使用します。 http.HandleFunc(\u0026#34;/foo/\u0026#34;, handler1) http.HandleFunc(\u0026#34;/bar/\u0026#34;, handler2) 任意のオブジェクトをハンドラーとして登録する (http.Handle) 前述の例では、http.HandleFunc 関数でハンドラー関数を登録しましたが、代わりに http.Handle 関数 を使うと、任意のオブジェクトをハンドラーとして登録することができます。 このオブジェクトは Web サーバーの起動中は破棄されないので、ステート（状態）を持ったハンドラーとして使用できます。 ハンドラーとなる型は、次のようなシグネチャのメソッドを持っている必要があります（http.Handler インタフェースとして定義されています）。 実装方法は、前述のハンドラー関数と同様です。 ServeHTTP(w http.ResponseWriter, r *http.Request) 次の countHandler は、呼び出されるたびに自身の count フィールドをインクリメントし、その値をレスポンスとして返します。 handler.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; ) // カウンターを持つ HTTP リクエストハンドラー type countHandler struct { mutex sync.Mutex // guards count count int } func (h *countHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { h.mutex.Lock() defer h.mutex.Unlock() h.count++ fmt.Fprintf(w, \u0026#34;Count: %d\\n\u0026#34;, h.count) } このハンドラーを登録するには、次のようにします。 main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.Handle(\u0026#34;/count\u0026#34;, new(countHandler)) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } http://localhost:8080/count/ にアクセスして、次のようなレスポンスが返って来れば成功です。 Count の値はブラウザをリロードするたびに 1 つずつ増えていきます。 Count: 1 ハンドラーはどこに登録されているのか？ これまでのサンプルコードでは、ハンドラーを登録するときに、http.HandleFunc 関数や http.Handle 関数を使ってきましたが、これらは単なる関数です。 これらに渡したハンドラー関数やハンドラーオブジェクトが、どのように Web サーバーと結び付けられているのか疑問に感じたかもしれません。 その謎は、net/http パッケージのコードを覗いてみると分かります。 net/http/server.go（抜粋） func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) } func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) } どちらの関数も、内部的には DefaultServeMux という http.ServeMux オブジェクトにハンドラーを登録しています。 ServeMux は、ハンドラーを束ねるハンドラーです（Composite パターン）。 そして、次のように第 2 引数を nil にして Web サーバーを起動すると、この DefaultServeMux がハンドラーとして使われるようになっています。 http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) 第 2 引数で別のハンドラーオブジェクトを指定してしまうと、http.HandleFunc 関数や http.Handle 関数で登録したハンドラーは呼び出されなくなってしまうので注意してください。 次のようにすれば、独自の ServeMux オブジェクトを作成して、Web サーバーの待ち受けを開始することができます。 func main() { // 独自の ServeMux を作成してハンドラーを登録していく mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/foo/\u0026#34;, func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \u0026#34;I am foo\u0026#34;) }) mux.HandleFunc(\u0026#34;/bar/\u0026#34;, func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, \u0026#34;I am bar\u0026#34;) }) // Web サーバーの待ち受けを開始 log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, mux)) } 静的ファイルをホスティングする (http.FileServer) ハンドラー実装として、http.FileServer を使うと、ローカルディレクトリに配置した静的ファイル（HTML ファイルなど）を簡単にホスティングできます。 public ディレクトリ内のファイルを公開する package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) const port = 8080 const directory = \u0026#34;public\u0026#34; func main() { // 指定したディレクトリをホスティングする handler := http.FileServer(http.Dir(directory)) http.Handle(\u0026#34;/\u0026#34;, handler) // サーバーの待ち受けを開始 log.Printf(\u0026#34;Serving %s on HTTP port: %d\\n\u0026#34;, directory, port) log.Fatal(http.ListenAndServe(fmt.Sprintf(\u0026#34;:%d\u0026#34;, port), nil)) } シンプルに書きたいのであれば、次のように 1 行で書くこともできます。 func main() { log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, http.FileServer(http.Dir(\u0026#34;.\u0026#34;)))) } CORS アクセス対応する (rs.cors) Web ブラウザ上で動作するクライアントサイド JavaScript から、別ドメインの Web サーバーにアクセスしてデータを取得するには、CORS (Cross-Origin Resource Sharing) 用のレスポンスヘッダーを返す必要があります。 下記は、JSON データを返す簡単な Web サーバー実装です。 main.go（CORS 未対応） package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Write([]byte(\u0026#34;{\\\u0026#34;hello\\\u0026#34;: \\\u0026#34;world\\\u0026#34;}\u0026#34;)) }) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, handler)) } http://localhost:8080/ にアクセスすると、{\u0026quot;hello\u0026quot;: \u0026quot;world\u0026quot;} という JSON データが返ってくるはずなのですが、別ドメインの Web サーバーにより配信された JavaScript から次のようにアクセスすると、CORS ポリシーによりブラウザがアクセスをブロックしてしまいます。 クライアントサイド JS fetch(\u0026#39;http://localhost:8080/\u0026#39;) .then((response) =\u0026gt; response.json()) .then((data) =\u0026gt; console.log(data)) アクセスがブロックされたことは、Web ブラウザのコンソールログを見るとわかります。 Access to fetch at \u0026lsquo;http://localhost:8080/\u0026rsquo; from origin \u0026lsquo;http://localhost:3000\u0026rsquo; has been blocked by CORS policy: No \u0026lsquo;Access-Control-Allow-Origin\u0026rsquo; header is present on the requested resource. If an opaque response serves your needs, set the request\u0026rsquo;s mode to \u0026rsquo;no-cors\u0026rsquo; to fetch the resource with CORS disabled. Golang の rs/cors パッケージ を使用すると、簡単に CORS 対応用の HTTP レスポンスヘッダーを返すことができます。 rs/cors の依存情報を追加 $ go get github.com/rs/cors main.go（CORS 対応版） package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/rs/cors\u0026#34; ) func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, _ *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Write([]byte(\u0026#34;{\\\u0026#34;hello\\\u0026#34;: \\\u0026#34;world\\\u0026#34;}\u0026#34;)) }) // CORS レスポンスヘッダーの追加 c := cors.Default() handler := c.Handler(mux) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, handler)) } 追加したコードは、下記の部分です。 c := cors.Default() handler := c.Handler(mux) 既存のハンドラー (mux) を、デフォルトの cors.Cors インスタンスが持つハンドラーでラップしています。 これにより、次のようなクロスドメインアクセスを許可するレスポンスヘッダーが付加されるようになります。 Access-Control-Allow-Origin: * 上記のように cors.Default() が返す cors.Cors インスタンスを使うと、すべてのドメインからの GET/POST アクセスを許可しますが、次のように独自の cors.Cors オブジェクトを作成して受け入れるドメインや HTTP メソッドを指定することができます。 // CORS レスポンス対応（OPTIONS プリフライトリクエストなどに対応） c := cors.New(cors.Options{ AllowedOrigins: []string{\u0026#34;http://localhost:3000\u0026#34;, \u0026#34;http://foo.com\u0026#34;}, AllowedMethods: []string{http.MethodGet, http.MethodPost, http.MethodDelete, http.MethodOptions}, AllowedHeaders: []string{\u0026#34;*\u0026#34;}, AllowCredentials: true, }) CORS アクセスの問題がどうしても解決できないときは、次のように、すべての接続を許可する CORS 設定 (cors.AllowAll()) を試してみるとよいです。 c := cors.AllowAll() handler := c.Handler(mux)`},{url:"/p/oj3izfu/",title:"Hugo で新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo)",date:"2022-08-17T00:00:00Z",body:"Hugo で新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo) 既存の Web ページの URL を変更した場合は、古い URL にアクセスしたときに自動的に新しい URL にリダイレクトされるようにしておくと親切です。 ここでは、2 種類のリダイレクト方法を説明します。 aliases を使う方法 \u0026hellip; 同じ Hugo サイト内でリダイレクトする redirectTo を使う方法（独自） \u0026hellip; 別のサイトへリダイレクトする aliases を使う方法 同一の Hugo サイト内でページの URL を変更した場合は、新しいページのフロントマターに aliases プロパティを追加し、以前の URL を列挙しておきます。 古いページの Markdown ファイルは削除します。 content/new-page/_index.md --- title: \u0026#34;新しい URL のページ\u0026#34; date: \u0026#34;2022-08-17\u0026#34; aliases: - /old-page - /old-page2 - /old-page3 --- 本文... 上記のように記述しておくと、古いページの URL (https://examle.com/old-page) にアクセスしたときに、新しいページの URL (https://example.com/new-page) にリダイレクトしてくれます。 この仕組みは単純で、aliases に列挙した URL に対応するように、Hugo が次のような内容のファイルを出力しています。 public/old-page/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja-jp\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;https://example.com/new-page/\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;canonical\u0026#34; href=\u0026#34;https://example.com/new-page/\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;noindex\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0; url=https://example.com/new-page/\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; meta 要素を使って、Web ブラウザに新しい URL にジャンプするように指示しています。 さらに、link 要素の Canonical URL として新しい URL を設定することで、Google などの検索エンジンに、正しい URL はこちらですよと知らせています。 redirectTo を使う方法（独自） 応用として、別の Web サイトにリダイレクトしたい場合を考えてみます。 前述の aliases を使う方法は、あくまで同じ Hugo サイト内でのリダイレクトを想定しています。 別ドメインへのリダイレクトを行う方法は Hugo 標準では用意されていないようなので、フロントマターに独自のプロパティ redirectTo を指定できるようにしてみます。 まず、リダイレクト用の出力を行えるように、独自の redirect レイアウトテンプレートを作っておきます。 内容は、Hugo の aliases.html を真似しています（.Permalink の部分を .Params.redirectTo に置き換えています）。 layouts/redirect.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html{{ with site.LanguageCode | default site.Language.Lang }} lang=\u0026#34;{{ . }}\u0026#34;{{ end }}\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Params.redirectTo }}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;canonical\u0026#34; href=\u0026#34;{{ .Params.redirectTo }}\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;noindex\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0; url={{ .Params.redirectTo }}\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; あとは、リダイレクトさせたいページのフロントマターで、このレイアウトを使うように指定すれば OK です。 リダイレクト先の URL は、redirectTo プロパティで設定します。 さらに、_build プロパティ を指定して、ページのコレクションとして列挙されないようにしておくのがよさそうです。 content/old-page/_index.md --- title: \u0026#34;別のサイトへリダイレクトさせたいページ\u0026#34; layout: redirect redirectTo: \u0026#34;https://google.com\u0026#34; _build: { list: false } --- これで、https://example.com/old-page/ にアクセスしたときに、https://google.com にリダイレクトされるようになります。"},{url:"/p/4ox6dmu/",title:"Golang で環境変数を扱う (os.Getenv, os.LookupEnv)",date:"2022-08-13T00:00:00Z",body:`Golang で環境変数を扱う (os.Getenv, os.LookupEnv) Go 言語で OS の環境変数を扱うには、標準ライブラリの os パッケージ を使用します。 環境変数を参照する (os.Getenv, os.LookupEnv) os.Getenv 関数 を使うと、特定の環境変数を参照することができます。 指定した名前の環境変数が設定されていない場合は、空文字列 (\u0026quot;\u0026quot;) を返します。 main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func main() { shell := os.Getenv(\u0026#34;SHELL\u0026#34;) if shell == \u0026#34;\u0026#34; { fmt.Println(\u0026#34;環境変数 SHELL が設定されていません\u0026#34;) return } fmt.Printf(\u0026#34;SHELL = %s\\n\u0026#34;, shell) } 環境変数の値として、明示的に空文字列が設定されていることを判別したい場合は、os.Getenv の代わりに os.LookupEnv 関数 関数を使用します。 os.LookupEnv は、2 番目の bool 型戻り値で、環境変数が設定されているかどうかを返します。 val, ok := os.LookupEnv(key) if !ok { fmt.Printf(\u0026#34;%s not set\\n\u0026#34;, key) } else { fmt.Printf(\u0026#34;%s=%s\\n\u0026#34;, key, val) } 文字列リテラルで環境変数を参照する (s.ExpandEnv) 環境変数の値を文字列に展開したいことはよくあります。 そのような場合は、os.ExpandEnv 関数 を使用すると、文字列リテラル内で $key や \${key} という形で環境変数を展開できます。 s := os.ExpandEnv(\u0026#34;環境変数 HOME の値は \${HOME} です\u0026#34;) fmt.Println(s) すべての環境変数を参照する (os.Environ) os.Environ 関数 は、すべての環境変数を文字列配列で返します。 ただし、それぞれの要素は key=value という文字列になっているので、キーと値を別々に取り出したい場合は、= で文字列分割する必要があります。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func main() { for _, env := range os.Environ() { arr := strings.SplitN(env, \u0026#34;=\u0026#34;, 2) key, val := arr[0], arr[1] fmt.Printf(\u0026#34;%s =\u0026gt; %s\\n\u0026#34;, key, val) } } （おまけ）具体的な使用例 例: 環境変数でサーバーのポート番号を指定する 次の例では、何らかのサーバーで使用するポート番号を、環境変数 PORT で指定できるようにしています。 環境変版を指定しなかった場合は、デフォルトで 3000 番ポートを使用します。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) const defaultPort = 3000 // 使用するポート番号を取得します func getPort() (int) { // 環境変数 PORT の値を参照 port := os.Getenv(\u0026#34;PORT\u0026#34;) if port == \u0026#34;\u0026#34; { return defaultPort } // 環境変数の値は文字列型なので数値に変換して返す portNum, err := strconv.Atoi(port) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;PORT \u0026#39;%s\u0026#39; is not valid\\n\u0026#34;, port) return defaultPort } return portNum } func main() { port := getPort() fmt.Printf(\u0026#34;Server is running at port %d\\n\u0026#34;, port) }`},{url:"/p/8r3cmu5/",title:"Docker Compose で環境変数を使用する (env_file, environment)",date:"2022-07-03T00:00:00Z",body:"Docker Compose で環境変数を使用する (env_file, environment) 環境変数を参照する Docker Compose の Compose ファイル (docker-compose.yml) 内では、次のように OS（シェル）の環境変数の値を参照することができます。 例: 環境変数 TAG の値を参照する services: web: image: \u0026#34;webapp:${TAG}\u0026#34; この仕組みを利用すると環境に依存する値をハードコードしなくて済むようになるため、汎用的な docker-compose.yml を記述できるようになります。 上記の例では、${TAG} のように記述していますが、多くのケースでは $TAG のようにカッコを省略することができます。 ドル記号 ($) そのものを扱いたい場合は、$$ のように記述する必要があります。 .env ファイル .env ファイルは自動で読み込まれる docker compose up コマンドは、プロジェクトディレクトリに置いてある環境ファイル .env を読み込んでくれます。 .env ファイルには、次のように複数の環境変数を定義しておくことができます。 .env の記述例 # この行はコメント MYAPP_PORT=3000 DB_PASSWORD=mypassword 別の .env ファイルを参照する docker compose コマンドの --env-file オプションを指定すると、参照する .env ファイルを切り替えることができます。 例: .env ではなく .env.prod を参照する $ docker compose --env-file .env.prod up 優先順位 シェル環境で同じ名前の環境変数がセットされている場合（例: export MYAPP_PORT=4000）は、そちらが優先して使われます。 つまり、.env ファイルで定義されている値は、シェル環境変数がセットされていない場合のデフォルト値のように扱われます。 環境変数の優先順位: OS の環境変数（シェル環境）でセットした値。例えば、bash シェルであれば export FOO=BAR のように設定した値 プロジェクトディレクトリの .env ファイルで定義した値 環境変数が定義されていない場合の振る舞い 環境変数 VARIABLE が定義されていないときに、Compose ファイルの中で ${VARIABLE} のように参照すると、空文字列 (\u0026quot;\u0026quot;) として評価されます。 この振る舞いは次のような参照方法によって変更することができます（この構文は、bash の変数展開の構文 に基づいています）。 環境変数が設定されていないときにデフォルト値を使用する ${VARIABLE:-default} … 変数 VARIABLE がセットされていないか空文字のときに、default で指定された値を使用します。 ${VARIABLE-default} … 変数 VARIABLE がセットされていないときに、default で指定された値を使用します（VARIABLE に空文字がセットされているときは、そのまま空文字を使います）。 次の例では、web サービスのデフォルトのホスト側ポート番号を 8000 番に設定しています（コンテナ側のポート番号は 80 で固定です）。 docker-compose.yml services: web: image: nginx ports: - \u0026#34;${APP_PORT:-8000}:80\u0026#34; 実行例 $ docker compose up # localhost:8000 でアクセスできるようになる 次のように APP_PORT の値を明示すると、ホスト側のポート番号は 8000 ではなく、3000 が使われるようになります。 $ APP_PORT=3000 docker compose up # localhost:3000 でアクセスできるようになる 環境変数が設定されていないときにエラーにする ${VARIABLE:?err} … 変数 VARIABLE がセットされていないか空文字のときに、err メッセージを表示して終了します（実際には err を省略して ${VARIABLE:?} と書くだけでもそれっぽいエラーメッセージが表示されます） ${VARIABLE?err} … 変数 VARIABLE がセットされていないときに、err メッセージを表示して終了します（VARIABLE に空文字がセットされているときは空文字を使います） 次の例では、PostgreSQL のパスワードを環境変数 POSTGRES_PASSWORD でセットしておくことを強制しています。 docker-compose.yml services: db: image: postgres restart: always environment: - POSTGRES_USER=${POSTGRES_USER:-root} - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?} - POSTGRES_DB=${POSTGRES_DB:-mydb} 環境変数 POSTGRES_PASSWORD を設定せずにサービスを起動しようとすると、次のようにエラーになります。 $ docker compose up invalid interpolation format for services.db.environment.[]: \u0026#34;required variable POSTGRES_PASSWORD is missing a value: \u0026#34;. You may need to escape any $ with another $ 各コンテナの環境変数を設定する Compose ファイル (docker-compose.yml) の中では OS（シェル）の環境変数を参照できますが、それらがそのまま各コンテナに渡されるわけではありません。 environment プロパティによる指定 各コンテナの環境変数を設定するには、各サービスの定義で environment プロパティを指定する必要があります。 次の例では、web サービス（コンテナ）の環境変数 DEBUG の値を 1 にセットしています。 これは、docker run -e DEBUG=1 ... のようにコンテナを起動するのと同じ効果があります。 docker-compose.yml services: web: image: nginx ports: - \u0026#34;80:80\u0026#34; environment: - DEBUG=1 ホスト側の環境変数（.env で定義したものを含む）の値をそのままコンテナに渡したいときは、次のように環境変数名だけを記述します。 これは、docker run -e DEBUG ... のようにコンテナを起動するのと同じ効果があります。 environment: - DEBUG env_file プロパティによる指定 コンテナに渡す環境変数の一覧を .env ファイルに記述しておき、そのファイル名を env_file プロパティで指定する、という方法もあります。 web-vars.env DB_NAME=mydb DB_USER=root DB_PASSWORD=mypassword docker-compose.yml services: web: image: nginx ports: - \u0026#34;80:80\u0026#34; env_file: - web-vars.env 優先度 次のように、env_file と environment が両方指定されていて、同じ環境変数がセットされている場合は、Compose ファイルに直接記述された environment の方が優先されます。 services: web: image: nginx ports: - \u0026#34;80:80\u0026#34; env_file: - web-vars.env environment: - DB_NAME=xxxxx - DB_USER=yyyyy docker compose config コマンドを実行すると、実際にどのような環境変数がコンテナに設定されるかを確認できます。 $ docker compose config name: myproject services: web: environment: DB_NAME: xxxxx DB_PASSWORD: mypassword DB_USER: yyyyy ...（省略）..."},{url:"/p/qm5k2hx/",title:"Docker Compose の基本",date:"2022-07-03T00:00:00Z",body:"Docker Compose の基本 Docker Compose とは？ Docker Compose (docker compose) を使うと、複数の Docker コンテナをまとめてコントロールすることができます。 各コンテナの起動時に必要となるパラメーターや連携方法を docker-compose.yml という YAML ファイルにまとめて記述できるため、すべてのコンテナの起動を docker compose up というシンプルなコマンドで行うことができます。 Docker Compose は複数のコンテナをコントロールすることを想定していますが、単一のコンテナを起動するときにも便利 です。 例えば、Dockerfile を使ったイメージビルド、ポート番号のマッピング、ネットワークの定義などを docker-compose.yml で定義しておいて、docker compose up コマンド一発で実行できます。 docker-compose.yml の中では環境変数の値を参照できる（例: ${APP_PORT}）ため、環境ごとに異なる値をハードコードしなくて済みます。 また、docker compose up コマンドは、環境変数を定義した .env ファイルを自動的に読み込んでくれます。 単一のコンテナを起動してみる Docker Compose で簡単な nginx サーバーを立ち上げてみます。 Docker Compose は、デフォルトで カレントディレクトリ名をプロジェクト名として使用します（-p オプションで任意のプロジェクト名を付けることもできます）。 ここでは、myproject というディレクトリを作って、その中に Compose ファイル (docker-compose.yml) を配置することにします。 $ mkdir myproject $ cd myproject 次のようなシンプルな Compose ファイルを作成します。 docker-compose.yml services: web: image: nginx ports: - \u0026#34;80:80\u0026#34; 各サービス（コンテナ）の定義は、services プロパティの下に記述していきます。 この例では、web という名前のサービスを 1 つだけ定義しており、その下の image プロパティで nginx のイメージを使うよう指示しています。 さらに、ports プロパティで、ホストの 80 番ポートへのアクセスをコンテナの 80 番ポートへ転送しています。 この定義で生成されるコンテナの名前は web ではなく、プロジェクト名や連番が付加された myproject-web-1 という名前になります。 Compose ファイル (docker-compose.yml) のあるディレクトリで docker compose up コマンドを実行すると、コンテナを作成＆起動できます。 $ docker compose up 停止したいときは、Ctrl-C を入力するとすべてのコンテナが停止します（今回は 1 コンテナだけですが）。 初回起動時には、nginx のイメージなどがダウンロードされるため少し時間がかかりますが、しばらくすると myproject-web-1 コンテナが起動し、http://localhost/（あるいは http://127.0.0.1/）で Web ページにアクセスできるようになります。 別のターミナル（端末）を開いて次のように実行すると、myproject-web-1 というコンテナが起動していることを確認できます。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cf2aa5a2b831 nginx \u0026#34;/docker-entrypoint.…\u0026#34; 10 minutes ago Up 5 minutes 0.0.0.0:80-\u0026gt;80/tcp myproject-web-1 参考: Docker Compose をデタッチモードで起動する (docker compose up -d) 応用 Dockerfile からイメージをビルドする 独自の Dockerfile を使ってイメージを構築してコンテナを起動したいときは、サービスの定義の中で image プロパティの代わりに build プロパティを使用します。 設定する値は、Dockerfile があるディレクトリのパスです。 次の docker-compose.yml は、カレントディレクトリ (.) にある Dockerfile を使ってイメージをビルドし、コンテナを起動します。 services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; 複数のコンテナを起動する services プロパティ以下には、複数のサービスを定義することができます。 次の docker-compose.yml では、web と redis の 2 つのサービスを定義しています。 services: web: build: . ports: - \u0026#34;3000:3000\u0026#34; redis: image: \u0026#34;redis:alpine\u0026#34; web サービスは独自の Dockerfile からイメージをビルドし、redis サービスは Docker Hub レジストリ上の redis:alpine イメージを使うよう指定しています。 redis サービスは同一の Docker ネットワーク内にある web サービスから参照できればよいので、ports プロパティによるポート転送設定は必要ありません。 docker compose up を実行すると、次のような名前の 2 つのコンテナが起動します。 \u0026lt;PROJECT-NAME\u0026gt;-web-1 \u0026lt;PROJECT-NAME\u0026gt;-redis-1 ひとつの Compose ファイルで定義したサービスは同一の Docker ネットワーク（例: myproject_default）に配置されるため、それぞれのコンテナは互いにコンテナ名で参照することができます。 上記の例でいうと、web サービスの中では、redis というホスト名で Redis サービスを参照できます。 Web アプリの実装の中から、Redis コンテナに割り当てられた IP アドレスを意識しなくて済みます（逆に言うと、変化しやすい IP アドレスをもとに通信すべきではありません）。 参考: Docker のネットワークについて理解する"},{url:"/p/94m3izf/",title:"Docker Compose をデタッチモードで起動する (docker compose up -d)",date:"2022-07-03T00:00:00Z",body:"Docker Compose をデタッチモードで起動する (docker compose up -d) docker compose up コマンドを実行すると、現在のターミナル（端末）に入出力がアタッチされて Docker Compose のログが出力されるようになるため、その端末では別の入力作業ができなくなってしまいます（Ctrl-D で停止できます）。 $ docker compose up [+] Running 2/0 ⠿ Network myproject_default Created ⠿ Container myproject-web-1 Created Attaching to myproject-web-1 ...（省略）... myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker processes myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 31 myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 32 ...（省略）... docker compose up コマンドを実行するときに、-d (--detach) オプションを指定すると、Docker Compose がデタッチモードで起動（バックグラウンド実行）されるため、その端末を引き続き使用できるようになります。 $ docker compose up -d [+] Running 1/1 ⠿ Container myproject-web-1 Started $ （次のコマンドを入力可能） 表示されなくなったログは、docker compose logs コマンドで確認できます。 $ docker compose logs ...（省略）... myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker processes myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 31 myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 32 ...（省略）... Docker Compose で動作しているコンテナの一覧は docker compose ps で確認できます。 $ docker compose ps NAME COMMAND SERVICE STATUS PORTS myproject-web-1 \u0026#34;/docker-entrypoint.…\u0026#34; web running 0.0.0.0:80-\u0026gt;80/tcp デタッチモードで起動したコンテナをすべて停止するには docker compose stop コマンド、停止されたコンテナを起動するには docker compose start コマンドを使用します。 $ docker compose stop # コンテナを停止 $ docker compose start # 停止中のコンテナを起動 コンテナやネットワークをすべて削除するには、docker compose down コマンドを実行します。 こちらは停止ではなくて削除なので気をつけてください。 $ docker compose down # コンテナとネットワークの削除 $ docker compose down --volumes # ボリュームまで削除する場合 なお、上記のようなコマンドは、対象の docker-compose.yml があるディレクトリ内（プロジェクト内）で実行する必要があります。 別のディレクトリから実行したいときは、-p オプションでプロジェクト名（デフォルトではディレクトリ名）を指定します。 $ docker compose -p myproject ps"},{url:"/p/4ohyhxe/",title:"Docker Hub のイメージを検索する (docker search)",date:"2022-07-03T00:00:00Z",body:"Docker Hub のイメージを検索する (docker search) docker search コマンドを使って、Docker Hub（レジストリ）で公開されているイメージを検索することができます。 次の例では、ubuntu というキーワードでイメージを検索しています。 Docker Hub 上で付けられたスターの数や、公式イメージかどうかもチェックできます。 $ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 14524 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 286 [OK] ubuntu-upstart DEPRECATED, as is Upstart (find other proces… 112 [OK] neurodebian NeuroDebian provides neuroscience research s… 91 [OK] open-liberty Open Liberty multi-architecture images based… 53 [OK] ubuntu/nginx Nginx, a high-performance reverse proxy \u0026amp; we… 52 ubuntu-debootstrap DEPRECATED; use \u0026#34;ubuntu\u0026#34; instead 46 [OK] ubuntu/apache2 Apache, a secure \u0026amp; extensible open-source HT… 36 ubuntu/mysql MySQL open source fast, stable, multi-thread… 34 kasmweb/ubuntu-bionic-desktop Ubuntu productivity desktop for Kasm Workspa… 29 ubuntu/prometheus Prometheus is a systems and service monitori… 27 ubuntu/squid Squid is a caching proxy for the Web. Long-t… 25 ubuntu/bind9 BIND 9 is a very flexible, full-featured DNS… 22 ubuntu/postgres PostgreSQL is an open source object-relation… 17 ubuntu/redis Redis, an open source key-value store. Long-… 10 ubuntu/grafana Grafana, a feature rich metrics dashboard \u0026amp; … 6 ubuntu/prometheus-alertmanager Alertmanager handles client alerts from Prom… 6 ubuntu/kafka Apache Kafka, a distributed event streaming … 6 ubuntu/memcached Memcached, in-memory keyvalue store for smal… 5 ubuntu/telegraf Telegraf collects, processes, aggregates \u0026amp; w… 4 ubuntu/zookeeper ZooKeeper maintains configuration informatio… 4 ubuntu/cortex Cortex provides storage for Prometheus. Long… 3 ubuntu/cassandra Cassandra, an open source NoSQL distributed … 2 bitnami/ubuntu-base-buildpack Ubuntu base compilation image 2 [OK] ubuntu/loki Grafana Loki, a log aggregation system like … 0"},{url:"/p/najs2ah/",title:"Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal)",date:"2022-07-02T00:00:00Z",body:"Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal) コンテナからホスト側のサーバーにアクセスする Docker コンテナの中から、ホスト側で動作しているサービス（Web サーバーなど）にアクセスするには、IP アドレスの代わりに特殊な DNS 名 host.docker.internal を使用します（localhost だとコンテナ自身を参照してしまうのでうまくいきません）。 コンテナからホスト上のサービスにアクセスする $ curl http://host.docker.internal:8000/ 接続テスト テストとして、ホスト上で Web サーバーを起動してコンテナからアクセスしてみます。 まず、何でもいいのでホスト側で Web サーバーを起動します。 Docker で nginx サーバーを起動する方法 $ docker container run --rm -p 8000:80 --name webserver nginx:alpine Python のワンライナーで Web サーバーを起動する方法 $ python -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... 参考: Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) 次に、コンテナ側からこの Web サーバーに curl でアクセスできるか確認します。 ここでは、軽量のコンテナとして Alpine Linux を使っています。 コンテナからホスト側の Web サーバーにアクセス $ docker container run --rm -it alpine ash / # apk add curl / # curl http://host.docker.internal:8000/ \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; ...（省略）..."},{url:"/p/7fjnqtw/",title:"Docker のネットワークについて理解する (none, host, bridge)",date:"2022-06-15T00:00:00Z",body:"Docker のネットワークについて理解する (none, host, bridge) Docker の 3 つのネットワーク Docker をインストールすると、デフォルトで none、host、bridge という 3 つのネットワークが生成されます。 docker network ls コマンドの出力の NAME カラムを見ると、これら 3 つの名前があることを確認できます。 $ docker network ls NETWORK ID NAME DRIVER SCOPE 1d32c46c83f6 bridge bridge local a97adbf7b226 host host local 7543afe52cd6 none null local none Docker コンテナにネットワークインタフェースを持たせたくない場合に指定します。 つまり、外部との通信が一切できないコンテナになります。 host ホスト側のネットワークインタフェースを共有するときに指定します。 つまり、ホストと同じ IP アドレスがコンテナに割り当てられます。 bridge 一番よく使用されるネットワークで、bridge という名前の仮想ブリッジに接続されたネットワーク環境であることを示します。 docker container create (run) でコンテナを作成するときにネットワーク (--net) を指定しないと、デフォルトでこの bridge が使われます。 Linux のブリッジ機能を利用しており、このネットワークに参加したコンテナからは、インターネットにアクセスすることができます。 同じ bridge に接続するコンテナは、同じ仮想ブリッジで接続された状態（同じネットワークに所属する状態）になるため、相互に通信ができます（ping など）。 Docker コンテナを作成する際には、どのネットワークを使うかを --net オプションで指定します。 指定しない場合はデフォルトで bridge が使われます。 例: ネットワーク接続できないコンテナを作成する $ docker container create --name my-ubuntu --net none ubuntu:22.04 bridge ネットワークのアドレスを確認してみる デフォルトで作成される bridge には、172.17.0.0/16 などのネットワークアドレスが割り当てられています。 $ docker network inspect bridge --format \u0026#34;{{.IPAM.Config}}\u0026#34; [{172.17.0.0/16 map[]}] このネットワークに参加させるコンテナには、172.17.0.2 や 172.17.0.3 などの IP アドレスが割り当てられていきます。 172.17.0.1 など、末尾が 1 のアドレスは通常はデフォルトゲートウェイに割り当てられています。 コンテナに割り当てられた IP アドレスを確認するには、次のようにコンテナ情報を表示します。 $ docker container inspect --format \u0026#34;{{.NetworkSettings.IPAddress}}\u0026#34; my-cont 172.17.0.2 あるいは、次のようにネットワーク情報を表示して、Containers プロパティ以下の情報を参照すれば、そのネットワークに参加しているすべてのコンテナの IP アドレスを確認できます。 $ docker network inspect bridge 新しいブリッジネットワークを作成すると、別のネットワークアドレス（172.18.0.0/16 など）が割り当てられます。 $ docker network create my-net $ docker network inspect my-net --format \u0026#34;{{.IPAM.Config}}\u0026#34; [{172.18.0.0/16 172.18.0.1 map[]}] Docker Compose を使えば、複数のコンテナを同一ネットワークに参加させるということをシンプルに表現できます。 ☝️ format オプションについて 上記の例では、--format オプションで出力を絞り込んでいますが、ここで使われている書式は、Go 言語の template パッケージ に従っています。 コンテナ名による通信 Docker ネットワークを作成し、コンテナをそのネットワークに参加させると、各コンテナ同士が コンテナ名 で通信できるようになります。 つまり、各コンテナに割り当てられた IP アドレスを知る必要がありません。 図: Docker コンテナ間のコンテナ名での通信 次のように実行すれば、コンテナ名で通信を行えることを確認できます。 （新しいネットワーク my-net を作成） $ docker network create my-net （1 つ目のコンテナ alpine1 を起動） $ docker run --rm -it --net my-net --name alpine1 alpine /bin/sh （別のターミナルから 2 つ目のコンテナ alpine2 を起動） $ docker run --rm -it --net my-net --name alpine2 alpine /bin/sh （コンテナ名で互いに ping できるか確認）　# ping alpine1 # ping alpine2 （コラム）仮想ブリッジ bridge0 Docker 用のブリッジは、ホスト側に bridge0 という名前の仮想ブリッジとして作成されます。 $ ifconfig bridge0 bridge0: flags=8863\u0026lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST\u0026gt; mtu 1500 options=63\u0026lt;RXCSUM,TXCSUM,TSO4,TSO6\u0026gt; ether 36:f6:6f:f3:5a:c0 Configuration: id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0 ipfilter disabled flags 0x0 member: en1 flags=3\u0026lt;LEARNING,DISCOVER\u0026gt; ifmaxaddr 0 port 10 priority 0 path cost 0 member: en2 flags=3\u0026lt;LEARNING,DISCOVER\u0026gt; ifmaxaddr 0 port 11 priority 0 path cost 0 member: en3 flags=3\u0026lt;LEARNING,DISCOVER\u0026gt; ifmaxaddr 0 port 12 priority 0 path cost 0 Address cache: nd6 options=201\u0026lt;PERFORMNUD,DAD\u0026gt; media: \u0026lt;unknown type\u0026gt; status: inactive ちなみにこの bridge0 は、Docker Desktop for Windows/macOS を使っている場合は直接は参照できないことに注意してください。 Docker Desktop の場合は、その仮想マシン内に bridge0 が作成されます。"},{url:"/p/8fjnqtw/",title:"Docker のコンテナイメージを削除する (docker image rm/prune)",date:"2022-06-12T00:00:00Z",body:"Docker のコンテナイメージを削除する (docker image rm/prune) docker image rm （指定したコンテナイメージを削除する） 使い方 docker image pull や docker container run 経由でダウンロードした Docker イメージを削除するには、docker image rm コマンド（旧: docker rmi）を使用します。 $ docker image rm ＜イメージ＞ 削除するイメージは、イメージ名:タグ名 や イメージID の形で指定します。 $ docker image rm ubuntu:20.04 $ docker image rm 54c9d81cbb44 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB ヘルプ $ docker help image rm Usage: docker image rm [OPTIONS] IMAGE [IMAGE...] Remove one or more images Aliases: rm, rmi, remove Options: -f, --force Force removal of the image --no-prune Do not delete untagged parents docker image prune （使用していないコンテナイメージを削除する） 使い方 docker image prune コマンドを使用すると、使用していない Docker イメージをまとめて削除することができます。 $ docker image prune デフォルトでは、dangling images（エラーなどで予期せず残ってしまったイメージ）のみを削除します。 コンテナと関連づけられていないイメージをすべて削除するには、-a (--all) オプションを指定して実行します。 $ docker image prune -a ヘルプ $ docker help image prune Usage: docker image prune [OPTIONS] Remove unused images Options: -a, --all Remove all unused images, not just dangling ones --filter filter Provide filter values (e.g. \u0026#39;until=\u0026lt;timestamp\u0026gt;\u0026#39;) -f, --force Do not prompt for confirmation 参考 リポジトリ名のついていない Docker イメージをすべて削除する (docker image rm)"},{url:"/p/9hkprvx/",title:"Hugo で Markdown (.md) ファイルを VS Code で開くリンクを表示する",date:"2022-06-04T00:00:00Z",body:"Hugo で Markdown (.md) ファイルを VS Code で開くリンクを表示する VS Code で開くリンク 下記の Hugo テンプレートコードは、現在のページの生成元になった Markdown (.md) ファイルを VS Code で開くリンクを表示します（ローカルサーバーでの実行中のみ）。 {{- if .Site.IsServer }} {{- with .File }} \u0026lt;a href=\u0026#34;vscode://file/{{ .Filename }}\u0026#34;\u0026gt;✎ VS Code で開く\u0026lt;/a\u0026gt; {{- end }} {{- end }} 仕組み VS Code (Visual Studio Code) をインストールすると、ブラウザのアドレス欄に vscode://path\u0026lt;ファイルのフルパス\u0026gt; という特殊なアドレスを入力することで、ローカル PC 内のファイルを VS Code で開くことができるようになります。 例えば、/Users/maku/hugo-site/content/page.md というファイルを開きたいときは次のようなアドレスを入力します。 Linux や macOS の場合 vscode://file/Users/maku/hugo-site/content/page.md Windows の場合 vscode://file/C:\\Users\\maku\\hugo-site\\content\\page.md Markdown ファイルのパス情報は File 変数で参照できる ので、それを利用して a 要素を出力してやれば、リンクのクリックだけで VS Code を開くことができるようになります。"},{url:"/p/3adgjnq/",title:"Hugo の記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する",date:"2022-06-02T00:00:00Z",body:"Hugo の記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する js.Build の基本 Hugo Pipes のひとつである js.Build を使用すると、TypeScript ファイル (.ts) のビルドを行うことができます。 下記のショートコードは、記事ページにバンドルした .ts ファイルを .js ファイルにトランスパイルし、script 要素として出力する例です。 layouts/shortcodes/script.html {{- $src := .Get \u0026#34;src\u0026#34; -}} {{- $res := .Page.Resources.GetMatch $src -}} {{- $built := $res | js.Build -}} \u0026lt;script src=\u0026#34;{{ $built.RelPermalink }}\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; このショートコードを使う記事ページ (.md) と TypeScript ファイル (.ts) は、次のような感じで content ディレクトリ以下の任意のディレクトリに配置します。 content/ sample-page/ index.md hello.ts ページバンドルの形にするため、記事ページは index.md というファイル名で作成し、同じディレクトリに .ts ファイルを配置することに注意してください。 content/sample-page/index.md --- title: \u0026#34;サンプルページ\u0026#34; --- {{\u0026lt; script src=\u0026#34;hello.ts\u0026#34; \u0026gt;}} content/sample-page/hello.ts alert(\u0026#39;Hello!\u0026#39;) assets ディレクトリに配置した ts ファイルを参照する 前述の例では、ページバンドルした .ts ファイルを参照しましたが、プロジェクト全体で使う .ts ファイルは、共有リソースとして assets ディレクトリ以下に入れておくと便利です（assets ディレクトリには、ビルド時に何らかの変換を行うファイルを配置します）。 assets/js/hello2.ts alert(\u0026#39;Hello2\u0026#39;) assets ディレクトリ以下のリソースを参照するために、ショートコードを少しだけ変更する必要があります（.Page.Resources.GetMatch を resources.Get に置き換えます）。 ここでは、別のショートコード (script-shared.html) として作成することにします。 layouts/shortcodes/script-shared.html {{- $src := .Get \u0026#34;src\u0026#34; -}} {{- $res := resources.Get $src -}} {{- $built := $res | js.Build -}} \u0026lt;script src=\u0026#34;{{ $built.RelPermalink }}\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; ショートコードの使い方は、前述の例と同様です。 .ts ファイルのパスは、assets ディレクトリからの相対パスで指定します。 content/test.md --- title: \u0026#34;テストページ\u0026#34; --- {{\u0026lt; script-shared src=\u0026#34;js/hello2.ts\u0026#34; \u0026gt;}} ちなみに、assets ディレクトリに配置した .ts ファイルは、js.Build への入力ファイルとして使われるだけで、最終的なビルド結果（public ディレクトリ）にコピーされることはありません。 上記の例の場合は、トランスパイル後の public/js/hello2.js だけが出力されます。 NPM パッケージを使用する js.Build は、Hugo のプロジェクトルートに配置した node_modules ディレクトリを参照してくれます（ver 0.78.1 以降）。 つまり、npm install でインストールした NPM パッケージを使用できるということです。 ここでは、day.js という日付を扱うパッケージを使ってみます。 まず、Hugo プロジェクトのルートで次のように NPM パッケージをインストールします。 $ npm init -y # package.json の作成 $ npm install dayjs # dayjs パッケージのインストール あとは、TypeScript コードから普通に import して使えます。 assets/js/test.ts import dayjs from \u0026#39;dayjs\u0026#39; const s = dayjs(\u0026#39;2019-01-25\u0026#39;).format(\u0026#39;DD/MM/YYYY\u0026#39;) alert(s) もちろん、React などのパッケージも使えるので、Hugo のページ内に React コンポーネントを埋め込むといったことも可能です。 Hugo は自由度が高いですね。"},{url:"/p/9gjnqtw/",title:"Hugo のセクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight)",date:"2022-05-20T00:00:00Z",body:"Hugo のセクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight) .Pages のデフォルトソート順序 Hugo のセクションページのテンプレート内で .Pages 変数を参照すると、子セクションや子ページの一覧を取得できますが、その一覧はデフォルトで次のような情報をもとにソートされています（参考: Lists of Content in Hugo - Order Content）。 Weight ページのフロントマターで weight: 1 のように書いておくと、ページに重み付けできます。 より小さな値の weight を持っているページの方が先に表示されます。 weight を持たないページ（あるいは weight: 0 のページ）は、いかなる weight を持つページよりも後ろに表示されます。 Date ページのフロントマターで、date: \u0026quot;2022-05-20\u0026quot; のように記述しておくと、そのページの作成日として認識されます。 より新しいページが先に表示されます。 LinkTitle / Title ページのタイトルで昇順ソートされます。 フロントマターに linkTitle が指定されていればその値でソートされ、なければ title の値でソートされます。 FilePath .md ファイルのフルパスで昇順ソートされます。 具体的のどのような実装になっているかは、下記 Hugo ソースコードの DefaultPageSort 関数あたりを見ると分かります。 参考: hugo/pages_sort.go ソート方法をカスタマイズする .Pages 変数でページの一覧を取得するときに .Pages.ByTitle のように指定すると、ページタイトルでソートされた結果を取得できます。 他にもいろいろな参照方法があります。 参照方法 意味 .Pages.ByWeight フロントマターの weight の小さい順。ただし、weight: 0 は指定なしとみなされる .Pages.ByTitle タイトル (title) 順 .Pages.ByLinkTitle タイトル (linkTitle) 順。linkTitle がない場合は title を参照する .Pages.ByDate 日付 (date) が新しい順 .Pages.ByPublishDate 日付 (publishdate) が新しい順 .Pages.ByExpiryDate 日付 (expirydate) が新しい順 .Pages.ByLastmod 日付 (lastmod) が新しい順 .Pages.ByLength 本文が短い順 .Pages.ByParam \u0026quot;rating\u0026quot; フロントマターの独自フィールドの値でソート（この場合は rating） .Pages.ByParam \u0026quot;author.last_name\u0026quot; 上の応用（入れ子になった独自フィールド） 逆順にしたいときは、後ろに .Reverse を付けます。 例えば次のようにすると、タイトルで降順ソート されます。 .Pages.ByTitle.Reverse セクションテンプレートの中に、次のようなスニペットを記述すれば、各種ソート条件でどのように表示されるかを確認できます。 この例では、ページタイトルで逆順ソートした結果を表示しています。 layouts/_default/section.html（抜粋） \u0026lt;ul\u0026gt; {{ range .Pages.ByTitle.Reverse }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Weight }} / {{ .Date.Format \u0026#34;2006-01-02\u0026#34; }} / {{ .LinkTitle }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; 応用: 複数の条件でソートする 前述の通り、.Pages はデフォルトで Weight → Date → LinkTitle → FilePath の優先度でソートされるのですが、これをカスタマイズして Weight → LinkTitle の順でソートしたい場合はちょっとややこしいです。 .Pages.ByWeight.ByTitle としてしまうと、Weight 順にソートされた結果がタイトル順で再度ソートされるだけでうまくいきません（.ByWeight の意味がなくなってしまいます）。 段階的にソートするには、まずグループ機能で同じ Weight を持つページを取り出し、そのグループ内でタイトル順ソートする必要があります。 次のパーシャルテンプレートは、渡された .Pages を Weight → LinkTitle の順でソートする関数です。 layouts/partials/functions/sort-pages.html {{- $pages := . }} {{- $pagesWithWeight := where $pages \u0026#34;Weight\u0026#34; \u0026#34;\u0026lt;\u0026gt;\u0026#34; 0 }} {{- $pagesWithoutWeight := where $pages \u0026#34;Weight\u0026#34; \u0026#34;==\u0026#34; 0 }} {{- $ret := slice }} {{- range $pagesWithWeight.GroupBy \u0026#34;Weight\u0026#34; }} {{- $ret = $ret | append .Pages.ByLinkTitle }} {{- end }} {{- $ret = $ret | append $pagesWithoutWeight.ByLinkTitle }} {{- return $ret }} あとは、セクションテンプレートなどから次のように使用します。 layouts/_default/section.html（抜粋） \u0026lt;ul\u0026gt; {{ range partial \u0026#34;functions/sort-pages\u0026#34; .Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt;"},{url:"/p/uh84kfj/",title:"ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)",date:"2022-04-21T00:00:00Z",body:"ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages) （確認バージョン: Android 12 (S)） pm list packages コマンド adb shell pm list packages コマンドを使用すると、Android デバイスにインストールされているパッケージ (APK) の一覧を取得できます。 パッケージ名は順不同で表示されるので、出力をパイプで sort につなぐと見やすくなります。 $ adb shell pm list packages | sort ... package:com.google.android.apps.maps package:com.google.android.apps.messaging package:com.google.android.apps.nexuslauncher package:com.google.android.apps.photos package:com.google.android.apps.restore package:com.google.android.apps.wallpaper ... -f オプションを付けて実行すると、各 APK の インストール先のパス を調べることができます。 $ adb shell pm list packages -f | sort ... package:/system/priv-app/UserDictionaryProvider/UserDictionaryProvider.apk=com.android.providers.userdictionary package:/system/priv-app/VpnDialogs/VpnDialogs.apk=com.android.vpndialogs package:/system_ext/priv-app/CarrierConfig/CarrierConfig.apk=com.android.carrierconfig package:/system_ext/priv-app/EmergencyInfo/EmergencyInfo.apk=com.android.emergency ... -3 オプションを付けて実行すると、サードパーティ製のパッケージ の一覧を表示できます。 つまり、Google Play ストアからインストールしたアプリや、自分で作ってインストールしたアプリの一覧を確認できます。 $ adb shell pm list packages -3 package:com.example.myapp package:com.example.myapp2 （おまけ）pm help のヘルプ表示抜粋 adb shell pm help のヘルプ表示のうち、pm list packages コマンドに相当する部分の抜粋です。 list packages [-f] [-d] [-e] [-s] [-3] [-i] [-l] [-u] [-U] [--show-versioncode] [--apex-only] [--uid UID] [--user USER_ID] [FILTER] Prints all packages; optionally only those whose name contains the text in FILTER. Options are: -f: see their associated file -a: all known packages (but excluding APEXes) -d: filter to only show disabled packages -e: filter to only show enabled packages -s: filter to only show system packages -3: filter to only show third party packages -i: see the installer for the packages -l: ignored (used for compatibility with older releases) -U: also show the package UID -u: also include uninstalled packages --show-versioncode: also show the version code --apex-only: only show APEX packages --uid UID: filter to only show packages with the given UID --user USER_ID: only list packages belonging to the given user"},{url:"/p/whs2bjt/",title:"Go でコマンドラインツールを作って GitHub で公開する",date:"2022-04-10T00:00:00Z",body:"Go でコマンドラインツールを作って GitHub で公開する 何をするか？ ここでは、Go 言語の HelloWorld として、go-hello というコマンドを作って、GitHub で公開できるようにしてみます。 この手順が完了すると、世界中のユーザーが次のように go-hello コマンドをインストールできるようになります。 $ go install github.com/\u0026lt;User\u0026gt;/go-hello@latest go-hello プロジェクトの作成 まず、適当なディレクトリにプロジェクト用のディレクトリを作成します。 $ mkdir -p ~/go-hello $ cd ~/go-hello go mod コマンドで、プロジェクトのルートディレクトリに go.mod ファイルを作成します。 引数として、モジュール名（モジュールパス）を指定します。 GitHub で公開するのであれば次のような感じで指定します（maku77 の部分は自分の GitHub ユーザー ID に変更してください）。 $ go mod init github.com/maku77/go-hello 作成された go.mod の内容 module github.com/maku77/go-hello go 1.18 Go は、go.mod ファイルのあるディレクトリをモジュールルートとみなします。 go-hello コマンドの実装 実装 Go 言語では実行可能なコマンドは main パッケージの main 関数として実装します。 ファイル名は何でもよいのですが、ここでは main.go として作成します。 go-hello/main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, world!\u0026#34;) } 動作確認 この Hello World プログラムは、go run コマンドでファイル名かディレクトリパスを指定して直接実行できます。 $ go run . Hello, world! go build コマンドを実行すれば、実行ファイル (go-hello) を生成することができます。 実行ファイル名は go mod init で指定したモジュール名にしたがって自動的につけられますが、-o オプションで明示することもできます。 $ go build $ ./go-hello Hello, world! go install コマンドを使うと、go-hello 実行ファイルが $GOPATH/bin（あるいは $GOBIN で指定したディレクトリ）にインストールされます（あらかじめ go build しておく必要はありません）。 Go 用の PATH 環境変数を設定 してあれば、どのディレクトリからでもインストールした go-hello コマンドを実行できるようになります。 $ go install $ go-hello Hello, world! インストールしたコマンドが不要になった場合は、次のように単純に実行ファイルを削除すれば OK です。 $ rm `go env GOPATH`/bin/go-hello # GOBIN 環境変数を設定済みであれば下記でも OK $ rm `go env GOBIN`/go-hello GitHub で go-hello モジュールを公開する 作成した Go モジュールを GitHub で公開します。 リポジトリの作成 まず、モジュール名に合わせて、GitHub にリポジトリを作成 します。 ここでは、\u0026lt;User\u0026gt;/go-hello という名前で作成します。 README.md と Go 言語用の .gitignore を自動生成しておくと便利です。 コミット＆プッシュ リポジトリを作成したら、適当な作業用ディレクトリに git clone します。 $ cd ~/gitwork $ git clone https://github.com/\u0026lt;User\u0026gt;/go-hello $ cd ~/gitwork/go-hello 前のステップで作成した go.mod や main.go ファイルをこのディレクトリにコピーしてコミット、プッシュします。 これで、GitHub への公開は完了です。 $ git add . $ git commit -m \u0026#34;Add main function\u0026#34; $ git push GitHub からコマンドをインストールしてみる GitHub への Go モジュールのデプロイが完了したら、GitHub から直接 go install してみます。 この際、取得するコードのバージョンをサフィックスとして指定する必要があります。 これは想定外のコードを使わないようにするための安全策です。 最新コードを信用してよいのであれば、次のように @latest を指定してインストールします。 $ go install github.com/maku77/go-hello@latest もう少しお行儀よくやるには、GitHub のコードにバージョンタグを付けておき、次のようにバージョンを指定してインストールします。 $ go install github.com/maku77/go-hello@v1.0.0 下記のように実行ファイルができていれば、うまくインストールできています。 $ ls `go env GOPATH`/bin go-hello $ go-hello Hello, world! 複数のコマンドを提供する 前述の例では、モジュール名を github.com/maku77/go-hello として、go-hello という名前のコマンド作成しました。 1 つのモジュールで複数のコマンドを提供したい場合は、コマンドごとにディレクトリを作成して、その中にそれぞれの main パッケージを構成します。 典型的なディレクトリ構成 としては、cmd ディレクトリを作って、その中にコマンド名と同名のディレクトリを作成します。 例えば、go-hello モジュール内に hello1 コマンドと hello2 コマンドを作成するには次のようなディレクトリ構成にします。 go-hello/ +- go.mod +- cmd/ +- hello1/main.go （hello1 コマンド用の main パッケージ） +- hello2/main.go （hello2 コマンド用の main パッケージ） go-hello/cmd/hello1/main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello 1\u0026#34;) } go-hello/cmd/hello2/main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello 2\u0026#34;) } 各コマンド用のディレクトリを go run で指定すれば実行できます。 ディレクトリ名は ./ で始まる相対パスで指定することに注意してください。 $ go run ./cmd/hello1 Hello1 $ go run ./cmd/hello2 Hello2 go run の代わりに go install を使えば、システムにコマンドをインストールできます。 $ go install ./cmd/hello1 $ go install ./cmd/hello2 # 次のようにまとめてインストールすることも可能です $ go install ./... これらのコードを GitHub にプッシュして公開すれば、世界中の人が次のように簡単にコマンドをインストールできるようになります。 $ go install github.com/maku77/go-hello/cmd/hello1@v1.0.0 $ go install github.com/maku77/go-hello/cmd/hello2@v1.0.0 # あるいは次のようにまとめてインストール $ go install github.com/maku77/go-hello/cmd/...@v1.0.0"},{url:"/p/s258beh/",title:"Go のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin)",date:"2022-04-10T00:00:00Z",body:"Go のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin) go install コマンドで Go の実行可能コマンドをインストールすると、次のようなディレクトリにコマンドがインストールされます。 GOBIN 環境変数が設定されていれば、$GOBIN が指すディレクトリ GOPATH 環境変数が設定されていれば、$GOPATH/bin が指すディレクトリ $HOME/go/bin ディレクトリ これらのディレクトリに OS のパスを通しておくと、どのディレクトリからでもインストールしたコマンドを実行できるようになります。 Linux や macOS であれば、~/.zlogin や ~/.bash_profile で次のような感じで設定できます。 ここでは、GOBIN 環境変数を設定して、コマンドのインストール先を ~/bin に設定しています。 ~/.zlogin export GOBIN=~/bin export PATH=$PATH:$GOBIN でも、なんだかんだ言って次のような標準的な構成にしておくとトラブルが少なくてよい気がします。 ~/.zlogin export GOPATH=$HOME/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN Windows の場合は、コントロールパネルの「環境変数を編集」から次のような感じで設定します（%USERPROFILE% 以外の変数を参照すると、うまく展開できなくて問題が出たりするので注意）。 GOPATH → %USERPROFILE%\\go GOBIN → %USERPROFILE%\\go\\bin PATH → %USERPROFILE%\\go\\bin （を PATH に追加） 上記のようにパスを通しておけば、go install でインストールしたコマンドを、どこからでも実行できるようになります。 $ go install github.com/maku77/go-hello@latest $ go-hello Hello, world!"},{url:"/p/3x95seb/",title:"nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager)",date:"2022-03-13T00:00:00Z",body:"nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager) nvm (Node Version Manager) とは？ nvm というコマンドラインツールを使うと、システム内に複数バージョンの Node.js 実行環境をインストールして、切り替えて使うことができるようになります。 $ nvm use 16 # node コマンドを version 16.x.x に切り替え $ nvm use 14 # node コマンドを version 14.x.x に切り替え 新しいバージョンの Node.js を試してみたいときや、複数バージョンでテストを行いたい場合に便利です。 nvm はスタンドアローン版の Node.js とも共存できるので、安心してインストールすることができます。 nvm を使わずにインストールされた Node.js は、system という名前で参照できるようになっています。 $ nvm use system # node コマンドをスタンドアローン版に切り替え nvm のインストール nvm コマンドは次のように簡単にインストールできます。 macOS や Linux の場合 $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 最新バージョンのインストール方法は nvm-sh/nvm - GitHub の公式サイトで確認してください。 インストール後は、ターミナル（bash など）を再起動するか、source ~/.bashrc を実行すると nvm コマンドを実行できるようになります。 Windows の場合 nvm はもともと Linux 系のコマンドラインツールとして作成されていますが、Windows でも nvm-windows のインストーラー を使えば簡単にインストールできます。 nvm の使い方 nvm が現在アクティブにしている Node.js のバージョンを調べるには、nvm current コマンドを使用します。 $ nvm current system 上記のように system と表示される場合は、システムにすでにインストールされている（nvm を使わずにインストールした）Node.js がアクティブになっています。 まだ Node.js がインストールされていない環境の場合は none と表示されます。 システムにインストールされた Node.js 実行環境は必要なくなるので、不要なグローバルパッケージをアンインストールしておくとよいかもしれません（npm root -g で表示されたディレクトリをクリアする方法もあります）。 $ npm list -g # グローバルパッケージの一覧を表示 $ sudo npm uninstall -g XXXX # 不要なパッケージをアンインストール nvm で特定のバージョンの Node.js をインストールしたいときは、nvm install コマンドを使用します。 次の例では、メジャーバージョン 16 の最新の Node.js をインストールしています。 最新の LTS （長期サポート）バージョンをインストールしたいときは、--lts オプションを指定します。 最新バージョンをインストールしたいときは、node というエイリアス名を使用します。 $ nvm install 16 # メジャーバージョンを指定してインストールする場合 Downloading and installing node v16.14.0... $ nvm install --lts # 最新の LTS 版をインストールする場合 Installing latest LTS version. v16.14.0 is already installed. $ nvm install node # 最新バージョンをインストールする場合 Downloading and installing node v17.7.1... Node.js 環境を追加インストールすると、自動的にそのバージョンがアクティブになります。 $ nvm current v16.14.0 $ node -v v16.14.0 使用する Node.js のバージョンを切り替えるには、nvm use コマンドを使用します。 $ nvm use system # システムインストールされた Node.js を使う $ nvm use 16 # nvm でインストールしたバージョン 16 の Node.js を使う インストールされている Node.js の一覧を表示するには、nvm ls コマンドを使用します。 $ nvm ls v14.19.0 -\u0026gt; v16.14.0 system default -\u0026gt; 16 (-\u0026gt; v16.14.0) ... stable -\u0026gt; 16.14 (-\u0026gt; v16.14.0) (default) ... lts/gallium -\u0026gt; v16.14.0 現在アクティブになっているバージョンには、行頭に -\u0026gt; が表示されています。 上記の例では、v16.14.0 がアクティブになっていることが分かります。 default -\u0026gt; 16 のように矢印の左側に表示されている名前は、具体的なバージョンのエイリアス名を示しており、default などのエイリアス名が自動的に生成されます。 このエイリアスの仕組みによって、次のコマンドはいずれも v16.14.0 の切り替えを意味します。 $ nvm use 16 $ nvm use 16.14 $ nvm use v16.14.0 $ nvm use default $ nvm use stable $ nvm use lts/gallium $ nvm use --lts （参考までに LTS はオプションでも指定可能） default となっているのは、その名の通り、ターミナル起動時（bash シェル起動時）にデフォルトで有効になるバージョンとして扱われます。 nvm alias コマンドで、デフォルトのバージョンを変更することができます（この default エイリアスの実体は、~/.nvm/alias/default というファイルです）。 $ nvm alias default 14 ちなみに、各バージョンの Node.js 実行環境は、~/.nvm ディレクトリ以下にインストールされていきます。 npm install -g でグローバルインストールした NPM パッケージも、各バージョンごとに管理されます（node_modules ディレクトリの場所は npm root -g で確認できます）。 多くのバージョンの Node.js をインストールすると、ホームディレクトリのサイズが肥大化していくので注意してください（1 バージョンごとに 100 MB くらい消費していきます）。 必要のなくなったバージョンは適宜、nvm uninstall で削除しましょう。 $ nvm uninstall 14 （応用）最新環境に同じ NPM パッケージをインストールする 前述の通り、nvm install node コマンドを使用すると、最新の Node.js バージョンをインストールすることができますが、新しい環境の NPM グローバルパッケージはひとつずつ入れ直す必要があります。 現在アクティブになっている Node.js 環境にインストールされている NPM グローバルパッケージを、最新の Node.js 環境にすべてインストールするには次のように --reinstall-packages-from オプションを使用します。 $ nvm install node --reinstall-packages-from=current このオプションには、任意のエイリアス名を指定できます。 # 現在の最新環境 (node) にインストールされているパッケージを引き継ぐ $ nvm install node --reinstall-packages-from=node # 特定のバージョンにインストールされているパッケージを引き継ぐ $ nvm install node --reinstall-packages-from=16 デフォルトでは NPM パッケージのバージョンはすべて引き継がれますが、--latest-npm オプションを指定することで、最新の NPM パッケージをインストールすることができます。 新しい Node.js 環境では、新しいバージョンの NPM パッケージが必要になることも多いため、このオプションは指定しておいた方がいいかもしれません。 $ nvm install node --reinstall-packages-from=node --latest-npm （応用） .nvmrc ファイルで Node.js バージョンを揃える Node.js プロジェクトのルートディレクトリに .nvmrc ファイルを置くと、そのプロジェクトが想定する Node.js のバージョンを示すことができます。 例えば、プロジェクトで Node.js バージョン 14.19.x を使用するように統一したい場合は、次のように .nvmrc ファイルを作成して、Git などにコミットしておきます。 $ echo 14.19 \u0026gt; .nvmrc このディレクトリより下のディレクトリで nvm install を引数なしで実行すると、.nvmrc に記述されたバージョンの Node.js がインストールされます。 $ nvm install Found \u0026#39;/Users/maku/myapp/.nvmrc\u0026#39; with version \u0026lt;14.19.0\u0026gt; Downloading and installing node v14.19.0... アクティブな Node.js バージョンを切り替える場合も、nvm use を引数なしで実行するだけで済みます。 $ nvm use Found \u0026#39;/Users/maku/myapp/.nvmrc\u0026#39; with version \u0026lt;14.19.0\u0026gt; Now using node v14.19.0 (npm v6.14.16) このように、nvm さえ入れておけば、プロジェクト全体で使用する Node.js のバージョンを簡単に揃えることができます。"},{url:"/p/z3n4hye/",title:"Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する",date:"2022-03-01T00:00:00Z",body:"Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する マルチステージビルドとは？ ある GitHub のリポジトリに、Dockerfile と src/hello.go（Go 言語のコード）が入っているとします。 myapp/ +-- Dockerfile （アプリのビルド＆実行コンテナイメージの生成用） +-- src/hello.go （Hello World アプリのソースコード） この Dockerfile で作成したいのは、Go ソースコードをビルドしてできた hello アプリを実行するための Docker イメージです。 つまり、この Dockerfile ファイルには、次のようなイメージ生成手順を記述することになります。 src/hello.go をビルドして、実行ファイル hello を生成する。 hello を実行するための Docker コンテナイメージを生成する。 ここで 1 つ疑問が出てきます。 最終的な Docker イメージでは hello アプリの実行環境さえ整っていればよいはずですが、上記の手順通りに Docker イメージを構築すると、Go 言語のビルド環境まで含まれてしまいそうです。 hello アプリを実行するための軽量なイメージを作るにはどうしたらよいでしょうか？ このようなケースで便利なのが、Docker の マルチステージビルド です。 なお、アプリのソースコード (src/hello.go) には何を使ってもよいのですが、ここでは次のような簡単な Hello World コードを使うことにします。 src/hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Printf(\u0026#34;Hello World\\n\u0026#34;) } シングルステージビルドの場合 マルチステージビルドの効果を実感するために、まずはシングルステージによるビルド（従来のビルド方法）で Docker コンテナをビルドしてみます。 Dockerfile（シングルステージビルド） FROM golang:1.17 WORKDIR /work COPY src . RUN go build hello.go CMD [\u0026#34;./hello\u0026#34;] Go ソースコードのビルドを行うために、golang:1.17 をベースイメージとして使用しています。 ビルド手順はシンプルで、ホスト側の src ディレクトリ以下の Go ソースコードをコンテナ側の /work にコピーして、go build でビルドしているだけです。 次のように実行すれば、Docker イメージ (img-hello) が生成されます。 $ docker image build -t img-hello . 完成したイメージからコンテナを起動してみます。 Dockerfile に CMD 命令を記述しているので、次のようにするとデフォルトで ./hello アプリが実行されます。 --rm オプションを指定しておくと、実行後にコンテナを自動で削除してくれるので、一時的にコンテナを起動したいときに便利です。 $ docker container run --rm img-hello Hello World やったー！ うまく動いたー！ さっそくこの実行イメージを配布しよう！ ・・・・・・ ちょっと待って！！！ 作った Docker イメージ (img-hello) のサイズを見てみましょう。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE img-hello latest bcfd5668d079 About a minute ago 943MB 単純な Hello World アプリを実行したいだけなのに、Docker イメージのサイズが 1GB 弱もあります。 これは、ベースイメージの golang に Go 言語用のビルド環境がたくさん詰まっているからです。 Hello World アプリを実行するだけであれば、Go 言語のビルド環境は必要ないはずです。 そこで、マルチステージビルドの出番です。 マルチステージビルドの場合 マルチステージビルドを行うには、Dockerfile に 複数の FROM 命令 を含めます。 つまり、複数のベースイメージを切り替えながらビルドを進めていきます。 最終的なイメージは、最後の FROM 命令で指定したベースイメージをもとに生成されます。 構造的には次のような感じになります。 FROM xxx ... FROM yyy ... FROM zzz ... この場合、最終的に生成される Docker イメージは、ベースイメージ zzz を使って構築されます。 つまり、zzz には、アプリを実行するのに必要かつ最小限のベースイメージを指定すればよいことになります。 今回の hello アプリの場合は、次のような Dockerfile になります。 Go 言語のビルドでは、対象 OS やアーキテクチャを指定できるので、ここでは Linux の AMD64 環境をターゲットとして指定しています (GOOS=linux GOARCH=amd64)。 もちろん、実行環境のベースイメージはこのアーキテクチャに合わせる必要があります。 Dockerfile（マルチステージビルド） # 1st ステージ -- Go ソースコードをビルドするためのステージ FROM golang:1.17 AS builder WORKDIR /work COPY src . RUN GOOS=linux GOARCH=amd64 go build hello.go # 2nd ステージ -- 最終的な実行イメージを生成するためのステージ FROM amd64/alpine:3.15 WORKDIR /bin COPY --from=builder /work/hello . CMD [\u0026#34;./hello\u0026#34;] 1st ステージは、golang:1.17 イメージを使って Go ソースコードをビルドする役割を担います。 FROM 命令で、次のように AS builder としてエイリアス名 (builder) を割り当てていますが、これは後段のステージで、1st ステージ内で生成したファイルを参照しやすくするためのものです。 FROM golang:1.17 AS builder 2nd ステージは最終的な Docker イメージを生成する役割を担うので、FROM 命令で軽量な Alpine Linux を指定しています。 FROM alpine:3.15 そして、1st ステージで生成したアプリの実行ファイル /work/hello を /bin/hello にコピーしています。 WORKDIR /bin COPY --from=builder /work/hello . ここの --from=builder オプションで、1st ステージのファイルを参照することを示しています。 1st ステージの FROM 命令でエイリアス名を付けていない場合は、--from=0 のように番号で参照することもできますが、できるだけエイリアス名を付けておいた方がよいでしょう。 ビルド方法は、シングルステージビルドの場合と同様です。 $ docker image build -t img-hello . 実行方法も同じです。 $ docker container run --rm img-hello Hello World 最後に、マルチステージビルドによって生成された Docker イメージのサイズを確認してみます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE img-hello latest 638578ac0bdc About a minute ago 7.37MB なんと、イメージサイズが 100 分の 1 以下になりました！ このサイズであれば気楽に配布できそうです (^-^)"},{url:"/p/cqar8o5/",title:"Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp)",date:"2022-02-21T00:00:00Z",body:"Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp) docker container cp コマンドを使用すると、Docker コンテナ内の任意のファイルやディレクトリを、ホスト PC にコピーすることができます。 例えば、以下のようにすると、mycon コンテナ内の /work/hello というファイルを、ホスト側のカレントディレクトリにコピーすることができます。 $ docker container cp mycon:/work/hello ./ ディレクトリごと丸ごとコピーすることもできます。 $ docker container cp mycon:/work/imgs ./imgs 逆に、ホスト側のファイルを Docker コンテナにコピーすることもできます。 $ docker container cp hoge.txt mycon:/work/tempdir"},{url:"/p/hxhzgxf/",title:"Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfs マウント）",date:"2022-01-25T00:00:00Z",body:"Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfs マウント） Docker の 3 種類のマウント Docker コンテナ内で作成・編集した作業ファイルは、コンテナを停止 (docker container stop) しても消えてしまうことはありませんが、コンテナを削除 (docker container rm) した場合には消えてしまいます。 これは、コンテナ内のファイル群が、コンテナ内に閉じて存在しているからです（だからこそコンテナなのですが）。 Docker のマウント機能を用いると、コンテナ内の特定のディレクトリパス（の中のファイル群）をホスト PC 上のファイルシステムに関連付けることができるため、コンテナのライフサイクルとは切り離して作業ファイルを管理できるようになります。 マウントには下記で説明する 3 種類がありますが、作業ファイルをホスト PC 側に永続化したい場合は、「ボリュームマウント」か「バインドマウント」というマウントタイプを使用します。 もうひとつの「tmpfs マウント」は、その名のとおりテンポラリファイルにのみ使用できます。 図: Docker の 3 種類のマウント（公式サイトより） ボリュームマウント ホスト PC 上にコンテナ用のデータファイルを作成 し、コンテナ内の特定のディレクトリパスにマッピングします。 このデータファイルはポータビリティが高く、クラウド上に保存するということもできます（ボリュームドライバーが必要）。 複数のコンテナから 1 つのボリュームを共有することも可能です。 コンテナ内で作成したファイルの永続化には、このボリュームの使用が推奨されています。 バインドマウント ホスト PC の特定のディレクトリ（絶対パス指定） を、コンテナ内の特定のディレクトリパスにマッピングします。 ボリュームと比べてポータビリティが低いため、名前付きボリュームの使用が推奨されてます。例えば、バインドマウントでは、ホスト側の多数のファイルとマッピングされてしまうため別環境に移しにくいとか、マウント時のパス表現が OS に依存してしまうといった欠点があります。 ホスト側からコンテナで操作したファイルをささっと覗いて見たいときはバインドマウントは便利ですが、これはコンテナ内で作成した危険なファイルが、そのままホスト上にも作られてしまうということを示しています。 tmpfs マウント ホスト PC のメモリ領域 を、コンテナ内の特定のディレクトリパスにマッピングします。コンテナ上でファイル生成を行うと、実際には一時的なメモリ領域に保存されることになるので、ここに保存されたファイルはコンテナを停止すると消えてしまいます。一時的なファイルを格納するディレクトリを tmpfs マウントすることで、コンテナサイズの増加を防ぐことができ（書き込みレイヤーに出力されない）、パフォーマンスの向上を見込めます。 上記で、「ホスト PC」といっているのは Docker コンテナの実行環境のことであり、Windows や macOS で Docker Desktop を使用している場合は、正確には Linux VM のことを示します。 ボリュームマウント (volume mount) の使い方 コンテナ内での作業内容（生成したファイル）をホスト PC 側に永続化したいときに最初に検討すべきは「ボリューム」の使用です。 ボリュームの実体はホスト PC 上のファイルシステム（Docker 管轄下）に永続化されたファイルであり、コンテナ側から見ると「ディレクトリ」として見えます。 ボリュームを作成する (docker volume create) ボリュームを明示的に作成するには次のように実行します（コンテナ実行時に自動生成することも可能です）。 ボリューム名を明示するので、名前付きボリューム (named volume) と呼ばれています。 $ docker volume create my-vol ボリュームの一覧を表示する (docker volume ls) Docker ホスト上に存在しているボリュームの一覧を表示するには、次のように実行します。 $ docker volume ls DRIVER VOLUME NAME local e61a091c345b2b969dd288f984be... local my-vol ← 今回作成したボリューム local out （ボリューム名がランダムな記号列になっているものは、匿名マウント時に自動生成されたボリュームです） ボリュームの詳細情報を表示する (docker volume inspect) 指定したボリュームの詳細情報を確認するには次のようにします。 $ docker volume inspect my-vol [ { \u0026#34;CreatedAt\u0026#34;: \u0026#34;2022-01-25T07:18:24Z\u0026#34;, \u0026#34;Driver\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;Labels\u0026#34;: null, \u0026#34;Mountpoint\u0026#34;: \u0026#34;/var/lib/docker/volumes/my-vol/_data\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;my-vol\u0026#34;, \u0026#34;Options\u0026#34;: null, \u0026#34;Scope\u0026#34;: \u0026#34;local\u0026#34; } ] ボリュームを削除する (docker volume rm/prune) # ボリューム名を指定して削除 $ docker volume rm my-vol # 未使用のボリューム（どのコンテナからも参照されていないもの）をすべて削除 $ docker volume prune ボリュームマウントしてコンテナを起動する コンテナ側の /volume というパスに、上記で作成した my-vol ボリュームをマウントして使ってみます。 ここでは、軽量の Alpine Linux イメージ (alpine:latest) を使ってコンテナを作成します。 # コンテナ (my-alpine) の作成 $ docker container create -it --mount src=my-vol,dst=/volume --name my-alpine alpine:latest # コンテナが作成できているか確認 $ docker container ls -a --mount オプションの src や dst で、ボリューム名やマウント先のパスを指定します。 src=\u0026lt;ボリューム名\u0026gt; … src ではなく source でも OK。存在しないボリューム名を指定すると、その名前のボリュームが自動的に生成されます。src パラメーターを省略すると、ランダムな16進文字列の名前のボリュームが生成されます。 dst=\u0026lt;コンテナ側のパス\u0026gt; … dst ではなく destination や target でも OK。 type=\u0026lt;マウントタイプ\u0026gt; … ボリュームマウントの場合は省略できます。マウントタイプとして volume、bind、tmpfs を指定します。 （過去の記事には、-v オプションを使っているものもありますが、現在は公式に --mount オプションの使用が推奨されています（挙動がわかりにくく問題が発生しやすいなどの理由があります）。特別な事情がない限り、--mount オプションの方を使うようにしてください） コンテナを作成したら、次のようにして起動してシェル接続できます。 $ docker start -ai my-alpine コンテナ側の /volume というディレクトリが見えているかを確認してください。 この中にファイルを作成すると、ホスト OS 側のボリューム領域に内容が保存されるので、次回コンテナを起動 (docker start) したときにファイル編集作業の続きを行えます。 my-volume ボリュームを他のコンテナにマウントして共有するということもできます。 # ls /volume # 初期状態は空っぽ # echo Hello \u0026gt; /volume/hello.txt # exit ボリュームファイルの格納場所 ボリュームのデータファイルは具体的にはホスト PC の /var/lib/docker/volumes に生成されますが、ボリュームは docker volume コマンドを介して操作するので、通常は保存先のパスを意識する必要はありません。 Windows や macOS で Docker Desktop を使用している場合は、Volumes タブでボリュームの一覧を確認することができます（Docker Desktop のバックエンドとして使われる Linux VM 上に格納されているため、Windows や macOS 上で上記のパスを探しても見つからないことに注意してください）。 図: Docker Desktop によるボリュームの確認 バインドマウント (bind mount) の使い方 バインドマウントは、ホスト OS 上のディレクトリをコンテナ側のディレクトリにマッピングします。 つまり、お互いのファイルシステム上で同じディレクトリ／ファイルを参照できるようになります。 次の例では、ホスト OS 上のカレントディレクトリにある data ディレクトリを、コンテナ側の /data にマウントしています。 ホスト OS 側のディレクトリは、存在するディレクトリを絶対パスで指定する必要があります（次の例では、\u0026quot;$(pwd)/data\u0026quot; で絶対パスを生成しています）。 $ mkdir data $ docker container create -it --mount type=bind,src=\u0026#34;$(pwd)/data\u0026#34;,dst=/data --name my-alpine alpine:latest バインドマウントするときは、上記のように --mount オプションで type=bind と指定する必要があります。 コンテナを起動してシェル接続し、適当なファイルを /data ディレクトリ以下に作成してみます。 $ docker container start -ai my-alpine # echo Hello \u0026gt; /data/hello.txt # exit ホスト OS 側で data ディレクトリを見ると、コンテナで作成したファイルが存在していることを確認できます。 $ ls data hello.txt tmpfs マウントの使い方 tmpfs マウントを使用すると、ホスト OS 上のメモリ領域を一時ファイルシステムとして、コンテナ側のディレクトリにマッピングすることができます。 結果として、そのディレクトリ内に保存したファイルは、コンテナを停止したときに削除されます。 一時的にしか使用しないファイルは、tmpfs マウントしたディレクトリ内に作成することで、Docker イメージの肥大化を防ぐことができます。 また、そのファイルはメモリ上に生成されるため、パフォーマンス的にも有利です。 $ docker container create -it --mount type=tmpfs,dst=/sandbox --name my-alpine alpine:latest tmpfs マウントするときは、上記のように --mount オプションで type=tmpfs と指定する必要があります。 この例では、コンテナ側の /sandbox ディレクトリを tmpfs マウントのターゲットとしています。 コンテナを起動して /sandbox 内にファイルを作成し、コンテナを停止してみます。 $ docker start -ai my-alpine # echo Hello \u0026gt; /sandbox/hello.txt # exit 再度コンテナを起動して /sandbox の中を見ると、上記で作成した hello.txt は消えていることがわかります。 $ docker start -ai my-alpine # ls /sandbox #"},{url:"/p/wyxzbdw/",title:"Python でファイルやディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move)",date:"2021-08-10T00:00:00Z",body:"Python でファイルやディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move) ファイルやディレクトリのコピーや移動を行うには、Python 標準ライブラリの shutil モジュール が提供する高水準のファイル操作 API を利用するのが簡単です。 ファイルをコピーする (shutil.copyfile, shutil.copy) shutil.copyfile 関数 shutil.copyfile 関数 で単一のファイルをコピーできます。 import shutil import sys try: shutil.copyfile(\u0026#39;src.txt\u0026#39;, \u0026#39;dst.txt\u0026#39;) except Exception as e: print(\u0026#39;Error: {0}\u0026#39;.format(e), file=sys.stderr) 同名のファイルがすでに存在する場合（上記の場合は dst.txt）は上書きされます。 shutil.copyfile 関数は次のようなエラーを発生させる可能性があります。 IsADirectoryError \u0026hellip; コピー先として指定したファイル名と同名のディレクトリが存在する場合。 OSError \u0026hellip; 指定したファイル名で書き込めない場合（バージョン 3.3 以降）。 SameFileError \u0026hellip; コピー元とコピー先のファイル名が同じ場合（バージョン 3.4 以降）。 FileNotFoundError \u0026hellip; 存在しないディレクトリ階層（aaa/bbb/dst.txt など）にコピーしようとした場合。 shutil.copy 関数 既存のディレクトリ以下に同じファイル名でコピーしたいときは、shutil.copyfile の代わりに shutil.copy 関数 を使用します。 # dst という名前でコピー、あるいは dst ディレクトリ以下にコピー shutil.copy(\u0026#39;src.txt\u0026#39;, \u0026#39;dst\u0026#39;) 上記のように実行すると、dst ディレクトリがない場合は dst というファイル名でコピーされ、dst ディレクトリが存在する場合は dst/src.txt としてコピーされます。 shutil.copyfile と shutil.copy の使い分け copyfile 関数と copy 関数の振る舞いの違いをまとめておきます。 違いは、ターゲットと同じ名前のディレクトリが存在しているときの振る舞いです。 shutil.copyfile('src.txt', 'dst') dst が存在しないとき: dst としてコピー dst ファイルが存在するとき: dst ファイルを上書き dst ディレクトリが存在するとき: エラー (IsADirectoryError) shutil.copy('src.txt', 'dst') dst が存在しないとき: dst としてコピー dst ファイルが存在するとき: dst ファイルを上書き dst ディレクトリが存在しないとき: dst/src.txt としてコピー なお、shutil.copyfile も shutil.copy もディレクトリをコピーすることはできません（IsADirectoryError が発生します）。 ディレクトリをコピーする (shutil.copytree) shutil.copytree 関数 を使用すると、指定したディレクトリを丸ごとコピーできます。 次の例では、src ディレクトリを dst ディレクトリとしてコピーします。 import shutil shutil.copytree(\u0026#39;src\u0026#39;, \u0026#39;dst\u0026#39;) すでにカレントディレクトリに dst という名前のファイルやディレクトリが存在する場合は FileExistsError が発生します。 ただし、次のように dirs_exist_ok フラグを True に設定すると、dst ディレクトリが存在していてもそのままコピーしようとします（dst 内のファイル群が上書きされるという動作になります）。 import shutil shutil.copytree(\u0026#39;src\u0026#39;, \u0026#39;dst\u0026#39;, dirs_exist_ok=True) shutil.copytree 関数には面白い機能が付いていて、次のように ignore パラメーターを利用すると、グロブパターンに一致したファイルやディレクトリをコピー対象から外すことができます（バージョン 3.8 以降）。 from shutil import copytree, ignore_patterns copytree(src, dst, ignore=ignore_patterns(\u0026#39;*.pyc\u0026#39;, \u0026#39;tmp*\u0026#39;)) ファイルやディレクトリを移動する (shutil.move) ファイルやディレクトリの移動は単純で、shutil.move 関数 一種類だけで実現できます。 import shutil shutil.move(\u0026#39;src\u0026#39;, \u0026#39;dst\u0026#39;) 上記のようにすると、src ファイル（あるいはディレクトリ）を、dst という名前に変更します。 すでに dst という名前のディレクトリが存在している場合は、dst ディレクトリ内に移動させようとします（dst/src ができる）。 つまり、Linux の mv コマンドのように振る舞います。 確実にリネームだけを実行したい場合は、os.rename 関数を使ってください。 参考: Python でファイルやディレクトリの名前を変更する (os.rename, os.renames) ファイルの存在を確認しておくのが安全 (os.path.exists) 基本的には、ファイルやディレクトリの移動やコピーを行う場合は、os.path.exists 関数 を使って、あらかじめ同名のファイルやディレクトリが存在していないかをチェックしておくのが安全です。 import os import shutil def check_and_copy(src, dst): \u0026#34;\u0026#34;\u0026#34; ファイルをコピーします。 すでに同名のファイルが存在する場合は、確認プロンプトを表示します。 \u0026#34;\u0026#34;\u0026#34; if os.path.exists(dst): if input(\u0026#39;Overwrite?(y/n): \u0026#39;) != \u0026#39;y\u0026#39;: return shutil.copyfile(src, dst) check_and_copy(\u0026#39;src\u0026#39;, \u0026#39;dst\u0026#39;)"},{url:"/p/vexfweu/",title:"Python の dictionary の内部的な要素順序を変更する (dict, OrderedDictionary)",date:"2021-07-24T00:00:00Z",body:"Python の dictionary の内部的な要素順序を変更する (dict, OrderedDictionary) dict が保持する要素の順序 Python の辞書オブジェクト (dict) は要素の追加順序を保持しており、要素のイテレート時や print での出力時はこの順序で出力されるようになっています（Python 3.7 以降）。 sample.py book = { \u0026#39;id\u0026#39;: \u0026#39;123\u0026#39;, \u0026#39;authors\u0026#39;: [\u0026#39;Author 1\u0026#39;], \u0026#39;title\u0026#39;: \u0026#39;Title 1\u0026#39; } print(book) 出力結果 {\u0026#39;id\u0026#39;: \u0026#39;123\u0026#39;, \u0026#39;authors\u0026#39;: [\u0026#39;Author 1\u0026#39;], \u0026#39;title\u0026#39;: \u0026#39;Title 1\u0026#39;} 単純にキー名のアルファベット順にループ処理したい場合は、例えば次のようにします。 キーのリストをソート for key in sorted(book.keys()): print(\u0026#39;%s: %s\u0026#39; % (key, book[key])) でもこれは、出力時に一時的なキーリストをソートしているだけで、辞書オブジェクト内部の要素順序を制御しているわけではありません。 次のようにすれば、あるキーの要素を辞書オブジェクト内で末尾に持ってくることができます。 book[\u0026#39;id\u0026#39;] = book.pop(\u0026#39;id\u0026#39;) 単純に id キーの要素を取り出して、再度辞書オブジェクトに追加しているだけです (^^; この後、print(book) とすると、id 要素が最後に出力されます。 もっといい方法があるかもしれませんが、この仕組みだけである程度柔軟な並び替えが可能です。 例えば、次の sort_dict 関数は、辞書オブジェクト内部の要素をキー名順に並び替える関数ですが、priority_keys 引数でキー名のリストを渡すと、それらのキーは優先的にその順番で先頭に並べられます。 sort_dict 関数の実装例 def sort_dict(d, priority_keys=()): \u0026#34;\u0026#34;\u0026#34; 辞書オブジェクト d の要素を内部的にキー名でソートします。 ただし、priority_keys にキー名のリストが指定されたときは、 そのキーを優先的に先頭に並べます。 \u0026#34;\u0026#34;\u0026#34; keys1 = list(filter(lambda k: k in d, priority_keys)) keys2 = sorted(d.keys() - keys1) for k in (keys1 + keys2): d[k] = d.pop(k) 下記はこの sort_dict 関数の使用例です。 book オブジェクト内のキーをアルファベット順にソートしつつ、id と title キーは優先的に先頭に並べるようにしています。 sort_dict 関数の使用例 import json book = { \u0026#39;authors\u0026#39;: [\u0026#39;Maku\u0026#39;, \u0026#39;Ponyo\u0026#39;, \u0026#39;Chi\u0026#39;], \u0026#39;title\u0026#39;: \u0026#39;Title 1\u0026#39;, \u0026#39;id\u0026#39;: \u0026#39;123\u0026#39;, \u0026#39;note\u0026#39;: \u0026#39;Very interesting\u0026#39; } sort_dict(book, (\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;)) print(json.dumps(book, indent=2)) 実行結果 { \u0026#34;id\u0026#34;: \u0026#34;123\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Title 1\u0026#34;, \u0026#34;authors\u0026#34;: [ \u0026#34;Maku\u0026#34;, \u0026#34;Ponyo\u0026#34;, \u0026#34;Chi\u0026#34; ], \u0026#34;note\u0026#34;: \u0026#34;Very interesting\u0026#34; } OrderedDict について ちなみに、Python は dict のサブクラスとして collections.OrderedDict クラスを用意しています。 通常の dict が要素の追加順序を保持するようになった今、OrderedDict の出番はあまり多くないかもしれませんが、OrderedDict は独自のメソッドを備えていたりします。 例えば、指定した要素を末尾か先頭に移動させる move_to_end(key, last=True) メソッドがあります。 sample.py from collections import OrderedDict book = OrderedDict({ \u0026#39;title\u0026#39;: \u0026#39;Title 1\u0026#39;, \u0026#39;authors\u0026#39;: [\u0026#39;Author 1\u0026#39;], \u0026#39;id\u0026#39;: \u0026#39;123\u0026#39; }) book.move_to_end(\u0026#39;title\u0026#39;) # title を末尾へ book.move_to_end(\u0026#39;id\u0026#39;, last=False) # id を先頭へ print(dict(book)) 実行結果 {\u0026#39;id\u0026#39;: \u0026#39;123\u0026#39;, \u0026#39;authors\u0026#39;: [\u0026#39;Author 1\u0026#39;], \u0026#39;title\u0026#39;: \u0026#39;Title 1\u0026#39;}"},{url:"/p/26hr2bk/",title:"dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認）",date:"2021-03-09T00:00:00Z",body:"dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認） Janky frames 情報を取得する Android デバイス上で実行可能なコマンド dumpsys gfxinfo を使用すると、指定したアプリにおける Janky frames（ジャンクフレーム）の発生率を調べることができます。 Janky frame の説明は「dropped frame」と書かれていたりしますが、60FPS 出ていないフレーム（16.6ミリ秒以上かかったフレーム）だと考えればよいと思います。 アプリの UI が、どの程度ぬるぬるさくさくなアニメーション (60FPS) を達成できているかを定量的に調べたいときに使えるかもしれません。 $ adb shell dumpsys gfxinfo com.example.myapp | grep frames Total frames rendered: 544 Janky frames: 242 (44.56%) 本来 dumpsys gfxinfo の出力はもっと長いのですが、上記では frames という単語で grep してフィルタしちゃってます（Windows なら findstr を使えば OK）。 Janky frames の発生率を確認したいのであれば、これが手っ取り早いです。 dumpsys gfxinfo の詳細は下記ドキュメントが参考になります。 参考: UI パフォーマンスをテストする｜Android デベロッパー フレームの計測単位 Total frames rendered は、アプリを起動してからの総フレーム数を表しています。 ただし、この数はフレームメトリクスとして計測されたフレームのみが対象で、アニメーションが発生していないときは増加しません。 これは、開発者オプションの Profile HWUI rendering を有効にしたときに、画面上にバーが増えていく速度と同じです。 図: Profile HWUI rendering Janky frames としてカウントされているのは、このバーが緑色のライン（16.6ミリ秒）を超えているもののようです（太くて濃いバーになっているもの）。 上の図の場合は、最初の30％くらいが緑色の水平ラインを超えているので、Janky frames は約30％ということです。 フレームの統計情報をリセットする 何らかのアニメーションのパフォーマンスを計測したい場合は、アプリ起動時からのフレーム統計ではなく、そのタイミングだけでの統計情報が欲しいと思います。 そのような場合は、まずは次のように Android が収集しているフレーム統計情報をリセットします。 $ adb shell dumpsys gfxinfo \u0026lt;PACKAGE_NAME\u0026gt; reset リセットしたいだけでも統計情報がだらだらと表示されてしまうので、Linux なら \u0026gt; /dev/null、Windows なら \u0026gt; nul にリダイレクトして出力を消した方がいいかもしれません。 その後、何らかのユーザー操作を発生して、再度 dumpsys gfxinfo で統計情報を確認すれば OK です。 ちなみに、開発者オプションの Profile HWUI rendering で画面上に GPU バーを表示している場合、上記のリセットコマンドを実行すると、このバー表示もクリアされます（内部で同じ gfxinfo 情報を参照していることが分かります）。 （応用）ユーザー操作 → パフォーマンス計測を自動化 次のバッチファイルは、次のような操作を自動化しています。 com.example.myapp アプリのフレーム統計情報をリセット 1 秒待つ 下キーを 30 回押す（リスト UI などをスクロールさせることを想定） 1 秒待つ フレーム統計情報 (Janky frames) を出力 janktest.cmd @echo off adb shell dumpsys gfxinfo com.example.myapp reset \u0026gt; nul timeout /t 1 /nobreak \u0026gt; nul FOR /L %%A IN (1, 1, 30) DO ( adb shell input keyevent DPAD_DOWN ) timeout /t 1 /nobreak \u0026gt; nul adb shell dumpsys gfxinfo com.example.myapp | findstr frames 実行例 C:\\\u0026gt; janktest.cmd （自動操作が終わるまでしばらく待つ） Total frames rendered: 400 Janky frames: 200 (50.00%) うーむ、60FPS 安定までの道のりは長いです。。。 参考: ADB からキー入力やテキスト入力を行う (input text, input keyevent)"},{url:"/p/ehu5eox/",title:"Perfetto でシステム全体のパフォーマンスを計測する",date:"2021-03-09T00:00:00Z",body:"Perfetto でシステム全体のパフォーマンスを計測する Perfetto とは Android 端末のシステム全体のプロファイリングを行うには、Perfetto というツールを使用します。 システム全体の動作を調査する場合、従来は Systrace を使っていましたが、Android 10 (Q) 以降は、より洗練された Perfetto で分析を行うことができます。 Perfetto - System profiling, app tracing and trace analysis - Perfetto Tracing Docs Android には Perfetto 用のトレースデーモンと、トレースデータを取得するための perfetto コマンドが標準搭載されています。 取得したトレースデータは、Perfetto の Web アプリ (Perfetto UI) から読み込んで、グラフィカルな UI で分析を行うことができます。 開発 PC と Android 端末が Bluetooth や USB 接続されていれば、Perfetto UI から直接トレースデータを取得することができます。 Perfetto デーモンの有効化 （この設定は、Android 10 (Q) の端末でのみ必要です。Android 11 (R) 以降は必要ありません） perfetto コマンドでトレースを開始するには、Android 端末上で Perfetto デーモンを起動しておく必要があります。 次のようにシステムプロパティを設定すれば、Perfetto デーモンが起動します。 $ adb shell setprop persist.traced.enable 1 これは persist プレフィックスの付いたプロパティなので、設定が不揮発メモリに保存されます。 Android 端末を再起動したときに設定しなおす必要はありません。 正しく Perfetto デーモンが起動していれば、次のような Logcat ログが出力されます。 $ adb logcat -s perfetto --------- beginning of main 03-09 21:38:37.139 21766 21766 I perfetto: probes.cc:56 Starting /system/bin/traced_probes service 03-09 21:38:37.140 21765 21765 W perfetto: service.cc:65 Started traced, listening on /dev/socket/traced_producer /dev/socket/traced_consumer 03-09 21:38:37.141 21766 21766 I perfetto: probes_producer.cc:88 Connected to the service Perfetto トレースデータの取得 次のように Android 端末上の perfetto コマンドを実行すると、トレース結果が /data/misc/perfetto-traces/trace ファイルとして出力されます。 出力先は -o (--out) オプションで変更できますが、SELinux のセキュリティ制限のため、/data/misc/perfetto-traces ディレクトリしか指定できないようになっています（errno: 13, Permission denied が発生します）。 $ adb shell perfetto --config :test --out /data/misc/perfetto-traces/trace --config :test というオプションは、perfetto コマンドにハードコードされたテスト設定を使用することを示しています（参考: Perfetto trace config）。 トレースファイルは下記のようにローカル PC へダウンロードできます。 $ adb pull /data/misc/perfetto-traces/trace あるいは、 $ adb shell cat /data/misc/perfetto-traces/trace \u0026gt; ~/trace 以下のようにして、ディレクトリごとダウンロードすることもできます。 $ adb pull /data/misc/perfetto-traces 取得したトレースファイルを Perfetto UI のサイト で開けば、グラフィカルに分析を行うことができます。 Perfetto のトレース設定 perfetto コマンドを実行するときにパラメーターを指定することで、計測時間や取得するデータのカスタマイズを行えます。 設定方法は大きく分けて、下記の 2 通りの方法があります。 lightweight mode -t/--time などの個々のパラメーターを 1 つずつ設定する方法。従来の systrace と同様の指定 (atrace、ftrace) を行うだけでよければこの方法が使えます。 normal mode -c/--config オプションでコンフィグファイルを指定する方法。lightweight mode より詳細なトレース設定を行うことができます。 参考: perfetto コマンドのコマンドラインオプション。 lightweight mode（個別パラメーターで指定する方法） perfetto コマンドを実行するときに、次のようなオプションを使って、トレース方法を設定する方法です。 adb shell perfetto [--time TIMESPEC] [--buffer SIZE] [--size SIZE] [ATRACE_CAT | FTRACE_GROUP/FTRACE_NAME]... -t/--time TIMESPEC \u0026hellip; トレース時間。使える単位は s、m、h（デフォルト: 10s）。 -b/--buffer SIZE \u0026hellip; リングバッファサイズ。使える単位は mb、gb（デフォルト: 32mb)。 -s/--size SIZE \u0026hellip; 最大ファイルサイズ。使える単位は mb、gb（デフォルトはリングバッファサイズ？）。 ATRACE_CAT \u0026hellip; トレースする atrace カテゴリ（例: am wm gfx view など）を指定。参考: Tracing categories（実装） FTRACE_GROUP/FTRACE_NAME \u0026hellip; トレースする ftrace グループ（カーネル系のトレース）（例: sched/sched_switch、sched/*） 例）3秒間、gfx、input、view、sched をトレースする $ adb shell perfetto -o /data/misc/perfetto-traces/trace -t 3s gfx input view sched normal mode（コンフィグファイルで指定する方法） perfetto 用の設定をコンフィグファイルの形で保存しておけば、--config オプションでそのファイル名を指定するだけで毎回同じ設定でトレースできます。 perfetto コマンドはデバイス上で実行する都合上、コンフィグファイルはデバイス上に作成しなければいけないことに注意してください。 ただ、ファイル名として - を指定すると標準入力から設定テキストを流し込むことができるので、これを使えばローカル PC 上のコンフィグファイルの内容をそのまま渡せます。 $ cat config.pbtx | adb shell perfetto -o /data/misc/perfetto-traces/trace --txt -c - Windows の場合は cat を type に置き換えてください。 下記はコンフィグファイルの記述例です。 このようなテキスト形式のコンフィグファイルを指定する場合は、-c/--config オプションに加えて、--txt オプションも同時に指定する必要があります。 コンフィグファイルの例 (perfetto-config.pbtx) duration_ms: 5000 buffers: { size_kb: 8960 fill_policy: DISCARD } data_sources { config { name: \u0026#34;linux.ftrace\u0026#34; ftrace_config { # Enables events for a specific app. atrace_apps: \u0026#34;com.example.myapp\u0026#34; # Enables all events for all apps. # atrace_apps: \u0026#34;*\u0026#34; # Enables specific system events tags. atrace_categories: \u0026#34;gfx\u0026#34; atrace_categories: \u0026#34;input\u0026#34; atrace_categories: \u0026#34;view\u0026#34; atrace_categories: \u0026#34;sched\u0026#34; # ftrace_events: \u0026#34;sched/sched_switch\u0026#34; # ftrace_events: \u0026#34;power/suspend_resume\u0026#34; # ftrace_events: \u0026#34;sched/sched_process_exit\u0026#34; # ftrace_events: \u0026#34;sched/sched_process_free\u0026#34; # ftrace_events: \u0026#34;task/task_newtask\u0026#34; # ftrace_events: \u0026#34;task/task_rename\u0026#34; # ftrace_events: \u0026#34;ftrace/print\u0026#34; } } } （応用）簡単にトレース取得できるようスクリプト化 下記のバッチファイルを実行すると、perfetto-20210309-213055.pb のようなタイムスタンプ入りのトレースファイルを作成し、ローカル PC にダウンロードします。 トレースの設定は、先頭部分の DURATION 変数や ATRACE 変数である程度柔軟にカスタマイズできます。 perfetto デーモンが起動していない場合は、設定のヒントを表示して終了するようにしています。 get-perfetto.cmd（Windows用） @echo off setlocal REM Perfetto configuration set DURATION=3s set ATRACE=gfx view input sched set FTRACE= REM Check if the perfetto daemon is enabled for /f \u0026#34;usebackq delims=\u0026#34; %%A in ( `adb shell getprop persist.traced.enable` ) do set PERFET_ENABLED=%%A if not \u0026#34;%PERFET_ENABLED%\u0026#34;==\u0026#34;1\u0026#34; ( echo Trace daemon is not started. Try the following command. echo adb shell setprop persist.traced.enable 1 exit /b ) REM Generate a filename by the current date and time set mydate=%DATE% set mytime=%TIME% set year=%mydate:~0,4% set month=%mydate:~5,2% set day=%mydate:~8,2% set hour=%mytime:~0,2% set minute=%mytime:~3,2% set second=%mytime:~6,2% set filename=perfetto-%year%%month%%day%-%hour%%minute%%second%.pb REM Start tracing adb shell perfetto --out /data/misc/perfetto-traces/%filename% -t %DURATION% %ATRACE% %FTRACE% REM Download the trace file adb pull /data/misc/perfetto-traces/%filename%"},{url:"/p/sfqyajt/",title:"Android アプリのパフォーマンス改善のためのチェックリスト",date:"2021-03-08T00:00:00Z",body:"Android アプリのパフォーマンス改善のためのチェックリスト はじめに パフォーマンスの最適化を行うには、フレームワーク特有の知識と、プロファイラによる計測 の両面から攻めていく必要があります。 アプリケーションを 60FPS の描画性能で動作させるには、1フレームあたりわずか 16.6 ミリ秒で処理を終えなければいけません。 複雑な計算処理や描画を行うアプリケーションにおいて、常に 60FPS を達成するのは非常に大変で、考えるべきことがたくさんあります。 ここでは、Android アプリのパフォーマンス改善のヒントをまとめておきます。 パフォーマンス可視化自動化のススメ 定期的にパフォーマンスに関するプロファイリングを行うのはよいことですが、もっといい方法は、パフォーマンスに関する計測を自動化＆見える化 することです。 例えば次のような仕組みを作り、普段の開発では常に有効化しておきます。 各フェーズの実行にかかった時間を、画面上に自動で表示する 画面上に FPS を表示する 各端末のパフォーマンス（メトリクス情報）を自動でサーバーに送り、統計をグラフ化する このような仕組みを作り込んでおけば、チームメンバー全員が普段からパフォーマンスを意識 して開発できるようになります。 アーキテクトだけにプロファイリング作業を任せたり、プロジェクト終盤になってからパフォーマンス計測をはじめたりするのはやめましょう。 コードを作り込んでからデータ構造やスレッド戦略を変更するのはとても大変で、手遅れになることが多いです。 上記の仕組みによって表示された結果は、製品リリースのためのパフォーマンスクライテリアを満たしているかの指標にもなります。 まずは計測 FPS の確認（1 フレームあたり何ミリ秒かかっているか） 開発者オプションから GPU バー表示を ON にして確認 GPU レンダリング速度のプロファイリング Profile HWUI rendering の設定は ADB で OFF/ON する と素早く切り替えられる 何らかの操作をしているときに、赤色のライン (16.6ms) を上回ることがないか を調べる Window.OnFrameMetricsAvailableListener でフレームごとのメトリクス情報を取得できる Firebase などを使えるのであれば、メトリクス情報をサーバー集計することが可能 Choreographer を使ってプログラム内で FPS を確認する 方法もあり adb shell dumpsys gfxinfo PKG名 | grep frames で ジャンクフレーム発生率を調べる オーバードローの確認（Debug GPU overdraw で何度も重ねて描画している部分がないか確認） レイアウトの確認（Layout Inspector で無駄なネストを確認） 全般的なボトルネックの確認 CPU Profiler でアプリ内のボトルネックを調査（Traceview はサポート終了） 各スレッドのビジー状態や、どのメソッドに時間がかかっているか を調べる → メソッド単位の最適化 GC (Garbage Collection) が頻繁に発生していないか を調べる (Perfeto/SystraceAllocation Tracker)。 Perfetto でシステム全体のボトルネックを調査 他のプロセスとの Binder 通信などがボトルネックになっていなかを調べる adb shell perfetto で計測開始するか、Perfetto の Web アプリから直接データ取得可能（要 Bluetooth/USB 接続） 昔は Systrace だったけど、Android 10 以降は Perfetto で。 改善ポイント 背景色描画の削減 背景色は、テーマ、Activity、Fragment、View のいずれかのレイヤで一回のみ指定する テーマの背景色が余計なときは、テーマの定義で android:windowbackground=\u0026quot;null\u0026quot; するか、Activity で window.setBackgroundDrawable(null) する カスタムビュー内のオーバードローをチェック onDraw 内の描画で重なって見えない部分は clipRect でマスクする。カスタムビューの描画内容は Android フレームワークが最適化することができない レイアウトをフラット化 ListView → ConstraintLayout / RelativeLayout レイアウトリソースの Inflate 時間短縮 Layout XML の Inflate 処理時間が短縮したいなら、レイアウト情報をハードコード する手もあり カスタムビューにして onDraw を実装 スレッド戦略 各種処理をどのようなスレッド上で実行するか設計する。各メソッドに スレッドアノテーション を付けてみる（Main/UI、Worker スレッド間の呼び出しで警告してくれる） Kotlin のコルーチンで実行スレッドを分ける。 Dispatcher.Main \u0026hellip; メインスレッド（ここの処理は最小限に） Dispatcher.Default \u0026hellip; ワーカースレッド（ほとんどの処理はここで実行する） Dispatcher.IO \u0026hellip; I/O アクセス、ネットワーク処理など メインスレッドの処理を極小化 例えば、Android のユーザー入力イベントはメインスレッドでハンドルされるので、ViewModel のメソッドをトリガにコルーチン起動 (viewModelScope.launch) し、その中から戻り値なしの別コンテキスト（スレッド）処理を呼び出し (withContext(Dispatcher.Default)) て、メインスレッドはそのまま抜けるようにする。画面反映は LiveData からの更新通知のタイミングで行えばよい。ViewModel クラスには戻り値を持つ public メソッド (getter) を作らないということ（それは同期処理を意味する）。 並列化できる処理を見極める 順序依存のない処理は同時に開始する ように書き換える（とくに画面遷移後の初期化処理など） 最後に Join の必要な並列処理は coroutineScope { ... async { ... }} など スレッドのキャンセル、間引き処理 キー連打や同種のイベントが連続発生する可能性がある場合は、要求をコマンド化してキューイングして間引く（Command パターン） あえてシングルスレッドでキュー処理して (SingleThreadExecutor)、新しい要求が来たらキューを空にするとか（最新要求だけ処理） 排他制御のデザインパターン 排他制御によるロック時間を最小化するパターンを学ぶ。例えば、Read-Write Lock パターンでは、Read スレッド同士は排他制御する必要がないことを示している（Java の標準クラスにも ReadWriteLock がある）。 頻繁な GC の抑制 onDraw 内でオブジェクト生成しないようにする（アニメーション中の GC 発生を抑制） ループ内で一時オブジェクトを生成しないようにする Flyweight パターンでオブジェクトを共有する オブジェクトプールでオブジェクトを使いまわす（Android の Message クラス が参考になる (Message.obtain() でプールから取得 → recycle() でプールに戻す)） その他 キャッシュ関連処理は全般的に難しいが重要 時間のかかる関数呼び出し結果はメモ化 キャッシュコントロール（いつ消すかなど）は、基本的には HTTP の Cache-Control レスポンスヘッダの stale-while-revalidate 拡張 (RFC 5861) を参考にするとよい。簡単にいうと、キャッシュで高速に描画しつつ、背後でキャッシュの更新処理を走らせるという考え方。 シーケンシャルサーチ (indexOf) 処理はマップ処理に置き換える（O(n) → O(1)） ログ出力用のオブジェクト生成（主にテキスト構築）を削除（if (DEBUG) で引数生成部分ごと囲む） 画像ファイルに PNG ではなく WebP フォーマットを使用する 起動時 (onCreate) での初期化コードは最低限にする（各種処理の遅延化） onResume へ遅らせる スレッド起動するだけにする レイアウトの Inflate 処理を遅らせる (ViewStub で次のフレームへ遅らせる） DI による依存注入処理を Dagger/Hilt で遅延させる コールバックオブジェクトの共通化 補足メモ Android Profiler で関数レベルのボトルネックを探る Android Studio の Android Profiler から CPU ペーンを開き、Record ボタンを押してレコード開始 → 何らかの操作をしてレコード停止 レコード中は動作が重くなるので、トレース結果は実時間で速度を見るのでなく、全体時間に対してどの程度の割合で時間がかかっているかで見る 正確に呼び出し情報をトレースするために、プロファイルモードで Trace Java Methods を選択しておく。Sample Java Methods は一定間隔でサンプリングするだけなので、動作は軽いけど正確な呼び出し情報が取れない Android Profiler でデバイスを認識しない時は、デバイス側の開発者オプションで USB デバッグが有効になっているかを確かめる 本質的に遅いメソッドを見つけるには、Bottom Up タブを選択 → Self 時間でソートする 先に main スレッドのチャート上でメソッドを選択しておくと、右側の分析ペーンの結果をフィルタできる 図: Android Studio の Profiler 機能 Layout Inspector で無駄なレイアウト構成を見つける アプリ動作中に Layout Inspector を起動すると、リアルタイムに現在のレイアウト構造を確認することができます（Hierarchy Viewer はサポート終了）。 パフォーマンスへの影響を見るときは、主にレイアウトが 深いネスト構造になっていないか を調べます。 Layout Inspector は 3D 表示にして角度をずらして、Layer spacing スライダーを調整すると、どれだけ重なっているかがよく分かかります。 オーバードローされている部分を見つける 開発者オプションから Debug GPU overdraw（GPU オーバードローをデバッグ） を ON にすると、何度も重ねて描画してしまっている部分を確認できます。 不透明な部分を重ねて描画していると完全に無駄です。 参考: GPU オーバードローの視覚化 この設定は開発者オプションの深いところにあるので、ADB で OFF/ON するのが早い 何らかの操作をしているときに、赤や緑の矩形が表示されることがないか を調べる（できれば青の領域もない方がいい） オーバードローされている部分は Layout Inspector でレイアウトを確認 コールバックオブジェクトの共通化 例えば、RecyclerView.Adapter#onBindViewHolder の中で次のようにリスナー登録していると、そのビューが表示されるごとにリスナーオブジェクトが生成されることになります。 setOnClickListener { // ... } リスナー内の処理が共通であれば、共通のリスナーオブジェクトを使うようにします。 setOnClickListener(handleClick)"},{url:"/p/w5gs4ep/",title:"Hugo でクリックで開閉する accordion ショートコードを作成する",date:"2021-02-22T00:00:00Z",body:"Hugo でクリックで開閉する accordion ショートコードを作成する 図: accordion ショートコードによる開閉表示 ブログ記事内の補足的な説明テキストなどは、デフォルトでは非表示にしておいて、必要なときにクリックで開閉できるようにしておくとスッキリします。 このような UI コンポーネントは、アコーディオン (accordion) と呼ばれることが多いので、ここでは accordion という名前のショートコードとして作成してみます。 accordion ショートコードは次のように使うことを想定しています。 Markdown 内での使用例 {{% accordion title=\u0026#34;もっと詳しく\u0026#34; %}} この本文はデフォルトでは隠されていて、クリックで見えるようになります。 - サンプルコード - 補足説明 などに使うと便利です。 {{% /accordion %}} ☝️ ワンポイント 本文のテキストを Markdown コードとして処理するためには、ショートコード名を \u0026lt; と \u0026gt; ではなく、上記のように % で囲む必要があります。 下記は、accordion ショートコードの実装例です。 クリックによる HTML 要素の表示／非表示の切り替えは、input 要素の状態による CSS の切り替えテクニック を利用しています。 label 要素と input 要素を結びつける ID には、Hugo の関数でランダムに生成した文字列 を使用しています。 layouts/shortcodes/accordion.html {{- $title := .Get \u0026#34;title\u0026#34; | default \u0026#34;例\u0026#34; }} {{- $rand := delimit (seq 9 | shuffle) \u0026#34;\u0026#34; }} \u0026lt;div class=\u0026#34;xAccordion\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;xAccordion_title\u0026#34; for=\u0026#34;id-{{ $rand }}\u0026#34;\u0026gt;{{ $title }}\u0026lt;/label\u0026gt; \u0026lt;input id=\u0026#34;id-{{ $rand }}\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;xAccordion_body\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上記の出力に合わせて、次のようなスタイルシートを読み込んでおく必要があります。 ここでは、SCSS によるスタイル記述が有効化 されていることを想定していますが、通常の CSS で記述しても大丈夫です。 表示スタイルはここで自由に変更できます。 common.scss .xAccordion { /* タイトル */ \u0026amp;_title { display: block; padding: 0.5rem 0.7rem; background: #ddd; cursor: pointer; \u0026amp;::after { font-size: smaller; color: #999; content: \u0026#34;（クリックで開閉）\u0026#34;; } \u0026amp;:hover { background: #ccc; } } \u0026amp;_body { display: none; /* デフォルトでは本文は非表示 */ /* 本文の共通設定 */ border: solid lightgray 1px; padding: 0.5rem; } input { display: none; /* チェックボックスは非表示 */ /* ラベルをクリックしたら本文を開く（表示） */ \u0026amp;:checked + .xAccordion_body { display: block; } } }"},{url:"/p/9qexh2q/",title:"Hugo のテンプレートやショートコードでランダムな文字列を生成する",date:"2021-02-22T00:00:00Z",body:"Hugo のテンプレートやショートコードでランダムな文字列を生成する 次の random ショートコードは、1 〜 9 の数値をランダムに並び替えた 9 桁の数値文字列を生成します。 layouts/shortcodes/random.html {{ $random1 := delimit (seq 9 | shuffle) \u0026#34;\u0026#34; }} {{ $random2 := delimit (shuffle (split \u0026#34;123456789\u0026#34; \u0026#34;\u0026#34; )) \u0026#34;\u0026#34; }} \u0026lt;p\u0026gt;random1 = {{ $random1 }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;random2 = {{ $random2 }}\u0026lt;/p\u0026gt; content/page1.md（使用例） --- title: \u0026#34;ページタイトル\u0026#34; --- {{\u0026lt; random \u0026gt;}} レンダリング結果 \u0026lt;p\u0026gt;random1 = 816257394\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;random2 = 234976851\u0026lt;/p\u0026gt; 上記の例では、2 種類の生成方法を示していますが、どちらも次のような手順でランダムな文字列を生成しています。 1 〜 9 の連番からなる配列を生成（seq 9 あるいは split \u0026quot;123456789\u0026quot; \u0026quot;\u0026quot; の部分） shuffle 関数 で配列要素をシャッフル delimit 関数 で配列要素を 1 つの文字列に結合 配列要素を結合する関数に delimit という名前が付けられていますが、多くの言語では join とか concatenate という名前が一般的ですね。 この関数名にはちょっと戸惑うかも（＾＾；"},{url:"/p/bn8q8o6/",title:"ADB で描画パフォーマンス計測のデバッグ機能を有効にする",date:"2021-01-29T00:00:00Z",body:"ADB で描画パフォーマンス計測のデバッグ機能を有効にする Android の開発者向けオプション (Developer options) には、描画パフォーマンスなどを測定するための便利なツールが揃っています。 特に、GPU オーバードロー領域の表示や、レンダリングプロファイル（画面上にバー表示）は、描画パフォーマンス 60 FPS を達成するために必須のツールです。 でも、これらの設定項目は設定メニューの深いところにあって、ホーム画面に戻って毎回切り替えるのは手間がかかります。 実はこれらのオプション設定は、adb shell から setprop コマンドを実行することで簡単に切り替えることができます。 コマンドからこれらの設定を変更した場合は、すぐに設定が有効にならないことがあるので注意してください。 その場合は、アプリの再起動や、アプリ内での画面遷移などを発生させると有効になるようです。 各種デバッグ項目の ADB からの設定方法 Show view updates（GPU表示の更新を表示） ON にすると、GPU での描画時にウィンドウ内の表示を点滅させます。 (Flash views inside windows when drawn) 設定方法 意味 adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を OFF adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を ON Show hardware layers updates（ハードウェア層情報を表示） ON にすると、ハードウェア層が更新されると緑を表示します。 (Flash hardware layers green when they update) GPU を活用した描画が行えているのであれば、GPU 層での更新は頻繁に発生するものではありません。 新しいビューが生成されたときのみ緑色のフラッシュが発生していれば OK です。 設定方法 意味 adb shell setprop debug.hwui.show_layers_updates false HW層更新表示を OFF adb shell setprop debug.hwui.show_layers_updates true HW層更新表示を ON Debug GPU overdraw（GPU オーバードローをデバッグ） ON にすると、何度も重ねて描画されてしまっている部分を色付きで表示します。 緑色や赤色の矩形がたくさん出てきたら、レイアウトの階層構造や、描画まわりの実装を見直す必要があります。 設定方法 意味 adb shell setprop debug.hwui.overdraw false OFF adb shell setprop debug.hwui.overdraw show オーバードロー領域の表示 adb shell setprop debug.hwui.overdraw show_deuteranomaly 第二色弱の方向けの領域の表示 参考: GPU レンダリングの速度とオーバードローを検査する Profile HWUI rendering（GPU レンダリングのプロファイル作成） 設定を visual_bars にすると、描画時にフレームあたり何ミリ秒かかったかを画面上の棒グラフで表示してくれます。 緑色の水平線以下にあれば、16.66ミリ秒、つまり 60FPS での描画を達成できています。 設定方法 意味 adb shell setprop debug.hwui.profile false レンダリングプロファイルを OFF adb shell setprop debug.hwui.profile visual_bars バーとして画面に表示 adb shell setprop debug.hwui.profile true dumpsys gfxinfo での確認用 参考: GPU レンダリングの速度とオーバードローを検査する （おまけ）設定項目のプロパティ名はどうやって調べたの？ 次のようにすると、Android 端末の現在のプロパティ設定の一覧を取得できます。 $ adb shell getprop あらかじめ上記の結果をファイルに保存しておいて、開発者向けオプションの設定を変更したときに値が変化する項目を調べれば、その設定項目のプロパティ名（および設定値）が分かります。 adb shell getprop \u0026gt; props1.txt 開発者向けオプションで設定を変更 adb shell getprop \u0026gt; props2.txt 比較 Windows: fc props1.txt props2.txt | findstr debug Linux: diff props1.txt props2.txt | grep debug プロパティ名は Android のバージョンによって変わる可能性がありますが、この方法でプロパティ名を調べれば対応できます。"},{url:"/p/ias8kt3/",title:"GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink)",date:"2020-12-03T00:00:00Z",body:"GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink) オートリンク機能とは GitHub の Issue（イシュー）や PR（プルリクエスト）のページの概要欄、コメント欄では、次のように Issue 番号を書いておくだけで該当ページに自動リンクすることができます。 #1234 参考: Autolinked references and URLs - GitHub Docs この機能はあくまで GitHub サイト内のリンクを簡単に記述するためのものですが、カスタムの Autolink references を設定しておくことで、任意の外部サイトに ID ベースで自動リンクできるようになります。 参考: Configuring autolinks to reference external resources - GitHub Docs 例えば、仕様書サイトのあるページ（ID=123 とします）にリンクしたい場合に、次のように簡単にリンクできるようになります。 SPEC-123 URL そのものを記述する必要がなくなるので、仕様書サイトのサーバー移転などでドメイン名が変わったとしても、Issue のコメントに記述したリンクが無効になってしまうことがありません。 ちなみにブログサイトなどの各ページの URL には、ID ベースのパーマリンクアドレスを割り当てる運用にしておくと、こういった機能と連携しやすくなります。 参考: サイト構造を変えてもページの URL が変わらないようにする - まくまくHugoノート カスタム・オートリンクの設定 （2022年7月時点で、このカスタム・オートリンクは、GitHub Pro、GitHub Team などの 有料プランのみで設定可能 です） 外部サイトへのオートリンク機能を有効にするには、次のように設定します。 ここでは、外部サイトの URL は https://spec.example.com/p/123/ といったパーマリンクで提供されるものとします（123 といった ID はサーバー移転などしても変わらないことが保証されていると過程）。 対象のリポジトリの Settings（設定）を選択 サイドバーから Autolink references を選択 次のような感じで Autolink 方法を設定 Reference prefix: SPEC- Target URL: https://spec.example.com/p/\u0026lt;num\u0026gt;/ すると、Issue や PR のコメントとして SPEC-123 のように記述するだけで、自動的に https://spec.example.com/p/123/ という URL へリンクされるようになります。 注意点 SPEC-XXX という形でリンクを張るとき、XXX の部分には 数値しか指定できない ということに注意してください。 SPEC-xyz1234 といった数値以外の文字が含まれる ID では自動リンクしてくれません。 GitHub チームに問い合わせましたが、2020年12月時点では、やはり数値のみのページ ID にしか対応していないとのこと。 パーマリンクのアドレスとしては、xyz1234 といった数値以外の文字を含む ID は一般的に使われているので、このあたりは改善されることを期待しています。 （2022年7月追記） これまで、オートリンクの ID 部分には数値しか指定できませんでしたが、GitHub 側の対応により、英数字及びハイフンの組み合わせ ([a-zA-Z0-9-]+)が使えるようになりました。 例えば、SPEC-xyz1234 のように、ID 部分に英数字を含んでいてもオートリンクが機能します。 参考: Autolinks with alphanumeric IDs - GitHub Changelog"},{url:"/p/oifj5jn/",title:"GitHub で Pull Request のコードレビューワーを自動でアサインする",date:"2020-10-20T00:00:00Z",body:"GitHub で Pull Request のコードレビューワーを自動でアサインする 2019年の末に、GitHub にコードレビューワーの自動アサイン機能が追加されました。 Managing code review assignment for your team - GitHub Docs この機能を有効にすると、Pull Request のレビューワーとしてチームをアサインしたときに、そのチーム内の数名を自動アサインしてくれるようになります。 この機能は、チーム単位の設定になるので、あらかじめリポジトリに何らかのチームを参加させておく必要があります。 チーム構成に迷ったら、プロジェクトと同じ粒度で作ってしまうのが手っ取り早いです（例えば、MyApp プロジェクトのチームとして、team-MyApp を作成します）。 自動アサインの設定画面は、チームのページから、Settings → Code review assignment と辿ると開くことができます。 図: GitHub Auto Assign 上記の例では次のような設定を行っています。 自動アサインする人数: 2人 選択アルゴリズム: ロードバランス アサイン対象外とする人: （省略） 自動アサインのアルゴリズムとしては「ラウンドロビン」と「ロードバランス」を選択できます。 「ラウンドロビン」を選択すると、単純に順番に割り当てていきます。 「ロードバランス」を選択すると、最近レビュー活動を行っていない人から優先的に割り当てていきます。 自動アサインといっても、PR 作成時に完全自動でアサインされるわけではありません（チームを手動でアサインする必要がある）。 状況に応じて、この自動アサイン機能と、ユーザー単位の手動アサインを使い分けると便利です。 ちなみに、この自動アサインの設定は、Organization の Owner メンバーだけでなく、各チームで team maintainer として登録されているユーザーが自由に行うことができます。 各チームのレビュー事情はチーム内の人が一番よく分かっているので、team maintainer をうまく設定してあげるとよいです。"},{url:"/p/kyn8rcv/",title:"Hugo で SVG ファイルをインラインで埋め込む svg ショートコードを作成する",date:"2020-10-20T00:00:00Z",body:"Hugo で SVG ファイルをインラインで埋め込む svg ショートコードを作成する Hugo で SVG ファイルを表示するには、Markdown の画像ファイル用構文や、Hugo 組み込みの figure ショートコード などを使用します。 ![サンプル画像](sample.svg) {{\u0026lt; figure src=\u0026#34;sample.svg\u0026#34; caption=\u0026#34;サンプル画像\u0026#34; \u0026gt;}} この方法で SVG ファイルを表示すると、次のような img タグで外部ファイルを参照するような HTML が出力されます。 \u0026lt;img src=\u0026#34;sample.svg\u0026#34;\u0026gt; これは、PNG ファイルや JPG ファイルと同様に外部ファイルを画像として表示する方法なので、SVG ファイル内にテキストが含まれていたとしても、そのテキストを検索することはできません。 SVG ファイルの内容をインラインで svg 要素として埋め込むようにすれば、SVG ファイルの内容をブラウザの検索機能などで検索できるようになります。 次の svg ショートコードは、指定された SVG ファイルをインラインで HTML に埋め込みます。 ポイントは、Hugo の readFile 関数でファイルの中身を読み込んで、その場に出力するところです。 layouts/shortcodes/svg.html {{- $src := .Get \u0026#34;src\u0026#34; }} {{- $title := .Get \u0026#34;title\u0026#34; }} {{- /* md ファイルからの相対パスで svg ファイル名を指定できるように */}} {{- $svgFile := path.Join (path.Dir .Position.Filename) $src }} \u0026lt;figure class=\u0026#34;xImage\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ $src }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; {{ readFile $svgFile | safeHTML }} \u0026lt;/a\u0026gt; {{- with $title }} \u0026lt;figcaption\u0026gt;図: {{ . }}\u0026lt;/figcaption\u0026gt; {{- end }} \u0026lt;/figure\u0026gt; 使用例（Markdown ファイル内） {{\u0026lt; svg src=\u0026#34;sample.svg\u0026#34; title=\u0026#34;サンプル画像\u0026#34; \u0026gt;}}"},{url:"/p/3j6qatd/",title:"GitHub で管理している社内リポジトリをトピックで分類する (topics)",date:"2020-10-14T00:00:00Z",body:"GitHub で管理している社内リポジトリをトピックで分類する (topics) GitHub リポジトリのトピック機能 社内で GitHub を使っている場合、組織内 (GitHub organization) にたくさんのリポジトリがごちゃ混ぜになっているかもしれません。 例えば、製品アプリ用のリポジトリ、社内ツール用のリポジトリ、ドキュメント管理用のリポジトリなどなど。 このような場合は、リポジトリのトピック機能 を使用すると、リポジトリをグループ化して管理することができます。 例えば、一般ユーザーにリリースする予定の製品アプリには product というトピックを付けるというルールで運用すると、製品アプリの一覧を簡単に作成することができます。 GitHub API を使ってリポジトリの一覧情報を取得すれば、高度な自動化処理を実現することができます。 GitHub リポジトリにトピックを割り当てる リポジトリへのトピック割り当てはとても簡単です。 リポジトリのトップページを開き、右上の 歯車アイコンをクリック します。 すると、リポジトリの情報を入力するダイアログが開くので、Topics の項目に任意のトピック名を入力します。 ここでは、製品アプリであることを示す product というトピックを付けています。 あとは、左上の検索窓などに topic:product と入力すれば、組織内の製品アプリ用のリポジトリの一覧を表示することができます。 このときブラウザに表示されている URL を共有すれば、マネージャー陣にアプリリストを提出するということも簡単にできます。 製品別のトピックを付けて管理するのもいいですね！ トピックの AND 検索と OR 検索 複数のトピックで GitHub リポジトリを検索するときに、次のように指定すれば AND 検索や OR 検索を行えるようです（2023-03 確認）。 AND 検索の例: AAA トピックと BBB トピックが付いているリポジトリを検索 topic:AAA topic:BBB OR 検索の例: AAA トピックまたは BBB トピックが付いているリポジトリを検索 topic:\u0026#34;AAA BBB\u0026#34;"},{url:"/p/3j6qate/",title:"Hugo でショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode)",date:"2020-10-13T00:00:00Z",body:"Hugo でショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode) .HasShortcode 関数 外部の JavaScript ファイルを利用して動作するショートコードを作成すると、Web サイトの表現力を大きく向上させることができます。 例えば、次のようなショートコードが考えられます。 独自の構文でコードを記述すると UML 図を出力してくれる mermaid ショートコード（mermaid.js などを利用） TeX 構文でコードを記述すると数式を出力してくれる math ショートコード（MathJax.js などを利用） このとき悩ましいのが、どのようにして次のような script 要素を出力するかです。 \u0026lt;script src=\u0026#34;for-shortcode.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; すべてのページにこのようなコードを出力してしまうと、この JavaScript が必要ないページでもファイルの読み込みが発生してしまいます。 こういった拡張が増えてくると、大量の JavaScript ファイルが読み込まれることになり、重い Web サイトになってしまいます。 このような場合の救世主が Page.HasShortcode 関数です。 参考: Hugo - Create Your Own Shortcodes - Checking for Existence ページテンプレート内で、 {{ if .HasShortcode \u0026#34;my-shortcode\u0026#34; }} ... {{ end }} といった記述をしておくと、Markdown ファイル内で my-shortcode ショートコードを使用している場合のみ出力を行うことができます。 実装例 例えば、ベーステンプレートの body 要素の末尾に次のように記述しておけば、Markdown ファイル内で mermaid ショートコードを使用している場合のみ、mermaid.js の読み込みと初期化処理を実行することができます。 layouts/_default/baseof.html（抜粋） ... {{- if .HasShortcode \u0026#34;mermaid\u0026#34; }} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;mermaid.initialize({startOnLoad: true});\u0026lt;/script\u0026gt; {{- end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ちなみに、mermaid ショートコードの実装は次のような感じになっています。 layouts/shortcodes/mermaid.html \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; Markdown ファイルからは次のように呼び出します。 {{\u0026lt; mermaid \u0026gt;}} sequenceDiagram Client-\u0026gt;\u0026gt;Cache: search cache Cache--\u0026gt;\u0026gt;Client: cache Client-\u0026gt;\u0026gt;Repo: fetch data Repo--\u0026gt;\u0026gt;Client: data {{\u0026lt; /mermaid \u0026gt;}} 図: 出力結果 （応用）他のページを間接的に出力するとき baseof.html での .HasShortcode がうまく動作しない例 Page.HasShortcode 関数は、あくまで現在処理しようとしているページの Markdown 内でショートコードが使われているかどうかを調べます。 例えば、ホームページテンプレートで、次のように最新記事の内容を間接的に取得して表示しているような場合は、baseof.html テンプレートに記述した .HasShortcode 関数は意図通り動作しない可能性があります。 \u0026lt;!-- 最近の記事をいくつかまとめて表示 --\u0026gt; {{- range first 3 .Site.RegularPages.ByLastmod.Reverse -}} \u0026lt;article class=\u0026#34;xArticle\u0026#34; itemscope itemtype=\u0026#34;https://schema.org/BlogPosting\u0026#34;\u0026gt; {{ .Render \u0026#34;inc-article\u0026#34; }} \u0026lt;/article\u0026gt; {{- end -}} なぜなら、ホームページ (content/_index.md) の Markdown ファイルではショートコードを使っていないのにもかかわらず（.HasShortcode が false になる）、上記ループで表示される別ページ内で JavaScript のロードを必要としていることがあるからです。 このようなケースに対応するには、上記のような Page オブジェクトをループしている部分で、.HasShortcode によるチェックを行わなければいけません。 ただし、ループ内で JavaScript ファイルをロードする script 要素を出力してしまうと、読み込みタイミングとしてはよろしくない（できれば body の末尾がいい）し、読み込み用のコードが重複してしまいます。 解決案 解決方法はいろいろありそうですが、ひとつの解決方法としては、ショートコード内で、自分自身が必要とする JavaScript ファイル（下記の例では mermaid.min.js）をロードする JavaScript コードを出力してしまうという方法です。 layouts/shortcodes/mermaid.html \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; (function() { const JS_FILE = \u0026#39;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#39;; // JSファイルの多重ロードを防止 const jsSet = window.loadedJsSet = window.loadedJsSet || new Set(); if (jsSet.has(JS_FILE)) return; jsSet.add(JS_FILE); // JSファイルの動的読み込み const script = document.createElement(\u0026#39;script\u0026#39;); script.src = JS_FILE; script.onload = function() { // 必要に応じてJSファイルロード後に初期化処理 mermaid.initialize({startOnLoad: true}); } document.body.appendChild(script); })(); \u0026lt;/script\u0026gt; すでにロードした JavaScript の情報は、グローバルな window.loadedJsSet 変数に格納しておくことで重複ロードを防いでいます。 この方法であれば、baseof.html などのベーステンプレートで script 要素を出力する必要もなく、ショートコード用のファイルだけで完結できます。 ある意味 .HasShortcode を使う方法よりもすっきりするかもしれません。 この方法の欠点としては、このショートコードを使うたびに同じ JavaScript コードが出力されてしまうという点でしょうか。 とはいえ、ページ内でのショートコードの呼び出し回数が、たかだか数回程度と想定できるのであれば、それほど気にしなくてもいいと思います。 参考: mermaid.js で Markdown 中に UML 図を埋め込む"},{url:"/p/xg3n7qa/",title:"mermaid.js で Hugo の Markdown 記事に UML 図を埋め込む",date:"2020-10-13T00:00:00Z",body:"mermaid.js で Hugo の Markdown 記事に UML 図を埋め込む mermaid.js とは mermaid.js を使うと、独自構文のテキストから UML 図などを生成することができます。 JavaScript で動的に SVG を生成することができるので、Markdown ファイルに図を埋め込みたい場合によく使われています。 Azure DevOps Wiki や GitHub、Gitlab などでも標準サポートされており、Markdown で図を扱うときのデファクトスタンダードになるかもしれません。 UML 図の表現力という点では PlantUML の方が上ですが、そのあたりは改善されていくと思います。 Hugo は現時点 (v0.76.4) では、mermaid.js を標準サポートしていないので、ここでは Hugo に mermaid.js を組み込む方法を説明します。 mermaid.js の仕組み mermaid.js は、次のような mermaid クラスが付けられた HTML 要素の内容を読み取り、そこに変換後の図 (SVG) を挿入します。 この例の場合は、div 要素の内容が SVG に置き換わります。 \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; graph LR A --- B B--\u0026gt;C[あいうえお] B--\u0026gt;D(かきくけこ) \u0026lt;/div\u0026gt; HTML の body 要素の末尾あたりで、次のように mermaid.js の読み込みと初期化を行います。 ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;mermaid.initialize({startOnLoad: true});\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; これだけで、Web ブラウザでページを開いたときに、SVG に変換された図が表示されます。 図: 表示例 mermaid.initialize() 関数には、表示方法をカスタマイズするためのオプション情報を渡すことができます。 startOnLoad: true と指定すると、HTML コンテンツが読み込み終わった時点で mermaid.js による変換が自動で開始されます。 逆に、startOnLoad: false としておくと、変換処理は自動で始まらなくなるので、任意のタイミングで mermaid.init() を呼び出すことで変換を開始します。 参考: API-Usage · mermaid これらをふまえて、Hugo にどのように mermaid.js を組み込んでいくかを考えてみます。 Hugo に mermaid.js を組み込む 方法1: コードブロックをそのまま使用する方法 Markdown ファイル内に、次のようなコードブロックを記述しておくと、クラス名 .language-mermaid の付いた \u0026lt;code\u0026gt; 要素が出力されます。 これは、Hugo 標準の機能です。 Markdown ```mermaid graph TD; A--\u0026gt;B; A--\u0026gt;C; ``` mermaid.js はデフォルトで mermaid クラスの付いた要素を変換対象としますが、任意の CSS セレクタを指定することができます。 なので、Hugo のベーステンプレートなどに次のようなコードを入れておけば、上記のコードブロックで SVG 図を出力することができます。 layouts/_default/baseof.html（抜粋） ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; mermaid.initialize({startOnLoad: false}); mermaid.init(undefined, \u0026#39;.language-mermaid\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; これはとてもお手軽な方法ですが、図が含まれていないページでも mermaid.min.js の読み込みが発生してしまうという欠点があります。 それを許容できるのであれば、おそらく最も簡単な方法です。 方法2: 独自のショートコード + テンプレートを使う方法 下記は、mermaid ショートコードの実装例です。 layouts/shortcodes/mermaid.html \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; このショートコードは、Markdown ファイル内で次のように呼び出します。 {{\u0026lt; mermaid \u0026gt;}} sequenceDiagram Client-\u0026gt;\u0026gt;Cache: search cache Cache--\u0026gt;\u0026gt;Client: cache Client-\u0026gt;\u0026gt;Repo: fetch data Repo--\u0026gt;\u0026gt;Client: data {{\u0026lt; /mermaid \u0026gt;}} あとは、ベーステンプレートなどで mermaid.js を読み込めばいいのですが、ここで Hugo の Page.HasShortcode という関数を利用すると、「mermaid ショートコードを使っているページでのみ mermaid.js をロードする」という振る舞いを実現できます。 layouts/_default/baseof.html（抜粋） ... {{- if .HasShortcode \u0026#34;mermaid\u0026#34; }} \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;mermaid.initialize({startOnLoad: true});\u0026lt;/script\u0026gt; {{- end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考: あるショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode) 方法3: ショートコードのみを使う方法 下記の mermaid ショートコードを使用すると、その場に mermaid.js を動的に読み込むコードが出力されます。 つまり、mermaid.js の導入を、ショートコードのみで完結させてしまう方法です。 layouts/shortcodes/mermaid.html \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; (function() { // JSファイルの多重ロードを防止 if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; // JSファイルの動的読み込み const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#39;; script.onload = () =\u0026gt; { mermaid.initialize({startOnLoad: true}); }; document.body.appendChild(script); })(); \u0026lt;/script\u0026gt; ベーステンプレートなどを一切変更せずに mermaid.js を使えるようになるので、とてもお手軽な方法です。 ショートコード化しているので、独自パラメータを導入するのも簡単です。 若干気になるのは、mermaid ショートコードを呼び出すたびに重複する JS コードが出力されてしまうところですが、このくらいの長さであれば、ほとんど問題になることはないと思います。 （おまけ）mermaid ショートコードのカスタマイズ mermaid ショートコードを使うときに、次のように図の「タイトル」を入れられると便利です。 {{\u0026lt; mermaid title=\u0026#34;ほげほげ\u0026#34; \u0026gt;}} graph LR A --- B B--\u0026gt;C[あいうえお] B--\u0026gt;D(かきくけこ) {{\u0026lt; /mermaid \u0026gt;}} 図: ほげほげ 次の mermaid ショートコードは、title パラメータで図のタイトルを表示できるようにしています（今まで通り title を省略することも可能です）。 ついでに、全体を中央寄せで表示するようにしています。 ここでは、style 属性を直接指定していますが、CSS ファイル内で .mermaid クラスに対してスタイル指定することもできます（mermaid による変換後も \u0026lt;div class=\u0026quot;mermaid\u0026quot;\u0026gt; というタグは残るため）。 layouts/shortcodes/mermaid.html \u0026lt;figure style=\u0026#34;text-align: center;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt;{{ .Inner }}\u0026lt;/div\u0026gt; {{- with .Get \u0026#34;title\u0026#34; }}\u0026lt;figcaption\u0026gt;図: {{ . }}\u0026lt;/figcaption\u0026gt;{{ end }} \u0026lt;/figure\u0026gt; （おまけ）Visual Studio Code で mermaid をプレビュー VS Code は Markdown エディタとしてとても優秀ですが、さらに mermaid.js 用のプラグインを入れると、プレビューウィンドウで mermaid.js による図の変換をリアルタイムに確認できるようになります。 mermaid.js 用のプラグインは多数提供されていますが、下記は Markdown Preview Mermaid Support プラグインを入れたときの表示例です。 図: Markdown Preview Mermaid Support プラグイン このプラグインは、```mermaid という行で始まるコードブロックがプレビューの対象になるようですが、Hugo のショートコードにも対応したプラグインが出てくるとよいですね。"},{url:"/p/nmv4cjr/",title:"Python でテキストファイルを書き込む (write, writelines)",date:"2020-06-02T00:00:00Z",body:`Python でテキストファイルを書き込む (write, writelines) テキストファイルを一行ずつ書き込む (write) Python でファイル書き込み用のファイルオブジェクトを作成するには、open 関数 の mode パラメータで下記のいずれかの値を設定してファイルをオープンします。 文字 意味 ファイルが存在しない場合の動き ファイルが存在する場合の動き w 上書き 新規作成 内容をクリアして上書き a 追記 新規作成 末尾にテキストを追加 x 排他生成 新規作成 オープンに失敗する (FileExistsError) 最もよく使うのは、w による上書き用のオープンです。 次の例では、output.txt という名前のファイルを作成（あるいは上書き）して、2 つの行を書き込んでいます。 テキストファイルの作成 f = open(\u0026#39;output.txt\u0026#39;, mode=\u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) f.write(\u0026#39;Hello\\n\u0026#39;) f.write(\u0026#39;World\\n\u0026#39;) f.close() エンコーディング形式 (encoding) は、省略するとプラットフォーム依存になるので、明示的に utf-8 を指定しておいた方がよいでしょう。 改行の扱い方 (newline) は、省略すると write() 関数での \\n の書き込みが、プラットフォーム依存の改行コードの書き込みという扱いになります。 必ず Unix の改行コード (LF) で書き込みたいということであれば、上記のように \\n あるいは '' を指定しておきましょう。 この指定により、write() 関数での \\n が LF、\\r\\n が CR+LF として書き込まれるようになります。 ファイルオブジェクトは最後に close() してリソースを解放する必要がありますが、 with を使って close() を自動化することができます。 基本的にはこの書き方をしておけばよいです。 close 処理の自動化 with open(\u0026#39;output.txt\u0026#39;, mode=\u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) as f: f.write(\u0026#39;Hello\\n\u0026#39;) f.write(\u0026#39;World\\n\u0026#39;) 文字列のリストをまとめて書き込む (writelines) 文字列のリストを一度に書き込みたい場合は、write() の代わりに writelines() を使用すると便利です。 複数行の出力 lines = [ \u0026#39;Hello\\n\u0026#39;, \u0026#39;World\\n\u0026#39; ] with open(\u0026#39;output.txt\u0026#39;, mode=\u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) as f: f.writelines(lines) writelines() も write() と同様に、行末に改行を入れたりはしません。 改行したい場合は、明示的に改行文字 \\n を入れる必要があります。 open の排他生成モード (mode=x) の用途 open() の一見変わったモードとして、排他生成モード (mode=\u0026quot;x\u0026quot;)があります。 このモードでオープンすると、すでにファイルが存在している場合に FileExistsError 例外 が発生するようになっています。 例えば次のように、ファイルが存在しない場合だけ、デフォルト値の書き込まれたデータファイルを作成するといったケースで使えます。 すでに config.yml が存在する場合は何もしない try: with open(\u0026#39;config.yml\u0026#39;, mode=\u0026#39;x\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) as f: f.write(\u0026#39;user: anonymous\\n\u0026#39;) except FileExistsError: # Already exists pass このコードは、次のようにファイルの存在チェックをするのと同じように見えるかもしれません。 このコードには不具合がある import os.path if os.path.exists(\u0026#39;config.yml\u0026#39;): # Already exists else: with open(\u0026#39;config.yml\u0026#39;, mode=\u0026#39;x\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) as f: f.write(\u0026#39;user: anonymous\\n\u0026#39;) しかし、後者の方法では、ファイルの存在チェックから open() の実行までのわずかな時間に、ファイル存在状態が変化するというレースコンディションが発生する危険があります。 また、後者の方法だと、os.path をインポートしないといけないとか、ファイル名を 2 か所で指定しないといけない、といった欠点があります。 これらの理由から、ファイルが存在しない場合にのみファイルを新規作成したい場合には、open 関数の x モードを使用するのが適しています。`},{url:"/p/wewevcs/",title:"Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する",date:"2020-06-01T00:00:00Z",body:"Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する urllib.request.urlopen() が返した HTTPResponse オブジェクトの info() メソッドを呼び出すと、HTTP レスポンスのヘッダ情報を取得することができます。 ヘッダ情報は HTTPMessage オブジェクト として返されますが、これは通常の辞書オブジェクトと同様に使用することができます。 詳しくは、HTTPMessage の親クラスである email.message.Message の定義を参照してください。 次の例では、Web サイトにアクセスしたときの HTTP レスポンスヘッダーを取得して表示しています。 sample.py import urllib.request url = \u0026#39;https://yahoo.co.jp/\u0026#39; try: with urllib.request.urlopen(url) as res: # HTTP レスポンスのヘッダ情報を取得 headers = res.info() print(type(headers)) #=\u0026gt; http.client.HTTPMessage print() print(headers) # 下記は Body 部分の取得 # text = res.read().decode(\u0026#39;utf-8\u0026#39;) # print(text) except urllib.error.URLError as err: print(\u0026#39;Could not access: %s\u0026#39; % url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) 実行結果 \u0026lt;class \u0026#39;http.client.HTTPMessage\u0026#39;\u0026gt; Cache-Control: private, no-cache, no-store, must-revalidate Content-Type: text/html; charset=UTF-8 Date: Mon, 01 Jun 2020 06:07:42 GMT Expires: -1 Pragma: no-cache Set-Cookie: B=1sg6o4tfd96pe\u0026amp;b=3\u0026amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.yahoo.co.jp Vary: Accept-Encoding X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-Vcap-Request-Id: f25c0bf4-0481-4804-5fe1-ef1fab7a3080 X-Xss-Protection: 1; mode=block Age: 0 Transfer-Encoding: chunked Connection: close Via: http/1.1 edge2424.img.djm.yahoo.co.jp (ApacheTrafficServer [c sSf ]) Server: ATS Set-Cookie: XB=1sg6o4tfd96pe\u0026amp;b=3\u0026amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.yahoo.co.jp; secure; samesite=none 特定のヘッダ情報だけ取得したい場合は、次のように参照すれば OK です。 Content-Type ヘッダーを参照する with urllib.request.urlopen(url) as res: headers = res.info() if \u0026#39;Content-Type\u0026#39; in headers: print(headers[\u0026#39;Content-Type\u0026#39;])"},{url:"/p/8axzppz/",title:"GitHub の REST API を Python から使用する",date:"2020-05-30T00:00:00Z",body:"GitHub の REST API を Python から使用する 何を作るか？ Python で GitHub API を利用するアプリケーションを作るときは、GitHub API を実行して情報取得する部分を、1 つのモジュールとして切り出しておくと全体のコードがすっきりします。 ここでは、実装例として GitHubApi というクラスを作り、次のようなことを行えるようにします。 get_members() や get_issues() といった直感的な API で GitHub の情報を取得できるようにする オプションでプロキシや Personal Access Token を指定できるようにする ページネーションによる連続アクセスで、多くの情報を一度に取得できるようにする GitHub の REST API に関しては、下記の記事を参照してください。 GitHub の REST API を使用する GitHub の REST API で Issue 情報を取得する方法いろいろ GitHubApi クラスを実装する ここで紹介する GitHubApi クラスを使うと、次のようなシンプルなコードで GitHub API を呼び出して、その結果を Python のオブジェクトとして取得することができます。 # ユーザー情報を取得する user = api.get_user(\u0026#39;maku77\u0026#39;) print(user[\u0026#39;login\u0026#39;]) 下記は、GitHubApi クラスの実装例です。 github.py import json import re import sys from urllib.parse import quote, urlencode import urllib.request class GitHubApi: BASE_URL = \u0026#39;https://api.github.com\u0026#39; UNVERIFY_SSL = True def __init__(self, option={}): self.option = option if self.UNVERIFY_SSL: self.__unverify_ssl() def __unverify_ssl(self): import ssl ssl._create_default_https_context = ssl._create_unverified_context def __get_json(self, url, paginate=False): req = self.__create_request(url) try: with urllib.request.urlopen(req) as res: json_text = res.read().decode(\u0026#39;utf-8\u0026#39;) json_obj = json.loads(json_text) # ページネーションによる繰り返し取得 if paginate: next_link = self.__get_next_link(res.info()) if next_link: json_obj.extend(self.__get_json(next_link)) return json_obj except urllib.error.URLError as err: print(\u0026#39;Could not access: %s\u0026#39; % req.full_url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) # ページネーションによる連続取得が必要な場合は、 # 次のアドレスを返す。必要ない場合は None を返す。 def __get_next_link(self, response_headers): link = response_headers[\u0026#39;Link\u0026#39;] if not link: return None match = re.search(r\u0026#39;\u0026lt;(\\S+)\u0026gt;; rel=\u0026#34;next\u0026#34;\u0026#39;, link) if match: return match.group(1) return None def __create_request(self, url): req = urllib.request.Request(url) if \u0026#39;token\u0026#39; in self.option: req.add_header(\u0026#39;Authorization\u0026#39;, \u0026#39;token %s\u0026#39; % self.option[\u0026#39;token\u0026#39;]) if \u0026#39;proxy\u0026#39; in self.option: req.set_proxy(self.option[\u0026#39;proxy\u0026#39;], \u0026#39;http\u0026#39;) req.set_proxy(self.option[\u0026#39;proxy\u0026#39;], \u0026#39;https\u0026#39;) return req # 指定したユーザーの情報を取得します def get_user(self, username): url = self.BASE_URL + \u0026#39;/users/%s\u0026#39; % quote(username) return self.__get_json(url) # 指定した組織のメンバーリストを取得します def get_members(self, org): url = self.BASE_URL + \u0026#39;/orgs/%s/members?per_page=100\u0026#39; % quote(org) return self.__get_json(url, paginate=True) # 指定した組織のリポジトリ一覧を取得します def get_org_repos(self, org): url = self.BASE_URL + \u0026#39;/orgs/%s/repos?per_page=100\u0026#39; % quote(org) return self.__get_json(url, paginate=True) # 指定したユーザーのリポジトリ一覧を取得します def get_user_repos(self, user): url = self.BASE_URL + \u0026#39;/users/%s/repos?per_page=100\u0026#39; % quote(user) return self.__get_json(url, paginate=True) # 指定したリポジトリの Issue 一覧を取得します def get_issues(self, owner, repo, params={}): url = self.BASE_URL + \u0026#39;/repos/%s/%s/issues?per_page=100\u0026#39; % (quote(owner), quote(repo)) if params: url = \u0026#39;%s\u0026amp;%s\u0026#39; % (url, urlencode(params)) return self.__get_json(url, paginate=True) 最後の方にある get_xxx 系のメソッドが、GitHub API を呼び出すための public メソッドです。 同じようにメソッドを追加していけば、いろいろな GitHub API に対応することができます。 どのような API があるかは、GitHub REST API v3 のサイト を参照してください。 ページネーション処理 GitHub API v3 でリポジトリの一覧などを取得すると、デフォルトでは 30 件ずつしか結果を返してくれません。 URL 末尾のクエリパラメーターで per_page=100 と指定すれば、100 件までは一度に取得できるのですが、100 件を超えるすべての情報を取得したいときは、ページネーションの仕組み を使って何度かに分けて取得する必要があります。 次ページの情報を取得するときは、page=2 のようにクエリ指定する必要があるのですが、次ページが存在する場合は HTTP レスポンスの Link ヘッダーに次ページのアドレスが含まれているので、このアドレスを使って繰り返しアクセスするのがよいでしょう。 上記のサンプルコードでは、__get_json メソッドの中で次のようにページネーション処理しています。 次のページがある場合は、再帰的に __get_json を呼び出し、その結果を json_obj 配列に結合しています。 # ページネーションによる繰り返し取得 if paginate: next_link = self.__get_next_link(res.info()) if next_link: json_obj.extend(self.__get_json(next_link)) GitHubApi クラスの使用例いろいろ 下記は、GitHubApi クラスを使って、いろいろな情報を取得するサンプルコードです。 from github import GitHubApi api = GitHubApi() # ユーザー情報を取得 user = api.get_user(\u0026#39;maku77\u0026#39;) print(user[\u0026#39;login\u0026#39;]) print(user[\u0026#39;blog\u0026#39;]) print(user[\u0026#39;company\u0026#39;]) # 指定した組織のリポジトリ一覧を取得します repos = api.get_org_repos(\u0026#39;sony\u0026#39;) for repo in repos: print(repo[\u0026#39;name\u0026#39;]) print(repo[\u0026#39;full_name\u0026#39;]) print(repo[\u0026#39;description\u0026#39;]) print(repo[\u0026#39;html_url\u0026#39;]) print() # 指定した組織のメンバーリストを取得 members = api.get_members(\u0026#39;sony\u0026#39;) for member in members: print(member[\u0026#39;login\u0026#39;]) # 指定したリポジトリの Issue 一覧を取得します（open 状態のもの） issues = api.get_issues(\u0026#39;sony\u0026#39;, \u0026#39;nnabla\u0026#39;) for issue in issues: print(issue[\u0026#39;title\u0026#39;]) # 指定したリポジトリの Issue 一覧を取得します（close 状態のものも取得） issues = api.get_issues(\u0026#39;sony\u0026#39;, \u0026#39;nnabla\u0026#39;, params={\u0026#39;state\u0026#39;: \u0026#39;all\u0026#39;}) for issue in issues: print(issue[\u0026#39;title\u0026#39;]) プロキシや Personal Access Token を指定してアクセスする必要がある場合は、GitHubApi コンストラクタのオプションで次のように指定します。 options = { \u0026#39;proxy\u0026#39;: \u0026#39;proxy.example.com:80\u0026#39;, \u0026#39;token\u0026#39;: \u0026#39;a0709c8d0ac21812d9c4b8511298b33ec0fd2813\u0026#39; } api = GitHubApi(options) ここでは、取得した情報のうち、ごく一部のプロパティだけを参照していますが、GitHub API が返す値にはもっといろいろな情報が含まれています。 これらの情報をうまく使えば、日々の業務を自動化できるかもしれません。"},{url:"/p/w7p7n4j/",title:"Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode)",date:"2020-05-30T00:00:00Z",body:"Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode) Python の標準モジュールとして提供されている urllib.parse を使用すると、任意の文字列を URL 内で扱えるようにエンコード／デコードすることができます。 ユーザーが入力したテキストや、日本語を含むテキストをエスケープ処理して URL として扱いたいときに使用できます。 文字列を URL エンコードする (quote) 任意の文字列を URL として扱いたいときは、urllib.parse.quote 関数 を使うと、エスケープすべき文字を %xx という形に変換してくれます。 from urllib.parse import quote print(quote(\u0026#39;あ\u0026#39;)) #=\u0026gt; \u0026#39;%E3%81%82\u0026#39; print(quote(\u0026#39;ABC\u0026#39;)) #=\u0026gt; \u0026#39;ABC\u0026#39; print(quote(\u0026#39;A B C\u0026#39;)) #=\u0026gt; \u0026#39;A%20B%20C\u0026#39; print(quote(\u0026#39;A/B/C\u0026#39;)) #=\u0026gt; \u0026#39;A/B/C\u0026#39; 上記の結果からわかるように、quote 関数はデフォルトではスラッシュ (/) をエスケープしません。 これは、変換しない文字を示すオプションパラメータ safe のデフォルト値が '/' になっているからです。 次のようにすると、スラッシュが %2F にエスケープされるようになります。 print(quote(\u0026#39;A/B/C\u0026#39;, safe=\u0026#39;\u0026#39;)) #=\u0026gt; \u0026#39;A%2FB%2FC\u0026#39; URL の特定階層のパス名をユーザーに入力させるようなケースで使用できます。 URL をデコードする (unquote) 逆に、URL エンコードされた文字列をデコードして元に戻すには、urllib.parse.unquote 関数 を使用します。 from urllib.parse import unquote print(unquote(\u0026#39;%E3%81%82\u0026#39;)) #=\u0026gt; \u0026#39;あ\u0026#39; print(unquote(\u0026#39;ABC\u0026#39;)) #=\u0026gt; \u0026#39;ABC\u0026#39; print(unquote(\u0026#39;A%20B%20C\u0026#39;)) #=\u0026gt; \u0026#39;A B C\u0026#39; print(unquote(\u0026#39;A%2FB%2FC\u0026#39;)) #=\u0026gt; \u0026#39;A/B/C\u0026#39; クエリ文字列を作成する (urlencode) HTTP の GET リクエストを送るときに、URL の末尾に次のようにクエリ文字列を付加したいことがあります。 https://example.com/?key1=value1\u0026amp;key2=value2 urllib.parse.urlencode 関数 を使用すると、任意のディクショナリオブジェクトからクエリ文字列を作成することができます。 ディクショナリの各要素が key1=value1 という形で、\u0026amp; 記号により結合された文字列が返されます。 キーと値は適切に URL エンコードされるので、そのまま URL の末尾にくっつけることができます。 from urllib.parse import urlencode query = urlencode({\u0026#39;a\u0026#39;:100, \u0026#39;b\u0026#39;:200}) print(query) #=\u0026gt; a=100\u0026amp;b=200 query = urlencode({\u0026#39;a\u0026#39;:\u0026#39;あ\u0026#39;, \u0026#39;b\u0026#39;:\u0026#39;い\u0026#39;}) print(query) #=\u0026gt; a=%E3%81%82\u0026amp;b=%E3%81%84 query = urlencode({\u0026#39;msg\u0026#39;:\u0026#39;hello world\u0026#39;}) print(query) #=\u0026gt; msg=hello+world 次のようにすれば、クエリ文字列の付いた URL を簡単に生成できます。 from urllib.parse import urlencode base = \u0026#39;https://example.com/\u0026#39; query = { \u0026#39;key1\u0026#39;: 100, \u0026#39;key2\u0026#39;: 200 } url = \u0026#39;%s?%s\u0026#39; % (base, urlencode(query)) print(url) #=\u0026gt; https://example.com/?key1=100\u0026amp;key2=200"},{url:"/p/gzo8d7y/",title:".env ファイルで環境変数を設定する (python-dotenv)",date:"2020-05-27T00:00:00Z",body:".env ファイルで環境変数を設定する (python-dotenv) python-dotenv モジュールの概要 python-dotenv モジュールを使用すると、Python プログラム実行時に次のような .env ファイルを読み込んで、環境変数を設定することができます。 .env MYAPP_USER=maku MYAPP_PASS=makupass MYAPP_CONFIG=${HOME}/${MYAPP_USER}/config 上記の例のように、${HOME} という形で環境変数の値を展開することもできます。 特定のプログラムを実行するために、いちいち OS の環境変数を設定するのを嫌がるユーザーはたくさんいます。 あなたのプログラムが何らかの環境変数を必要としているのであれば、.env ファイルによる設定手段も提供しておくと親切です。 .env の仕組みは Python に限ったものではなく、いろいろな言語で採用されています。 参考: Node.js プログラムで .env ファイルを使用する python-dotenv モジュールのインストール python-dotenv モジュールは pip コマンドでインストールできます。 $ python3 -m pip install python-dotenv ☝️ venv 仮想環境を使う システム全体の Python 実行環境を汚したくない場合は、次のように venv 仮想環境を作成 して、そこにインストールしましょう。 $ python3 -m venv venv $ source venv/bin/activate (venv) $ pip install python-dotenv 仮想環境は次のように抜けられます。 (venv) $ deactivate python-dotenv の使い方 .env ファイルの内容を環境変数に反映する .env ファイルを読み込むのはとても簡単で、load_dotenv() を呼び出すだけです。 次の Python スクリプトでは、同じディレクトリ（あるいは、より上位のディレクトリ）に置かれた .env ファイルの内容を読み込み、環境変数に反映しています。 .env を環境変数に反映 from dotenv import load_dotenv load_dotenv() # Load environment variables from .env file 基本的な使い方としては、これだけで OK です。 仮に、.env ファイルが存在しなくても、load_dotenv() はエラーにならないので、上記のようなコードは安心して実行することができます。 OS の環境変数を上書きする (override) OS の環境変数設定で、すでに同じ名前の変数が定義されている場合は、そちらが優先して使われるようになっています。 .env ファイルで設定した値を優先して使いたい場合は、次のように override オプションを指定します。 from dotenv import load_dotenv load_dotenv(override=True) （おまけ）config モジュール化する 次の config.py は、アプリケーション全体のコンフィグ情報を管理するモジュールの実装例です。 config.py from dotenv import load_dotenv import os load_dotenv() # Load environment variables from .env file MYAPP_USER = os.getenv(\u0026#34;MYAPP_USER\u0026#34;) MYAPP_PASS = os.getenv(\u0026#34;MYAPP_PASS\u0026#34;) この config モジュールを使えば、アプリケーションのどこからでも次のようにコンフィグ情報を参照できるようになります。 main.py import config print(config.MYAPP_USER) print(config.MYAPP_PASS) .env ファイルの扱い方 .env ファイルはどこに置くべきか？ ある Python スクリプトから dotenv.load_dotenv() 関数を呼び出すと、そのスクリプトファイルがあるディレクトリを起点に、.env ファイルが見つかるまで親ディレクトリを遡りながら検索します。 なので、あるプロジェクトで使用する .env ファイルは、そのプロジェクトのルートディレクトリに配置 しておけば、まずロードに失敗することはありません。 .env ファイルは Git にコミットする？ .env ファイルは、ユーザー固有の設定を記述するものです。 例えば、Web サービスのアクセストークンなどを記述するので、 .env ファイルは Git にコミットしてはいけません。 間違えてコミットしないように、.gitignore ファイルに .env のエントリを登録しておきましょう。 Git にコミットしない .env ファイルであることを明確にするために、.env.local というファイル名を使うこともあります。"},{url:"/p/wozpogm/",title:"Python の実行環境を venv で切り替える",date:"2020-05-27T00:00:00Z",body:"Python の実行環境を venv で切り替える venv モジュールは、Python の仮想実行環境を作成するための標準モジュールです。 Python 3.2 までは virtualenv という外部パッケージを使用していましたが、Python 3.3 以降は標準で同等機能を提供する venv パッケージ を使用できます。 なぜ仮想環境が必要か？ Python で作成されたプログラムは、pip install で外部モジュールをインストールすることを前提に作成されたものがたくさんあります。 Python プログラムを実行するために、何も考えずに pip install を繰り返していると、いろいろなバージョンのモジュールがインストールされてしまい、実行環境がぐちゃぐちゃになってしまいます。 あるプログラムを動作させるために pip install すると、別のプログラムが動作しなくなるといったことが起こります。 venv を使って仮想環境を作ると、その環境内に閉じて pip install することができるようになります。 例えば、app1 と app2 という 2 つの Python プログラム用に別々の仮想環境を作って、それぞれのプログラムに必要なパッケージをインストールするということができます。 プロジェクト用の仮想環境を作成する／削除する 仮想環境を作成する 仮想環境を作成するには、次のようなコマンドを実行します。 仮想環境はディレクトリの形で作成され、その中に必要なファイルが自動生成されます。 ここでは、python3 を使っていますが、環境によっては python に置き換えてください（Windows の場合は py だったりします）。 仮想環境の作成 $ python3 -m venv \u0026lt;仮想環境ディレクトリ\u0026gt; 仮想環境ディレクトリの名前としては、一般的に venv や .venv が使われます。 このディレクトリは Git にコミットするものではないので、好きな方を選べばよいです。 プロジェクトごとに仮想環境を作成するのであれば、プロジェクトのルートに仮想環境ディレクトリを作成するのがよいでしょう。 例えば、myapp プロジェクト用の仮想環境を作るには次のようにします。 仮想環境ディレクトリ venv を作成 $ mkdir ~/myapp $ cd ~/myapp $ python3 -m venv venv この仮想環境ディレクトリには、次のようなファイル群が格納されていて、仮想環境内でインストールしたパッケージなどはこの中で管理されます。 $ ls venv bin/ include/ lib/ pyvenv.cfg 仮想環境を削除する 仮想環境が必要なくなった場合は、仮想環境ディレクトリを丸ごと削除してしまえば OK です。 仮想環境の削除 $ rm -Rf venv .gitignore を修正する 仮想環境ディレクトリは他のユーザーと共有する仕組みにはなっていないので、.gitignore ファイルに次のように記述して、Git にコミットしないようにします。 .gitignore .venv/ venv/ ここでは、仮想環境ディレクトリ名が .venv あるいは venv であると想定しています。 このあたりはプロジェクト内でルール化して、README.md などに仮想環境の構築方法を記述しておきましょう。 仮想環境に入る / 抜ける 仮想環境に入る (activate) 作成した仮想環境を使用するには、仮想環境のディレクトリ内に作成された activate スクリプトを実行します。 Linux と Windows で呼び出すスクリプトのパスが異なるので注意してください。 仮想環境に入る（Linux や macOS の場合） $ source venv/bin/activate 仮想環境に入る（Windows の場合） venv\\Scripts\\activate.bat 仮想環境に入ると、次のように、プロンプトの先頭に仮想環境名が表示されます。 (.venv) $ この状態で pip install コマンドを実行すると、仮想環境内に閉じてパッケージがインストールされます。 そのパッケージが有効なのは、この仮想環境内で python コマンドを実行した場合のみです。 仮想環境にパッケージをインストール (.venv) $ pip install requests (.venv) $ pip install python-dotenv (.venv) $ pip install ... 仮想環境から抜ける (deactivate) 仮想環境から抜けるには、単純に deactivate コマンドを実行します。 このコマンドは、仮想環境に入っている状態であれば、どのディレクトリからでも実行できるようになっています。 仮想環境から抜ける (.venv) $ deactivate 特定のバージョンの Python を使う仮想環境を作成する venv 環境内で実行される python のバージョンは、venv 環境を作成するときに実行した python のバージョンと同じになります。 仮想環境内で任意のバージョンの python コマンドを使いたい場合は、venv 環境を作るときにそのバージョンの python コマンドを使用する必要があります。 python コマンドのバージョンを切り替えるには、pyenv コマンド (Linux/macOS) や py コマンド (Windows) を使うと便利です。 参考: python コマンドのバージョンを切り替える (pyenv, py) 下記は任意の Python バージョン（ここでは 3.10）の venv 仮想環境を作成する方法の例です。 pyenv を使う方法 (Linux/macOS) # Python 3.10.X をインストール $ pyenv install 3.10 # カレントシェルで Python 3.10 を使うように切り替え $ pyenv shell 3.10 # venv 環境を作成 $ python -m venv venv py を使う方法 (Windows) C:\\\u0026gt; py -3.10 -m venv venv プロジェクトの依存パッケージを requirements.txt で管理する requirements.txt とは これは venv の仕組みではなくて、パッケージ管理ツールの pip の仕組み ですが、requirements.txt というファイルに依存パッケージを記述しておくと、一撃で依存パッケージをインストールできるようになります。 Python アプリのソースコードと一緒に、この requirements.txt を Git にコミットしておくことで、チーム内の開発環境を簡単に揃えることができます。 venv による仮想環境を使って開発を進める場合、初期状態では何もパッケージがインストールされていない状態からパッケージをインストールしていくことになるため、requirements.txt によるパッケージ管理は非常に相性がよいといえます。 requirements.txt を生成する pip freeze コマンドを使うと、現在の仮想環境にインストールされているパッケージのリストをもとに requirements.txt を自動生成することができます。 このコマンドは、仮想環境に入っている状態で（source venv/bin/activate コマンドを実行した後に）実行してください。 (.venv) pip freeze \u0026gt; requirements.txt 例えば、requires と python-dotenv パッケージをインストールした後の requirements.txt の内容は次のような感じになります（間接的に依存するパッケージも列挙されます）。 requirements.txt certifi==2021.10.8 charset-normalizer==2.0.7 idna==3.3 python-dotenv==0.19.1 requests==2.26.0 urllib3==1.26.7 requirements.txt はプロジェクトのルートディレクトリに配置して、Git にコミットしておきましょう。 requirements.txt を使ってパッケージをインストールする 別の PC 環境で開発を始めるときは、次のようにセットアップすることができます。 $ python3 -m venv venv # 仮想環境を作成する $ source venv/bin/activate # 仮想環境に入る (.venv) $ pip install -r requirements.txt # 依存パッケージをインストールする これで、依存パッケージがすべてインストールされた状態で python コマンドを実行することができます。"},{url:"/p/uvoibwi/",title:"GitHub の REST API で Issue 情報を取得する方法いろいろ",date:"2020-05-25T00:00:00Z",body:"GitHub の REST API で Issue 情報を取得する方法いろいろ あるリポジトリの Issues の一覧を取得する GitHub の /repos/\u0026lt;ユーザー名\u0026gt;/\u0026lt;リポジトリ名\u0026gt;/issues という REST API エンドポイントにアクセスすると、指定したリポジトリ内の Issue の一覧を取得することができます。 特定の Organization が提供しているリポジトリを指定するときは、ユーザー名 の部分を Organization名 に置き換えてください。 Public リポジトリの場合 Public リポジトリの情報は、誰でも簡単に取得することができます。 下記は、curl コマンドを使って REST API を呼び出すサンプルです。 ユーザー名とリポジトリ名の部分は適切な値に変更してください。 Public なリポジトリの場合 $ USER_NAME=myname $ REPO_NAME=myrepo $ curl https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues HTTP レスポンスのヘッダ情報も確認したい場合は、 -i オプションを追加してください。 上記のような GET リクエストにより、Issue のリスト（PullRequest も含む）が JSON 形式で返されます。 単純な GET リクエストなので、ブラウザで直接 URL を入力することでも情報を取得することができます。 下記は、1 つの Issue だけ含むリポジトリから情報を取得したときのサンプルです。 この Issue には、ラベル1 と ラベル2 という 2 つのラベルが設定されています。 リポジトリの Issue リストの例 (JSON) [ { \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample/issues/1\u0026#34;, \u0026#34;repository_url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample\u0026#34;, \u0026#34;labels_url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample/issues/1/labels{/name}\u0026#34;, \u0026#34;comments_url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample/issues/1/comments\u0026#34;, \u0026#34;events_url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample/issues/1/events\u0026#34;, \u0026#34;html_url\u0026#34;: \u0026#34;https://github.com/maku77/sample/issues/1\u0026#34;, \u0026#34;id\u0026#34;: 624149172, \u0026#34;node_id\u0026#34;: \u0026#34;MDU6SXNzdWU2MjQxNDkxNzI=\u0026#34;, \u0026#34;number\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Issueのタイトル1\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;login\u0026#34;: \u0026#34;maku77\u0026#34;, \u0026#34;id\u0026#34;: 5519503, \u0026#34;node_id\u0026#34;: \u0026#34;MDQ6VXNlcjU1MTk1MDM=\u0026#34;, \u0026#34;avatar_url\u0026#34;: \u0026#34;https://avatars2.githubusercontent.com/u/5519503?v=4\u0026#34;, \u0026#34;gravatar_id\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/users/maku77\u0026#34;, \u0026#34;html_url\u0026#34;: \u0026#34;https://github.com/maku77\u0026#34;, \u0026#34;followers_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/followers\u0026#34;, \u0026#34;following_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/following{/other_user}\u0026#34;, \u0026#34;gists_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/gists{/gist_id}\u0026#34;, \u0026#34;starred_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/starred{/owner}{/repo}\u0026#34;, \u0026#34;subscriptions_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/subscriptions\u0026#34;, \u0026#34;organizations_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/orgs\u0026#34;, \u0026#34;repos_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/repos\u0026#34;, \u0026#34;events_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/events{/privacy}\u0026#34;, \u0026#34;received_events_url\u0026#34;: \u0026#34;https://api.github.com/users/maku77/received_events\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;User\u0026#34;, \u0026#34;site_admin\u0026#34;: false }, \u0026#34;labels\u0026#34;: [ { \u0026#34;id\u0026#34;: 2086106907, \u0026#34;node_id\u0026#34;: \u0026#34;MDU6TGFiZWwyMDg2MTA2OTA3\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample/labels/%E3%83%A9%E3%83%99%E3%83%AB1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;ラベル1\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;23c6bc\u0026#34;, \u0026#34;default\u0026#34;: false, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;id\u0026#34;: 2086107046, \u0026#34;node_id\u0026#34;: \u0026#34;MDU6TGFiZWwyMDg2MTA3MDQ2\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://api.github.com/repos/maku77/sample/labels/%E3%83%A9%E3%83%99%E3%83%AB2\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;ラベル2\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;f9bbdb\u0026#34;, \u0026#34;default\u0026#34;: false, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34; } ], \u0026#34;state\u0026#34;: \u0026#34;open\u0026#34;, \u0026#34;locked\u0026#34;: false, \u0026#34;assignee\u0026#34;: null, \u0026#34;assignees\u0026#34;: [ ], \u0026#34;milestone\u0026#34;: null, \u0026#34;comments\u0026#34;: 0, \u0026#34;created_at\u0026#34;: \u0026#34;2020-05-25T08:51:56Z\u0026#34;, \u0026#34;updated_at\u0026#34;: \u0026#34;2020-05-25T08:51:56Z\u0026#34;, \u0026#34;closed_at\u0026#34;: null, \u0026#34;author_association\u0026#34;: \u0026#34;OWNER\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Issueのコメント1\u0026#34; } ] Issue が 1 つも存在しない場合は、空の配列を示す JSON 文字列 ([]) が返されます。 リポジトリ名などの指定が間違っている場合は、次のような JSON 文字列が返されます（レスポンスのステータスコードは HTTP/1.1 404 Not Found です）。 存在しないリポジトリを指定した場合 { \u0026#34;message\u0026#34;: \u0026#34;Not Found\u0026#34;, \u0026#34;documentation_url\u0026#34;: \u0026#34;https://developer.github.com/v3/issues/#list-issues-for-a-repository\u0026#34; } Private リポジトリの場合 Private なリポジトリの情報を単純に GET リクエストで取得しようとすると、間違ったリポジトリ名を指定した場合と同様の Not Found メッセージが返されます。 403 Forbidden ではなく、404 Not Found を返すのは、Private リポジトリの存在に気づかれないようにするためのセキュリティ上の対策とされています。 Private リポジトリから Issue の一覧を取得するには、GitHub の Personal access token 設定 で発行したトークンや、OAuth トークンを使ってアクセスする必要があります。 二要素認証を有効にしている場合でも、これらのトークンによるアクセスは有効です。 トークンは次のように HTTP リクエストの Authorization ヘッダで指定します。 アクセストークンを指定した API 呼び出し $ TOKEN=dd7bbe7538fd705d5350bc152c5e44d828d32b22 $ USER_NAME=myname $ REPO_NAME=myrepo $ curl -H \u0026#34;Authorization: token $TOKEN\u0026#34; https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues アクセストークンのスコープとしては、次のように repo (Full control of private repositories) を割り当てておく必要があるようです。 図: Issue のリストを取得するためのアクセストークン設定 あるユーザーにアサインされた Issue の一覧を取得する /user/issues という REST API エンドポイントにアクセスすると、認証済みユーザー（つまり自分）にアサインされた Issue の一覧を取得することができます。 例えば、次のように、Personal Access Token を使った情報取得が可能です。 ユーザーにアサインされた Issue の一覧を取得する $ TOKEN=dd7bbe7538fd705d5350bc152c5e44d828d32b22 $ curl -H \u0026#34;Authorization: token $TOKEN\u0026#34; https://api.github.com/user/issues 取得する Issue の種類を指定する URL 末尾にクエリパラメーターを追加することで、取得する Issue を絞り込むことができます。 closed 状態の Issue を取得する (state=closed) 例: Close 済みの Issue を取得する $ USER_NAME=myname $ REPO_NAME=myrepo $ curl https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues?state=closed state パラメーターを指定すると、open/closed 状態を指定して Issue リストを取得することができます。 state=open \u0026hellip; Open 状態の Issue のみ取得（デフォルト） state=closed \u0026hellip; Close 状態の Issue のみ取得 state=all \u0026hellip; すべての Issue を取得 ちなみに curl コマンドでは、URL 末尾のクエリパラメーター (?...) の代わりに、次のように --data オプションで指定することもできます。 スクリプトを作成するときに便利かもしれません。 --data オプションを指定すると、curl は POST メソッドでアクセスしようとするので、-G も同時に指定して GET メソッドを使うように指示する必要があります。 クエリパラメーターの代わりに --data オプションを使う方法 $ curl -G --data \u0026#34;state=closed\u0026#34; https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues あるラベルが付いている Issue を取得する (labels) 例: \u0026#39;ラベル1\u0026#39; というラベルを持つ Issue を取得する $ curl -G --data-urlencode \u0026#34;labels=ラベル1\u0026#34; https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues labels パラメーターでは、複数のラベル名をカンマ区切りで指定することができます。 URL 末尾のクエリパラメーターとして指定することもできるのですが、日本語などを含むラベルは URL エンコードした形で指定しなければいけないので、ここでは curl の --data-urlencode オプションを使って labels パラメーターを渡しています。 この場合も前述の例と同様に、-G オプションを指定して GET メソッドを使う必要があります。 その他のパラメーター Issue の一覧を取得するときには、他にもいろいろクエリパラメーターで絞り込みを行えます。 詳しくは下記の GitHub Developers Guide のサイトで確認してみてください。 参考: Issues ｜ GitHub Developer Guide"},{url:"/p/4ziyhxe/",title:"Hugo でページリスト（記事一覧）に列挙されないページを作る (_build.list)",date:"2020-05-17T00:00:00Z",body:"Hugo でページリスト（記事一覧）に列挙されないページを作る (_build.list) Hugo 0.65.0 で、ビルド時の振る舞いを制御するためのフロントマター用プロパティ (_build) が導入されました。 記事ページのフロントマターで、_build.list プロパティを never に設定しておくと、.Pages、.RegularPages、.Sections などで返されるページリストに、そのページが含まれなくなります。 _build: # Whether to add it to any of the page collections. # # Note that the page can still be found with .Site.GetPage. # We extended this property from a boolean to an enum in Hugo 0.68.0. # Valid values are: # # - never: The page will not be included in any page collection. # - always (default): The page will be included in all page collections, # e.g. site.RegularPages, $page.Pages. # - local: The page will be included in any local page collection, # e.g. $page.RegularPages, $page.Pages. One use case for this # would be to create fully navigable, but headless content sections. list: always # Whether to render it. # # If always, the page will be treated as a published page, # holding its dedicated output files (index.html, etc…) and permalink. # We extended this property from a boolean to an enum in Hugo 0.76.0. # Valid values are: # # - never: The page will not be included in any page collection. # - always (default): The page will be rendered to disk and get a RelPermalink etc. # - link: The page will be not be rendered to disk, but will get a RelPermalink. render: always # Whether to publish its resources. # # These will still be published on demand, but enabling this can be useful # if the originals (e.g. images) are never used. # # - true: The Bundle\u0026#39;s Resources will be published. # - false: Still publish Resources on demand (when a resource\u0026#39;s .Permalink or # .RelPermalink is invoked from the templates) but will skip the others. publishResources: false 例えば、サイト内検索のページは特別な経路でのみリンクしたいので、「メニューツリー」や「子ページ一覧」などには表示しないようにしたいとします。 そのような場合は、該当記事の Markdown ファイルで次のようにフロントマターを設定すれば OK です。 content/search.md --- title: \u0026#34;サイト内検索\u0026#34; _build: list: never --- ネストされたプロパティは、次のように 1 行で記述することもできます。 --- title: \u0026#34;サイト内検索\u0026#34; _build: { list: never } --- この仕組みができるまでは、独自の nomenu プロパティなどを定義して対応していたのですが、リスト系のページから除外するのがとても簡単になりました。 一方で、サイトマップ・テンプレート などで .Data.Pages によるリスト出力しているところからも除外されてしまうので、そういった副作用には注意してください。"},{url:"/p/5fzgwdt/",title:"Hugo で JSON-LD 形式のパンくずリストを出力する（SEO 対策）",date:"2020-05-16T00:00:00Z",body:"Hugo で JSON-LD 形式のパンくずリストを出力する（SEO 対策） JSON-LD 形式の構造化データを HTML 内に含めておくと、Google の検索結果にページの階層構造が表示されるようになります。 この構造化データは、あくまで Google などの検索エンジンに記事の階層を伝えるためのもの であり、記事内に表示するためのパンくずリストではないことに注意してください。 画面表示用のパンくずリストを出力したいときは、下記の記事を参考にしてください。 参考: Hugo でパンくずリストを表示する パンくずリストのフォーマット JSON-LD 形式でパンくずリストを作成するときに、どのような内容で出力すればよいかは、 Google のパンくずリストの説明ページ に分かりやすく書かれています。 例えば、ある「記事ページ」が次のような階層で配置されているとします。 ホーム ＞ カテゴリA ＞ カテゴリB ＞ 記事ページ これを JSON-LD で表現するには、下記のようなコードを head 要素や body 要素の中に記述します。 特に理由がなければ、少しでもパフォーマンスを考慮して body 要素の最後に記述するのがよいでしょう。 \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BreadcrumbList\u0026#34;, \u0026#34;itemListElement\u0026#34;: [{ \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;サイト名\u0026#34;, \u0026#34;item\u0026#34;: \u0026#34;https://example.com/\u0026#34; },{ \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;カテゴリA\u0026#34;, \u0026#34;item\u0026#34;: \u0026#34;https://example.com/category-a\u0026#34; },{ \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: 3, \u0026#34;name\u0026#34;: \u0026#34;カテゴリB\u0026#34;, \u0026#34;item\u0026#34;: \u0026#34;https://example.com/category-b\u0026#34; },{ \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: 4, \u0026#34;name\u0026#34;: \u0026#34;記事ページのタイトル\u0026#34;, \u0026#34;item\u0026#34;: \u0026#34;https://example.com/article-page\u0026#34; }] } \u0026lt;/script\u0026gt; 重要なのは itemListElement プロパティで、この配列要素として各階層の内容を記述します。 とても単純なので説明するまでもないと思いますが、 name プロパティで各階層の名称、 item プロパティでその階層を示す URL を指定します。 position プロパティは 1、2、3 と順番に振っていけば OK です。 パンくずリストは記事の位置を論理的に階層化しますが、item プロパティで指定する URL は階層化されていなくてもよいところが柔軟性があってよいですね。 1 番目の要素にホームページのエントリ、最後の要素に記事ページ自体のエントリを配置するのが無駄なように感じるかもしれませんが、Google 検索の結果ではこのあたりを考慮して表示を最適化してくれるので、心配せずに全て含めておけば大丈夫です。 テンプレートで JSON-LD を出力する ここでは、Hugo のパーシャルテンプレートで、JSON-LD 形式のパンくずリストを出力できるようにします。 まず、ユーティリティ関数として、現在のページの階層構造を .Page の配列で取得するパーシャルテンプレートを用意します。 参考: ページの階層構造を取得する関数を作成する (get-hierarchy) layouts/partials/function/get-hierarchy.html {{ $hierarchy := slice . }} {{ if .Parent }} {{ $parentHierarchy := partial \u0026#34;function/get-hierarchy\u0026#34; .Parent }} {{ if $parentHierarchy }} {{ $hierarchy = $parentHierarchy | append $hierarchy }} {{ end }} {{ end }} {{ return $hierarchy }} 次のパーシャルテンプレートでは、上記の get-hierarchy ユーティリティが返す階層情報を使って、JSON-LD 形式のパンくずリストを出力します。 layouts/partials/breadcrumb-json.html {{ $hierarchy := partial \u0026#34;function/get-hierarchy\u0026#34; . }} \u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; { \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BreadcrumbList\u0026#34;, \u0026#34;itemListElement\u0026#34;: [ {{- range $index, $page := $hierarchy }} {{- if gt $index 0 }},{{ end }} { \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: {{ add $index 1 }}, \u0026#34;name\u0026#34;: {{ $page.LinkTitle }}, \u0026#34;item\u0026#34;: {{ $page.Permalink }} } {{- end }} ] } \u0026lt;/script\u0026gt; あとは、任意のレイアウト用テンプレートから、次のように呼び出せば、そこにパンくずリストが出力されます。 layouts/_default/baseof.html（抜粋） \u0026lt;body\u0026gt; ... 省略 ... {{ partial \u0026#34;breadcrumb-json\u0026#34; . }} \u0026lt;/body\u0026gt; JSON-LD の内容を検証する 出力された JSON-LD 形式のパンくずリストは、下記のサイトで検証することができます。 Google 構造化データ テストツール BreadcrumbList の項目でエラーが出ていないことを確認しましょう。"},{url:"/p/v9t62ux/",title:"Hugo でページの階層構造を取得する関数を作成する (get-hierarchy)",date:"2020-05-16T00:00:00Z",body:"Hugo でページの階層構造を取得する関数を作成する (get-hierarchy) 何を作るか？ Hugo の記事ページは、次のような感じで、セクション機能を使って階層化することができます。 ホーム ＞ セクション1 ＞ セクション2 ＞ ページタイトル ここでは、上記のような階層構造をスライス（配列）で取得する 関数を作成 してみます。 ページの階層構造を取得できると、パンくずリストなどを簡単に出力できるようになります。 階層構造を取得する関数 関数はパーシャルテンプレートの形で作るので、layouts/partials の下に .html ファイルを作成します。 ここでは、関数であることを明確にするために、さらに function という名前のディレクトリを作ってその下に格納することにします。 関数名（テンプレート名）は get-hierarchy とします。 layouts/partials/function/get-hierarchy.html {{ $hierarchy := slice . }} {{ if .Parent }} {{ $parentHierarchy := partial \u0026#34;function/get-hierarchy\u0026#34; .Parent }} {{ if $parentHierarchy }} {{ $hierarchy = $parentHierarchy | append $hierarchy }} {{ end }} {{ end }} {{ return $hierarchy }} この関数は、任意のテンプレートファイルから次のように呼び出します。 {{ $hierarchy := partial \u0026#34;function/get-hierarchy\u0026#34; . }} $hierarchy 変数には、ホームページからカレントページまでの Page 変数の配列データ が格納されます。 例えば、次のようにすれば、ページ階層を番号付きでリンク表示できます。 {{ $hierarchy := partial \u0026#34;function/get-hierarchy\u0026#34; . }} {{- range $index, $page := $hierarchy }} {{ $index }}: \u0026lt;a href=\u0026#34;{{ $page.RelPermalink}}\u0026#34;\u0026gt;{{ $page.Title }}\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; {{- end }} 表示結果のイメージ 0: ホーム 1: セクション1 2: セクション2 3: ページタイトル この get-hierarchy 関数を使用すれば、パンくずリストのようなものも簡単に表示できるはずです。 参考: パンくずリストを表示する ← こちらの記事では関数を使わずに出力してますが"},{url:"/p/9tg2m7q/",title:"Hugo のショートコードをエスケープ処理してそのまま表示する",date:"2020-05-07T00:00:00Z",body:"Hugo のショートコードをエスケープ処理してそのまま表示する Hugo で作成した記事（.md ファイル）内でショートコードの使い方を説明するときなど、ショートコードのタグそのものを文章中に表示させたいことがあります。 そのまま記述するとショートコードとして処理されてしまうので、次のようにエスケープ処理して記述する必要があります。 Markdown ファイル内での書き方 出力結果 {{\u0026lt;/* my-shortcode */\u0026gt;}} {{\u0026lt; my-shortcode \u0026gt;}} {{%/* my-shortcode */%}} {{% my-shortcode %}} ショートコード名の部分 (my-shortcode) を C/C++ や Java のコメント風に囲めば OK です。 コードブロックの中でも同様にエスケープ処理できます。"},{url:"/p/m2n8rbu/",title:"Hugo の記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout)",date:"2020-05-04T00:00:00Z",body:"Hugo の記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout) フロントマターでのレイアウト指定 Hugo では、記事ファイル (.md) のレンダリングにどのレイアウトファイルを使用するかは、content ディレクトリ以下にどのようなパスで .md ファイルを配置したかによって決まります。 ほとんどのページではこれで十分なのですが、あるページだけ特殊なレイアウトを使用したい ことがあります。 例えば、検索ページや、新着記事リストのページなどです。 このような場合は、Markdown ファイルのフロントマターで、type プロパティや layout プロパティを指定することで、使用するレイアウトファイルを制御することができます。 type プロパティ コンテントタイプを指定します。デフォルトでは、content ディレクトリ以下のディレクトリ名が使われます（参考: Content Types | Hugo）。 layout プロパティ レイアウト名を指定します。デフォルトでは、ページの種類によって section.html（セクションテンプレート）や single.html（シングルページテンプレート）が使用されます。 これらの値の組み合わせによって、そのページをレンダリングするときに使用するレイアウトファイル（テンプレート）が次のように決まります。 layouts/\u0026lt;タイプ名\u0026gt;/\u0026lt;レイアウト名\u0026gt;.html 実際には、すべてのコンテントタイプで共通のレイアウトファイルを使えばよいことが多く、そのようなケースでは layouts/_default/single.html といったレイアウトファイルを配置します（タイプ名として _default 指定されたかのように振る舞います）。 複数のレイアウトファイルが存在する場合に、どのレイアウトファイルが選択されるかのルールは下記を参照してください。 参考: レイアウト用のテンプレートの種類を理解する 通常、コンテントタイプとレイアウトファイル名は、ディレクトリ構造と Markdown ファイル名によって決まるようになっています。 例えば、次のような感じです。 Markdown フィイル名 コンテントタイプ レイアウトファイル content/foo/_index.md foo section.html や list.html content/foo/page1.md foo single.html content/bar/page2.md bar single.html content/foo/bar/page3.md foo single.html フロントマターで type と layout を指定することにより、これらのルールを無視して、強制的に使用するレイアウトファイルを変更することができます。 例を見た方が分かりやすいので、ここでは、「新着一覧」のページをサンプルとして作ってみます。 ☝️ ワンポイント 記事の一覧を表示するくらいであれば、通常はショートコードで出力してしまった方が簡単です。 ここでは、特定のページだけレイアウトを大きく変更する必要があると想定しています 使用するレイアウトファイルを指定する例 下記のテンプレートでは、更新日時が新しい順に、5 件分の記事をリスト表示しています。 このレイアウトは、「新着一覧」のページでしか使わない 特殊なレイアウト なので、レイアウトファイル自体も layouts/special/latest.html という特殊なパスに作成することにします。 このレイアウトファイルは、コンテントタイプとして special、レイアウト名として latest が設定された記事ファイルに適用されます。 layouts/special/latest.html（抜粋） \u0026lt;ul\u0026gt; {{- range first 5 .Site.RegularPages.ByLastmod.Reverse }} \u0026lt;li\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;time\u0026gt;{{ .Date.Format \u0026#34;2006-01-02\u0026#34; }}\u0026lt;/time\u0026gt; \u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; 次に、記事一覧のページを出力するための Markdown ファイルを作成します。 コンテントタイプとレイアウト名はフロントマターで指定するので、Markdown ファイルはどのようなパスに配置しても構いません。 ここでは、content ディレクトリ直下に配置することにします。 content/latest.html --- title: \u0026#34;新着一覧\u0026#34; type: \u0026#34;special\u0026#34; layout: \u0026#34;latest\u0026#34; --- （本文は空っぽで OK） 本文はレイアウトファイルの方で出力される内容だけでいいので、Markdown ファイルにはフロントマターだけを記述します。 コンテントタイプとして special、レイアウト名として latest を指定しているので、layouts/special/latest.html というパスに配置したレイアウトファイルが使用されることになります。 もちろん、記事ファイルを配置するパスによって、使用するレイアウトファイルをうまく制御するのでも OK です。 例えば、content/latest/_index.md というパスに Markdown ファイルを配置すれば、フロントマターで type や layout を指定しなくても、レイアウトファイルとして layouts/latest/section.html（あるいは list.html）が使用されます。"},{url:"/p/qr4eox7/",title:"Hugo でサーチエンジン用に sitemap.xml や robots.txt ファイルを配置する",date:"2020-04-26T00:00:00Z",body:"Hugo でサーチエンジン用に sitemap.xml や robots.txt ファイルを配置する サーチエンジンに対して、インデックス登録させたいページを伝えるには、Web サイトに sitemap.xml や robots.txt というファイルを配置します。 Google の検索結果に影響するため、正しく理解して配置しましょう。 sitemap.xml と robots.txt の概要 Web サイトのルートに sitemap.xml や robots.txt を置くと、下記のようなヒント情報を Google などの検索エンジンに伝えることができます。 sitemap.xml \u0026hellip; サイト内のページ一覧情報を記述します。検索エンジンは、サイト全体をクロールしなくても、この情報でページのインデックス情報を作成できるようになります。ページごとに更新日時 (YYYY-MM-DD) や優先度 (0.0〜1.0) を指定できます。 robots.txt \u0026hellip; クロールしなくてもよいディレクトリやファイルを指定します。上記の sitemap.xml の URL を指定することもできます。 もちろん、これらのファイルを用意したところで、どこまで反映されるかは検索エンジン側の実装によりますが、SEO 対策として少しでもヒントとなる情報を与えておくのが望ましいでしょう。 sitemap.xml を作成する sitemap.xml ファイルには、Google などの検索エンジンにインデックス登録してもらいたいページの一覧を記述します。 sitemap.xml のデフォルト出力 Hugo はデフォルトで Web サイトのルートに、Sitemap protocol に基づいた sitemap.xml ファイルを出力するようになっています。 下記はデフォルト設定で出力される sitemap.xml の例です。 sitemap.xml \u0026lt;urlset xmlns=\u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34; xmlns:xhtml=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;https://example.com/page1/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-04-26T00:00:00+00:00\u0026lt;/lastmod\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;https://example.com/page2/\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-04-25T00:00:00+00:00\u0026lt;/lastmod\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;/urlset\u0026gt; この出力は、Hugo にデフォルトで組み込まれている sitemap.xml テンプレートによって生成されています。 デフォルトのテンプレート定義は下記を見ると分かります。 Hugo’s sitemap.xml gohugoio/hugo/tpl/tplimpl/embedded/templates/_default/sitemap.xml (GitHub) このままで問題なければ、特に何も設定する必要はありませんが、出力内容をカスタマイズしたいときは、次のように sitemap.xml 用のテンプレートファイルを生成する必要があります。 Hugo はデフォルトですべてのページを sitemap.xml にリスト化しようとするので、Google などの検索結果に載せたくないページがある場合は、sitemap.xml のカスタマイズが必要です。 sitemap.xml のカスタマイズ 下記のいずれかのテンプレートファイルを作成することで、Web サイトのルートディレクトリに出力される sitemap.xml の内容をカスタマイズできます。 layouts/sitemap.xml layouts/_default/sitemap.xml ここでは、下記のようにカスタマイズしてみます。 タクソノミーリスト（あるタグのページ一覧）のページを出力しない（/tags/* や /categories/* などをリストに載せない） 特定の URL 以下のページを出力しない (URL が /search/ で始まるページをリストに載せない） Markdown ファイルのフロントマターで noindex: true と記述されていたら出力しない セクションページの優先度を上げる（デフォルトで priority=0.5 のところを priority=1.0 とする。ただしフロントマターでの指定があればそちらを優先） layouts/sitemap.xml \u0026lt;urlset xmlns=\u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34; xmlns:xhtml=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34;\u0026gt; {{- range .Data.Pages }} {{- if ne .Kind \u0026#34;term\u0026#34; }} {{- if not (hasPrefix .RelPermalink \u0026#34;/search/\u0026#34;) }} {{- if ne .Params.noindex true }} \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;{{ .Permalink }}\u0026lt;/loc\u0026gt; {{- if not .Lastmod.IsZero }} \u0026lt;lastmod\u0026gt;{{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}\u0026lt;/lastmod\u0026gt; {{- end }} {{- with .Sitemap.ChangeFreq }} \u0026lt;changefreq\u0026gt;{{ . }}\u0026lt;/changefreq\u0026gt; {{- end }} {{- if ge .Sitemap.Priority 0.0 }} \u0026lt;priority\u0026gt;{{ .Sitemap.Priority }}\u0026lt;/priority\u0026gt; {{- else if eq .Kind \u0026#34;section\u0026#34; }} \u0026lt;priority\u0026gt;1.0\u0026lt;/priority\u0026gt; {{- end }} \u0026lt;/url\u0026gt; {{- end }} {{- end }} {{- end }} {{- end }} \u0026lt;/urlset\u0026gt; ここでは、ページ変数の .Kind の値を見ることで、セクションやタクソノミーリスト (/tags/*) のページであるかどうかを判断しています。 このあたりのページ変数がどのような値を取るかに関しては、下記の記事を参考にしてください。 参考: 各種ページにおいて .Kind や .IsPage、.IsNode の値がどうなるかの一覧 ｜ まくまく Hugo/Go ノート 各ページのフロントマターでサイトマップ出力を制御する ページごとにサイトマップ出力を制御したい場合は、フロントマターのプロパティを設定します。 サイトマップに列挙されないようにする サイトマップには列挙したくない特殊なページがあるかもしれません。 簡単な方法として、Hugo 組み込みの _build プロパティで、list: never を指定してしまう方法があります（参考: Hugo でページリスト（記事一覧）に列挙されないページを作る）。 このフラグを設定すると、Hugo の .Pages や .RegularPages などのコレクションに含まれなくなるので、結果的に sitemap.xml にも列挙されなくなります（サイトマップテンプレート内で .Data.Pages をループ処理していたことに着目してください）。 content/page.md（Hugo の _build プロパティで出力抑制） --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2023-05-31\u0026#34; _build: { list: never } --- 別の方法として、独自の noindex プロパティを定義してしまう方法もあります。 .Pages コレクションなどには含めたいけれど、サイトマップには列挙したくないといった事情があれば、このような独自プロパティを使って制御します。 前述のカスタマイズされた sitemap.xml 用テンプレートでは、この noindex プロパティがセットされていたら、そのページの URL を列挙しないようにしています。 content/page.md（独自の noindex プロパティで出力抑制） --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2023-05-31\u0026#34; noindex: true --- ちなみに、独自の noindex プロパティを導入するのであれば、それと連動させて HTML の meta 要素を出力するようにしておくのがよいでしょう（noindex 用の meta 要素については後述）。 layouts/_default/baseof.html（ベーステンプレートの抜粋） \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; {{- if .Params.noindex }} \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;noindex\u0026#34; /\u0026gt; {{- end }} サイトマップに出力される情報を調整する (changefreq, priority) Hugo 組み込みの sitemap プロパティを設定することで、sitemap.xml に出力する \u0026lt;changefreq\u0026gt; や \u0026lt;priority\u0026gt; 要素の値を制御することができます。 これらの値は、前述のテンプレート内で .Sitemap.ChangeFreq、.Sitemap.Priority といった変数で参照しています。 content/page.md（ページのプライオリティなどを調整） --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2020-04-26\u0026#34; sitemap: changefreq: monthly priority: 0.8 --- sitemap.xml の出力先パスを変更する sitemap.xml はデフォルトで Web サイトのルートに出力されますが、Hugo の設定ファイルで出力パスを変更することができます。 hugo.toml [sitemap] filename = \u0026#34;assets/my-sitemap.xml\u0026#34; robots.txt によるクロールの抑制 Web サイトのルートに robots.txt を配置しておくと、検索エンジンに対して、そのサイト内でクロールされたくないディレクトリやファイルを知らせることができます（参考: robotstxt.org）。 また、上記で作成した sitemap.xml の URL を知らせることもできます。 robots.txt を出力するための設定 静的なファイルとして robots.txt を作成するのであれば、単純に Hugo プロジェクト内に /static/robots.txt というファイルを配置しておけば OK です（robots.txt が出力ディレクトリのルートにコピーされます）。 テンプレート機能を使って、動的に robots.txt を生成したいのであれば、設定ファイルで下記のように指定しておく必要があります。 hugo.toml enableRobotsTXT = true この設定により、下記のテンプレートファイルを使って robots.txt を生成してくれるようになります。 /layouts/robots.txt /themes/\u0026lt;THEME\u0026gt;/layouts/robots.txt 下記のようなテンプレートを作成すると、すべての種類のクローラーに対して sitemap.xml の URL を知らせるための robots.txt を生成できます。 /layouts/robots.txt User-agent: * Sitemap: {{ .Site.BaseURL }}sitemap.xml sitemap.xml のパスは、FQDN（完全修飾 URL）で指定しなければいけないので、上記のようにテンプレート内で .Site.BaseURL 変数を使って完全な URL を構築しています。 robots.txt の Disallow ディレクティブはあまり使わない よくある robots.txt の例として、Disallow ディレクティブを使ったクロールの防止方法が示されていたりしますが、実際に Disallow ディレクティブが必要になるケースはそれほど多くありません（それよりは後述の meta 要素を使う方が目的と合っていることが多いです）。 特に、JavaScript や CSS、画像ファイルなどは、検索エンジンがページ内容を正しく処理するために必要なので、Disallow 指定してクロール対象から外してはいけません。 Google の検索結果から除外する（meta 要素の noindex 設定） robots.txt の Disallow ではなく meta 要素の noindex を使う 特定のページを Google の検索結果に表示されないようにするには、HTML の head 要素内に下記のような meta 要素を記述するのが正解みたいです。 \u0026lt;meta name=\u0026#34;robots\u0026#34; content=\u0026#34;noindex\u0026#34; /\u0026gt; robots.txt に下記のように指定すれば、/search/ 以下をクロールしないように知らせることにはなるのですが、すでにインデックスされてしまったページは検索結果に表示され続けることになってしまいます。 robots.txt User-agent: * Disallow: /search/ また、クロールを防いだとしても、他のページからリンクされている場合はインデックスされてしまう可能性があります。 よって、検索エンジンに特定のページがインデックスされることを防ぐには、 meta 要素で noindex を指定する robots.txt の Disallow は指定しない とするのがよいようです。 参考: noindex を使用して検索インデックス登録をブロックする - Search Console ヘルプ 重要: noindex ディレクティブが有効に機能するようにするために、robots.txt ファイルでページをブロックしないでください。ページが robots.txt ファイルでブロックされると、クローラは noindex ディレクティブを認識しません。そのため、たとえば他のページからリンクされていると、ページは検索結果に引き続き表示される可能性があります。 （コラム）Google Search Console の sitemap.xml に関するエラー sitemap.xml にリストアップされているにも関わらず、HTML ファイルの \u0026lt;meta name=\u0026quot;robots\u0026quot; content=\u0026quot;noindex\u0026quot;\u0026gt; でインデックス登録を抑制しているようなページがあると、Google Search Console にエラーが表示されることがあります。 図: 送信された URL に noindex タグが追加されています これは、「sitemap.xml でインデックス登録しろと指定されているけど、実際にページの内容を見ると meta 要素で noindex 指定されてるのでインデックス登録しないよ。それでいいの？」という意味の警告です。 インデックス登録されたくないページは、sitemap.xml にもリストアップされないように整合性を取りましょう。"},{url:"/p/88e7tiz/",title:"Hugo のテンプレートの中で絵文字を使用する (emojify)",date:"2020-04-13T00:00:00Z",body:"Hugo のテンプレートの中で絵文字を使用する (emojify) emojify 関数の概要 Hugo のテンプレートファイルの中で emojify 関数 を使用すると、GitHub や Slack などで使える有名どころの絵文字 (emoticons) を出力することができます。 使えるアイコンのリストは下記サイトで確認できます。 🎁 Emoji cheat sheet for GitHub, Basecamp, Slack \u0026amp; more 例えば、:smile: アイコンを表示したければ、任意のテンプレートファイルの中で次のように記述します。 {{ emojify \u0026#34;:smile:\u0026#34; }} emojify 関数の使用例 下記の例では、Hugo をサーバーモードで起動しているときに、ローカルファイルのパスをアイコン付きで表示します。 layouts/_default/single.html（抜粋） {{ if .Site.IsServer }} {{ emojify \u0026#34;:memo:\u0026#34; }}{{ .File.Filename }} {{ end }} 図: 表示結果"},{url:"/p/4anjern/",title:"Hugo のパーシャルテンプレートから値を返す（関数化）(return)",date:"2020-04-06T00:00:00Z",body:"Hugo のパーシャルテンプレートから値を返す（関数化）(return) パーシャルテンプレートを関数として使用する Hugo v.0.55 以降のパーシャルテンプレートでは、テキストを出力する代わりに、値を return できるようになっています（参考: Returning a value from a Partial ｜ Hugo）。 この機能をうまく使うと、テンプレート内の共通処理をくくり出して、コードをスッキリさせることができます（通常のプログラミング言語の関数と同じイメージ）。 例えば、次の my-add-100 パーシャルテンプレートは、引数で受け取った値に 100 を足した値を返します。 パーシャルテンプレートの呼び出し時に渡された引数は、コンテキスト (.) として参照できます。 layouts/partials/functions/my-add-100.html {{ $ret := add 100 . }} {{ return $ret }} ここでは、関数風に呼び出せるパーシャルテンプレートであることを示すために、functions というディレクトリ以下に HTML ファイルを保存していますが、このあたりは自由です。 呼び出し側のテンプレートからは、次のように関数のように呼び出して、戻り値を受け取ることができます。 layouts/_default/single.html（抜粋） {{ $ret := partial \u0026#34;functions/my-add-100\u0026#34; 50 }} 戻り値: \u0026lt;b\u0026gt;{{ $ret }}\u0026lt;/b\u0026gt; レンダリング結果は次のようになります。 戻り値: \u0026lt;b\u0026gt;150\u0026lt;/b\u0026gt; パーシャルテンプレートに複数の値（引数）を渡す パーシャルテンプレートに複数の値を渡すには、辞書オブジェクト（キー＆バリュー）の形で値を渡します。 次のパーシャンテンプレート (my-add) は、2 つの数値を受け取り、それらを足し合わせた結果を返します。 ここでは、辞書のキー名として val1 と val2 を使用することを想定していますが、キー名は何でも構いません。 下記のように、パーシャルテンプレートの先頭で辞書キーを参照して変数に代入するようにしておくと、このパーシャルテンプレートがどのような辞書キーを期待しているのかが分かりやすくなります。 layouts/partials/functions/my-add.html {{ $v1 := .val1 }} {{ $v2 := .val2 }} {{ return (add $v1 $v2) }} このパーシャルテンプレートを呼び出すには、次のように dict 関数を使って辞書オブジェクトを作成して引数として渡します。 ここでは、val1 に 100、val2 に 200 という値を入れて渡しているので、結果として 300 という値が返ってきます。 テンプレートからの呼び出し例 {{- $ret := partial \u0026#34;functions/my-add\u0026#34; (dict \u0026#34;val1\u0026#34; 100 \u0026#34;val2\u0026#34; 200) }} 戻り値: \u0026lt;b\u0026gt;{{ $ret }}\u0026lt;/b\u0026gt; レンダリング結果 戻り値: \u0026lt;b\u0026gt;300\u0026lt;/b\u0026gt; ☝️ 引数は 1 つしか渡せない partial 関数の呼び出し時に指定した第 2 引数は、パーシャルテンプレート側のコンテキスト (.) として参照できるようになるのですが、次のように複数の値を単純に並べて渡すことはできません。 間違った呼び出し方 {{ $ret := partial \u0026#34;functions/my-add\u0026#34; 100 200 }} なぜなら、第 3 引数の値 (200) は、パーシャルテンプレート呼び出しのキャッシュ用のキーとして使われるという仕様になっているからです。 詳しくは、公式サイトの partialCached 関数 の説明を参照してください。 パーシャルテンプレートからリストを返す パーシャルテンプレートの return では、様々な型のオブジェクトを返すことができます。 例えば次の get-colors パーシャルテンプレートでは、slice で作成したリストを返しています。 layouts/partials/functions/get-colors.html {{ $ret := slice \u0026#34;Blue\u0026#34; \u0026#34;Red\u0026#34; \u0026#34;Yellow\u0026#34; }} {{ $ret = $ret | append \u0026#34;Black\u0026#34; \u0026#34;White\u0026#34; }} {{ return $ret }} 呼び出し元のテンプレートファイルでは、get-colors が返したリストを range などでループ処理します。 layouts/_default/single.html \u0026lt;ul\u0026gt; {{- range partial \u0026#34;functions/get-colors\u0026#34; . }} \u0026lt;li\u0026gt;{{ . }} {{- end }} \u0026lt;/ul\u0026gt; 実行結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Blue \u0026lt;li\u0026gt;Red \u0026lt;li\u0026gt;Yellow \u0026lt;li\u0026gt;Black \u0026lt;li\u0026gt;White \u0026lt;/ul\u0026gt; インラインパーシャルテンプレート パーシャルテンプレートは、通常 layouts/partils ディレクトリ以下に HTML ファイルとして作成しますが、テンプレート（ショートコードやレイアウトファイル）の中で、define 関数を使って、インラインに定義してしまうこともできます（参考: Inline Partials）。 特定のショートコード内でしか使わないような関数を定義したいときに利用できるかもしれません。 layouts/shortcodes/my-shortcode.html {{/* インラインパーシャルを定義する （partials プレフィックスを付ける） */}} {{ define \u0026#34;partials/functions/inline-add\u0026#34; }} {{ $v1 := .val1 }} {{ $v2 := .val2 }} {{ return (add $v1 $v2) }} {{ end }} {{/* 上記は同じテンプレート内から呼び出せる （partials プレフィックスは省略できる） */}} {{- $ret := partial \u0026#34;functions/inline-add\u0026#34; (dict \u0026#34;val1\u0026#34; 100 \u0026#34;val2\u0026#34; 200) }} 戻り値 = {{ $ret }} define 関数で、インラインパーシャルテンプレートを定義する時は、プレフィックスとして partials/ を付けることに注意してください。 これにより、partial 関数による呼び出しが可能になります。 partials/ プレフィックスを付けずに定義した場合は、通常の部分テンプレートとして template 関数で呼び出すことができるようになるのですが、その方法だと戻り値を返すことができません（戻り値を返すことができるのは、パーシャルテンプレートを partial 関数で呼び出したときのみです）。 パーシャルテンプレートの名前空間はグローバルに共有されるため、名前のコンフリクトには注意してください。 同じ名前のテンプレートが定義されている場合は、Hugo ビルド時に次のようなエラーになります。 multiple definition of template \u0026#34;partials/functions/inline-add\u0026#34;"},{url:"/p/kmv4bjr/",title:"Hugo でページ内リンク（アンカー）を張る",date:"2020-04-05T00:00:00Z",body:"Hugo でページ内リンク（アンカー）を張る ページ内リンクを張ることで、ワンクリックでページ内の任意の位置へジャンプできるようになります。 ヘッダ要素 (h2, h3, h4) へのジャンプ 自動的に割り振られる id 属性を使用する Hugo はデフォルトで、ヘッダ要素（h2 などの見出し）に id 属性を付けてくれます。 例えば、次のようなヘッダがあったとすると、 Link to me ---- 生成される h2 要素には、次のように自動的に id 属性が設定されます（スペースは - に置き換えられます）。 \u0026lt;h2 id=\u0026#34;link-to-me\u0026#34;\u0026gt;Link to me\u0026lt;/h2\u0026gt; よって、このヘッダ要素には、次のような内部リンクを張ることができます。 [Link to me へジャンプ](#link-to-me) もちろん、他のページのヘッダ要素へのリンクを張ることもできます。 [Link to me へジャンプ](/posts/pagename/#link-to-me) ヘッダ要素に独自の id 属性を設定する ヘッダ要素に自動的に割り振られる id 属性を使用することの欠点は、アルファベットや数字以外の文字が削除されてしまうことです。 また、見出しを変更すると id 属性の値も変わってしまうので、リンク切れのリスクも高まります。 例えば、次のような見出しがあったとすると、 OGP とは ---- 出力される HTML は次のようになります。 \u0026lt;h2 id=\u0026#34;ogp-\u0026#34;\u0026gt;OGP とは\u0026lt;/h2\u0026gt; 日本語の「とは」の部分が無視され、分かりにくい ID になってしまっています。 このような不完全な ID が割り当てられるのが嫌な場合は、次のようにして独自の ID を設定することができます。 OGP とは {#what-is-ogp} ---- 出力される HTML は次のようになります。 \u0026lt;h2 id=\u0026#34;what-is-ogp\u0026#34;\u0026gt;OGP とは\u0026lt;/h2\u0026gt; これで、次のように自信を持って内部リンクを張ることができます。 詳細は [OGP の説明](#what-is-ogp) を参照してください。 任意の位置にアンカーを設定するショートコード 通常は、前述のようなヘッダ要素への内部リンクを使うだけで十分ですが、任意の位置に内部リンクを張りたいことがあるかもしれません。 次の anchor ショートコードは、id 属性を持つ、空っぽのアンカータグを出力します（ちなみに、id 属性の代わりに name 属性を設定しても同様の振る舞いをしますが、HTML5 では id 属性の方を使用すべきとされています）。 layouts/shortcodes/anchor.html \u0026lt;a id=\u0026#34;{{ .Get 0 }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; Markdown ファイルの中で、アンカーを設定したい位置（ジャンプ先）で次のようにショートコードを呼び出します。 content/posts/sample.md {{\u0026lt; anchor \u0026#34;what-is-ogp\u0026#34; \u0026gt;}} ここに OGP の説明を記述。 ここにジャンプしてきたい。 ここにジャンプするためのリンクを張るには次のように記述します。 詳細は [OGP の説明](#what-is-ogp) を参照してください。"},{url:"/p/vit4ckt/",title:"Hugo で「このページを編集 (Edit this page)」のリンクを表示する",date:"2020-04-01T00:00:00Z",body:"Hugo で「このページを編集 (Edit this page)」のリンクを表示する GitHub の編集ページ GitHub には簡易的なエディタ機能があり、ウェブサイト上で Markdown ファイルを直接編集できるようになっています。 Hugo サイトのコンテンツを GitHub で管理しているのであれば、GitHub の編集ページにリンクを張っておくと便利かもしれません。 この編集ページを使用すれば、Git コマンドに不慣れな人でも手軽に Markdown ファイルを修正することができます。 例えば、https://github.com/yourname/website/ といった GitHub リポジトリで Hugo のサイトコンテンツを管理している場合、トップページの Markdown ファイルを編集するための URL は次のようになります。 https://github.com/yourname/website/edit/master/content/_index.md ここでは、Hugo で生成する各ページに、上記のような編集ページへのリンクを出力することを考えてみます。 編集ページへのリンクを出力する まず、GitHub リポジトリのベース URL は、Hugo の設定ファイルに、独自パラメータ editBaseURL として定義することにしましょう。 hugo.toml baseURL = \u0026#34;https://example.com\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;私のウェブサイト\u0026#34; [params] editBaseURL = \u0026#34;https://github.com/yourname/website/edit/master/content\u0026#34; 次に、編集ページへのリンクを出力するためのパーシャルテンプレートを作成します。 layouts/partials/edit-this-page.html {{ if $.Site.Params.editBaseURL }} {{- $filepath := replace .File.Path \u0026#34;\\\\\u0026#34; \u0026#34;/\u0026#34; -}} {{- $url := printf \u0026#34;%s/%s\u0026#34; $.Site.Params.editBaseURL $filepath -}} \u0026lt;a href=\u0026#34;{{ $url }}\u0026#34;\u0026gt;Edit this page\u0026lt;/a\u0026gt; {{- end }} このテンプレートでは次のようなことを行っています。 設定ファイルに editBaseURL が定義されている場合のみ処理を継続 .File.Path で、Markdown ファイルの content ディレクトリからの相対パスを取得（さらに、Windows を考慮してバックスラッシュをスラッシュに変換しておく） editBaseURL の値と Markdown ファイルのパスを組み合わせて、編集ページの URL を構築（URL の結合に path.Join が使えるかと思ったけど、https:// のスラッシュが一個削除されてしまってうまくいかないので、ここでは printf で結合してます） HTML のアンカータグ (a) を出力 あとは、このパーシャルテンプレートを、任意のレイアウトファイルから呼び出せば OK です。 ここでは、シングルページテンプレートから呼び出してみます。 layouts/_default/single.html（抜粋） {{ partial \u0026#34;edit-this-page\u0026#34; . }}"},{url:"/p/2ycmvbn/",title:"hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする",date:"2020-03-25T00:00:00Z",body:"hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする Hugo は、各種クラウド (Azure Storage, Google Cloud Storage, AWS S3) 上のストレージにデプロイするためのコマンドを標準で搭載しています。 hugo deploy コマンドとは 静的なウェブサイトをホスティングするために、次のような有名どころのストレージサービスを使用している人は多いと思います。 Microsoft の Azure Storage (BLOB Storage) Google の GSC (Google Cloud Storage) Amazon の AWS S3 Hugo が搭載している hugo deploy コマンドを使用すると、プロジェクトの設定ファイル (hugo.toml) に記述されたデプロイ設定に基づき、これらのサービスへのデプロイを行えるようになります。 もちろん、各種ストレージサービス用の CLI（コマンドラインツール）を使ってもデプロイすることはできるのですが、hugo deploy を使うことでデプロイ方法が単純化（統一化）され、余計なコマンドラインツールをインストールしなくてもデプロイを実行できるという利点があります。 ここでは、Azure のストレージコンテナ（BLOB ストレージ）に Hugo で生成した Web コンテンツをデプロイする方法を説明します。 Azure のストレージコンテナにデプロイする hugo deploy の設定 Azure Storage は、簡単に静的な Web サイトをホスティングする機能を提供しています。 ここでは詳細な手順は記載しませんが、下記サイトのように、(1) ストレージアカウントの作成、(2) 静的な Web サイトを有効化、という 1 分くらいの手順で Web サイトを立ち上げることができます。 利用料金も、小規模なサイトであれば月額 100 円もかからないくらいリーズナブルです。 参考: Azure Storage で静的 Web サイトをホスティングする｜まくろぐ Azure Storage で静的な Web サイトを有効化すると、$web という名前のストレージコンテナが生成されるので、ここにデプロイするための設定を設定ファイル (hugo.toml) に追記します。 hugo.toml（追記） [[deployment.targets]] URL = \u0026#34;azblob://$web\u0026#34; あとはデプロイ先を示す Azure Storage のストレージアカウント名と、アクセス用のキーを、次のような環境変数で設定します。 環境変数 AZURE_STORAGE_ACCOUNT: ストレージアカウント名 環境変数 AZURE_STORAGE_KEY: ストレージキー（代わりに SAS トークンを使いたい場合は AZURE_STORAGE_SAS_TOKEN を設定します） 設定は最低限これだけしておけばよいので、とてもシンプルです。 さらに細かい設定については 公式サイト を参照してください。 hugo deploy の実行 あとは、次のように hugo コマンドで Web サイトをビルドし、hugo deploy コマンドでデプロイを実行できます。 # サイトをビルド（public ディレクトリを生成） $ hugo Building sites … # デプロイを実行（public ディレクトリの中身をアップロード） $ hugo deploy Deploying to target \u0026#34;\u0026#34; (azblob://$web) Identified 38 file(s) to upload, totaling 6.0 MB, and 0 file(s) to delete. Success! 今回はデプロイ先が 1 つなので、ターゲット名の設定を省略しており、ログにもターゲット名が出力されていません。 差分アップロードもちゃんとできているようです（azcopy sync に相当）。 コンテンツに更新がない場合は、次のようにアップロード処理をスキップしてくれます。 $ hugo deploy Deploying to target \u0026#34;\u0026#34; (azblob://$web) No changes required. ちなみに、プロキシ環境から hugo deploy を実行したいときは、http_proxy 環境変数を設定しておけば OK です。 （おまけ）アップロード用のバッチファイル 下記は、hugo コマンドによるサイトのビルドと、hugo deploy によるデプロイをまとめて実行する Windows バッチファイルの例です。 AZURE_STORAGE_ACCOUNT、AZURE_STORAGE_KEY などの汎用的な環境変数をシステム全体に設定してしまうのが嫌な場合は、下記のように独自の環境変数に設定した値を伝搬させて設定するとよいでしょう。 deploy.bat @echo off setlocal set AZURE_STORAGE_ACCOUNT=%MAKU_AZURE_STORAGE_ACCOUNT% set AZURE_STORAGE_KEY=%MAKU_AZURE_STORAGE_KEY% if defined MAKU_AZURE_STORAGE_PROXY ( set http_proxy=%MAKU_AZURE_STORAGE_PROXY% ) hugo hugo deploy"},{url:"/p/w7r8p6m/",title:"Hugo サイトで SNS（Twitter や Facebook）用の表示設定を行う (OGP: Open Graph Protocol)",date:"2020-03-15T00:00:00Z",body:"Hugo サイトで SNS（Twitter や Facebook）用の表示設定を行う (OGP: Open Graph Protocol) Web ページに OGP (Open Graph Protocol) に基づいたメタ情報を記述しておくと、SNS アプリで URL をシェアしたときに表示される内容をカスタマイズできます。 図: OGP 設定によるリンク表示の例 Open Graph のメタ情報として、どのような HTML タグを記述すればよいかは、下記のサイトを参考にしてください。 参考: Facebook や Twitter でシェアするときに画像や説明文が表示されるようにする (OGP: Open Graph Protocol) Open Graph タグを出力するためのパーシャルテンプレート ここでは、Hugo のパーシャルテンプレートで Open Graph タグを出力するようにしてみます。 layouts/partials/head/ogp.html \u0026lt;meta property=\u0026#34;og:site_name\u0026#34; content=\u0026#34;{{ .Site.Title }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;{{ .Title }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;website\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;{{ .Permalink }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:locale\u0026#34; content=\u0026#34;ja_JP\u0026#34; /\u0026gt; {{- if .Params.image }} {{- $imageRes := .Resources.GetMatch .Params.image -}} \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $imageRes.Permalink }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:width\u0026#34; content=\u0026#34;{{ $imageRes.Width }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:height\u0026#34; content=\u0026#34;{{ $imageRes.Height }}\u0026#34; /\u0026gt; {{- else if .Site.Params.image }} {{- $imageRes := resources.Get .Site.Params.image -}} \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $imageRes.Permalink }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:width\u0026#34; content=\u0026#34;{{ $imageRes.Width }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:height\u0026#34; content=\u0026#34;{{ $imageRes.Height }}\u0026#34; /\u0026gt; {{- end }} {{- if .Description }} \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;{{ .Description }}\u0026#34; /\u0026gt; {{- else if .Summary }} \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;{{ .Summary }}\u0026#34; /\u0026gt; {{- else if .Site.Params.description }} \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;{{ .Site.Params.description }}\u0026#34; /\u0026gt; {{- end }} {{- with .Site.Params.facebookAppId }} \u0026lt;meta property=\u0026#34;fb:app_id\u0026#34; content=\u0026#34;{{ . }}\u0026#34; /\u0026gt; {{- end }} 画像 (og:image) や説明文 (og:description) などの内容は、いくつかフォールバックの仕組みを入れて、次のように出力するようにしています。 og:image ページバンドルとして画像ファイルを含んでいる場合、フロントマターの image プロパティでそのファイル名を指定することで、Open Graph の画像として表示できるようにしています。 例えば、content/aaa/bbb/index.md というページにバンドルする画像ファイルは、content/aaa/bbb/sample.png のように同じディレクトリ内に配置します。 フロントマターでのページ画像の指定 --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2020-03-15\u0026#34; image: \u0026#34;sample.png\u0026#34; --- フロントマターで image プロパティが指定されていない場合は、サイトの設定ファイル (config.toml) の独自プロパティ params.image で指定した画像ファイルをサイトロゴ画像として使用します。 サイトロゴ画像は、Hugo プロジェクトのディレクトリ内に、assets/img/site-log-large.png のようなパスで配置しておきます（Hugo の Image processing 機能を使って画像サイズを取得するため、static ディレクトリではなく assets ディレクトリに配置しなければいけないことに注意してください）。 hugo.toml でのサイトロゴの指定（抜粋） [params] image = \u0026#34;img/site-logo.png\u0026#34; og:description ページの説明文を表す og:description には、下記のような優先度で見つかったものを設定します。 フロントマターの description プロパティに記述されたテキスト ページ本文があれば、.Page.Summary で求められる要約テキスト（本文の先頭部分） サイトの設定ファイル config.toml の独自プロパティ params.description に記述されたテキスト これは 1 番だけにしておいた方がいいかもしれません。。。 fb:app_id Facebook の公式ドキュメントによると、Facebook のアプリ ID も指定しておく必要があるとされています。 Facebook のアプリ ID は、サイトの設定ファイル config.toml の独自プロパティ params.facebookAppId で指定できるようにしています。 [params] facebookAppId = \u0026#34;1234567890123456\u0026#34; head 要素に Open Graph メタ情報を埋め込む 上記のように作成したパーシャルテンプレートは、各ページの head 要素内に展開されるようにします。 ここでは、全てのページに適用するために、ベーステンプレート 内から読み込むようにしてみます。 layouts/_default/baseof.html（抜粋） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34;\u0026gt; \u0026lt;head prefix=\u0026#34;og: https://ogp.me/ns# fb: https://ogp.me/ns/fb#\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; {{ partial \u0026#34;head/ogp\u0026#34; . }} ... html 要素か head 要素で、メタ情報用のプレフィックス定義が必要なことに注意してください。 これで、Facebook や Twitter といった SNS アプリでサイトの URL が共有されたときに、アイキャッチ画像や説明文が表示されるようになります。 （応用）親セクションの image プロパティを採用する 細かいページをたくさん作っている場合は、各ページごとにアイキャッチ画像を用意するのは大変です。 そこで、各ページが所属するセクションや、親セクションのフロントマターに設定された image プロパティを見て og:image 情報を設定するようにしてみます。 もちろん、自分自身のページのフロントマターに image プロパティが指定されていれば、そちらを優先的に使用します。 layouts/partials/head/ogp.html（og:image 出力部分の抜粋） {{- define \u0026#34;og_image\u0026#34; }} {{- if .Params.image }} {{- $imageRes := .Resources.GetMatch .Params.image -}} \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $imageRes.Permalink }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:width\u0026#34; content=\u0026#34;{{ $imageRes.Width }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:height\u0026#34; content=\u0026#34;{{ $imageRes.Height }}\u0026#34; /\u0026gt; {{- else if .Parent }} {{- template \u0026#34;og_image\u0026#34; .Parent }} {{- else if .Site.Params.image }} {{- $imageRes := resources.Get .Site.Params.image -}} \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ $imageRes.Permalink }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:width\u0026#34; content=\u0026#34;{{ $imageRes.Width }}\u0026#34; /\u0026gt; \u0026lt;meta property=\u0026#34;og:image:height\u0026#34; content=\u0026#34;{{ $imageRes.Height }}\u0026#34; /\u0026gt; {{- end }} {{- end }} {{- template \u0026#34;og_image\u0026#34; . }} この仕組みを採用した場合、最終的にホームページ (content/_index.md) のフロントマターまで遡って image プロパティを探してくれるようになるので、サイト全体のロゴをホームページのフロントマターでも設定できるようになります（サイトの設定ファイル (config.toml) で image プロパティを設定しておく必要がなくなります）。 content/_index.md によるサイトロゴの指定 --- title: \u0026#34;まくろぐ\u0026#34; url: \u0026#34;/\u0026#34; image: \u0026#34;site-logo.png\u0026#34; --- この場合は、site-log.png ファイルはホームページにバンドルされたものを参照することになるので、次のようなパスで配置することに注意してください（assets ディレクトリには配置しません）。 content/site-logo.png"},{url:"/p/msds6iv/",title:"Git の設定値がどのファイルで設定されているか調べる (config --show-origin)",date:"2020-03-04T00:00:00Z",body:"Git の設定値がどのファイルで設定されているか調べる (config --show-origin) Git 設定のスコープには、local/global/system などがあり、ある設定値がどのスコープ（設定ファイル）で行われているか混乱することがあります。 参考: Git 設定のスコープ (local/global/system) を理解する そのような場合は、git config --list --show-origin コマンドを使うと、それぞれの設定値がどのファイルで設定されいるものなのか調べることができます。 $ git config --list --show-origin ... file:/Users/maku/.gitconfig user.name=maku77 file:/Users/maku/.gitconfig user.email=xxx@gmail.com file:/Users/maku/.gitconfig core.editor=vim file:/Users/maku/.gitconfig push.default=simple file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config core.ignorecase=true file:.git/config core.precomposeunicode=true file:.git/config remote.origin.url=https://github.com/maku77/maku77.github.io.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master この例の場合、/Users/maku/.gitconfig で始まるものが global スコープ、.git/config で始まるものが local スコープで設定されていることが分かります。 ここでは、--list オプションですべての設定値を列挙していますが、次のように個別の設定値に関して調べることもできます。 $ git config --show-origin user.name file:/Users/maku/.gitconfig user.name=maku77"},{url:"/p/y8hs5w6/",title:"Python で環境変数を参照する (os.getenv, os.environ)",date:"2020-01-29T00:00:00Z",body:"Python で環境変数を参照する (os.getenv, os.environ) 指定した環境変数を取得する Python で OS の環境変数を取得するには、os.getenv 関数を呼び出すか、os.environ 辞書オブジェクトを参照します。 例: 環境変数 PATH の値を表示 import os print(os.getenv(\u0026#34;PATH\u0026#34;)) print(os.environ[\u0026#34;PATH\u0026#34;]) 両者の違いは、存在しないキーを指定した場合に os.getenv がデフォルトで None を返すのに対し、os.environ は KeyError 例外を投げるという点です（辞書オブジェクト参照時の共通の振る舞いです）。 通常は os.getenv 関数を使った方が、例外をハンドルせずに済むのでシンプルなコードになります。 環境変数が設定されているかどうかで分岐 import os key = os.getenv(\u0026#34;ACCESS_KEY\u0026#34;) if key: print(\u0026#34;環境変数が見つかった場合の処理\u0026#34;) if not key: print(\u0026#34;環境変数が見つからない場合の処理\u0026#34;) ただし、複数の環境変数を参照する場合は、os.environ を使って一度に例外処理した方が分かりやすくなることがあります。 いずれかの環境変数が設定されていない場合に終了する try: openai.api_base = os.environ[\u0026#34;OPENAI_API_BASE\u0026#34;] openai.api_key = os.environ[\u0026#34;OPENAI_API_KEY\u0026#34;] except KeyError as e: sys.exit(f\u0026#34;Environment variable not set: {e}\u0026#34;) os.getenv 関数の第 2 パラメータ (default) では、キーが存在しな場合のデフォルト値を指定することが可能です。 環境変数が設定されていないときにデフォルト値を使う import os env = os.getenv(\u0026#34;MYAPP_ENV\u0026#34;, default=\u0026#34;development\u0026#34;) print(env) ちなみに、os.environ.get() という関数もありますが、これは os.getenv() 関数のエイリアスです。 すべての環境変数を列挙する 単一の環境変数を参照するときは os.getenv 関数が便利ですが、すべての環境変数をループ処理したい場合は os.environ オブジェクトをループ処理するとよいです。 環境変数を列挙する（キーを取り出す方法） import os for key in os.environ: val = os.environ[key] print(f\u0026#34;{key}: {val}\u0026#34;) 環境変数を列挙する（キーと値を取り出す方法） import os for key, val in os.environ.items(): print(f\u0026#34;{key}: {val}\u0026#34;) より実践的なサンプル ある環境変数が設定されていない場合にプログラムを終了する 次の config.py モジュールは、環境変数 MYAPP_USER と MYAPP_PASS の値を参照し、同じ名前の変数にセットします。 環境変数が見つからない場合は、対応方法を出力してプログラムを終了します。 config.py import os import sys def load_env_or_exit(env_name: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; 環境変数の値を取得します。 設定されていない場合はエラーメッセージを表示してプログラムを終了します。 \u0026#34;\u0026#34;\u0026#34; env_val = os.getenv(env_name) if not env_val: sys.exit(f\u0026#34;Error: {env_name} not set. Please consider adding a .env file with {env_name}.\u0026#34;) return env_val # 環境変数を参照 MYAPP_USER = load_env_or_exit(\u0026#34;MYAPP_USER\u0026#34;) MYAPP_PASS = load_env_or_exit(\u0026#34;MYAPP_PASS\u0026#34;) ☝️ ワンポイント 環境変数の値として明示的に空文字 (\u0026quot;\u0026quot;) がセットされているときにエラーにしたくない場合は、上記の if not env_val: の部分を if env_val is None: に変更します。 env_val が文字列型の場合、if not env_val: という条件指定は、if env_val is None or env_val == \u0026quot;\u0026quot;: と同じ意味になります。 さらに、.env ファイルを使って環境変数を設定できるようにしておくと、よりユーザーにとって扱いやすいプログラムになります。 上記の config.py モジュールは、別のモジュールから次のような感じ使用できます。 main.py import config print(config.MYAPP_USER) print(config.MYAPP_PASS) config.MYAPP_USER や config.MYAPP_PASS の値は、config.py をインポートしたときに自動的に初期化されるので、定数のように参照できます。 複数のモジュールから config.py をインポートする場合は、最初にインポートしたときのキャッシュが使われるので、何度も load_env_or_exit 関数が呼ばれてしまう心配はありません。 あるプログラム専用のプロキシ環境変数を用意する プロキシの設定を行う場合、一般的に http_proxy 環境変数が使用されますが、この環境変数を参照するのが適切ではないケースがあります。 例えば、http_proxy 環境変数を設定することにより、依存する別のプログラムが動作しなくなってしまうようなケースです。 このような場合は、次のようにアプリ特有の環境変数でプロキシを設定できるようにすることで対処できます。 config.py import os # 独自の MYAPP_PROXY 環境変数が設定されていたら http_proxy よりも優先的に使う PROXY = os.getenv(\u0026#34;MYAPP_PROXY\u0026#34;) or os.getenv(\u0026#34;http_proxy\u0026#34;)"},{url:"/p/mxhzgwd/",title:"Hugo で大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing)",date:"2020-01-15T00:00:00Z",body:"Hugo で大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing) Image Processing 機能とは Hugo の Image Processing 機能 を使用すると、ページにバンドル した 1 枚の画像ファイルを加工し、サムネイル画像などを自動的に生成することができます。 例えば、デジカメで撮影した写真をウェブサイト上に掲載する場合、直接画像を貼り付けるとサイズが大きいため、小さなサムネイル画像からのリンクを用意することが多いと思います。 このような場合に、Image Processing 機能を使用すれば、サムネイル画像を手動で作成する手間をなくすことができます。 Image Processing の使用例 ここでは、下記のように、books セクションページ内に sample.png というリソースが含まれているとします。 content/ books/ _index.md sample.png Image Processing の機能を使って画像の変換を行うには、Page Resources のオブジェクト を取得する必要があります（Page 変数ではないので注意）。 このオブジェクトは、Page 変数 の次のようなプロパティ、およびメソッドを使って取得することができます。 .Resources（バンドルされたすべてのリソースを参照する） .Resources.ByType（指定した種類のリソースだけ取り出す） 例: $resources := .Resources.ByType \u0026quot;image\u0026quot; .Resources.Match（ファイル名のパターンに一致するリソースだけ取り出す） 例: $resources := .Resources.Match \u0026quot;sample.png\u0026quot; 例: $resources := .Resources.Match \u0026quot;**.png\u0026quot; 例: $resources := .Resources.Match \u0026quot;images/**.png\u0026quot; これらのメソッドは Markdown ファイル内から直接呼び出すことはできないので、実際にはショートコードやテンプレートファイルから利用することになります。 例えば、次のようなショートコードを作成しておけば、元の画像ファイルがどのようなサイズであっても、強制的に 150x150 のサイズのサムネイル画像を生成して表示してくれます。 layouts/shortcodes/thumbnail.html {{- $src := .Get \u0026#34;src\u0026#34; }} {{- $imageRes := .Page.Resources.GetMatch $src }} {{- $imageRes := $imageRes.Fill \u0026#34;150x150\u0026#34; }} {{- $imageUrl := $imageRes.RelPermalink }} \u0026lt;img src=\u0026#34;{{ $imageUrl }}\u0026#34; alt=\u0026#34;{{ $src }}\u0026#34; /\u0026gt; ショートコードから .Resources オブジェクトを参照するときは、上記のように .Page.Resources としなければいけないことに注意してください。 この thumbnail ショートコードは、Markdown ファイル内からは次のように利用します。 content/books/_index.md --- title: \u0026#34;タイトル\u0026#34; date: \u0026#34;2020-01-15\u0026#34; --- {{\u0026lt; thumbnail src=\u0026#34;sample.png\u0026#34; \u0026gt;}} ここでは、Fill メソッドで生成する画像ファイルのサイズを 150x150 で固定していますが、ショートコードのパラメータで指定できるようにしてもよいでしょう。 ちなみに自動生成されるサムネイル画像の URL は次のような感じのランダムな文字列になるようです。 /books/sample_d74hu175c61ccf69bf5f1995b2e27ba4cd_111429_150x150_fill_q75_box_smart1.png Image Processing 用の関数は、Fill メソッド以外にも色々あるので、ざっと目を通しておくとよいでしょう。 下記に、Resize、Fit、Fill メソッドの使用例を示しておきます。 幅x高さを 200x150 にする（アスペクト比は考慮されないので、歪んだ画像になるかもしれない） $img = $resource.Resize \u0026quot;200x150\u0026quot; アスペクト比を保って幅が 200px になるよう拡大縮小する $img = $resource.Resize \u0026quot;200x\u0026quot; アスペクト比を保って高さが 150px になるよう拡大縮小する $img = $resource.Resize \u0026quot;x150\u0026quot; アスペクト比を保って幅x高さが大きくても 200x150 に収まるようにする（最終的な画像サイズはどちらか一辺が指定したサイズより小さくなるかもしれない） $img = $resource.Fit \u0026quot;200x150\u0026quot; アスペクト比を保って幅x高さがちょうど 200x150 になるようにする（アスペクト比が変わる場合、画像の中央当たりだけが見えるような画像になる） $img = $resource.Fill \u0026quot;200x150\u0026quot; 他にも、背景色を指定したり、回転させたり、JPEG のクオリティを調整したりと、色々なオプションが用意されています。 Facebook などで Web ページをシェアする場合は、画像ファイルの中央部分しか表示されなかったりしますね（OGP という仕組みが使われる）。 この振舞いは、上記の Fill メソッドの動きに似ているので、サムネイル用のショートコードを作成するときは、Fill メソッドを使用するのがよいかもしれません。 サムネイル画像をクリックしたときに元の画像ファイルを表示する おまけのショートコードサンプルです。 この image ショートコードを使用して画像を表示すると、指定したサイズに縮小した画像を表示しつつ、画像をクリックすることで元の大きいサイズの画像を表示することができます。 layouts/shortcodes/image.html {{- $src := .Get \u0026#34;src\u0026#34; }} {{- $title := .Get \u0026#34;title\u0026#34; }} {{- $width := .Get \u0026#34;w\u0026#34; }} {{- $size := printf \u0026#34;%sx\u0026#34; $width }} {{- $res := .Page.Resources.GetMatch $src }} {{- $image := $res.Resize $size }} {{- $imageUrl := $image.RelPermalink }} \u0026lt;figure\u0026gt; \u0026lt;a href=\u0026#34;{{ $src }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $imageUrl }}\u0026#34; alt=\u0026#34;{{ $src }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{- with $title }} \u0026lt;figcaption\u0026gt;図: {{ . }}\u0026lt;/figcaption\u0026gt; {{- end }} \u0026lt;/figure\u0026gt; Markdown ファイルの中からは次のように呼び出します。 content/books/_index.md {{\u0026lt; image w=\u0026#34;200\u0026#34; src=\u0026#34;sample.jpg\u0026#34; title=\u0026#34;タイトル\u0026#34; \u0026gt;}} 上記のショートコードでは、figure タグと figcaption を使って、画像のタイトルも表示できるようにしています。 ショートコードのパラメータで title=\u0026quot;タイトル\u0026quot; のように指定すると、画像の下にタイトルが表示されます。 また、アスペクト比を保ったまま画像を縮小表示することを想定しているため、サイズ指定は横幅だけを指定できるようにしています（ショートコードのパラメータで w=\u0026quot;200\u0026quot; のように単位なしで指定します）。 応用1: w パラメータをオプショナルにしたバージョン 下記はもう少し改良したバージョンの image ショートコードで、w パラメータが省略された場合に、src で指定した画像ファイルをそのまま使用するようにしています。 layouts/shortcodes/image.html {{- $src := .Get \u0026#34;src\u0026#34; }} {{- $title := .Get \u0026#34;title\u0026#34; }} {{- $width := .Get \u0026#34;w\u0026#34; }} {{- $imageUrl := $src }} {{- $res := .Page.Resources.GetMatch $src }} {{- /* ページまたぎでリンク切れを防ぐおまじない */}} {{- if $res }} {{- $src = $res.RelPermalink }} {{- $imageUrl = $res.RelPermalink }} {{- end }} {{- if $width }} {{- $size := printf \u0026#34;%sx\u0026#34; $width }} {{- $image := $res.Resize $size }} {{- $imageUrl = $image.RelPermalink }} {{- end }} \u0026lt;figure\u0026gt; \u0026lt;a href=\u0026#34;{{ $src }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{ $imageUrl }}\u0026#34; alt=\u0026#34;{{ $src }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{- with $title }} \u0026lt;figcaption\u0026gt;図: {{ . }}\u0026lt;/figcaption\u0026gt; {{- end }} \u0026lt;/figure\u0026gt; 応用2: SVG ファイルに対応する SVG ファイルは Image Processing 機能に対応していないので、同じコードで width 調整しようとすると、次のようなエラーになってしまいます。 error calling Resize: *resources.genericResource is not an image 下記の image ショートコードは、src パラメータで指定されたファイルの拡張子が svg だった場合に、Image Processing 機能を使わず、style 属性を使って横幅を指定するようにしています。 {{- $src := .Get \u0026#34;src\u0026#34; }} {{- $title := .Get \u0026#34;title\u0026#34; }} {{- $width := .Get \u0026#34;w\u0026#34; }} {{- $imageUrl := $src }} {{- $res := .Page.Resources.GetMatch $src }} {{- /* ページまたぎでリンク切れを防ぐおまじない */}} {{- if $res }} {{- $src = $res.RelPermalink }} {{- $imageUrl = $res.RelPermalink }} {{- end }} {{- $isSvg := strings.HasSuffix $src \u0026#34;svg\u0026#34; }} {{- if and $width (not $isSvg) }} {{- $size := printf \u0026#34;%sx\u0026#34; $width }} {{- $image := $res.Resize $size }} {{- $imageUrl = $image.RelPermalink }} {{- end }} \u0026lt;figure\u0026gt; \u0026lt;a href=\u0026#34;{{ $src }}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;img {{ if $isSvg }}style=\u0026#34;width:{{ $width }}px;\u0026#34;{{ end }} src=\u0026#34;{{ $imageUrl }}\u0026#34; alt=\u0026#34;{{ $src }}\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; {{- with $title }} \u0026lt;figcaption\u0026gt;図: {{ . }}\u0026lt;/figcaption\u0026gt; {{- end }} \u0026lt;/figure\u0026gt;"},{url:"/p/mju5eox/",title:"Hugo で Markdown ファイルに記述した HTML コードが削除されてしまう場合",date:"2019-12-26T00:00:00Z",body:"Hugo で Markdown ファイルに記述した HTML コードが削除されてしまう場合 Goldmark 化による弊害 Hugo v0.60.0 から Markdown パーサーとして Goldmark が採用され、Markdown の解釈が微妙に変わっています。 Now CommonMark Compliant! - Hugo 例えば、今までは .md ファイル内に記述した HTML コードはそのまま出力されていたのに、デフォルトで取り除かれるようになっています。 これまでに作成した記事で HTML タグを使用している場合はちょっと困ってしまいます。 Markdown ファイル内に HTML コードを記述できるようにする .md ファイルに記述した HTML コードを、これまで通り出力できるようにするには、Hugo の設定ファイルで次のように指定します。 hugo.toml（TOML フォーマットの場合） [markup.goldmark.renderer] unsafe = true hugo.yaml（YAML フォーマットの場合） markup: goldmark: renderer: unsafe: true もちろん、使用する Markdown パーサー自体を旧来の BlackFriday に設定するという方法もあります。 [markup] defaultMarkdownHandler = \u0026#34;blackfriday\u0026#34; ただ、Goldmark の方が高速に動作するようなので、前向きに Goldmark に乗り換えることを考えた方がよいでしょう。"},{url:"/p/ynv4ago/",title:"Hugo でドラフト指定したセクションが公開されてしまう場合",date:"2019-12-26T00:00:00Z",body:"Hugo でドラフト指定したセクションが公開されてしまう場合 Hugo のトラブルシューティングです（v0.62.0 で確認）。 ドラフトセクションが公開されてしまう問題 Hugo では、記事ページのフロントマターに、 draft: true という感じでドラフト指定を行なっておくと、hugo コマンドでページ生成するときに -D オプションを付けない限り、そのページは出力されなくなります。 しかし、セクションページに関しては、上記のように指定していても、必ず出力されてしまいます（v0.57 くらいからこんな振る舞いになってしまったような・・・）。 例えば、下記のようにトップレベルのセクションを一覧表示しようとすると、ドラフトのセクションまで出力されてしまいます。 \u0026lt;ul\u0026gt; {{ range .Site.Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; このあたりの振る舞いは下記で議論されていて、 Improve _index.md vs draft · Issue #6312 · gohugoio/hugo · GitHub 作者の bep 氏 (Bjørn Erik Pedersen) によると、下記の回答がすべてを表しているようです。 The original purpose of draft did not include section pages \u0026ndash; as that was not a thing back then. （当初はドラフト機能はセクションページを対象にすることを考えていなかった） セクションをドラフトとしてマークできるようにした場合、その下にぶらさがるページはどう振舞うべきなんだ（一時的にそのセクション自体が存在しないものとしてセクション外に出すの？）とか、仕様が複雑になってしまうのであまり振る舞いを変えたくないという事情があるみたいです。 とは言っても、セクション全体をドラフトとして扱うという機能は需要があるはずです。 bep 氏もドラフトセクションの機能は検討すると言っているようなので、将来のバージョンに期待したいと思います。 ドラフトセクションを表示しない対策 ドラフト設定したセクションの出力を抑制する機能は今のところありませんが（2019年時点 v0.62.0）、少なくともセクションを列挙する際に自力でドラフトセクションを無視するようにすることは可能です。 次のサンプルでは、where 関数を使って、.Site.Sections に含まれるセクションの一覧から、.Draft プロパティが false であるものだけを抽出しています。 結果として、ドラフトではないセクションだけを列挙できます。 {{ range where .Site.Sections \u0026#34;.Draft\u0026#34; false }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} 次のように、各ページ（セクション）の .Draft 変数の値によって分岐させる方法もありますが、上記のように where 関数を使って最初にフィルタリングしてしまった方がネストが深くならなくてシンプルです。 {{ range .Site.Sections }} {{ if not .Draft }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} {{ end }} もちろん、上記のようにリンクを出力しないように制御しても、ドラフトセクションのページ自体（HTML ファイル）は生成されてしまうことに注意してください。 生成されているドラフトセクションを見落とさないようにするためには、Hugo をサーバーモードで起動したときに、ドラフトセクションのリンクも含めて出力するようにしておくとよいでしょう。 Hugo がサーバーモードで動作しているかどうかは、.Site.IsServer で確認できます。 {{/* サーバーモードではドラフトセクションも含めて表示 */}} {{ $sections := .Site.Sections }} {{ $filtered := cond .Site.IsServer $sections (where $sections \u0026#34;.Draft\u0026#34; false) }} {{ range $filtered }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} ここで使用している cond 関数は、C 言語の三項演算子のようなもので、最初のパラメータで指定した .Site.IsServer の値が true であれば 2 番目のパラメータの値を、false の場合は 3 番目のパラメータの値を返します。 よって、サーバーモード時は $filtered にドラフトを含むセクション一覧が格納され、リリース時はドラフトを除いたセクション一覧が格納されます。"},{url:"/p/58ctg7k/",title:"Python で 2 つのリストに重複する要素を抽出する (set と \u0026)",date:"2019-11-25T00:00:00Z",body:"Python で 2 つのリストに重複する要素を抽出する (set と \u0026) Python では 2 つの set インスタンス同士で \u0026amp; 演算を行うと、両方のセットに含まれる要素を抽出することができます（積集合）。 s1 = {1, 2, 3, 4} s2 = {3, 4, 5, 6} print(s1 \u0026amp; s2) #=\u0026gt; {3, 4} 参考: set オブジェクトで集合演算を行う リストやタプルにはこのような演算子は実装されていないため、リストやタプル同士でこういった演算を行うには、一度 set オブジェクトに変換する必要があります。 l1 = [1, 2, 3, 4] l2 = [3, 4, 5, 6] s1 = set(l1) s2 = set(l2) print(s1 \u0026amp; s2) #=\u0026gt; {3, 4} 重複要素があるかのチェックだけを行いたい場合は、\u0026amp; 演算の結果求められたセットを条件式として評価すれば OK です（Python では空のセットを偽、それ以外のセットを真として扱います）。 if s1 \u0026amp; s2: print(\u0026#34;重複要素があります\u0026#34;)"},{url:"/p/n4o7o6m/",title:"Hugo でGoogle カスタム検索を設置して記事を検索できるようにする",date:"2019-11-10T00:00:00Z",body:"Hugo でGoogle カスタム検索を設置して記事を検索できるようにする Google カスタム検索エンジンによる検索フォームを Hugo のサイトに設置することで、簡単にサイト内の記事を検索することができるようになります。 Google カスタム検索エンジンに自分のサイトを登録する まず、Google カスタム検索エンジンを適用する Web サイトは、インターネット上に公開されている必要があります。 プライベートな Hugo サーバーを使用する場合に検索機能を付けたい場合は、自己完結する全文検索の仕組み を導入する必要があります。 ここでは、すでにインターネット上に公開されている Web サーバーがあるという前提で話を進めます。 カスタム検索エンジンの登録は下記のサイトから行えます。 Google カスタム検索エンジン 追加 ボタンを押して、自分の Web サイトのアドレスを入力するだけで登録は完了します。 検索ページを表示する Web サイトをカスタム検索エンジンに登録すると、Google のサーバ上に、カスタム検索用のページが作成されます。 カスタム検索のコントロールパネル から、登録した検索エンジンを選択し、公開 URL の欄を確認してみてください。 下記のようなアドレスが生成されているはずです（下記アドレスの cx パラメータ部分は適当です）。 https://cse.google.com/cse?cx=207539779230035260336:1pkduco3un7 あとは、Markdown ファイルの中から、次のようにリンクを張ってやれば、即席のカスタム検索サイトの完成です。 [サイト内検索](https://cse.google.com/cse?cx=207539779230035260336:1pkduco3un7) 図: 表示例 Hugo のページ内に検索フォームと検索結果を表示する 上記のやり方では、Google のサーバ上に生成された検索ページへただジャンプするだけでした。 ここでは、Hugo の記事ページ内に検索フォームと、検索結果を表示できるようにしてみます。 まず、カスタム検索のサイトから、ページ埋め込み用の HTML コードを取得します。 図: カスタム検索用の HTML コードを生成 カスタム検索のコントロールパネル から、登録した検索エンジンを選択する デザイン のタブから、全幅 のデザインを選択する 保存してコードを取得する ボタンを押す 上記のようにポチポチ入力していくと、下記のようなコードが取得できるはずです（バージョンにより変更される可能性があります）。 \u0026lt;script async src=\u0026#34;https://cse.google.com/cse.js?cx=207539779230035260336:1pkduco3un7\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;gcse-search\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 後は、このコードを、任意の記事ページの Markdown ファイル内にコピペするだけです。 content/custom-search/_index.md --- title: \u0026#34;サイト内検索\u0026#34; --- \u0026lt;script async src=\u0026#34;https://cse.google.com/cse.js?cx=207539779230035260336:1pkduco3un7\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;gcse-search\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 下記は、実際に Hugo を使ったサイト内のページにカスタム検索を埋め込んだときの表示例です。 図: Hugo サイトへのカスタム検索の埋め込み 検索フォームに余計な枠線が表示されていたり、微妙にレイアウトが崩れてしまっているのが分かります。 これは、その Web サイトのスタイル設定が Google の検索フォームにも影響してしまっているからです。 このようなレイアウトの崩れを防ぐ一番手っ取り早い方法は、先に示した、Google のサーバ上に生成された検索ページに飛ばしてしまう方法です。 検索フォームだけ独自コードで設置する 最初の例で示したように、Google のサーバー上に生成される検索ページのアドレスは次のようになっています。 https://cse.google.com/cse?cx=＜検索エンジンID＞ 実は、このアドレスの後ろに、次のように検索ワードを追加して開くと、検索結果を表示した状態で検索ページを開くことができます。 https://cse.google.com/cse?cx=＜検索エンジンID＞\u0026amp;q=＜検索ワード＞ つまり、このようなアドレスを開くための FORM 要素を設定してやることで、直接カスタム検索の結果にジャンプできる検索フォームを作成できます。 下記は、form 要素の記述例です（cx パラメータの値は、あなたの Web サイト用の検索エンジン ID に変更してください）。 \u0026lt;form action=\u0026#34;https://cse.google.com/cse\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;searchBox\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;cx\u0026#34; value=\u0026#34;207539779230035260336:1pkduco3un7\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;ie\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;search\u0026#34; name=\u0026#34;q\u0026#34; placeholder=\u0026#34;サイト内検索\u0026#34; size=\u0026#34;30\u0026#34; autocomplete=\u0026#34;off\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;検索\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; ここでは、div 要素に searchBox というクラスを割り当てているので、このクラスに対する CSS スタイルを設定してやれば、見た目のカスタマイズは自由に行えます。 .searchBox \u0026gt; input { font-size: 16px; vertical-align: middle; border-radius: 3px; } .searchBox \u0026gt; input[type=\u0026#34;search\u0026#34;] { border: solid 1px #ccc; padding: 0.5em; } .searchBox \u0026gt; input[type=\u0026#34;submit\u0026#34;] { background: #ff3c5f; color: white; font-weight: bold; border: none; margin-left: 0.3em; padding: 0.5em 1em; } 図: 表示結果 パーシャルテンプレート化する こういった検索フォームは、すべてのページに設置することが多いでしょうから、Hugo では下記のような感じで、レイアウトファイルからパーシャルテンプレートとして呼び出せるようにしておくと便利です。 layouts/_default/single.html（抜粋） {{ partial \u0026#34;custom-search\u0026#34; . }} 下記は custom-search パーシャルテンプレートの記述例です。 ここでは、Hugo の設定ファイルで CustomSearchId という独自パラメータが設定されている場合のみ、カスタム検索のフォームを表示するようにしています（最初の with による分岐）。 layouts/partials/custom-search.html {{- with .Site.Params.CustomSearchId }} \u0026lt;form action=\u0026#34;https://cse.google.com/cse\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;searchBox\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;cx\u0026#34; value=\u0026#34;{{ . }}\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;ie\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;search\u0026#34; name=\u0026#34;q\u0026#34; placeholder=\u0026#34;サイト内検索\u0026#34; size=\u0026#34;30\u0026#34; autocomplete=\u0026#34;off\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;検索\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; {{- end }} 設定ファイルには下記のように検索エンジン ID を設定しておきます。 hugo.toml [params] CustomSearchId = \u0026#34;207539779230035260336:1pkduco3un7\u0026#34; 参考 Hugo に全文検索（インクリメンタルサーチ）の機能を付ける"},{url:"/p/bes7iu7/",title:"Python で Markdown ファイルのフロントマターの記述が正しいかチェックする",date:"2019-10-22T00:00:00Z",body:`Python で Markdown ファイルのフロントマターの記述が正しいかチェックする 下記の Python スクリプト (check-front-matter.py) は、Markdown ファイルに記載された YAML フロントマターの内容が正しいかどうかを調べるサンプルスクリプトです。 確認内容は、validate() 関数の中に記載されていますので、用途に応じてこの内容を書き換えてください。 下記のサンプルコードでは、フロントマターに title と date が記載されているかをチェックしています。 使い方 PyYAML というライブラリを使用しているので、下記のようにインストールしておく必要があります。 PyYAML のインストール $ pip install pyyaml 次のように実行すると、カレントディレクトリ以下の全ての Markdown ファイル (.md) の内容を検証できます。 $ python check-front-matter.py content/title3.md: Missing title or date content/title4.md: Missing title or date content/title5.md: Missing title or date この例では、3 つの Markdown ファイルのフロントマターが正しく記述されていないことが検出されています。 サンプルスクリプト check-front-matter.py #!/usr/bin/env python3 import yaml class YamlFrontMatter: \u0026#34;\u0026#34;\u0026#34;YAML ファイルからフロントマターを取得するクラスです。\u0026#34;\u0026#34;\u0026#34; def __init__(self, filename): self.filename = filename def load_frontmatter(self): \u0026#34;\u0026#34;\u0026#34; Markdown ファイルのフロントマターを読みこんで、 Python のオブジェクトとして返します。 \u0026#34;\u0026#34;\u0026#34; with open(self.filename, encoding=\u0026#39;utf-8\u0026#39;) as file: text = self.__load_front_matter_text(file) return yaml.safe_load(text) def __load_front_matter_text(self, file): \u0026#34;\u0026#34;\u0026#34; ファイルオブジェクトからフロントマター部分のテキストを抽出します。 セパレータの \u0026#34;---\u0026#34; は含みません。 \u0026#34;\u0026#34;\u0026#34; line = file.readline().rstrip(\u0026#39;\\r\\n\u0026#39;) if line != \u0026#39;---\u0026#39;: raise Exception(file.name + \u0026#39;: Front matter must begin with \u0026#34;---\u0026#34;\u0026#39;) result = [] for line in file: line = line.rstrip(\u0026#39;\\r\\n\u0026#39;) if line == \u0026#39;---\u0026#39;: return \u0026#39;\\n\u0026#39;.join(result) result.append(line) raise Exception(file.name + \u0026#39;: Front matter must end with \u0026#34;---\u0026#34;\u0026#39;) # カレントディレクトリ以下のすべての Markdown ファイルの # フロントマターの記述が正しいかチェックします。 if __name__ == \u0026#39;__main__\u0026#39;: import glob import sys def validate(filename, fm): \u0026#34;\u0026#34;\u0026#34; フロントマターの内容 (fm) が正しいかチェックします。 ここの実装は自由に変更してください。 \u0026#34;\u0026#34;\u0026#34; if (\u0026#39;title\u0026#39; in fm) and (\u0026#39;date\u0026#39; in fm): # print(filename + \u0026#39;: OK\u0026#39;) pass else: print(filename + \u0026#39;: Missing title or date\u0026#39;) for filename in glob.iglob(\u0026#39;**/*.md\u0026#39;, recursive=True): try: fm = YamlFrontMatter(filename).load_frontmatter() validate(filename, fm) except Exception as e: print(e, file=sys.stderr) sys.exit(1)`},{url:"/p/euevcsa/",title:"Python で ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive)",date:"2019-10-22T00:00:00Z",body:"Python で ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive) Python の標準ライブラリである shutil を使用すると、複数のファイルを含むディレクトリから ZIP アーカイブを簡単に作成することができます（1 ファイル単位でアーカイブに追加するファイルを細かく制御したいときは、zipfile モジュールを使用します）。 ディレクトリを ZIP 圧縮する ZIP ファイルの作成 shutil.make_archive 関数 を使用すると、指定したディレクトリ内のファイルを丸ごと ZIP 圧縮できます。 次の例では、src ディレクトリ内のファイルを backup.zip ファイルに圧縮しています。 zip.py（src ディレクトリから backup.zip を作成） import shutil import sys try: shutil.make_archive(\u0026#39;backup\u0026#39;, format=\u0026#39;zip\u0026#39;, root_dir=\u0026#39;src\u0026#39;) except Exception as e: print(e, file=sys.stderr) ZIP ファイルの上書き確認をする shutil.make_archive 関数は、すでに ZIP ファイルがある場合には、問答無用で上書き保存してしまうようです。 下記の create_zip 関数は、同名の ZIP ファイルが存在している場合に確認プロンプトを表示するようにしています。 上書き確認付きの ZIP アーカイブ化関数 import shutil import sys import os def create_zip(zip_filename, src_dir): \u0026#34;\u0026#34;\u0026#34; src_dir ディレクトリ内のファイル群を、 zip_filename で指定した名前の ZIP ファイルにアーカイブします。 すでに同名の ZIP ファイルが存在する場合は、確認プロンプトを表示します。 \u0026#34;\u0026#34;\u0026#34; # 上書き確認 if os.path.exists(zip_filename): answer = input(zip_filename + \u0026#39; already exists. Overwrite? (y/n): \u0026#39;) if (answer != \u0026#39;y\u0026#39; and answer != \u0026#39;Y\u0026#39;): return # ZIP アーカイブの作成 try: name = os.path.splitext(zip_filename)[0] shutil.make_archive(name, format=\u0026#39;zip\u0026#39;, root_dir=src_dir) except Exception as e: print(e, file=sys.stderr) if __name__ == \u0026#39;__main__\u0026#39;: create_zip(\u0026#39;backup.zip\u0026#39;, \u0026#39;src\u0026#39;) ZIP ファイルを展開する shutil.unpack_archive 関数 を使用すると、指定した ZIP ファイルの中身を、指定したディレクトリに展開することができます。 下記の例では、backup.zip アーカイブ内のファイル群を dst ディレクトリ以下に展開しています。 dst ディレクトリが存在しない場合は、自動的に生成されます。 unzip.py import shutil import sys try: shutil.unpack_archive(\u0026#39;backup.zip\u0026#39;, extract_dir=\u0026#39;dst\u0026#39;) except Exception as e: print(e, file=sys.stderr)"},{url:"/p/u9r9p7n/",title:"Hugo でサイト構造を変えてもページの URL が変わらないようにする (Permalink)",date:"2019-10-20T00:00:00Z",body:`Hugo でサイト構造を変えてもページの URL が変わらないようにする (Permalink) 各ページの URL は変わってはいけない Hugo によって出力される HTML ファイルのパスは、デフォルトでは content ディレクトリ以下のセクション構成（ディレクトリ構成）やファイル名によって決定されます。 サイトの規模が小さいうちはこれでもよいのですが、Markdown ファイル数が増えてくると、ディレクトリ構造を変えたり、ファイル名を整理したくなってきます。 それによってページの URL がころころ変わってしまうと、せっかくリンクを張ってくれたサイトがあっても、すべてリンク切れになってしまいます。 このようなリンク切れを起こさないようにするのが パーマリンク (permalink) という考え方で、各ページに不変の ID を割り当てて URL が変わらないようにします。 例えば、Amazon の各商品のページは 10 桁の ISBN-10 という ID でアクセスできるようになっています。 https://www.amazon.co.jp/dp/4592146980/ Hugo でも、各ページにこのような ID ベースの URL を割り当てることができます。 不変の URL を割り当てた例 https://\u0026lt;your-hugo-site\u0026gt;/p/abc1234/ Hugo で出力するページに固定の URL を割り当てる Markdown ファイルのフロントマターに url プロパティを設定すると、そのページの URL を固定することができます。 --- title: \u0026#34;ページタイトル\u0026#34; url: \u0026#34;p/abc1234/\u0026#34; date: \u0026#34;2019-10-20\u0026#34; --- 例えば、上記のようなフロントマターを記述しておくと、そのページには必ず https://ドメイン名/p/abc1234/ というアドレスでアクセスできるようになります。 一階層目のパスは別の用途で使用する可能性があるため、ここでは p という階層を掘って、permalink 化した記事を格納するようにしています（Amazon の dp と同様です）。 このようにすることで、Markdown ファイルのファイル名や記事タイトル、ディレクトリ構成を変えても、最終的な URL を変化させずに済みます。 Hugo 搭載の permalink 機能は使わない Hugo には他にも、設定ファイルで permalink に関する設定を行う仕組みが用意されていますが、こちらは日付や記事タイトルに基づいて URL が決まるものであり、URL を固定する用途にはあまり向いていません。 また、フロントマターで aliases プロパティを指定することもできますが、こちらはリダイレクト用の HTML ファイルを追加出力するものであり、最終ターゲットとなるページの URL を制御することはできません。 このような理由により、ページのリンク切れの心配をなくすには、url プロパティで変化しない ID を割り当てる ことをお勧めします。 多言語対応ページでは url の先頭にスラッシュを付けない Hugo は 1 つのページを 多言語化してホスティング する機能を持っており、例えば、フランス語に翻訳したページの URL は、/fr/p/xxxxxxx/ のように、先頭に /fr という言語プレフィックスが付いたものになります。 各言語用の .md ファイルは次のようなファイル名で作成するのですが、 hello.md（デフォルト言語のページ） hello.en.md（英語のページ） hello.fr.md（フランス語のページ） このとき、フロントマターの url プロパティには en や fr やなどの言語プレフィックスを付ける必要はありません。 url: \u0026#34;p/abc1234/\u0026#34; ← 全ページ共通でこの指定で OK 多言語対応ページをビルドしたときに、自動的に言語プレフィックスを考慮したパスに HTML ファイルを出力してくれます（Hugo 0.55 以降）。 /p/abc1234/index.html /en/p/abc1234/index.html /fr/p/abc1234/index.html ただし、フロントマターの url プロパティの値をスラッシュ (/) で始めると、こういった言語プレフィックスの考慮はなくなり、指定したままのパスで HTML 出力されることになるので注意してください。 url: \u0026#34;/p/abc1234/\u0026#34; ← スラッシュで始めるように変えた 上記のように記述すると、必ず次のようなパスで HTML 出力されることになります。 /p/abc1234/index.html 通常は、url の値はスラッシュで始めないようにする のがよさそうです。 ランダム ID の生成方法 本記事の例では、ページの URL に 7 桁の ID を割り当てていますが、この ID は下記のサイトでランダム文字列として生成することができます。 ランダムID生成 - まくろぐ 毎回手動で ID を生成するのが面倒であれば、エディタのマクロなどで自動的に Markdown ファイルのフロントマターを挿入できるようにしておくと便利です。 下記にフロントマターの自動挿入方法をいくつか紹介します。 （応用）Archetypes でフロントマターを自動挿入 Hugo プロジェクトのルートに、archetypes/default.md というファイルを作成しておくと、hugo new コマンドで記事ページを生成したときに、その内容が雛形として使用されます（Hugo の Archetypes という機能です）。 次のサンプルでは、自動でフロントマターにランダムな url プロパティを挿入するようにしています。 archetypes/default.md --- title: \u0026#34;\u0026#34; url: \u0026#34;p/{{ template \u0026#34;permanentId\u0026#34; }}/\u0026#34; date: \u0026#34;{{ now.Format \u0026#34;2006-01-02\u0026#34; }}\u0026#34; tags: [\u0026#34;\u0026#34;] --- {{ define \u0026#34;permanentId\u0026#34; -}} {{- $scratch := newScratch -}} {{- range (seq 7) -}} {{- $nextCh := slice \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; \u0026#34;5\u0026#34; \u0026#34;6\u0026#34; \u0026#34;7\u0026#34; \u0026#34;8\u0026#34; \u0026#34;9\u0026#34; \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34; \u0026#34;d\u0026#34; \u0026#34;e\u0026#34; \u0026#34;f\u0026#34; \u0026#34;g\u0026#34; \u0026#34;h\u0026#34; \u0026#34;i\u0026#34; \u0026#34;j\u0026#34; \u0026#34;k\u0026#34; \u0026#34;m\u0026#34; \u0026#34;n\u0026#34; \u0026#34;o\u0026#34; \u0026#34;p\u0026#34; \u0026#34;q\u0026#34; \u0026#34;r\u0026#34; \u0026#34;s\u0026#34; \u0026#34;t\u0026#34; \u0026#34;u\u0026#34; \u0026#34;v\u0026#34; \u0026#34;w\u0026#34; \u0026#34;x\u0026#34; \u0026#34;y\u0026#34; \u0026#34;z\u0026#34; | shuffle | first 1 -}} {{- $scratch.Add \u0026#34;id\u0026#34; $nextCh -}} {{- end -}} {{- delimit ($scratch.Get \u0026#34;id\u0026#34;) \u0026#34;\u0026#34; -}} {{- end -}} ここでは、permanentId という内部テンプレートを定義して、xpya1z3 という感じのランダム文字列を生成しています（もうちょっと綺麗に生成する方法があればいいんですが）。 Hugo プロジェクトのルートで次のようにコマンドを実行すれば、新しい記事ファイルが生成され、その先頭にフロントマターが挿入されます。 $ hugo new sample.md 例えば、次のような感じのファイルが生成されます（デフォルトで content ディレクトリ以下に生成されます）。 content/sample.md --- title: \u0026#34;\u0026#34; url: \u0026#34;p/es3qakw/\u0026#34; date: \u0026#34;2020-03-16\u0026#34; tags: [\u0026#34;\u0026#34;] --- （応用）Vim エディタでフロントマターを自動挿入 Vim などのエディタを使っている人は、エディタのマクロ機能でフロントマターを挿入できるようにしておくと便利です。 下記の Vim スクリプトは、現在編集中のファイルの先頭に、date プロパティや url プロパティを挿入する Hugo コマンドを定義します。 ~/vimrc_hugo.vim \u0026#34; 0〜n-1 の範囲のランダム整数を生成する function! s:RandNum(n) return reltime()[1] % (a:n) endfunction \u0026#34; 指定した長さのランダム文字列を生成する function! s:RandStr(length) let chars = \u0026#39;23456789abcdefghijkmnopqrstuvwxzy\u0026#39; let n = len(chars) let result = \u0026#39;\u0026#39; for i in range(a:length) let result .= chars[s:RandNum(n)] endfor return result endfunction \u0026#34; 先頭行に Hugo 用のフロントマターを挿入する function! s:InsertHugoFrontMatter() let title = \u0026#34;title: \\\u0026#34;\\\u0026#34;\\n\u0026#34; let url = \u0026#34;url: \\\u0026#34;p/\u0026#34; . s:RandStr(7) . \u0026#34;/\\\u0026#34;\\n\u0026#34; let date = \u0026#34;date: \\\u0026#34;\u0026#34; . strftime(\u0026#34;%Y-%m-%d\u0026#34;) . \u0026#34;\\\u0026#34;\\n\u0026#34; let tags = \u0026#34;tags: [\\\u0026#34;\\\u0026#34;]\\n\u0026#34; execute \u0026#34;:normal gg\u0026#34; execute \u0026#34;:normal I\u0026#34; . \u0026#34;---\\n\u0026#34; . title . url . date . tags . \u0026#34;---\\n\\n\u0026#34; execute \u0026#34;:normal gg\u0026#34; endfunction \u0026#34; Hugo コマンドを定義する command! Hugo call s:InsertHugoFrontMatter() このスクリプトファイルを ~/.vimrc などから下記のように読みこんでおくか、直接コードを ~/.vimrc にコピペしておけば、Vim エディタ上で Hugo コマンドを実行できるようになります。 ~/.vimrc（Windows の場合は %HOME%/_vimrc） source \u0026lt;sfile\u0026gt;:p:h/vimrc_hugo.vim ファイル名の前のあやしい記号群は、同じディレクトリにある別のファイルを読み込むためのおまじないです。 フルパスで指定しておいても OK です。 Vim エディタから下記のようにコマンドを実行すると、 :Hugo 現在編集中のファイルに、次のようなフロントマターが挿入されます。 --- title: \u0026#34;\u0026#34; url: \u0026#34;p/4nzaju5/\u0026#34; date: \u0026#34;2019-10-20\u0026#34; tags: [\u0026#34;\u0026#34;] --- （応用）GitHub の Issue や PullRequest からショートカット記法でリンクを張る GitHub のオートリンク機能を使うと、GitHub リポジトリの Issue や PR の Markdown ドキュメントの中から、簡単な ID 指定で Hugo のページにリンクを張れるようにようになります。 参考: GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink) - まくまくGitノート 例えば、https://blog.example.com/p/1234abc/ というアドレスの代わりに、BLOG-1234abc と記述するだけで済むようになります。 本記事で紹介したように Hugo のページを ID ベースで管理する場合は、GitHub のオートリンク機能も合わせて利用すると幸せになれるかもしれません。 参考 出力される HTML ファイルのパスが変更されると、それに付随する画像ファイルとの位置関係が変わって、画像の表示ができなくなってしまうかもしれません。 下記の記事で紹介しているショートコードを使って画像を表示するようにしておくと、このような心配がなくなります。 参考: 画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle)`},{url:"/p/9n8p6n4/",title:"Hugo で画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle)",date:"2019-10-19T00:00:00Z",body:"Hugo で画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle) ページバンドルとは 初期の頃の Hugo では、画像ファイルは static ディレクトリに置いて、記事ファイル (Markdown) と別々のディレクトリで管理するという方法がとられていました。 content/ _index.md page1.md page2.md page3.md static/ image1.png image2.png image3.png しかし、これでは Markdown ファイルと画像ファイルをバラバラに管理しないといけないというユーザーの不満が出て、現状は content ディレクトリ以下に一緒に配置できるようになっています。 この仕組みを ページバンドル (Page Bundle) と言います。 参考: Page Bundles - Hugo ページバンドルは、その名のとおり、各ページにバンドルする形で画像ファイル（リソース）を保持するという考え方です。 ページバンドルを作成するには、content ディレクトリ以下に _index.md あるいは index.md を含むディレクトリを作成し、そのディレクトリ内に一緒に画像ファイルなどのリソースファイルを格納します（画像ファイル以外のファイルでも OK）。 つまり、バンドルされた画像ファイルを表示したいページは、_index.md あるいは index.md というファイル名のコンテンツでなければいけません。 Page Bundle には、Branch Bundle と Leaf Bundle の 2 種類があり、_index.md を含むディレクトリは Branch Bundle となり、index.md を含むディレクトリは Leaf Bundle となります。 content/ branch/ ← Branch Bundle _index.md image1.png data/ image2.png （不正なリソース） leaf/ ← Leaf Bundle index.md image3.png （Leaf Bundle のリソース） data/ image4.png （Leaf Bundle のリソース） Branch Bundle は、いわゆるセクションを構成するものなので、その下にさらに別のバンドル (Branch Bundle あるいは Leaf Bundle) を入れ子で持つことができます。 一方 Leaf Bundle は、末端のページであり、その下に別のバンドルを持つことはできません（というかその下に子ページを作れない）。 本家のサイトの記述を理解するのには中々時間がかかりますが、かみ砕いてまとめると次のような感じです。 Branch Bundle _index.md を持つディレクトリ。いわゆるセクションページに、画像などのリソースをくっつけたもの。 入れ子で別のバンドルを含むことができる（子ページを持てることと同義）。 リソースファイル用のサブディレクトリを持つことはできない（サブディレクトリは、あくまで別のページ用に作るものである）。だから、_index.md から参照する画像ファイルなどは、_index.md と同じディレクトリ内に並べて置く必要がある。 このディレクトリ以下に配置した Markdown ファイル (.md) は、別の独立したシングルページとして存在することになる（当たり前のように思えるけど、下の Leaf Bundle の場合はちょっと違う扱いになる）。 Leaf Bundle index.md を持つディレクトリ。いわゆるシングルページに、専用のディレクトリを割り当てたもの。 入れ子で別のバンドルは含められない。だから、ブランチ（枝）に対して、リーフ（葉）という名前が付けられている。 リソースファイル用のサブディレクトリを持つことができる。このディレクトリ以下に置いた index.md 以外のファイルは、どんなに深いディレクトリに置こうが、この Leaf Bundle のリソースである。だから、index.md から参照する画像ファイルは、それ以下の階層であればどこにでも置ける。 Markdown ファイル (.md) でさえ、このディレクトリ内に配置したら、Leaf Bundle のリソースという扱いになる（単独で表示する記事ページとはみなされない）。 Branch Bundle 内でのリソース参照 Branch Bundle から見ていきます。 下記の content ディレクトリは Branch Bundle を構成している部分の抜粋です。 content/ branch/ ← Branch Bundle _index.md image1.png data/ image2.png （不正なリソース） _index.md（セクションページ）の中から、同じ階層に置いた image1.png を下記のように参照することができます。 1 行目は HTML のべた書き、2 行目は Markdown の文法、3 行目は Hugo 組み込みの figure ショートコード を使用した記述方法です。 まぁ迷ったらショートコードを使用しておきましょう（まとめて振る舞いを変えやすいので）。 \u0026lt;img src=\u0026#34;image1.png\u0026#34; alt=\u0026#34;画像1\u0026#34;\u0026gt; ![画像1](image1.png) {{\u0026lt; figure src=\u0026#34;image1.png\u0026#34; alt=\u0026#34;画像1\u0026#34; \u0026gt;}} content/branch ディレクトリの下には、悪いリソースの配置例として data/image2.png ファイルを用意してあります。 実は Branch Bundle では、このように _index.md と違う階層に配置したリソースを参照することができません。 デフォルトの状態では、下記のようにすれば参照できてしまうかもしれませんが、 \u0026lt;img src=\u0026#34;data/image2.png\u0026#34;\u0026gt; ![data/image2](data/image2.png) {{\u0026lt; figure src=\u0026#34;data/image2.png\u0026#34; \u0026gt;}} _index.md のフロントマターで url プロパティなどを指定して、出力先のディレクトリを変更したとたんに 404 Not Found エラーになってしまいます。 なぜなら、data ディレクトリに配置した画像ファイルの出力先（コピー先）は、_index.md の出力先と連動して変化してくれないからです。 つまり、data ディレクトリ内のファイルは、_index.md にバンドルされたリソースとして扱われていないということです。 以上のような理由により、Branch Bundle では、基本的に画像ファイルを _index.md と同じディレクトリ内に配置することになります。 もちろん、フルパス指定で \u0026lt;img src=\u0026quot;/branch/data/image2.png\u0026quot;\u0026gt; と記述すれば、まったく別のディレクトリに出力された画像ファイルを参照できてしまいますが、そのような指定をするくらいであれば、従来の static ディレクトリを使ってリソースファイルを管理した方が余計なトラブルの心配が少ないと思います。 Leaf Bundle 内でのリソース参照 次に、もうひとつのページバンドルの種類である Leaf Bundle です。 下記の content ディレクトリは Leaf Bundle を構成している部分の抜粋です。 Leaf Bundle は Branch Bundle の下に入れ子にする形で配置できます。 というか、Leaf Bundle 同士で入れ子にしなければどこにでも置けます。 content/ branch/ ← Branch Bundle leaf/ ← Leaf Bundle index.md image3.png （Leaf Bundle のリソース） data/ image4.png （Leaf Bundle のリソース） index.md ファイル（アンダースコアなし）を配置したディレクトリが Leaf Bundle となります。 Branch Bundle と同様に、index.md ファイルと同じ階層に置かれた画像ファイルは、次のように参照することができます。 \u0026lt;img src=\u0026#34;image3.png\u0026#34; alt=\u0026#34;画像3\u0026#34;\u0026gt; ![画像3](image3.png) {{\u0026lt; figure src=\u0026#34;image3.png\u0026#34; alt=\u0026#34;画像3\u0026#34; \u0026gt;}} Branch Bundle とは異なり、Leaf Bundle ではそのディレクトリ以下のファイルがすべて自分自身にバンドルされているものだとみなされるため、深い階層に置いた画像ファイルにも直感的に（相対パスで）アクセスできます。 \u0026lt;img src=\u0026#34;data/image4.png\u0026#34; alt=\u0026#34;画像4\u0026#34;\u0026gt; ![画像4](data/image4.png) {{\u0026lt; figure src=\u0026#34;data/image4.png\u0026#34; alt=\u0026#34;画像4\u0026#34; \u0026gt;}} 逆に、index.md ファイルを置いたディレクトリ以下には、別のページを構成するための Markdown ファイルを配置することはできません。 配置したとしても、それはあくまで Leaf Bundle 内のリソースファイルとして扱われます。 ショートコードなどで、.Page.Resources 配列の内容を出力してみると、画像ファイルと一緒に Markdown ファイルも index.md ページに付随するリソースとして含まれていることが分かります。 index.md を配置したディレクトリは、そのページ専用のディレクトリになると考えましょう。 （応用）ページバンドルに含まれるリソースファイルの一覧を表示する 下記のショートコードは、現在のページにバンドルされているリソースファイルを列挙します。 layouts/shortcodes/list-page-resources.html \u0026lt;ul\u0026gt; {{- range .Page.Resources }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Name }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; 任意のページの Markdown ファイル内で下記のように使用します。 {{\u0026lt; list-page-resources \u0026gt;}} 参考: Page Resources - Hugo （応用）別のページのページバンドルリソースを参照する .Site.GetPage 関数などを使用して、別のページの Page インスタンスを取得すれば、そのページバンドルとして格納されているリソースファイルを参照することができます（もちろん、そのページがページバンドルになっている必要があります）。 ただ、こういった仕組みを使いすぎると、全体的に複雑な構成になってメンテナンス性が下がってしまいます。 共有したいリソースファイルがあるときは、できるだけ static ディレクトリを使って単純なファイルコピーで済ませられないか検討することをオススメします。 下記のショートコードを使用すると、dir パラメータで指定したページから、src で指定した名前の画像リソースを参照して表示できます。 layouts/shortcodes/shared-image.html {{ $dir := .Get \u0026#34;dir\u0026#34; }} {{ $src := .Get \u0026#34;src\u0026#34; }} {{ $page := .Page.GetPage $dir }} {{ $imagePath := ($page.Resources.GetMatch $src).RelPermalink }} \u0026lt;img src=\u0026#34;{{ $imagePath }}\u0026#34;\u0026gt; 例えば、下記のような構成で data/index.md による Leaf Bundle が作成されていて、その中の sample.png を外側のページから参照したいとします。 content/ section/ data/ ← Leaf Bundle index.md （Leaf Bundle を生成するには index.md が必要） sample.png _index.md （セクションページ） page.md （シングルページ） section/_index.md や section/page.md の中から、下記のようにショートコードを呼び出すと、data/sample.png を表示することができます。 つまり、2 つのページから 1 つのページバンドル内の画像を共有できます。 {{\u0026lt; shared-image dir=\u0026#34;data\u0026#34; src=\u0026#34;sample.png\u0026#34; \u0026gt;}} .Page.GetPage 関数に相対パス（上記の例では data）を渡すと、content ディレクトリ内の相対的な位置関係をもとに Page オブジェクトを取得できるようです。 なので、仮に section/_index.md や section/page.md のフロントマターで url プロパティを指定をして、HTML ファイルの出力先が変わったとしてもリソースは正しく参照できます。 （応用）image ショートコードを作成する Hugo は画像を表示するための組み込みショートコードとして figure を提供しています。 figure ショートコードの実装は、下記の GitHub リポジトリで参照できます。 shortcodes/figure.html - Hugo 画像の表示はいろいろとカスタマイズしたかったりするので（デフォルトで CSS クラスを付加するとか）、何か不満を感じたら、早めに自分専用のショートコードを作成してしまった方がよいでしょう。 figure ショートコードをベースにして少しずつ修正していけば簡単です。 私は自分用にカスタマイズした image という名前のショートコードを作成して使っています。 基本的に画面中央に画像を大きく表示するためのショートコードになっており、画像をインライン表示したい場合は、それ専用に作成した image-inline という別のショートコードを使っています。 layouts/shortcodes/image.html （大したことしてなかったので省略）"},{url:"/p/imx8hr2/",title:"Choreographer で FPS を計測する（Fps クラスの実装）",date:"2019-09-18T00:00:00Z",body:"Choreographer で FPS を計測する（Fps クラスの実装） Choreographer クラスによる FPS 計測 Android の Choreographer クラスを使用すると、フレームの描画開始のタイミングで呼び出されるコールバック (Choreographer.FrameCallback) を登録することができます。 Choreographer#postFrameCallback(callback: Choreographer.FrameCallback!) 上記のメソッドでコールバックを登録すると、次のフレーム描画のタイミングで doFrame(long frameTimeNanos) メソッドが呼び出されます。 Choreographer.FrameCallback#doFrame(frameTimeNanos: Long) パラメータとして描画開始時刻（ナノ秒単位）が渡されるため、前回のコールバック時の描画開始時刻からの差分を取れば、1 フレームの描画にかかった時間を求めることができます。 この値を使えば、FPS (Frame per second) は下記のように計算できます。 FPS = 1秒あたりのナノ秒 / 描画にかかった時間（ナノ秒） サンプルコード Fps クラスの実装 下記の Fps クラスは、FPS を簡単に計測するためのクラスです。 内部で Android の Choreographer を使っています。 Fps.kt import android.view.Choreographer import java.util.concurrent.TimeUnit class Fps : Choreographer.FrameCallback { interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Float) } private val choreographer = Choreographer.getInstance() private var fpsCallback: FpsCallback? = null private var prevFrameTimeNanos: Long = 0 /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: FpsCallback) { this.fpsCallback = fpsCallback prevFrameTimeNanos = 0 choreographer.postFrameCallback(this) } /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: (Float) -\u0026gt; Unit) { startObserving(object : FpsCallback { override fun onFpsUpdated(fps: Float) = fpsCallback(fps) }) } /** * Stops observing the FPS. */ fun stopObserving() { choreographer.removeFrameCallback(this) } /** * Implementation for [Choreographer.FrameCallback]. */ override fun doFrame(frameTimeNanos: Long) { // Register the same callback again to be called continuously choreographer.postFrameCallback(this) // At first, just store the frame time for later calculation if (prevFrameTimeNanos == 0L) { prevFrameTimeNanos = frameTimeNanos return } // Calculate FPS and pass it to the callback function val elapsed = frameTimeNanos - prevFrameTimeNanos val fps = TimeUnit.SECONDS.toNanos(1) / elapsed.toFloat() checkNotNull(fpsCallback).onFpsUpdated(fps) prevFrameTimeNanos = frameTimeNanos } } Choreographer#postFrameCallback() で登録したコールバックは、一度しか呼び出されないことに注意してください。 連続してフレーム描画のタイミングを取得するには、毎回同じコールバックを登録し直す必要があります（上記では、doFrame() メソッドの先頭で登録しています）。 Fps クラスの使用例 Fps クラスを使って FPS の観測を行うには、例えば次のようにします。 Fps().startObserving { fps -\u0026gt; Log.i(\u0026#34;DEBUG\u0026#34;, \u0026#34;FPS = %.3f\u0026#34;.format(fps)) } （応用） 1 秒おきに平均 FPS を求める 上記のサンプルコードでは、毎フレーム FPS を求めてコールバック関数を呼び出していましたが、これでは高頻度すぎるという場合は、下記のようにすれば約 1 秒ごとに呼び出すように軽量化できます。 FrameCallback.doFrame() が呼び出されたときに、前回のコールバックから 1 秒以上経過している場合だけ、コールバックするようにしています。 ここでは、約 1 秒間のフレーム数を数えて平均 FPS を求めています。 Fps.kt (2) import android.view.Choreographer import java.util.concurrent.TimeUnit /** * Utility class for obtaining FPS (frames per second). */ class Fps : Choreographer.FrameCallback { companion object { /** Callbacks are invoked at intervals of this time. */ private val CALLBACK_INTERVAL_NANOS = TimeUnit.SECONDS.toNanos(1) } interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Double) } private val choreographer = Choreographer.getInstance() private var fpsCallback: FpsCallback? = null private var prevCallbackTimeNanos: Long = 0 /** How many times doFrame is called since the last onFpsUpdated. */ private var frames = 0 /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: FpsCallback) { this.fpsCallback = fpsCallback prevCallbackTimeNanos = 0 frames = 0 // Add a frame callback but prevents duplicate registration choreographer.removeFrameCallback(this) choreographer.postFrameCallback(this) } /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: (Double) -\u0026gt; Unit) { startObserving(object : FpsCallback { override fun onFpsUpdated(fps: Double) = fpsCallback(fps) }) } /** * Stops observing the FPS. */ fun stopObserving() { choreographer.removeFrameCallback(this) } /** * Implementation for [Choreographer.FrameCallback]. */ override fun doFrame(frameTimeNanos: Long) { // Register the same callback again to be called continuously choreographer.postFrameCallback(this) // At first, just store the frame time for later calculation if (prevCallbackTimeNanos == 0L) { prevCallbackTimeNanos = frameTimeNanos return } frames++ // Callback at the intervals of CALLBACK_INTERVAL_NANOS val elapsed = frameTimeNanos - prevCallbackTimeNanos if (elapsed \u0026gt;= CALLBACK_INTERVAL_NANOS) { // Calculate FPS and pass it to the callback function val fps = frames.toDouble() * TimeUnit.SECONDS.toNanos(1) / elapsed checkNotNull(fpsCallback).onFpsUpdated(fps) // Reset counters prevCallbackTimeNanos = frameTimeNanos frames = 0 } } } （応用） 1 秒おきに最低 FPS を求める 上記の例では、1 秒間の描画フレーム数を数えることで秒間平均 FPS を求めていましたが、その方法だと、あるフレームが非常に遅くても、残りのフレームが高速であれば、FPS としては比較的高い値が出てしまいます。 ここでは、もっとストイックに、過去 1 秒間で最も時間のかかったフレームの描画時間をもとに、FPS 計算するようにしてみます。 つまり、 秒間最低 FPS（秒間最悪 FPS） です。 秒間最低FPS = 1秒あたりのns / 最も時間のかかったフレームの描画時間(ns) Fps.kt (3) import android.view.Choreographer import java.lang.Long.max import java.util.concurrent.TimeUnit /** * Utility class for obtaining FPS (frames per second). */ class Fps : Choreographer.FrameCallback { companion object { /** Callbacks are invoked at intervals of this time. */ private val CALLBACK_INTERVAL_NANOS = TimeUnit.SECONDS.toNanos(1) } interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Double) } private val choreographer = Choreographer.getInstance() private var fpsCallback: FpsCallback? = null private var prevCallbackTimeNanos: Long = 0 private var prevFrameTimeNanos: Long = 0 /** Maximum frame time over the last one minute. */ private var worstFrameTimeNanos: Long = 1 /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: FpsCallback) { this.fpsCallback = fpsCallback prevCallbackTimeNanos = 0 // Add a frame callback but prevents duplicate registration choreographer.removeFrameCallback(this) choreographer.postFrameCallback(this) } /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: (Double) -\u0026gt; Unit) { startObserving(object : FpsCallback { override fun onFpsUpdated(fps: Double) = fpsCallback(fps) }) } /** * Stops observing the FPS. */ fun stopObserving() { choreographer.removeFrameCallback(this) } /** * Implementation for [Choreographer.FrameCallback]. */ override fun doFrame(frameTimeNanos: Long) { // Register the same callback again to be called continuously choreographer.postFrameCallback(this) // At first, just store the frame time for later calculation if (prevCallbackTimeNanos == 0L) { prevCallbackTimeNanos = frameTimeNanos prevFrameTimeNanos = frameTimeNanos return } worstFrameTimeNanos = max(worstFrameTimeNanos, frameTimeNanos - prevFrameTimeNanos) // Callback at the intervals of CALLBACK_INTERVAL_NANOS val elapsed = frameTimeNanos - prevCallbackTimeNanos if (elapsed \u0026gt;= CALLBACK_INTERVAL_NANOS) { // Calculate the minimum FPS and pass it to the callback function val fps = TimeUnit.SECONDS.toNanos(1).toDouble() / worstFrameTimeNanos checkNotNull(fpsCallback).onFpsUpdated(fps) // Reset counters prevCallbackTimeNanos = frameTimeNanos worstFrameTimeNanos = 1 } prevFrameTimeNanos = frameTimeNanos } }"},{url:"/p/vu7hr2b/",title:"Hugo サイトの favicon.ico をサイトのルートに配置する (static)",date:"2019-09-10T00:00:00Z",body:"Hugo サイトの favicon.ico をサイトのルートに配置する (static) Hugo によって生成した Web サイトのルート階層に favicon.ico を配置するには、static ディレクトリに favicon.ico ファイルをそのまま置いておけば OK です。 website/ +-- content/ +-- layouts/ +-- static/ +-- favicon.ico static ディレクトリ以下に置いたファイル群は、その階層構造を保ったまま出力ディレクトリへコピーされます。 favicon の詳細については下記を参考にしてください。 Web サイトに favicon を設定する"},{url:"/p/y2biqz7/",title:"Python でドキュメンテーションコメント (docstring) を記述する",date:"2019-06-04T00:00:00Z",body:"Python でドキュメンテーションコメント (docstring) を記述する Docstring とは？ Python のコードに docstring フォーマットでコメントを記述しておくと、いろいろなツールから API ドキュメントとして参照できるようになります。 例えば、Python 用の統合開発環境 (IDE) におけるコード補完時に、ヒントとして関数の使用方法が表示されます。 下記は PEP 257 \u0026ndash; Docstring Conventions に記述されている docstring の書き方の例です。 def complex(real=0.0, imag=0.0): \u0026#34;\u0026#34;\u0026#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) \u0026#34;\u0026#34;\u0026#34; if imag == 0.0 and real == 0.0: return complex_zero ... docstring はこのように 3 つのクォート (\u0026quot;\u0026quot;\u0026quot;) で囲んで記述します。 docstring コメントは関数の内部に記述する ところがポイントです。 このあたりは、関数の外側にドキュメンテーションコメントを記述する Java や C# などとは異なっています。 Docstring の書き方 \u0026quot;\u0026quot;\u0026quot; で始まり \u0026quot;\u0026quot;\u0026quot; で終わる。 一行目はサマリであり、ピリオドで終わるフレーズで記述する。 一行目は \u0026quot;\u0026quot;\u0026quot; と同じ行に記述してもよいし、改行してから記述してもよい。 最後の \u0026quot;\u0026quot;\u0026quot; は行末に書いてもよいし、単独の行に書いてもよい。 一行だけで記述する場合は、開始クォートと終了クォートを同じ行に記述してもよい。 def complex(real=0.0, imag=0.0): \u0026#34;\u0026#34;\u0026#34;Form a complex number.\u0026#34;\u0026#34;\u0026#34; 一行当たり 72 文字以内 で記述する。 クラスメソッドであれば、最初から 8 文字インデントして書き始めることになるので、結局、一行あたりのサイズを 80 文字にするということですね。 r\u0026quot;\u0026quot;\u0026quot; で始めると Raw docstring となり、バックスラッシュを含めることができる。 サマリは命令形で記述する。動詞で始め、三単現の s は付けない（例: Return ...）。 これは、Javadoc が三単現の s を付けるのを慣例しているのとは対照的です。下記は、PEP 257 \u0026ndash; Docstring Conventions からの抜粋です。 The docstring is a phrase ending in a period. It prescribes the function or method\u0026rsquo;s effect as a command (\u0026ldquo;Do this\u0026rdquo;, \u0026ldquo;Return that\u0026rdquo;), not as a description; e.g. don\u0026rsquo;t write \u0026ldquo;Returns the pathname \u0026hellip;\u0026rdquo;. 詳細なコメントを記述する場合は、一行目にサマリ、二行目は空行、三行目以降に詳細コメントを記述する。この場合も一行目のサマリは、\u0026quot;\u0026quot;\u0026quot; と同じ行に記述してよい。 def complex(real=0.0, imag=0.0): \u0026#34;\u0026#34;\u0026#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) \u0026#34;\u0026#34;\u0026#34; パッケージのドキュメントは __init__.py に書く。自分が export するモジュールやサブパッケージをリスト化し、それぞれ一行のサマリを記述する。 Docstring の記述例 os モジュールの例 def normcase(s): \u0026#34;\u0026#34;\u0026#34;Normalize case of pathname. Makes all characters lowercase and all slashes into backslashes.\u0026#34;\u0026#34;\u0026#34; urllib.request モジュールの例 def _open_generic_http(self, connection_factory, url, data): \u0026#34;\u0026#34;\u0026#34;Make an HTTP connection using connection_class. This is an internal method that should be called from open_http() or open_https(). Arguments: - connection_factory should take a host name and return an HTTPConnection instance. - url is the url to retrieval or a host, relative-path pair. - data is payload for a POST request or None. \u0026#34;\u0026#34;\u0026#34; json モジュールの例 def load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw): \u0026#34;\u0026#34;\u0026#34;Deserialize ``fp`` (a ``.read()``-supporting file-like object containing a JSON document) to a Python object. ``object_hook`` is an optional function that will be called with the result of any object literal decode (a ``dict``). The return value of ``object_hook`` will be used instead of the ``dict``. This feature can be used to implement custom decoders (e.g. JSON-RPC class hinting). ``object_pairs_hook`` is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of ``object_pairs_hook`` will be used instead of the ``dict``. This feature can be used to implement custom decoders. If ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority. To use a custom ``JSONDecoder`` subclass, specify it with the ``cls`` kwarg; otherwise ``JSONDecoder`` is used. \u0026#34;\u0026#34;\u0026#34; （コラム）Docstring はなぜ 72 文字までなのか？ PEP 8 \u0026ndash; Style Guide for Python Code では、docstring コメントは一行あたり 72 文字まで にすることを推奨しています。 For flowing long blocks of text with fewer structural restrictions (docstrings or comments), the line length should be limited to 72 characters. \u0026hellip; The Python standard library is conservative and requires limiting lines to 79 characters (and docstrings/comments to 72). 72 文字という数字は、パンチカードの印刷幅から来ているという説や、ツールでの出力を考慮しているという説などがあります。 現実的にはツールの出力を考慮しているのだと考えるのが自然でしょう。 例えば、Python 付属の pydoc コマンドで、main.py 内のドキュメンテーションコメントを表示すると下記のように表示されます。 $ pydoc main Help on module main: NAME main FUNCTIONS complex(real=0.0, imag=0.0) Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) FILE /User/maku/main.py 関数のドキュメンテーション部分には 8 文字分のインデントが入っています。 よって、ドキュメンテーションコメント自体は 72 文字に収めておかないと、合計で 80 文字を超えることになってしまいます。"},{url:"/p/i4zkqye/",title:"Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする",date:"2019-05-30T00:00:00Z",body:"Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする リクエストごとにヘッダを設定する (Request) urllib.request.Request オブジェクトの add_header メソッドや、headers プロパティを使用すると、HTTP リクエスト時のヘッダ情報を設定することができます。 あとは、urllib.request.urlopen で HTTP リクエストを送信するとき、URL の代わりに Request オブジェクトを渡せば、ヘッダ付きのリクエストを送ることができます。 import urllib.request def create_request(): req = urllib.request.Request(\u0026#39;https://example.com/myapi\u0026#39;) req.add_header(\u0026#39;Referer\u0026#39;, \u0026#39;http://www.python.org/\u0026#39;) req.add_header(\u0026#39;User-Agent\u0026#39;, \u0026#39;Mozilla/5.0\u0026#39;) return req if __name__ == \u0026#39;__main__\u0026#39;: req = create_request() with urllib.request.urlopen(req) as res: html = res.read().decode(\u0026#39;utf-8\u0026#39;) print(html) 上記の例では、Request#add_header() メソッドを使って、ヘッダ情報を 1 つずつ付加しています。 Request#headers プロパティを使用すれば、複数のヘッダ情報をディクショナリ形式でまとめて設定することができます。 req.headers = { \u0026#39;Referer\u0026#39;: \u0026#39;http://www.python.org/\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0\u0026#39;, } すべてのリクエストに共通のヘッダを設定する (OpenerDirector) Request オブジェクトは URL まで含んでいるため、アクセス先の URL が変わるたびに生成しなおす必要があります。 一方、OpenerDirector を使用すると、リクエスト時のヘッダ情報などはそのままで、URL だけを変更してアクセスすることができます。 import urllib.request def create_opener(): opener = urllib.request.build_opener() opener.addheaders = [ (\u0026#39;Referer\u0026#39;, \u0026#39;http://www.python.org/\u0026#39;), (\u0026#39;User-Agent\u0026#39;, \u0026#39;Mozilla/5.0\u0026#39;), ] return opener if __name__ == \u0026#39;__main__\u0026#39;: opener = create_opener() with opener.open(\u0026#39;https://example.com/myapi\u0026#39;) as res: html = res.read().decode(\u0026#39;utf-8\u0026#39;) print(html) ヘッダ情報は OpenerDirector#addheaders プロパティにセットするのですが、add という名前なのにプロパティになっていたり、ディクショナリではなくリストで値を設定しなければいけなかったりと、謎仕様なところには注意してください。 作成した OpenerDirector オブジェクトを、urllib.request.install_opener 関数で設定してやることで、それ以降の urlopen はその OpenerDirector の設定に基づいて動作するようになります。 アプリケーション全体でアクセス方法を統一したいのであれば、こちらの方法を使うとシンプルかもしれません。 import urllib.request def setup_requests(): opener = urllib.request.build_opener() opener.addheaders = [ (\u0026#39;Referer\u0026#39;, \u0026#39;http://www.python.org/\u0026#39;), (\u0026#39;User-Agent\u0026#39;, \u0026#39;Mozilla/5.0\u0026#39;), ] urllib.request.install_opener(opener) if __name__ == \u0026#39;__main__\u0026#39;: setup_requests() with urllib.request.urlopen(\u0026#39;https://example.com/myapi\u0026#39;) as res: html = res.read().decode(\u0026#39;utf-8\u0026#39;) print(html)"},{url:"/p/qpcvfzi/",title:"Hugo でドラフトページの一覧を簡単に確認できるようにする",date:"2019-05-22T00:00:00Z",body:"Hugo でドラフトページの一覧を簡単に確認できるようにする やりたいこと Hugo では、作成途中の記事ページをドラフトとしてマークしておくと、デフォルトで非公開扱いになるので、気軽に記事を書き始めることができます。 ただ、ドラフトページがたくさん溜まってくると、自分が中途半端に書き始めた記事が散らばって分かりにくくなってしまいます。 そこで、ここでは下記のような仕組みを実装して、Hugo のドラフト機能をより便利に使用できるようにします。 図: ドラフト一覧のページへ移動するボタン ドラフトの一覧ページに飛ぶための ドラフト記事一覧ボタン をサイドバー上に表示する（上図） ドラフトの一覧ページでは、最終更新日 や タグ情報 も一緒に表示する 上記は ローカルでの作業中のみ表示する こととする（具体的には hugo server で実行中のみ） ドラフト記事一覧のページにジャンプするボタンを配置する ドラフトページへジャンプするためのボタンは、レイアウトファイルから簡単に配置できるように、パーシャルファイルとして作成します。 個人的に、ローカルでしか有効にしないコードは、下記のように debug ディレクトリの下に入れるようにしています。 そして、全体のコードを if .Site.IsServer の条件で囲むことで、ローカルサーバーで起動しているときのみ出力されるようにしています。 layouts/partials/debug/draft-button.html {{- if .Site.IsServer -}} \u0026lt;style\u0026gt; .xDraftButton { display: block; text-align: center; width: 100%; font-weight: bolder; color: white !important; background: blue; padding: 0.3em 0.5em; border-radius: 0.5em; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;/drafts/\u0026#34; class=\u0026#34;xDraftButton\u0026#34;\u0026gt;ドラフト記事一覧\u0026lt;/a\u0026gt; {{- end }} 簡単に言えば、このパーシャルは、https://example.com/drafts/ といった URL へのリンクを出力しているだけです。 上記では style 要素も含めてしまっていますが、みなさんはちゃんと CSS ファイルでスタイル定義するようにしてください。 このパーシャルファイルを、サイドバーを出力するテンプレートから呼び出します。 layouts/partials/sidebar/all.html（抜粋） {{ partial \u0026#34;debug/draft-button\u0026#34; . }} ドラフト記事一覧を表示するページを作成する ドラフト記事をリストアップするためのショートコードを作成します。 下記のようにすれば、フロントマター部分に draft: true と記述された記事のみをループ処理できます。 layouts/shortcodes/list-drafts.html \u0026lt;ul\u0026gt; {{- range (where .Site.Pages \u0026#34;.Draft\u0026#34; true) }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;small\u0026gt; ({{ .Lastmod.Format \u0026#34;2006-01-02\u0026#34; }}) {{ range .Params.tags }}#{{ . }} {{ end }} \u0026lt;/small\u0026gt; \u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; このショートコードを、ドラフト記事一覧のページを生成するための Markdown ファイルから呼び出します。 ドラフトボタンのリンク先 URL を /drafts/ にしたので、その URL に合うように、drafts/_index.md というパスに作成します。 content/drafts/_index.md --- title: \u0026#34;ドラフト記事一覧\u0026#34; draft: true --- （ここに本文を書くこともできるよ！） {{\u0026lt; list-drafts \u0026gt;}} これで、hugo server -D とサーバーモードで起動したときに、ドラフト記事一覧へのリンクボタンが表示されるようになり、簡単に書きかけの記事を確認できるようになります。 ドラフト記事をビルド対象にするために、-D オプションが必要になることに注意してください。"},{url:"/p/x9tbr8o/",title:"Hugo で各ページに目次を表示する (.TableOfContents)",date:"2019-05-21T00:00:00Z",body:"Hugo で各ページに目次を表示する (.TableOfContents) Hugo 組み込みのページ変数 .TableOfContents を使用すると、各ページに簡単に目次を表示することができます。 Hugo の目次機能 各ページの Markdown ファイル (.md) には、## や ---- を使ったセクション（h2 要素として出力される）を記述していると思います。 Hugo は、これらの セクション名から自動的に目次 (Table of Contents) を出力する機能 を搭載しています。 下記は、自動的に出力した目次の例です。 図: Hugo で自動生成された目次 テンプレートの記述方法（v0.59以前） 目次を自動的に出力するには、テンプレートファイル内で .TableOfContents というページ変数を参照します。 layouts/_default/single.html（抜粋） {{- with .TableOfContents }} \u0026lt;aside class=\u0026#34;xToc\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;xToc_title\u0026#34;\u0026gt;目次\u0026lt;/div\u0026gt; {{ . }} \u0026lt;/aside\u0026gt; {{- end }} ここでは、目次情報がないときに何も表示しないように、with で分岐処理を行っています（2019-12-26 追記: v0.60.0 以降は出力内容が変わったため、このように分岐処理を行えなくなりました。次のセクションを参照してください）。 Hugo が自動的に生成する .TableOfContents の値は、ul 要素と li 要素によって構成されています。 出力された HTML の内容を見て、スタイルシート (CSS) の調整をするとよいでしょう。 下記は CSS の記述例です。 .xToc { font-size: smaller; border-radius: 0.5em; border: solid 1px lightgray; padding: 0.5em 1em; line-height: 2; } .xToc_title { font-weight: bolder; } .xToc ul { list-style-type: none; padding-left: 0; } .xToc li { padding-top: 0 !important; } .xToc li \u0026gt; ul { padding-left: 1em; width: 100%; } .xToc a { font-weight: normal; display: block; border-bottom: dashed 1px lightgray; } テンプレートの記述方法（v0.60以降） Hugo v0.60 から Markdown パーサーが Goldmark に変更され、Table of Contents の出力内容も変わってしまいました。 これまでは、ページ内に見出し（h2 要素など）が存在しない場合は、.TableOfContents 変数の値は空っぽになっていたので、その場合は「目次」というタイトルも含めて何も出力しない、という制御ができていました。 しかし、v0.60 以降は、ページ内に一切見出しが存在しなくても .TableOfContents の値には次のような文字列が入ってしまいます。 \u0026lt;nav id=\u0026#34;TableOfContents\u0026#34;\u0026gt;\u0026lt;/nav\u0026gt; しょうがないので、Hugo テンプレートファイルの中では分岐処理などを行わずに、素直に .TableOfContents の値を出力しておきます。 layouts/_default/single.html（抜粋） {{ .TableOfContents }} 「目次」というタイトルを表示するかどうかの制御は、CSS で行うことにしましょう。 ここでは、#TableOfContents という ID の HTML 要素の直下に ul 要素があるときのみ、その直前に「目次」というテキストを挿入しています。 #TableOfContents \u0026gt; ul { font-size: smaller; border-radius: 0.5em; border: solid 1px lightgray; padding: 0.5em 1em; line-height: 2; } #TableOfContents \u0026gt; ul:before { content: \u0026#34;目次\u0026#34;; font-weight: bolder; } #TableOfContents ul { list-style-type: none; } #TableOfContents li { padding-top: 0; } #TableOfContents li \u0026gt; ul { padding-left: 1em; width: 100%; } #TableOfContents a { font-weight: normal; display: block; border-bottom: dashed 1px lightgray; } これで、ある程度は目次の見た目を制御できます。 本当は、ツールが生成する要素の ID (#TableOfContents) に依存する CSS などは記述したくないのですが、仕方ありません。 Hugo がうまい制御方法を用意してくれるまでこれで凌ぎます。 参考 Table of Contents ｜ Hugo"},{url:"/p/dunigdz/",title:"Hugo でページタイトルに自動でセクションプレフィックスを付ける",date:"2019-05-17T00:00:00Z",body:"Hugo でページタイトルに自動でセクションプレフィックスを付ける Hugo で多くのコンテンツを作成する場合、記事の種類ごとにセクション（ディレクトリ）に分けて管理することになります。 このような場合、各ページのタイトルに対して、セクションのタイトルを自動で付加できれば、ページタイトルの管理が楽になります。 何をするか？ 例えば、次のようなセクション構造で記事を管理しているとします。 contents/ +-- _index.md (home page) +-- section1/ | +-- _index.md (section page) | +-- page1.md (single page) | +-- page2.md (single page) | +-- page3.md (single page) +-- section2/ +-- _index.md (section page) +-- ... 各ディレクトリにある _index.md は、セクションページのコンテンツファイルとして使用されます。 このファイルのフロントマターには、下記のようにセクションのタイトルを記述することができます。 contents/section1/_index.md --- title: \u0026#34;セクション1\u0026#34; date: \u0026#34;2019-05-17\u0026#34; --- セクションページの本文… このセクションタイトルは、セクションページ（このケースでは https://example.com/section1/）にアクセスしたときに使用されるものですが、同じセクションに所属する記事ページのタイトルのプレフィックスにも自動で付加できると便利です。 例えば、section1 に所属する記事ページとして下記のようなコンテンツがあるとします。 contents/section1/page.md --- title: \u0026#34;タイトル1\u0026#34; date: \u0026#34;2019-05-17\u0026#34; --- ページの本文… このように記述されているときに、表示するタイトルを タイトル1 ではなく、セクション1: タイトル1 のようにしたいということです。 このように、セクションタイトルを付加することで、あるページを単独で表示したときに、どのような階層に配置された記事なのかが分かりやすくなります。 セクションプレフィックスの実装 ここでは、シングルページテンプレートで、セクションプレフィックスの仕組みを実現する方法を示します。 下記の例では、構築したページタイトルを $pageTitle という変数に格納しています。 layouts/_defaults/single.html（抜粋） {{ $pageTitle := cond (eq .CurrentSection.Section \u0026#34;\u0026#34;) (.Title) (printf \u0026#34;%s: %s\u0026#34; .CurrentSection.Title .Title) }} \u0026lt;h1\u0026gt;{{ $pageTitle }}\u0026lt;/h1\u0026gt; コンテンツのルートディレクトリ (contents) に配置したページにアクセスしたときは、.CurrentSection.Section の値が空 (\u0026quot;\u0026quot;) になることを利用して、ページのタイトルをそのまま表示するようにしています。 ☝️ ワンポイント 上記では、h1 要素で表示上のページタイトルを設定していますが、head 要素下の title 要素にも同様に設定するようにしてください。 Google などの検索エンジンは、title 要素に指定したページタイトルを表示します。 （応用）セクションプレフィックス用のプロパティを用意する方法 上記の例では、セクションプレフィックスとして、自分が所属するセクションのセクションページに設定された title プロパティの値を使用していました。 ここでは、セクションプレフィックス用に、独自のプロパティ sectionPrefix を参照するようにしてみます。 このようなケースでは、Hugo の Front Matter Cascade という機能を使用すると便利です。 例えば、セクションページのフロントマターで次のように記述しておくと、 contents/section1/_index.md --- title: \u0026#34;セクションタイトル1\u0026#34; cascade: sectionPrefix: \u0026#34;セクション1\u0026#34; --- このセクション内の記事では、.Params.sectionPrefix 変数で セクション1 という値を参照できるようになります。 親セクションのフロントマターで cascade: 以下に設定したプロパティを、すべての子ページから参照できるということです。 下記はテンプレートの実装例です。 テンプレートの例（抜粋） {{ $pageTitle := .Title }} {{ if ne .Kind \u0026#34;section\u0026#34; }} {{ with .Params.sectionPrefix }} {{ $pageTitle = printf \u0026#34;%s: %s\u0026#34; . $pageTitle }} {{ end }} {{ end }} \u0026lt;h1\u0026gt;{{ $pageTitle }}\u0026lt;/h1\u0026gt; 現在のページがセクションページでなければ、sectionPrefix プロパティの値をタイトルの前に連結する、という処理になっています。"},{url:"/p/gxk6qat/",title:"Hugo でソースコードをハイライト表示する (highlight)",date:"2019-03-17T00:00:00Z",body:"Hugo でソースコードをハイライト表示する (highlight) Pygments によるコードハイライト Hugo の設定ファイル config.toml の中で、下記のように設定しておくと、Pygments によるコードブロックのハイライト機能を有効にすることができます。 pygmentsCodeFences = true 例えば、Java のソースコードであれば、Markdown ファイルの中で、下記のように言語名 (java) を指定してコードブロックを記述するだけで、その言語に特化したハイライト表示を行ってくれます。 ```java public class Main { public static void main(String... args) { System.out.println(\u0026#34;Hello\u0026#34;); } } ``` 図: ハイライト表示例 highlight ショートコードによるコードハイライト Hugo の組み込みショートコードとして highlight が用意されています。 このショートコードを使用すると、pyghmentsCodeFences を使う方法よりも高度なコードハイライトを行えます。 例えば、下記のように、行番号を表示したり、特定の行を強調表示することができます。 {{\u0026lt; highlight java \u0026#34;linenos=table, hl_lines=3\u0026#34; \u0026gt;}} public class Main { public static void main(String... args) { System.out.println(\u0026#34;Hello\u0026#34;); } } {{\u0026lt; /highlight \u0026gt;}} 図: ハイライト表示例 色々なオプションが用意されているので、詳しくは下記の Hugo ドキュメントを参照してください。 Hugo - Syntax Highlighting キャプションを付けられる独自のショートコードを作成する ソースコードの表示をキャプション付きでマークアップする場合は、HTML では下記のように figure、figcaption タグを使って記述します。 \u0026lt;figure\u0026gt; \u0026lt;figcaption\u0026gt;サンプルコード\u0026lt;/figcaption\u0026gt; \u0026lt;pre\u0026gt;\u0026lt;code\u0026gt; public class Main { public static void main(String... args) { System.out.println(\u0026#34;Hello\u0026#34;); } } \u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; \u0026lt;/figure\u0026gt; このようなコードを手書きで毎回記述するのは大変なので、独自のショートコードを作る のがオススメです。 ここでは code というショートコードを作成し、コードブロックをタイトル付きでハイライト表示できるようにします。 ハイライト機能自体は自力で実装するのは大変なので、Hugo の組み込み関数として用意されている highlight 関数 を利用します（Hugo の組み込みの highlight ショートコードも、この highlight 関数を使って実装されています）。 layouts/shortcodes/code.html {{ $title := .Get \u0026#34;title\u0026#34; }} {{ $lang := or (.Get \u0026#34;lang\u0026#34;) \u0026#34;\u0026#34; }} \u0026lt;figure class=\u0026#34;xCodeBlock\u0026#34;\u0026gt; {{ with $title }}\u0026lt;figcaption class=\u0026#34;xCodeBlock_title\u0026#34;\u0026gt;{{ . }}\u0026lt;/figcaption\u0026gt;{{ end }} \u0026lt;div class=\u0026#34;xCodeBlock_code\u0026#34;\u0026gt;{{ highlight (trim .Inner \u0026#34;\\r\\n\u0026#34;) $lang \u0026#34;\u0026#34; }}\u0026lt;/div\u0026gt; \u0026lt;/figure\u0026gt; このショートコードは、Markdown ファイルの中で次のように呼び出します。 {{\u0026lt; code lang=\u0026#34;java\u0026#34; title=\u0026#34;タイトル\u0026#34; \u0026gt;}} public class Main { public static void main(String... args) { System.out.println(\u0026#34;Hello\u0026#34;); } } {{\u0026lt; /code \u0026gt;}} 図: ハイライト表示例 ちなみに、上記のようなタイトルラベルを表示するために、次のような CSS 定義を使用しています。 .xCodeBlock_title { display: inline-block; font-size: smaller; border-radius: 0.5em 0.5em 0 0; padding: 0 0.5em; background: gray; color: white; } .xCodeBlock_code { margin-top: -2px; } .xCodeBlock_code pre { padding: 0.5em; white-space: pre-wrap; } ハイライトのカラーテーマを変更する Hugo の highlight ショートコード、あるいは highlight 関数で使用されるカラーテーマは、CSS ファイルを用意することで変更することができます。 まず、highlight 機能によって出力される HTML コードが、CSS クラスを使用したものになるように、Hugo の設定ファイル config.toml に下記のような行を追加します。 config.toml に追記 pygmentsUseClasses = true 次に、使用したいカラーテーマの CSS ファイルを生成します。 下記のようなサイトからダウンロードしてしまうのが手っ取り早いです。 Pygments Syntax Highlighter CSS Theme Files Hugo にはシンタックスハイライト用の CSS ファイルを生成する機能がついているので、下記のようにコマンド実行して生成することもできます。 スタイル名は Pygments style gallery のサイトで探してください。 $ hugo gen chromastyles --style=manni \u0026gt; highlight-manni.css あとは、この CSS をすべてのページで読み込むようにすれば OK です。 参考: Hugo の highlight ショートコードの実装 hugo/tpl/tplimpl/embedded/templates/shortcodes/highlight.html - gohugoio/hugo - GitHub {{ if len .Params | eq 2 }} {{ highlight (trim .Inner \u0026#34;\\n\\r\u0026#34;) (.Get 0) (.Get 1) }} {{ else }} {{ highlight (trim .Inner \u0026#34;\\n\\r\u0026#34;) (.Get 0) \u0026#34;\u0026#34; }} {{ end }}"},{url:"/p/32n9scv/",title:"Hugo でリンクをページからの相対パスで出力するようにする (relativeurls)",date:"2019-02-21T00:00:00Z",body:"Hugo でリンクをページからの相対パスで出力するようにする (relativeurls) サイト内のページへのリンクを /sec1/sec2/ のように記述しておくと、デフォルトではそのまま /sec1/sec2/ へのリンクとして出力されます（つまり、baseURL からの相対パスになります）。 Hugo の設定ファイル config.toml（あるいは config.yaml）で relativeurls = true という設定を追加しておくと、各リンクが現在のページからの相対パスで出力されるようになります。 config.toml の例 baseURL = \u0026#34;https://example.com/\u0026#34; relativeurls = true languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;サンプル Web サイト\u0026#34; 例えば、/content/posts/sample.md というコンテンツファイル内に /about/ というリンクを記載しておくと、出力されるリンクのパスは ../about/ になります。"},{url:"/p/mprs3v6/",title:"GitHub の REST API を使用する",date:"2019-01-30T00:00:00Z",body:"GitHub の REST API を使用する GitHub の REST API でできること GitHub は Web API (REST API) を提供しており、コマンドラインや任意のアプリケーションから利用することで、GitHub の操作を自動化することができます。 Linux の curl コマンドや、スクリプト（Python や Ruby など）から簡単に利用できるので、Organization やリポジトリを管理する立場にある人はぜひ使ってみてください。 GitHub - REST API v3 GitHub の REST API を使うと、例えば、下記のような処理を自動化できます。 Users 指定したユーザの詳細情報を取得する 二要素認証が設定できていないユーザのリストを取得する Repositories 指定したオーナー（ユーザー or 組織）のリポジトリのリストを取得する Organizations/Members 指定した組織のユーザーリストを取得する Pull Requests Pull Request のリストを取得する Issues 指定したリポジトリの Issue のリストを取得する Projects 指定したリポジトリのプロジェクト（かんばん）のリストを取得する ただし、アプリケーションに GitHub との連携機能を本格的に組み込む場合は、REST API ではなく GraphQL API を使うをことをお勧めします。 参考: GitHub GraphQL API のクエリ例｜まくろぐ API トークンを発行する REST API を呼び出すには、API トークン (HTTPS Access Token) が必要です。 プライベートリポジトリに関する情報を取得するには、そのリポジトリへのアクセス権限を持つユーザが作成した API トークンを使用して REST API を呼び出す必要があります。 GitHub の API トークンは下記のページで生成することができます。 GitHub - Personal access token Generate new token のボタンを押すと、新しいトークンを発行できます。 Select scope の項目で、そのトークンを使って使用できる機能 (API) の範囲を制御できるようになっているので、必要な機能のみにチェックを入れるようにしてください。 API トークンは次のようなハッシュ値です。 REST API を呼び出す際に必要になるので保存しておいてください。 c647c084ed5f60ee7fd53a22537fd6602ace4ced REST API を呼び出す REST API は単純な HTTP リクエストをベースに動作するため、Linux の curl コマンドなどを使って簡単に実行できます。 例: オープンな Pull Request の一覧を取得する (github-api.sh) #!/bin/bash GITHUB_TOKEN=9b671cc01a1d966f3a3d1dc3366867836aa19c5d GITHUB_BASEURL=https://api.github.com GITHUB_API=/repos/YourOrganization/YourProject/pulls?state=open curl -k -s -u :$GITHUB_TOKEN $GITHUB_BASEURL$GITHUB_API GITHUB_TOKEN 変数は自分で作成した API トークンに、GITHUB_API 変数は実行した API にそれぞれ置き換えて実行してください。 GITHUB_TOKEN \u0026hellip; API トークン GITHUB_API \u0026hellip; 実行したい REST API 上記のサンプルコードでは、指定した Organization あるいはユーザ（ここでは YourOrganization) の、指定したリポジトリ (ここでは YourProject) のうち、オープン状態 (state=open) になっている Pull リクエストの一覧を取得しています。 結果は JSON 形式で出力されますが、長いのでここでは省略します。 GITHUB_API 変数は、他にも下記のような感じで置き換えて実行できます。 詳細は GitHub REST API のサイトを参照してください。 /users/MyName \u0026hellip; 指定したユーザ (MyName) の詳細情報 /orgs/MyOrg/members \u0026hellip; 指定した Organization (MyOrg) 内のメンバーリスト ちなみに、上記の curl コマンド実行時に指定しているオプションの意味は下記の通りです。 -u USER:PASSWORD \u0026hellip; Server user, password and login options -k \u0026hellip; Allow connections to SSL sites without certs -s \u0026hellip; Silent mode. Don\u0026rsquo;t output anything プロキシ環境から curl 実行する場合 プロキシ環境内から実行する場合は、https_proxy 環境変数でプロキシサーバのアドレスとポート番号を設定してから実行してください。 $ export https_proxy=https://proxy.example.com:10080 $ ./github-api.sh プロキシは、curl コマンドの --proxy (-x) オプションで指定する方法もあります。 $ curl --proxy http://proxy.example.com:10080 https://www.google.com/ すべての結果が得られない場合 REST API の結果は、デフォルトでは ページネーション によって 30 件ずつ しか返されません。 一度にたくさんの結果を取得するには、URL の末尾に per_page オプションを指定することで 最大 100 件ずつ 取得することができます。 それ以上の件数を取得するときは、page オプションを使用して取得位置を切り替える必要があります。 GITHUB_API=/user/repos?per_page=100\u0026amp;page=1 # 1～100件目のリポジトリ情報 GITHUB_API=/user/repos?per_page=100\u0026amp;page=2 # 101～200件目のリポジトリ情報 GITHUB_API=/user/repos?per_page=100\u0026amp;page=3 # 201～300件目のリポジトリ情報 ページの切り替え処理 を自動化するのは若干面倒ですが、件数が多くても 500 件以下であることが分かっているのであれば、下記のように単純にループで取得してしまえば事足りるかもしれません。 GITHUB_API=/user/repos?per_page=100 # 100件の取得を5ページ分繰り返す for i in `seq 1 5`; do curl -k -s -u :$GITHUB_TOKEN $GITHUB_BASEURL$GITHUB_API\\\u0026amp;page=$i done （おまけ）Windows のバッチファイルで GitHub REST API を呼び出す Window 10 version 1803 (2018年4月) 以降には、デフォルトで curl コマンドがインストールされるようになったみたいです。 これで、Windows のバッチファイルからも気兼ねなく curl コマンドを使えます。 次の例では、バッチファイルから curl を使って、GitHub の REST API を呼び出すサンプルコードです。 例: members.bat（YourOrganization のメンバーリストを取得する） @echo off setlocal REM --------------- REM User settings REM --------------- set GITHUB_TOKEN=b72209e0b0ed0ad32d7b8cc38b36cf71b416d0a0 set GITHUB_API=/orgs/YourOrganization/members REM set GITHUB_API=/orgs/YourOrganization/repos REM set GITHUB_API=/user/repos REM set PROXY=-x http://proxy.example.com:10080 REM ----------------- REM Call GitHub API REM ----------------- set GITHUB_BASEURL=https://api.github.com FOR /L %%A IN (1, 1, 5) DO ( curl -k -s %PROXY% -u :%GITHUB_TOKEN% \u0026#34;%GITHUB_BASEURL%%GITHUB_API%?per_page=100\u0026amp;page=%%A\u0026#34; ) FOR ループでページネーションを切り替えながら 100 件ずつ取得することで、1～500 件目までの情報を表示しています。 プロキシ環境下で実行したい場合は、PROXY 変数の REM コメントアウトを外してください。 GITHUB_API 変数の部分を置き換えることで、取得する情報を切り替えることができます。 set GITHUB_API=/orgs/YourOrganization/members \u0026hellip; 組織のメンバーリスト set GITHUB_API=/orgs/YourOrganization/repos \u0026hellip; 組織のリポジトリリスト set GITHUB_API=/user/repos \u0026hellip; 自分のリポジトリリスト"},{url:"/p/jbi9ojq/",title:"Hugo で参照するデータファイルをショートコードのパラメータで切り替える",date:"2018-12-07T00:00:00Z",body:"Hugo で参照するデータファイルをショートコードのパラメータで切り替える 下記の記事では、data ディレクトリの基本的な使い方を説明しています。 全ページから参照できるデータを用意する（data ディレクトリ） ここではもう少し踏み込んで、ショートコードを使って、パラメータで指定した名前のデータファイルを読み込めるようにしてみます。 まず、サンプルデータとして下記のようなデータファイルを用意します。 ファミコンのゲームタイトルの一覧です。 data/games/nes.yaml （データファイル） - title: ドンキーコング date: 1983-07-15 maker: 任天堂 - title: ドンキーコングJR. date: 1983-07-15 maker: 任天堂 - title: ポパイ date: 1983-07-15 maker: 任天堂 次に、このデータファイルを使って、HTML の table として出力するショートコードを作成します。 layouts/shortcodes/games.html （ショートコード） \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;発売日\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;タイトル\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;メーカー\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {{- range .Site.Data.games.nes }} \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;{{ .date }}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{{ .title }}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{{ .maker }}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; {{- end }} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; コンテンツページから、次のように使用することができます。 content/ref/nes-games.md --- title: \u0026#34;ファミコンのゲームタイトル一覧\u0026#34; --- {{% games %}} 上記のショートコードは、data/games/nes.yaml という決まったデータファイルを読み込むようにしていますが、下記のようにすれば、パラメータで指定した YAML ファイルを読み込めるようになります。 こうすることで、例えば、スーパーファミコンのタイトルリストを別の YAML ファイルで作成しておき、同じショートコードを使ってテーブル出力できるようになります。 layouts/shortcodes/games.html （ショートコード） \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;発売日\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;タイトル\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;メーカー\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {{- range (index .Site.Data.games (.Get 0)) }} \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;{{ .date }}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{{ .title }}\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;{{ .maker }}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; {{- end }} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; .Get 0 という部分で、ショートコードに渡されたパラメータ（例えば nes）を取得しています。 この games ショートコードは下記のように使用します。 ショートコードのパラメータとして、nes、snes を指定することで、それぞれデータファイルとして nes.yaml、snes.yaml が使用されます。 content/ref/nes-games.md --- title: \u0026#34;ファミコンのゲームタイトル一覧\u0026#34; --- {{% games nes %}} content/ref/snes-games.md --- title: \u0026#34;スーパーファミコンのゲームタイトル一覧\u0026#34; --- {{% games snes %}}"},{url:"/p/3i3j2hx/",title:"Linux シェルスクリプト: expect で外部コマンドの出力を待機する",date:"2018-11-10T00:00:00Z",body:"Linux シェルスクリプト: expect で外部コマンドの出力を待機する expect コマンドを使用すると、任意のコマンドの出力を待ち受けて、自動でそれに応答するといったことを実現できます。 expect の基本的な使い方 Linux のコマンド expect がインストールされていない場合は、パッケージ管理ツール（apt や yum）を使用してインストールしてください（macOS には最初からインストールされています）。 まずは、簡単な例として、下記のような簡単なユーザ入力を必要とするスクリプトを自動で動作させてみます。 greet.sh #!/bin/bash echo -n \u0026#34;Enter your name: \u0026#34; read name echo \u0026#34;Hello, $name\u0026#34; これをそのまま実行すると、下記のようにユーザ入力の待ち受け状態となります。 $ ./greet.sh Enter your name: このような状態になったときに、自動的に入力を行うには、下記のように expect -c コマンドを使ったシェルスクリプトを作成します。 sample.sh #!/bin/bash expect -c \u0026#34; set timeout 3 spawn ./greet.sh expect \\\u0026#34;Enter your name:\\\u0026#34; send \\\u0026#34;Maku\\n\\\u0026#34; interact \u0026#34; expect -c の後ろのダブルクォートで囲まれた部分には、expect で実行するスクリプトを記述します。 この中でダブルクォートを使用したいときは、\\\u0026quot; のようにエスケープしなければいけないことに注意してください。 スクリプト中の各行は次のような意味を持っています。 set timeout 3 … 外部プログラムの実行を 3 秒待つ spawn ./greet.sh … 指定した外部プログラム (./greet.sh) を実行する expect \u0026#34;Enter your name:\u0026#34; … 外部プログラムの出力 (Enter your name:) を待つ send \u0026#34;Makun\u0026#34; … 外部プログラムに Maku と入力して、最後に Enter を入力する interact … 外部プログラムとのインタラクションへ戻る 上記のシェルスクリプトを実行すると、外部プログラム greet.sh の入力待ちに対して、自動的に Maku という入力を行います。 実行結果 $ ./sample.sh spawn ./greet.sh Enter your name: Maku Hello, Maku コマンドラインからのパスワード入力を自動化する あまりよくない例かもしれませんが、ssh や rsync コマンドなどのパスワード入力も同様に自動化することができます。 下記のスクリプトを実行すると、ssh コマンドがパスワード入力を求めてきたときに、自動でパスワードを入力してログイン処理が完了します。 例: ssh 接続時のパスワード入力を自動化 (autologin.sh) #!/bin/bash expect -c \u0026#34; set timeout 3 spawn ssh username@example.com expect \\\u0026#34;password:\\\u0026#34; send \\\u0026#34;x5sd6sfc\\n\\\u0026#34; interact \u0026#34; 実行結果 $ ./autologin.sh spawn ssh username@example.com username@examle.com\u0026#39;s password: Last login: Sat Nov 10 19:58:51 2018 from hogehoge.ap.example.jp username$ ログイン後に、何らかのコマンド（例えば ls -aFl）を実行するところまで自動化したいのであれば、下記のようにプロンプトの $ を待ち受けて次の入力を行えばよいでしょう。 #!/bin/bash expect -c \u0026#34; set timeout 3 spawn ssh username@example.com expect \\\u0026#34;password:\\\u0026#34; send \\\u0026#34;x5sd6sfc\\n\\\u0026#34; expect \\\u0026#34;$\\\u0026#34; send \\\u0026#34;ls -aFl\\n\\\u0026#34; interact \u0026#34; ちなみに、rsync コマンドでファイル転送するときも同様にパスワード入力を自動化できます。 #!/bin/bash expect -c \u0026#34; spawn rsync -r -h -v --delete public user@example.com:public expect \\\u0026#34;Password:\\\u0026#34; send \\\u0026#34;abcabcabc\\n\\\u0026#34; interact \u0026#34; ただし、このような使い方をすると、シェルスクリプトにパスワードをそのまま記述することになるので、ファイルの保存場所には十分に注意してください。 ここでは、プログラムの例としてパスワード入力を扱いましたが、SSH 接続を行うのであれば、通常は ~/.ssh/config ファイルによる SSH キー設定 を用いた方がよいでしょう。"},{url:"/p/7m6n4j2/",title:"Hugo で Markdown ファイルに本文が記述されていない場合だけ特別な出力をする",date:"2018-11-02T00:00:00Z",body:"Hugo で Markdown ファイルに本文が記述されていない場合だけ特別な出力をする 例えば、あるページの Markdown ファイルが下記のようにフロントマターだけの記述になっていると、 --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2018-11-02\u0026#34; --- テンプレートから Page 変数の {{ .Content }} を参照したときの値は空っぽ になります。 このような場合だけ別の出力をしたい場合は、下記のように場合分け処理を記述します。 layouts/_default/single.html（抜粋） {{ with .Content }} {{ . }} {{ else }} \u0026lt;b\u0026gt;本文が記述されていません。\u0026lt;/b\u0026gt; {{ end }} このような分岐出力は、セクションページ（_index.md）などで活用できると思います。 例えば、次のようにセクションテンプレートを記述しておけば、セクションページに本文が記述されている場合はその内容を表示し、本文が記述されていない場合はそのセクション直下のページリストを表示できます。 layouts/_default/section.html（抜粋） {{- with .Content }} {{ . }} {{- else }} \u0026lt;ul class=\u0026#34;pageList\u0026#34;\u0026gt; {{/* カレントセクション直下のセクション */}} {{- range .Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; /\u0026lt;/li\u0026gt; {{- end -}} {{/* カレントセクション直下の記事ページ */}} {{- range .RegularPages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} コンテンツファイルが下記のような構成で配置されているとすると、 content/ +-- mysection/ +-- _index.md +-- page1.md +-- page2.md +-- page3.md セクションページの mysection/_index.md の本文に何も書かなかった場合は、自動的にサブページ (page1, page2, page3) へのリンクが表示されます。 本文を記述した場合は、その本文だけが表示されるので、自力で子ページへのリンクを記述するようにします。"},{url:"/p/m3si4w6/",title:"Python で標準エラー出力へ出力する (sys.stderr)",date:"2018-10-14T00:00:00Z",body:"Python で標準エラー出力へ出力する (sys.stderr) 標準エラー出力への出力 Python の print の出力先を標準エラー出力 (STDERR) にするには、file オプションで sys.stderr を指定します。 標準エラー出力への出力 import sys # ... if not is_valid_config(): print(\u0026#34;Error: invalid configuration\u0026#34;, file=sys.stderr) sys.exit(1) ちなみに、file 引数には write メソッドを持っているオブジェクトを渡せるようになっています。 sys.stderr オブジェクトも write メソッドを持っているので、上記のように file 引数に渡すことができます。 上記の例では、標準エラーにメッセージ出力をして、さらに sys.exit(1) でプログラムをエラー終了させていますが、実はこの処理は、sys.exit 関数にエラーメッセージを渡すことで 1 行で記述できます。 標準エラーへ出力してエラー終了する sys.exit(\u0026#34;Error: invalid configuration\u0026#34;) コラム: Python2 までの方法 Python2 までは下記のように標準エラー出力に出力することができました。 古い Python2 のやり方 import sys print \u0026gt;\u0026gt; sys.stderr, \u0026#39;エラーメッセージ\u0026#39;"},{url:"/p/25gqyai/",title:"echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ",date:"2018-10-11T00:00:00Z",body:"echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ Linux の echo コマンドで文字列変数 $str の値を出力しようとして、下記のように実行すると、文字列に含まれている連続するスペースが 1 つのスペースにまとめられてしまいます。 sample.sh（間違った方法） #!/bin/bash str=\u0026#34;AAA BBB CCC\u0026#34; echo $str 実行結果 AAA BBB CCC これは、変数展開が行われることによってダブルクォートが取り除かれ、下記のように echo コマンドに 3 つのパラメータが渡されたものとして扱われるからです。 パラメータの区切りとして使われるスペースの数は関係なく、各パラメータ (AAA、BBB、CCC) が 1 つのスペースで結合されて出力されます。 $ echo AAA BBB CCC AAA BBB CCC スペースを含む文字列を 1 つの文字列として echo コマンドに渡すには、次のようにダブルクォートで囲む必要があります。 sample.sh（正しい方法） #!/bin/bash str=\u0026#34;AAA BBB CCC\u0026#34; echo \u0026#34;$str\u0026#34; 実行結果 AAA BBB CCC"},{url:"/p/usqqvps/",title:"HTML の画像要素 (img) を親要素の左右両端に表示する",date:"2018-09-26T00:00:00Z",body:"HTML の画像要素 (img) を親要素の左右両端に表示する HTML のある親要素の左右両端に画像などの子要素を配置する方法を紹介します。 Flex レイアウトを使って子要素を左右に配置する方法 （別ページで開く） Flex レイアウトの配置方法として justify-content: space-between を指定すると、「子要素を均等に配置し、最初のアイテムは先頭に寄せ、最後のアイテムは末尾に寄せる」という意味になります。 HTML \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;tree.png\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;tree.png\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; CSS .box { display: flex; justify-content: space-between; } position: abosolute 指定で子要素を左右に配置する方法 （別ページで開く） スタイルに position: absolute 指定を行うと、親要素の原点を基準に要素を配置することができます。 この指定に加えて、left: 0 とすれば左寄せ（デフォルト）、right: 0 とすれば右寄せで子要素を配置することができます（親要素の左端、右端に配置される）。 HTML \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;box_left\u0026#34; src=\u0026#34;tree.png\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;box_right\u0026#34; src=\u0026#34;tree.png\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; CSS .box { /* 子要素のタイトルを aboslute 配置するために必要 */ position: relative; } .box .box_left { position: absolute; left: 0; } .box .box_right { position: absolute; right: 0; } 応用例: ウェブサイトのヘッダ部分で使えそうな例 （別ページで開く） ここでは、両端に配置した画像の間にテキストを追加しています。 テキストに関しても同じ階層に position: absolute 配置し、中央寄せで表示しています。 このような構成にすることで、横幅が狭くなった場合に、画像の上にテキストが重なる形で表示されるようになります。 下記は CSS と HTML の抜粋ですが、ヘッダーの帯部分の高さに対して、上下方向にも中央寄せするようにしているため若干複雑になっています。 HTML \u0026lt;div class=\u0026#34;titleBox\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;titleBox_imageLeft\u0026#34; src=\u0026#34;tree.png\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;titleBox_imageRight\u0026#34; src=\u0026#34;tree.png\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;これはウェブサイトのタイトルです\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; CSS .titleBox { position: relative; /* 子要素の aboslute 配置用 */ height: 200px; background: #597380; } .titleBox \u0026gt; * { /* 子要素をすべて上下に中央寄せする */ position: absolute; top: 50%; transform: translateY(-50%); } .titleBox \u0026gt; .titleBox_imageLeft { left: 0; } .titleBox \u0026gt; .titleBox_imageRight { right: 0; } .titleBox \u0026gt; h1 { margin: 0; padding: 0; width: 100%; text-align: center; color: #eee; text-shadow: 2px 2px 3px black; }"},{url:"/web/",title:"HTML/CSS",date:"2018-09-26T00:00:00Z",body:"HTML/CSS HTML 全般 HTML ファイルの雛形（テンプレート） Web サイトに favicon を設定する 旧記事 IE 8 でも HTML5 の header や footer 要素を使えるようにする 全体のレイアウト レイアウトの基礎知識 CSS の position プロパティによるレイアウト方法を理解する CSS の box-sizing プロパティで width の計算方法を制御する CSS のふくろうセレクター (* + *) で全要素の上下マージンを設定する CSS で画像の下に隙間が空くのを防ぐ (vertical-align) HTML のリスト要素 (ul, ol, li) のマージン指定方法を理解する CSS のフローティングボックス (float) を利用したレイアウトを理解する HTML 要素を中央寄せ／右寄せで表示する HTML の画像要素 (img) を親要素の左右両端に表示する レスポンシブ Viewport とメディアクエリによるレスポンシブ Web デザインの基本 モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし） CSS で画像と埋め込み動画のサイズを画面内に収める (max-width) CSS のフレキシブルボックスによるレスポンシブレイアウト 旧記事 （旧）フレキシブルボックスの旧式の定義方法 （旧）CSS で画面サイズによって全体のレイアウトを変更する フォント／テキスト フォントサイズは 100% と指定する CSS の rem や em を使用したサイズ指定を理解する pre 要素でもテキストがはみ出さないように折り返す 要素 フォーム 入力フォームに自動的にフォーカスする（autofocus 属性） プレースホルダーで入力フォームに補足説明を表示する（placeholder 属性） 入力必須の入力フォームを指定する（required 属性） 独自の入力フォーマットを指定する（pattern 属性） 入力エリアの入力候補を表示する（autocomplete 属性、datalist 要素） ヘッダ ヘッダ要素に連番を振る メニュー メニューの縦並びと横並びを切り替える メニューの表示位置を固定する メニューの高さを画面の高さに合わせる メニュー要素内でスクロールできるようにする CSS だけで開閉できるアコーディオンメニューを作成する ある位置までスクロールしたら固定されるメニューを作成する 印刷時に特定の要素（メニューなど）を非表示にする リンク 外部リンクに自動的にアイコンを付けて表示する (External link icons) 外部リンクをクリックしたときに必ず新しいタブで開く リンク先ファイルの拡張子によって自動的にアイコンを付けて表示する 画像／ボタン SVG アイコンの色をまわりの文字の色に合わせる SNS ボタンをきれいに並べる CSS セレクタ 結合子を使用して構造に応じてスタイルシートを適用する 子孫セレクタ 子セレクタ（直下セレクタ） 隣接兄弟セレクタ（隣接セレクタ） 一般兄弟セレクタ（間接セレクタ） マルチメディア audio タグを使って音声ファイルを再生する その他 吹き出し風の見出しを作る Web サイト作成に関するメモ: SEO 対策 jQuery に関しては JavaScript のページを参照 外部サイトリンク HTML5の仕様 (W3C Recommendation) HTML5の文法チェック (W3C Markup Varidation Service) ブラウザのHTML5適合度チェック (HTML5test)"},{url:"/p/bf2nban/",title:"GitHub Pages で独自の 404 ページを用意する",date:"2018-09-12T00:00:00Z",body:"GitHub Pages で独自の 404 ページを用意する GitHub Pages で存在しないページにアクセスすると、デフォルトでは GitHub が用意している 404 ページが表示されます。 Web サイトのルートパスに 404.html ファイルを配置すると、独自の 404 ページを表示することができます。 ここでは、Jekyll のページ生成の仕組みを使って、独自の 404 ページを作成する方法を説明します。 図: GitHub Pages で独自の 404 ページを表示した例 コンテンツファイル (404.md) の作成 まず、プロジェクトのルートディレクトリに 404.md を作成し、404.html というページが出力されるようにします。 404.md --- title: \u0026#34;404\u0026#34; layout: \u0026#34;404\u0026#34; permalink: \u0026#34;404.html\u0026#34; --- 表示内容に関しては、404 ページ専用のレイアウト (_layouts/404.html) の方で定義することにします。 よって、上記の Markdown ファイルでは、フロントマターで出力設定だけを記述しておきます。 レイアウトファイル (_layouts/404.html) の作成 404 ページの出力内容は特有のレイアウトになることが多いので、専用のレイアウトファイルで作成するのがオススメです。 ここでは、_layouts/404.html というパスにファイルを作成します（404.md のフロントマターで指定したレイアウト名に合わせてください）。 _layouts/404.html の記述例 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;{{ page.title }} | {{ site.name }}\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;{{ page.title }} | {{ site.name }}\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; sizes=\u0026#34;16x16 32x32 48x48 64x64\u0026#34; href=\u0026#34;/assets/img/favicon/favicon.ico\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon-precomposed\u0026#34; href=\u0026#34;/assets/img/favicon/favicon-152.png\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; body { background: #eee; margin: 1em auto; text-align: center; } .content { width: 500px; margin: 0 auto; } h1 { font-size: 3rem; margin: 1em 0; } a { color: #36f; font-weight: bolder; text-decoration: none; } a:hover { color: white; background: #36f; } img { width: 100px; vertical-align: bottom; } \u0026lt;/style\u0026gt; {% if jekyll.environment != \u0026#34;development\u0026#34; %} {% include analytics.html %} {% endif %} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ page.title }}\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;p\u0026gt;ページが見つかりませんでした。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;{{ site.url }}\u0026#34;\u0026gt;{{ site.name }}のトップページ\u0026lt;/a\u0026gt;へ移動するか、\u0026lt;br\u0026gt; 下記から検索してみてください。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{% include search-bar.html %}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;{{ site.url }}\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;{{ site.logo }}\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上記の例では、Google Analytics 用のコード (_includes/analytics.html) も挿入するようにしています。 こうしておけば、404 ページへのアクセスも解析できるようになるので便利です。 Google Analytics を使用していないのであれば外してください。 また、404 ページからトップページへ飛ばすだけでは不親切なので、Google カスタム検索のためのフォーム (_includes/search-bar.html) も配置するようにしています。 このあたりは適宜調整してください。 上記のレイアウトファイルでは、site 変数を使ってサイト名 (site.name) やロゴファイル名 (site.logo) を取得しているので、_config.yml の中で下記のような感じで設定しておいてください。 _config.yml name: 天才まくまくノート url: https://maku77.github.io logo: /assets/img/logo.jpg あとは、作成した 404.md と _layouts/404.html を GitHub 上のリポジトリにプッシュすれば完成です。 参考サイト Creating a custom 404 page for your GitHub Pages site - User Documentation"},{url:"/p/p4n5m3i/",title:"Hugo に全文検索（インクリメンタルサーチ）の機能を付ける",date:"2018-09-11T00:00:00Z",body:"Hugo に全文検索（インクリメンタルサーチ）の機能を付ける ここでは、Hugo サイトに全文検索の機能を付ける方法を説明します。 全文検索を実現する方法としては、Google カスタム検索を導入する方法もありますが、Google カスタム検索は、インターネット上に公開する Web サイトにしか適用できません。 ここで紹介する JavaScript を利用した全文検索は、ローカルで運用する Web サイトでも利用できますし、インクリメンタルサーチも実現することができます（実際のサイトの例）。 図: 全文検索＋インクリメンタルサーチの完成イメージ 大まかに、下記のようなコードを含む HTML ファイルを出力できれば、サイト内の全文検索を実現することができます。 検索用 JavaScript データ (const data = [...]) 検索用 HTML フォーム (\u0026lt;input\u0026gt;) 検索用 JavaScript 関数 (function search() {...}) ここでは、全文検索のためのページとして search という名前のページ (content/search.md) を作成することにします（URL としては http://localhost:1313/search/ という形でアクセスすることになります）。 すでに search という名前のページを作成している場合は適宜変更してください。 ☝️ 2023-05-04 追記 以前の実装では、検索用データ (search/data.js) と検索用ページ (search/index.html) を分けて出力していましたが、検索用ページに統合するように変更しました。 Hugo がバージョンアップして、出力ファイルに livereload 用の script タグを自動挿入するようになり、正しい data.js ファイルとして出力できなくなってしまったからです。 コンテンツファイル (content/search.md) の作成 まず、全文検索用のページを出力するためのコンテンツファイルを作成しておきます。 content/search.md --- title: \u0026#34;サイト内全文検索\u0026#34; layout: search _build: { list: never } --- フロントマターの layout プロパティで search という名前のテンプレートを使うことを指定しておきます。 ついでに、_build プロパティで、このページをリスト系ページの一覧に列挙しないようにしておきます（参考: 記事一覧に列挙されないページを作る）。 本文はすべてテンプレート側で出力するので、Markdown ファイルには上記のようにフロントマターだけ記述しておけば OK です。 テンプレートファイル (layouts/_default/search.html) の作成 検索用 JavaScript データの出力 全ページの本文を JavaScript から検索できるようするために、検索用のデータ（インデックス）を作成します。 ここでは、HTML ファイルの \u0026lt;script\u0026gt; 要素内に、次のようなフォーマットで data 変数を出力することにします。 const data = [ { url:\u0026#34;ページURL1\u0026#34;, title:\u0026#34;タイトル1\u0026#34;, body:\u0026#34;本文1…\u0026#34; }, { url:\u0026#34;ページURL2\u0026#34;, title:\u0026#34;タイトル2\u0026#34;, body:\u0026#34;本文2…\u0026#34; }, { url:\u0026#34;ページURL3\u0026#34;, title:\u0026#34;タイトル3\u0026#34;, body:\u0026#34;本文3…\u0026#34; }, ... ]; data 変数は、各ページの情報を配列として保持しています。 ユーザーが検索キーワードを入力したときに、この変数内の body プロパティの内容を検索するように実装します。 テンプレートファイル内で次のように実装しておけば、全ページの情報を含む data 変数のコードを出力することができます。 layouts/_default/search.html（途中経過） {{- /* エスケープ処理（改行を空白化、前後の空白削除、連続する空白を集約） */}} {{- define \u0026#34;escape\u0026#34; }} {{- trim (replace . \u0026#34;\\n\u0026#34; \u0026#34; \u0026#34;) \u0026#34; \u0026#34; | replaceRE \u0026#34; +\u0026#34; \u0026#34; \u0026#34; -}} {{- end }} \u0026lt;script\u0026gt; // 検索用のインデックスデータ const data = [ {{- range $index, $page := .Site.Pages }} { url: {{ $page.RelPermalink }}, title: {{ $page.Title }}, date: {{ $page.Date }}, body: {{ template \u0026#34;escape\u0026#34; (printf \u0026#34;%s %s\u0026#34; $page.Title $page.Plain) }} }, {{- end }} ]; \u0026lt;/script\u0026gt; 本文内の連続するスペースの集約や、改行文字の削除を行うために、escape という部分テンプレートを定義しています（define で定義し、template で呼び出しています）。 タグの一覧ページ（.Kind = taxonomy) や、タグの付いた記事の一覧ページ (.Kind = term) を検索対象にしたくないときは、上記の .Pages の range ループの中に次のような if - end 条件分岐を追加すればフィルタできます。 {{- if not (or (eq $page.Kind \u0026#34;taxonomy\u0026#34;) (eq $page.Kind \u0026#34;term\u0026#34;)) }} { ... }, {{- end }} ここまでできたら、hugo serve でローカルサーバーを起動して http://localhost:1313/search/ にアクセスして、出力されたファイルの内容を確かめてみるとよいでしょう。 ただし、この時点ではブラウザ上での表示は空っぽです。 data 変数は \u0026lt;script\u0026gt; 要素内に出力されているため、その内容を確認するためには、ブラウザ上で右クリックして「ページのソースを表示」などから確認する必要があります。 検索用 HTML フォームと JavaScript 関数の出力 あとは、全体の UI として、ユーザーがキーワードを入力するための \u0026lt;input\u0026gt; 要素などを配置し、そのキーワードで data 配列の内容を検索するための JavaScript 関数 (search) などを追加します。 スタイルシート (CSS) まで含んでいるので若干長いですが、やっていることは単純で、キーワードを含むページを見つけてその概要を出力しているだけです。 layouts/_default/search.html（完成版） {{- /* エスケープ処理（改行を空白化、前後の空白削除、連続する空白を集約） */}} {{- define \u0026#34;escape\u0026#34; }} {{- trim (replace . \u0026#34;\\n\u0026#34; \u0026#34; \u0026#34;) \u0026#34; \u0026#34; | replaceRE \u0026#34; +\u0026#34; \u0026#34; \u0026#34; -}} {{- end }} \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;{{ .Page.Title }} | {{ .Site.Title }}\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background: #fafafa; } input { color: deeppink; font-size: 1.2em; font-weight: bolder; } input::-webkit-input-placeholder { color: pink; } #result { margin: 1em; } .item_title { text-decoration: none; color: #36f; font-weight: bolder; } .item_excerpt { background: white; margin: 0.5em 2em 1em; padding: 0.5em; border: dashed 1px lightgray; font-size: smaller; } .item_excerpt b { background: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Page.Title }}\u0026lt;/h1\u0026gt; \u0026lt;input onkeyup=\u0026#34;search(this.value)\u0026#34; size=\u0026#34;15\u0026#34; autocomplete=\u0026#34;off\u0026#34; autofocus placeholder=\u0026#34;検索ワード\u0026#34; /\u0026gt; \u0026lt;span id=\u0026#34;inputWord\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;resultCount\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div id=\u0026#34;result\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 検索用のインデックスデータ const data = [ {{- range $index, $page := .Site.Pages }} {{- if not (or (eq $page.Kind \u0026#34;taxonomy\u0026#34;) (eq $page.Kind \u0026#34;term\u0026#34;)) }} { url: {{ $page.RelPermalink }}, title: {{ $page.Title }}, date: {{ $page.Date }}, body: {{ template \u0026#34;escape\u0026#34; (printf \u0026#34;%s %s\u0026#34; $page.Title $page.Plain) }} }, {{- end }} {{- end }} ]; function search(query) { const result = searchData(query); const html = createHtml(result); showResult(html); showResultCount(result.length, data.length); } function searchData(query) { // 検索にヒットした情報を下記のような配列として格納していく // [データのインデックス, 文字の開始位置, 文字の終了位置] const result = []; query = query.trim(); if (query.length \u0026lt; 1) { return result; } const re = new RegExp(query, \u0026#39;i\u0026#39;); for (let i = 0; i \u0026lt; data.length; ++i) { const pos = data[i].body.search(re); if (pos != -1) { result.push([i, pos, pos + query.length]); } } return result; } function createHtml(result) { const htmls = []; for (let i = 0; i \u0026lt; result.length; ++i) { const dataIndex = result[i][0]; const startPos = result[i][1]; const endPos = result[i][2]; const url = data[dataIndex].url; const title = data[dataIndex].title; const body = data[dataIndex].body; htmls.push(createEntry(url, title, body, startPos, endPos)); } return htmls.join(\u0026#39;\u0026#39;); } function createEntry(url, title, body, startPos, endPos) { return \u0026#39;\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026#39; + \u0026#39;\u0026lt;a class=\u0026#34;item_title\u0026#34; href=\u0026#34;\u0026#39; + url + \u0026#39;\u0026#34;\u0026gt;\u0026#39; + title + \u0026#39;\u0026lt;/a\u0026gt;\u0026#39; + \u0026#39;\u0026lt;div class=\u0026#34;item_excerpt\u0026#34;\u0026gt;\u0026#39; + excerpt(body, startPos, endPos) + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; } function excerpt(body, startPos, endPos) { return [ body.substring(startPos - 30, startPos), \u0026#39;\u0026lt;b\u0026gt;\u0026#39;, body.substring(startPos, endPos), \u0026#39;\u0026lt;/b\u0026gt;\u0026#39;, body.substring(endPos, endPos + 200) ].join(\u0026#39;\u0026#39;); } function showResult(html) { const el = document.getElementById(\u0026#39;result\u0026#39;); el.innerHTML = html; } function showResultCount(count, total) { const el = document.getElementById(\u0026#39;resultCount\u0026#39;); el.innerHTML = \u0026#39;\u0026lt;b\u0026gt;\u0026#39; + count + \u0026#39;\u0026lt;/b\u0026gt; 件見つかりました（\u0026#39; + total + \u0026#39;件中）\u0026#39;; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; これで、http://localhost:1313/search/ といった URL にアクセスすれば、全文検索のページが表示されるようになります。 （応用）URL のハッシュフラグメントに検索ワードを入れる やりたいこと ハッシュフラグメントとは、次のような、URL の末尾についた # 以降の文字列のことです。 http://localhost:1313/search/#検索ワード ここでは、ハッシュフラグメントに設定された検索ワードを使って全文検索を実行するようにしてみます。 コードは複雑になりますが、このような仕組みにすることで、 検索結果のページにリンクを張れるようになる 検索結果のページをブックマークできるようになる といった利点があります（正確には検索結果のページにリンクを張るわけではなく、ページを開いてから検索を実行します）。 全文検索のページのコードを修正 元のコードでは、input 要素の onkeyup 属性を使って search() 関数を呼び出すようにしていましたが、次のように、入力した値を URL のハッシュフラグメントにセットするように変更します（2021-06 追記: location.hash=this.value としてましたが、これだとキー入力のたびに履歴に追加されてしまうので、location.replace() を使うように変更しました）。 \u0026lt;input id=\u0026#34;query\u0026#34; onkeyup=\u0026#34;location.replace(\u0026#39;#\u0026#39; + this.value)\u0026#34; size=\u0026#34;15\u0026#34; autocomplete=\u0026#34;off\u0026#34; autofocus placeholder=\u0026#34;検索ワード\u0026#34; /\u0026gt; これにより、ユーザーが検索ワードを入力するたびに、ブラウザの URL 欄のハッシュフラグメントにその値が反映されるようになります。 次に、ページの表示時 (DOMContentLoaded) と、ハッシュフラグメントの変更時 (hashchange) に、ハッシュフラグメントの値を使って search() 関数を呼び出すようにします。 // ハッシュフラグメントの値で検索を実行 function searchWithHash() { const hash = decodeURI(location.hash.substring(1)); search(hash); // 必要があれば input 要素の値を更新 const queryElem = document.getElementById(\u0026#39;query\u0026#39;); if (queryElem.value !== hash) { queryElem.value = hash; } } // ハッシュフラグメント付きの URL でページを開いたときに検索 window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, searchWithHash); // ページ表示後にハッシュフラグメントが変化したら検索 window.addEventListener(\u0026#39;hashchange\u0026#39;, searchWithHash); これで、ハッシュフラグメント経由での全文検索を実行できるようになります。 検索ワード付きの URL をブラウザで開いたときには、その検索ワードを使って即全文検索が実行されるようになり、その検索ワードが input 要素に表示されます。 ページ表示後にユーザーが input 要素のテキストを変更すれば、URL のハッシュフラグメントに反映され、その値で再度検索が実行されます。 他のページに検索ボックスを配置する 次のような検索フォームを任意のページに配置しておけば、そこから検索ワードを入力して全文検索のページにジャンプできるようになります。 \u0026lt;form\u0026gt; \u0026lt;input id=\u0026#34;searchKeyword\u0026#34; type=\u0026#34;search\u0026#34; size=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;searchButton\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;検索\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; const SEARCH_URL = \u0026#39;/search/\u0026#39;; window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { const searchButton = document.getElementById(\u0026#39;searchButton\u0026#39;); const searchKeyword = document.getElementById(\u0026#39;searchKeyword\u0026#39;); // 検索ボタンのクリックで検索ページへジャンプ searchButton.addEventListener(\u0026#39;click\u0026#39;, e =\u0026gt; { e.preventDefault(); // Prevent default form\u0026#39;s behavior const query = searchKeyword.value; const url = query ? SEARCH_URL + \u0026#39;#\u0026#39; + query : SEARCH_URL; location.href = url; }); }); \u0026lt;/script\u0026gt; form 要素のデフォルトアクションではハッシュフラグメントに検索ワードを付加できないので、検索ボタンの click イベントをハンドルし、自力でハッシュフラグメントをセットした上でページ遷移を行うようにしています。 参考 URL 内のハッシュフラグメントの値を扱う (hashchange, location.hash) ｜ まくまくJavaScriptノート Hugo で Google カスタム検索を設置して記事を検索できるようにする"},{url:"/p/tvuztbm/",title:"JavaScript で文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec)",date:"2018-09-11T00:00:00Z",body:"JavaScript で文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec) JavaScript の String オブジェクトの中で正規表現を利用できるメソッドとしては、search()、replace()、split() などがありますが、中でも強力なのは match() メソッドです。 String#match(regexp) メソッドを使用すると、指定した正規表現パターンに一致する部分を配列オブジェクトとして取得することができます。 一致する部分がひとつも見つからない場合は null を返します。 match メソッドは、パラメータとして渡す正規表現パターンで g フラグを指定した場合と指定しない場合で振る舞いが変化します。 match の正規表現パターンに g フラグを指定したとき String#match(regexp) の正規表現パターンで、g フラグを付加すると、戻り値はパターンに一致した部分文字列の配列 になります。 例: 数値部分だけを抽出して配列で取得する const text = \u0026#39;ABC 123 DEF 456 GHI 789 123ABC\u0026#39;; const arr = text.match(/\\b\\d+\\b/g); if (arr != null) { console.log(arr); //=\u0026gt; [ \u0026#39;123\u0026#39;, \u0026#39;456\u0026#39;, \u0026#39;789\u0026#39; ] } match の正規表現パターンに g フラグを指定しなかったとき String#match(regexp) の正規表現パターンで g フラグを付加しない場合、RegExp#exec(string) を単発で呼び出した場合と同様の振る舞い をします。 具体的には、戻り値の配列の先頭には、パターンに一致した部分の全体が格納され、残りの配列要素（インデックス 1 以降）には、( と ) でグルーピングされたパターンに一致した部分文字列が順番に格納されます。 これを利用すると、特定のフォーマットに従った文字列から各パートの文字列を抽出するということが簡単に実現できます。 URL 形式の文字列から、プロトコル、ホスト、パスを抽出 const re = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)/; const text = \u0026#39;Visit my website at https://maku77.github.io/js\u0026#39;; const matches = text.match(re); if (matches != null) { const url = matches[0]; //=\u0026gt; \u0026#39;https://maku77.github.io/js\u0026#39; const protocol = matches[1]; //=\u0026gt; \u0026#39;https\u0026#39; const host = matches[2]; //=\u0026gt; \u0026#39;maku77.github.io\u0026#39; const path = matches[3]; //=\u0026gt; \u0026#39;js\u0026#39; } 実は、match メソッドの戻り値として返されるオブジェクトには、index プロパティと input プロパティも含まれています。 これらには、正規表現に（最初に）一致した位置と、入力として使ったテキスト全体が含まれています。 下記は、match メソッドの戻り値を console.log(matches) で出力した結果です。 [ \u0026#39;https://maku77.github.io/js\u0026#39;, \u0026#39;https\u0026#39;, \u0026#39;maku77.github.io\u0026#39;, \u0026#39;js\u0026#39;, index: 20, input: \u0026#39;Visit my website at https://maku77.github.io/js\u0026#39; ] index プロパティの値が 20 ということは、検索された URL が 20 の位置から始まっていることを示しています。 input プロパティには、検索対象となったテキストへの参照が含まれているのがわかります。 String#match(regexp) を使用したこのようなパターン抽出は非常に便利ですが、1つのテキスト内に一致する部分が複数含まれているような場合にはうまく抽出できないことに注意してください。 なぜなら、String#match(regexp) は、最初に見つかった部分の結果だけを抽出して返すからです（String#search() が最初に見つかった部分の位置を返すのと同様です）。 先に述べたように、正規表現パターンに g フラグを付けて検索すれば、パターンに一致する文字列をまとめて配列として取得できますが、ここで説明したような特定のフォーマットに一致する文字列の各パート（( と ) でグルーピングした部分）を抽出するということはできません。 この問題を解決するには、次に説明する正規表現オブジェクトの RegExp#exec() メソッドを使用する必要があります。 RegExp オブジェクトを使用したパターン抽出（最強！） String#match(regexp)（正規表現の g フラグなし）のような特定のフォーマットに従った部分文字列の抽出を、1 つの検索対象テキストの中で繰り返し実行（グローバル検索）したい場合は、RegExp#exec(string) メソッドを使用する必要があります。 両者の使用方法はほぼ同様ですが、呼び出しの関係が下記のように入れ替わることに注意してください。 正規表現オブジェクト.exec(検索対象テキスト) ここでは、下記のような検索対象テキストの中から、URL のホスト名、パス部分を繰り返し抽出するようなケースを考えてみます（2 つの URL からそれぞれホスト名とパスを抽出します）。 Visit my website at https://example.com/file1 and https://example.co.jp/file2 RegExp#exe(string) の戻り値は、String#match(regexp) の（g オプションなしで呼び出した場合の）戻り値と同様の配列で、最初の要素としてパターンに一致した部分の全体が格納され、残りの配列要素（インデックス1以降）には、( と ) でグルーピングされたパターンに一致した部分文字列が順番に格納されます。 検索パターンに一致する文字列が見つからなかった場合は、null を返します。 String#match(regexp) と異なるのは、RegExp#exec(string) は検索結果を返す度に、自分自身の lastIndex プロパティを更新し、次の検索はその位置から検索を始めるという点です。 この仕組みにより、繰り返し exec メソッドを呼び出すことでパターンに一致する部分をすべて検索することが可能になっています。 const re = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)/g; // gフラグを忘れない！ const text = `Visit my website at https://example.com/file1 and https://example.co.jp/file2`; let matches; while ((matches = re.exec(text)) != null) { const protocol = matches[1]; const host = matches[2]; const path = matches[3]; console.log(\u0026#39;host = \u0026#39; + host); console.log(\u0026#39;path = \u0026#39; + path); console.log(\u0026#39;lastIndex = \u0026#39; + re.lastIndex); console.log(\u0026#39;----------------\u0026#39;); } 実行結果 host = example.com path = file1 lastIndex = 45 ---------------- host = example.co.jp path = file2 lastIndex = 77 ---------------- 検索結果が返される度に、次の検索開始位置を示す RegExp#lastIndex の値が更新されていることに注目してください。 このように、1 つの検索対象テキストに対して複数回の検索を実行する場合は、必ず 正規表現の g フラグ（グローバル検索）を ON にしておく 必要があります。 これを忘れると、RegExp#exec() メソッドを実行したときに、RegExp オブジェクトの lastIndex プロパティが更新されず、毎回先頭からの検索になっていまいます（結果的に上記のような while ループは無限ループになってしまう）。 ☝️ ワンポイント RegExp#exec() による検索が最後まで進むと（戻り値で null が返されるまで実行されると）、lastIndex の値は自動的に 0 にリセットされます。 そのため、通常は複数の検索対象テキストに対して、同じ RegExp オブジェクトを使って検索を続けることができます。 ただし、検索を途中で中断して別のテキストを検索したい場合は、明示的に lastIndex の値を 0 にリセットする必要があります。 RegExp#exec() メソッドの振る舞いは若干ややこしいところがありますが、これを使いこなせるようになれば、正規表現を利用した文字列抽出のタスクはほとんどカバーできるようになります。"},{url:"/p/p5nx3n9/",title:"JavaScript で文字列の中から文字列を検索する (String#search, RegExp#test)",date:"2018-09-11T00:00:00Z",body:"JavaScript で文字列の中から文字列を検索する (String#search, RegExp#test) String#search による文字列検索 search の基本 String#search() メソッドを使用すると、正規表現パターンを使用して String オブジェクト内の文字列を検索することができます。 文字列が見つかった場合は、その先頭のインデックスを返し、見つからなかった場合は -1 を返します。 パラメータには RegExp オブジェクトを指定するか、次のように正規表現リテラルで検索パターンを指定します（単純な文字列を渡した場合は、内部で RegExp オブジェクトが生成されます）。 例: text の中から leader という文字列を検索 const text = \u0026#34;A leader is a dealer in hope.\u0026#34;; const index = text.search(/leader/); if (index == -1) { console.log(\u0026#34;見つかりませんでした\u0026#34;); } else { console.log(`位置 ${index} に見つかりました`); } 実行結果 位置 2 に見つかりました。 大文字と小文字を区別しない検索 String#search() メソッドのパラメータとして渡す正規表現の属性として i を指定すると、大文字と小文字を区別しない検索を行えます。 const index = text.search(/javascript/i); 上記のようにすると、JavaScript にも javascript にも JAVASCRIPT にも一致します。 コラム: グローバル検索はない String#search() メソッドは、最初に見つかった文字列のインデックスを返すため、次のように正規表現属性の g（グローバル検索）を指定しても無視されます（意味がありません）。 検索時は正規表現の g 属性は無視される var text = \u0026#34;Pen pineapple apple pen\u0026#34;; var index = text.search(/apple/g); console.log(index); //=\u0026gt; 8 上記の例では、テキスト内に apple という文字列は 2 か所（8と14）見つかりますが、返されるインデックスは最初に見つかった文字列のインデックス 8 のみです。 RegExp#test による文字列検索 正規表現オブジェクトの RegExp#test(string) メソッドを使っても、String#search(regexp) と同様に文字列検索を行うことができます。 ただし、こちらの場合は、見つかった位置を返すのではなく、単純に見つかったかどうかを示す真偽値 (true/false) を返します。 const re = /java/i; console.log(re.test(\u0026#39;Javascript is not Java\u0026#39;)); //=\u0026gt; true console.log(re.test(\u0026#39;Python is cool\u0026#39;)); //=\u0026gt; false console.log(re.test(\u0026#39;Ruby is fantastic\u0026#39;)); //=\u0026gt; false ユーザ入力を使った検索 ユーザが入力したテキストなど、文字列変数に格納された値を使って正規表現オブジェクトを作成するには、RegExp コンストラクタを使用します。 RegExp コンストラクタの第 2 引数では、正規表現属性（g、i、gi などのフラグ）を指定することができます。 // ユーザの入力したテキストが input 変数に格納されていると仮定 // const input = \u0026#34;Java\u0026#34;; var re = new RegExp(input, \u0026#34;i\u0026#34;); if (re.test(\u0026#34;Javascript is not Java\u0026#34;)) { console.log(\u0026#34;見つけたっ\u0026#34;); }"},{url:"/p/k7jv7hs/",title:"Hugo で Sass (SASS/SCSS) スタイルシートを使用する",date:"2018-08-16T00:00:00Z",body:"Hugo で Sass (SASS/SCSS) スタイルシートを使用する Hugo 0.46 で Sass (SASS/SCSS) がサポートされました。 これを使うと、スタイルシートを効率的に記述できるようになります。\u0026quot; Sass とは Sass (SASS/SCSS) は CSS のプリプロセッサで、これを利用すると、柔軟な変数の仕組みや、入れ子構造を用いたスタイルシート記述が可能になります。 Sass: Syntactically Awesome Style Sheets Sass の記述フォーマットとしては、古い SASS 記法（拡張子 .sass）と、新しい SCSS 記法（拡張子 .scss）がありますが、現在は CSS のフォーマットと互換性のある SCSS 記法が主流になっています。 最新の CSS では、ネイティブに変数の仕組みなどをサポートしていますが、ブラウザの対応状況もまだまだなので、しばらくは Sass が使われ続けるでしょう。 Hugo で Sass を使用する Hugo で Sass を使用する方法は、下記の本家ドキュメントに記述されています。 Hugo Pipes ＞ SASS/SCSS Hugo Pipes ＞ Hugo Pipes Introduction 大まかな手順は次の通りです。 ルートの assets ディレクトリ以下に .scss ファイルを配置する。 テンプレート内でパイプコマンドを利用して .scss ファイルを .css に変換し、変換後の .css ファイル名を link 要素で指定する。 1. assets ディレクトリに .scss ファイルを配置する 本家のドキュメントでは、resources.Get 関数を使って .scss ファイルを読み込む方法が紹介されています。 デフォルトの設定では、この関数はプロジェクトのルートにある assets ディレクトリ以下のファイルを検索するようになっています。 ここでは、assets ディレクトリ以下に sass ディレクトリを作成し、その中に .scss ファイルを格納していくことにしましょう。 main.scss ファイルの中から _color.scss ファイルの内容をインポートするようにしています。 assets/sass/main.scss @import \u0026#34;color.scss\u0026#34;; body { background: $BASE_COLOR; } assets/sass/_color.scss $BASE_COLOR: #f3f3f3; 2. テンプレート内で .scss ファイルを .css に変換し、link 要素で指定する これも本家のドキュメントに記載されている通りです。 head 要素を出力するテンプレート（ここでは baseof テンプレート）の中に下記のように記述します。 layouts/_default/baseof.html（抜粋） {{ $style := resources.Get \u0026#34;sass/main.scss\u0026#34; | toCSS | minify | fingerprint }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ $style.Permalink }}\u0026#34;\u0026gt; resources.Get で読み込んだ SCSS をパイプでいくつかの関数に渡していますが、最低限必要なのは toCSS による変換処理です。 その後ろに続く minify は CSS のコード圧縮、fingerprint は SCSS の変更が反映されないことを防ぐ（ファイル名に毎回違うサフィックスを付加してキャッシュが使用されるのを防ぐ）ための処理です。 これで、Hugo で Sass (SASS/SCSS) を使えるようになります。 あとは、main.scss ファイルの内容を更新すれば、自動的に CSS に変換されて反映されるようになります。"},{url:"/p/dsfzi4n/",title:"Hugo のページ内に Tex 形式の数式を埋め込めるようにする (MathJax)",date:"2018-06-21T00:00:00Z",body:"Hugo のページ内に Tex 形式の数式を埋め込めるようにする (MathJax) Hugo のテンプレートで MathJax という Javascript ライブラリを組み込むと、Markdown 記事内に Tex 形式で数式を埋め込むことができるようになります。 下記は、MathJax による数式表示の例です。 $$ -b\\pm \\sqrt{b^2 -4ac} \\over 2a $$ 図: MathJax による数式表示 MathJax を有効にする MathJax を有効にするのは簡単で、HTML 内で MathJax の Javascript ファイルを読み込むだけです。 次の例では、Hugo の ベーステンプレート (baseof.html) の head 要素内に、MathJax を読み込むための script 要素を追加しています。 layouts/_default/baseof.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html{{ with .Site.LanguageCode }} lang=\u0026#34;{{ . }}\u0026#34;{{ end }}\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; ... \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上記の例では、配信元の CDN として cdn.jsdeliver.net を指定していますが、他の CDN で配信されているものを使用することもできます。 詳しくは下記の MathJax のドキュメントを参照してください。 参考: Getting Started with MathJax Components 数式の記述例 ブロック形式 (displayed mathematics) ブロック形式（独立した段落）の数式を表示するには、Markdown ファイル内に $$ で囲む形で TeX を記述します（あるいは \\\\[ と \\\\] で囲みます）。 次の例では、Sum 記号（Σ）や分数を表示しています。 Markdown 内での記述例 $$ F(x) = \\sum_{n=1}^{N} \\frac{1}{N} $$ $$ F(x) = \\sum_{n=1}^{N} \\frac{1}{N} $$ 図: 出力結果 インライン形式 (in-line mathematics) 文章内にインライン形式で数式を埋め込むには、\\\\( と \\\\) で TeX 命令を囲みます。 Markdown 内での記述例 次の数式は \\\\(F(x) = \\sum_{n=1}^{N} \\frac{1}{N}\\\\) 文章内に埋め込まれます。 表示結果: 次の数式は \\(F(x) = \\sum_{n=1}^{N} \\frac{1}{N}\\) 文章内に埋め込まれます。 参考 数学メモ: TeX チートシート｜まくろぐ 必要なときのみ MathJax を読み込むようにする 数式を使わないページで MathJax の JavaScript ファイルを読み込むのは無駄です。 次の例では、記事のフロントマターに useMath: true という指定があるときのみ MathJax を有効化しています。 layouts/_default/baseof.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html{{ with .Site.LanguageCode }} lang=\u0026#34;{{ . }}\u0026#34;{{ end }}\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; ... {{- if eq .Params.useMath true }} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; {{- end }} \u0026lt;/head\u0026gt; ... あとは、数式を使用する記事ページで次のようにフロントマターを記述すれば OK です。 MathJax の有効化 --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2023-10-21\u0026#34; useMath: true --- オイラーの公式： \\\\(\\mathrm{e}^{\\mathrm{i}\\theta} = \\cos(\\theta) + \\mathrm{i}\\sin(\\theta)\\\\)"},{url:"/p/8env4bi/",title:"Hugo で Markdown (.md) ファイルのパス情報を取得する",date:"2018-06-14T00:00:00Z",body:"Hugo で Markdown (.md) ファイルのパス情報を取得する Hugo のテンプレートファイル内で、File 変数を参照すると、記事ページのもとになった Markdown ファイルのパス情報を取得することができます。 File 変数の一覧は下記のページで参照できます。 File Variables｜Hugo File 変数の使用例 テンプレートファイルに下記のようなコードを追加すれば、File 変数の内容を簡単に確認できます。 layouts/_default/baseof.html（抜粋） \u0026lt;pre\u0026gt; .File.Filename = {{ .File.Filename }} .File.Path = {{ .File.Path }} .File.Dir = {{ .File.Dir }} .File.LogicalName = {{ .File.LogicalName }} .File.BaseFileName = {{ .File.BaseFileName }} .File.Extension = {{ .File.Extension }} \u0026lt;/pre\u0026gt; 例えば、C:\\Users\\maku\\website\\content\\diary\\2018.md から生成されたページ (diary/2018.html) にアクセスすると、以下のようなパス情報を取得することができます。 .File.Filename = C:\\Users\\maku\\website\\content\\diary\\2018.md .File.Path = diary\\2018.md .File.Dir = diary\\ .File.LogicalName = 2018.md .File.BaseFileName = 2018 .File.Extension = md Hugo サーバ動作させているときに Markdown ファイルのパスを表示する テンプレート内に下記のように記述しておけば、Hugo のローカルサーバで Web サイトをホスティングしている場合のみ、ローカル PC 内の Markdown ファイルのパスを表示することができます。 {{- /* Markdown ファイルのパスを表示 */}} {{- if .Site.IsServer -}} \u0026lt;div style=\u0026#34;text-align:right; font-size: smaller;\u0026#34;\u0026gt; {{- with .File }}{{ .Filename }}{{ end -}} \u0026lt;/div\u0026gt; {{- end }} 記事内に表示されたパスをターミナル上にコピペして、任意のエディタで開くということが素早く行えるようになります。 タグの一覧ページなど、生成元の Markdown ファイルが存在しない場合は、.File.Filename の値は空っぽになることに注意してください。 応用 Hugo ページの生成元になった Markdown (.md) ファイルを VS Code で開くリンクを表示する"},{url:"/p/q4o6n4k/",title:"Hugo でファイルが存在する場合のみ処理するコードを記述する (fileExists)",date:"2018-06-11T00:00:00Z",body:"Hugo でファイルが存在する場合のみ処理するコードを記述する (fileExists) Hugo のテンプレートの中で、fileExists 関数を使用すると、指定したファイルが存在する時のみ有効になる処理を記述することができます。 例えば、次のようにすると、static ディレクトリに画像ファイル (img/site-logo.png) が存在する場合のみ、その画像を表示する img 要素を出力します。 {{ if (fileExists \u0026#34;static/assets/img/site-logo.png\u0026#34;) }} \u0026lt;img src=\u0026#34;{{ \u0026#34;assets/img/site-logo.png\u0026#34; | absURL }}\u0026#34;\u0026gt; {{ end }} 参考: fileExists｜Hugo"},{url:"/p/8ogzaxd/",title:"Hugo のページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする",date:"2018-06-02T00:00:00Z",body:"Hugo のページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする Hugo には Pagenator という標準のページャー機能が備わっており、比較的簡単にページャー機能を組み込むことができます（参考: Pagination｜Hugo）。 ページャーの基本 ページャーとは、Google の検索結果のページなどで表示される、下記のようなものです。 図: ページャーの例 あるカテゴリに属する記事のリストを表示するときや、数日分の日記をまとめて表示するようなケースでは、1 ページが長くなりすぎないように、ページャーを導入することを検討するのがよいでしょう。 Hugo でページャーを導入すると、デフォルトでは /page/1、/page/2、/page/3 といった URL で、それぞれのグループ（複数の記事をまとめたページ）を表示するためのページにアクセスできるようになります（page というパスは、Hugo のコンフィグファイルの PaginatePath で変更できます）。 図: ページャーによる切り替え Hugo のページャー機能は、ホームページとリスト系ページ（セクションページや、タクソノミーリスト）のみで有効です。 つまり、ホームページテンプレート (layouts/index.html) や、リストテンプレート (layouts/_default/list.html) などに適用することになります。 ホームページテンプレートに適用すれば、それぞれのグループを表示するためのページには、次のようなアドレスでアクセスできるようになります。 https://example.com/page/1 （https://example.com/ のエイリアス） https://example.com/page/2 https://example.com/page/3 セクションテンプレートに適用した場合は、次のようなアドレスでアクセスできるようになります。 https://example.com/\u0026lt;SECTION\u0026gt;/page/1 （https://example.com/\u0026lt;SECTION\u0026gt;/ のエイリアス） https://example.com/\u0026lt;SECTION\u0026gt;/page/2 https://example.com/\u0026lt;SECTION\u0026gt;/page/3 ここでのポイントは、上記のようなファイル群は、1 つのホームページテンプレート（あるいはセクションテンプレート）から自動的に生成されるということです。 つまり、複数のページとして出力されてはいるものの、ページャー部分以外のコンテンツは同じになります。 後述するように、テンプレート内で .Pagenator にアクセスすると、Hugo は自動的にこれらのファイルを出力するようになります。 ちなみに、単独のページを出力するためのシングルページテンプレート (layouts/_default/single.html) ではページャー機能は使えないので、代わりに、ページ切り替え用の「次のページ」、「前のページ」といったリンク を表示しておくのがよいでしょう。 ページャーを導入する 組み込みの pagination テンプレートを使用する 1 グループごとの記事のリストは、.Pagenator.Pages で参照することができるようになっているので、これを range を使って列挙すれば OK です。 デフォルトでは 10 記事ごとがグルーピングされていますが、このサイズは Hugo のコンフィグファイルの Paginate で変更できます。 肝心のページ切り替え部分は、Hugo 組み込みのテンプレート _internal/pagination.html を使用して出力することができます。 つまり、ページャー機能を使って、シンプルにグループ内の記事リンクを列挙し、さらに切り替え部分を表示するなら、下記のようなテンプレートを記述すればよいことになります。 layouts/index.html（ホームページテンプレートの抜粋） \u0026lt;h3\u0026gt;ページリスト\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range .Paginator.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;h3\u0026gt;切り替え\u0026lt;/h3\u0026gt; {{ template \u0026#34;_internal/pagination.html\u0026#34; . }} 上記のようなテンプレートからは、下記のような URL でアクセス可能な HTML ファイルが出力されます。 ここでは、先頭のグループにアクセスするため、下記のいずれかのアドレスにアクセスしたと考えてください。 https://\u0026lt;ドメイン\u0026gt;/ https://\u0026lt;ドメイン\u0026gt;/page/1 （上記のエイリアス） HTML 出力サンプル \u0026lt;h3\u0026gt;ページリスト\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title1/\u0026#34;\u0026gt;タイトル1\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title2/\u0026#34;\u0026gt;タイトル2\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title3/\u0026#34;\u0026gt;タイトル3\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title4/\u0026#34;\u0026gt;タイトル4\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title5/\u0026#34;\u0026gt;タイトル5\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title6/\u0026#34;\u0026gt;タイトル6\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title7/\u0026#34;\u0026gt;タイトル7\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title8/\u0026#34;\u0026gt;タイトル8\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title9/\u0026#34;\u0026gt;タイトル9\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/title10/\u0026#34;\u0026gt;タイトル10\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;h3\u0026gt;切り替え\u0026lt;/h3\u0026gt; \u0026lt;ul class=\u0026#34;pagination\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34; aria-label=\u0026#34;First\u0026#34;\u0026gt;\u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026amp;laquo;\u0026amp;laquo;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;disabled\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;\u0026#34; aria-label=\u0026#34;Previous\u0026#34;\u0026gt;\u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026amp;laquo;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;1\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page/2/\u0026#34;\u0026gt;2\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page/3/\u0026#34;\u0026gt;3\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;disabled\u0026#34;\u0026gt;\u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026amp;hellip;\u0026lt;/span\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page/8/\u0026#34;\u0026gt;8\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page/2/\u0026#34; aria-label=\u0026#34;Next\u0026#34;\u0026gt;\u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026amp;raquo;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page/8/\u0026#34; aria-label=\u0026#34;Last\u0026#34;\u0026gt;\u0026lt;span aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026amp;raquo;\u0026amp;raquo;\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 後半のグループ切り替え部分は、Hugo 組み込みのテンプレート (_internal/pagination.html) によって出力されたもので、Bootstrap ベースの構造で出力されています。 Bootstrap を採用していない Web サイトでは、そのままでは思ったような表示にならないので、出力に合わせた CSS を定義してやる必要があります。 ul 要素に設定される pagination クラス li 要素の active クラス（現在のページ）と disabled クラス（その他のページ） あたりを考慮した CSS を記述すればよさそうです。 下記は、Bootstrap の pagination クラスまわりの定義を抜粋したものです。 .pagination { display: inline-block; padding-left: 0; margin: 20px 0; border-radius: 4px; } .pagination \u0026gt; li { display: inline; } .pagination \u0026gt; li \u0026gt; a, .pagination \u0026gt; li \u0026gt; span { position: relative; float: left; padding: 6px 12px; margin-left: -1px; line-height: 1.42857143; color: #337ab7; text-decoration: none; background-color: #fff; border: 1px solid #ddd; } .pagination \u0026gt; li:first-child \u0026gt; a, .pagination \u0026gt; li:first-child \u0026gt; span { margin-left: 0; border-top-left-radius: 4px; border-bottom-left-radius: 4px; } .pagination \u0026gt; li:last-child \u0026gt; a, .pagination \u0026gt; li:last-child \u0026gt; span { border-top-right-radius: 4px; border-bottom-right-radius: 4px; } .pagination \u0026gt; li \u0026gt; a:hover, .pagination \u0026gt; li \u0026gt; span:hover, .pagination \u0026gt; li \u0026gt; a:focus, .pagination \u0026gt; li \u0026gt; span:focus { z-index: 2; color: #23527c; background-color: #eee; border-color: #ddd; } .pagination \u0026gt; .active \u0026gt; a, .pagination \u0026gt; .active \u0026gt; span, .pagination \u0026gt; .active \u0026gt; a:hover, .pagination \u0026gt; .active \u0026gt; span:hover, .pagination \u0026gt; .active \u0026gt; a:focus, .pagination \u0026gt; .active \u0026gt; span:focus { z-index: 3; color: #fff; cursor: default; background-color: #337ab7; border-color: #337ab7; } .pagination \u0026gt; .disabled \u0026gt; span, .pagination \u0026gt; .disabled \u0026gt; span:hover, .pagination \u0026gt; .disabled \u0026gt; span:focus, .pagination \u0026gt; .disabled \u0026gt; a, .pagination \u0026gt; .disabled \u0026gt; a:hover, .pagination \u0026gt; .disabled \u0026gt; a:focus { color: #777; cursor: not-allowed; background-color: #fff; border-color: #ddd; } この CSS 定義を使用すると、ページャーの切り替え部分は下記のような表示になります。 図: ページャーの表示例 切り替え部分のテンプレートを自作する ページャーによる切り替え部分は、Hugo の組み込みテンプレート (_internal/pagination.html) を使って出力することができました。 この組み込みテンプレートの出力内容が気に入らない場合は、その内容を参考にしながら独自のテンプレートを作成することになるでしょう。 _internal/pagination.html の内容は、Hugo の GitHub リポジトリで参照することができます。 tpl/tplimpl/embedded/templates/pagination.html \u0026ndash; gohugoio/hugo"},{url:"/p/zxk6pat/",title:"Hugo で Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics)",date:"2018-06-01T00:00:00Z",body:"Hugo で Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics) Google Analytics を使用すると、Web サイトのアクセス情報を多角的に分析できるようになります。 ここでは、Hugo で作成する Web サイトに、簡単に Google Analytics 用のコードを埋め込めるようにしてみます。 ☝️ Google Analytics 4 (GA4) への移行 Google は従来 Google Analytics (Universal Analytics) を提供していましたが、2023 年 7 月以降は、最新バージョン Google Analytics 4 (GA4) しか使用できなくなります。 ただし、乗り換えは簡単で、設定するトラッキング ID を GA4 用のものに変更するだけです。 Analytics ID の先頭部分を見ると、どちらのバージョンを使用しているかが分かります。 （旧）Universal Analytics の ID \u0026hellip; UA-12345678-1 （新）Google Analytcs 4 (GA4) の ID \u0026hellip; G-12345ABCDE トラッキング ID をコンフィグファイルで設定する まずは、Google Analytics の管理画面から、「プロパティの追加」を実行し、分析したい Web サイトのアドレスを追加しておきます（Google Analytics のアカウントを持っていない場合は、先にアカウントから作成しておく必要があります）。 そのとき発行されるトラッキング ID（G-12345ABCDE のような ID）が、その Web サイトへのアクセスを判別するための識別情報となります。 この ID は、Web サイトごとに別のものを使用するので、Hugo のコンフィグファイルで設定するのがよいでしょう。 Hugo には、コンフィグファイル用のパラメータとして、あらかじめ googleAnalytics というパラメータが用意されています。 下記のような感じで、Google Analytics のサイトで発行したトラッキング ID を設定しましょう。 config.toml baseURL = \u0026#34;https://example.com/\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;まく日記\u0026#34; theme = \u0026#34;maku\u0026#34; googleAnalytics = \u0026#34;G-12345ABCDE\u0026#34; 上記のように設定すると、テンプレートファイルの中から、.Site.GoogleAnalytics でトラッキング ID を参照できるようになります。 トラッキングコード (JS) を自動で埋め込むようにする Google Analytics を有効にするには、各ページの head 要素の先頭に、次のような トラッキングコード を埋め込む必要があります（参考: gtag.js を使用してアナリティクスのトラッキングを設定する）。 \u0026lt;!-- Google tag (gtag.js) --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id=G-12345ABCDE\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;G-12345ABCDE\u0026#39;); \u0026lt;/script\u0026gt; ここでは、Hugo のパーシャルテンプレートを使い、上記の HTML コードを各ページに埋め込むようにしましょう。 G-12345ABCDE のようなトラッキング ID を指定する部分は、コンフィグファイルの googleAnalytics パラメータで指定した値で置換するようにします。 layouts/partials/analytics.html {{ if not .Site.IsServer }} {{ with .Site.GoogleAnalytics }} \u0026lt;!-- Google tag (gtag.js) --\u0026gt; \u0026lt;script async src=\u0026#34;https://www.googletagmanager.com/gtag/js?id={{ . }}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(\u0026#39;js\u0026#39;, new Date()); gtag(\u0026#39;config\u0026#39;, \u0026#39;{{ . }}\u0026#39;); \u0026lt;/script\u0026gt; {{ end }} {{ end }} ☝️ ワンポイント 上記テンプレートの 1、2 行目では、ローカルな Hugo サーバでテストしている場合や、googleAnalytics が設定されていない場合に、トラッキングコードを出力しないように制御しています。 作成したパーシャルテンプレートは、下記のようにテンプレートファイルからインクルードします（ここでは、ベーステンプレート (baseof) からインクルードしています）。 layouts/_default/baseof.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; {{- partial \u0026#34;analytics\u0026#34; . -}} \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; ...省略... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ...省略... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; これで、すべてのページに Google Analytics のトラッキングコードが埋め込まれるようになります。 （おまけ）Hugo 組み込みのテンプレート 実は、Hugo は組み込みの Internal Template として、Google Analytics のトラッキングコードを埋め込むためのテンプレートを用意しています。 任意のテンプレートファイルの中で、 {{ template \u0026#34;_internal/google_analytics.html\u0026#34; . }} \u0026lt;!-- 同期バージョン --\u0026gt; {{ template \u0026#34;_internal/google_analytics_async.html\u0026#34; . }} \u0026lt;!-- 非同期バージョン --\u0026gt; のように記述するだけで、簡単にトラッキングコードを埋め込むことができます。 ただし、組み込みのテンプレートは、ローカルサーバー動作時のコード出力抑制には対応していませんし、Google の変更に柔軟に対応することもできないので、できればパーシャルテンプレートは自作してしまった方がよいでしょう。"},{url:"/p/5m9tdwg/",title:"Hugo でコンフィグファイルに設定した情報を参照する",date:"2018-06-01T00:00:00Z",body:"Hugo でコンフィグファイルに設定した情報を参照する コンフィグファイルの基本 Hugo サイトの全般的な設定は、ルートディレクトリに置いた下記のいずれかのコンフィグファイルで行います（最初に見つかったものが採用されます）。 hugo.toml （TOMLフォーマットで記述） hugo.yaml （YAMLフォーマットで記述） hugo.json （JSONフォーマットで記述） hugo.toml の記述例 baseURL = \u0026#34;https://example.com/\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;まく日記\u0026#34; themesDir = \u0026#34;../hugo_themes\u0026#34; theme = \u0026#34;maku\u0026#34; 設定可能なパラメータや、それぞれのデフォルト値は下記に一覧があります。 Configure Hugo｜Hugo ☝️ hugo.toml と config.toml Hugo v0.110.0 でコンフィグファイル名が config.toml から hugo.toml に変更されました。 互換性のために config.toml のままでも動作するようですが、各種エディタやツールとの連携のためのリネームらしいので、新しい名前に乗り換えておいた方がよいでしょう。 設定値を参照する Hugo が定義しているパラメータを参照する コンフィグファイルで設定したパラメータは、テンプレートファイル内から、.Site 変数を使って参照することができます。 例えば、hugo.toml ファイルの中で設定した title や baseURL パラメータの値は次のようにして参照することができます。 このサイトのタイトルは \u0026lt;b\u0026gt;{{ $.Site.Title }}\u0026lt;/b\u0026gt; です。 このサイトのベースアドレスは \u0026lt;b\u0026gt;{{ $.Site.BaseURL }}\u0026lt;/b\u0026gt; です。 パラメータ名の先頭は、大文字になっていることに注意してください（.Site.title ではなく .Site.Title が正しい）。 それぞれの設定値が、どのようなプロパティ名で参照できるようになっているかは、下記の Site 変数の一覧を見るとわかります。 Site Variables｜Hugo パラメータが設定されているかどうかで処理を分岐させたい場合は、例えば次のように記述しておけばよいでしょう。 ここでは、googleAnalytics というパラメータで、Google Analytics 用のトラッキング ID が設定されているかどうかをチェックしています。 {{ with $.Site.GoogleAnalytics }} Google Analytics のトラッキング ID は \u0026lt;b\u0026gt;{{ . }}\u0026lt;/b\u0026gt; です。 {{ else }} Google Analytics のトラッキング ID が設定されていません。 {{ end }} 参考: Google アナリティクス用のトラッキングコードを埋め込む 独自定義のパラメータを参照する コンフィグファイルで独自定義のパラメータを設定するには、params セクションの下にパラメータを追加します。 hugo.toml baseURL = \u0026#34;https://example.com/\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;まく日記\u0026#34; [params] GitHubUser = \u0026#34;maku77\u0026#34; Twitter = \u0026#34;hogehoge\u0026#34; Subtitle = \u0026#34;天才まくまくのゆるふわ日記といろんなメモ\u0026#34; Description = \u0026#34;ここには、このサイトの詳細情報を記述します。\u0026#34; SidebarRecentLimit = 5 ListOfFoo = [\u0026#34;foo1\u0026#34;, \u0026#34;foo2\u0026#34;] 独自定義のパラメータは、テンプレートファイル内から $.Site.Params.名前 という形で参照することができます。 下記の例では、独自パラメータの Description の値を参照しています。 独自パラメータを参照する (layouts/partials/head.html) \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ if .IsHome }}{{ $.Site.Params.description }}{{ else }}{{ .Description }}{{ end }}\u0026#34; /\u0026gt; ちなみに、このサンプルでは、ホームページではサイトのコンフィグ設定 ($.Site.Params.Description) を参照し、それ以外のページでは、各ページのフロントマターに設定した description パラメータの値を参照するようにしています。"},{url:"/p/taxh3m7/",title:"Hugo サーバーで記事の変更内容が反映されない場合",date:"2018-05-29T00:00:00Z",body:"Hugo サーバーで記事の変更内容が反映されない場合 Hugo サーバーを立ち上げて記事の更新をしていると、Web ブラウザをリロードしても変更内容が反映されないことがあります（特に layouts や partials など、共有して使う部分など）。 ページのビルドに成功しているのに変更内容が反映されない場合は、Hugo サーバーのキャッシュを疑ってみるとよいかもしれません。 hugo server コマンドを実行するときに、--ignoreCache オプションをつけると、キャッシュを使わずにレンダリングされます。 $ hugo server --ignoreCache"},{url:"/p/pocxi4n/",title:"Hugo で最近更新された記事（新着記事）のリストを表示する",date:"2018-05-29T00:00:00Z",body:"Hugo で最近更新された記事（新着記事）のリストを表示する 新しく作成した記事を列挙する 下記のテンプレートコードは、日付（フロントマターの date フィールドの値）の新しい順に、 5 件分のリンクを表示します。 作成日 (date) 順に 5 件のリンクを表示する \u0026lt;h2\u0026gt;新着記事\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{ range first 5 .Site.RegularPages.ByDate.Reverse }} \u0026lt;li\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;time\u0026gt;{{.Date.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/time\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; .Site.RegularPages.ByDate.Reverse という部分で、サイト内の全ページを日付の逆順に列挙することを示しています（インデックス系のページも列挙したい場合は .RegularPages の部分を .Pages に変更してください）。 first 5 は、その中の最初の 5 件を取り出すという命令です。 .Date.Format による日時フォーマットの指定方法は、こちらの Go 言語の記事 を参考にしてください。 更新日 (lastmod) の新しい順に列挙する date ではなく lastmod を使う 上記の例では、記事の作成日（date フィールド）を基準にして最新記事を列挙しましたが、更新日時（lastmod フィールド）を基準に最新記事を列挙することもできます。 次のようにコードを置き換えるだけで OK です。 .Date → .Lastmod .ByDate → .ByLastmod 最終更新日 (lastmod) 順に 5 件のリンクを表示する \u0026lt;h2\u0026gt;最近更新された記事\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{ range first 5 .Site.RegularPages.ByLastmod.Reverse }} \u0026lt;li\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;time\u0026gt;{{.Lastmod.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/time\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; 記事のフロントマターに lastmod フィールドが定義されていない場合は、date フィールドが使用されるようになっています。 このようなフォールバックの仕組みが用意されているので、最新記事を列挙するときは、.ByDate よりも .ByLastmod を使うようにしておくのがよさそうです。 ただし、typo の修正などで lastmod を更新してしまうと、それだけで記事が一番上に出てきてしまうので、ある程度内容のある更新をしたときのみ lastmod の日付を更新するなどの工夫が必要かもしれません。 Git と連携して lastmod の日付を自動で設定する Hugo の設定ファイルで、下記のように設定しておくと、lastmod フィールドが設定されていない記事に対して、Git のコミット日時を自動的に設定してくれるようになります（Page 変数の .Lastmod を参照して日時を表示してください）。 config.toml（抜粋） enableGitInfo = true Git を使用しているのであれば、この設定を入れておくと便利かもしれません（参考: Git Info Variables｜Hugo）。 新着記事のリストにドラフトページを含めない where 関数を組み合わせて使用すると、新着記事の一覧から、ドラフトページ（ページのフロントマターに draft: true と書かれたもの）を除くことができます（参考: ドラフトページを作成する）。 \u0026lt;h2\u0026gt;新着記事\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{ range first 5 (where .Site.RegularPages.ByLastmod.Reverse \u0026#34;.Draft\u0026#34; \u0026#34;!=\u0026#34; true) }} \u0026lt;li\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;time\u0026gt;{{.Lastmod.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/time\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; ☝️ ワンポイント ドラフトページはデフォルトでは出力されないので、通常はこのようなフィルタリングは必要ありません。 hugo コマンドを実行するときに、-D オプションを指定すると、ドラフトページが出力されるようになります。 hugo server コマンドで Hugo サーバーのホスティングを行うときも同様です。 独自のページ変数を用意して、新着記事への表示／非表示を制御するというのもありですね。 例えば、ページのフロントマターに working: true と設定されていたら新着記事に列挙しないようにするには次のようにします。 \u0026lt;h2\u0026gt;新着記事\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{ range first 5 (where .Site.RegularPages.ByLastmod.Reverse \u0026#34;.Params.working\u0026#34; \u0026#34;!=\u0026#34; true) }} \u0026lt;li\u0026gt; \u0026lt;b\u0026gt;\u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;time\u0026gt;{{.Lastmod.Format \u0026#34;2006-01-02\u0026#34;}}\u0026lt;/time\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; where 関数の条件式の \u0026quot;.Draft\u0026quot; \u0026quot;!=\u0026quot; true というところが \u0026quot;.Params.working\u0026quot; \u0026quot;!=\u0026quot; true に変わっただけです。"},{url:"/p/yqjs3aw/",title:"Python の実行環境を virtualenv で切り替える（Python 3.2 以前）",date:"2018-04-28T00:00:00Z",body:"Python の実行環境を virtualenv で切り替える（Python 3.2 以前） virtualenv コマンドを使用すると、仮想的な Python の実行環境を作成することができます。 （追記）Python 3.3 以降は、virtualenv と同様の機能を提供する venv モジュールが標準搭載されたので、そちらを使うようにしましょう。 Python の実行環境を切り替えて使用する (venv) virtualenv とは Virtualenv Python 製のツールを使おうとすると、使用可能な Python のバージョンが制限されていたり、依存する Python パッケージを pip コマンドでたくさんインストールしなければいけなかったりします。 こういったツールを実行するために、パッケージをどんどんインストールしていくと、PC 内の Python 環境がぐちゃぐちゃになってしまいます（システムの site-packages ディレクトリに大量のパッケージがインストールされて管理できなくなる）。 そこで便利なのが、独立した Python 環境を作成することができる virtualenv コマンドです。 virtualenv で作成した仮想環境の中では、特定のバージョンの Python を使用することができ、閉じた環境内に Python パッケージをインストール (pip install) することができます。 もし、その環境が必要なくなったら、仮想環境ごと削除してしまえば、PC 内のグローバルな Python 実行環境はクリーンなままです。 例えば、何らかの Python 製ツール app があったとして、そのツールを使用するにはいくつかの Python パッケージをインストールしなければならないとします。 virtualenv を使用して、その Python 製ツールを使用するための環境を作る流れは以下のようになります。 app ディレクトリに移動する (cd app) app 用の Python 仮想環境を作成する (virtualenv 環境名) 仮想環境に入る (source 環境名/bin/activate) app に必要な Python パッケージをインストールする (pip install XXX) app を使う (python app.py) 仮想環境を抜ける (deactivate) virtualenv コマンドのインストール virtualenv コマンドは、pip コマンドで簡単にインストールすることができます。 $ pip install virtualenv （うまくいかない場合は sudo をつけてみる） virtualenv コマンドが実行できるようになればインストール成功です。 $ virtualenv --version 15.2.0 virtualenv で Python 仮想環境を作成／使用／削除する 仮想環境を作成する virtualenv コマンドで新しい Python 仮想環境を作成するには、下記のように実行します。 ENV というのは任意の環境名で、ここで指定した名前のディレクトリがカレントディレクトリに作成されます。 $ virtualenv ENV 仮想環境に入る (activate) この環境を使用するには、ENV ディレクトリの中に作成された bin/activate スクリプトを読み込みます（Windows の場合はバッチファイルになっています）。 仮想環境に入ると、プロンプトに (環境名) と表示されるようになります。 $ source ENV/bin/activate （source の代わりに . でもOK） (ENV)$ 仮想環境に入った状態で python コマンドを実行すると、その仮想環境内に配置された ENV/bin/python が参照されます（この処理系の切り替え方法は後述）。 (ENV)$ which python /Users/maku/ENV/bin/python また、pip コマンドでインストールする Python パッケージも、仮想環境内の ENV/lib/python3.6/site-packages に格納されるようになるので、たくさんパッケージをインストールしても、仮想環境の外の Python 実行環境を汚染することがありません。 仮想環境を抜ける (deactivate) 仮想環境を抜けて元の世界に戻るには、deactivate コマンドを実行します。 このコマンドは、ENV/bin/deactivate として配置されているのですが、仮想環境に入るときに ENV/bin にパスが通されるので、どこからでも実行することができます。 (ENV)$ deactivate $ 仮想環境を削除する 仮想環境自体が不要になったら、ディレクトリごと削除してしまえば OK です。 $ rm -r ENV virtualenv の高度な使い方 仮想環境で使用する Python のバージョンを指定する 仮想環境で使用する Python (ENV/bin/python) のバージョンは、デフォルトでは virtualenv のインストールに使用した Python 処理系と同じバージョンになります（要するに pip コマンドが使用する python のバージョンということ）。 仮想環境内から使用する Python 処理系のバージョンを指定したい場合は、仮想環境の作成時に、--python オプションで指定します（ENV/bin/python として配置する処理系を指定する）。 $ virtualenv --python=python ENV $ virtualenv --python=python2.7 ENV $ virtualenv --python=python3 ENV $ virtualenv --python=/opt/python-2.7/bin/python ENV この例からも分かるように、指定できる Python 処理系は、あらかじめインストールされているものだけだということに注意してください。 Python 2.7 しかインストールされていない環境で、Python 3 を使用する仮想環境を作成したいときは、先に Python 3 をインストールしておく必要があります。 仮想環境からグローバルな site-packages を参照できるようにする システムにインストールされている Python パッケージ群を、仮想環境からも参照できるようにするには、仮想環境を作成するときに --system-site-packages オプションを指定します。 $ virtualenv --system-site-packages ENV ☝️ ワンポイント 過去のバージョンの virtualenv では、デフォルトで仮想環境からグローバルな site-packages を参照できるようになっており、これを抑制するためには --no-site-packages オプションが必要でした。 現在は、デフォルトでグローバルな site-package は参照できないようになっており、--no-site-packages オプションも deprecated（廃止予定）扱いとなっています。 仮想環境内に Linux コマンドなどをインストールする virtualenv の仮想環境に入ると、ENV/bin ディレクトリに自動的にパスが通されるようになっています。 $ . ENV/bin/activate (ENV)$ echo $PATH /Users/maku/ENV/bin:... つまり、この ENV/bin ディレクトリ内に何らかのコマンドラインツールを配置すれば、仮想環境内でのみ使用可能なコマンドとして扱うことができます。 仮想環境が必要なくなった場合は、ENV ディレクトリごと削除してしまえばよいので、外部の環境に影響を与えずに済みます。"},{url:"/p/sw5kgj2/",title:"HTML のリスト要素 (ul, ol, li) のマージン指定方法を理解する",date:"2018-04-23T00:00:00Z",body:"HTML のリスト要素 (ul, ol, li) のマージン指定方法を理解する HTML でリストを表示するには ul や ol 要素を使いますが、これらのマージン、インデント設定は若干わかりにくいので、ここではいろいろなパターンの表示例を確認しながら理解を深めます。 ul 要素と li 要素の padding-left 図: ul 要素と li 要素の padding プロパティの意味 この図は、ul 要素（あるいは ol 要素）の padding-left の値と、li 要素の padding-left の値がどの領域のサイズとして反映されるかを示しています。 特に気をつけなければいけないのは、ul 要素の padding-left 値は、li 要素の描画領域の左端までのサイズになるというところです。 言い換えると、リストマーカー（・など）の右端までのサイズです。 つまり、ul 要素の padding-left の値は、リストマーカーまで含んだサイズ であることを意識して設定する必要があります。 Chrome では ul 要素の padding-left の規定値は 40px になっているようです。 一方で、li 要素の padding-left の値は、リストマーカーの右端から、テキストの左端までのサイズ を表します。 こちらの値は 0 になっていても、特におかしな表示にはなりません。 ul のインデント設定は padding-left で行うのが基本 下記は、ul 要素の padding-left プロパティだけを設定した場合の表示デモです（その他の margin 設定や padding 設定は 0 です）。 入れ子になった ul 要素も、それっぽくインデントされていることがわかります。 これが、ul 要素や ol 要素に対してインデントサイズを指定するときの基本的な方法です。 表示デモ 1 （別ページで開く） 表示デモの中の外側の矩形は、ul 要素を配置する親要素の描画領域を示しています。 ul 要素の描画領域はピンク背景、li 要素の描画領域は下線を引くことで、それぞれの要素の位置関係が分かるようにしています。 ここでは ul { padding-left: 3em; } と指定していますが、このサイズは、上記の表示では、ピンク領域の左端 ～ テキストの下線が始まるところまでのサイズとして反映されています。 ☝️ ワンポイント サイズの単位として em を使うようにすれば、ul 要素内のフォントサイズを基準にして指定することができます。 表示デモ 2 （別ページで開く） ul 要素の padding-left を 0 にしてしまうと、上記のように入れ子要素のインデントがなくなり、さらに、リストマーカーを表示する余裕もないので、親要素をはみ出してリストマーカーが表示されてしまいます。 ul 要素の padding-left には、余裕を持ったサイズを指定しなければいけないということです。 表示デモ 3 （別ページで開く） 上記は、padding-left の代わりに margin-left を設定した場合の表示デモですが、この方法でもうまくインデントされているかのように見えます。 ただし、margin プロパティの値は、他の要素と並べて配置した時に、それらの margin と相殺される性質を持っています。 思わぬ表示位置のずれを防ぐためにも、ul/ol 要素のインデントサイズ指定には padding-left だけを使う ことをおススメします。 ちなみに padding-left と margin-left を両方設定すると、次のようにインデント幅がものすごく大きくなったように見えます。 表示デモ 4 （別ページで開く） li の padding-left は 0 で OK li 要素の padding-left プロパティでは、リストマーカーの右端からテキストの先頭までの距離を設定します。 次の例では、各 li 要素の padding-left の値を少しずつ増やしながら表示しています。 表示デモ 5 （別ページで開く） 入れ子になった ul 要素は li 要素の子要素として配置されるため、li 要素の padding-left を大きくすると、その下の ul 要素自体のインデント幅が大きくなったかのように見えます。 表示デモ 6 （別ページで開く） ☝️ ワンポイント 間違えがちですが、ul 要素の直下に ul を配置することはできません。 ul 要素の直下には、必ず li 要素を配置する必要があります。 入れ子になった（2 階層目以降の）ul のインデントだけ小さくする 1 階層目の ul のインデントだけ小さくしたい場合や、2 階層目以降の ul のインデントだけ小さくしたい場合は、例えば以下のように設定すればよいでしょう。 ul, ol { padding-left: 3em; } li \u0026gt; ul, li \u0026gt; ol { /* 2 階層目以降はインデントを小さく */ padding-left: 1em; } ul 要素の親要素が li であることを示すセレクタ (li \u0026gt; ul) を使用することで、2 階層目以降の ul 要素に対するスタイル設定を行うことができます。 表示デモ 7 （別ページで開く） 画面幅が狭い時にインデントを小さくする（レスポンシブ対応） リストのインデントを大きくしすぎると、ブラウザの画面サイズが小さいとき（スマホで表示した場合など）に、表示できる文字数が少なくなってしまいます。 このような問題を避けるためには、メディアクエリを使用して、画面サイズに応じてインデントサイズを変更するようにします。 CSS の例 ul, ol { padding-left: 2em; } li \u0026gt; ul, li \u0026gt; ol { padding-left: 1em; } /* スクリーンサイズが大きいときはインデントを大きくする */ @media (min-width: 35rem) { ul, ol { padding-left: 3em; } li \u0026gt; ul, li \u0026gt; ol { padding-left: 2em; } } 次の例では、ブラウザの画面サイズが小さいときに、リストのインデント幅も小さくなるように設定しています（フレームの右下をドラッグしたり、Ctrl-+ でフォントサイズを変更したりすると、インデントサイズが変化することを確認できます）。 表示デモ 8 （別ページで開く） まとめ ul/ol 要素を入れ子にしたときのインデントサイズは ul/ol 要素の padding-left で設定する。 2 階層目以降の ul/ol 要素のインデントサイズだけ変更したい場合は li \u0026gt; ul というセレクタを使用する。 margin-left は使用しない。 padding-left の値のサイズとしては em を使用するのがおすすめ。"},{url:"/p/sc9t737/",title:"Hugo で次のページ、前のページへのリンクを表示する",date:"2018-04-22T00:00:00Z",body:"Hugo で次のページ、前のページへのリンクを表示する ページ変数の .NextInSection や .PrevInSection を使用すると、同じセクション内の次のページ、前のページを参照することができます。 同じ階層にある「前のページ」「次のページ」へのリンクを表示する 下記のテンプレートコードは、前のページへのリンクと、次のページへのリンクを表示するシンプルな例です。 テンプレートコード（抜粋） {{ with .PrevInSection }} \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; {{ end }} {{ with .NextInSection }} \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; {{ end }} Page 変数の .PrevInSection や .NextInSection には、同じセクション内にある通常ページ (regular page) の内、前のエントリと次のエントリにあたるページ が格納されています。 これらの変数は、通常ページ (regular page) でしか有効でないことに注意してください（つまり、シングルページレイアウトで使用します）。 セクションページなどで参照すると、nil が返されます。 ☝️ .Title ではなく .LinkTitle を出力する リンクのタイトルをなるべく短く表示するため、.Title ではなく .LinkTitle を参照していることに注意してください。 こうしておくと、ページのフロントマターで linkTitle プロパティが設定されている場合に、title プロパティよりも優先的に参照されるようになります。 体裁を整えるのであれば、前のページへのリンクは左寄せ、次のページへのリンクは右寄せで表示するとよいでしょう。 表示イメージとしては次のような感じです。 ≪前のページへ 次のページへ≫ さらに、コードは prev-next パーシャルテンプレートとして、使い回しがきくようにしておきましょう。 下記は完成版のパーシャルテンプレートです。 layouts/partials/prev-next.html \u0026lt;div class=\u0026#34;xPrevNextLink\u0026#34;\u0026gt; {{ with .PrevInSection }} \u0026lt;div class=\u0026#34;xPrevNextLink_prev\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{ end }} {{ with .NextInSection }} \u0026lt;div class=\u0026#34;xPrevNextLink_next\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{ end }} \u0026lt;/div\u0026gt; 左寄せ、右寄せ用のスタイルも定義しておきます。 リンクタイトルの前後に表示される ≪ 記号や ≫ 記号も、CSS で表示するように設定します。 static/assets/css/main.css（例） /* 前ページ、次ページへのリンク */ .xPrevNextLink { display: flex; justify-content: space-between; } .xPrevNextLink_prev::before { content: \u0026#34;≪\u0026#34;; } .xPrevNextLink_next::after { content: \u0026#34;≫\u0026#34;; } prev-next パーシャルテンプレートを使用するには、任意のテンプレートファイル内で次のように呼び出します。 layouts/_default/single.html（抜粋） \u0026lt;body\u0026gt; \u0026lt;main\u0026gt; ... {{ partial \u0026#34;prev-next\u0026#34; . }} ... \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; セクションページも含めて「前のページ」「次のページ」へのリンクを表示する 上記の .PrevInSection や .NextInSection は、通常ページ (regular page) のみを対象 として、「前のページ」や「次のページ」へのリンクを実現するための機能でした。 例えば、content ディレクトリ内に次のような構成で記事を作成したとすると、 section-0/_index.md section-1/_index.md section-2/_index.md section-3/_index.md page-1.md page-2.md page-3.md page-1、page-2、page-3 の 3 つの通常ページを前後に移動するためのリンクとして働きます。 セクションページは対象にならないため、page-1 から section-3 へのリンク（およびその逆のリンク）は張られません。 section-1、section-2、section-3 などのセクションページも含めて、前後に移動できるようにするには、.PrevInSection や .NextInSection を使用せず、自力で前後のページへの参照を求める必要があります。 下記のサンプルコードは、セクションページを含めた「前のページ」「次のページ」へのリンクを出力する例です。 layouts/partials/prev-next-siblings.html {{ if .Parent }} {{- /* まずは同じ階層のセクションとページから prev と next を決める */}} {{- range .Parent.Pages }} {{ if eq . $ }} {{ $.Scratch.Set \u0026#34;found\u0026#34; true }} {{ else }} {{ if $.Scratch.Get \u0026#34;found\u0026#34; }} {{ if not ($.Scratch.Get \u0026#34;next\u0026#34;) }} {{/* Set \u0026#34;next\u0026#34; entry as just after the current page. */}} {{ $.Scratch.Set \u0026#34;next\u0026#34; . }} {{ end }} {{ else }} {{/* Update \u0026#34;prev\u0026#34; entry until the current page is found. */}} {{ $.Scratch.Set \u0026#34;prev\u0026#34; . }} {{ end }} {{ end }} {{ end }} {{/* 見つかった prev と next のリンクを表示 */}} \u0026lt;div class=\u0026#34;xPrevNextLink\u0026#34;\u0026gt; {{- with ($.Scratch.Get \u0026#34;prev\u0026#34;) -}} \u0026lt;div class=\u0026#34;xPrevNextLink_prev\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} {{- with ($.Scratch.Get \u0026#34;next\u0026#34;) -}} \u0026lt;div class=\u0026#34;xPrevNextLink_next\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; {{ end }} ちょっと長いですが、大まかには次のようなことを行っています。 同一階層にある通常ページおよびセクションページをループ処理（前から順番に見ていく） カレントページにたどり着いた時点で、その前後のページが判明する（\u0026quot;prev\u0026quot; と \u0026quot;next\u0026quot;） \u0026quot;prev\u0026quot; と \u0026quot;next\u0026quot; のページへのリンクを出力 ☝️ ワンポイント 現時点の Hugo バージョン v0.47.1 は、range ループの break をサポートしていなかったため、前後のページを発見した後も最後までループ処理が継続してしまいます。 Hugo（が使用している Go テンプレート）が break に対応すれば、もう少し効率的な処理が可能になります。 とはいえ、そのままでも十分速いですが。 上記の prev-next-siblings パーシャルテンプレートは、通常ページ (regular page) 専用の Page 変数である .PrevInSection や .NextInSection を使用せずに実装されているため、下記のようにセクションテンプレートなどからも使用することができます。 このセクションテンプレートは、ベーステンプレートと組み合わせて使用する ことを想定しています。 layouts/_default/section.html（使用例） {{ define \u0026#34;article\u0026#34; }} \u0026lt;article class=\u0026#34;xArticle\u0026#34;\u0026gt; {{ partial \u0026#34;prev-next-siblings\u0026#34; . }} {{ .Render \u0026#34;inc-article\u0026#34; }} \u0026lt;/article\u0026gt; {{ end }} Hugo がネイティブでこのようなリンク出力用の Page 変数を用意してくれれば楽なんですけどね(^^;"},{url:"/p/5ru4kte/",title:"Hugo で全ページから参照できるデータを用意する（data ディレクトリ）",date:"2018-04-08T00:00:00Z",body:"Hugo で全ページから参照できるデータを用意する（data ディレクトリ） Hugo プロジェクトの data ディレクトリに YAML、JSON、TOML、CSV などの形式でデータファイルを作成しておくと、すべてのページから自由に参照できるようになります。 データファイルを作成する data ディレクトリに置くデータファイルは、下記のいずれかのフォーマットで作成します。 YAML フォーマット JSON フォーマット TOML フォーマット CSV フォーマット ここでは英単語の辞書データを YAML 形式のファイル data/words.yaml として作成してみましょう（拡張子は .yaml でも .yml でも構いません）。 data ディレクトリは、サイトのルートディレクトリに作成します（content ディレクトリや layouts ディレクトリと同じ階層に data ディレクトリを置きます）。 data/words.yaml - en: apple jp: りんご - en: banana jp: バナナ - en: grape jp: ぶどう ☝️ ワンポイント Hugo 0.37 より前のバージョンには YAML 処理の不具合があり、上記のようにルートレベルに配列データを記述することができませんでした。 hugo version コマンドでバージョンを確認し、必要があれば 最新の Hugo に更新 しましょう。 あるいは、JSON ファイルとして作成するのであればこんな感じです。 data/words.json [ { \u0026#34;en\u0026#34; : \u0026#34;apple\u0026#34;, \u0026#34;jp\u0026#34; : \u0026#34;りんご\u0026#34; }, { \u0026#34;en\u0026#34; : \u0026#34;banana\u0026#34;, \u0026#34;jp\u0026#34; : \u0026#34;バナナ\u0026#34; }, { \u0026#34;en\u0026#34; : \u0026#34;grape\u0026#34;, \u0026#34;jp\u0026#34; : \u0026#34;ぶどう\u0026#34; } ] できれば、よりシンプルに記述できる YAML 形式を使いたいですね。 データファイルを参照する data ディレクトリ以下に作成したデータファイルを参照するには、テンプレートファイルの中で .Site.Data.ファイル名（拡張子は除く）のように参照します。 ここでは、words セクションのインデックスページ (content/words/_index.md) にのみ適用されるセクションテンプレートを作成することにしましょう。 layouts/words/list.html（抜粋） \u0026lt;ul\u0026gt; {{- range .Site.Data.words }} \u0026lt;li\u0026gt;{{ .en }} は {{ .jp }} です。\u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; 次に、words セクションのコンテンツファイルを作成します。 セクションの生成が目的ですから、本文は空っぽで構いません。 content/words/_index.md --- title: \u0026#34;単語集\u0026#34; --- （本文は空っぽでOK） これで、http://\u0026lt;サイト\u0026gt;/words/ にアクセスすると、次のような HTML コンテンツが表示されるはずです。 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;apple は りんご です。\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;banana は バナナ です。\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;grape は ぶどう です。\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 複数のデータファイルをループ処理する data ディレクトリ以下のディレクトリ内に、複数のデータファイルを同じフォーマットで作成しておくと、テンプレート内でループ処理することができます。 次の例では、data/books ディレクトリ内に、書籍情報を表す YAML ファイルを配置しています。 1 つの YAML ファイルに、1 つの書籍の情報を記述します。 ディレクトリ内のファイルをすべてループ処理するので、YAML ファイルの名前は何でも構いません。 data/books/title1.yaml title: ライザップ式 2 週間ダイエットレシピ author: RIZAP 株式会社 isbn13: 978-4537215489 data/books/title2.yaml title: 大人女子の体にライザップ author: RIZAP 株式会社 isbn13: 978-4537215618 本当はこれくらいの情報量であれば、1 ファイルに記述してしまった方がよいのですが、ここでは説明のために分けていると考えてください。 これらのデータファイルを参照するテンプレートは、例えば以下のように記述します。 ここでは、1 データごとの出力内容を、パーシャルテンプレートに分けてみましょう。 layouts/_default/list.html（抜粋） {{- range .Site.Data.books }} {{ partial \u0026#34;book\u0026#34; . }} {{- end }} layouts/partials/book.html \u0026lt;div class=\u0026#34;book\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;book_title\u0026#34;\u0026gt;{{ .title }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;著者: {{ .author }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;ISBN-13: {{ .isbn13 }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; レンダリング結果は次のような感じになります。 \u0026lt;div class=\u0026#34;book\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;book_title\u0026#34;\u0026gt;ライザップ式 2 週間ダイエットレシピ\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;著者: RIZAP 株式会社\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;ISBN-13: 978-4537215489\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;book\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;book_title\u0026#34;\u0026gt;大人女子の体にライザップ\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;著者: RIZAP 株式会社\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;ISBN-13: 978-4537215618\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;"},{url:"/p/jbr6kzd/",title:"Hugo のローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する",date:"2018-04-02T00:00:00Z",body:"Hugo のローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する 自分の作業用備忘録としてはメモとして残したいけれど、インターネット上には公開したくない内容に関しては、Hugo をローカルサーバーとして動作させているときだけ出力するようなショートコードを作成しておくと便利です。 private ショートコードを作成する そのショートコードが、Hugo のローカルサーバ上 (hugo server) で使用されたかを判別するには、Site 変数の .Site.IsServer を参照します。 layouts/shortcodes/private.html {{ if .Site.IsServer }} ローカルサーバで動作しています。 {{ end }} あとは、.Inner 変数で、渡されたテキストを参照することができるので、たとえば次のように実装すればよいでしょう。 layouts/shortcodes/private.html {{ if .Site.IsServer }} \u0026lt;div class=\u0026#34;private\u0026#34;\u0026gt;{{ .Inner }}\u0026lt;/div\u0026gt; {{ end }} ここでは、出力する div 要素に private というクラスを割り当てています。 下記は private クラスに適用するスタイルシートの例です（赤系の色で強調表示するようにしています）。 .private { background: #fee; color: #f11; padding: 0.5em; border: solid 1px #f11; } .private::before { content: \u0026#34;Private メモ\u0026#34;; display: block; font-weight: bolder; } 使用方法 作成した private ショートコードは、記事ファイルの中で次のように利用します。 content/sample.md --- title: \u0026#34;サンプルタイトル\u0026#34; --- {{\u0026lt; private \u0026gt;}} これは非公開なメモだよ。 {{\u0026lt; /private \u0026gt;}} 次のように、内部のテキストで Markdown 構文を使用することもできます（その場合は、ショートコード名を % 記号で囲むことに注意してください）。 {{% private %}} これは非公開なメモだよ。 - Markdown の構文も使えるよ - Markdown の構文も使えるよ - Markdown の構文も使えるよ {{% /private %}} （おまけ）.Site.IsServer が使えなかった頃はどうやっていたか？ .Site.IsServer 変数は Hugo v.0.38 で追加されました。 v.0.37 以前のバージョンでは、ローカルサーバーで Web ページをホスティングしているかどうかを、.Site.BaseURL の値が http://localhost で始まっているかどうかで判断していました。 layouts/shortcodes/private.html {{ if hasPrefix .Site.BaseURL \u0026#34;http://localhost\u0026#34; }} ローカルサーバーで動作しています。 {{ end }}"},{url:"/p/7o7ymst/",title:"Hugo でサイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示）",date:"2018-01-23T00:00:00Z",body:"Hugo でサイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示） サイドバーメニューに、サイトの階層構造に応じたリンクを表示しておくと、サイト内の様々なページに簡単に移動できるようになります。 サイドバーでのページツリー表示のイメージ サイト全体のページ一覧をツリー構造で表示する方法は、下記のページで紹介しています。 サイト内の全ページの一覧をセクションの階層構造に従って表示する しかし、上記のページで説明している方法でツリー表示すると、すべてのページが展開された状態で表示されてしまうため、サイドバーに表示するツリーとしてはちょっと情報量が多すぎます。 ここでは、もう少しコンパクトに表示されるように、現在のページの上位ノードだけを展開したツリーを表示するようにしてみます。 イメージとしては次のような感じで、表示中のページ（ここでは page1）の上位のセクションだけを展開したツリーを表示することを考えます。 - sec1/ - sec2/ - sec2-1/ - sec2-2/ - page1 （表示中のページ） - page2 - sec2-2-1/ - sec2-2-2/ - sec2-3/ - sec3/ - sec4/ このようなツリーをサイドバーなどに表示しておくことで、ユーザが今、サイト全体でどの位置の記事を読んでいるかを簡単に把握できるようになります（パンくずリストなども同様の効果がありますが、ツリー表示の方が、より全体を把握しやすいといえます）。 展開すべきノードを知る 自分自身のページが所属するセクションだけを展開したツリーを表示するには、テンプレートコード内で、セクションの親子関係を（先祖まで含めて）把握する必要があります。 そのために、Page オブジェクトの以下のようなメソッドを利用することができます（参考: Hugo - Section Variables and Methods）。 Hugo 本家のマニュアルページでは、.InSection や .IsAncestor、.IsDescendant メソッドは、Section 変数 の Methods として記述されていますが、通常ページを含む Page オブジェクトのメソッドとして参照することができます。 $p1.InSection $p2 $p1 と $p2 が同一のセクションに所属していれば true（$p1 = $p2 の場合も true）。 それ以外は false。 (Whether the given page is in the current section.) $p1.IsAncestor $p2 $p1 が $p2 の先祖ページかどうかを調べる。 $p1 セクションが $p2 のカレントセクションよりも上位のセクションであれば true。 $p1 が通常ページの場合は常に false。 $p1 = $p2 の場合も false。 (Whether the current page is an ancestor of the given page.) $p1.IsDescendant $p2 $p1 が $p2 の子孫ページかどうかを調べる。$p2.IsAncestor $1 とするのと同じ。 (Whether the current page is a descendant of the given page.) ☝️ ワンポイント Hugo 0.100 で .IsDescendant と .IsAncestor の振る舞いが変更されました。 IsDescendant/IsAncestor returns true for self · Issue #9925 · gohugoio/hugo Notes release notes 0.100 · Issue #9934 · gohugoio/hugo なかなか分かりにくいですね。このような場合は実際にテストしてみるのが一番です。 これらのメソッドがどういう振る舞いをするのかを明確にするため、次のようなディレクトリ構成（セクション構成）のダミーサイトでテストしてみます。 /_index.md /page.md /sec1/_index.md /sec1/page.md /sec1/sec1-1/_index.md /sec1/sec1-1/page1.md /sec1/sec1-1/page2.md /sec1/sec1-1/sec1-1-1/_index.md /sec1/sec1-1/sec1-1-1/page.md /sec1/sec1-2/_index.md /sec1/sec1-2/page1.md /sec1/sec1-2/page2.md 次の表は、各ページの Page オブジェクト ($p1) の .InSection、.IsAncestor、.IsDescendant メソッドに、別ページの Page オブジェクト ($p2) を渡したときにどう判定されるかの一覧です（Hugo 0.110.0 で確認）。 → 別ウィンドウで開く $p1 がセクションの場合と通常ページの場合で振る舞いが変わったりするので若干ややこしいですが、これらのメソッドは、セクションページのみで使用する ようにすれば比較的わかりやすいコードを記述できると思います。 特に、サイドバーなどに表示するページツリーを生成するときは、.IsAncestor が true になるセクションだけを、さらに深く辿っていく ようにすれば、カレントページの上位セクションのみを開いたページツリーを生成することができます。 このテストに使用したコードはこちら: https://github.com/maku77/p-7o7ymst/ サイドバー用のページツリーを作成する 下記のパーシャルテンプレートは、現在表示中のページよりも上位のセクションを展開して、ページツリーを表示します。 /layouts/partials/nav-tree.html \u0026lt;h3\u0026gt;メニュー\u0026lt;/h3\u0026gt; {{- template \u0026#34;nav-tree-internal\u0026#34; (dict \u0026#34;section\u0026#34; .Site.Home \u0026#34;current\u0026#34; .) }} {{- define \u0026#34;nav-tree-internal\u0026#34; }} {{- $section := .section }}{{/* 今回処理するセクション */}} {{- $current := .current }}{{/* 現在表示中のページ */}} \u0026lt;ul\u0026gt; {{- /* セクション直下のセクションページをループ表示 */}} {{- range $section.Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}{{ if eq . $current }}★{{ end }}\u0026lt;/a\u0026gt; {{- if or (.IsAncestor $current) (eq . $current) }} {{- /* 開いているページよりも上位のセクション（あるいは自分自身）であればさらに辿る */}} {{- template \u0026#34;nav-tree-internal\u0026#34; (dict \u0026#34;section\u0026#34; . \u0026#34;current\u0026#34; $current) }} {{- end }} {{- end }} {{- /* セクション直下の通常ページをループ表示 */}} {{- range $section.RegularPages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}{{ if eq . $current }}★{{ end }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} 例えば、サイドバー用のパーシャルテンプレートなどから次のような感じで使用します。 /layouts/partials/side-bar.html {{ partial \u0026#34;nav-tree\u0026#34; . }} すると、次のような感じのツリーメニューが表示されます。 現在表示中のページには ★ マークが表示され、それよりも上位のセクションだけが展開されて表示されます。 メニュー - sec1/ - sec1-1/ - sec1-1-1/ - page1.html★ - page2.html - sec1-2/ - page.html - page.html ちなみに、ここでは最上位のホームページへのリンクは表示しないようにしています（無駄に階層が 1 つ深くなってしまうため）。 トップページのリンクを表示したいときは、下記のように個別に表示すればよいでしょう。 \u0026lt;a href=\u0026#34;{{ \u0026#34;/\u0026#34; | relURL }}\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;"},{url:"/p/co8p6n4/",title:"Hugo で各種ページの .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧",date:"2018-01-11T00:00:00Z",body:"Hugo で各種ページの .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧 Hugo のテンプレートで、ページの種類によって条件分岐するコードを記述するには、レンダリング時のコンテキストにおいて、.Kind の値や .IsPage などの値がどう変化するかを知っておく必要があります。 ページ種類 .RelPermalink の例 .Section .Type .Kind .IsHome .IsNode .IsPage .IsSection ホームページ / nil page home true true false false セクションページ（第 1 階層） /sec1/ sec1 sec1 section false true false true セクションページ（第 2 階層） /sec1/sec2/ sec1 sec1 section false true false true タクソノミーターム /tags/ tags tags taxonomy ※ false true false false タクソノミーリスト /tags/xxx/ tags tags term ※ false true false false 404 ページ nil nil page 404 false true false false 記事ページ（第 1 階層） /mypage/ nil page page false false true false 記事ページ（第 2 階層） /sec1/mypage/ sec1 sec1 page false false true false 記事ページ（第 3 階層） /sec1/sec2/mypage/ sec1 sec1 page false false true false ☝️ ※ taxonomy と term という名前 Hugo v0.73 において taxonomyTerm → taxonomy、taxonomy → term という .Kind 値の変更が入っているので、バージョンアップ時はご注意ください。 上記の値は、次のようなテンプレートコードを、ベーステンプレート (layouts/_default/baseof.html) に記述して調べています（2020-04-27: .IsSection を追記、.URL (deprecated) を .RelPermalink に変更）。 \u0026lt;pre\u0026gt; .RelPermalink = {{ .RelPermalink }} .Section = {{ .Section }} .Type = {{ .Type }} .Kind = {{ .Kind }} .IsHome = {{ .IsHome }} .IsNode = {{ .IsNode }} .IsPage = {{ .IsPage }} .IsSection = {{ .IsSection }} \u0026lt;/pre\u0026gt; これらの情報を使って分岐処理するときの方針としては、まずは、大まかに .IsHome、.IsNode、.IsPage、.IsSection の値で分岐できないかを考え、もう少し細かい分岐処理が必要であれば、.Kind の値を利用する、という感じにするとよいでしょう。 次の例では、title 要素のテキストを構築するときに、.IsHome の値を使って分岐処理しています。 ホームページの場合は「サイト名」だけを表示し、その他のページでは「ページタイトル｜サイト名」のように連結して表示するようにしています。 \u0026lt;title\u0026gt;{{ if not .IsHome }}{{ .Title }}｜{{ end }}{{ .Site.Title }}\u0026lt;/title\u0026gt; あるいは、cond 関数を利用して次のように書くこともできます。 \u0026lt;title\u0026gt;{{ cond .IsHome .Site.Title (print .Title \u0026#34;｜\u0026#34; .Site.Title)}}\u0026lt;/title\u0026gt;"},{url:"/p/bbxj5pa/",title:"Hugo のベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html)",date:"2018-01-10T00:00:00Z",body:"Hugo のベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html) ベーステンプレートの仕組み Hugo のベーステンプレート機能を利用すると、各種テンプレートの親テンプレートのようなものを作成することができます。 ベーステンプレートを作成することで、すべてのページの HTML 構成を統一することができ、個々のテンプレートの見通しもよくなります。 Hugo では、リストテンプレートやシングルページテンプレートなど、用途によって別々のテンプレートファイルを用意することになっています。 でも、HTML 全体の大まかな構成は共通した部分が多いはずです。 例えば、どのページでも HTML は次のような構成になっているはずです。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;html\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; ... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ... \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Hugo のベーステンプレート機能を使用すると、上記のような全体の構成をベーステンプレート (baseof.html) として作成し、その中の部分的なブロックだけを通常のテンプレート（リストテンプレートやシングルページテンプレート）で定義した内容で置き換えるということができます。 図: ベーステンプレートの仕組み Hugo のベーステンプレート機能は、Go のテンプレートライブラリの block template という仕組みを使用しており、block で定義した部分を、define で定義した内容で置き換えるという動作をします。 上の図を見ると分かりやすいと思いますが、ベーステンプレート (baseof.html) を用意すると、基本的にすべてのページがベーステンプレートを利用してレンダリングされるようになり、その中の部分的なブロック（上記では main という名前のブロック）が子テンプレートで定義した内容で置き換えられます。 このとき、どの子テンプレートが使用されるかは、ベーステンプレートの仕組みを使用しない場合と同様で、表示するページの種類によって決まります。 例えば、ホームページやセクションページなどのレンダリングには list.html が使用され、個々の記事ページのレンダリングには single.html が使用されます。 具体的なベーステンプレートの利用例 下記はベーステンプレートの具体的な記述例です。 main 要素以下のメインコンテンツを block template の機能で置き換えるようにしています。 layouts/_default/baseof.html（ベーステンプレート） \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ \u0026#34;assets/css/main.css\u0026#34; | relURL }}\u0026#34;\u0026gt; \u0026lt;title\u0026gt;{{ if not .IsHome }}{{ .Title }}｜{{ end }}{{ .Site.Title }}\u0026lt;/title\u0026gt; {{ partial \u0026#34;head/favicon\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;pageTitle\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ \u0026#34;/\u0026#34; | relURL }}\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt; {{ partial \u0026#34;menu\u0026#34; . }} \u0026lt;main id=\u0026#34;main\u0026#34;\u0026gt; {{ block \u0026#34;main\u0026#34; . }}main ブロックが見つかりません。{{ end }} \u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; layouts/_default/list.html（リストテンプレート） {{ define \u0026#34;main\u0026#34; }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ partial \u0026#34;breadcrumb\u0026#34; . }} {{ .Content }} \u0026lt;h2\u0026gt;ページリスト\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{- range .Data.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{ end }} layouts/_default/single.html（シングルページテンプレート） {{ define \u0026#34;main\u0026#34; }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ partial \u0026#34;breadcrumb\u0026#34; . }} {{ partial \u0026#34;tags-in-page\u0026#34; . }} {{ .Content }} {{ end }} 子テンプレートにはテキスト出力するコードを入れない ベーステンプレート（親テンプレート）を使用したレンダリングを行いたい場合は、子テンプレート側では何も出力しないようにする必要があるようです。 例えば、下記のシングルページテンプレートでは、部分テンプレート main を定義していますが、その直後に「こんにちは！」と出力しています。 layouts/_default/single.html {{ define \u0026#34;main\u0026#34; }} メインコンテンツ１ {{ end }} こんにちは！ このように記述してしまうと、シングルページレイアウトには、ベーステンプレート (baseof.html) によるレイアウトが適用されなくなり、「こんにちは！」としか表示されなくなってしまうようです。 逆に、ベーステンプレートを適用したくないテンプレートファイルでは、そのテンプレートファイルだけで出力を完結してしまえばよいということですね。"},{url:"/p/xuwd7tn/",title:"Hugo でサイト内の全ページの一覧をセクションの階層構造に従って表示する",date:"2018-01-09T00:00:00Z",body:"Hugo でサイト内の全ページの一覧をセクションの階層構造に従って表示する 現在の階層のページ一覧を出力するテンプレートを再帰的に呼び出すようにすると、サイト内の全てのセクションとページを、ツリー構造で表示することができます。 すべてのページのリンクが出力されるので、サイトマップの出力に使用したり、ホームページ用のテンプレートに利用するとよいでしょう。 ツリー出力の基本 下記は、サイト内のすべてのページをツリー形式で表示するサンプルテンプレートです。 セクション変数の .Pages を参照すると、そのセクションに含まれるサブセクションや通常ページを取得することができるので、それを range でループ処理しています。 部分テンプレート hierarchy を定義し、これをホームページ (.Site.Home) から再帰的に呼び出すことで全ページのツリー構造を出力しています。 layouts/index.html（抜粋） \u0026lt;h2\u0026gt;全ページのリスト\u0026lt;/h2\u0026gt; {{- define \u0026#34;hierarchy\u0026#34; }} \u0026lt;ul\u0026gt; {{- range .Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- if .IsSection }}{{ template \u0026#34;hierarchy\u0026#34; . }}{{ end }} {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{ template \u0026#34;hierarchy\u0026#34; .Site.Home }} 出力結果のイメージ（実際には各項目がリンクになります） * タイトル A * セクション 1 * セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * タイトル B * タイトル C * セクション 2 * セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B ここでは、hierarchy のパラメータとして .Site.Home を渡しているため、サイト全体のページツリーが出力されていますが、任意のセクションをルートにしてページツリーを出力することができます。 例えば、セクションテンプレートで次のように呼び出せば、現在のページが所属しているセクション (.CurrentSection) 以下のセクションおよびページをツリー表示できます。 {{ template \u0026#34;hierarchy\u0026#34; .CurrentSection }} セクションページを優先的に表示する ページをリスト化するときに、セクションページを通常ページよりも先に表示したいときは、例えば次のようにします。 ここでは、セクションページと通常ページを .Pages でまとめてループ処理するのではなく、.Sections でセクションページのみを先にループ処理してから、.RegularPages で通常ページをループ処理するようにしています。 layouts/index.html（抜粋） {{- define \u0026#34;hierarchy\u0026#34; }} \u0026lt;ul\u0026gt; {{- /* セクションページをループ処理 */}} {{- range .Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;📁{{ .Title }}\u0026lt;/a\u0026gt; {{- template \u0026#34;hierarchy\u0026#34; . }} {{- end }} {{- /* 通常の記事ページをループ処理 */}} {{- range .RegularPages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{ template \u0026#34;hierarchy\u0026#34; .Site.Home }} 出力結果のイメージ（セクションページが先に表示される） * 📁セクション 1 * 📁セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * 📁セクション 2 * 📁セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B * タイトル A * タイトル B * タイトル C ちなみに、セクション名の前にはフォルダアイコンを表示しています（Unicode の数値文字参照で \u0026amp;#128193; と書いても OK）。 フォルダアイコンを表示する別の方法として、Hugo の絵文字表示機能 (emojify) を使って、{{ emojify \u0026quot;:open_file_folder:\u0026quot; }} のように記述する方法もあります。 指定したセクションも含めて表示する ツリー構造が一段深くなってしまうのでオススメはしませんが、指定したセクション（ルートセクション）も含めてツリー表示するには、例えば次のように実装します。 {{- define \u0026#34;hierarchy\u0026#34; }} \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;📁{{ .Title }}\u0026lt;/a\u0026gt; {{- range .Sections }} {{- template \u0026#34;hierarchy\u0026#34; . }} {{- end }} {{- range .RegularPages }} \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{ template \u0026#34;hierarchy\u0026#34; .Site.Home }} 次のように、ホームページをルートとしてツリー表示されます。 出力結果のイメージ * 📁ホーム * 📁セクション 1 * 📁セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * 📁セクション 2 * 📁セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B * タイトル A * タイトル B * タイトル C 2 階層目までを表示する 下記の例では、hierarchy ローカルテンプレートに level というパラメータを追加し、そのパラメータで指定した階層までのページリストを表示するように変更したものです。 ここでは level に 2 を指定して、2 階層目までのページをツリー出力しています。 layouts/index.html（抜粋） \u0026lt;h2\u0026gt;2 階層目までのページのリスト\u0026lt;/h2\u0026gt; {{- define \u0026#34;hierarchy\u0026#34; }} {{- $section := .section }} {{- $level := .level }} \u0026lt;ul\u0026gt; {{- range $section.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ if .IsSection }}📁{{ end }}{{ .Title }} {{- if and .IsSection (gt $level 1) }} {{- template \u0026#34;hierarchy\u0026#34; (dict \u0026#34;section\u0026#34; . \u0026#34;level\u0026#34; (sub $level 1)) }} {{- end }} \u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{ template \u0026#34;hierarchy\u0026#34; (dict \u0026#34;section\u0026#34; .Site.Home \u0026#34;level\u0026#34; 2) }} 出力結果のイメージ * タイトル A * 📁セクション 1 * セクション 1-1 * タイトル 1-A * タイトル 1-B * タイトル B * タイトル C * 📁セクション 2 * 📁セクション 2-1 hierarchy テンプレートを再帰呼び出しするときに、sub 関数で level パラメータの値を 1 つずつ減らすことで、再帰処理を途中で止めるようにしています。"},{url:"/p/vqran9d/",title:"CSS のふくろうセレクターで全要素の上下マージンを設定する",date:"2018-01-08T00:00:00Z",body:"CSS のふくろうセレクターで全要素の上下マージンを設定する HTML の各要素の上下のマージンを、それぞれの要素の margin-top や margin-bottom で設定していると、ちょっとした調整が全体のレイアウトの崩れにつながります。 Owl セレクタ（ふくろうセレクタ） と呼ばれている * + * という CSS セレクタを利用すると、全要素のマージンをまとめて設定することができるので、サイト全体のレイアウトに一貫性を持たせることができます。 * + * という指定は、ユニバーサルセレクタ (*) と隣接セレクタ (+) の組み合わせから成っており、要するに、連続する 2 番目以降の要素をすべて選択するという意味になります。 * + * によって選択された要素の上マージン (margin-top) を設定してやることで、要素間のマージンをまとめて設定できます。 下記の例では、main 要素直下に配置された、すべての要素間に 1rem のマージンを設定しています（つまり、そのページのフォントサイズで１行分のマージン）。 CSS * { margin: 0; /* ブラウザ依存のマージンはリセット */ } html { font-size: 100%; /* ユーザの指定した表示サイズを尊重する */ line-height: 1.5; } main \u0026gt; * + * { margin-top: 1rem; /* サイト全体で上下マージンを統一 */ } main \u0026gt; * + h2, main \u0026gt; * + h3, main \u0026gt; * + h4, main \u0026gt; * + h5, main \u0026gt; * + h6 { margin-top: 1.5em; /* ヘッダ要素の上マージンは広めに取る */ } ただし、h2 や h3 などのヘッダの上マージンまで同じサイズになってしまうと、セクションごとのまとまりが分かりにくくなってしまいます。 そこで、ヘッダに関しては特別に 1.5em のマージンを設定しています。 このマージンには、単位として rem ではなく、em を使用していることに注意してください。 em を使用することで、ヘッダ自身のフォントサイズを基準として、1.5 行分のマージンが設定されることになります。 つまり、h2 要素のマージンの方が、h3 要素のマージンよりも大きくなるということです（h2 のフォントサイズの方が大きければですが）。 参考サイト: Axiomatic CSS and Lobotomized Owls"},{url:"/p/xwog7ip/",title:"Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re)",date:"2018-01-07T00:00:00Z",body:"Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re) replace_files.py 複数のテキストファイル内の文字列を一気に置換してしまう Python スクリプトの実装例を紹介します。 ここでは、カレントディレクトリ以下の Markdown ファイル (.md) 内の時刻情報を書き換えてみます。 置換対象のテキストは、下記のような日付情報を表すテキストです（created: の部分を date: に置き換えます）。 （置換前のテキスト）created: \u0026quot;2018-01-01\u0026quot; （置換後のテキスト）date: \u0026quot;2018-01-01\u0026quot; replace_files.py import glob import re GLOB = \u0026#39;**/*.md\u0026#39; REPLACE_FROM = re.compile(r\u0026#39;created: (\\d{4}-\\d{2}-\\d{2})\u0026#39;) REPLACE_TO = r\u0026#39;date: \u0026#34;\\1\u0026#34;\u0026#39; def write_lines(filename, lines): with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: f.write(lines) def read_lines(filename): with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as f: return f.read() def process_file(filename): src_lines = read_lines(filename) dst_lines = REPLACE_FROM.sub(REPLACE_TO, src_lines) if src_lines == dst_lines: print(filename) else: write_lines(filename, dst_lines) print(filename + \u0026#39;: CHANGED\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: for filename in glob.iglob(GLOB, recursive=True): process_file(filename) このスクリプトを実行すると、既存のファイル自体を書き換えることに注意してください（実行する前に、必ずバックアップを取ってください）。 置換パターンに一致する行が見つからなかった場合は、そのファイルに対する書き換え処理は行われません（同じ内容を書き戻すような無駄な処理はしません）。 実行例 $ python replace_files.py python/io/basename.md: CHANGED python/io/yaml.md: CHANGED python/io/user-input.md: CHANGED python/io/script-path.md: CHANGED ... ☝️ ワンポイント 上記のサンプルコードでは、パターンに一致する部分のうち、最初に見つかった部分だけを置換します。 パターンに一致する全ての文字列を置換したい場合は、sub メソッドの代わりに gsub メソッドを使用してください。 参考 Python で文字列を置換する (str.replace, re.sub, re.subn)"},{url:"/p/on7omgt/",title:"JavaScript で HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索",date:"2018-01-06T00:00:00Z",body:"JavaScript で HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索 タグ名で要素を取得する (getElementsByTagName) document.getElementsByTagName() 関数を使用すると、指定したタグ名を持つ要素を取得することができます。 同じタグ名を持つ要素は複数存在する可能性があるので、戻り値は配列になります。 例: p 要素をすべて取得する \u0026lt;p\u0026gt;こんにちは\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;おやすみ\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; window.onload = function() { const elems = document.getElementsByTagName(\u0026#34;p\u0026#34;); for (const e of elems) { console.log(e.innerText); } }; \u0026lt;/script\u0026gt; 実行結果 こんにちは おやすみ クラス名で要素を取得する (getElementsByClassName) document.getElementsByClassName() 関数を使用すると、指定したクラス名が class 属性に含まれている要素を取得することができます。 そのような要素は複数存在する可能性があるので、戻り値は配列になります。 \u0026lt;div class=\u0026#34;foo\u0026#34;\u0026gt;AAA\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;foo bar\u0026#34;\u0026gt;BBB\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;foo bar baz\u0026#34;\u0026gt;CCC\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; window.onload = function() { const elems = document.getElementsByClassName(\u0026#34;foo\u0026#34;); for (const e of elems) { console.log(e.innerText); } }; \u0026lt;/script\u0026gt; 実行結果 AAA BBB CCC ID で要素を取得する (getElementById) document.getElementById() 関数を使用すると、指定した ID を id 属性に持つ要素を取得することができます。 指定した ID を持つ要素が見つからない場合は null を返します。 例: id 属性に message が含まれている要素を取得する \u0026lt;span id=\u0026#34;message\u0026#34;\u0026gt;ばよえーん\u0026lt;/span\u0026gt; \u0026lt;script\u0026gt; window.onload = function() { const elem = document.getElementById(\u0026#34;message\u0026#34;); if (elem) { console.log(elem.innerText); //=\u0026gt; ばよえーん } }; \u0026lt;/script\u0026gt; 特定の ID を持つ要素は高々ひとつしか存在することができないので、getElementsByTagName や getElementsByClassName とは異なり、getElementById は単一の要素を返すことに注意してください。 子要素からのみ検索する document の代わりに、特定の親要素に対して前述のメソッドを呼び出すようにすれば、その子要素だけを検索対象とすることができます。 下記の例では、まず ID で要素を検索し、次にタグ名による検索を行なっています。 子要素の検索 \u0026lt;ul id=\u0026#34;my-data\u0026#34;\u0026gt; \u0026lt;li\u0026gt;AAA\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;BBB\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;CCC\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; window.onload = function() { const data = document.getElementById(\u0026#34;my-data\u0026#34;); const elems = data.getElementsByTagName(\u0026#34;li\u0026#34;); for (const e of elems) { console.log(e.innerText); } }; \u0026lt;/script\u0026gt; 実行結果 AAA BBB CCC セレクタ API で要素を取得する (querySelector, querySelectorAll) CSS のセレクタ形式（#foo や .bar など）で要素を指定して取得したいときは、document.querySelector() 関数や document.querySelectorAll() 関数を使用します。 前者は最初に見つかった要素、後者は見つかった全ての要素を返します。 例: id 属性が sample の要素を取得 window.onload = function() { const elem = document.querySelector(\u0026#34;#sample\u0026#34;); console.log(elem); }; 例: class 属性に sample を持つ要素をすべて取得 window.onload = function() { const elems = document.querySelectorAll(\u0026#34;.sample\u0026#34;); console.log(elems); }; 例: div 要素で、かつ、class 属性に note を持つ要素をすべて取得 window.onload = function() { const elems = document.querySelectorAll(\u0026#34;div.note\u0026#34;); console.log(elems); }; 例: li 要素で、偶数番目のものをすべて取得 window.onload = function() { const elems = document.querySelectorAll(\u0026#34;li:nth-child(even)\u0026#34;); console.log(elems); }; ☝️ jQuery と同じ？ jQuery が登場した当初は、このようなセレクタ API が使えることがひとつのウリでした。 現在は JavaScript の機能として querySelectAll() が使えるようになっているので、セレクタ API だけのために jQuery を使用する必要はなくなりました。"},{url:"/p/vemn3c4/",title:"Hugo でパンくずリストを表示する",date:"2018-01-02T00:00:00Z",body:"Hugo でパンくずリストを表示する パンくずリストは、親ページに素早くジャンプするための次のようなリンクです。 ホーム \u0026gt; セクション1 \u0026gt; セクション2 \u0026gt; ページタイトル ここでは、Hugo のテンプレート機能を使って、パンくずリストを出力する方法を説明します。 パンくずリストを表示するためのテンプレート 下記は、パンくずリストを出力するための breadcrumb テンプレートの定義です（Hugo 本家で紹介されているコードを参考にしています）。 {{- define \u0026#34;breadcrumb\u0026#34; }} {{- if .node.Parent }} {{- template \u0026#34;breadcrumb\u0026#34; (dict \u0026#34;node\u0026#34; .node.Parent \u0026#34;start\u0026#34; .start) }} {{- else if not .node.IsHome }} {{- template \u0026#34;breadcrumb\u0026#34; (dict \u0026#34;node\u0026#34; .node.Site.Home \u0026#34;start\u0026#34; .start) }} {{- end }} {{- if eq .node .start }} \u0026lt;li\u0026gt;{{ .node.LinkTitle }} {{- else }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .node.Permalink }}\u0026#34;\u0026gt;{{ .node.LinkTitle }}\u0026lt;/a\u0026gt; {{- end }} {{- end }} 実際にパンくずリストを出力したい部分で下記のように呼び出します。 \u0026lt;ol class=\u0026#34;breadcrumb\u0026#34;\u0026gt; {{- template \u0026#34;breadcrumb\u0026#34; (dict \u0026#34;node\u0026#34; . \u0026#34;start\u0026#34; .) }} \u0026lt;/ol\u0026gt; さらに、下記のようなスタイルを適用すれば、リンクがいい感じで横方向に並んでくれます。 .breadcrumb { padding: 0; } .breadcrumb li { display: inline; list-style: none; } .breadcrumb li:not(:last-child)::after { content: \u0026#39;\u0026gt;\u0026#39;; padding: 0 0.5em; } 表示イメージ ホーム \u0026gt; セクション1 \u0026gt; セクション2 \u0026gt; ページタイトル ☝️ ワンポイント ここでは、リンクタイトルとして、.LinkTitle で取得したページタイトルを表示しています。 記事のフロントマターに、linkTitle プロパティが設定されている場合、title の設定よりも優先して表示されます。 linkTitle に短めのタイトルを設定しおくことで、パンくずリストをシンプルに表示できます。 解説 パンくずリストを作成する基本的な考え方は、自分自身のページから親ページを辿るという方法です。 Hugo では、.Parent で親ページ（親セクション）を参照することができるので、下記のように再帰的に .Parent を辿っていくことで、最上位のホームページまで辿ることができます（ホームページまで到達すると .Parent の値が nil になるのでそこで再帰呼び出しが止まります）。 {{- define \u0026#34;breadcrumb\u0026#34; }} {{- if .Parent }} {{- template \u0026#34;breadcrumb\u0026#34; .Parent }} {{- end }} \u0026lt;li\u0026gt;{{ .Title }} {{- end }} \u0026lt;ol\u0026gt; {{- template \u0026#34;breadcrumb\u0026#34; . }} \u0026lt;/ol\u0026gt; 例えば、ホームページから見て 2 階層下のセクション内のページで、上記のテンプレートを適用すると、次のような HTML が出力されます。 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;ホームページ \u0026lt;li\u0026gt;セクション \u0026lt;li\u0026gt;サブセクション \u0026lt;li\u0026gt;サブセクション内の記事タイトル \u0026lt;/ol\u0026gt; 通常の記事ページやセクションページでパンくずリストを表示するときは、このアルゴリズムで十分なのですが、これだけだと、タクソノミーリスト（あるタグを持つ記事一覧）のページを表示するケースで、最上位にホームページが表示されません。 なぜなら、タクソノミーリストのページで .Parent を参照してもホームページを取得することはできず、nil になってしまうからです。 パンくずリストの最上位に必ずホームページを表示するには、下記のように else if を追加する必要があります。 {{- define \u0026#34;breadcrumb\u0026#34; }} {{- if .Parent }} {{- template \u0026#34;breadcrumb\u0026#34; .Parent }} {{- else if not .IsHome }} {{- template \u0026#34;breadcrumb\u0026#34; .Site.Home }} {{- end }} \u0026lt;li\u0026gt;{{ .Title }} {{- end }} \u0026lt;ol\u0026gt; {{- template \u0026#34;breadcrumb\u0026#34; . }} \u0026lt;/ol\u0026gt; 親ページが見つからなかったときに、自分自身がホームページではないとすると、自分自身はタクソノミーリストのページだと考えられます。 なので、そのようなケースでは、強制的に .Site.Home をパラメータに渡して、ホームページを出力するようにしています。 上記のテンプレートを、タクソノミーリストのページに適用すると、例えば下記のような感じで表示されます（正しく先頭にホームページが表示されます）。 \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;ホームページ \u0026lt;li\u0026gt;タグ１ \u0026lt;/ol\u0026gt; あとは、リンク出力やスタイル定義などを加えてあげれば、立派なパンくずリストが完成します。"},{url:"/p/pkww45p/",title:"Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき）",date:"2018-01-01T00:00:00Z",body:"Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき） Hugo のテンプレートファイル内で define を使用すると、部分的なテンプレートを定義することができ、別の場所から関数のように呼び出すことができます。 define による部分テンプレート定義の基本 Hugo のテンプレート定義は、基本は layouts ディレクトリ内に置いたテンプレートファイル（HTML ファイル）単位で行うのですが、そのテンプレートファイルの中で、define アクションを使用することで、入れ子でテンプレート定義を行うことができます。 テンプレートファイル内で使える関数定義のようなもの だと思うと分かりやすいです。 次の例では、define を使用して、showParentSection というテンプレートを定義しています。 showParentSection テンプレートを定義する {{/* セクションの一覧を出力します */}} {{ define \u0026#34;showParentSection\u0026#34; }} \u0026lt;h2\u0026gt;セクション一覧\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{- range .Site.Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{ end }} define で定義したテンプレートを呼び出すには、template 関数を使用します。 {{ template \u0026#34;showParentSection\u0026#34; . }} 2 番目のパラメータで渡した値が、部分テンプレート側のドットコンテキスト (.) として参照できるようになります。 多くの場合は、上記のようにドット (.) を指定し、Page オブジェクトを参照できるようにします。 複数のパラメータを受け取る部分テンプレートを定義する template 関数を使って部分テンプレートを呼び出すときは、引数に . を指定して Page オブジェクトを渡すことが多いのですが、単純な文字列や数値をパラメータとして渡すこともできます。 次の例では、パラメータで渡された名前を使って挨拶文を出力する greet テンプレートを定義しています。 greet テンプレートを定義する {{ define \u0026#34;greet\u0026#34; }} Hello, {{ . }}! {{ end }} この greet テンプレートを呼び出すには次のようにします。 {{ template \u0026#34;greet\u0026#34; \u0026#34;Maku\u0026#34; }} 出力結果 Hello, Maku! パラメータとして マップオブジェクト を渡せば、名前付きパラメータを実現できます。 次の例で定義している calc テンプレートは、x と y というキーを含むマップオブジェクトを受け取ることを想定しています。 {{ define \u0026#34;calc\u0026#34; }} {{ printf \u0026#34;%d+%d=%d\u0026#34; .x .y (add .x .y) }} {{ end }} この calc テンプレートは次のように呼び出します。 マップオブジェクトを作成するときは、dict 関数のパラメータに、キーと値を交互に指定します。 {{ template \u0026#34;calc\u0026#34; (dict \u0026#34;x\u0026#34; 100 \u0026#34;y\u0026#34; 200) }} 出力結果 100+200=300 ☝️ ワンポイント マップオブジェクトを受け取る部分テンプレートを定義するときは、次のように先頭でローカル変数（$x や $y）に代入してしまう慣例もあるようです。 このように記述しておくことで、この部分テンプレートにどのようなキーを持つマップオブジェクトを渡せばよいのかが一目で分かるようになります。 {{ define \u0026#34;calc\u0026#34; }} {{ $x := .x }} {{ $y := .y }} {{ printf \u0026#34;%d+%d=%d\u0026#34; $x $y (add $x $y) }} {{ end }} パーシャルテンプレートとの違い layouts/partials/foo.html というファイル名で作成したパーシャルテンプレートは、次のように partial を使って呼び出します。 {{ partial \u0026#34;foo\u0026#34; . }} 一方で、define で定義した部分テンプレート（Go のドキュメントでは nested template と呼んでいます）は、次のように template を使って呼び出します。 {{ template \u0026#34;foo\u0026#34; . }} 呼び出し方がちょっと異なるだけで、ほとんど同じような感覚で使えるようです。 使い分けの基準としては、 複数のテンプレートファイルから共通で使用するものは、パーシャルテンプレート (layouts/partials/xxx.html) として定義する。 1 つのテンプレートファイル内でのみ使用する部分テンプレートは、define による部分テンプレートとして定義する。 と考えておけばよいでしょう。 応用: Hugo のパーシャルテンプレートから値を返す（関数化）"},{url:"/p/topd7uy/",title:"Hugo で記事ページに付けられたターム一覧（タグ一覧）を表示する",date:"2018-01-01T00:00:00Z",body:"Hugo で記事ページに付けられたターム一覧（タグ一覧）を表示する シングルページテンプレートにおいて、その記事ページに付けられたタグの一覧を表示するようにしておくと、関連する記事（同じタグの付けられた記事）を探しやすくなります。 タクソノミーターム（タグやカテゴリ）は、各ページの front matter 部分で定義するので、ページ変数 (.Params) 経由でその情報を取得することができます。 次のパーシャルテンプレートは、記事ページに付けられたタグの情報を取得し、リスト形式で出力します。 layouts/partials/tags-in-page.html \u0026lt;ul class=\u0026#34;tags\u0026#34;\u0026gt; {{- range .Params.tags -}} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ \u0026#34;/tags/\u0026#34; | relLangURL }}{{ . | urlize }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/ul\u0026gt; タグが設定されていない場合に、先頭の ul 要素ごと出力しないようにするには、ちょっとだけ変えて下記のようにします。 {{ with .Params.tags }} \u0026lt;ul class=\u0026#34;tags\u0026#34;\u0026gt; {{- range . -}} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ \u0026#34;/tags/\u0026#34; | relLangURL }}{{ . | urlize }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/ul\u0026gt; {{ end }} 上記のパーシャルテンプレートを使用するときは、シングルページテンプレート内で次のように記述します。 layouts/_default/single.html {{ partial \u0026#34;tags-in-page\u0026#34; . }} デフォルトでは、li 要素は単純な箇条書きのリスト形式で表示されてしまいます。 次のようなスタイルを定義しておくと、それっぽく横並びで表示されてよい感じになります。 CSS .tags { padding: 0; } .tags li { display: inline-block; /* 横に並べる */ list-style-type: none; margin-right: 0.5em; } .tags li a { display: block; /* 選択範囲を広げる */ text-decoration: none; padding: 0.5em 1em; background: lightgray; color: #333; } .tags li a:hover { background: #555; color: white; } 実際に表示すると次のような感じになります。"},{url:"/p/5v7o2xp/",title:"Hugo で記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする",date:"2018-01-01T00:00:00Z",body:"Hugo で記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする Hugo の仕組みでは、1 つのタクソノミーに割り当てられるタームの数を制限することはできません。 ここでは、複数のタームを割り当ててしまった場合に、エラー表示を行う方法を紹介します。 １つの記事ページに複数のタグを付けるのはよくあることですが、Web サイトのポリシーによっては、1 つの記事に付けられるカテゴリーは 1 つまでに制限したい、ということがあるかもしれません。 Hugo のデフォルトの仕組みでは、そのような制限はできないのですが、複数のカテゴリが付けられた記事を表示したときに、ログとページ上にメッセージを表示することはできます。 下記のシングルページテンプレートでは、categories タクソノミーに 2 つ以上の値（ターム）が設定されている場合に警告メッセージを出力しています。 errorf 関数を使ってテキスト出力を行うことで、画面上への出力と同時に、コンソール上にもエラーメッセージを出力することができます。 layouts/_default/single.html（抜粋） {{ if .Params.categories }} {{ if gt (len .Params.categories) 1 }} \u0026lt;b\u0026gt;{{ errorf \u0026#34;カテゴリが 1 つ以上設定されています！\u0026#34; }}\u0026lt;/b\u0026gt; {{ end }} {{ end }} ☝️ ワンポイント len .Params.categories を実行するときに、.Params.categories が存在しないと nil dereference のエラーが発生してしまいます。 そのため、最初に if .Params.categories という存在チェックを入れています。 例えば、記事ページの先頭のフロントマターで、下記のように複数のカテゴリを割り当てるような記述をすると、上記の警告メッセージが表示されます。 content/sample-page.md --- title: \u0026#34;サンプルページ\u0026#34; categories: [\u0026#34;カテゴリ1\u0026#34;, \u0026#34;カテゴリ2\u0026#34;] --- サンプルページの本文。"},{url:"/p/tfk4tdg/",title:"Hugo でサイト全体のターム一覧（タグ一覧）を表示する",date:"2017-12-31T00:00:00Z",body:"Hugo でサイト全体のターム一覧（タグ一覧）を表示する Web サイトのサイドバーなどに、タクソノミータームの一覧（つまりタグの一覧、タグクラウドなど）を表示しておくと、同じ系統の記事に素早くアクセスできて便利です。 ここでは、タクソノミーとして Hugo デフォルトの tags と categories が定義されていることを前提とします。 特定のタクソノミーのターム一覧を表示（タグの一覧を表示する） ここでは、tags タクソノミーに含まれているターム一覧を表示する例を示します（つまりタグの一覧です）。 多くのサイトでは、使用するタクソノミーの数は限られている（デフォルトの tags や categories で間に合うことが多い）ので、この使い方が一番多いかもしれません。 テンプレートの実装 \u0026lt;h3\u0026gt;タグ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range $termName, $entries := .Site.Taxonomies.tags }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ \u0026#34;/tags/\u0026#34; | relLangURL }}{{ $termName | urlize }}\u0026#34;\u0026gt;{{ $termName }}\u0026lt;/a\u0026gt; ({{ $entries.Count }}) {{- end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;h3\u0026gt;タグ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B01\u0026#34;\u0026gt;タグ1\u0026lt;/a\u0026gt; (5) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B02\u0026#34;\u0026gt;タグ2\u0026lt;/a\u0026gt; (10) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B03\u0026#34;\u0026gt;タグ3\u0026lt;/a\u0026gt; (15) \u0026lt;/ul\u0026gt; 各リンクの後ろには、そのタグを含むページの数を表示しています。 ページ数の多い順に列挙するには次のようにします。 テンプレートの実装 \u0026lt;h3\u0026gt;タグ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range .Site.Taxonomies.tags.ByCount }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ \u0026#34;/tags/\u0026#34; | relLangURL }}{{ .Term | urlize }}\u0026#34;\u0026gt;{{ .Term }}\u0026lt;/a\u0026gt; ({{ .Count }}) {{- end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;h3\u0026gt;タグ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B03\u0026#34;\u0026gt;タグ3\u0026lt;/a\u0026gt; (15) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B02\u0026#34;\u0026gt;タグ2\u0026lt;/a\u0026gt; (10) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B01\u0026#34;\u0026gt;タグ1\u0026lt;/a\u0026gt; (5) \u0026lt;/ul\u0026gt; ターム一覧と、そのタームに所属するページを列挙する タグ別にページの一覧まで表示してしまいたい場合は次のようにします。 テンプレートの実装 \u0026lt;h3\u0026gt;タグ別ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range $termName, $entries := .Site.Taxonomies.tags }} \u0026lt;li\u0026gt;{{ $termName }} \u0026lt;ul\u0026gt; {{- range $entries.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;h3\u0026gt;タグ別ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;タグ1 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page1/\u0026#34;\u0026gt;記事ページ1\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page2/\u0026#34;\u0026gt;記事ページ2\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;タグ2 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page3/\u0026#34;\u0026gt;記事ページ3\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page4/\u0026#34;\u0026gt;記事ページ4\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;タグ3 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page2/\u0026#34;\u0026gt;記事ページ2\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/page4/\u0026#34;\u0026gt;記事ページ4\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 全タクソノミーのターム一覧を表示 タクソノミーが tags や categories 以外にもたくさん定義されている場合、全てのタクソノミーをループ処理で出力してしまうのがよいかもしれません。 下記の例では、1 つ目の range ループですべてのタクソノミーをループ処理し、2 つ目の range ループで各タクソノミー内のタームをループ処理しています。 テンプレートの実装 \u0026lt;h3\u0026gt;全タクソノミーのターム一覧を表示\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range $taxonomyName, $taxonomy := .Site.Taxonomies }} {{- $taxonomyUrl := print (\u0026#34;/\u0026#34; | relLangURL) ($taxonomyName | urlize) }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ $taxonomyUrl }}\u0026#34;\u0026gt;{{ $taxonomyName }}\u0026lt;/a\u0026gt; \u0026lt;ul\u0026gt; {{- range $termName, $entries := $taxonomy }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ print $taxonomyUrl \u0026#34;/\u0026#34; ($termName | urlize) }}\u0026#34;\u0026gt;{{ $termName }}\u0026lt;/a\u0026gt; ({{ $entries.Count }}) {{- end }} \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;h3\u0026gt;全タクソノミーのターム一覧を表示\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/categories\u0026#34;\u0026gt;categories\u0026lt;/a\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/categories/%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA1\u0026#34;\u0026gt;カテゴリ1\u0026lt;/a\u0026gt; (7) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/categories/%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA2\u0026#34;\u0026gt;カテゴリ2\u0026lt;/a\u0026gt; (3) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/categories/%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA3\u0026#34;\u0026gt;カテゴリ3\u0026lt;/a\u0026gt; (9) \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags\u0026#34;\u0026gt;tags\u0026lt;/a\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B01\u0026#34;\u0026gt;タグ1\u0026lt;/a\u0026gt; (5) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B02\u0026#34;\u0026gt;タグ2\u0026lt;/a\u0026gt; (10) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B03\u0026#34;\u0026gt;タグ3\u0026lt;/a\u0026gt; (15) \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; タクソノミーごとにタームの一覧情報だけ出力すればよいのであれば、$.Site.GetPage を組み合わせて使用することで、もう少しシンプルに記述することができます。 {{- range $taxonomyName, $taxonomy := .Site.Taxonomies }} \u0026lt;h2\u0026gt;{{ $taxonomyName }}\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{- range ($.Site.GetPage \u0026#34;taxonomyTerm\u0026#34; $taxonomyName).Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} さらに、タームが付加されている各ページへのリンクをすべて表示したいのであれば、次のような感じで記述すればよいでしょう。 \u0026lt;h1\u0026gt;全ページのタクソノミー別リンク\u0026lt;/h1\u0026gt; {{- range $taxonomyName, $taxonomy := .Site.Taxonomies }} \u0026lt;h2\u0026gt;{{ $taxonomyName }}\u0026lt;/h2\u0026gt; {{- range $termName, $entries := $taxonomy }} \u0026lt;h3\u0026gt;{{- $termName }}\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range $entries.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink}}\u0026#34;\u0026gt;{{ .LinkTitle }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{- end }} 出力結果は長くなってしまうので省略します。 大きなサイトではあまりにも巨大なリンク集になってしまうので使いものにならないかもしれませんが、小規模なサイトでは、タクソノミー別のサイトマップを作成したいときに使えるかもしれません。"},{url:"/p/aqchnnq/",title:"Hugo でタクソノミー関連のテンプレートを定義する",date:"2017-12-31T00:00:00Z",body:"Hugo でタクソノミー関連のテンプレートを定義する あるタクソノミーに所属するタームの一覧（例えばタグの一覧）などを表示するページは Hugo によって自動的に生成されます。 ただし、そのためのレイアウト（テンプレート）ファイルをあらかじめ作成しておく必要があります。 タクソノミー関連の２種類のテンプレート タクソノミー関連のテンプレートには、大きく分けて下記の２種類があります。 タクソノミー・ターム・テンプレート (Taxonomy Terms Template) あるタクソノミーに含まれているタームの一覧を表示するためのレイアウトです。 https://example.com/tags/ といった URL にアクセスしたときに使用されます。 タクソノミー・リスト・テンプレート (Taxonomy List Template) あるタームが付加されているページの一覧を表示するためのレイアウトです。 https://example.com/tags/mytag/ といった URL にアクセスしたときに使用されます。 以下、それぞれのテンプレートをどのように作成するかを説明していきます。 タクソノミー・ターム・テンプレートを作成する タクソノミー・ターム・テンプレートは、あるタクソノミーに所属するタームの一覧 を表示するときに使用されるテンプレートです。 例えば、tags というタクソノミーが定義されている時、このテンプレートによって https://example.com/tags/ という URL でアクセスできるタグ一覧ページが生成されます。 下記のテンプレートファイルのうち、最初に見つかったファイルがタクソノミー・ターム・テンプレートとして使用されます。 /layouts/taxonomy/\u0026lt;単数系のタクソノミー名\u0026gt;.terms.html /layouts/_default/terms.html /themes/\u0026lt;テーマ名\u0026gt;/layouts/taxonomy/\u0026lt;単数系のタクソノミー名\u0026gt;.terms.html /themes/\u0026lt;テーマ名\u0026gt;/layouts/_default/terms.html 全てのタクソノミーで共通のレイアウトを使用するのであれば、まずは layouts/_default/terms.html を作成しておけばよいでしょう。 下記のサンプルテンプレートは、対象のタクソノミーに所属するタームの一覧を表示します。 layouts/_default/terms.html（抜粋） \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {{- $plural := .Data.Plural }} {{- range $index, $term := .Data.Terms.Alphabetical }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ $.Site.LanguagePrefix }}/{{ $plural }}/{{ $term.Name | urlize }}\u0026#34;\u0026gt;{{ $term.Name }}\u0026lt;/a\u0026gt; ({{ $term.Count }}) {{- end }} \u0026lt;/ul\u0026gt; ここでは、簡略化のために \u0026lt;head\u0026gt; 要素などの記述を省略していますが、本番環境では、正しく全体の HTML コードを出力するようにしてください。 上記のようなタクソノミー・ターム・テンプレートを配置した後で、http://example.com/tags にアクセスすると、以下のような HTML がレンダリングされます（日本語のタグ名を含む URL は正しくエスケープされます）。 \u0026lt;h1\u0026gt;Tags\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B01\u0026#34;\u0026gt;タグ1\u0026lt;/a\u0026gt; (10) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B02\u0026#34;\u0026gt;タグ2\u0026lt;/a\u0026gt; (7) \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/tags/%E3%82%BF%E3%82%B02\u0026#34;\u0026gt;タグ3\u0026lt;/a\u0026gt; (12) \u0026lt;/ul\u0026gt; ここでは、tags タクソノミーに、「タグ1」「タグ2」「タグ3」というタームが存在していると仮定しています。 各リンクの後ろに表示された数字は、そのタグが付加されているページの数が表示されています。 ☝️ タームの表示順序 前述のテンプレートでは、アルファベット順にターム名を表示しています。 .Data.Terms.Alphabetical という部分を .Data.Terms.ByCount に置き換えると、ページ数の多い順にタグの一覧を表示することができます。 上記のリンクをクリックすると、そのターム（ここではタグ）が設定された記事の一覧ページにジャンプします。 そこで使われるテンプレートが、次に説明するタクソノミー・リスト・テンプレートです。 タクソノミー・リスト・テンプレートを作成する タクソノミー・リスト・テンプレートは、あるタクソノミーの、あるタームが付加されているページの一覧 を表示するときに使用されるテンプレートです。 例えば、tags タクソノミーに、mytag というタームが設定されているページの一覧は、https://example.com/tags/mytag/ という URL で表示できるのですが、そのページを生成するときに使用されます。 下記のテンプレートファイルのうち、最初に見つかったファイルがタクソノミー・リスト・テンプレートとして使用されます。 /layouts/taxonomy/\u0026lt;単数系のタクソノミー名\u0026gt;.html /layouts/_default/taxonomy.html /layouts/_default/list.html /themes/\u0026lt;テーマ名\u0026gt;/layouts/taxonomy/\u0026lt;単数系のタクソノミー名\u0026gt;.html /themes/\u0026lt;テーマ名\u0026gt;/layouts/_default/taxonomy.html /themes/\u0026lt;テーマ名\u0026gt;/layouts/_default/list.html 汎用リストテンプレートである layouts/_default/list.html は、タクソノミー・リスト・テンプレートとしても使用できるのですが、汎用リストテンプレートはホームページやセクションページのレンダリングにも使用されるものです。 セクションの記事一覧ページと、ターム別の記事一覧ページのレイアウトを異なるものにしたい場合は、layouts/_default/taxonomy.html などの専用ファイルとして作成してください。 ここでは、汎用リストテンプレートである layouts/_default/list.html を作成することにします。 layouts/_default/list.html \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{- .Content }} \u0026lt;ul\u0026gt; {{- range .Data.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink}}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; このテンプレートにより、例えば下記のような記事ページ一覧用の HTML ファイルが生成されます。 \u0026lt;h1\u0026gt;Mytag\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/post/page1/\u0026#34;\u0026gt;記事ページ１\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/post/page2/\u0026#34;\u0026gt;記事ページ２\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/post/page3/\u0026#34;\u0026gt;記事ページ３\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; 上記テンプレートも、説明用に簡略化したものなので、本番環境では head 要素などをちゃんと出力してください。"},{url:"/p/mtfmaxr/",title:"Hugo のタクソノミー機能の基本（タグやカテゴリなど）",date:"2017-12-31T00:00:00Z",body:"Hugo のタクソノミー機能の基本（タグやカテゴリなど） タクソノミーとターム Hugo では、多くのブログツールや CMS ツールと同様に、各ページに「タグ」や「カテゴリ」といった付加情報を付けてグルーピング（分類）することができます。 このグルーピング（分類）のことを タクソノミー (taxonomy) と呼んでいます。 タクソノミー (taxonomy) グルーピング（分類）のための項目名。 例えば、「タグ」や「カテゴリ」といった分類名自体がタクソノミーです。 Hugo は、デフォルトで tags と categories というタクソノミーが定義されています。 ターム (term) タクソノミーに割り当てる具体的な値。 例えば、あるページのタグとして、「経済」と「日本」という値を割り当てたとすると、「経済」と「日本」のことをタームと呼びます。 タグの一覧ページで表示される個々のタグ名がタームです。 コンテンツ（ページ）にタクソノミー・タームを割り当てる コンテンツにタクソノミーを割り当てるには、記事先頭のフロントマター部分に、タクソノミー名とそこに割り当てるターム配列を記述します。 次の例では、tags: と categories: というところでタクソノミーの設定を行なっています。 content/page.md --- title: \u0026#34;記事のタイトル\u0026#34; date: \u0026#34;2017-12-31\u0026#34; tags: [\u0026#34;タグ1\u0026#34;, \u0026#34;タグ2\u0026#34;] categories: [\u0026#34;カテゴリ1\u0026#34;, \u0026#34;カテゴリ2\u0026#34;] --- この記事では、`tags` タクソノミーとして「タグ1」「タグ2」というターム、 `categories` タクソノミーとして「カテゴリ1」「カテゴリ2」というタームを割り当てています。 Hugo のデフォルトのタクソノミーとして、tags と categories が用意されています。 上記ではそれぞれのタクソノミーに タグ1 や カテゴリ1 といったタームを設定しています。 それぞれのタクソノミーの使い方は自由ですが、 どのタクソノミーにも複数のタームを割り当てることができます。 逆に、「1 種類のタクソノミーには 1 つのタームしか割り当てられない」という設定はできません。 そのような場合は、単純にフロントマターで categories に割り当てるタームを 1 つだけにする、といった運用でカバーします（それよりは、セクションの機能（ディレクトリ階層）で分けた方がよいですね）。 参考までに、1 つのページに複数のカテゴリを割り当ててしまった場合にエラー表示する方法を こちらで紹介しています。 タクソノミータームの一覧ページ コンテンツ（記事ページ）に何らかのタクソノミーを割り当てると、タクソノミーごとのターム一覧ページが自動的に生成されます。 例えば、tags タクソノミーに含まれているタームの一覧ページ（タグの一覧ページ）は、下記のようなアドレスでアクセスできるようになります。 https://example.com/tags/ 同様に、categories タクソノミーに含まれているタームの一覧ページ（カテゴリの一覧ページ）は、下記のようなアドレスでアクセスできます。 https://example.com/categories/ ☝️ ワンポイント これは、つまり、通常の記事ページとして tags.md や categories.md という名前のファイルを作成してしまうと、上記のようなタームの一覧ページにはアクセスできなくなってしまうということを示しています。 このあたりは URL をシンプルに保つためのトレードオフですね。 上記のような一覧ページ（HTML ファイル）は Hugo の仕組みで自動的に生成されますが、デフォルトでは空っぽ（真っ白）の HTML ページが出力されるだけです。 タームの一覧ページを正しくレンダリングするには、専用のテンプレートファイルを作成しておく必要があります。 詳しくは、下記のページを参照してください。 タクソノミー関連のテンプレートを定義する"},{url:"/p/4sxmnfi/",title:"Hugo でセクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages)",date:"2017-12-30T00:00:00Z",body:"Hugo でセクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages) Home ページ直下の記事ページ ＝ セクションを持たないページ ホームページを示す Page オブジェクトの RegularPages プロパティを参照すると、content ディレクトリ直下に置かれた通常ページの一覧 を取得することができます。 つまり、どのセクションにも所属していない記事ページの一覧です。 \u0026lt;h3\u0026gt;セクションを持たない記事ページ一覧（タイトル順）\u0026lt;/h3\u0026gt; \u0026lt;ol\u0026gt; {{ range .Site.Home.RegularPages.ByTitle }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ol\u0026gt; さらに first 関数を組み合わせて使用すれば、最初の 5 件のみに絞り込んで表示することができます。 \u0026lt;h2\u0026gt;セクションを持たない記事ページ一覧（最初の５件）\u0026lt;/h2\u0026gt; \u0026lt;ol\u0026gt; {{ range first 5 .Site.Home.RegularPages.ByTitle }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ol\u0026gt; （コラム）Hugo v0.58.0 より前のバージョンでのやり方 Hugo v0.58.0 より前のバージョンでは、ホームページの Page オブジェクトの .RegularPages が、サイト全体の記事ページを返してしまっていたので、別の方法でセクションに所属していない記事ページを取得する必要がありました。 例えば、$.Site.RegularPages で取得したサイト内の記事ページの一覧（Page 配列）を、where 関数を使ってフィルタすることで、目的の記事ページだけに絞り込んでいました。 \u0026lt;h3\u0026gt;セクションを持たない記事ページ一覧（タイトル順）\u0026lt;/h3\u0026gt; \u0026lt;ol\u0026gt; {{ range (where $.Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;\u0026#34;).ByTitle }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ol\u0026gt;"},{url:"/p/fprd6w4/",title:"CSS の box-sizing プロパティで width の計算方法を制御する",date:"2017-12-29T00:00:00Z",body:"CSS の box-sizing プロパティで width の計算方法を制御する CSS の width プロパティが要素のどの部分の幅を示すかは、box-sizing プロパティの設定によって変化します。 段組などのレイアウトを正しく行うには、box-sizing の考え方を理解しておく必要があります。 content-box 指定と border-box 指定 下記の図は、HTML 要素の width の値が、具体的にどの部分の幅であるかを示しています。 ここでは簡略化のために width の例を示していますが、height も同様です。 box-sizing プロパティのデフォルト値は content-box になっており、簡単に言うと、テキストの描画部分の領域のことを表しています。 デフォルトの状態で、width: 300px; というスタイル指定を行った場合、その 300px にはパディング (padding) 部分や、ボーダー (border) 部分のサイズは含まれません。 つまり、width: 300px; と指定された要素が実際に描画されるときには、それよりも大きなサイズで描画されることになります。 ボーダー領域まで含めたサイズを、width プロパティや height プロパティで指定したいときは、box-sizing プロパティの値を border-box に指定します。 CSS .sample { /* width と height にボーダー領域まで含める */ box-sizing: border-box; } 実際に試してみる 下記のデモは、box-sizing プロパティの値を content-box（デフォルト）と border-box に設定したときの表示の違いを示しています。 分かりやすくするために、ボーダー領域は青色で表示しています。 パディング領域だけに色をつけることはできないため、テキストの周りの微妙な隙間がパディング領域だと思ってください。 図: box-sizing のデモ（別ページで開く） どちらも、width は 300px としていますが、box-sizing: border-box; と指定した場合は、ボーダー領域まで width に含めて計算するようになるため、実際の表示も若干小さくなります。 HTML \u0026lt;div class=\u0026#34;content-box\u0026#34;\u0026gt; box-sizing: \u0026lt;b\u0026gt;content-box\u0026lt;/b\u0026gt;; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;border-box\u0026#34;\u0026gt; box-sizing: \u0026lt;b\u0026gt;border-box\u0026lt;/b\u0026gt;; \u0026lt;/div\u0026gt; CSS div { width: 300px; height: 100px; margin: 10px; padding: 10px; border: solid 10px #59f; background: #ddd; } div.content-box { box-sizing: content-box; } div.border-box { box-sizing: border-box; } ☝️ ワンポイント ちなみに margin に関しては、width の計算に含まれることはありません。 margin はあくまで 要素の外側 のマージンだと考えましょう。 段組レイアウトでは box-sizing: border-box が便利 ２つ以上のボックスを横に並べて段組レイアウトを行う場合、デフォルトの box-sizing アルゴリズム (content-box) を使用していると、width 値の指定が非常に複雑になります（パディングやボーダーのサイズを考慮して width 値を調整しなければならないため）。 このような場合、横に並べるボックス要素に、box-sizing: border-box; の指定を行っておくと、直感的な width 指定を行うことができます。 図: box-sizing のデモ 2（別ページで開く） CSS \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;pane pane-left\u0026#34;\u0026gt;Left (150px)\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;pane pane-right\u0026#34;\u0026gt;Right\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS .pane { box-sizing: border-box; height: 100vh; padding: 10px; } .pane-left { float: left; width: 150px; background: #f9c; } .pane-right { margin-left: 150px; background: #9fa; }"},{url:"/p/hbh4dwr/",title:"CSS の rem や em を使用したサイズ指定を理解する",date:"2017-12-28T00:00:00Z",body:"CSS の rem や em を使用したサイズ指定を理解する CSS の rem や em といった相対的なサイズ指定方法を理解すると、Web サイト全体のレイアウトの整合性を保ちやすくなります。 rem と em の違い rem や em などのフォントサイズに比例する単位は、W3C の下記のページに詳しく説明されています。 CSS Values and Units Module Level 3 - 5.1.1. Font-relative lengths: the em, ex, ch, rem units rem も em も小文字の m の幅にほぼ等しいサイズを表しますが、下記のように、どの要素のフォントサイズを基準にするかが異なります。 rem (root em) font size of the root element（ルート要素のフォントサイズ） em font size of the element（要素のフォントサイズ） これだけでは分かりにくいので、それぞれの単位の意味を詳しく見てみましょう。 rem の意味 rem はルート要素のフォントサイズを基準にした単位です。 例えば、下記のようなスタイルを考えてみます。 html { font-size: 100%; } p { font-size: 1rem; } h2 { font-size: 1.5rem; } ルートの html 要素でフォントサイズを 100% に設定しているため、ブラウザのデフォルトサイズ（通常は 16px = 12pt）が 1rem となります。 つまり、p 要素は 1rem = 12pt、h2 要素は 1.5rem = 18pt になります。 ただし、ユーザがブラウザ設定で表示フォントサイズを変更している場合は、それに応じて 1rem あたりの実際のサイズが変わってきます。 いずれにしても、全ての要素のフォントサイズを rem を使って指定しておけば、ウェブサイト全体でフォントサイズの整合性を保ちやすくなるでしょう。 em の意味 単位 em の意味は、font-size プロパティに使用するか、それ以外のプロパティに使用するかで意味が異なってきます。 font-size プロパティの値の単位に em を使用すると、親要素の font-size を 1em とした相対サイズ でのフォントサイズ指定が可能です。 例えば、下記のようにすると、p 要素のフォントサイズは、親要素の 1.5 倍のフォントサイズになります。 p { font-size: 1.5em; } font-size 以外のプロパティに em を使用すると、自分自身の font-size を 1em とした相対サイズ での指定になります。 例えば、下記のようにすると、p 要素自身のフォントサイズの 1.5 倍のマージンが設定されます。 p { margin-top: 1.5em; } rem と em の使い道 rem と em は、上記のようにフォントサイズの指定に使用するだけでなく、レイアウト全般に活用することができます。 例えば、次のようにすればメインコンテンツのカラム幅を、ルート要素の文字幅 50 字分 (50rem) に設定することができます。 main { max-width: 50rem; } 次のようにすれば、現在の要素のフォントサイズで 1 文字分 (1em) のインデントを入れることができます。 p { text-indent: 1em; } 次のようにすれば、各ヘッダの上部にヘッダレベルに応じたマージンを入れることができます。 マージン設定の記述は共通ですが、単位に em を使用することで、h2 のマージンの方が h3 のマージンよりも大きくなります（もちろん、h2 の font-size の方が h3 のものより大きいことを前提としています）。 * + h2, * + h3 { margin-top: 1.5em; } 大まかな方針としては、rem はサイト全体の各要素の配置、em は要素内でのインデントやマージン設定などに使用すると考えるとよいでしょう。"},{url:"/p/wvi3n7q/",title:"Hugo でサイトのヘッダーとフッターをパーシャルファイルに分離する",date:"2017-12-27T00:00:00Z",body:"Hugo でサイトのヘッダーとフッターをパーシャルファイルに分離する パーシャルテンプレートでページ構成を分割する サイト内で共通のヘッダー部分とフッター部分を Hugo の パーシャルテンプレートファイル として作成しておくと、全てのテンプレートから参照できるため、テンプレートの記述をシンプルにすることができます。 Hugo のテンプレート構成では、下記のような感じでテンプレート前半部分と後半部分をまるごとパーシャルファイルで構成してしまうのが一般的のようです。 図: ヘッダーとフッターをパーシャルテンプレート化 上記ではリストテンプレート (list.html) の例を示していますが、ホームページテンプレート (layouts/index.html) や、セクションテンプレート (layouts/_default/section.html)、シングルページテンプレート (layouts/_default/single.html) などを記述する際も同様に構成します。 つまり、パーシャルファイルとして作成する header.html や footer.html は、どのテンプレートファイルからでも使用できるように、汎用的な記述をしておく必要があります。 layouts/partials/header.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;{{ .Site.LanguageCode }}\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/assets/css/main.css\u0026#34;\u0026gt; \u0026lt;title\u0026gt;{{ if not .IsHome }}{{ .Title }} | {{ end }}{{ .Site.Title }}\u0026lt;/title\u0026gt; {{ partial \u0026#34;header-favicon\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; layouts/partials/footer.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上記のようなパーシャルテンプレートは、各レイアウト用のテンプレートから次のように使用します。 layouts/_default/list.html {{ partial \u0026#34;header\u0026#34; . }} \u0026lt;main id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} \u0026lt;/main\u0026gt; {{ partial \u0026#34;footer\u0026#34; . }} ここでは、リストテンプレート内で使用する方法を示していますが、ホームテンプレートや、シングルページテンプレートなどでも同様に使用できます。 ベーステンプレートの機能を使うのがオススメ 上記では、HTML の前半部分や後半部分をパーシャルテンプレートとして分離する方法を示しましたが、Hugo の仕組みに慣れてきたら、ベーステンプレートの機能 を使って HTML を構成する方法がお勧めです。 参考: ベーステンプレートを作成して、各種テンプレートの基本構成を統一する"},{url:"/p/vczuozw/",title:"Hugo でサイト内の全セクションの一覧を表示する (.Site.Sections)",date:"2017-12-22T00:00:00Z",body:"Hugo でサイト内の全セクションの一覧を表示する (.Site.Sections) .Site.Sections を参照すると、サイト内のすべてのセクションページを示す Page 配列を取得することができます。 layouts/index.html \u0026lt;h3\u0026gt;全セクションのリスト\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range .Site.Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; ここで参照できるセクションページは、第一階層に存在するセクションのみであることに注意してください。 下のようなコンテンツ構造だとすると、.Site.Sections に含まれるのは、★のついたセクションページのみです。 content/ +-- dir1/_index.md ★ | +-- dir1-1/_index.md | +-- dir1-2/_index.md +-- dir2/_index.md ★ +-- dir2-1/_index.md +-- dir2-2/_index.md"},{url:"/p/sgrjpfu/",title:"Hugo でサイト内の全ページの一覧を表示する (.Site.Pages)",date:"2017-12-22T00:00:00Z",body:"Hugo でサイト内の全ページの一覧を表示する (.Site.Pages) .Site.Pages を参照すると、サイト内のすべてのページを示す Page 配列を取得することができます。 下記はホームページテンプレート内で、サイト内のすべてのページのリンクを表示する例です。 layouts/index.html \u0026lt;h3\u0026gt;全ページのリスト\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range .Site.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; .Site.Pages はデフォルトで、日時 (.Date) の一番新しいものから昇順に並べられた Page 配列を返します。 ☝️ ワンポイント .Site.Pages は、現在選択中の言語内でのページ一覧を返します。 全言語を含むページ一覧を取得したいときは、代わりに .Site.AllPages を参照してください。"},{url:"/p/ffr2bku/",title:"Hugo でホームページの Page オブジェクトを取得する",date:"2017-12-22T00:00:00Z",body:"Hugo でホームページの Page オブジェクトを取得する Hugo テンプレートの中で、ホームページを表す Page オブジェクトを取得するには次のようにします。 {{ $home := .Site.Home }} {{ printf \u0026#34;%#v\u0026#34; $home }} 公式ドキュメントの .Site 変数のページには書いてないのですが、上記のように簡単にホームページの Page オブジェクトを取得できるみたいです。 2 行目では、取得した Page オブジェクトの内容を出力して確認しています。 GetPage 関数を使用して、Kind パラメータに \u0026quot;home\u0026quot; を指定するというのもありです。 {{ $home := .Site.GetPage \u0026#34;home\u0026#34; }} {{ printf \u0026#34;%v\u0026#34; (eq $home .Site.Home) }} {{/* true になるはず */}} このような取得方法を知るまでは、次のような感じでものすごく面倒な書き方してました。。。 {{ $home := index (where .Site.Pages \u0026#34;URL\u0026#34; \u0026#34;==\u0026#34; \u0026#34;/\u0026#34;) 0 }} まず、where 関数を使い、全ページ (.Site.Pages) 中で URL が / であるものの Page オブジェクトの配列を取得しています。 実際にはホームページは 1 つだけなのですが、where は Page オブジェクトの配列を返すので、index 関数を使って 1 番目の要素だけを取り出しています。 なんて非効率的な（＾＾；"},{url:"/p/8vm6xqm/",title:"Hugo テンプレートで数値によるループ処理を行う (range, seq)",date:"2017-12-22T00:00:00Z",body:"Hugo テンプレートで数値によるループ処理を行う (range, seq) Hugo のテンプレート内では、Go 言語のような for を使用した数値ループは記述できません。 代わりに range を使用します。 次の例では、seq 関数 を使用して 1 から 5 の数値シーケンスを作成し、それらを range を使ってループ処理しています。 テンプレート内での記述例 \u0026lt;ul\u0026gt; {{ range $val := seq 5 }} \u0026lt;li\u0026gt;{{ $val }} {{ end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;1 \u0026lt;li\u0026gt;2 \u0026lt;li\u0026gt;3 \u0026lt;li\u0026gt;4 \u0026lt;li\u0026gt;5 \u0026lt;/ul\u0026gt; 戻り値を 2 つの変数で受け取れば、0 始まりのインデックスも同時に得ることができます。 テンプレート内での記述例 \u0026lt;ul\u0026gt; {{ range $index, $val := seq 5 }} \u0026lt;li\u0026gt;{{ $index }} : {{ $val }} {{ end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;0 : 1 \u0026lt;li\u0026gt;1 : 2 \u0026lt;li\u0026gt;2 : 3 \u0026lt;li\u0026gt;3 : 4 \u0026lt;li\u0026gt;4 : 5 \u0026lt;/ul\u0026gt;"},{url:"/p/pgub54h/",title:"Hugo で同一セクション内のページ／セクションの一覧を表示する",date:"2017-12-22T00:00:00Z",body:"Hugo で同一セクション内のページ／セクションの一覧を表示する そのセクション内のページ一覧を取得する (.Pages、.RegularPages) リストテンプレートやセクションテンプレートの中で、.Pages を参照すると、そのセクション（やタクソノミー）直下の記事ページ (regular page) とセクションページ (list page) の一覧を Page オブジェクトの配列として取得することができます。 layouts/_default/section.html \u0026lt;h3\u0026gt;セクションに含まれる記事ページ（あるいはセクションページ）の一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range .Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; 記事ページ (regular page) のみを列挙したい場合は、.Pages の部分を .RegularPages に変更してください。 逆に、セクションページ (list page) のみを列挙したい場合は、.Pages の部分を Sections に変更してください。 .Pages \u0026hellip; セクションページと記事ページの一覧 .RegularPages \u0026hellip; 記事ページの一覧 .Sections \u0026hellip; セクションページの一覧 上記のようなテンプレートは、タクソノミーテンプレート（タグの一覧ページ）でも同様に使用することができます。 ただし、.Pages や .RegularPages は、リスト系のページから参照することが想定されているため、シングルページテンプレート内で参照すると、サイズ 0 の配列 が返されることに注意してください。 そのため、基本的には上記のコードはリスト系のテンプレートでのみ使用することができます。 シングルページテンプレートからも、同一セクション内のページの一覧を取得したい場合は、まず .CurrentSection でカレントセクションを示す Page オブジェクトを取得するとよいでしょう（下記参照)。 同一セクション内のページ一覧を取得する (.CurrentSection.Pages) 下記のテンプレートコードは、現在の記事ページ（あるいはセクションページ）が所属するセクションの直下のページ（記事ページおよびセクションページ）の一覧を表示します。 例えば、ホームページを含むトップレベルの階層に置いた記事で実行された場合は、第一階層にあるセクションおよび記事ページの一覧が表示されます。 何らかのセクション内の記事で実行された場合は、その記事が所属するセクション内のサブセクションおよび記事ページの一覧が表示されます。 layouts/_default/single.html など \u0026lt;h3\u0026gt;同じセクション内のページ一覧（セクションページを含む）\u0026lt;/h3\u0026gt; {{ with .CurrentSection }} \u0026lt;ul\u0026gt; {{ range .Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; {{ end }} .Pages 変数はリスト系ページ（セクションページなど）の Page オブジェクトにしか要素が格納されない（記事ページでは空配列）になってしまうので、まずは自分自身の記事ページが所属するセクションに対応する Page オブジェクトを、.CurrentSection で取得してから処理を行うようにしています。 先に説明したのと同様、記事ページのみを列挙したい場合は .Pages の代わりに .RegularPages を、セクションページのみを列挙したい場合は .Pages の代わりに .Sections を参照してください。 このコードは、シングルページテンプレートからも、リストテンプレートからも使用できます。 参考: Hugo | Page Variables a collection of associated pages. This value will be nil for regular content pages. .Pages is an alias for .Data.Pages. 参考: hugo/page.go at master · gohugoio/hugo · GitHub Since Hugo 0.18 we got rid of the Node type. So now all pages are pages (regular pages, home page, sections etc.). Sections etc. will have child pages. These were earlier placed in .Data.Pages, but can now be more intuitively also be fetched directly from .Pages. This collection will be nil for regular pages. （コラム）ホームページでの .Pages 変数の振る舞いについて （下記は Hugo v0.58.0 より前のバージョンの記事です） Hugo v0.58.0 で、ホームページにおける .Pages 変数、.RegularPages 変数の振る舞いが、他のセクションページと同じになりました（そのセクション直下のページだけ返す）。 なので、v0.58.0 以降を使用する場合は、下記の対応は必要ありません。 参考: Hugo v0.58.0 Release Note home.Pages now behaves like all the other sections, see #6240. If you want to list all the regular pages, use .Site.RegularPages. ホームページテンプレートとセクションテンプレートでの .Pages の振る舞いの違い ホームページテンプレート (layouts/index.html) 内で .Pages を参照すると、サイト内のすべてのページ の Page 配列が返されるのですが、セクションテンプレート (layouts/_default/section.html) 内で .Pages を参照すると、その セクション直下にあるページ のみの Page 配列が返されるという違いがあるようです。 テンプレート内で .Pages 変数を参照するときは、そのテンプレートがホームページテンプレートと、セクションテンプレートのどちらのコンテキストで使用されるかを意識して扱い方を変える必要があります。 特に、layouts/_default/list.html のような、ホームページテンプレートとしても、セクションテンプレートとしても使用されるファイルを作成する場合には注意してください。 次の節では、この点を考慮して、カレントセクション直下に配置されたページのみのリストを取得する方法を示します。 同一セクションの直下の記事ページのリストを表示する 下記のテンプレートコードは、現在のページが所属するセクションの直下に配置された記事ページのリストを表示します。 layouts/partials/subpages.html {{- $sec := .CurrentSection }} {{- if $sec }} {{- if $sec.IsHome }} {{ .Scratch.Set \u0026#34;pages\u0026#34; (where $.Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;\u0026#34;) }} {{- else }} {{ .Scratch.Set \u0026#34;pages\u0026#34; $sec.Pages }} {{- end }} {{- end }} \u0026lt;h3\u0026gt;同じセクション内の記事ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range (.Scratch.Get \u0026#34;pages\u0026#34;) }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; 例えば、mysection セクションに所属する記事ページのテンプレートで上記のコードが実行されると、同じ mysection セクションに所属する記事ページのリストが表示されます。 また、ホームページを含む、トップレベル（content ディレクトリ直下）に配置したページ内で実行した場合は、トップレベルに配置した記事ページのリストが表示されます。 つまり、上記のパーシャルテンプレートは、下記のような様々なテンプレートファイル内から同様に使用することができます。 ホームページテンプレート (layouts/index.html) セクションテンプレート (layouts/_default/section.html) 汎用リストテンプレート (layouts/_default/list.html) {{ partial \u0026#34;subpages\u0026#34; . }} テンプレートコードが若干複雑になっているのは、.Pages の振る舞いがコンテキストによって変わってくることが影響しています。 セクションページ内では、単純に .Pages を参照すれば、セクション直下の記事ページ一覧を取得できるのですが、ホームページで .Pages を参照すると、サイト内のすべてのページが含まれてしまいます。 そこで、現在のページがトップレベルの階層の記事である場合は、ちょっと特殊な方法、セクションを持たない記事の一覧を取得する (where $.Site.RegularPages \u0026quot;Section\u0026quot; \u0026quot;\u0026quot;) といった回りくどいことを行っています。 ちなみに、前半部分は次のようにセクション名 (.Section) の有無で分岐するように書けそうですが、このような記述はタクソノミーテンプレートのコンテキストではエラーになってしまいます。 なぜなら、https://example.com/tags/tag1/ のようなタグページにアクセスした場合に、セクション名 (.Section) に tags という文字列が格納されるのにもかかわらず、.CurrentSection の値は nil になってしまうからです（.CurrentSection の nil dereference エラーが発生する）。 {{/* カレントセクション直下の記事ページ一覧を \u0026#34;pages\u0026#34; スクラッチに格納 */}} {{- if .Section }} {{ .Scratch.Set \u0026#34;pages\u0026#34; .CurrentSection.Pages }} {{- else }} {{ .Scratch.Set \u0026#34;pages\u0026#34; (where $.Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;\u0026#34;) }} {{- end }} このような記述をするのであれば、全体を {{ if nq .Kind \u0026quot;taxonomy\u0026quot; }} 〜 {{ end }} のように囲んで、タクソノミーテンプレートのコンテキストでは実行されないようにしておくべきでしょう。 そうすると、結局のところ、最初の例とあまりコード量は変わらなくなります。 あと、$pages 変数のようなものを作成せずに、わざわざ .Scratch.Set を使ってスクラッチ領域にページリストを保存しているのは、Go テンプレートの構文で、変数の条件代入を行ううまい方法が用意されていないからです。 このあたりの話は、こちらの Hugo のサイトで議論されています。 スクラッチ領域 (.Scratch) を使用するのが気持ち悪いという場合は、下記のように、define による部分テンプレートを定義してしまえば、変数を用意しなくてすみますね。 {{- define \u0026#34;showPageList\u0026#34; }} \u0026lt;h3\u0026gt;同じセクション内の記事ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- range . }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; {{- end }} {{- with $sec := .CurrentSection }} {{- if $sec.IsHome }} {{ template \u0026#34;showPageList\u0026#34; (where $.Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;\u0026#34;) }} {{- else }} {{ template \u0026#34;showPageList\u0026#34; $sec.Pages }} {{- end }} {{- end }} 条件代入は cond 関数でスッキリかける！？（2017-12-30 追記） Hugo v0.27 で、三項演算子のようなことが実現できる cond 関数が追加されました（参考: Ternary operator-like function · Issue #3860 · gohugoio/hugo · GitHub）。 まだ公式ドキュエントには cond 関数の記載がないようですが、下記のように使用できます。 {{ $変数 := (cond (条件式) 真の場合の値 偽の場合の値) }} これで回りくどい .Scratch イディオムを使用しなくて済む！やったー！(^o^)/ と思って、下記のように書いてみました。 \u0026lt;h3\u0026gt;同じセクション内の記事ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{- $pages := (cond (eq .Section \u0026#34;\u0026#34;) (where $.Site.RegularPages \u0026#34;Section\u0026#34; \u0026#34;\u0026#34;) .CurrentSection.RegularPages) }} {{- range $pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{- end }} \u0026lt;/ul\u0026gt; がしかし！ cond 関数を使用して上記のように記述すると、条件式が真と判定される場合も、後ろの .CurrentSection.Pages の部分が評価されてしまうようです（値が実際に使われなくても実行される）。 .CurrentSection は nil になるケースがあるので、そのようなコンテキストで実行された場合にエラーになってしまいます。 Go の並列実行の都合なのだと思いますが、惜しい！"},{url:"/p/bdox8hr/",title:"Web サイトに favicon を設定する",date:"2017-12-18T00:00:00Z",body:"Web サイトに favicon を設定する favicon の基本 Web サイトの favicon は、Web ブラウザのタブのアイコンや、ブックマークのアイコンとして使用されます。 favicon 用の画像は、PNG、ICO、GIF のいずれかのフォーマットで作成します（PNG 形式が推奨）。 favicon のパスは、HTML の head 要素内で下記のように指定します。 ルートからの相対 URL で指定する場合 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/favicon.ico\u0026#34; /\u0026gt; ドメインを含めた URL で指定する場合 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;https://example.com/favicon.ico\u0026#34; /\u0026gt; ICO ファイルは複数のサイズのアイコンを含むことができるので、どのようなサイズを含めておくべきか迷うところですが、Microsoft は下記のようなサイズで作ることを推奨しています。 16 x 16 24 x 24 32 x 32 48 x 48 64 x 64 X-Icon Editor のサイト を使用すると、Web ブラウザ上で複数サイズのアイコンを含む ICO ファイルを作成することができます。 PNG ファイルで favicon を用意する方法 ICO 形式は古いフォーマットのため、現在では PNG 形式のファイルで favicon を作成するのが一般的 です。 PNG ファイルは、ICO ファイルと異なり、複数サイズのアイコンを含むことができないので、特定のサイズに最適されたアイコンを用意する場合は、複数の PNG ファイルとして作成しておく必要があります。 link 要素の type 属性、sizes 属性を使用すると、クライアントに対して、favicon に関する付加的な情報を与えることができます。 PNG フォーマットで favicon ファイルを用意する場合は、下記のように属性指定を行い、サイズ別にどのファイルを使用するか明示しておくとよいでしょう。 \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/favicon-16x16.png\u0026#34; sizes=\u0026#34;16x16\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/favicon-32x32.png\u0026#34; sizes=\u0026#34;32x32\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/favicon-96x96.png\u0026#34; sizes=\u0026#34;96x96\u0026#34; /\u0026gt; 上記で指定した PNG ファイルのうち、複数のファイルが適用可能な場合は、最後に宣言されたものが選択されることが一般的なため、上記のように 解像度の低いものから順番に指定する ようにしましょう。 sizes 属性には複数のサイズを指定することができるため、下記のように同一のアイコンで複数サイズの表示に対応させることもできます（この場合、きれいに拡大・縮小されて表示されるかどうかはクライアントの実装依存になります）。 \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/favicon.png\u0026#34; sizes=\u0026#34;16x16 24x24 32x32 48x48 64x64\u0026#34; /\u0026gt; スマホ（Android、iPhone）用の高解像度アイコンの指定 Android や iPhone などのスマホ、Windows 10、Android TV（旧: Google TV）のような様々なデバイスでは、より高解像度なアイコンを表示するようになってきています。 これらのアイコンは Web サイトの顔（エントリポイント）となるものですから、できるだけ最適なサイズで用意しておくとよいでしょう。 例えば、iOS version 8 までの全ての Apple Touch icon サイズに対応するのであれば、下記のようなサイズのアイコンを用意しておく必要があります。 \u0026lt;!-- Android \u0026amp; iPhone --\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;57x57\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-57x57.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;60x60\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-60x60.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;72x72\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-72x72.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;76x76\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-76x76.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;114x114\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-114x114.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;120x120\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-120x120.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;144x144\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-144x144.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;152x152\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-152x152.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; sizes=\u0026#34;180x180\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-180x180.png\u0026#34; /\u0026gt; 最低限どのようなアイコンファイルを用意しておくべき？ デバイスごとに最適なサイズのアイコンは、多種多様なため、すべてのサイズのアイコンを用意するのは大変です。 てっとり早く、ある程度きれいな表示を行いたいのであれば、とりあえずは下記のサイズのアイコンを用意しておけばよいでしょう。 32x32 の PNG アイコン（favicon 用） 152x152 の PNG アイコン（Apple Touch icon 用） HTML 内では下記のように指定します。 \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/asset/favicon/favicon-32x32.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;apple-touch-icon\u0026#34; href=\u0026#34;/asset/favicon/apple-touch-icon-152x152.png\u0026#34;\u0026gt; ... \u0026lt;/head\u0026gt; ルートに favicon.ico を置く方法 HTML ファイルの link 要素で favicon の URL を指定する方法が推奨されていますが、Web サイトのルートに /favicon.ico を置くことでも favicon を認識させることができます。 shortcut icon という指定はダメ IE8 以前は、link 要素に下記のように rel 属性として shortcut icon を指定していましたが、これは非標準な指定方法なので、rel 属性は icon とだけ指定するようにしましょう。 間違った指定方法 \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/path/favicon.ico\u0026#34;\u0026gt; link 要素の rel 属性に指定可能な値の一覧は下記にまとまっています。 Link types - HTML｜MDN icon の説明欄に、shortcut という指定が間違いであることが示されています。 icon より以前はリンクタイプ shortcut がよく使用されていましたが、これは非準拠で無視されますので Web 作者は今後使用してはいけません。 どうしても、IE8 以下のバージョンにも対応したいのであれば、下記のように IE 用の条件分岐を使用してファイルを指定しておくのがよいでしょう。 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;/asset/favicon.ico\u0026#34;/\u0026gt; \u0026lt;!--[if IE]\u0026gt; \u0026lt;link rel=\u0026#34;shortcut icon\u0026#34; href=\u0026#34;/asset/favicon.ico\u0026#34;/\u0026gt; \u0026lt;![endif]--\u0026gt; 参考になるサイト favicon の説明 Favicons, Touch Icons, Tile Icons, etc. Which Do You Need? ｜ CSS-Tricks All About Favicons (And Touch Icons) favicon 作成サイト 様々なファビコンを一括生成。favicon generator"},{url:"/p/yhqogz6/",title:"Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range)",date:"2017-12-16T00:00:00Z",body:"Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range) Hugo テンプレート内で辞書変数を定義すると、キーと値のマップ情報を管理することができます。 マップを定義する (dict) dict 関数 のパラメータに、キーと値のペアを並べていくと、マップ変数を作成することができます。 下記の例では、3 つのキー＆値を持つマップを定義して、その内容を出力しています。 テンプレート内でのマップ定義例 {{ $d := dict \u0026#34;key1\u0026#34; 100 \u0026#34;key2\u0026#34; 200 \u0026#34;key3\u0026#34; 300 }} {{ printf \u0026#34;%#v\u0026#34; $d }} 実行結果 map[string]interface {}{\u0026#34;key1\u0026#34;:100, \u0026#34;key2\u0026#34;:200, \u0026#34;key3\u0026#34;:300} ☝️ ワンポイント 関数名が dict なので、「辞書」と訳したほうがよいのかもしれませんが、内部的には Go の map オブジェクトなので、ここでは「マップ」と呼ぶことにします。 Go のテンプレート内で使用できる文法は、Go 言語の文法とは異なっています。 Go 言語でマップを定義する ときは map を使用しますが、Hugo のテンプレート内でマップ（辞書）を定義するときは dict 関数を使用しなければいけないことに注意してください。 マップの要素を参照する (index) マップ変数の後ろに、ドットで繋げてキー名を指定すると、そのキーに対応する要素の値を参照することができます（存在しないキーを指定した場合は何も出力されません）。 テンプレート内での記述例 {{ $d := dict \u0026#34;key1\u0026#34; 100 \u0026#34;key2\u0026#34; 200 \u0026#34;key3\u0026#34; 300 }} \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ $d.key1 }} \u0026lt;li\u0026gt;{{ $d.key2 }} \u0026lt;li\u0026gt;{{ $d.key3 }} \u0026lt;/ul\u0026gt; 実行結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;100 \u0026lt;li\u0026gt;200 \u0026lt;li\u0026gt;300 \u0026lt;/ul\u0026gt; ただし、このようにドットを使ってキーを指定する方法は、キー名がアルファベット（やアンダースコア）で始まっている場合にしか使用できません。 より汎用的なキー（数字始まりなど）を使用して、マップ内の要素を参照するには、index 関数 を使用します。 テンプレート内での記述例 {{ $d := dict \u0026#34;123\u0026#34; 100 \u0026#34;-a-\u0026#34; 200 \u0026#34;$foo\u0026#34; 300 }} \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ index $d \u0026#34;123\u0026#34; }} \u0026lt;li\u0026gt;{{ index $d \u0026#34;-a-\u0026#34; }} \u0026lt;li\u0026gt;{{ index $d \u0026#34;$foo\u0026#34; }} \u0026lt;/ul\u0026gt; ☝️ ワンポイント index 関数は、配列（スライス）変数内の要素を参照するときにも使用します（例: {{ index $arr 0 }}）。違いは、第 2 引数が文字列か数値かだけです。 マップをループで処理する (range) マップ内のすべての要素を、range を使ってループ処理することができます。 次の例では、マップ内のキーと値を順番に取り出しています。 テンプレート内での記述例 {{ $d := dict \u0026#34;key1\u0026#34; 100 \u0026#34;key2\u0026#34; 200 \u0026#34;key3\u0026#34; 300 }} \u0026lt;ul\u0026gt; {{- range $key, $val := $d }} \u0026lt;li\u0026gt;{{ $key }} = {{ $val }} {{- end }} \u0026lt;/ul\u0026gt; 実行結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;key1 = 100 \u0026lt;li\u0026gt;key2 = 200 \u0026lt;li\u0026gt;key3 = 300 \u0026lt;/ul\u0026gt; あまり使い道はないかもしれませんが、次のようにキー用の変数を省略して記述すると、値だけを取り出しながらループ処理することができます。 {{ $d := dict \u0026#34;key1\u0026#34; 100 \u0026#34;key2\u0026#34; 200 \u0026#34;key3\u0026#34; 300 }} \u0026lt;ul\u0026gt; {{- range $val := $d }} \u0026lt;li\u0026gt;{{ $val }} {{- end }} \u0026lt;/ul\u0026gt; マップをパーシャルテンプレートの引数として渡す Hugo の本家サイトには、下記のようなパーシャルテンプレートのパラメータとしてマップを受け取る例が掲載されています（本家のコードは細かい間違いが多いので若干修正してます）。 このパーシャルテンプレートは、指定された色、サイズで外部リンクアイコンを表示します。 layouts/partials/svgs/link-ext.svg \u0026lt;svg version=\u0026#34;1.1\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; xmlns:xlink=\u0026#34;http://www.w3.org/1999/xlink\u0026#34; fill=\u0026#34;{{ .fill }}\u0026#34; width=\u0026#34;{{ .size }}\u0026#34; height=\u0026#34;{{ .size }}\u0026#34; viewBox=\u0026#34;0 0 32 32\u0026#34; aria-label=\u0026#34;External Link\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M25.152 16.576v5.696q0 2.144-1.504 3.648t-3.648 1.504h-14.848q-2.144 0-3.648-1.504t-1.504-3.648v-14.848q0-2.112 1.504-3.616t3.648-1.536h12.576q0.224 0 0.384 0.16t0.16 0.416v1.152q0 0.256-0.16 0.416t-0.384 0.16h-12.576q-1.184 0-2.016 0.832t-0.864 2.016v14.848q0 1.184 0.864 2.016t2.016 0.864h14.848q1.184 0 2.016-0.864t0.832-2.016v-5.696q0-0.256 0.16-0.416t0.416-0.16h1.152q0.256 0 0.416 0.16t0.16 0.416zM32 1.152v9.12q0 0.48-0.352 0.8t-0.8 0.352-0.8-0.352l-3.136-3.136-11.648 11.648q-0.16 0.192-0.416 0.192t-0.384-0.192l-2.048-2.048q-0.192-0.16-0.192-0.384t0.192-0.416l11.648-11.648-3.136-3.136q-0.352-0.352-0.352-0.8t0.352-0.8 0.8-0.352h9.12q0.48 0 0.8 0.352t0.352 0.8z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; パーシャルテンプレートに渡されたマップの要素は、下記のようにキーを指定することで参照することができます。 {{ .fill }} このパーシャルテンプレートを使用するテンプレート側では、下記のように記述します。 layouts/_default/list.html {{ partial \u0026#34;svgs/link-ext.svg\u0026#34; (dict \u0026#34;fill\u0026#34; \u0026#34;#01589B\u0026#34; \u0026#34;size\u0026#34; 20) }} パーシャルテンプレートはこんな感じで SVG 画像を生成するのにも利用できるんですね。"},{url:"/p/y39gzkc/",title:"Hugo テンプレート内で変数を扱う",date:"2017-12-15T00:00:00Z",body:"Hugo テンプレート内で変数を扱う Hugo テンプレート内で変数を定義するときは、変数名のプレフィックスとして $ を付けます。 変数定義の基本 Hugo テンプレート内で変数を定義するには、下記のような構文を使用します。 = ではなくて、:= を使用することに注意してください。 {{ $変数名 := 初期値 }} 上記の構文から分かるように、独自の変数を定義する場合は、変数名のプレフィックスとして $ を付けます。 ☝️ ワンポイント より正確に言うと、上記のように $ で始まるようにアクションを記述すると、それが変数定義のためのアクションだと見なされるということです。 次の例では、数値変数 $x と、文字列変数 $y を定義し、それらの値を出力しています。 変数定義のアクションを実行しただけでは、その変数の値は出力されないので、変数出力のためのアクションを続けて記述しています（下の例では {{ $x }} や {{ $y }} という部分）。 テンプレート内での記述例 {{ $x := 100 }} \u0026lt;p\u0026gt;{{ $x }}\u0026lt;/p\u0026gt; {{ $y := \u0026#34;Hello\u0026#34; }} \u0026lt;p\u0026gt;{{ $y }}\u0026lt;/p\u0026gt; 出力結果 \u0026lt;p\u0026gt;100\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Hello\u0026lt;/p\u0026gt; 処理結果を変数に格納する ある値をパイプで関数に渡して、処理を行った結果を変数に格納する、といったこともできます。 次の例では、文字列 maku を printf 関数に渡し、その結果をさらに printf 関数に渡しています。 変数 $x には、その最終的な結果が格納されます。 テンプレート内での記述例 {{ $x := \u0026#34;maku\u0026#34; | printf \u0026#34;Hello %s.\u0026#34; | printf \u0026#34;%s What\u0026#39;s up?\u0026#34; }} \u0026lt;p\u0026gt;{{ $x }}\u0026lt;/p\u0026gt; 出力結果 \u0026lt;p\u0026gt;Hello maku. What\u0026#39;s up?\u0026lt;/p\u0026gt; 上記では、文字列 maku をパイプで printf 関数に渡していますが、次のように printf 関数のパラメータとして指定することもできます。 {{ $x := printf \u0026#34;%s What\u0026#39;s up?\u0026#34; (printf \u0026#34;Hello %s.\u0026#34; \u0026#34;maku\u0026#34;) }} \u0026lt;p\u0026gt;{{ $x }}\u0026lt;/p\u0026gt; どちらの方法でも結果は同じですが、上記のように 1 つの値を連続して変換していくようなケースでは、パイプを使って記述したほうが読みやすいように感じます。 ☝️ ワンポイント パイプ (|) を使用して処理を繋げると、パイプの前に記述した処理結果が、後ろの関数の 最後のパラメータ として渡されます。 range アクションでの変数の使用 range アクションによって配列をループ処理する場合は、各要素の値を変数に取り出しながら処理することができます。 \u0026lt;h3\u0026gt;ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range $page := .Site.AllPages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ $page.RelPermalink }}\u0026#34;\u0026gt;{{ $page.Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; ただし、上記のように要素の値のみを取り出す場合は、デフォルトのドット (.) のコンテキストを置き換えて下記のようにループ処理する方が簡潔に記述できます。 \u0026lt;h3\u0026gt;ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range .Site.AllPages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; 次のように、2 つの変数を用意することで、インデックス（0 始まり）を取得しながらループ処理することもできます。 \u0026lt;h3\u0026gt;ページ一覧\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; {{ range $index, $page := .Site.AllPages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ $page.RelPermalink }}\u0026#34;\u0026gt;{{ printf \u0026#34;%d: %s\u0026#34; (add $index 1) $page.Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; じゃなくて \u0026lt;ol\u0026gt; で表示すればいいじゃん、というツッコミはなしで（＾＾； with アクションでの変数の使用 with アクションで変数スコープを制限する場合にも、変数を使用することができます。 {{ with $x := \u0026#34;maku\u0026#34; }} Hello {{ $x }} {{ end }} 上記のようにすると、with ～ end のブロックの外からは、変数 $x は参照できなくなります。"},{url:"/p/7bvjywy/",title:"Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range)",date:"2017-12-15T00:00:00Z",body:"Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range) Hugo テンプレートの中で slice 関数を使用すると、渡されたパラメータ群から新しいスライス（配列）を作成することができます。 配列（スライス）を定義する (slice) Hugo テンプレートでは、新しくスライス（配列）を定義するための構文は用意されていないため、そのような場合はスライス（配列）を戻り値として返す slice 関数 を使用する必要があります。 下記の例では、slice 関数に 3 つのパラメータを渡し、それらの要素からなるスライスを生成しています。 テンプレート内での記述例 {{ $arr := slice \u0026#34;AAA\u0026#34; \u0026#34;BBB\u0026#34; \u0026#34;CCC\u0026#34; }} {{ printf \u0026#34;%#v\u0026#34; $arr }} 実行結果 []interface {}{\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;} ☝️ ワンポイント Go のテンプレート内で使用できる文法は、Go 言語の文法とは異なっています。 スライスを定義するときに、Go 言語と同じ構文で、$arr := []string{\u0026quot;AAA\u0026quot;, \u0026quot;BBB\u0026quot;, \u0026quot;CCC\u0026quot;} と記述することはできないことに注意してください。 配列（スライス）の要素を参照する (index) インデックス番号指定で配列（スライス）内の要素を参照するには、index 関数 を使用します。 この書き方は、慣れるまでは若干わかりにくいかもしれません。 テンプレート内での記述例 {{ $arr := slice \u0026#34;AAA\u0026#34; \u0026#34;BBB\u0026#34; \u0026#34;CCC\u0026#34; }} \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ index $arr 0 }} \u0026lt;li\u0026gt;{{ index $arr 1 }} \u0026lt;li\u0026gt;{{ index $arr 2 }} \u0026lt;/ul\u0026gt; 実行結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;AAA \u0026lt;li\u0026gt;BBB \u0026lt;li\u0026gt;CCC \u0026lt;/ul\u0026gt; 配列（スライス）をループで処理する (range) 配列の全要素をループで処理したい場合は、range を使って以下のように記述します。 テンプレート内での記述例 {{ $arr := slice \u0026#34;AAA\u0026#34; \u0026#34;BBB\u0026#34; \u0026#34;CCC\u0026#34; }} \u0026lt;ul\u0026gt; {{- range $arr }} \u0026lt;li\u0026gt;{{ . }} {{- end }} \u0026lt;/ul\u0026gt; 実行結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;AAA \u0026lt;li\u0026gt;BBB \u0026lt;li\u0026gt;CCC \u0026lt;/ul\u0026gt; 上記の例ではドットコンテキストを置き換えて、各要素をドット (.) で参照するようにしていますが、次のように変数名を付けてアクセスすることもできます。 テンプレート内での記述例 {{ $arr := slice \u0026#34;AAA\u0026#34; \u0026#34;BBB\u0026#34; \u0026#34;CCC\u0026#34; }} \u0026lt;ul\u0026gt; {{- range $val := $arr }} \u0026lt;li\u0026gt;{{ $val }} {{- end }} \u0026lt;/ul\u0026gt; ☝️ ワンポイント range を使ってループ処理をするときに、ループ用の変数を明示的に割り当てても、結局ドットコンテキストの方は置き換えられてしまうようなので、この書き方はあまり意味がないかもしれません。 range で配列をループ処理するときに、下記のように 2 つの変数を指定すると、配列のインデックス番号を取得しながらループ処理することができます。 テンプレート内での記述例 {{ $arr := slice \u0026#34;AAA\u0026#34; \u0026#34;BBB\u0026#34; \u0026#34;CCC\u0026#34; }} \u0026lt;ul\u0026gt; {{- range $index, $val := $arr }} \u0026lt;li\u0026gt;{{ $index }} : {{ $val }} {{- end }} \u0026lt;/ul\u0026gt; 実行結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;0 : AAA \u0026lt;li\u0026gt;1 : BBB \u0026lt;li\u0026gt;2 : CCC \u0026lt;/ul\u0026gt;"},{url:"/p/5zwytgx/",title:"Hugo テンプレート内にコメントを記述する",date:"2017-12-15T00:00:00Z",body:"Hugo テンプレート内にコメントを記述する Hugo のテンプレートファイル内では、C/C++ や Java に似た形式（/* と */）でコメントを記述することができます。 コメントとして記述した部分は、HTML ファイルに出力するときに削除されます。 {{/* a comment */}} 複数行にまたがるコメントを記述することもできます。 {{/* comment comment comment */}}"},{url:"/p/ewoqwrk/",title:"Hugo テンプレート内で if や with で分岐処理する",date:"2017-12-11T00:00:00Z",body:"Hugo テンプレート内で if や with で分岐処理する Hugo テンプレートの中で、if アクションや with アクションを使用することで、分岐処理を行うことができます。 if による分岐処理 if の構文 Hugo のテンプレート内で分岐処理を行うには、下記のように if ~ end を使用します。 必要に応じて、else や else if を挟むことができます。 {{ if ● }} ... {{ end }} {{ if ● }} ... {{ else }} ... {{ end }} {{ if ● }} ... {{ else if ▲ }} ... {{ end }} {{ if ● }} ... {{ else if ▲ }} ... {{ else }} ... {{ end }} {{ と }} で囲まれた部分は、Go のテンプレートでは アクション と呼ばれている部分で、基本的に 1 つのアクションだけを記述することができます（関数をパイプで結んだりすることはできる）。 if による条件式を記述する部分と、end でブロックを閉じる部分は、上記のように分けて記述する必要があるため、若干まわりくどくなってしまうケースがあるかもしれませんが、そこは我慢するしかありません。 if の条件式（上記の ● の部分）において「偽」とみなされる値は、空値 (empty value) です。 空値となるのは下記のような値です。 false 0 とみなされる数値（0.0 も含む） サイズ 0 の配列、スライス、マップ 空文字列 (\u0026quot;\u0026quot;) nil ポインタ 真とみなされる例（T と表示される） {{ if true }} T {{ else }} F {{ end }} {{ if \u0026#34;ABC\u0026#34; }} T {{ else }} F {{ end }} {{ if 1 }} T {{ else }} F {{ end }} {{ if -1 }} T {{ else }} F {{ end }} 偽とみなされる例（F と表示される） {{ if false }} T {{ else }} F {{ end }} {{ if \u0026#34;\u0026#34; }} T {{ else }} F {{ end }} {{ if 0 }} T {{ else }} F {{ end }} {{ if 0.0 }} T {{ else }} F {{ end }} 条件式の部分で、値の比較を行いたい場合は、下記のような eq や ne といった二値関数 (boolean functions) を使用します。 比較する 2 つの値は、後ろに続けて記述することに注意してください。 記述方法 いつ真とみなすか？ リファレンス eq ARG1 ARG2 ARG1 ＝ ARG2 のとき eq 関数 ne ARG1 ARG2 ARG1 ≠ ARG2 のとき ne 関数 lt ARG1 ARG2 ARG1 ＜ ARG2 のとき lt 関数 le ARG1 ARG2 ARG1 ≦ ARG2 のとき le 関数 gt ARG1 ARG2 ARG1 ＞ ARG2 のとき gt 関数 ge ARG1 ARG2 ARG1 ≧ ARG2 のとき ge 関数 if の使用例 次の例では、数値変数の値が 100 より大きいかを、gt 関数を使用して調べています。 変数 $x の値が 100 より大きいか調べる {{ $x := 200 }} {{ if gt $x 100 }} x is greater than 100 {{ end }} 文字列変数の比較 にも eq（等しい）や ne（等しくない）を使用することができます。 変数 $s の値が hello かどうか調べる {{ $s := \u0026#34;hello\u0026#34; }} {{ if eq $s \u0026#34;hello\u0026#34; }} s is hello {{ end }} with による分岐処理 with の構文 if アクションの代わりに、with アクションを使用して分岐処理を記述すると、ブロックの中のコンテキスト（ドット .）を、条件式で評価した値に置き換えることができます。 {{ with ● }} ... {{ end }} {{ with ● }} ... {{ else }} ... {{ end }} 使い方は、例を見たほうが分かりやすいかもしれません。 次の例では、with アクションの条件式で Maku という文字列が指定されているため、ブロックの中でドット (.) を参照することで、Maku という文字列を取得することができます。 テンプレート内で with アクションを利用する {{ with \u0026#34;Maku\u0026#34; }} {{ printf \u0026#34;I am %s\u0026#34; . }} {{ end }} 実行結果 I am Maku 通常、ドット (.) はトップレベルのコンテキスト（Hugo のレイアウトファイルの中では通常 Page オブジェクト）を表しますが、上記のように with アクションを使用することで、コンテキストを切り替えて、ブロック内の記述をシンプルにすることができます。 逆に、with ブロックでコンテキストを切り替えた後に、トップレベルのコンテキストを明示的に参照したい場合は、次のように $ プレフィックスを指定して参照します。 with ブロックの中からトップレベルコンテキストを参照する {{ with \u0026#34;Maku\u0026#34; }} {{ printf \u0026#34;Hello, %s. Page title is %s\u0026#34; . $.Title }} {{ end }} 実行結果 Hello, Maku. Page title is SAMPLE_TITLE. with の使用例 下記のサンプルコードは、Web サイトの設定ファイル (config.toml) に、サイトの説明文や作者が設定されている場合に、それを meta 要素として出力する例です。 テンプレート内での記述例 {{ with .Site.Params.author -}} \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; {{- end }} {{ with .Site.Params.description -}} \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt; {{- end }} 設定ファイルの記述例 (config.toml) title = \u0026#34;My New Hugo Site\u0026#34; [params] author = \u0026#34;Maku\u0026#34; description = \u0026#34;This is my first Hugo site. It\u0026#39;s very cool.\u0026#34; 出力結果 \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;Maku\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;This is my first Hugo site. It\u0026amp;#39;s very cool.\u0026#34;\u0026gt; クォーテーションマークが、出力箇所のコンテキストに応じて、自動的にエスケープ処理されてますね。Cool!"},{url:"/p/8vrj4ui/",title:"Hugo でセクションの階層構造を取得する (.CurrentSection、.Parent、.Sections)",date:"2017-12-05T00:00:00Z",body:"Hugo でセクションの階層構造を取得する (.CurrentSection、.Parent、.Sections) Hugo のテンプレートファイル内から参照できる .Parent や .Sections といった Page 変数を参照すると、親セクションの情報や、子セクションの情報を取得することができます。 セクション系の情報を取得するための Page 変数 には下記のようなものがあります。 .CurrentSection 自分自身が所属するセクションの情報。自分自身がセクションページであったり、ホームページである場合は、自分自身のページの情報。型は Page オブジェクト。通常の記事ページ、ホームページ、セクションページ以外では nil になります（例えば、タクソノミーリストのページでは nil になります）。 .Parent 自分自身がセクションページの場合、親セクションの情報。自分自身が通常ページの場合、自分が所属するセクションの情報。型は Page オブジェクト。 .Sections 自分自身のセクションが含む子セクションの配列（ホームページテンプレート、あるいは、セクションテンプレートのみで意味を持つ）。型は Page オブジェクトの配列。 レイアウトファイル内で、これらのセクション情報を参照することで、階層構造に応じたナビゲーション用リンクを自動で生成 したりすることができるようになります。 ここでは、下記のような階層構造のコンテンツを用意して、それぞれのページで参照できるセクション情報がどのように変化するかを見てみましょう。 contents/ +-- _index.md (home page) +-- dir1/ | +-- _index.md (section page) | +-- page.md (single page) | +-- dir1-1/ | | +-- _index.md (section page) | | +-- page.md (single page) | +-- dir1-2/ | +-- _index.md (section page) | +-- page.md (single page) +-- dir2/ | +-- _index.md (section page) +-- dir3/ +-- _index.md (section page) .CurrentSection（自分が所属するセクション） テンプレートファイル内で .CurrentSection を参照すると、自分自身のページが所属するセクション (同一階層の _index.md）の Page オブジェクトを取得することができます。 テンプレートファイル（レイアウトファイル）内で、.CurrentSection の値を出力して、どのような値が格納されているかを調べてみましょう。 ここでは、次のような３種類のテンプレートファイルを用意することにします。 Home page template: layouts/index.html Section page template: layouts/_default/section.html Single page template: layouts/_default/single.html テンプレートファイル内の記述（上記 3 ファイルとも共通） \u0026lt;pre\u0026gt; {{ with .CurrentSection }} .CurrentSection = {{ . }} .CurrentSection.File.Path = {{ .File.Path }} .CurrentSection.Title = {{ .Title }} .CurrentSection.Kind = {{ .Kind }} .CurrentSection.Section = {{ .Section }} {{ end }} \u0026lt;/pre\u0026gt; .CurrentSections は通常ページ、ホームページ、セクションページ以外のテンプレートから参照すると nil になります。 つまり、layout/_default/taxonomy.html の中で参照すると必ず nil になるので、タクソノミーリストテンプレートの中では参照してはいけません。 また、layouts/_default/list.html の中で参照した場合でも、それがタクソノミーリストテンプレートとして使用されたときに .CurrentSections は nil になります。 layouts/_default/list.html の中で .CurrentSection の値を使用するときは、上記のように with ブロックや if ブロックで nil チェックしてから参照すると安全です。 参考: hugo/site_sections.go at master · gohugoio/hugo · GitHub CurrentSection returns the page\u0026rsquo;s current section or the page itself if home or a section. Note that this will return nil for pages that is not regular, home or section pages. ホームページ (/index.html) にアクセスしたとき .CurrentSection = Page(\u0026#34;タイトル (/index.html)\u0026#34;) .CurrentSection.File.Path = _index.md .CurrentSection.Title = タイトル (/index.html) .CurrentSection.Kind = home .CurrentSection.Section = ホームページ (/index.md) にアクセスしたときの .CurrentSection 変数の値は、自分自身のページ（ホームページ）を表す Page オブジェクトになります。 つまり、ホームページテンプレート (/layouts/index.html) の中では、.CurrenctSection.Title と .Title の値は同じになります。 ホームページはルート階層のコンテンツなので、どのセクションにも存在しておらず、セクション名 (.Section) は空っぽになっています。 ☝️ ワンポイント .Section は .CurrentSection と混同しがちですが、まったく違うものであることに注意してください。 .Section は自分自身のページが配置されている一階層目のディレクトリ名（String 型）を表し、.CurrentSection は自分自身のページが所属するセクション（同一階層の _index.md）の Page オブジェクトを表しています。 ルート階層の通常ページ (/page.html) にアクセスしたとき .CurrentSection = Page(\u0026#34;タイトル (/index.html)\u0026#34;) .CurrentSection.File.Path = _index.md .CurrentSection.Title = タイトル (/index.html) .CurrentSection.Kind = home .CurrentSection.Section = ルート階層に置いた通常ページ（シングルページ）にアクセスしたときの .CurrentSection 変数の値は、ホームページ（ルート階層の _index.md）の Page オブジェクトになります。 上記の出力結果を見ると、ホームページ (/index.html) にアクセスしたときと同じ結果になっていることが分かります。 1 階層目のセクションページ (/dir1/index.html) にアクセスしたとき .CurrentSection = Page(\u0026#34;タイトル (/dir1/index.html)\u0026#34;) .CurrentSection.File.Path = dir1/_index.md .CurrentSection.Title = タイトル (/dir1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 セクションページ（ディレクトリ内の _index.md）にアクセスしたときの .CurrentSection 変数の値は、自分自身のページ（セクション）を表す Page オブジェクトになります。 つまり、セクションページテンプレート (/layouts/_default/section.html) の中では、.CurrentSection.Title と .Title の値は同じになります。 1 階層目のセクションに所属する通常ページ (/dir1/page.html) にアクセスしたとき .CurrentSection = Page(\u0026#34;タイトル (/dir1/index.html)\u0026#34;) .CurrentSection.File.Path = dir1/_index.md .CurrentSection.Title = タイトル (/dir1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 あるセクションに所属する通常ページ（シングルページ）にアクセスしたときの .CurrentSection 変数の値は、同じ階層の _index.md（つまり、所属するセクションのセクションページ）を表す Page オブジェクトになります。 2 階層目のセクションページ (/dir1/dir1-1/index.html) にアクセスしたとき .CurrentSection = Page(\u0026#34;タイトル (/dir1/dir1-1/index.html)\u0026#34;) .CurrentSection.File.Path = dir1/dir1-1/_index.md .CurrentSection.Title = タイトル (/dir1/dir1-1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 2 階層目のセクションページにアクセスしたときの .CurrentSection 変数の値も同様に、自分自身のページ（2 階層目のセクション）を表す Page オブジェクトになります。 深い階層のセクションであっても、.Section 変数の値は、1 階層目のディレクトリ名になることに注意してください。 2 階層目のセクションに所属する通常ページ (/dir1/dir1-1/page.html) にアクセスしたとき .CurrentSection = Page(\u0026#34;タイトル (/dir1/dir1-1/index.html)\u0026#34;) .CurrentSection.File.Path = dir1/dir1-1/_index.md .CurrentSection.Title = タイトル (/dir1/dir1-1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 2 階層目のセクションに所属する通常ページ（シングルページ）にアクセスした場合も、これまでと同じ考え方ですね。 .CurrentSection の値は、同じ階層にある _index.md から生成されるセクションページの Page オブジェクトになります。 .Parent（親セクション） テンプレートファイル（レイアウトファイル）内から、.Parent を参照すると、親セクションのセクションページを表す Page オブジェクトを取得することができます。 親セクションというのは、自分自身がセクションページの場合は 1 階層上のセクションページ、自分自身が通常ページ（シングルページ）の場合は同一階層のセクションページを表します。 各種テンプレートの内容を次のように変更して、それぞれのページにアクセスしたときにどのような値が表示されるかを確認してみましょう。 \u0026lt;pre\u0026gt; {{ with .Parent }} .Parent = {{ . }} .Parent.File.Path = {{ .File.Path }} .Parent.Title = {{ .Title }} .Parent.Kind = {{ .Kind }} .Parent.Section = {{ .Section }} {{ end }} \u0026lt;/pre\u0026gt; ホームページ (/index.html) にアクセスしたとき ホームページは、最上位のセクションを表すページであるため、ホームページテンプレートからは親セクションを取得することはできません。 .Parent を参照したときの値は nil になるため、上記テンプレートでは何も表示されません。 ☝️ ワンポイント 正確には、ホームページはセクションページには分類されませんが、.Parent で参照する親セクションを考えるときには、通常のセクションと同様に考えたほうが分かりやすいです。 ルート階層の通常ページ (/page.html) にアクセスしたとき .Parent = Page(\u0026#34;タイトル (/index.html)\u0026#34;) .Parent.File.Path = _index.md .Parent.Title = タイトル (/index.html) .Parent.Kind = home .Parent.Section = ルート階層に配置された通常ページのテンプレート（シングルページテンプレート）から .Parent を参照すると、ホームページを表す Page オブジェクトを取得することができます。 1 階層目のセクションページ (/dir1/index.html) にアクセスしたとき .Parent = Page(\u0026#34;タイトル (/index.html)\u0026#34;) .Parent.File.Path = _index.md .Parent.Title = タイトル (/index.html) .Parent.Kind = home .Parent.Section = 1 階層目のセクションのセクションページから .Parent を参照すると、ホームページを表す Page オブジェクトを取得できます。 1 階層目のセクションに所属する通常ページ (/dir1/page.html) にアクセスしたとき .Parent = Page(\u0026#34;タイトル (/dir1/index.html)\u0026#34;) .Parent.File.Path = dir1/_index.md .Parent.Title = タイトル (/dir1/index.html) .Parent.Kind = section .Parent.Section = dir1 1 階層目のセクションに属する通常ページのテンプレート（シングルページテンプレート）から .Parent を参照すると、そのページが所属するセクションのセクションページを表す Page オブジェクトを取得することができます。 2 層目のセクションページ (/dir1/dir1-1/index.html) にアクセスしたとき .Parent = Page(\u0026#34;タイトル (/dir1/index.html)\u0026#34;) .Parent.File.Path = dir1/_index.md .Parent.Title = タイトル (/dir1/index.html) .Parent.Kind = section .Parent.Section = dir1 2 階層目のセクションのセクションページから .Parent を参照すると、1 階層上のセクションのセクションページを表す Page オブジェクトを取得することができます。 2 階層目のセクションに所属する通常ページ (/dir1/dir1-1/page.html) にアクセスしたとき .Parent = Page(\u0026#34;タイトル (/dir1/dir1-1/index.html)\u0026#34;) .Parent.File.Path = dir1/dir1-1/_index.md .Parent.Title = タイトル (/dir1/dir1-1/index.html) .Parent.Kind = section .Parent.Section = dir1 2 階層目のセクションに属する通常ページのテンプレート（シングルページテンプレート）から .Parent を参照すると、自分自身が所属するセクション（2 階層目のセクション）のセクションページを表す Page オブジェクトを取得することができます。 .Sections（子セクションの配列） テンプレートファイル（レイアウトファイル）の中から、.Sections を参照すると、そのセクションの下位セクション（子セクション）の配列を取得することができます。 .Sections に子セクションの値が格納されるのは、ホームページテンプレート、あるいは、セクションテンプレートから参照したときです（シングルページテンプレートから .Sections を参照すると、空配列になります）。 ここでは、各種テンプレートファイルに下記のように記述し、出力される値を確かめてみましょう。 \u0026lt;ul\u0026gt; {{ range .Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; ホームページ (/index.html) にアクセスしたとき \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/dir1/\u0026#34;\u0026gt;タイトル (/dir1/index.html)\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/dir2/\u0026#34;\u0026gt;タイトル (/dir2/index.html)\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/dir3/\u0026#34;\u0026gt;タイトル (/dir3/index.html)\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; 最上位には、dir1/、dir2/、dir3/ というセクション（ディレクトリ）が配置されているため、ホームページテンプレートから .Sections を参照すると、それらのセクションページを表す Page オブジェクトの配列を取得することができます。 ルート階層の通常ページ (/page.html) にアクセスしたとき 通常ページのテンプレート（シングルページテンプレート）からは、子セクションの値を取得できません。 Sections の値はサイズ０の配列になります。 \u0026lt;ul\u0026gt; \u0026lt;/ul\u0026gt; 1 階層目のセクションページ (/dir1/index.html) にアクセスしたとき \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/dir1/dir1-1/\u0026#34;\u0026gt;タイトル (/dir1/dir1-1/index.html)\u0026lt;/a\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;/dir1/dir1-2/\u0026#34;\u0026gt;タイトル (/dir1/dir1-2/index.html)\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; 1 階層目のセクション (/dir1) には、2 階層目のセクション (dir1-1、dir1-2) が存在するため、.Sections を参照すると、それらの下位セクションのセクションページを表す Page オブジェクトの配列を取得することができます。 1 階層目のセクションに所属する通常ページ (/dir1/page.html) にアクセスしたとき 通常ページのテンプレート（シングルページテンプレート）からは、子セクションの値を取得できません。 Sections の値はサイズ 0 の配列になります。 \u0026lt;ul\u0026gt; \u0026lt;/ul\u0026gt; 2 階層目のセクションページ (/dir1/dir1-1/index.html) にアクセスしたとき 2 階層目のセクション (/dir1/dir1-1) には、下位セクションが存在しないため、.Sections はサイズ 0 の配列になります。 \u0026lt;ul\u0026gt; \u0026lt;/ul\u0026gt; 2 階層目のセクションに所属する通常ページ (/dir1/dir1-1/page.html) にアクセスしたとき 通常ページのテンプレート（シングルページテンプレート）からは、子セクションの値を取得できません。 Sections の値はサイズ 0 の配列になります。 \u0026lt;ul\u0026gt; \u0026lt;/ul\u0026gt; 応用例（兄弟セクションの一覧） シングルページテンプレート内で次のように記述すれば、そのページが所属するセクションの子セクションの一覧（つまり、兄弟セクションの一覧）を表示することができます。 \u0026lt;ul\u0026gt; {{ range .CurrentSection.Sections }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/ul\u0026gt;"},{url:"/p/mn4ji9o/",title:"Hugo のセクションテンプレート (section.html) の中でセクションのタイトルを表示する",date:"2017-11-28T00:00:00Z",body:"Hugo のセクションテンプレート (section.html) の中でセクションのタイトルを表示する セクションテンプレートの中では、.Title や .Section を利用してセクションページ用のタイトルを生成することができます。 それぞれの変数の違いについて説明します。 セクションテンプレートとは セクションテンプレート（あるいはセクションページテンプレート）は、content ディレクトリ内の各セクションのインデックスファイル (_index.md) をレンダリングするときに使用されるテンプレートファイルです。 ディレクトリ構成の例 content/ +-- mysection1/ | +-- _index.md ★このファイルや、 | +-- page1.md | +-- page2.md +-- mysection2/ +-- _index.md ★このファイルに適用されるレイアウトです +-- page1.md +-- page2.md どのようなファイルがセクションテンプレートとして使用されるかは、本家サイトの下記ページに詳しく説明されています。 Section Template Lookup Order すべてのセクションで共通のテンプレートを使用したいのであれば、まずは下記のようなパスにテンプレートファイルを用意するのがよいでしょう。 /layouts/_default/section.html （セクション専用のテンプレート） /layouts/_default/list.html （セクション以外にも様々なリスト系ページで使われるテンプレート） ＜ テーマとしてテンプレートファイルを提供したいときは、テーマディレクトリの下に同じ構成でファイルを作成すれば OK です。 /themes/\u0026lt;テーマ名\u0026gt;/layouts/_default/section.html /themes/\u0026lt;テーマ名\u0026gt;/layouts/_default/list.html list.html の方は、ホームページ（ルートの _index.md）や、タグやカテゴリーのインデックスページなどにも使用されます。 セクションのインデックスページとしてのみ適用したいテンプレートであれば、section.html という名前で作成しましょう。 セクションテンプレートから .Title を参照する セクションテンプレート layouts/_default/section.html（存在しない場合は list.html）の中で {{ .Title }} と記述すると、そのセクションの _index.md ファイルのフロントマターに定義した title の情報が参照されます。 これはすなわち「セクションページのタイトル」として使用できるものです。 ☝️ ワンポイント シングルページテンプレート layouts/_default/single.html の場合も、同様に {{ .Title }} と記述することで、各ページのフロントマターに記述した title 情報を参照することができます。 ディレクトリ構成の例 content/ +-- mysection/ +-- _index.md （セクションページ） +-- a.md +-- b.md +-- c.md セクションページの例 (content/mysection/_index.md) --- title: \u0026#34;サンプルセクション\u0026#34; --- これは本文のサンプル。 セクションテンプレートの例 (layouts/_default/section.html) \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; 上記のような構成で、http://localhost:1313/mysection/ にアクセスすると、下記のような HTML が表示されることになります。 \u0026lt;h1\u0026gt;サンプルセクション\u0026lt;/h1\u0026gt; 想定通り、_index.md のフロントマターに記述した title フィールドの値が表示されていることがわかります。 同様に、セクションテンプレートの中から {{ .Content }} を参照すると、_index.md に記述した本文の内容がそこに展開されます（この場合は、「これは本文のサンプル。」というテキストが展開されます）。 _index.md がない場合に .Title を参照するとどうなるか？ 実は、上記のディレクトリ構成で示した content/mysection/_index.md というファイルを作成しなくても、そのセクションの index.html ファイルは暗黙的に生成されます。 そのようなケースでも、テンプレートファイルとしてはセクションテンプレート (section.html) が使用されます。 擬似的な空っぽの _index.md ファイルが存在し、そのファイルに対してセクションテンプレートが適用されていると考えればよいでしょう。 ただし、この場合は _index.md のフロントマター記述も存在しないため、{{ .Title }} で参照できるはずの title 情報を取得することができません。 その代わりに、Hugo は セクションのディレクトリ名から自動的にセクションページのタイトルを生成 し、それを {{ .Title }} の値として使用します。 そのとき生成されるタイトルは、ディレクトリ名と同一ではないことに注意してください。 Hugo はセクションのディレクトリ名の 先頭を大文字にし、さらに複数形に変換した単語 をタイトルとして生成します。 上記のディレクトリ構成の場合は、セクションのディレクトリ名は mysection なので、自動生成されるタイトルは Mysections となります。 http://localhost:1313/mysection/ にアクセスした場合のレンダリング結果 \u0026lt;h1\u0026gt;Mysections\u0026lt;/h1\u0026gt; セクション名が自動的に複数形になってしまうのを防ぎたい場合は、Hugo の設定ファイル（config.toml など）で下記のように設定します。 /config.toml # Pluralize titles in lists using inflect pluralizeListTitles = false セクションテンプレートから .Section を参照する セクションテンプレートの中で {{ .Section }} を参照すると、セクションのディレクトリ名をそのまま取得することができます。 {{ .Title }} と異なり、自動的に先頭を大文字にしたり、複数形にしたりすることがないので、ディレクトリ構成をそのまま出力したい場合にはこちらを使用するのがよいでしょう。 セクションテンプレートの例 (layouts/_default/section.html) \u0026lt;h1\u0026gt;{{ .Section }}\u0026lt;/h1\u0026gt; http://localhost:1313/mysection/ にアクセスした場合のレンダリング結果 \u0026lt;h1\u0026gt;mysection\u0026lt;/h1\u0026gt;"},{url:"/p/zg4n7q9/",title:"Hugo のレイアウト用テンプレートの種類を理解する",date:"2017-11-28T00:00:00Z",body:"Hugo のレイアウト用テンプレートの種類を理解する Hugo では様々なタイプのテンプレートファイルを用意することができ、コンテンツファイルのパスに応じて、どのテンプレートファイルを使ってレンダリングされるかが決定されます。 Hugo のテンプレートファイル Hugo で Web サイトを作成する場合、コンテンツファイルとして Markdown ファイルを作成していきます。 この Markdown ファイルが HTML の形にレンダリングされるとき、テンプレートファイル が使用されます。 Hugo のテンプレートの仕組みを理解することは、Hugo を使いこなすキモとなります。 ここでは、どのような種類のテンプレートファイルが、どのようなコンテンツに対して適用されてレンダリングされるのかを把握しましょう。 ここでは、下記のようなコンテンツ階層があるものとして説明していきます。 コンテンツのディレクトリ階層 content/ +-- _index.md （ホームページ） +-- page1.md （通常のページ） +-- page2.md （通常のページ） +-- section1/ | +-- _index.md （セクションのインデックスページ ＝ セクションページ） | +-- pagel-1.md （通常のページ） | +-- page1-2.md （通常のページ） +-- section2/ +-- _index.md （セクションのインデックスページ ＝ セクションページ） +-- page2-1.md （通常のページ） +-- page2-2.md （通常のページ） ホームページテンプレート (Homepage Template) Homepage Template 最上位の _index.md をレンダリングするときは、ホームページテンプレート が使用されます。 content/ +-- _index.md ★ホームページテンプレートを使用してレンダリング +-- page1.md +-- page2.md +-- section1/ | +-- _index.md | +-- pagel-1.md | +-- page1-2.md +-- section2/ +-- _index.md +-- page2-1.md +-- page2-2.md ホームページテンプレートといっても、特定のテンプレートファイルが適用されるのではなく、下記のようなファイルのうち最初に見つかったテンプレートファイルが使用されることになります。 /layouts/index.html /layouts/_default/list.html /themes/＜テーマ名＞/layouts/index.html /themes/＜テーマ名＞/layouts/_default/list.html ☝️ ワンポイント このように複数の候補の中からテンプレートファイルを探す仕組みは、別の種類のコンテンツファイルの場合も同様に採用されています。 この仕組みによって、異なる種類のコンテンツに、共通のテンプレートファイルを適用するといったことができるようになっています。 セクションテンプレート (Section Templates) Section Page Templates セクションごとのインデックスページ (_index.md) をレンダリングするときは、セクションテンプレート が使用されます。 content/ +-- _index.md +-- page1.md +-- page2.md +-- section1/ | +-- _index.md ★セクションテンプレートを使用してレンダリング | +-- pagel-1.md | +-- page1-2.md +-- section2/ +-- _index.md ★セクションテンプレートを使用してレンダリング +-- page2-1.md +-- page2-2.md 下記のファイルの内、最初に見つかったテンプレートファイルがセクションテンプレートとして使用されます。 /layouts/section/＜セクション名＞.html /layouts/＜セクション名＞/list.html /layouts/_default/section.html /layouts/_default/list.html /themes/＜テーマ名＞/layouts/section/＜セクション名＞.html /themes/＜テーマ名＞/layouts/＜セクション名＞/list.html /themes/＜テーマ名＞/layouts/_default/section.html /themes/＜テーマ名＞/layouts/_default/list.html パスに ＜セクション名＞ を含んでいるものは、そのセクション固有のテンプレートを提供したいときに使用します。 多くの場合は、すべてのセクションページで共通のセクションテンプレートを使用しますので、3 番目の /layouts/_default/section.html を用意すると考えておけばよいでしょう。 リストテンプレート (List Templates) List Templates リストテンプレート は、前述のテンプレートファイルとは若干概念が異なるものです。 鋭い方は、ホームページテンプレート (Homepage Template) とセクションテンプレート (Section Templates) として使用されるテンプレートファイルの候補に、共通の /layouts/_default/list.html が含まれていることに気が付いたかもしれません。 Web サイトのホームページや、セクションごとのインデックスページ（セクションページ）には、そこに含まれるコンテンツのリストを表示するという共通の目的があります。 Hugo では、このようなリスト表示を目的としたコンテンツに適用可能できる、共通のテンプレートファイルとして /layouts/_default/list.html を参照するようになっています。 つまり、ホームページとセクションページで共通のレイアウトを使用するのであれば、/layouts/_default/list.html というファイルを 1 つだけ作成しておけばよいことになります。 この仕組みをリストテンプレートと呼んでいます。 content/ +-- _index.md ★リストテンプレートの適用対象 +-- page1.md +-- page2.md +-- section1/ | +-- _index.md ★リストテンプレートの適用対象 | +-- pagel-1.md | +-- page1-2.md +-- section2/ +-- _index.md ★リストテンプレートの適用対象 +-- page2-1.md +-- page2-2.md ☝️ テンプレートの優先度 リストテンプレートの適用優先度は低く設定されているため、/layouts/_default/list.html ファイルは主にフォールバック機構により適用されることになります。 例えば、ホームページのレンダリングには、まずは /layouts/index.html テンプレートを適用しようとしますが、そのファイルが見つからなかった場合に /layouts/_default/list.html テンプレートを適用する、という動作をします。 シングルページテンプレート (Single Page Templates) Single Page Templates シングルページテンプレート は、前述のリスト系のコンテンツに当てはまらないページ、つまり、個別記事のコンテンツに対して適用されるテンプレートです。 content/ +-- _index.md +-- page1.md ★シングルページテンプレートを使用してレンダリング +-- page2.md ★シングルページテンプレートを使用してレンダリング +-- section1/ | +-- _index.md | +-- pagel-1.md ★シングルページテンプレートを使用してレンダリング | +-- page1-2.md ★シングルページテンプレートを使用してレンダリング +-- section2/ +-- _index.md +-- page2-1.md ★シングルページテンプレートを使用してレンダリング +-- page2-2.md ★シングルページテンプレートを使用してレンダリング 下記のテンプレートファイルのうち、最初に見つかったファイルがシングルページテンプレートとして使用されます。 /layouts/＜タイプ名＞/＜レイアウト名＞.html /layouts/＜セクション名＞/＜レイアウト名＞.html /layouts/＜タイプ名＞/single.html /layouts/＜セクション名＞/single.html /layouts/_default/single.html /themes/＜テーマ名＞/layouts/＜タイプ名＞/＜レイアウト名＞.html /themes/＜テーマ名＞/layouts/＜セクション名＞/＜レイアウト名＞.html /themes/＜テーマ名＞/layouts/＜タイプ名＞/single.html /themes/＜テーマ名＞/layouts/＜セクション名＞/single.html /themes/＜テーマ名＞/layouts/_default/single.html セクションテンプレートと同様、セクション固有のテンプレートファイルを用意することもできますが、まずは /layouts/_default/single.html を作成し、すべてのページを同じレイアウトでレンダリングするところから始めるのがよいでしょう。"},{url:"/p/s9r9q7n/",title:"Linux シェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)",date:"2017-11-01T00:00:00Z",body:"Linux シェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read) パイプで while read につなぐ方法 外部コマンドの出力結果を 1 行ずつ変数に取得しながらループ処理するには、コマンドの出力をパイプ (|) で while read につなぎます。 次の例では、外部コマンド find . -name '*.sh'（カレントディレクトリ以下の .sh ファイルを再帰的に列挙）の出力結果を 1 行ずつ line 変数に取得してループ処理しています。 find . -name \u0026#39;*.sh\u0026#39; | while read line; do echo \u0026#34;$line\u0026#34; done line という変数名は別の名前に変えても大丈夫です。 この例では 1 ファイルずつループ処理しているので、file という変数名の方が直感的かもしれません。 ☝️ ワンポイント echo 出力時に \u0026quot;$line\u0026quot; のようにダブルクォートで囲んでいるのは、echo が連続したスペースを 1 つのスペースにまとめて出力してしまうのを防ぐためです。 パス内にスペースが含まれていなければ問題は発生しませんが、必ずダブルクォートで囲むようにしましょう。 外部コマンドの出力を配列として受け取る方法 パイプ (|) を使用せず、$(command) の形で実行した外部コマンドの出力を、配列で受け取る方法もあります。 list=$(find . -name \u0026#39;*.sh\u0026#39;) for line in \u0026#34;$list\u0026#34;; do echo \u0026#34;$line\u0026#34; done 外部コマンドの出力を 1 行ずつ正しくループ処理するために、$list をダブルクォートで囲むことを忘れないでください。 for ループの in の後ろには、スペース区切りで各要素が列挙されているものとして認識されます。 行内にスペースが含まれている場合に、行全体を 1 つの要素として処理するためには、$list 変数を展開するときにダブルクォートで囲んでおく必要があります。"},{url:"/p/3dtq7o5/",title:"CSS の position プロパティによるレイアウト方法を理解する",date:"2017-10-23T00:00:00Z",body:"CSS の position プロパティによるレイアウト方法を理解する CSS の position プロパティには、static、fixed、relative、absolute を指定することができます。 これらの使い方を理解することで、HTML 要素の配置方法に広がりが出ます。 4 つの position 指定 position: static; 何も指定しない場合の初期値です。デフォルトの表示ルールによって要素が配置されます。あえて明示的に指定することはおそらくありません。 position: fixed; 画面上の指定した位置に固定配置します。スクロールしても表示位置の変わらないサイトヘッダーや、SNS ボタン群の表示などに利用することができます。 position: relative; 本来表示される位置から相対的に位置をずらします。補助的な使用方法として、自分自身の z-index プロパティを指定する場合や、子要素に position: absolute; を指定する場合にも使用されます。 position: absolute; 親要素の位置を基準にした絶対位置で配置します。position: absolute; を指定するには、その親要素に position: relative;（あるいは fixed、absolute）を指定しておく必要があります（親要素を移動させる必要がないときは、単純に position: relative; とだけ記述しておけば OK）。 position: fixed 図: position: fixed; の振る舞い position: fixed; を指定すると、ブラウザの表示領域内で位置を固定して表示することができます。 図: position: fixed; のデモ（別ページで開く） 具体的な表示位置は、top、bottom、left、right プロパティで指定します。 例えば、top: 0px; left: 0px; という指定を行えば、その要素はブラウザの画面上の左上に固定表示され、ユーザが画面スクロールを行ってもその要素は移動しません。 例えば、上記の表示例のように、サイトのヘッダ情報を画面上部に固定表示したり、サイドバーのメニューを固定表示したりするのに利用することができます。 position: relative 図: position: relative; の振る舞い position: relative; を指定すると、本来その要素が表示されるはずだった位置からのオフセットを指定して、表示位置をずらすことができます。 図: position: relative; のデモ（別ページで開く） 要素の表示位置をずらしたとしても、後続の要素は、その位置ずらしがなかったものとして配置される ことに注意してください。 上記の表示例を見るとよくわかると思います。 ちなみに、position: relative; の指定をだけを行い、top、bottom、left、right の指定を行わなかった場合は、その要素は本来表示されるべき位置にそのまま表示されます。 このような一見無駄に見える指定は、z-index プロパティ（要素の重なりの順序）を指定する際によく行われます。 なぜなら、z-index プロパティの指定は、position プロパティがデフォルトの static 値のままだと効果を発揮しないからです。 下記の例では、z-index プロパティの指定を有効にする目的のために position: relative; を指定しています。 .sample { position: relative; /* z-index の有効化のため（座標値は変わらない） */ z-index: 100; /* 要素同士の重なり順序を指定（上の方に表示） */ } また同様に、後述の position: absolute; という指定を有効にするためにも、親要素の position 指定を行う必要があります。 この場合も、position プロパティの値としては fixed、relative、absolute のいずれでも構わないのですが、表示位置に影響のない position: relative; という指定がよく使われます。 position: absolute 図: position: absolute; の振る舞い position: absolute; を使用すると、その親要素を基準とした絶対位置で表示位置を指定することができます（感覚的には絶対位置というよりは相対位置ですが）。 図: position: absolute; のデモ（別ページで開く） 注意しなければいけないのは、親要素の position プロパティとして、fixed、relative、absolute のいずれかを指定しておく必要があるというところです（つまり、デフォルトの static のままだと有効になりません）。 親要素の表示位置を特に移動させる必要がない場合は、親要素で position: relative; とだけ指定しておくのがよいでしょう。 例えば、下記のようにすると、親要素 (.parent) の左上に重なる形で、子要素 (.child) が表示されます。 .parent { position: relative; } .child { position: absolute; top: 0px; left: 0px; } position: absolute; は、画像の上にタイトル表示を重ねる場合などによく使用されます。 下記の例では、うさぎの画像に、「うさぎ」というテキストを重ねて表示しています。 図: position: absolute; でテキストを重ねる HTML 抜粋 \u0026lt;figure class=\u0026#34;catalog\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;rabbit.png\u0026#34;\u0026gt; \u0026lt;figcaption\u0026gt;うさぎ\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; CSS 抜粋 .catalog { position: relative; /* 子要素で position: absolute; を使うため */ max-width: 300px; } .catalog img { width: 100%; vertical-align: bottom; /* これを入れないとテキストの位置が微妙に下にずれる */ } .catalog figcaption { position: absolute; /* 親要素の位置を基準に表示位置を指定する */ bottom: 0px; left: 0px; width: 100%; text-align: center; font-size: 20pt; color: white; background: rgba(0, 0, 0, 0.5); } ちなみに、top、bottom、left、right などのプロパティにマイナスの値を指定すると、親要素からその分だけはみ出した位置に子要素を表示させることができます。 うまく利用すれば、画像を隠さないようにキャプションを表示することができます。"},{url:"/p/4m7gqfx/",title:"複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir)",date:"2017-10-14T00:00:00Z",body:"複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir) ローカル PC 上でいくつもの Hugo サイトを作成していて、さらに共通したテーマも同時に作成している場合は、同一のテーマディレクトリを参照して開発できると便利です。 複数の Hugo プロジェクトから、同一のテーマを参照するには、下記のような方法があります。 GitHub などにテーマ用のリポジトリを作成して、そのリポジトリを複数の Hugo プロジェクトに clone する。 各 Hugo プロジェクトの themes ディレクトリを、共通のテーマディレクトリへのシンボリックリンクへ置き換える。 設定ファイル (config.toml) で、共通のテーマディレクトリを参照するように設定する。 1 番目の方法は王道ですが、Git を介して各サイトのテーマを同一に保つのは、開発段階ではちょっと手間がかかって面倒かもしれません。 そんなときオススメなのは 2 番目と 3 番目の方法です。 シンボリックリンクで共通のテーマディレクトリを参照する Linux や macOS などのようにシンボリックリンクを作成できる OS では、共通のテーマディレクトリをシンボリックリンクで参照してしまうのがお手軽です。 例えば、下記のように共通で使用するテーマディレクトリ (hugo_themes) と、参照元となる３つの Hugo プロジェクト (site1、site2、site3) があるとします。 - hugo_themes/ （共通のテーマディレクトリ） +-- mytheme/ +-- archetypes/ +-- layouts/ +-- static/ +-- ... - site1/ （Hugo サイト 1） - site2/ （Hugo サイト 2） - site3/ （Hugo サイト 3） 各 Hugo プロジェクト内の themes ディレクトリを、hugo_themes へのシンボリックリンクに置き換えてしまえば、すべてのサイトから同じテーマディレクトリを参照できます。 $ cd site1 $ rmdir themes $ ln -s ../hugo_themes themes 使用するテーマ名の設定はあいかわらず必要なので、各 Hugo プロジェクトの設定ファイル (config.toml) でテーマ名を設定しておくことを忘れないでください。 site1/config.toml theme = \u0026#34;mythemes\u0026#34; 設定ファイルで共通のテーマディレクトリを設定する Hugo の設定ファイル (config.toml) で、共通のテーマディレクトリを設定する方法もあります。 テーマディレクトリの設定は themesDir という変数で設定するのですが、このディレクトリパスには、その Hugo プロジェクトよりも上位のディレクトリのパスを設定することができます。 config.toml themesDir = \u0026#34;../hugo_themes\u0026#34; theme = \u0026#34;mythemes\u0026#34; 例えば、各 Hugo プロジェクトの設定ファイルで、上記のように設定しておくと、上位のディレクトリに置いた共通のテーマディレクトリ (hugo_themes/mythemes/) を使用することができます。 設定ファイルを使わずに、hugo コマンドの --themesDir オプションでテーマディレクトリを指定することもできます。 $ hugo server --themesDir ~/gitwork/hugo_themes 設定ファイルの themesDir 変数と、コマンドライン引数の --themesDir の両方が指定された場合は、コマンドライン引数の方が優先されます。"},{url:"/p/yg4o9rb/",title:"複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる",date:"2017-10-10T00:00:00Z",body:"複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる Hugo サーバーの複数起動について 複数のサイトを Hugo で運用しているケースでは、ひとつのコマンドプロンプトから同時にサーバー起動できると便利です。 ここでは、下記のようにホームディレクトリ以下に複数の Hugo プロジェクトが存在するとします。 C:/website/site1 C:/website/site2 C:/website/site3 各 Hugo プロジェクトに対して Hugo サーバーを起動するには、例えば次のように実行していきます。 ポート番号を指定して Hugo サーバーを複数起動する C:\\\u0026gt; hugo server -p 50001 -s C:/website/site1 C:\\\u0026gt; hugo server -p 50002 -s C:/website/site2 C:\\\u0026gt; hugo server -p 50003 -s C:/website/site3 参考: カレントディレクトリを気にせずに hugo コマンドを実行する 参考: ポート番号を指定して Hugo サーバーを起動する ただし、上記のようにすると、1 つのサーバープロセスが 1 つのコマンドプロンプトを占有するため、複数の Hugo サーバーを起動しているときに複数のコマンドプロンプトを開いたままにしなければいけません。 1 つのターミナルで複数の Hugo サーバーを起動する Windows の場合 Windows の start コマンドを使用すると、バックグラウンドで hugo コマンドを実行することができるので、追加でコマンドプロンプトを開くことなしに複数の Hugo サーバーを起動することができます。 例えば、下記のバッチファイルは、３つの Hugo サーバーをバックグラウンドで起動します。 start-servers.bat @echo off start /b hugo server -p 50001 -s C:/website/site1 start /b hugo server -p 50002 -s C:/website/site2 start /b hugo server -p 50003 -s C:/website/site3 title Hugo Servers ☝️ ワンポイント 最後の行の title Hugo Servers では、コマンドプロンプトのウィンドウタイトルを Hugo Servers に変更しています。 ウィンドウタイトルを変更しておくと、タスクバーを見ただけで何のためのウィンドウなのかを判別しやすくなるのでお勧めです。 バックグラウンドで動作している Hugo サーバーをまとめて終了するには、例えば、taskkill コマンドを使用して、hugo.exe によるプロセスをまとめて終了します。 stop-servers.bat @echo off taskkill /f /im hugo.exe Windows の start コマンドや、taskkill コマンドの詳細は、まくまく Windows ノートを参照してください。 Linux の場合 Linux や macOS の場合は、下記のように末尾に \u0026amp; を付けて hugo コマンド実行すれば、簡単に複数のサーバーをバックグラウンドで立ち上げることができます。 start-servers.sh hugo server -p 50001 -s ~/website/site1 \u0026amp; hugo server -p 50002 -s ~/website/site2 \u0026amp; hugo server -p 50003 -s ~/website/site3 \u0026amp; Hugo サーバーのプロセスをまとめて終了したいときは、killall コマンドで簡単に終了できます。 stop-servers.sh killall hugo これくらいの規模であれば、シェルスクリプトではなく、関数やエイリアスとして定義してしまうのが手っ取り早いかもしれません。 ~/.bash_profile（抜粋） function hugo-start { hugo server -p 50001 -s ~/website/site1 \u0026amp; hugo server -p 50002 -s ~/website/site2 \u0026amp; hugo server -p 50003 -s ~/website/site3 \u0026amp; } function hugo-stop { killall hugo }"},{url:"/p/8ihz7es/",title:"Hugo のセクション機能の基本（記事を階層化する）",date:"2017-10-04T00:00:00Z",body:"Hugo のセクション機能の基本（記事を階層化する） Hugo では、記事ファイルをディレクトリ内に格納するだけで、その名前の セクション に所属する記事として扱うことができます。 この機能は、記事を物理的な階層構造で管理するために使用することができます。 セクションの基本 Hugo の記事ファイル（.md ファイル）は、content ディレクトリに格納していきますが、content ディレクトリの下にさらにディレクトリを作成して、そこに格納することもできます。 例えば、次のように author というサブディレクトリを作成して、その下に .md ファイルを配置することができます。 /content/author/maku.md このようなディレクトリ階層を作成すると、maku.md という記事は、author という セクションに所属する記事 として扱われるようになります。 セクションはディレクトリ階層で表現されるため、1 つの記事は、1 つのセクションにしか所属できません。 セクション名は、記事のテンプレート内から {{ .Section }} で参照することができます（Page オブジェクトのプロパティ）。 個々の記事のレイアウトは、single.html というテンプレートファイル (single page template) によって行われるため、まずはこのテンプレートファイルを作成しましょう。 layouts/_default/single.html \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; セクション名: {{ with .Section }}{{ . }}{{ else }}なし{{ end }} \u0026lt;main\u0026gt; {{ .Content }} \u0026lt;/main\u0026gt; ☝️ ワンポイント ここで使用している with という構文は、if の拡張構文です。 指定した値が存在する場合、シンプルに {{ . }} でその値を参照できます。 上記のテンプレートファイルの例では、.Section が存在する場合だけその値を表示し、存在しない場合は「なし」と表示するようにしています。 記事ファイル (.md) としては、次の 2 種類を用意してどのように表示されるか比べてみます。 content/sample.md（どのセクションにも所属しない記事） --- title: \u0026#34;サンプル\u0026#34; date: \u0026#34;2017-10-04\u0026#34; --- ダミー本文 content/author/maku.md（author セクションに所属する記事） --- title: まく date: \u0026#34;2017-10-04\u0026#34; --- ダミー本文 それぞれのページにアクセスすると、下記のように表示されます。 図: content/sample.md の場合 図: content/author/maku.md の場合 author ディレクトリ以下に配置した記事だけ、セクション名を取得できていることがわかります。 セクションの index ページを作成する (_index.md) セクション用の index ページ（section page と呼びます）は、そのセクションのディレクトリ直下に _index.md というファイル名で作成します。 例えば、下記は event セクションに属するコンテンツの構成を示しています。 event セクションの記事 /content/event/_index.md (section page) /content/event/page1.md (single page) /content/event/page2.md (single page) /content/event/page3.md (single page) 上記の index ページには、http://localhost:1313/event/ というアドレスでアクセスできるようになります。 セクションの index ページがレンダリングされるとき、レイアウトファイルとしては section.html (section page template) 、あるいは list.html (list page template) が使用されます。 個々の記事ファイルをレンダリングするときに使用される single.html (single page template) とは異なるレイアウトファイルが使用されることに注意してください。 これはつまり、index ページがセクション内のコンテンツを 一覧表示するためのリストページ として特殊扱いされることを意味しています。 より具体的には、下記のファイルのうち、最初に見つかったレイアウトファイルが _index.md のレンダリングに使用されます（Section Page Templates より抜粋）。 セクションの index ページ用のレイアウトファイル /layouts/section/\u0026lt;SECTION\u0026gt;.html /layouts/\u0026lt;SECTION\u0026gt;/list.html /layouts/_default/section.html /layouts/_default/list.html /themes/\u0026lt;THEME\u0026gt;/layouts/section/\u0026lt;SECTION\u0026gt;.html /themes/\u0026lt;THEME\u0026gt;/layouts/\u0026lt;SECTION\u0026gt;/list.html /themes/\u0026lt;THEME\u0026gt;/layouts/_default/section.html /themes/\u0026lt;THEME\u0026gt;/layouts/_default/list.html ☝️ list.html は section.html よりも汎用的に使われる /layouts/_default/list.html は、ホームページ（ルートの _index.html）や、タクソノミーリスト（あるタグがついたページの一覧）などのレイアウトファイルとしても使用されます。 ホームページ専用のレイアウトファイル、タクソノミーリスト専用のレイアウトファイルを用意したい場合は、/layouts/index.html、/layouts/_default/taxonomy.html などを作成します。 このあたりの詳細は、Hugo マニュアルの Homepage Template、Taxonomy Templates を参照してください。 ここでは、/layouts/_default/list.html というファイルとしてレイアウトファイルを作成してみます（list.html は、ホームページやタクソノミーリストのページにも使用される、リスト系ページ用の汎用レイアウトファイルです）。 /layouts/_default/list.html \u0026lt;main\u0026gt; \u0026lt;article\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; {{ .Content }} \u0026lt;/article\u0026gt; \u0026lt;ul\u0026gt; {{ range .Data.Pages }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }} ({{ .Date.Format \u0026#34;2006-01-02\u0026#34; }})\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/main\u0026gt; 上記のテンプレートを作成した後で、http://localhost:1313/event/ にアクセスすると、下記のように表示されます。 セクションの index ページ専用のレイアウトを作成する (section.html) layouts/_default/list.html というレイアウトファイルは、汎用的な list page template として使用されるため、各セクションの _index.md のレンダリング以外にも、ホームページ（ルートの _index.md）のレンダリングや、タグの一覧ページのレンダリングにも使用されます。 各セクションの _index.md をレンダリングするための専用のレイアウトファイルを用意したいときは、list.html という名前のレイアウトファイルの代わりに、次のような名前のレイアウトファイルを作成します。 セクションの index ページ専用のレイアウトファイル /layouts/section/\u0026lt;SECTION\u0026gt;.html /layouts/_default/section.html /themes/\u0026lt;THEME\u0026gt;/layouts/section/\u0026lt;SECTION\u0026gt;.html /themes/\u0026lt;THEME\u0026gt;/layouts/_default/section.html 上記のうち最初に見つかったレイアウトファイルが使用されます。 パスの中にセクション名 (\u0026lt;SECTION\u0026gt;) を含むファイルを用意しておくと、そのセクション専用の index ページをレンダリングするためのレイアウトファイルとして使用されます。 例えば、/layouts/section/event.html というレイアウトファイルは、event セクションの _index.md をレンダリングするためのレイアウトファイルとして使用されます。 全セクションの _index.md で共通のレイアウトファイルを使用するのであれば、layouts/_default/section.html というファイルをひとつだけ用意しておけば OK です。"},{url:"/p/t4sdxi3/",title:"Hugo のショートコードの中からフロントマターのパラメータを参照する ($.Page.Params)",date:"2017-10-02T00:00:00Z",body:"Hugo のショートコードの中からフロントマターのパラメータを参照する ($.Page.Params) Hugo のショートコードの中で $.Page.Params を参照すると、コンテンツファイルのフロントマターに記述したパラメータにアクセスすることができます。 下記の hello ショートコードは、コンテンツファイル (.md) のフロントマターに記述された title パラメータと date パラメータの値を表示します。 layouts/shortcodes/title-and-date.html {{ $.Page.Params.title }}\u0026lt;br\u0026gt; {{ $.Page.Params.date | dateFormat \u0026#34;Mon, 02 Jan 2006\u0026#34; }} ☝️ ワンポイント 時刻情報は dateFormat 関数に渡すことで、任意のフォーマットで出力することができます。 パイプで渡すのではなく、関数の第 2 パラメータとして次のように渡すこともできます。 {{ dateFormat \u0026#34;Mon, 02 Jan 2006\u0026#34; $.Page.Params.date }} Go 言語の時刻の扱いに関しては こちらを参照 してください。 作成した title-and-date ショートコードは、コンテンツファイルの中から次のように使用します。 content/page1.md --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2017-10-02\u0026#34; --- {{\u0026lt; title-and-date \u0026gt;}} 上記のショートコードの部分は、HTML ファイル出力時に次のように展開されます。 Page1 Title\u0026lt;br\u0026gt; Mon, 02 Oct 2017"},{url:"/p/53patex/",title:"Hugo のショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params)",date:"2017-10-02T00:00:00Z",body:"Hugo のショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params) Hugo のショートコードの中で $.Site.Params を参照すると、設定ファイル (config.toml) の params セクションに記述した情報を取得することができます。 例えば、設定ファイルに下記のように記述されていたとします。 config.toml baseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;わたしのブログ\u0026#34; theme = \u0026#34;my-theme\u0026#34; [params] subtitle = \u0026#34;Hugo を使って日記を書いています\u0026#34; authors = [ \u0026#34;Maku\u0026#34;, \u0026#34;Ponyo\u0026#34; ] 上記の params セクションに記述した設定値は、ショートコードの中から $.Site.Params.\u0026lt;パラメータ名\u0026gt; で参照することができます。 下記の site-info ショートコードは、サイトのタイトルとサブタイトル、筆者情報を表示するショートコードの実装例です。 layouts/shortcodes/site-info.html \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;{{ $.Site.Title }}\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;subtitle\u0026#34;\u0026gt;{{ $.Site.Params.subtitle }}\u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; {{ range $.Site.Params.authors }} \u0026lt;li\u0026gt;{{- . -}}\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; ☝️ ワンポイント 上記のコードの中で、{{- . -}} と書いてある部分は、ループ処理で取り出した著者の名前を出力することを示しています。 {{ . }} と記述する代わりに、前後にハイフンを入れておくことで、出力時に前後の余計なスペースを取り除いてくれます。 コンテンツファイル (.md) の中からは、下記のようにしてショートコードを呼び出すことができます。 --- title: \u0026#34;ページタイトル\u0026#34; date: \u0026#34;2017-10-02\u0026#34; --- {{\u0026lt; site-info \u0026gt;}} ショートコードの部分は、下記のように展開されます。 \u0026lt;div class=\u0026#34;title\u0026#34;\u0026gt;わたしのブログ\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;subtitle\u0026#34;\u0026gt;Hugo を使って日記を書いています\u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Maku \u0026lt;li\u0026gt;Ponyo \u0026lt;/ul\u0026gt;"},{url:"/p/ttfyk5o/",title:"Hugo で独自のショートコードを作成する",date:"2017-09-29T00:00:00Z",body:"Hugo で独自のショートコードを作成する Hugo で独自のショートコードを作成すると、定型の HTML コードを記事内に簡単に埋め込めるようになります。 ショートコード作成の基本 ショートコードは、layouts/shortcodes ディレクトリ内に .html 拡張子のファイルとして作成します。 layouts/shortcodes/my-shortcode.html This is my first short code. ファイル名から拡張子を除いたものが、ショートコード名となります。 上記の例の場合、my-shortcode というショートコードを作成したことになります。 記事（Markdown ファイル）の中から、下記のように呼び出すと、上記の内容がそこに展開されます。 content/page1.md --- title: \u0026#34;ページタイトル\u0026#34; --- {{\u0026lt; my-shortcode \u0026gt;}} ショートコードにパラメータを渡す (.Get) 単純なパラメータ ショートコード呼び出し時に、パラメータを渡すことができます。 下記の例では、２つのパラメータ red、32px を渡しています。 {{\u0026lt; my-shortcode red 32px \u0026gt;}} 渡されたパラメータは、ショートコードの中で {{ .Get インデックス番号 }} のように参照することができます。 layouts/shortcodes/my-shortcode.html \u0026lt;div style=\u0026#34;color:{{ .Get 0 }}; font-size:{{ .Get 1 }};\u0026#34;\u0026gt; This is my first short code. \u0026lt;/div\u0026gt; 名前付きパラメータ 上記の例では、参照するパラメータをインデックス番号 (0, 1, 2, \u0026hellip;) で指定していますが、2 つ以上のパラメータを持つショートコードを作成するときは、名前付きパラメータ の仕組みを使うと分かりやすくなります。 {{\u0026lt; my-shortcode color=\u0026#34;red\u0026#34; size=\u0026#34;32px\u0026#34; \u0026gt;}} 名前付きパラメータとして渡された値を参照するには、{{ .Get \u0026quot;パラメータ名\u0026quot; }} のように、インデックス番号の代わりにその名前を引用符で囲んで指定します。 \u0026lt;div style=\u0026#34;color:{{ .Get `color` }}; font-size:{{ .Get `size` }};\u0026#34;\u0026gt; This is my first short code. \u0026lt;/div\u0026gt; 上記のように HTML 要素の属性値の中で .Get のパラメータ名を記述するときは、ダブルクォーテーション (\u0026quot;) の代わりにバッククォート (`) で囲むと、引用符の対応がわかりやすくなります。 パラメータの有無を調べる パラメータが渡されたかどうかで処理を分岐するには、.Get で取得した値を if や with で評価します。 次の例では、ショートコードに class パラメータが渡されたときに、span 要素の class 属性の値として出力しています。 \u0026lt;span{{ with .Get \u0026#34;class\u0026#34;}} class=\u0026#34;{{.}}\u0026#34;{{ end }}\u0026gt;{{ .Inner }}\u0026lt;/span\u0026gt; default 関数を組み合わせて使うと、パラメータが指定されなかった場合のデフォルト値を用意しておくことができます。 以下のいずれの書き方も同様に振る舞いますが、1 つ目の書き方が直感的かと思います。 width パラメータのデフォルト値を auto にする {{ $width := .Get \u0026#34;width\u0026#34; | default \u0026#34;auto\u0026#34; }} {{ $width := default \u0026#34;auto\u0026#34; (.Get \u0026#34;width\u0026#34;) }} {{ $width := or (.Get \u0026#34;width\u0026#34;) \u0026#34;auto\u0026#34; }} ショートコードにテキストデータを渡す (.Inner) ショートコードの開始タグと終了タグで任意のテキスト（内部テキスト）を囲むと、ショートコードのテンプレート内からそのテキストを参照することができます。 下記は、caution という独自ショートコードにテキストを渡す例です。 content/page1.md --- title: \u0026#34;ページタイトル\u0026#34; --- {{\u0026lt; caution \u0026gt;}} 決して、この発射ボタンを押さないでください。 {{\u0026lt; /caution \u0026gt;}} 開始タグと終了タグで囲まれた内部テキストは、ショートコードの中から {{ .Inner }} で参照することができます。 layouts/shortcodes/caution.html \u0026lt;div style=\u0026#34;color:red;\u0026#34;\u0026gt; {{ .Inner }} \u0026lt;/div\u0026gt; 内部テキストを最終的に Markdown プロセッサで処理してもらいたい場合は、下記のように % を使用した呼び出し方をする必要があります。 --- title: \u0026#34;ページタイトル\u0026#34; --- {{% caution %}} 決して、この __発射ボタン__ を押さないでください。 {{% /caution %}} テーマ用のショートコード テーマの付属品として配布されるショートコードは、次のようなパスに配置します。 themes/\u0026lt;THEME\u0026gt;/layouts/shortcodes/\u0026lt;SHORTCODE\u0026gt;.html 同じ名前のショートコードが、現在の Hugo プロジェクト自身のショートコードディレクトリ (layouts/shortcodes) に存在する場合は、そちらが優先して使用されます。"},{url:"/p/tsfzj4n/",title:"Hugo のショートコードで本文内に HTML スニペットを埋め込む",date:"2017-09-29T00:00:00Z",body:"Hugo のショートコードで本文内に HTML スニペットを埋め込む 記事の中に定型のコード（YouTube 動画表示用 HTML など）を埋め込みたいときは、Hugo のショートコード (Shortcode) の機能を使用すると便利です。 ショートコードの基本 Hugo は基本的にマークダウン形式で記事を記述していくのですが、マークダウンの表現力には限界があるので、ときには HTML を直接記述したくなることがあります。 しかし、毎回同じような HTML を記述するのでは、マークダウン形式を使用する意味がなくなってしまいます。 このような場合に、HTML 部分をショートコードとして外部ファイルに保存しておくと、記事の中に簡単にその HTML を埋め込めるようになります。 ☝️ ワンポイント ショートコードは記事（コンテンツファイル）の中から呼び出すことができますが、テンプレートファイルの中からは呼び出せないことに注意してください。 テンプレートの中から同様のことを行いたい場合は、パーシャルテンプレートの仕組みを使用します。 Hugo には、いくつかの組み込みのショートコードが用意されています。 例えば、下記は Youtube の動画や、Instagram の投稿を埋め込むためのショートコードの使い方の例です。 例: Youtube 動画を記事内に埋め込む {{\u0026lt; youtube w7Ft2ymGmfc \u0026gt;}} {{\u0026lt; youtube id=\u0026#34;w7Ft2ymGmfc\u0026#34; autoplay=\u0026#34;true\u0026#34; \u0026gt;}} 例: Instagram の投稿を記事内に埋め込む {{\u0026lt; instagram BWNjjyYFxVx \u0026gt;}} 例: ツイートを記事内に埋め込む {{\u0026lt; tweet 877500564405444608 \u0026gt;}} ショートコードの呼び出し方 記事内からショートコードを呼び出すには、下記のような構文を使用します。 {{\u0026lt; shortcode-name param1 param2 \u0026gt;}} 名前付きのパラメータを使用する場合は、param1=\u0026quot;value1\u0026quot; のように記述します。 {{\u0026lt; shortcode-name param1=\u0026#34;value1\u0026#34; param2=\u0026#34;value2\u0026#34; \u0026gt;}} HTML タグのように、開始タグと終了タグで内部テキストを囲むこともできます (paired shortcode)。 {{\u0026lt; shortcode-name \u0026gt;}} 長めのテキストをショートコードへの入力として扱う場合は、このように開始タグと終了タグで囲む方式を使うとよいです。 この部分のテキストは、ショートコードの実装の中で .Inner という変数で参照できます。 {{\u0026lt; /shortcode-name \u0026gt;}} 内部テキストの中で Markdown 記法を使う場合は、{{\u0026lt; と \u0026gt;}} の代わりに、{{% と %}} でショートコード名を囲みます。 {{% shortcode-name %}} 内部テキストの中で __強調テキスト__ や `inline code` などの Markdown 記法を使うことができます。 {{% /shortcode-name %}} 参考: 独自のショートコードを作成する"},{url:"/p/tbf357g/",title:"インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding)",date:"2017-09-12T00:00:00Z",body:"インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding) Go 言語には継承の仕組みはありませんが、埋め込み (Embedding) という仕組みによって型の拡張（結合）を行うことができます。 インタフェース埋め込み (Interface Embedding) Go 言語標準の io パッケージには、下記のような Reader インタフェースと Writer インタフェースが定義されています。 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } ここで、Read メソッドと Write メソッドを両方とも備えるインタフェースを単純に定義しようとすると、下記のように記述することになります。 type ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } Go 言語では、このようなケースのために 埋め込み (Embedding) の仕組みが提供されており、次のように既存のインタフェースを再利用する形で新しいインタフェースを定義することができます。 type ReadWriter interface { Reader Writer } ReadWriter インタフェースを備えるオブジェクトは、ReadWriter 型のパラメータを取る関数だけでなく、Reader 型のパラメータを取る関数や、Writer 型のパラメータを取る関数にも渡すことができます。 ちなみに、この ReadWriter インタフェースも標準の io パッケージで定義されています。 構造体埋め込み (Struct Embedding) 埋め込み (Embedding) の仕組みは、インタフェースだけでなく、構造体でも同様に使用することができます。 下記の例では、Product 構造体を埋め込む形で Stock 構造体を定義しています。 Product 構造体は、メソッドを１つ実装しています。 type Product struct { Model string Name string Price int } func (p *Product) AdLabel() string { return fmt.Sprintf(\u0026#34;%s (%s)\u0026#34;, p.Model, p.Name) } type Stock struct { *Product Quantity int } Product 構造体に定義されているフィールドやメソッドは、Stock オブジェクト経由で直接参照することができます。 Stock オブジェクトは下記のように生成します。 s := \u0026amp;Stock{ Product: \u0026amp;Product{Model: \u0026#34;PR102\u0026#34;, Name: \u0026#34;Printer\u0026#34;, Price: 300}, Quantity: 100, } fmt.Println(s.Model) //=\u0026gt; PR102 fmt.Println(s.AdLabel()) //=\u0026gt; Printer (PR102) オブジェクト生成時は、埋め込んだ構造体のオブジェクトを生成して初期化しなければいけないことに注意してください（初期化すべきフィールドの名前も、埋め込んだ構造体の型名と同じになります）。 次のように、埋め込んだ構造体のフィールドを直接初期化することはできません。 間違った初期化方法 s := \u0026amp;Stock{ Model: \u0026#34;PR102\u0026#34;, // 初期化時に Product のフィールドは参照できない Name: \u0026#34;Printer\u0026#34;, // 初期化時に Product のフィールドは参照できない Price: 300, // 初期化時に Product のフィールドは参照できない Quantity: 100, }"},{url:"/p/29dgjnq/",title:"ベンチマークを行う (testing.B)",date:"2017-09-12T00:00:00Z",body:"ベンチマークを行う (testing.B) Go のベンチマーク機能の基本的な使い方 Go にはテストフレームワーク（testing パッケージ）の一機能として、ベンチマークを行う仕組みが搭載されています。 ここでは、下記のような構造体を、「値渡し」した場合と、「ポインタ渡し」した場合のパフォーマンスの違いを調べてみましょう。 type Book struct { Title string Author string Price int } func CallByValue(b Book) { } func CallByPointer(b *Book) { } ベンチマーク実行用の関数は、下記のように、Benchmark という名前で始まり、*testing.B 型のパラメーターを持つ関数として定義します。 func BenchmarkXxxYyyZzz(b *testing.B) 例えば、次のような感じで実装します。 // CallByValue の実行速度を計測 func BenchmarkCallByValue(b *testing.B) { book := Book{\u0026#34;Golang\u0026#34;, \u0026#34;Maku\u0026#34;, 1500} for i := 0; i \u0026lt; b.N; i++ { CallByValue(book) } } // CallByPointer の実行速度を計測 func BenchmarkCallByPointer(b *testing.B) { book := Book{\u0026#34;Golang\u0026#34;, \u0026#34;Maku\u0026#34;, 1500} for i := 0; i \u0026lt; b.N; i++ { CallByPointer(\u0026amp;book) } } 上記のように、ループ回数に b.N を指定しておくと、有意な実行時間が計測できるまで繰り返し実行してくれるようになります。 ベンチマーク用の実装ファイルは、ファイル名のサフィックスを _test.go としておく必要があります（あくまでベンチマークはテストの一部という位置付け）。 下記に全体のコードを示しておきます。 sample_test.go package main import \u0026#34;testing\u0026#34; type Book struct { Title string Author string Price int } func CallByValue(b Book) { } func CallByPointer(b *Book) { } func BenchmarkCallByValue(b *testing.B) { book := Book{\u0026#34;Golang\u0026#34;, \u0026#34;Maku\u0026#34;, 1500} for i := 0; i \u0026lt; b.N; i++ { CallByValue(book) } } func BenchmarkCallByPointer(b *testing.B) { book := Book{\u0026#34;Golang\u0026#34;, \u0026#34;Maku\u0026#34;, 1500} for i := 0; i \u0026lt; b.N; i++ { CallByPointer(\u0026amp;book) } } ベンチマークを実行するときは、go test コマンドを -bench オプション付きで実行します。 $ go test -bench . goos: windows goarch: amd64 BenchmarkCallByValue-8 2000000000 1.62 ns/op BenchmarkCallByPointer-8 2000000000 0.27 ns/op PASS ok /Users/maku/sandbox 5.060s この結果は、CallByValue と CallByPointer がそれぞれ 2000000000 回実行され、１回あたりの実行にかかった時間が 1.62 ns と、0.27 ns であったことを示しています（ポインタ渡しの方が高速だということ）。 メモリの使用効率を調べる (benchmem) go test -bench でベンチマークを実行するときに、-benchmem オプションを追加で指定すると、実行速度だけではなく、メモリ割り当ての統計情報も一緒に表示してくれます。 下記のサンプルコードは、スライスの append 処理のベンチマークを取っています。 FuncA の方は、初期サイズ 0 からの append の繰り返し、FuncB の方は、あらかじめ初期容量を確保しおいてからの append の繰り返しを行っています。 sample_test.go package main import \u0026#34;testing\u0026#34; const SIZE = 10000 func FuncA() { s := []int{} for i := 0; i \u0026lt; SIZE; i++ { s = append(s, 1) } } func FuncB() { s := make([]int, 0, SIZE) for i := 0; i \u0026lt; SIZE; i++ { s = append(s, 1) } } func BenchmarkFuncA(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { FuncA() } } func BenchmarkFuncB(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { FuncB() } } 次のようにベンチマークを起動します。 -benchmem オプションは最後に指定することに注意してください。 $ go test -bench . -benchmem goos: windows goarch: amd64 BenchmarkFuncA-8 30000 40035 ns/op 386296 B/op 20 allocs/op BenchmarkFuncB-8 200000 9985 ns/op 81920 B/op 1 allocs/op PASS ok /Users/maku/sandbox 3.807s ベンチマーク結果の 386296 B/op 20 allocs/op というところは、386296 バイトのメモリを使用したということ、20 回のメモリアロケーションを行ったということを示しています。 つまり、FuncA が 20 回もスライスの容量を拡張しているのに対し、FuncB は最初に make 関数で容量を確保してから一度も拡張されていないということが読み取れます。 プログラムの実行速度が思わしくないときは、このように -benchmem オプションを追加してベンチマーク実行すれば、メモリ割り当てが影響しているかどうかを調べることができます。 セットアップに時間がかかるときは b.ResetTimer テスト用データの構築に時間がかかるようなケースで、それにかかった時間をベンチマーク結果には含めたくない場合は、セットアップ処理が終わった時点で b.ResetTimer() を呼ぶようにします。 func BenchmarkBigLen(b *testing.B) { big := NewBig() b.ResetTimer() // ここから計測開始 for i := 0; i \u0026lt; b.N; i++ { big.Len() } }"},{url:"/p/sy58beh/",title:"時刻データを扱う (time)",date:"2017-09-12T00:00:00Z",body:`時刻データを扱う (time) Go 言語で日付や時刻の情報を扱うには、組み込みの time パッケージを使用します。 時刻データ (time.Time) を作成する 現在時刻を取得する Go 言語で日時を表す型は、time パッケージで定義されている time.Time 型です。 現在の時刻を取得するには、time.Now 関数を使用します。 t := time.Now() fmt.Printf(\u0026#34;%v\\n\u0026#34;, t) // time.Time が保持する値を表示 fmt.Printf(\u0026#34;%T\\n\u0026#34;, t) // 型名を表示 実行結果 2017-09-12 21:23:23.7770078 +0900 JST m=+0.003000200 time.Time 日時を指定して作成する time.Date 関数を使用して、指定した日時の time.Time を作成することができます。 パラメータには、年、月、日、時、分、秒、ナノ秒、Location を指定します。 t := time.Date(2017, 9, 12, 23, 0, 0, 0, time.Local) fmt.Println(t) // \u0026#34;2017-09-12 23:00:00 +0900 JST\u0026#34; Location には、ローカルタイムで設定することを表す time.Local や、協定世界時で設定することを表す time.UTC を指定することができます。 文字列表現から作成する time.Parse 関数 を使用すると、日時を表す文字列から time.Time オブジェクトを作成することができます。 第 1 パラメータに、日時文字列の形式を表す layout string（後述）、第 2 パラメータに、実際に変換する文字列を渡します。 const layout = \u0026#34;2006-01-02\u0026#34; t, err := time.Parse(layout, \u0026#34;2017-09-27\u0026#34;) if err != nil { panic(err) } fmt.Println(t) // 2017-09-27 00:00:00 +0000 UTC layout string には、下記のようにいろいろなパターンを指定することができます。 const layout = \u0026#34;Jan 2, 2006 at 3:04pm (MST)\u0026#34; t, _ := time.Parse(layout, \u0026#34;Feb 3, 2013 at 7:54pm (PST)\u0026#34;) fmt.Println(t) // 2013-02-03 19:54:00 +0000 PST 指定しなかったフィールドは、0 で初期化されます。 例えば、下記のように日付だけを指定した場合は、０時０分０秒になります。 const layout = \u0026#34;2006-Jan-02\u0026#34; t, _ := time.Parse(layout, \u0026#34;2013-Feb-03\u0026#34;) fmt.Println(t) // 2013-02-03 00:00:00 +0000 UTC layout string 中に JST などのタイムゾーンを示す文字列を指定しない場合は、time.Parse が生成する時刻データは世界協定時 UTC の時刻が指定されたものとして扱われます。 ローカルタイムの時刻を指定して time.Time を生成したい場合は、次のように time.ParseInLocation 関数を使用します。 const layout = \u0026#34;2006-01-02 15:04:05\u0026#34; t, err := time.ParseInLocation(layout, \u0026#34;2017-01-01 00:00:00\u0026#34;, time.Local) if err != nil { panic(err) } fmt.Println(t) // 2017-01-01 00:00:00 +0900 JST layout string time.Parse 関数を使用して文字列から time.Time を作成するときや、Format メソッドで time.Time を文字列表現に変換するときには、どのような形式の文字列として扱うかを示す layout string を指定する必要があります。 layout string に指定する文字列は、2006年1月2日 15時4分5秒 (MST) の日時を表すパーツを組み合わせて指定する必要があります（Go 言語の time パッケージの決まりです）。 この日時を扱うのは、次のように 1 ～ 7 の数字が並べられることが理由のようです。 詳しくは公式ドキュメントを参照してください。 01/02 03:04:05PM \u0026#39;06 -0700 例えば、次のような文字列を layout string として使用することができます。 Mon Jan 2 15:04:05 -0700 MST 2006 2006-01-02 2006/01/02 2006-Jan-02 2006-01-02 15:04:05 2006-01-02T15:04:05 2006-01-02 (Mon) 15:04:05 Jan 2, 2006 at 3:04pm (MST) time パッケージには、下記のような layout string 定数があらかじめ定義されています。 const ( ANSIC = \u0026#34;Mon Jan _2 15:04:05 2006\u0026#34; UnixDate = \u0026#34;Mon Jan _2 15:04:05 MST 2006\u0026#34; RubyDate = \u0026#34;Mon Jan 02 15:04:05 -0700 2006\u0026#34; RFC822 = \u0026#34;02 Jan 06 15:04 MST\u0026#34; RFC822Z = \u0026#34;02 Jan 06 15:04 -0700\u0026#34; // RFC822 with numeric zone RFC850 = \u0026#34;Monday, 02-Jan-06 15:04:05 MST\u0026#34; RFC1123 = \u0026#34;Mon, 02 Jan 2006 15:04:05 MST\u0026#34; RFC1123Z = \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; // RFC1123 with numeric zone RFC3339 = \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; RFC3339Nano = \u0026#34;2006-01-02T15:04:05.999999999Z07:00\u0026#34; Kitchen = \u0026#34;3:04PM\u0026#34; // Handy time stamps. Stamp = \u0026#34;Jan _2 15:04:05\u0026#34; StampMilli = \u0026#34;Jan _2 15:04:05.000\u0026#34; StampMicro = \u0026#34;Jan _2 15:04:05.000000\u0026#34; StampNano = \u0026#34;Jan _2 15:04:05.000000000\u0026#34; ) 時刻情報を参照する 年、月、日、曜日、時、分、秒を取得する time.Time 構造体には、時分秒などの各パートの情報を切り出して取得するためのメソッドが用意されています。 t := time.Now() fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Year()) // 2017（年） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Month()) // 9（月） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Day()) // 12（日） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.YearDay()) // 255（年内通算日数） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Weekday()) // 2（曜日: time.Sunday==0） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Hour()) // 21（時） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Minute()) // 37（分） fmt.Printf(\u0026#34;%d\\n\u0026#34;, t.Second()) // 11（秒） 月や曜日は単純な int ではなく、time.Month と time.Weekday という型で定義されており、それぞれの月や曜日を表す定数も定義されています（time.January や time.Sunday）。 time.Month 型 \u0026hellip; type Month int time.Weekday 型 \u0026hellip; type Weekday int 上記の型には String() メソッド（fmt.Stringer インタフェース）が実装されているため、次のようにして文字列表現の月、曜日を取得することができます。 t := time.Now() month := t.Month().String() //=\u0026gt; \u0026#34;September\u0026#34; weekday := t.Weekday().String() //=\u0026gt; \u0026#34;Tuesday\u0026#34; もちろん、Printf 系メソッドのフォーマットで %s を指定して文字列表現で出力することもできます。 t := time.Now() fmt.Printf(\u0026#34;%s, %s\\n\u0026#34;, t.Month(), t.Weekday) //=\u0026gt; \u0026#34;September, Tuesday\u0026#34; 年月日データのみ、時分秒データのみを取得する パラメータなしの Date() メソッドは、年、月、日の情報を戻り値として返します。 同様に、Clock() メソッドは、時、分、秒の情報を戻り値として返します。 t := time.Now() year, month, day := t.Date() hour, minute, second := t.Clock() 文字列形式で出力する time.Format 関数 を使用すると、time.Time オブジェクトを任意のフォーマットの文字列に変換することができます。 Format 関数には、取得する文字列の形式を表す layout string を指定します。 main.go package main import \u0026#34;fmt\u0026#34; import \u0026#34;time\u0026#34; func main() { const layout = \u0026#34;2006-01-02 Mon 15:04:05 (MST)\u0026#34; t := time.Now() fmt.Println(t.Format(layout)) } 実行結果 2017-09-12 Tue 23:30:58 (JST) ちなみに、time.Time 構造体の String() 関数は下記のようなフォーマットで、文字列を返すように実装されています。 2006-01-02 15:04:05.999999999 -0700 MST`},{url:"/p/aimpsvz/",title:"Go 言語のインタフェースの扱いを理解する (interface)",date:"2017-09-11T00:00:00Z",body:`Go 言語のインタフェースの扱いを理解する (interface) Go 言語で、ある型にインタフェースを実装するときは、Java などとは異なり、implements キーワードを使ったインタフェースの明示は行いません。 Ruby や Python と同様に、同じシグネチャのメソッドを実装した時点で、そのインタフェースを備えているとみなされます。 インタフェースを定義する (type \u0026hellip; interface) Go 言語でインタフェースを定義するときは、構造体 (struct) の定義と同様に type キーワードを使用します。 下記は Go 言語で定義されているインタフェースの例です。 fmt.Stringer インタフェース type Stringer interface { String() string } io.Reader インタフェース type Reader interface { Read(p []byte) (n int, err error) } 上記の例からも想像できるように、Go 言語では、1 つのメソッドだけを持つインタフェースの名前は、メソッド名＋er とする規約となっています。 String 関数だけを持つ → Stringer インタフェース Read 関数だけを持つ → Reader インタフェース Write 関数だけを持つ → Writer インタフェース Format 関数だけを持つ → Formatter インタフェース インタフェースを使用する インタフェースを引数として受け取る関数を定義すると、そのインタフェースが定義するメソッドを実装しているオブジェクトだけを渡せるようになります。 func PrintSomething(s fmt.Stringer) { // String() メソッドを呼び出せることが保証されている fmt.Println(s.String()) } Java などの言語では、あるクラスがあるインタフェースを実装していることを示すために implements キーワードを使用しますが、Go 言語では明示的にインタフェース名を指定して実装することはありません。 ただ単純に、インタフェースによって示されているメソッドを実装するだけで、その型はそのインタフェースを備えている（実装している）とみなされます。 このような思想は Ruby や Python でも採用されており、通称 ダックタイピング と言われているものです（アヒルのように歩いて鳴けば、それはアヒルであるという考え方）。 例えば、下記の Book 構造体は、String() メソッドを実装しているため、Go コンパイラは fmt.Stringer インタフェースを備えているとみなします。 type Book struct { Title string Author string } func (this *Book) String() string { return fmt.Sprintf(\u0026#34;%s : %s\u0026#34;, this.Title, this.Author) } よって、この Book 構造体のインスタンスは、先に示した PrintSomething 関数に渡せることになります。 b := \u0026amp;Book{Title: \u0026#34;Golang\u0026#34;, Author: \u0026#34;Maku\u0026#34;} PrintSomething(b) //=\u0026gt; \u0026#34;Golang : Maku\u0026#34; また、Book は fmt.Stringer インタフェースを備えているので、fmt.Stringer 型の変数に代入することができます。 var s fmt.Stringer = \u0026amp;Book{Title: \u0026#34;Golang\u0026#34;, Author: \u0026#34;Maku\u0026#34;} println(s.String()) すべてのオブジェクトを示す空っぽインタフェース ここで、次のようにメソッドを１つも持たない空っぽのインタフェース (empty interface) を考えてみます。 interface{} Go 言語では、インタフェースが示すメソッドを実装していれば、そのインタフェースを備えていると判断されます。 つまり、上記のような空インタフェースは、すべての型が備えているインタフェースということになります（Java における Object クラスに近い）。 関数のパラメータとして、inteface{} 型を受け取るように実装されている場合は、任意の型のオブジェクト を渡すことができるということを示しています。 例えば、fmt.Println 関数は、任意の型の引数を複数受け取るように実装されています。 func Println(a ...interface{}) (n int, err error) また、空インタフェース型の変数を定義すると、その変数にはどのような型の値でも代入できるようになります。 var i interface{} // 空インタフェース型の変数を定義 空インタフェースのゼロ値は nil で、型も nil となります。 下記のサンプルコードは、空インタフェースに色々な型の値を代入できること、代入される値によって変数の型が変化することを示しています。 package main import \u0026#34;fmt\u0026#34; func printTypeAndValue(i interface{}) { fmt.Printf(\u0026#34;%v (type:%T)\\n\u0026#34;, i, i) } func main() { var i interface{} printTypeAndValue(i) // \u0026lt;nil\u0026gt; (type:\u0026lt;nil\u0026gt;) i = 100 printTypeAndValue(i) // 100 (type:int) i = \u0026#34;Hello\u0026#34; printTypeAndValue(i) // Hello (type:string) } 空インタフェースをパラメータとして受け取る関数の中で、型スイッチ (Type Switch) の仕組みを使用すれば、実際に渡された値の型によって処理を分岐することができます。`},{url:"/p/j47aswy/",title:"Golang のパニックによるエラー処理 (panic, recover)",date:"2017-09-11T00:00:00Z",body:"Golang のパニックによるエラー処理 (panic, recover) Go 言語には try ~ catch による例外処理の仕組みは存在しませんが、panic という仕組みが用意されています。 パニックとは？ Go 言語では、関数呼び出し時に発生するエラーは、error オブジェクトを戻り値として返す方法が採用されています（参考: 関数を定義する）。 一方で、実行を継続できないランタイムエラー（スライスの範囲外アクセスなど）が発生した場合には、パニック (panic) を発生させる仕組みになっています。 vals := []int{10, 20, 30} println(vals[3]) // panic: runtime error: index out of range [3] with length 3 パニックが発生すると、デフォルトでは プログラム全体が終了します。 一般的なアプリケーションではパニックは発生させるべきではなく、関数内でエラーが発生したときは error オブジェクトを返すことが推奨されています。 パニックを発生させる (panic) 関数の中から明示的にパニックを発生させるには、panic 関数を呼び出します。 panic 関数には、エラーの内容を示す error オブジェクトを渡すことができます。 import \u0026#34;errors\u0026#34; func dumpBook(b *Book) { if b == nil { panic(errors.New(\u0026#34;Book cannot be nil\u0026#34;)) } // ... } このようにパニックの仕組みは簡単に使えてしまいますが、実行を継続できないケースに限って使用すべきです。 通常シーケンスで発生するエラーに関しては、戻り値として error オブジェクトを返すようにし、呼び出し側で簡単にハンドルできるようにしておきましょう。 panic 関数の代わりに、log パッケージの log.Panicln 関数や log.Panicf 関数を使用すると、時刻付きのログを出力したあとで、パニックを発生させてくれます。 import \u0026#34;log\u0026#34; func foo() { log.Panicln(\u0026#34;Something wrong happened\u0026#34;) } パニックから復帰する (recover) 関数内の処理で、何らかのパニックが発生したとしても、あらかじめ defer 登録された処理は、関数を抜ける前に実行されます。 この defer 処理の中で recover 関数を呼び出すと、パニック発生時に panic 関数に渡されたオブジェクト（通常は error オブジェクト）を取得することができます。 パニック発生時には、通常はプログラム全体が終了しますが、defer 処理の中で recover を呼び出すように実装した場合、プログラムの実行は継続されます。 package main import \u0026#34;log\u0026#34; func hello() { // パニックをハンドルするための処理を defer 登録 defer func() { if err := recover(); err != nil { log.Printf(\u0026#34;ぎゃー: %v\u0026#34;, err) } }() // out of range エラーをわざと発生させる println([]int{}[0]) } func main() { hello() println(\u0026#34;パニックが発生してもここまで処理が継続される\u0026#34;) } 実行結果 2017/09/11 23:21:10 ぎゃー: runtime error: index out of range 2017/09/11 23:21:10 パニックが発生してもここまで処理が継続される 参考: Handling panics - The Go Programming Language"},{url:"/p/jruz369/",title:"型キャストと型アサーションによる型変換",date:"2017-09-11T00:00:00Z",body:`型キャストと型アサーションによる型変換 Go 言語では暗黙的な型キャストは許されていません。明示的な型変換関数を使用するか、Type Assertion という仕組みを使用して型の変換を行う必要があります。 型キャスト Go 言語では暗黙的な型変換は許されていないため、下記のような異なる型の変数への代入はコンパイルエラーになります。 var i int = 100 var f float64 = i // cannot use i (type int) as type float64 このようなケースでは、型名(値) という形で明示的な 型キャスト を行います。 var i int = 100 var f float64 = float64(i) // OK 下記は様々な型変換の例です。 int8 → int32 var a uint8 = 100 var b uint32 = uint32(a) int32 → int8 var a uint32 = 1234567890 var b uint8 = uint8(a) fmt.Println(b) // 210（情報が欠落する） string → []byte var str string = \u0026#34;ABC\u0026#34; var bytes []byte = []byte(str) fmt.Println(bytes) // [65 66 67] []byte → string bytes := []byte{65, 66, 67} str := string(bytes) fmt.Println(str) // \u0026#34;ABC\u0026#34; 型アサーション (Type Assertion) による型変換 Go 言語で任意の型の変数（型の定まっていない変数）は、空インタフェース型 (interface{}) として表現されます。 このような値を、特定の型 T の変数に代入するには、型アサーション (Type Assertion) という仕組みを使用する必要があります。 型アサーションは、下記のような構文で実行します。 var x = i.(T) x := i.(T) // 関数内であればこの省略形で OK これにより、空インタフェース型 (interface{}) の変数 i が、型 T の変数 x に代入されます。 空インタフェース型の i を、型 T に変換できない場合は パニック が発生します。 下記の doGreet 関数は、パラメータで受け取った任意の型のオブジェクトに対して、Greet メソッドを実行します。 空インタフェースは Greet メソッドを備えていないので、まずは、i.(Greeter) という型アサーションで Greeter 型に変換してから Greet メソッドを呼び出しています。 type Greeter interface { Greet() } func doGreet(i interface{}) { g := i.(Greeter) g.Greet() } 上記の doGreet 関数は、Greet() メソッドを実装したオブジェクトを渡された場合にうまく動作します。 下記のサンプルでは、Greet() メソッドを実装した People 構造体のオブジェクトを、doGreet 関数に渡しています。 type People struct { Name string } func (this *People) Greet() { fmt.Printf(\u0026#34;Hello, I am %s\\n\u0026#34;, this.Name) } func main() { p := \u0026amp;People{\u0026#34;Maku\u0026#34;} doGreet(p) //=\u0026gt; \u0026#34;Hello, I am Maku\u0026#34; } 逆に、Greet() メソッドを実装していないオブジェクトを doGreet 関数に渡すと、型アサーションによる型変換に失敗し、パニックが発生します。 doGreet(\u0026#34;Hoge\u0026#34;) // panic: interface conversion: // string is not main.Greeter: missing method Greet このように、実際に実行するまでパニックが発生するかどうか分からないような関数は、安心して実行することができません。 そこで、型アサーションには、型変換がうまくいったかどうかを調べる構文が用意されています（マップ のキーの有無を確認する構文と同じです）。 x, ok := i.(T) 上記のように、2 つの戻り値を受け取るように型アサーションを実行すると、2 番目の戻り値 (bool) で、型変換に成功したかどうかを判別することができます。 型変換に失敗してもパニックは発生せず、x には型 T のゼロ値が格納されます。 下記の doGreet 関数は、渡された interface{} オブジェクトを Greeter 型に変換できるか確認し、変換できた場合のみ Greet() メソッドを呼び出しています。 func doGreet(i interface{}) { if g, ok := i.(Greeter); ok { g.Greet() } else { fmt.Printf(\u0026#34;Type %T is not Greeter\\n\u0026#34;, i) } } func main() { doGreet(\u0026amp;People{\u0026#34;Maku\u0026#34;}) //=\u0026gt; Hello, I am Maku doGreet(100) //=\u0026gt; Type int is not Greeter doGreet(0.5) //=\u0026gt; Type float64 is not Greeter doGreet(\u0026#34;Hoge\u0026#34;) //=\u0026gt; Type string is not Greeter } ちなみに、より多くの型への型変換を試みなければならないケース (Printf のような関数の実装）では、型スイッチの構文 を使用するとより簡潔に記述することができます。`},{url:"/p/s4qbuez/",title:"Hugo で独自のテーマを作成する",date:"2017-09-10T00:00:00Z",body:"Hugo で独自のテーマを作成する 独自テーマの新規作成 Hugo には、ネット上に公開されているテンプレートがたくさんありますが、思い通りのデザインをするときは、自分でテーマを作成することになります。 テーマを作成するときは、まずは下記のコマンドで雛形を出力します。 $ hugo new theme \u0026lt;テーマ名\u0026gt; 例えば下記のように実行すると、themes/my-theme ディレクトリが生成されます。 $ hugo new theme my-theme 生成されるファイル群は下記のようになっていて、ディレクトリ構成はバッチシできていますが、ファイル内の記述はほとんど空っぽです。 このファイル群をベースにして、テンプレートを作成していきます。 独自テーマの雛形 themes/my-theme/ ├── LICENSE.md （MIT ライセンス） ├── archetypes/ │ └── default.md （ほぼ空っぽ） ├── layouts/ │ ├── 404.html （空っぽ） │ ├── _default/ │ │ ├── list.html （空っぽ） │ │ └── single.html （空っぽ） │ ├── index.html （空っぽ） │ └── partials/ │ ├── footer.html （空っぽ） │ └── header.html （空っぽ） ├── static/ │ ├── css/ │ └── js/ └── theme.toml （デフォルトの設定ファイル） トップページのレイアウト (layouts/index.html) を作成する 図: 独自テーマを使ったはじめてのページ テーマディレクトリ内の layouts/index.html は、サイトのトップページ用のテンプレートファイルです。 もし、ひとつの HTML ファイルだけで構成されるサイト (SPA: Single Page Application) を作成するのであれば、このファイルだけを作成すればよいことになります。 初期状態では何も記述されていないので、まずは手始めに、サイト名だけを表示するように修正してみましょう。 themes/my-theme/layouts/index.html \u0026lt;h1\u0026gt;{{ .Site.Title }}\u0026lt;/h1\u0026gt; 上記のようにすると、サイト情報を保持する .Site 変数の、Title フィールドの値を出力することができます。 ここには、サイトの設定ファイル (config.toml) の title に設定した値が展開されます。 ここまで作成したら、このテーマを使ってサイトを表示してみましょう。 hugo コマンドで使用するテーマを指定するには、-t \u0026lt;テーマ名\u0026gt; オプションを使用します。 $ hugo server -t my-theme 上記のように Hugo サーバを立ち上げたら、http://localhost:1313/ にアクセスすれば、表示を確認できます。 トップページに全ページのリストを表示する トップページのテンプレート (layouts/index.html) 内で、.Data.Pages 変数を参照すると、すべてのページの情報 (Page 変数) を取得することができます。 この情報を range を使ってループ処理すれば、すべてのページへのリンクを出力することができます。 themes/my-theme/layouts/index.html \u0026lt;h1\u0026gt;{{ .Site.Title }}\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {{ range .Data.Pages }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; ({{ .Date.Format \u0026#34;2006-01-02\u0026#34; }})\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; 各ページ用のレイアウトを作成する (layouts/_default/single.html) リンク先の各ページは、layouts/_default/single.html テンプレートファイルを元に生成されるので、このファイルもあらかじめ作成しておく必要があります。 このテンプレートの中では、Page 変数 のフィールドを参照することができます。 例えば、.Title でページタイトル、.Content でページ本文を参照できます。 themes/my-theme/layouts/_default/single.html \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} 各ページの内容は、content/ ディレクトリ内に下記のような感じで作成しておきます。 content/page1.md --- title: \u0026#34;Page1 Title\u0026#34; date: \u0026#34;2017-09-10\u0026#34; --- Page1 Content 上記のようにレイアウトファイルとコンテンツを作成しておけば、各ページの内容が下記のように表示されるはずです。 図: シングルページテンプレートによる出力 あとは、同様にして layouts ディレクトリ内のテンプレートコードを育てていくことで独自テーマが完成します。 Markdown ファイルから使える ショートコード なども独自テーマの付属品 (layouts/shortcodes) として提供できます。"},{url:"/p/z8behko/",title:"テンプレート機能を使用する (text/template, html/template)",date:"2017-09-10T00:00:00Z",body:"テンプレート機能を使用する (text/template, html/template) Go には標準パッケージとしてテンプレート機能が用意されています。 テンプレート機能は、定型の Web ページ作成などに活用できます。 ２つのテンプレートパッケージ Go 言語には、組込みのテンプレート・パッケージとして、text/template と html/template パッケージが搭載されています。 Web ページの構築に使用する場合は、パラメータを HTML エスケープ処理してくれる html/template パッケージの方を利用します。 text/template Package html/template Package テンプレート機能の基本的な使い方 Template オブジェクトの生成 テンプレート機能を使用するには、まずは Template オブジェクトを生成します。 テンプレートファイルを使用する場合は template.ParseFiles 関数、文字列データをテンプレートとして使用する場合は template.Parse 関数を使用します。 t, err := template.ParseFiles(\u0026#34;./template.html\u0026#34;) if err != nil { log.Fatal(err) } テンプレートファイルのパース処理が成功することが分かっている場合は、次のように template.Must 関数を組み合わせて使用することで、エラー処理の記述を省略することができます（エラーになった場合は panic が発生します）。 t := template.Must(template.ParseFiles(\u0026#34;./template.html\u0026#34;)) テンプレートへの値の埋め込み テンプレートへの値の埋め込みは、Template オブジェクトの Execute メソッドによって行います。 第一引数には出力先、第二引数には埋め込むデータを渡します。 data := \u0026#34;Hello World\u0026#34; if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } 渡されたデータは、テンプレートファイル内の、{{ . }} という部分に展開されます。 この構文は、Hugo という静的サイトジェネレーターを使っている場合はおなじみかもしれません。 下記はシンプルなテンプレートファイルの例です。 template.html \u0026lt;h1\u0026gt;{{ . }}\u0026lt;/h1\u0026gt; 出力結果 \u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt; 全体のコード sample.go package main import ( \u0026#34;html/template\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // テンプレートの読み込み t := template.Must(template.ParseFiles(\u0026#34;./template.html\u0026#34;)) // 値の埋め込み data := \u0026#34;Hello World\u0026#34; if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } テンプレートへの入力データとしてマップや構造体を使用する Template オブジェクトの Execute メソッドには、単純な文字列だけではなく、マップや構造体を渡すこともできます（こちらの方が一般的）。 下記のコードでは、３つのキーを持つマップを渡しています。 data := map[string]int{ \u0026#34;key1\u0026#34;: 100, \u0026#34;key2\u0026#34;: 200, \u0026#34;key3\u0026#34;: 300, } if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } 渡されたデータは、テンプレート内で {{ .キー名 }} で参照することができます。 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ .key1 }} \u0026lt;li\u0026gt;{{ .key2 }} \u0026lt;li\u0026gt;{{ .key3 }} \u0026lt;/ul\u0026gt; 次のサンプルコードでは、構造体のオブジェクトをテンプレートに渡しています。 type Book struct { Title string Author string } data := Book{Title: \u0026#34;Golang\u0026#34;, Author: \u0026#34;Maku\u0026#34;} if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } テンプレートに渡された構造体の各フィルードの値も、マップの場合と同様な形式でアクセスすることができます。 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;{{ .Title }} \u0026lt;li\u0026gt;{{ .Author }} \u0026lt;/ul\u0026gt; 構造体のフィールドとして、構造体やマップを持っているようなケースでは、次のようにドットで連鎖させることで参照できます。 \u0026lt;h1\u0026gt;{{ .Site.Title }}\u0026lt;/h1\u0026gt; テンプレート内でのループ処理 range キーワードを使用すると、テンプレートファイル内でループ処理を行うことができます。 template.html \u0026lt;ul\u0026gt; {{ range . }} \u0026lt;li\u0026gt;{{ . }} {{ end }} \u0026lt;/ul\u0026gt; sample.go package main import \u0026#34;html/template\u0026#34; import \u0026#34;os\u0026#34; func main() { t := template.Must(template.ParseFiles(\u0026#34;./template.html\u0026#34;)) data := []string{\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;} if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } 出力結果 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;AAA \u0026lt;li\u0026gt;BBB \u0026lt;li\u0026gt;CCC \u0026lt;/ul\u0026gt; Go 言語のように、インデックスと値を取得しながらループ処理することもできます。 \u0026lt;ul\u0026gt; {{ range $i, $val := . }} \u0026lt;ul\u0026gt;{{ $i }} : {{ $val }} {{ end }} \u0026lt;/ul\u0026gt; 出力結果 \u0026lt;ul\u0026gt; \u0026lt;ul\u0026gt;0 : AAA \u0026lt;ul\u0026gt;1 : BBB \u0026lt;ul\u0026gt;2 : CCC \u0026lt;/ul\u0026gt; テンプレートの中からテンプレートをインクードする テンプレートファイルの中で、template 関数を使用すると、別のテンプレートファイルの内容をそこに展開することができます。 template.html \u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; {{ template \u0026#34;partial.html\u0026#34; . }} \u0026lt;/p\u0026gt; partial.html Hello, \u0026lt;b\u0026gt;{{ . }}\u0026lt;/b\u0026gt; 入れ子構造で読み込むテンプレートファイルも、template.ParseFiles 関数で指定しておく必要があります。 sample.go package main import \u0026#34;html/template\u0026#34; import \u0026#34;os\u0026#34; func main() { t := template.Must(template.ParseFiles(\u0026#34;template.html\u0026#34;, \u0026#34;partial.html\u0026#34;)) if err := t.Execute(os.Stdout, \u0026#34;Maku\u0026#34;); err != nil { panic(err) } } 実行結果 \u0026lt;h1\u0026gt;Hello\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Hello, \u0026lt;b\u0026gt;Maku\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; その他 コメント テンプレートファイルの中で、{{/* と */}} で囲んだ部分はコメントと見なされ、テンプレートのコンパイル時に削除されます。 {{/* これはコメント */}} 前後の空白を削除 テンプレート内で値を出力するときに、{{- と -}} で囲むようにすると、前後のスペース（前のタグからそこまでと、そこから後ろのタグまでのスペース）を削除して出力することができます。 template.html（置換部分の前後のスペースを削除） \u0026lt;p\u0026gt; {{- . -}} \u0026lt;/p\u0026gt; 出力結果 \u0026lt;p\u0026gt;Hello\u0026lt;/p\u0026gt; 前方のスペースのみ、あるいは、後方のスペースのみを削除することもできます。 template.html（置換部分の前のスペースだけ削除） \u0026lt;p\u0026gt; {{- . }} \u0026lt;/p\u0026gt; 出力結果 \u0026lt;p\u0026gt;Hello \u0026lt;/p\u0026gt;"},{url:"/p/6eimpsv/",title:"Golang でファイルを読み書きする (os, io)",date:"2017-09-08T00:00:00Z",body:`Golang でファイルを読み書きする (os, io) Go 言語でファイルの読み書きを行うには、os パッケージや io パッケージを使用します。 ファイルからバイトデータを読み出す（io.Reader） 既存のファイルを読み込み用にオープンするには、os.Open 関数を使用して下記のようにします。 // ファイルを読み取りオープン file, err := os.Open(\u0026#34;./input.txt\u0026#34;) // *os.File if err != nil { log.Fatal(err) } defer file.Close() // 関数を抜けるときに自動実行 defer キーワードでクローズ処理を登録しておくことで、関数から抜けるときに自動的にファイルクローズを実行してくれるようになります。 ファイルを扱うときは、常にこのように記述しておくことで、関数の途中で return したときなどのクローズ忘れを防ぐことができます。 ファイルを開いてすぐに実行すべきイディオムとして覚えておきましょう。 ファイルのオープンに失敗すると、２番目の戻り値として error オブジェクトが返され、下記のようなエラーメッセージを表示して終了 (log.Fatal) します。 2017/09/08 23:43:40 open ./input.txt: The system cannot find the file specified. ファイルのオープンに成功したら、取得した os.File オブジェクトの Read メソッドを使用して読み出し処理を行います（Read は io.Reader インタフェースで定義されているメソッドです）。 Read メソッドは、引数で渡した []byte スライスにファイルの内容を読み込みます。 一度に読み込むサイズは、パラメータとして渡すスライスの長さ (len(s)) になるため、あらかじめ make 関数などを使ってスライス長を確保しておく必要があります。 Read 関数は、ファイルの末尾まで読み込み終わると、0, io.EOF を返します。 ２番目の戻り値が io.EOF になるまで繰り返し Read を実行するようにすれば、すべてのデータを読み出すことができます。 // 10 バイト分のバッファを用意 buf := make([]byte, 10) // ファイルから読み出し for { count, err := file.Read(buf) if err == io.EOF { break // Reached to EOF } if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%q\\n\u0026#34;, buf[:count]) } 下記は、サンプルの入力ファイルと、実行可能な全体のコード、実行結果です。 ここでは、分かりやすさのために入力ファイルとしてテキストファイル (input.txt) を使用していますが、Read メソッドによる読み出しは、通常はバイナリファイルを扱うことを想定しています。 input.txt AAA BBB CCC DDD EEE FFF GGG HHH III sample.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // ファイルを読み取りオープン file, err := os.Open(\u0026#34;./input.txt\u0026#34;) // *os.File if err != nil { log.Fatal(err) } defer file.Close() // 関数脱出時に実行 // ファイルから読み出し buf := make([]byte, 10) for { count, err := file.Read(buf) if err == io.EOF { break // Reached to EOF } if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%q\\n\u0026#34;, buf[:count]) } } 実行結果 $ go run sample.go \u0026#34;AAA BBB CC\u0026#34; \u0026#34;C\\nDDD EEE \u0026#34; \u0026#34;FFF\\nGGG HH\u0026#34; \u0026#34;H III\\n\u0026#34; ファイルを一度に読み出す (os.ReadFile) io.Reader インタフェースで定義されている Read メソッドは、指定したサイズのバイトデータしか読み込めませんが、os.ReadFile を使用すると、ファイル全体を一度に読み出すことができます。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { bytes, err := os.ReadFile(\u0026#34;./input.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(string(bytes)) // os.Stdout.Write(bytes) } ちなみに、os.ReadFile はファイルの読み出し専用ですが、代わりに io.ReadAll を使用すると、io.Reader を実装した任意のインスタンスから全データを読み出すことができます。 次の例では、string.Reader からすべてのテキストを読み出しています。 r := strings.NewReader(\u0026#34;AAA\\nBBB\\nCCC\u0026#34;) bytes, err := io.ReadAll(r) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%s\\n\u0026#34;, bytes) テキストファイルを 1 行ずつ読み出す (bufio.Scanner) Read([]byte) 関数を使ったファイルの読み出しは、byte スライスによる読み出しになってしまうため、テキストファイルを 1 行ずつ読み出したい場合などに不便です。 テキストファイルを 1 行ずつ読み出すときは bufio.Scanner を使用すると簡単です。 bufio.Scanner を使用すると、テキストファイルの内容を 1 行ごとに string オブジェクトの形で取得していくことができます。 bufio.Scanner オブジェクトは、下記のファクトリ関数で生成することができます。 io.File オブジェクトは Read メソッドを実装しているため、このファクトリ関数のパラメータとして渡すことができます。 func bufio.NewScanner(r io.Reader) *Scanner 下記に、テキストファイル input.txt を 1 行ずつ読み出すサンプルコードを示します。 sample.go package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // ファイルを読み出し用にオープン file, err := os.Open(\u0026#34;./input.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // 1 行ずつ読み出し scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() fmt.Println(line) } // スキャン時のエラーをハンドル if err := scanner.Err(); err != nil { log.Fatal(err) } } scanner.Scan のループ処理を抜けた後に、scanner.Err メソッドでエラーの有無をチェックする必要があることに注意してください。 実行結果 $ go run sample.go AAA BBB CCC DDD EEE FFF GGG HHH III ファイルにバイトデータを書き込む (io.Writer, os.WriteFile) io.Writer の Write メソッドを使う方法 ファイルを書き込み用にオープン（新規作成）するには、os.Create 関数を使用します（読み出しのときは os.Open）。 os.Create はファイルのオープンに成功すると *os.File を返します。 os.File の Write([]byte) メソッドを使用して、バイトデータを書き込むことができます。 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // ファイルを書き込み用にオープン (mode=0666) file, err := os.Create(\u0026#34;./output.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() data := []byte(\u0026#34;Hello\\nWorld\u0026#34;) _, err = file.Write(data) if err != nil { log.Fatal(err) } } os.WriteFile 関数を使う方法 os.WriteFile 関数を使うと、ファイル名と書き込むバイトデータを指定するだけで、ファイルへの出力を一気に済ませることができます。 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { bytes := []byte(\u0026#34;Hello\\nWorld\u0026#34;) if err := os.WriteFile(\u0026#34;./output.txt\u0026#34;, bytes, 0666); err != nil { log.Fatal(err) } } ファイルに 1 行ずつテキストを書き込む (WriteString) os.File が実装している io.Writer インタフェースの Write([]byte) メソッドは、バイトデータの書き込みを想定しているため、テキストデータの書き込みには不便です（string を []byte に変換する手間がかかります）。 os.File は、実は WriteString(string) というメソッドを備えており、これを使用すると、指定したテキストデータ (string) をそのまま書き込むことができます。 package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // ファイルを書き込み用にオープン (mode=0666) file, err := os.Create(\u0026#34;./output.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // テキストを書き込む _, err = file.WriteString(\u0026#34;Hello\\nWorld\\n\u0026#34;) if err != nil { log.Fatal(err) } } 参考: Golang で JSON 形式の文字列やファイルを扱う (encoding/json)`},{url:"/p/5cgjnqt/",title:"マップを扱う (map)",date:"2017-09-05T00:00:00Z",body:`マップを扱う (map) Go 言語でマップを定義するには、map キーワードを使用します。 マップを定義する (map) Go 言語のマップ型は、map[キーの型]値の型 のように表現します。 どこにもスペースをいれないことに注意してください（go fmt コマンドで自動的にこのようにフォーマットされます）。 例えば、キーの型を string、値の型を int とするマップは次のように作成できます。 空のマップを作る方法 var m = map[string]int{} m := map[string]int{} // 関数内ではこの省略形が使える m := make(map[string]int) // make を使う方法 次のように初期値を指定せずにマップを作成するとゼロ値 (nil) になります。 要素数ゼロのマップとして参照はできますが、要素を追加しようとすると panic が発生します。 あまり意味のない nil マップの作成方法 var m map[string]int // これはゼロ値 (nil) になる println(len(m)) // 0 m[\u0026#34;maku\u0026#34;] = 14 // panic 配列やスライス と同様、初期値を同時に設定してしまうこともできます（前述の例では初期値を空っぽ {} にしています）。 下記のように複数行に分けて初期値を記述する場合、最後の要素の後ろのカンマは省略できないことに注意してください。 m := map[string]int{ \u0026#34;maku\u0026#34;: 14, \u0026#34;puni\u0026#34;: 7, \u0026#34;hemu\u0026#34;: 10, } fmt.Printf(\u0026#34;%v\\n\u0026#34;, m) //=\u0026gt; map[maku:14 puni:7 hemu:10] マップ要素を参照するときは、配列やスライスと同様に [] を使用してキーを指定します。 存在しないキーを指定して新しい値を設定することもできます。 i := m[\u0026#34;maku\u0026#34;] // 既存の要素の取得 m[\u0026#34;panyo\u0026#34;] = 20 // 新しい要素を追加 マップの要素を for ループで処理する (range) マップの要素は、配列やスライスと同様に for ループと range を使ってひとつずつ取得することができます。 m := map[string]int{ \u0026#34;maku\u0026#34;: 14, \u0026#34;puni\u0026#34;: 7, \u0026#34;hemu\u0026#34;: 10, } for k, v := range m { fmt.Printf(\u0026#34;key: %s, value: %d\\n\u0026#34;, k, v) } 実行結果 key: maku, value: 14 key: puni, value: 7 key: hemu, value: 10 あるキーが存在するかどうか調べる マップに存在していないキーを指定すると、値の型の ゼロ値 が返されます（例えば int 型の値であれば 0 です）。 i := m[\u0026#34;panyo\u0026#34;] //=\u0026gt; 0 そのため、マップの値を参照してゼロ値が返された場合、「キーが存在しない」のか、あるいは「値として 0 が格納されている」のかを区別することができません。 キーがもともと存在していたのかどうかを判別するには、2 つ目の戻り値として返される bool 値 を参照します。 val, ok := m[\u0026#34;maku\u0026#34;] if ok { println(val) } else { println(\u0026#34;見つからない\u0026#34;) } 取得した値を if ブロックの中でしか参照しないのであれば、下記のように変数スコープを限定してしまうのがよいです。 if val, ok := m[\u0026#34;maku\u0026#34;]; ok { println(val) } else { println(\u0026#34;見つからない\u0026#34;) } キーの存在のみを調べたいときは、1 つ目の戻り値をアンダースコア (_) で受け取って無視します。 if _, ok := m[\u0026#34;maku\u0026#34;]; ok { println(\u0026#34;あるよ\u0026#34;) } マップの要素を削除する (delete) 組み込み関数の delete を使用すると、マップから指定したキーの要素を削除することができます。 m := map[string]int{ \u0026#34;maku\u0026#34;: 100, \u0026#34;pani\u0026#34;: 200, } println(len(m)) //=\u0026gt; 2 println(m[\u0026#34;maku\u0026#34;]) //=\u0026gt; 100 delete(m, \u0026#34;maku\u0026#34;) // キー \u0026#34;maku\u0026#34; を削除する println(len(m)) //=\u0026gt; 1（サイズが減っている） println(m[\u0026#34;maku\u0026#34;]) //=\u0026gt; 0（存在しないキーを参照するとゼロ値が返される） 削除しようとしたキーが存在しなかった場合は、何も実行されません（エラーにはなりません）。 マップの値としてマップを持つ マップの値にマップを持つマップを定義することもできます。 値として map[string]int というマップを持つマップを定義する m := map[string]map[string]int{ \u0026#34;maku\u0026#34;: {\u0026#34;aaa\u0026#34;: 10, \u0026#34;bbb\u0026#34;: 20}, \u0026#34;puni\u0026#34;: {\u0026#34;aaa\u0026#34;: 30, \u0026#34;bbb\u0026#34;: 40}, \u0026#34;hemu\u0026#34;: {\u0026#34;aaa\u0026#34;: 50, \u0026#34;bbb\u0026#34;: 60}, } fmt.Println(m[\u0026#34;maku\u0026#34;][\u0026#34;aaa\u0026#34;]) //=\u0026gt; 10 この場合も、型名にはどこにもスペースを入れてはいけません。 若干読みにくいですが、気合いで読み解きましょう。 マップのキーでソートした順に要素を取り出す Go 言語には、マップをキー順にソートしてループ処理する簡潔な方法はないようです。 以下のサンプルでは、キーのリストを自力で作成し、そのリストをソートしています。 main.go package main import \u0026#34;fmt\u0026#34; import \u0026#34;sort\u0026#34; func main() { m := map[string]int{ \u0026#34;ccc\u0026#34;: 10, \u0026#34;aaa\u0026#34;: 20, \u0026#34;bbb\u0026#34;: 30, } // ソート済みのキーリストを作成する keys := make([]string, 0, len(m)) for k := range m { keys = append(keys, k) } sort.Strings(keys) // キーの型が int なら sort.Ints とする // キーリストの順番通りに値を列挙する for _, k := range keys { fmt.Println(\u0026#34;key:\u0026#34;, k, \u0026#34;value:\u0026#34;, m[k]) } } 実行結果 $ go run main.go key: aaa value: 20 key: bbb value: 30 key: ccc value: 10`},{url:"/p/4behkor/",title:"メソッドを定義する（レシーバ付き関数）",date:"2017-09-05T00:00:00Z",body:"メソッドを定義する（レシーバ付き関数） Go 言語にはクラスは存在しませんが、構造体型にメソッドを追加するという方法で同様のことを実現することができます。 メソッドは次のような文法で定義します。 func (レシーバ) 関数名(パラメータ) 戻り値 { ... } 通常の関数定義の関数名の前に、(レシーバ) という部分が追加されただけです。 例えば、下記の raisePrice メソッドは、レシーバとして Book オブジェクトを受け取り、そのフィールド値を書き換えます。 パラメータと戻り値はありません。 func (b *Book) raisePrice() { b.Price *= 2 } フィールド値を書き換える場合は、このようにレシーバをポインタ型で指定する必要があります。 このメソッドを呼び出すには、次のようにレシーバとして渡すオブジェクトにドットを付けて呼び出します。 b.raisePrice() // raisePrice メソッドの呼び出し 下記は、完全に動作するサンプルコードです。 package main // Book 構造体を定義 type Book struct { Title string Price int } // Book 構造体にメソッドを追加 func (b *Book) raisePrice() { b.Price *= 2 } func main() { b := Book{Title: \u0026#34;Golang\u0026#34;, Price: 2500} println(b.Price) // 2500 b.raisePrice() println(b.Price) // 5000 }"},{url:"/p/8z2o63r/",title:"構造体を定義する (struct)",date:"2017-09-05T00:00:00Z",body:"構造体を定義する (struct) Go 言語の構造体は、struct というキーワードを使って定義します。 構造体の基本 構造体は、複数のデータをまとめて扱うためのデータ構造です。 下記の例では、書籍のタイトルと著者、値段をフィールドとして持つ Book という構造体を定義しています。 type Book struct { Title string Authors []string Price int } 組込み型に別名を付ける ときには type Age int のように記述しますが、この後ろの int の部分が struct {...} という記述に置き換わったと考えればよいでしょう。 定義した構造体は下記のように使用することができます。 // Book 構造体を定義する type Book struct { Title string Authors []string Price int } func main() { // Book オブジェクトを生成する b := Book{ Title: \u0026#34;Golang ABC\u0026#34;, Authors: []string{\u0026#34;Maku\u0026#34;, \u0026#34;Moja\u0026#34;}, Price: 2500, } // 各フィールドの値を参照する fmt.Println(b.Title) // Golang ABC fmt.Println(b.Authors) // [Maku Moja] fmt.Println(b.Price) // 2500 } この例では、各フィールドの 名前を大文字で始めている（例えば Title）ので、そのフィールドは別のパッケージからも参照可能なフィールドとして公開されます。 逆に小文字で始める（例えば title）ように定義すると、そのフィールドは同じパッケージ内のコードからのみ参照できるようになります（≒ 同じディレクトリ内の .go ファイルであれば参照できる）。 ちなみに、オブジェクトを生成するときに、下記のようにフィールド名を省略して初期値を設定することもできます。 その場合は、構造体定義時と同じ順序で、すべてのフィールドの初期値を指定する必要があります。 b := Book{\u0026#34;Golang ABC\u0026#34;, []string{\u0026#34;Maku\u0026#34;, \u0026#34;Moja\u0026#34;}, 2500} フィールド名を指定する方法であれば、任意のフィールドの初期値を省略してオブジェクトを生成することができます。 省略したフィールドの値は、その型の ゼロ値 となります。 // すべてのフィールドを省略 b1 := Book{} //=\u0026gt; \u0026#34;\u0026#34;, [], 0 // Title フィールドだけ初期値を指定 b2 := Book{Title: \u0026#34;Golang\u0026#34;} //=\u0026gt; \u0026#34;Golang\u0026#34;, [], 0 構造体へのポインタ 関数に渡された構造体データのフィールドを書き換えたいときは、ポインタ型で渡す必要があります（そうしないとコピーが渡されてしまいます）。 下記サンプルの、raisePrice 関数は、渡された Book オブジェクトの Price フィールドの値を２倍に書き換えます。 func raisePrice(b *Book) { b.Price *= 2 } func main() { b := Book{ Title: \u0026#34;Golang ABC\u0026#34;, Price: 2500, } raisePrice(\u0026amp;b) fmt.Println(b.Price) //=\u0026gt; 5000（2倍になってる） } C/C++ の文法とは異なり、ポインタ経由のフィールドアクセスにもドット (.) を使用していることに注目してください。 C/C++ の場合: b-\u0026gt;Price Go の場合: b.Price Go 言語では、ポインタ経由のアクセスも同じ記法を使えるようにすることで、コードをシンプルに保てるようにしています。 この性質を利用すると、上記の main 関数は下記のように書き直すことができます。 変数 b を最初からポインタ型として定義してしまうことで、それ以降のコードで \u0026amp;b のような形でアドレス取得する手間を省くことができます（ここでは一か所だけですけどね＾＾）。 func main() { b := \u0026amp;Book{ Title: \u0026#34;Golang ABC\u0026#34;, Price: 2500, } raisePrice(b) fmt.Println(b.Price) } ここでのサンプルコードでは、raisePrice 関数のパラメータとして Book ポインタを受け取るように実装しましたが、オブジェクト指向風に実装するのであれば、メソッドの形で実装 してしまえばシンプルになります。 new 関数による初期化 すべてのフィールドをゼロ値で初期化したオブジェクトを生成するときは、new(型) という組込み関数を使って C++ 風の書き方をすることもできます。 new 関数の戻り値は、指定した型のポインタとなります。 空のオブジェクトを生成する方法いろいろ var b *Book = new(Book) var b *Book = \u0026amp;Book{} // 関数内なら次のように簡潔に書けます b := new(Book) b := \u0026amp;Book{} \u0026amp;Book{} の形式を使うとタイプ数を削減できますが、new(Book) の方がわかりやすいかもしれません。"},{url:"/p/cuxyj8c/",title:"組込み型に独自の型名を付ける (type)",date:"2017-09-05T00:00:00Z",body:`組込み型に独自の型名を付ける (type) 独自型を定義する Go 言語で type キーワードを使用すると、組込み型に新しい名前を付けることができます。 これは単なるエイリアスではなく新しい型として認識されるので、コンパイル時の型チェックの対象となり、コーディングミスを減らすことができます。 また、自身の値を操作対象とするメソッドを追加することができます。 次のような構文で、既存の組込み型をベースにして、新しい型を定義することができます。 type 型名 既存の型 下記の例では、string 型と同じように使用できる Title 型と Author 型を定義しています。 type Title string type Author string 独自型で型安全なコードを記述する 独自に定義した型を関数のパラメータの型として使うことで、コンパイル時に正しい型のデータが渡されているかをチェックしてくれるようになります。 独自型を使った型安全なコード package main import \u0026#34;fmt\u0026#34; type Title string type Author string func printBook(title Title, author Author) { fmt.Printf(\u0026#34;Title:\u0026#39;%s\u0026#39;, Author:\u0026#39;%s\u0026#39;\\n\u0026#34;, title, author) } func main() { t := Title(\u0026#34;Golang ABC\u0026#34;) // var t Title = \u0026#34;Golang ABC\u0026#34; でも OK a := Author(\u0026#34;Maku\u0026#34;) // var a Author = \u0026#34;Maku\u0026#34; でも OK printBook(t, a) } 上記の printBook 関数は、パラメータとして Title、Author 型の値を受け取るように定義しているため、組み込み型の string 変数を渡そうとするとコンパイルエラーになります。 エラーになる例 t := \u0026#34;Golang ABC\u0026#34; // これは標準の string 型 a := \u0026#34;Maku\u0026#34; printBook(t, a) // Error: cannot use t (type string) as type Title このチェックのおかげで、Title と Author の順番を間違えて渡してしまうといったコーディングミスを防ぐことができます。 ただし、下記のように文字列リテラルを直接渡してしまうと、コンパイルエラーとしては検出してくれないので注意してください。 printBook(\u0026#34;Golang ABC\u0026#34;, \u0026#34;Maku\u0026#34;) // これはエラーにならない 独自型にメソッドを追加する 新しい型を作成することのもうひとつの利点として、メソッドによる拡張があります。 int や string などの組み込み型にはメソッドを追加することはできませんが、独自の型には追加できます。 例えば、次の Age 型（中身は int）は String() メソッド（fmt.Stringer インタフェース）を実装し、fmt.Println などに渡したときの出力をカスタマイズしています。 package main import \u0026#34;fmt\u0026#34; type Age int func (a Age) String() string { return fmt.Sprintf(\u0026#34;%d years old\u0026#34;, a) } func main() { a := Age(14) fmt.Println(a) //=\u0026gt; 14 years old }`},{url:"/p/vpz8fnv/",title:"ポインタを扱う (＊)",date:"2017-09-04T00:00:00Z",body:`ポインタを扱う (＊) Go 言語には、C/C++ と同様にポインタが存在します。構文もかなり似ていますが、簡潔に記述できるような工夫がされています。 Go 言語のポインタの基本 Go 言語では、変数の型のプレフィックスとしてアスタリスク (*) を付けると、ポインタ型の変数になります。 ポインタ変数は、その型の値が格納されているメモリアドレスを保持します。 ポインタ変数のゼロ値（初期値）は nil です。 var p *int // p is a pointer to int fmt.Printf(\u0026#34;%v\\n\u0026#34;, p) // \u0026lt;nil\u0026gt; 既存の変数のアドレスは \u0026amp; プレフィックスをつけて取得できます。 次の例では、int 型変数 i のアドレスを p に格納しています。 i := 100 p := \u0026amp;i fmt.Printf(\u0026#34;%v (%T)\\n\u0026#34;, i, i) // 100 (int) fmt.Printf(\u0026#34;%v (%T)\\n\u0026#34;, p, p) // 0xc00018a000 (*int) 逆にポインタが指し示す値にアクセスするには、ポインタ変数の前に * を付けて参照します。 下記の例では、ポインタ経由で参照先の値を書き換えています。 var i int = 100 var p *int = \u0026amp;i fmt.Println(i) //=\u0026gt; 100 fmt.Println(*p) //=\u0026gt; 100 *p = 200 // ポインタ経由で値を書き換える fmt.Println(i) //=\u0026gt; 200 fmt.Println(*p) //=\u0026gt; 200 このあたりのポインタの文法は、C/C++ 言語とほとんど同じです。 ただし、Go 言語ではポインタ演算（アドレスの足し算など）を行うことはできません。 そういったアクセスを禁止することで、不正なメモリアドレスへアクセスしてしまう危険性を排除しています。 関数内から呼び出し元の変数の値を書き換える Go 言語の関数のパラメーターは、通常は値渡し（値のコピーが渡される）となるため、下記のような関数を実行しても呼び出し側の数値を変更することはできません。 func add100(n int) { n += 100 // 呼び出し側の値は変更されない } 関数のパラメーターをポインタ型にすると、呼び出し元の変数が格納されているメモリアドレスを受け取ることができます。 そのメモリアドレスに格納されている値を、関数内から直接書き換えることができるようになるため、結果的に呼び出し側でパラメーターとして渡した変数の値を書き換えることができます。 下記のコードでは、int のポインタを受け取り、呼び出し側の int 変数の値を変更しています。 func add100(n *int) { *n += 100 // 呼び出し側の値を変更できる } func main() { n := 50 add100(\u0026amp;n) println(n) //=\u0026gt; 150 }`},{url:"/p/as29hpw/",title:"Go 言語の組込み型一覧",date:"2017-09-01T00:00:00Z",body:"Go 言語の組込み型一覧 Go 言語には次のような組込み型が定義されています。 真偽値 bool \u0026hellip; true or false 文字列 string \u0026hellip; 文字列。文字列リテラルは、\u0026quot;あいうえお\u0026quot; のようにダブルクォートで囲んで表現する。文字列は immutable（不変）であり、文字列の内容を部分的に書き換えることはできない（1 文字でも違う場合は、必ず別の文字列を作成する必要がある）。空文字列 (\u0026quot;\u0026quot;) は格納できるが、nil は格納できない。 数値 整数 int \u0026hellip; システム依存サイズの符号あり整数（ただし、少なくとも 32 ビット以上） int8 \u0026hellip; 8 ビット符号あり整数 int16 \u0026hellip; 16 ビット符号あり整数 int32 \u0026hellip; 32 ビット符号あり整数 int64 \u0026hellip; 64 ビット符号あり整数 uint \u0026hellip; システム依存サイズの符号なし整数（ただし、少なくとも 32 ビット以上） uint8 \u0026hellip; 8 ビット符号なし整数 uint16 \u0026hellip; 16 ビット符号なし整数 uint32 \u0026hellip; 32 ビット符号なし整数 uint64 \u0026hellip; 64 ビット符号なし整数 byte \u0026hellip; uint8 のエイリアス 浮動小数点数 float32 \u0026hellip; 32 ビット浮動小数点数 float64 \u0026hellip; 64 ビット浮動小数点数 複素数 complex64 \u0026hellip; 64 ビット複素数 complex128 \u0026hellip; 128 ビット複素数 ポインタ uintptr \u0026hellip; ポインタ値（アドレス）を格納する、システム依存サイズの符号なし整数 文字 rune \u0026hellip; １文字を表す（Unicode のコードポイント）。int32 のエイリアス。文字リテラルは、'あ' のようにシングルクォートで囲んで表現する。 エラー用インタフェース error"},{url:"/p/5dhkoru/",title:"変数を定義する (var)／ゼロ値について",date:"2017-09-01T00:00:00Z",body:`変数を定義する (var)／ゼロ値について Go 言語では明示的に型を指定した変数定義と、コンパイラによる型推論を利用した変数定義を行うことができます。 変数定義の基本 Go 言語では、var キーワードを使用して、var 変数名 型名 というフォーマットで変数定義します。 Pascal や Ada のように、型名を後ろに指定することに注意してください。 var x int 同じ型の変数を複数定義するときは、下記のように型名を一度だけ記述するだけで済みます（逆に、var x int, y int, z int のように冗長に記述することはできません）。 var x, y, z int 括弧を使用して複数行に分けて変数定義することもできます。 var ( name string age int ) 変数の初期値を指定する = キーワードを使用して、変数の初期値を指定することができます。 var x int = 100 var a, b int = 100, 200 var ( name string = \u0026#34;Rei Ayanami\u0026#34; age int = 14 ) Go には型推論の仕組みが備わっているため、変数の初期値を指定する場合は、型の記述を省略することができます。 var x = 100 var a, b = 100, 200 var ( name = \u0026#34;Rei Ayanami\u0026#34; age = 14 ) 関数の中で変数を定義するときは、:= を使用することで var と型の記述を両方とも省略することができます。 func hello() { s := \u0026#34;yatta-ne\u0026#34; x, y := 100, 200 // ... } ちなみに、変数の型は fmt.Printf 関数のフォーマット文字列で %T を指定して確認することができます。 func main() { x := 100 fmt.Printf(\u0026#34;%T\\n\u0026#34;, x) //=\u0026gt; int } 変数のグルーピング var ( ... ) というシンタックスは、変数のグルーピングのために利用することもできます。 下記は、本家の Effective Go (Commentary) からの抜粋ですが、エラー情報を表す変数を var ( ... ) でグループ化して定義し、グループに対してコメントを付加しています。 // Error codes returned by failures to parse an expression. var ( ErrInternal = errors.New(\u0026#34;regexp: internal error\u0026#34;) ErrUnmatchedLpar = errors.New(\u0026#34;regexp: unmatched \u0026#39;(\u0026#39;\u0026#34;) ErrUnmatchedRpar = errors.New(\u0026#34;regexp: unmatched \u0026#39;)\u0026#39;\u0026#34;) ... ) ゼロ値 変数の定義時に初期値を指定しなかった場合、それぞれの型の ゼロ値 (Zero Value) が初期値として設定されます。 型 ゼロ値 整数 0 浮動小数点数 0.0 文字列 (string) \u0026quot;\u0026quot;（空文字列） 真偽値 (bool) false 構造体 (struct) 各フィールドがゼロ値の構造体 配列 各要素がゼロ値の配列 その他（ポインタ、スライス、マップ、関数、インタフェース、チャネル） nil 例えば、var i int とだけ記述した場合、i の初期値は 0 になります。 var i int fmt.Println(i); //=\u0026gt; 0 ポインタの初期値は nil です。 var p *int fmt.Println(p); //=\u0026gt; nil`},{url:"/p/6dhkoru/",title:"構造体のコンストラクタ（ファクトリ関数）を定義する",date:"2017-09-01T00:00:00Z",body:"構造体のコンストラクタ（ファクトリ関数）を定義する Go 言語には構造体のコンストラクタ用の文法は用意されていません。 通常の関数の形で構造体のファクトリ関数を実装します。 ただ、簡単なプログラムであれば、下記のような初期化リストを使ったオブジェクト生成で間に合ってしまいます。 b := Book{Title: \u0026#34;Title\u0026#34;, Price: 2500} 任意のパラメータからオブジェクトを生成できるようにしたい場合は、New で始まる名前のファクトリ関数を作成し、構造体のポインタを返す のが慣例となっています。 book/book.go package book type Book struct { Title string Author string Price int } func NewAuthorlessBook(title string) *Book { return \u0026amp;Book{ Title: title, Author: \u0026#34;Unknown Author\u0026#34;, Price: 100, } } 上記では、book パッケージの中で Book 構造体とそのファクトリ関数を定義してみました。 外部の main パッケージから使用する場合は、下記のような感じのコードになります。 main.go package main import \u0026#34;fmt\u0026#34; import \u0026#34;local.packages/book\u0026#34; func main() { b := book.NewAuthorlessBook(\u0026#34;The World\u0026#34;) fmt.Printf(\u0026#34;%+v\\n\u0026#34;, b) } 実行結果 $ go run main.go \u0026amp;{Title:The World Author:Unknown Author Price:100}"},{url:"/p/cjosvz3/",title:"配列とスライスを扱う",date:"2017-09-01T00:00:00Z",body:`配列とスライスを扱う Go 言語の配列は固定長ですが、スライスを組み合わせて使用することで、可変長配列のように扱うことができます。 配列定義の基本 ([n], [\u0026hellip;]) Go で配列を定義するときは、変数の型名の前に [サイズ] プレフィックスを付けて定義します。 例えば、サイズ 3 の int 配列を定義するには次のようにします。 var arr [3]int variable arr is array 3 of int. と自然な英文として読めるような文法になっています。 配列の各要素には、Java や C/C++ のように 0 から始まるインデックスを指定してアクセスすることができます。 var arr [3]int arr[0] = 100 arr[1] = 200 arr[2] = 300 fmt.Println(arr) //=\u0026gt; [100 200 300] // 下記はビルドエラー (invalid argument: array index 3 out of bounds [0:3]) // arr[3] = 400 次のようにすれば、配列定義と同時に 初期値 を設定することができます。 var arr = [3]int{100, 200, 300} // 関数内であれば次のように書ける arr := [3]int{100, 200, 300} 初期値と指定する要素の数と同じサイズの配列を定義するのであれば、配列サイズを下記のように ... と指定することができます。 var arr = [...]int{100, 200, 300} // 関数内であれば次のように書ける arr := [...]int{100, 200, 300} Go では、サイズの異なる配列は、型が異なるとみなします。 固定サイズの配列をパラメータにとる関数は、同じサイズの配列のみ受け取ることができます。 func myfunc(arr [3]int) { //... } func main() { arr1 := [3]int{100, 200, 300} arr2 := [4]int{100, 200, 300, 400} myfunc(arr1) myfunc(arr2) // Error: cannot use arr2 (type [4]int) as type [3]int } なお、上記のように固定サイズの配列を受け取る関数に配列を渡すと、値渡しで配列が渡されます（値がコピーされる）。 従って、関数内部で配列要素を書き換えても、呼び出し側の配列は変化しません。 呼び出し側の配列の内容を変更するには、後述のスライスを使用します。 配列の各要素を for ループで処理する (range) for ループで range キーワードを使用すると、配列要素のインデックスと値を 1 つずつ取り出しながら処理することができます。 arr := [...]int{100, 200, 300} for idx, val := range arr { fmt.Printf(\u0026#34;arr[%d] = %d\\n\u0026#34;, idx, val) } 実行結果 arr[0] = 100 arr[1] = 200 arr[2] = 300 ループ時にインデックスだけが必要な場合は、２番目のパラメータを省略して次のように記述します。 arr := [...]int{100, 200, 300} for idx := range arr { fmt.Printf(\u0026#34;arr[%d] = %d\\n\u0026#34;, idx, arr[idx]) } 値だけを取得したいときは、次のように１番目のパラメータに _ を指定して無視するようにします。 arr := [...]int{100, 200, 300} sum := 0 for _, val := range arr { sum += val } fmt.Println(sum) //=\u0026gt; 600 スライス スライスの基本 ([]) Go 言語の配列は固定長ですが、スライスという型を可変長配列のように扱うことができます。 Go 言語では、メモリ効率が重視されるとき以外は、配列よりもスライスの方がよく使用されるようです。 スライスを定義するには、下記のようにします（配列のサイズを指定しないような構文で定義します）。 配列と同様に、初期値とする要素を設定することもできます。 var s []int // 初期値なし var s = []int{100, 200, 300} // 初期値あり s := []int{100, 200, 300} // 初期値あり（関数内ならこう書ける） スライスの要素を追加するには、組込みの append 関数を使用します。 複数の要素をまとめて追加することもできます。 var s []int s = append(s, 100) s = append(s, 200) s = append(s, 300, 400) fmt.Println(s) //=\u0026gt; [100 200 300 400] スライスのサイズを拡張していく過程で、メモリ領域が再割り当てされて参照位置が変わる可能性があるので、append 関数による拡張結果は戻り値として受け取る必要があります。 スライスの要素数と容量 (len, cap) スライスは内部データとして、現在格納されている要素数 (len) と、メモリ上に確保された容量 (cap) の情報を持っています。 それぞれの値は、len(s)、cap(s) のような組込関数を使って取得することができます。 スライスの初期化時には要素数と容量は等しくなっており、append 関数などで要素の追加を行った際に容量オーバーすると、自動的に２倍の容量が新しいメモリ領域に割り当てられます（ただし、容量が 1024 が超えるあたりから、確保サイズの計算方法が変化するようです）。 下記のテストコードで、要素数 (len) と容量 (cap) の変化を確かめてみてください。 var s []int for i := 0; i \u0026lt; 10; i++ { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) s = append(s, i) } 実行結果 len=0 cap=0 [] len=1 cap=1 [0] len=2 cap=2 [0 1] len=3 cap=4 [0 1 2] len=4 cap=4 [0 1 2 3] len=5 cap=8 [0 1 2 3 4] len=6 cap=8 [0 1 2 3 4 5] len=7 cap=8 [0 1 2 3 4 5 6] len=8 cap=8 [0 1 2 3 4 5 6 7] len=9 cap=16 [0 1 2 3 4 5 6 7 8] 確かに、容量 (cap) は２倍、２倍と拡張されていることがわかります。 容量の拡張時には、内部で新しいメモリ領域へのデータコピーが発生するため、頻繁な容量拡張が発生すると効率が悪くなります。 あらかじめ追加するおおよその要素数が分かっている場合は、後述の make 関数を使うことで、容量を指定したスライス生成を行えます。 make によるスライスの初期化 Go 言語の組込み関数の make を使用してスライスを作成すると、初期要素数 (len) と、初期容量 (cap) を指定してスライスを作成できます。 make 関数の第 1 引数には生成するスライスの型（[]int など）、第 2 引数には初期要素数 (len)、第 3 引数は初期容量 (cap) を指定します。 第 3 引数の初期容量 (cap) は省略可能で、省略すると初期要素数 (len) と同じサイズになります。 各要素はゼロ値で初期化 されます。 len=cap=5 のスライスを作成 s := make([]int, 5) fmt.Printf(\u0026#34;len=%d cap=%d %v\u0026#34;, len(s), cap(s), s) //=\u0026gt; len=5 cap=5 [0 0 0 0 0] 次の例では、初期要素数 (len) と異なる初期容量 (cap) を指定してスライスを作成しています。 初期容量 (cap) は、初期要素数 (len) 以上の値を指定する必要があります。 len=0、cap=100 のスライスを作成 s := make([]int, 0, 100) fmt.Printf(\u0026#34;len=%d cap=%d %v\u0026#34;, len(s), cap(s), s) //=\u0026gt; len=0 cap=100 [] あらかじめ追加する要素数が分かっている場合は、このように初期容量を指定してスライスを生成した方が、パフォーマンスの面で有利です。 実際にどの程度の速度差が出るかは、ベンチマーク機能 を使って調べることができます。 スライスは参照 スライス変数は、配列とは異なり、内部的なメモリ領域へのアドレス値を格納しています（Java の参照のように扱えます）。 つまり、スライス変数の代入は、同じメモリ領域を参照するように指示していることになります。 下記の例で、スライス s1 と s2 が保持する要素は、同じメモリ領域を共有しているため、どちらか一方で要素を変更すると、もう一方のスライスの要素も変更されます。 s1 := []string{\u0026#34;AAA\u0026#34;, \u0026#34;BBB\u0026#34;, \u0026#34;CCC\u0026#34;} s2 := s1 // s1 と s2 は同じ要素群を参照する s1[0] = \u0026#34;XXX\u0026#34; // s1 の変更は s2 にも影響する fmt.Printf(\u0026#34;s1=%v, s2=%v\\n\u0026#34;, s1, s2) //=\u0026gt; s1=[XXX BBB CCC], s2=[XXX BBB CCC] この性質を利用して、関数のパラメータとしてスライスを受け取り、呼び出し側のスライスの要素を書き換えることができます。 スライスの内容を変更する関数 func double(values []int) { for i := 0; i \u0026lt; len(values); i++ { values[i] *= 2 } } func main() { s := []int{100, 200, 300} double(s) fmt.Println(s) //=\u0026gt; [200 400 600] } ちなみに、上記の double 関数の中の for ループを、次のように range を使用するように変更すると、スライスの要素の値は変更されないことに注意してください。 間違った実装 func double(values []int) { for _, v := range values { v *= 2 // ローカル変数の v の値を書き換えているだけ } } 配列、スライスの要素を切り出す 任意の配列やスライス（あるいは string）を、arr[m:n]（m と n は数値）という形で参照すると、元の配列の「m ～ n-1」の領域の要素を参照可能なスライスを取得することができます。 開始インデックスを省略した場合は先頭要素からの切り出し (s[:2] == s[0:2])、終了インデックスを省略した場合は末尾要素までの切り出し (s[2:] == s[2:len(s)]) として扱われます。 s := []int{0, 1, 2, 3, 4, 5} s1 := s[1:4] //=\u0026gt; [1, 2, 3] s2 := s[4:] //=\u0026gt; [4, 5] s3 := s[:2] //=\u0026gt; [0, 1] s4 := s[:] //=\u0026gt; [0, 1, 2, 3, 4, 5] 切り出し後のスライスは、元の配列やスライスのメモリ領域を共有する ことに注意してください。 切り出し後のスライス経由で要素の値を変更すると、元のスライスにも影響を与えます。 下記のように、それぞれのスライスのアドレスを表示してみると、同じメモリ領域を共有していることが分かります（s1 と s2 は先頭要素の位置がずれている分だけアドレスもずれています）。 s := []int{0, 1, 2, 3, 4, 5} s1 := s[1:4] //=\u0026gt; [1, 2, 3] s2 := s[4:] //=\u0026gt; [4, 5] s3 := s[:2] //=\u0026gt; [0, 1] s4 := s[:] //=\u0026gt; [0, 1, 2, 3, 4, 5] fmt.Printf(\u0026#34;%p\\n\u0026#34;, s) // 0xc0000a8060 fmt.Printf(\u0026#34;%p\\n\u0026#34;, s1) // 0xc0000a8068 fmt.Printf(\u0026#34;%p\\n\u0026#34;, s2) // 0xc0000a8080 fmt.Printf(\u0026#34;%p\\n\u0026#34;, s3) // 0xc0000a8060 fmt.Printf(\u0026#34;%p\\n\u0026#34;, s4) // 0xc0000a8060 確実に別のメモリ領域を扱うスライスを作成したい場合は、組み込み関数 copy を使用してスライスをコピーします。 スライスをコピーする (copy) Go の組み込み関数 copy を使用すると、あるスライスの内容を、別スライスの領域へコピーすることができます。 関数の定義は下記のようになっており、 copy(dst, src []T) int コピー元スライス src から、コピー先スライス dst に実際にコピーされた要素数が返されます。 ただし、コピー元スライスの要素数 (len(src))、あるいは、コピー先のスライスの要素数 (len(src)) のうち小さい方の数だけしかコピーされません。 つまり、同じ要素を持つスライスを作成するには、あらかじめコピー元スライスと同じ要素数のスライスを make 関数で確保しておく必要があります。 下記のサンプルでは、src スライスをコピーして、同じ要素を持つ dst スライスを作成しています。 スライス src の要素を dst へコピー src := []int{100, 200, 300} dst := make([]int, len(src)) // コピー先スライスの要素数を確保 (len=3) n := copy(dst, src) fmt.Printf(\u0026#34;%d elements have been copied\\n\u0026#34;, n) fmt.Printf(\u0026#34;src=%v, dst=%v\\n\u0026#34;, src, dst) 実行結果 3 elements have been copied src=[100 200 300], dst=[100 200 300] コピーされる要素数を決定するための判断基準は、あくまでスライスの要素数 (len) であって、容量 (cap) ではないことに注意してください。 なので、次のように容量だけを確保してもコピーは実行されません。 dst := make([]int, 0, 3) // len=0, cap=3 s[m:n] 形式での要素の切り出しを組み合わせて使用すれば、スライスの部分的なコピーが可能になります。 src のインデックス 1～(3-1) の要素を dst のインデックス 2 以降にコピー src := []int{100, 200, 300, 400, 500} dst := []int{1, 2, 3, 4, 5} n := copy(dst[2:], src[1:3]) fmt.Printf(\u0026#34;%d elements have been copied\\n\u0026#34;, n) fmt.Printf(\u0026#34;src=%v, dst=%v\\n\u0026#34;, src, dst) 実行結果 2 elements have been copied src=[100 200 300 400 500], dst=[1 2 200 300 5] さらに、copy 関数の仕様として、コピー元とコピー先の領域がオーバーラップすることが許されているので、次のように、自分自身のスライスの領域間でコピーすることもできます。 src := []int{1, 2, 3, 4, 5, 6, 7, 8} copy(src[4:], src[2:]) fmt.Println(src) //=\u0026gt; [1, 2, 3, 4, 3, 4, 5, 6] スライス同士を結合する (append) Go の組み込み関数 append を使用すると、スライスに対して要素を追加することができますが、別のスライスの要素をすべて結合してしまうこともできます。 結合された結果のスライスは、戻り値として受け取る必要があることに注意してください。 s1 := []int{100, 200, 300} s2 := []int{400, 500, 600} s3 := append(s1, s2...) //=\u0026gt; [100, 200, 300, 400, 500, 600] 上記の例では、結合結果を新しいスライス s3 に割り当てていますが、もちろん既存のスライス s1 に上書き代入してしまうこともできます。 s1 := []int{100, 200, 300} s2 := []int{400, 500, 600} s1 = append(s1, s2...) //=\u0026gt; [100, 200, 300, 400, 500, 600] このケースでは、append 後に新しいメモリ領域が確保されるため、代入後の s1 のアドレスは、元の s1 のアドレスから変化していることに注意してください。`},{url:"/p/kswy47a/",title:"Golang で関数を定義する (func)",date:"2017-09-01T00:00:00Z",body:"Golang で関数を定義する (func) Go 言語の関数定義はシンプルでありながら、複数の値を返すことができるなど、十分な機能を備えています。 関数定義の基本 Go 言語で関数を定義するときは、func キーワードを使用します。 func 関数名(パラメータ) 戻り値の型 { // ... } パラメータや、戻り値を持たない場合は、それぞれ省略することができます。 次の例は、メッセージを出力するだけの単純な関数の実装例です。 パラメータも戻り値もない関数 func hello() { fmt.Println(\u0026#34;Hello\u0026#34;) } 次の関数は、２つの int 型パラメータを受け取り、足し合わせた結果を返します。 func add(a, b int) int { return a + b } 複数の戻り値を持つ関数を定義する（多値関数） Go 言語の関数は、複数の戻り値を返すことができます。 その場合、戻り値の型をカンマで区切って並べ、括弧で囲みます。 func swap(a, b int) (int, int) { return b, a } func main() { x, y := swap(10, 20) fmt.Println(x, y) //=\u0026gt; 20, 10 } 複数の戻り値をひとつの変数で受け取ろうとすると、コンパイルエラーになります。 x := swap(10, 20) // Error: multiple-value swap() in single-value context 必要のない戻り値がある場合は、アンダースコア (_) を使って受け取ります。 x, _ := swap(10, 20) // 1 つ目の戻り値のみ欲しい場合 _, y := swap(10, 20) // 2 つ目の戻り値のみ欲しい場合 ちなみに、Go 言語で変数値をスワップするときは次のように簡単に書けます。 x, y = y, x 名前付き戻り値 関数の戻り値に名前をつけておくと、その名前の変数に代入した値を戻り値として返すことができます。 次の例では、２つの int 型の戻り値に、それぞれ index と value という名前を付けています。 func findMax(arr []int) (index int, value int) { ... } 関数から return するときに、その時点で変数 index と変数 value に格納されている値が戻り値として扱われます。 それぞれの変数の初期値は、その型のゼロ値になります（例えば int であれば 0）。 package main import \u0026#34;fmt\u0026#34; // 配列の中から最大値を持つ要素を検索し、そのインデックスと値を返します。 func findMax(arr []int) (index int, value int) { // index = 0 // index のゼロ値は 0 なので上記の初期化処理は省略できる value = arr[0] for i := 1; i \u0026lt; len(arr); i++ { if value \u0026lt; arr[i] { value = arr[i] index = i } } return // return index, value と同じ } func main() { arr := []int{3, 6, 100, 7, 8} i, v := findMax(arr) fmt.Println(i, v) //=\u0026gt; 2, 100 } 上記のように、関数が同じ型の戻り値を複数返すようなケースでは、戻り値に名前を付けておくと、戻り値の順序を間違えて return してしまうようなミスを防ぐことができます。 エラーを返す関数を定義する Go 言語には例外の仕組みがないため（ランタイムエラーを扱う panic は存在します）、関数内でエラーが発生した場合は、戻り値としてエラーを返すことでそれを表現します（成功時は nil を返します）。 f, err := os.Open(\u0026#34;/tmp/sample.txt\u0026#34;) if err != nil { log.Fatal(err) } // 正常シーケンス defer f.Close() // ... 自作の関数の中でエラーを返したいときは、戻り値の型を error と定義し、エラーを errors.New 関数で作成します。 下記の例では、フィボナッチ数列の n 番目の値を返す fibonacci 関数を定義しています。 パラメータに 1 より小さい値を指定された場合は、2 番目の戻り値でエラーを返すようにしています。 package main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func fibonacci(n int) (int, error) { if n \u0026lt; 1 { return 0, errors.New(\u0026#34;fibonacci() must take a natural number\u0026#34;) } x, y := 1, 1 for ; n \u0026gt; 1; n-- { x, y = y, x+y } return x, nil } func main() { n, err := fibonacci(7) if err != nil { log.Fatal(err) } fmt.Println(n) } エラーメッセージを作成するときに、フォーマット文字列を指定したい場合は、errors.New 関数の代わりに fmt.Errorf 関数を使用できます。 func fibonacci(n int) (int, error) { if n \u0026lt; 1 { return 0, fmt.Errorf(\u0026#34;fibonacci() cannot take a number %d\u0026#34;, n) } //... } 可変長引数 関数のパラメータの定義で、型名の前に ... というプレフィックス を指定することで、可変長引数を表現することができます。 渡された引数は、関数内部ではスライスとして参照することができます。 func sum(values ...int) (result int) { for _, v := range values { result += v } return } func main() { x := sum(1, 2, 3, 4, 5) println(x) //=\u0026gt; 15 } 可変長引数を受け取る関数に対してスライスを渡したいときは、次のように スライスの後ろに ... を付けて展開して渡します。 s := []int{1, 2, 3, 4, 5} x := sum(s...) （固定長の）配列を渡すときは、下記のように一度スライスに変換してから同じように渡すことができますが、これはもう少しよいやり方があるかも。。。 arr := [...]int{1, 2, 3, 4, 5} x := sum(arr[:]...)"},{url:"/p/xs3ahpw/",title:"（旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する",date:"2017-08-31T00:00:00Z",body:"（旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する 主要なプログラミング言語には、インターネット上のセントラルリポジトリでパッケージを配布する仕組みが提供されていることが多いのですが（Ruby の RubyGems など）、Go 言語では、Git リポジトリ上（主に GitHub）に公開されたソースコードを直接取得 (go get) してインポートする方法を採用しています。 GitHub 上のパッケージをインポートする go get コマンドで、GitHub リポジトリのパスを下記のように指定すると、GitHub 上で公開されている Go パッケージ（ここでは github.com/maku77/gosample）のコードを、$GOPATH/src ディレクトリに取得することができます（$GOPATH についてはこちらを参照）。 github.com/maku77/gosample パッケージを取得する $ go get github.com/maku77/gosample 取得したパッケージは、標準パッケージと同じようにインポートして使用することができます。 sample.go package main import \u0026#34;github.com/maku77/gosample\u0026#34; func main() { gosample.Hello(\u0026#34;Maku\u0026#34;) } ビルド＆実行 $ go run sample.run Hello, Maku! go get コマンドの面白いところは、GitHub 上で公開されているリポジトリ名そのものではなく、そのサブディレクトリで公開されている Go パッケージ名を指定してコードを取得できるところです（git clone コマンドではこのようなことはできませんね）。 例えば、代表的な Pretty Print 系のパッケージである github.com/davecgh/go-spew/spew パッケージは、GitHub 上でのリポジトリ名は https://github.com/davecgh/go-spew.git ですが、そのサブディレクトリとして公開されているパッケージ名を指定して取得することができます。 $ go get github.com/davecgh/go-spew/spew 実際には、go-spew.git リポジトリ以下のファイルがすべて取得されますが、その配下のパッケージを使用するユーザが特に意識する必要はありません。 下記は spew パッケージの使用例です。 sample.go package main import ( \u0026#34;github.com/davecgh/go-spew/spew\u0026#34; ) type Book struct { Title string Author string } func main() { a := Book{ Title: \u0026#34;Golang ABC\u0026#34;, Author: \u0026#34;Maku\u0026#34;, } spew.Dump(a) } ビルド＆実行 $ go run sample.go (main.Book) { Title: (string) (len=10) \u0026#34;Golang ABC\u0026#34;, Author: (string) (len=4) \u0026#34;Maku\u0026#34; } GitHub にパッケージを公開する 自作のパッケージを GitHub に公開したいときは、単純に、Go で作成したソースコードを自分のアカウントで作成した GitHub リポジトリにコミットするだけで OK です。 まずは、リポジトリ名を決めて GitHub 上で新規リポジトリを作成しましょう。 ここでは、https://github.com/maku77/gosample というリポジトリを作成し、その中のコードを作成していくことにします。 GitHub 上で新規リポジトリを作成したら、ローカルでの作業用に git clone で取得します。 取得先は、$GOPATH/src/github.com/＜ユーザ名＞/＜リポジトリ名＞/ というディレクトリにします（go get コマンドの取得先に合わせる）。 $ git clone https://github.com/maku77/gosample.git $GOPATH/src/github.com/maku77/gosample 次に、簡単な Hello 関数を実装してみます。 $GOPATH/src/github.com/maku77/gosample/gosample.go package gosample import \u0026#34;fmt\u0026#34; func Hello(name string) { fmt.Printf(\u0026#34;Hello, %s!\\n\u0026#34;, name) } ビルドできるか確認します。 $ go build github.com/maku77/gosample 何もエラーがでなければ成功です。 GitHub にコミットする前に、ちゃんと動作するかテストプログラムを実行して確かめておきましょう。 sample.go package main import \u0026#34;github.com/maku77/gosample\u0026#34; func main() { gosample.Hello(\u0026#34;Maku\u0026#34;) } ビルド＆実行 $ go run sample.go Hello, Maku! 正しく動作していることが確認できたら、コミットして GitHub へ公開します。 $ git add gosample.go $ git commit -m \u0026#34;Add Hello function\u0026#34; $ git push これで、他のユーザは go get github.com/maku77/gosample と実行するだけで、GitHub からパッケージ取得できるようになります。"},{url:"/p/u48bfim/",title:"（旧）GOPATH によるコードの一元管理",date:"2017-08-31T00:00:00Z",body:"（旧）GOPATH によるコードの一元管理 Go 言語を用いた開発では、他のプログラミング言語とは異なり、1 つのワークスペース内ですべてのコードを管理するという慣習があります。 （追記）Go 1.11 以降は Go modules の仕組みで、任意のディレクトリでプロジェクト（モジュール）を作成できるようになりました。 ワークスペースの構成 Go のワークスペースは下記のように、bin、pkg、src という３つのディレクトリで構成することが決められています。 このルールに従ってファイルを配置することで、Makefile のようなビルド設定ファイルを用意しなくても、ビルドコマンド (go build) は構造化されたディレクトリ構成のプロジェクトを認識できるようになっています。 ~/gowork/ +-- bin/ # 作成したバイナリファイル（go install したときの保存先） +-- pkg/ # 依存パッケージのオブジェクトファイル（.a ファイルなど） +-- src/ # ソースコード（実行対象のファイルやインポートするファイルを配置） Go による開発では、ひとつのシステム内（PC 内）に、ひとつのワークスペースだけを用意して、その中ですべての作業を完結させる方法が主流となっています。 自分で作成しているパッケージも、go get コマンドでインターネット上から取得したパッケージも、PC で唯一のワークスペース内の src/ ディレクトリの中に格納します。 Go のプログラム内から外部パッケージをインポートするときは、まず pkg/ ディレクトリ内のバイナリ版が検索され、次に src/ ディレクトリが参照されるようになっています。 他の言語と比べると、特殊な管理方法（ほとんどルールベースで動作する）なので最初は戸惑うかもしれませんが、一度分かってしまえばそれほど複雑な仕組みではありません（こういった１ワークスペースでの開発が、Google 社内の開発ルールに適していたのかもしれませんね）。 GOPATH によるワークスペースの指定 Go 言語用のワークスペースとして扱うディレクトリ（上記の例では gowork ディレクトリ）は、GOPATH 環境変数であらかじめ指定しておく必要があります。 Go 1.8 以上では、GOPATH を明示的に指定しなかった場合のデフォルトパスは $HOME/go となります（Windows の場合は %USERPROFILE%\\go です）。 $ export GOPATH=$HOME/gowork Go が認識している GOPATH の値は、go env GOPATH コマンドで確認することができます。 $ go env GOPATH /Users/maku/gowork go build や go install などのコマンドは、$GOPATH/src 以下のコードに対して実行されるため、どのディレクトリからでも実行することができます。 例えば、任意のディレクトリから、 $ go install foo/bar/hello と実行すると、$GOPATH/src/foo/bar/hello ディレクトリ以下の .go ファイル群がビルドされて、その中で package main と記述された .go ファイルが実行ファイルの形になって $GOPATH/bin にインストールされます。 $GOPATH/src/foo/bar/hello/hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello\u0026#34;) } ビルドしてできた実行ファイルは $GOPATH/bin にインストールされるので、そこに PATH を通しておくと便利かもしれません。 $ export PATH=$PATH:$GOPATH/bin $ hello Hello ちなみに、go build foo/bar/hello や go install foo/bar/hello のようにパッケージ名を指定してビルドした場合、パッケージ名をもとに実行ファイルが生成される（この場合は hello というディレクトリ名）ので、ソースコードのファイル名は何でも構いません（ここでは hello.go としたけど、main.go というファイル名にしてもよい）。 ただし、下記のように .go ファイル名を直接指定してビルドする場合は、ファイル名に基いてカレントディレクトリに実行ファイルが生成されます。 $ go build hoge/moge/sample.go $ ls hoge/ sample*"},{url:"/p/dkpsvz3/",title:"Go ツアーを起動して Go 言語の基本を勉強する",date:"2017-08-31T00:00:00Z",body:"Go ツアーを起動して Go 言語の基本を勉強する Go ツアーの Web サイトで学ぶ Go には、Go ツアーという Go 言語勉強用のツールが用意されています。まずはこれで Go の基本を一通り学んでみるのがよいです。 下記の Web サイトでは、ブラウザ上で Go 言語のコードを記述、実行しながら Go 言語の基本を学んでいくことができます。 A Tour of Go (https://go.dev/tour/) ローカルで Go ツアーを起動する方法 A Tour of Go は、次のようにローカルの Web サーバーとして立ち上げることができます。 サーバーが立ち上がると、自動的に Web ブラウザが開きます。 $ go run golang.org/x/website/tour@latest 次のようにして、tour コマンドとしてインストールすることもできます。 $ go install golang.org/x/website/tour@latest デフォルトでは $HOME/go/bin 以下に tour コマンドがインストールされるので、次のように起動できます。 $ ~/go/bin/tour GOBIN 環境変数や GOPATH 環境変数を設定している場合は、go install によるコマンドのインストール先が変わるので注意してください。 参考: go install のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin)"},{url:"/p/pw258be/",title:"Golang の if による条件分岐",date:"2017-08-31T00:00:00Z",body:"Golang の if による条件分岐 Go 言語の if 文の構文は、Java や C++ とほぼ同じですが、括弧の使用ルールが微妙に異なります。 if 文の構文 Go 言語の if 文は、条件部を括弧で囲みません。 一方で、実行部分のブロックを囲む中括弧（{ と }）は省略することができません。 x, y := 100, 200 if x \u0026gt; y { fmt.Println(\u0026#34;x is larger than y\u0026#34;) } else if x \u0026lt; y { fmt.Println(\u0026#34;x is smaller than y\u0026#34;) } else { fmt.Println(\u0026#34;x is equal to y\u0026#34;) } 比較演算子としては、Java や C++ と同様の ==、!=、\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;= が使用できます。 文字列の比較も == 演算子で行えます。 論理演算子も同様に、||、\u0026amp;\u0026amp;、! を使用できます。 s := \u0026#34;hemu\u0026#34; x, y := 100, 200 if s == \u0026#34;hemu\u0026#34; \u0026amp;\u0026amp; x \u0026lt; y { // ... } ちなみに Go 言語には Java や C++ のような三項演算子 (a ? b : c) は用意されていません。 言語として三項演算子や if 式を採用してしまうと、複雑なコードが書かれやすいというのが理由っぽいです（適度に使えば便利なんですけどね^^;）。 参考: Why does Go not have the ?: operator? if スコープの変数 if 変数定義; 条件式 { // ... } という形で変数定義を行うと、その変数のスコープを if あるいは、else のブロック内に制限することができます。 例えば、下記のように記述すると、err 変数は if の条件式と処理ブロックの中でのみ参照できるようになります。 if err := recover(); err != nil { log.Fatal(err) } 次の例では、マップ変数 m にキー AAA が存在するときのみ、その値を参照しています。 m := map[string]int{ \u0026#34;AAA\u0026#34;: 100, \u0026#34;BBB\u0026#34;: 200, \u0026#34;CCC\u0026#34;: 300, } if val, ok := m[\u0026#34;AAA\u0026#34;]; ok { fmt.Println(val) }"},{url:"/p/x6adgjn/",title:"Golang の switch 条件分岐（switch の基本、便利な使い方、型スイッチ）",date:"2017-08-31T00:00:00Z",body:`Golang の switch 条件分岐（switch の基本、便利な使い方、型スイッチ） Go 言語の switch 文は、Java や C++ に比べて簡潔に記述できるようになっています。 switch 文の基本 Go 言語の switch 文では、case に複数の値をカンマで区切って指定することができます。 １つの case が実行されると自動的に switch 文を終了するため、C 言語のように case ごとに break と記述する必要はありません。 逆に、次の case を続けて実行したい場合は、明示的に fallthrough と記述する必要があります。 func checkNumber(i int) { switch i { case 0: fmt.Println(\u0026#34;zero\u0026#34;) case 2, 3, 5, 7: fmt.Println(\u0026#34;primary number\u0026#34;) fallthrough default: fmt.Println(\u0026#34;good number\u0026#34;) } } if 文の代わりに switch 文を使うことでコードを簡潔にできることがあります。 func shouldEscape(c byte) bool { switch c { case \u0026#39; \u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;%\u0026#39;: return true } return false } if 文と同様に、switch 文でも変数のスコープをブロック内に絞った変数定義を行うことができます。 次の os 変数は、switch 文の中でのみ参照できます。 switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;OS = OS X\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;OS = Linux\u0026#34;) default: // freebsd, openbsd, plan9, windows... fmt.Printf(\u0026#34;OS = %s\\n\u0026#34;, os) } 連続する if else の代わりとして switch 文を使用する switch 文の条件部分を省略 すると、switch true と記述するのと同様の振る舞いをします。 この記述方法は、連続した if else を簡潔に記述するために使用することができます。 典型的なのは、ある変数の値を大小比較したいケースです。 func unhex(c byte) byte { switch { case \u0026#39;0\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;: return c - \u0026#39;0\u0026#39; case \u0026#39;a\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;f\u0026#39;: return c - \u0026#39;a\u0026#39; + 10 case \u0026#39;A\u0026#39; \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;F\u0026#39;: return c - \u0026#39;A\u0026#39; + 10 } return 0 } もう 1 つ例を。 func greet() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning.\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } } 上記の変数 t のスコープを switch 文の内部に絞りたいのであれば、下記のように変数定義します（セミコロンの後ろの条件部分だけを省略します）。 switch t := time.Now(); { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning.\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } ちなみに上記の switch を if else を使って書き換えると次のようになります。 if t := time.Now(); t.Hour() \u0026lt; 12 { fmt.Println(\u0026#34;Good morning!\u0026#34;) } else if t.Hour() \u0026lt; 17 { fmt.Println(\u0026#34;Good afternoon.\u0026#34;) } else { fmt.Println(\u0026#34;Good evening.\u0026#34;) } まぁ、このくらいであればそれほど差はありませんが、それでも switch の方が可読性は高そうです。 型スイッチ (Type Switch) Go 言語の関数で任意の型の引数を受け取るには、空インタフェース型 interface{} を使用します。 オブジェクトの実際の型に基づいて分岐処理を行うには、次のように 型スイッチ (Type Switch) の仕組みを使います。 func checkType(value interface{}) { switch v := value.(type) { case nil: fmt.Println(\u0026#34;value is nil\u0026#34;) case int: fmt.Printf(\u0026#34;value is int (%d)\\n\u0026#34;, v) case float64: fmt.Printf(\u0026#34;value is float64 (%f)\\n\u0026#34;, v) case func(int) string: fmt.Println(\u0026#34;value is function that takes int and returns string\u0026#34;) case bool, string: fmt.Println(\u0026#34;value is bool or string\u0026#34;) default: fmt.Printf(\u0026#34;value has unknown type (%T)\\n\u0026#34;, v) } } 上記の例では、value 変数の実際の型によって分岐処理を行っています。 さらに、分岐後は v 変数をその型の値として参照することができます。 型スイッチは、型アサーション (Type Assertion) の特殊形態だと考えることができます。`},{url:"/p/t269cgj/",title:"パッケージの作成とインポート (import)",date:"2017-08-31T00:00:00Z",body:"パッケージの作成とインポート (import) Go 言語でパッケージを作る方法と、他のパッケージを参照する色々な方法を紹介します。 パッケージとモジュール パッケージ Go 言語のパッケージは、1 つのディレクトリ内にまとめられたソースコードの集まりです。 下記のディレクトリ構成では、mymodule というモジュール（後述）に、pkg1 と pkg2 という名前の 2 つのパッケージが含まれています。 - mymodule/ - pkg1/ - auth.go (package pkg1) - user.go (package pkg1) - pkg2/ - hoge.go (package pkg2) パッケージ内のファイルの分割粒度は自由で、あるコードがパッケージ内のどの Go ファイルに記述されているかで違いはありません。 パッケージのインポート時にはパッケージ名しか指定しないので、パッケージの利用者は、パッケージを構成する各々の Go ファイルの存在を意識する必要はありません。 パッケージの実装者は、パッケージ内のファイルを都合のいいように分割できます。 Go 言語のソースコードは、必ず 1 つのパッケージに所属している必要があり、ソースコードの先頭の package ディレクティブでパッケージ名（＝親ディレクトリ名）を指定します。 package pkg1 特に、プログラムのエントリポイントとなる main 関数は、main パッケージに存在している必要があり、典型的にはモジュールルートを main パッケージとして扱います。 package main function main() { // ... } モジュール Go 1.11 以降は モジュール という考え方が導入され、Go 1.10 以前の GOPATH によるコードの一元管理 からの移行が進みました。 簡単に言うと、プロジェクト単位でディレクトリを自由な場所に置けるようになりました（以前はすべてのプロジェクトを $GOPATH 以下に置かなければいけませんでした）。 モジュールは単一あるいは複数のパッケージを集めたもので、GitHub などで管理するときののリリース単位として用いられます。 モジュール ◇── パッケージ モジュールのルートディレクトリには go.mod、go.sum というファイルが置かれ、依存するパッケージのバージョンやハッシュ情報などが管理されます。 公開されるモジュール名は世界で一意になっている必要があり、一般的に GitHub のリポジトリで管理されるため、次のような名前が使われます。 github.com/\u0026lt;username\u0026gt;/\u0026lt;modulename\u0026gt; 例えば、github.com/maku77/golibs として公開されているモジュールの、pkg1 パッケージを利用したい場合、次のようにインポートできます。 import \u0026#34;github.com/maku77/golibs/pkg1\u0026#34; 上記のように、モジュール内の単一のパッケージをインポートする場合でも、モジュール全体がダウンロードされるため、初回のビルドには少し時間がかかります。 インポートの使い方 基本 Go 言語のプログラムの中から、他のパッケージをインポートするには import を使用します。 GitHub で公開されているパッケージを直接インポートすることもできます。 import \u0026#34;fmt\u0026#34; import \u0026#34;os\u0026#34; import \u0026#34;strings\u0026#34; import \u0026#34;github.com/ユーザー名/リポジトリ名/パッケージ名\u0026#34; 括弧を使って次の様にまとめることもできます。 import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/ユーザー名/リポジトリ名/パッケージ名\u0026#34; ) パッケージで定義されている関数を参照するときは、パッケージ名.関数名 という形で呼び出します。 大文字で始まる関数のみ参照できます。 次の例では、cmp パッケージの Diff 関数を呼び出しています。 package main import \u0026#34;fmt\u0026#34; import \u0026#34;github.com/google/go-cmp/cmp\u0026#34; func main() { fmt.Println(cmp.Diff(\u0026#34;Hello World\u0026#34;, \u0026#34;Hello Go\u0026#34;)) } オプション パッケージをインポートするときに、パッケージ名の前にオプションを指定することで、別名を付けたり、パッケージ名を省略してアクセスできるようになります。 package main import ( . \u0026#34;fmt\u0026#34; // パッケージ名を省略して関数名だけで呼び出せるようにする sample \u0026#34;github.com/maku77/gosample\u0026#34; // パッケージに別名を付けて参照 _ \u0026#34;math/rand\u0026#34; // 参照していなくてもコンパイルエラーにしない ) func main() { Println(\u0026#34;Good morning\u0026#34;) sample.Hello(\u0026#34;Maku\u0026#34;) } パッケージ名の前に . オプションを付けると、パッケージ名を省略してアクセスできるようになります。 上記の例では、fmt.Println の呼び出しを、Println と記述できるようにしています。 2 つ目の例では、gosample パッケージに sample という別名を付けてアクセスできるように指定しています。 Go 言語では、パッケージ名を階層構造で表現しない（潔い！）ので、パッケージ名のコンフリクトが発生しやすくなっています。 同じ名前のパッケージをインポートするときは、この別名の仕組みを利用して解決しましょう。 同一パッケージ内の関数を参照する 同じパッケージ内（つまり、同じディレクトリ内）の Go ファイルで定義されている関数は、互いに参照することができます。 下記は、プログラムのエントリポイントとなる main.go ファイルです。 main.go package main func main(){ hello(\u0026#34;Maku\u0026#34;) } hello 関数は、同じパッケージ（同じディレクトリ内）の別のファイルで定義しています。 greet.go package main import \u0026#34;fmt\u0026#34; func hello(name string) { fmt.Printf(\u0026#34;Hello, %s\\n\u0026#34;, name) } 実行するときは、これらを一緒にビルドする必要があります。 $ go run *.go Hello, Maku ビルドして、実行ファイル myapp を作るときも同様です。 $ go build -o myapp *.go $ ./myapp Hello, Maku go.mod ファイルを生成してモジュール対応モードにしておけば、go build は引数なしで実行できます。 $ go mod init myapp $ go build $ ./myapp Hello, Maku 別のパッケージの関数を参照する ある関数を別のパッケージから参照できるようにするには、関数名を大文字で始める必要があります（例: Hello）。 ここでは、次のようなディレクトリ構成の myapp モジュールを作って、main.go（main パッケージ）から mymath/mymath.go（mymath パッケージ）で定義した関数を参照したいとします。 myapp/ go.mod main.go （main パッケージ） mymath/ （mymath パッケージ） mymath.go まず、モジュールのルートディレクトリ (myapp) で、go mod init コマンドを実行して、go.mod ファイルを生成します。 GitHub で管理することを想定しているのであれば、モジュールパス名はリポジトリ名に合わせて github.com/\u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt; のようにします。 これにより、モジュールパス名が世界で一意になるとともに、別のモジュールから GitHub 経由でインポートできるようになります。 ローカルでテスト開発するだけのアプリであれば、とりあえずモジュールパス名は myapp のように適当に付けちゃって構いません。 $ cd ~/gitwork/myapp $ go mod init github.com/maku77/myapp # GitHub で管理するならリポジトリ名を指定 $ go mod init myapp # ローカルでのテスト用ならこれでも OK mymath パッケージでは、簡単な足し算を行う Add 関数を提供することにします。 パッケージ外部から参照できるようにするには、関数名を大文字で始める必要があります。 mymath/mymath.go package mymath func Add(a, b int) int { return a + b } この mymath.Add 関数を、main パッケージの main 関数から参照するには次のようにします。 main.go package main import \u0026#34;fmt\u0026#34; import \u0026#34;github.com/maku77/myapp/mymath\u0026#34; func main() { fmt.Println(mymath.Add(100, 200)) } main パッケージ（の main 関数）は次のように実行できます。 $ go run . 300 ビルドして実行ファイル myapp を生成することもできます。 $ go build $ ./myapp 300 Go 言語のパッケージは、\u0026quot;./mymath\u0026quot; のような 相対パスではインポートできない ことに注意してください。 必ず \u0026quot;github.com/maku77/myapp/mymath\u0026quot; のようにモジュール名を含むパッケージパス全体（絶対パス）を指定する必要があります（go mod init でモジュールパス名を myapp のように簡略化した場合は、\u0026ldquo;myapp/mymath\u0026rdquo; のようにインポートします）。 昔は同一モジュール内のパッケージであれば相対パスでインポートできたのですが、現在は外部モジュールのパッケージと同様に絶対パスによる指定に統一されています。"},{url:"/p/v58cfik/",title:"Golang のループ処理（for ループ）",date:"2017-08-31T00:00:00Z",body:"Golang のループ処理（for ループ） Go 言語では、for キーワード 1 つだけで while ループや無限ループを表現することができます。 C/C++ 言語風の for ループ for 初期化; 条件式; 後処理 { // ... } Go 言語の for ループは、C/C++ 言語に似た構文を使用しますが、for の直後は括弧で囲みません。 ただし、実行部分の括弧は必ず記述する必要があります。 このあたりのルールは、if 文と同じですね。 記述例 for i := 0; i \u0026lt; 3; i++ { fmt.Println(i) } 実行結果 0 1 2 ちなみに、i++ という部分を、++i という前置インクリメントに置き換えることはできません。 Go 言語では、i++ という後置インクリメントは文として扱われる（評価後の値を得られない）ため、式の中に埋め込むことができないようになっています。 そのため、前置インクリメントと後置インクリメントを区別する必要がそもそもなく、文法として後置インクリメントの形に統一するようになっています。 while ループ（としての for ループ） Go 言語には while ループ（条件に一致する限り繰り返し）は存在しませんが、for ループで代用できます。 i := 0 // i が 3 より小さい間、繰り返す for i \u0026lt; 3 { fmt.Println(i) i++ } for ループの初期化ステートメントや条件式、後処理ステートメントはそれぞれ省略することができるので、上記の for ループは、実は下記のような記述の省略形です（上記のように省略して記述すべきです）。 for ; i \u0026lt; 3; { // ... } 無限ループ（としての for ループ） Go 言語では、無限ループも for を使用して記述するよう統一されています。 i := 0 for { i += 1 if i \u0026gt; 5 { break } if i % 2 == 0 { continue } fmt.Println(i) } 実行結果 1 3 5 C/C++ 言語の無限ループの記載方法 (for (;;) { }) に慣れているのであれば、上記は下記のような記述の省略形だと考えれば良いでしょう（このように書くべきではありませんが）。 for ;; { // ... } ループの継続に continue、終了に break キーワードを使用するのも C/C++ 言語と同様です。"},{url:"/p/qqy9gok/",title:"定数を定義する (const, iota)",date:"2017-08-31T00:00:00Z",body:"定数を定義する (const, iota) Go 言語の定数は、変数を定義するのと同じ感覚で定義することができます。 定数定義の基本 (const) Go 言語の定数は、const キーワードを使用して定義します。 func main() { const foo = 100 fmt.Println(foo) } 次のように複数の定数をまとめて定義することもできます。 const ( hoge = 100 fuga = 200 ) 定数値をパッケージ外に公開する パッケージ外に公開する定数値は、名前を大文字で始めます（関数や変数と同様です）。 逆に、小文字で始まる定数値は、同じパッケージ内からのみ参照可能です。 mypkg/mypkg.go package mypkg const PublicConst = 100 // 別のパッケージから mypkg.PublicConst で参照可能 const privateConst = 200 // mypkg 内からのみ参照可能 main.go package main import \u0026#34;fmt\u0026#34; import \u0026#34;mypkg\u0026#34; func main() { fmt.Println(mypkg.PublicConst) //=\u0026gt; 100 } 標準パッケージの math パッケージも、円周率πを math.Pi という大文字で始まる定数名で公開しています。 package main import \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; func main() { fmt.Println(math.Pi) //=\u0026gt; 3.141592653589793 } 定数には型を指定しない Go 言語で定数を定義するときは、const Foo int = 100 のように型を明示することもできますが、通常は型を指定せずに const Foo = 100 とだけ記述します。 こうして untyped なままで定義しておくことで、実際にその定数値を使用するときに適切な型の値として扱ってくれるようになります。 例えば、定数 Foo を int 型と明示して定義すると、下記の 3 行目で型のミスマッチが発生してエラーになってしまいます。 const Foo int = 100 var a uint = 100 a += Foo // invalid operation: a += Foo (mismatched types uint and int) 定数の型を指定しないようにしておけば、その定数が使用されるときに適切な型の定数として扱ってくれるのでエラーが発生しません。 const Foo = 100 var a uint = 100 a += Foo // OK このように、定数を定義するときは型を指定しない方が便利に（かつ直感的に）使用できます。 必ず特定の型でしか使って欲しくない場合のみ、定数の型を明示するようにしましょう。 連番の定数を定義する (iota) 定数ジェネレータの iota を使用すると、連番からなる定数を簡単に定義することができます。 const ( FAST = iota //=\u0026gt; 0 NORMAL //=\u0026gt; 1 SLOW //=\u0026gt; 2 ) iota は呼び出されるごとに 0、1、2 という連番を返しますが、2 つ目以降の呼び出しは上記のように省略することができます。 つまり、上記のコードは下記のコードと同等です。 const ( FAST = iota //=\u0026gt; 0 NORMAL = iota //=\u0026gt; 1 SLOW = iota //=\u0026gt; 2 0 始まりではなく、1 始まりの連番が欲しい場合は、次のように最初の値を _ で無視します。 const ( _ = iota //=\u0026gt; 0 FAST //=\u0026gt; 1 NORMAL //=\u0026gt; 2 SLOW //=\u0026gt; 3 ) あるいは、次のように記述することもできます。 const ( FAST = iota + 1 //=\u0026gt; 1 NORMAL //=\u0026gt; 2 SLOW //=\u0026gt; 3 ) iota が返す値は、次の const キーワードが出現したときに 0 にリセットされます。 const ( a = iota //=\u0026gt; 0 b //=\u0026gt; 1 c //=\u0026gt; 2 ) const ( d = iota //=\u0026gt; 0 e //=\u0026gt; 1 f //=\u0026gt; 2 ) 次のようにシフトと組み合わせて使用することもできます。 const ( a = 1 \u0026lt;\u0026lt; iota //=\u0026gt; 1 b = 1 \u0026lt;\u0026lt; iota //=\u0026gt; 2 c = 1 \u0026lt;\u0026lt; iota //=\u0026gt; 4 d = 1 \u0026lt;\u0026lt; iota //=\u0026gt; 8 ) 上記のように計算を組み合わせた定義も、下記のように省略することができます（代入式が暗黙的に繰り返されます）。 const ( a = 1 \u0026lt;\u0026lt; iota //=\u0026gt; 1 b //=\u0026gt; 2 c //=\u0026gt; 4 d //=\u0026gt; 8 ) 参考記事 Constants - The Go Blog"},{url:"/p/nuz369c/",title:"Go 言語で Hello World をコンパイル、実行する",date:"2017-08-30T00:00:00Z",body:"Go 言語で Hello World をコンパイル、実行する ここでは、Go 言語を使用して簡単な Hello World プログラムを作成し、コンパイル＆実行してみます。 Go 言語で Hello World を実装する Go 言語のソースコードファイルの拡張子は、.go を使用します。 hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello Go\u0026#34;) } エントリポイントとなる Go プログラムは、main パッケージとして作成し、main 関数を含んでいる必要があります（main.main と表現します）。 ファイル名は何でも構いません。 Hello World を実行する Go 言語はコンパイル型の言語ですが、go run コマンドを使用すると、ソースコードファイルを指定してそのまま実行することができます。 $ go run hello.go Hello Go ビルドして実行ファイル（Windows なら hello.exe）を作成するには、go build コマンドを使用します。 $ go build hello.go $ ./hello Hello Go 作成された実行ファイルは、同じ環境（OS、アーキテクチャ）であれば、Go の処理系がインストールされていなくてもそのまま実行することができます。 別の OS 用にビルドする場合は、クロスコンパイルの機能を使用します。 Go のクロスコンパイルがサポートしている OS と CPU アーキテクチャは、こちらのドキュメント に記述されています。 （応用）モジュール対応モードでアプリを作成する いろいろな外部パッケージを活用して Go アプリを作る場合、モジュールとしてアプリを初期化します（module-aware mode と呼びます）。 モジュールを初期化するには、モジュールルートにしたいディレクトリの下で go mod init \u0026lt;モジュールパス名\u0026gt; を実行します。 Node.js アプリの開発経験があるなら、npm init のようなものだと考えると分かりやすいです。 Go モジュールの初期化 $ mkdir hello \u0026amp;\u0026amp; hello $ go mod init hello # GitHub で管理するなら github.com/maku77/hello など go: creating new go.mod: module hello 上記のように、モジュールのルートディレクトリ (hello) に go.mod ファイルが作成されれば成功です。 このファイルには、このモジュールの名前や、Go のバージョン、パッケージの依存情報 (dependency tracking) などが保存されます。 hello/go.mod module hello go 1.18 シンプルな構成のアプリでは、モジュールのルートディレクトリに、main パッケージとする .go ファイルを配置します。 ファイル名は何でもいいですが、main.go としておきます。 hello/main.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello Go\u0026#34;) } モジュールのディレクトリ構成は次のようになっています。 hello/ （モジュールルート） main.go （main 関数を含む main パッケージの実装） go.mod （go mod init で自動生成された） このアプリを実行するには、モジュールルートから次のように go run を実行します。 モジュール対応モードの場合、main パッケージのディレクトリ名 (.) を指定するだけでよいことに注意してください。 $ go run . Hello Go ビルドして実行ファイルを作りたい場合は、go build を実行します。 ここでは、パッケージ名の指定すら必要ありません。 出力される実行ファイルの名前はモジュール名に従って hello、あるいは hello.exe になります（-o オプションで変更できます）。 $ go build $ ./hello Hello Go これで、Go 言語での簡単な Hello World アプリの導入は完了ですが、ある程度の規模のアプリを開発する場合は、自分でパッケージ用のディレクトリを作ったり、外部パッケージをインポートして実装していくことになります。 Go 言語でのパッケージの概念に関しては、下記を参考にしてください。 パッケージの作成とインポート"},{url:"/p/wxhzfvc/",title:"Go 言語とは？／Go をインストールする",date:"2017-08-30T00:00:00Z",body:"Go 言語とは？／Go をインストールする Go 言語 (Golang) は、Google が 2009 年に発表したオープンソースのプログラミング言語です。 コンパクトな実行ファイルを生成できるため、サーバーレス環境やコンテナ化されたアプリケーションとの相性がよく、多くのプロジェクトでメイン言語として採用されることが増えてきています。 ここでは Go 言語の特徴と、インストール方法を紹介します。 Go 言語の特徴 Go 言語は下記のような特徴を持っています。 マスコットキャラクター（Gopher: ホリネズミ）が 気持ち悪い かわいい 開発者 Ken Thompson（ケン・トンプソン）（C 言語の開発者） Rob Pike（ロブ・パイク）（UTF-8 の開発者） Brad Fitzpatrick（ブラッド・フィッツパトリック）（memcached の開発者） コンパイル型の言語 コンパイルが非常に高速 コンパイルせずにソースコードを指定して実行することも可能（go run sample.go) クロスコンパイルをサポートしており、Windows、Linux、macOS 用の実行ファイルを容易に生成できる 今まで C/C++ で行っていたシステムレイヤのプログラミングをより効率的に行う目的で作成された（ミドルウェアなどの実装に最適） シンプルな言語仕様のため習得が用意で、大規模開発にも耐えられる 最小限の構文により、コーディングのミスを防ぎ、コンパイルを最適化している 例えば、ループ構文は for ループしかない、三項演算子もない 行末のセミコロンは必要ない マクロなどのプリプロセッサ構文はない（コンパイルの低速化の原因のため） 暗黙の型変換はない ポインタはあるが、危険なポインタ演算はない GC による自動メモリ解放（C 言語と Java のいいとこ取り） 継承、ジェネリックプログラミング、アサーション、オーバーロードなども存在しない 2022-03-15 の Go 1.18 リリース でジェネリクスがサポートされました 不要なインポートがあるとコンパイルエラーになる（警告ではなくエラー） try-catch による例外の仕組みがない（関数が多値を返すことでカバー）（panic と recover という仕組みがある） クラスはないが、構造体＋レシーバ付き関数でカバー 豊富な標準パッケージを同梱（暗号化、圧縮、RDB、JSON、テスト用のライブラリなど） 並行処理もネイティブにサポート（ゴルーチンという軽量スレッド、チャネルによるスレッド間通信） テスト実行 (go test) やドキュメント生成 (godoc) のコマンドを標準搭載 バージョン 1.5 以降は Go 言語自体が Go 言語で記述されている（一部アセンブラ） Go 言語は、静的サイトジェネレータ Hugo や、コンテナ型仮想環境ツール Docker のベースとなる言語としても使用されており、これらのツールの高速な動作は、Go 言語によって支えられています。 Go をインストールする Go は各環境用のインストールパッケージを使用して簡単にインストールできます。 下記から Windows、Linux、macOS 用のパッケージをダウンロードしてインストールを実行してください。 Getting Started - The Go Programming Language インストールが完了したら、下記のようにバージョン情報を表示することで動作確認できます。 $ go version go version go1.9 windows/amd64 Go のバージョン推移 go1.19 (released 2022-08-02) ドキュメンテーションコメントの記述が強化され、ドキュメント間のリンクなどが可能になった。 go1.18 (released 2022-03-15) ジェネリクス をサポート。 Fuzzing テストのサポート。 go get はパッケージのビルドもインストールもしなくなり、go.mod ファイルの依存情報を更新するだけになった（= -d フラグが常に有効）。そのため、モジュールの外（go.mod がない）ディレクトリで go get を実行するとエラーになるようになった。 GOPATH モード (GO111MODULE=off) にすれば、go get コマンドは以前のようにパッケージのビルドとインストールを行う。 go.mod ファイルと go.sum ファイルは、go get、go mod tidy、go mod download コマンドのみで更新される。 go1.17 (released 2021-08-16) go get によるコマンドのインストールが非推奨に。代わりに go install cmd@ver を使う。 Windows の 64-bit ARM アーキテクチャをサポート。 ビルド制御のための //go:build コメントをサポート（古い型式の // +build は gofmt で置換してくれる）。 go1.16 (released 2021-02-16) パッケージビルドは module-aware モードがデフォルトになった（go.mod ファイルが存在しなくても）。今後、すべてのプロジェクトは module-aware モードでのビルドが推奨とされた。 GO111MODULE による振る舞い（未指定時が on とみなされるようになった） 未指定 \u0026hellip; 常に module-aware モードで動作（下記 on と同様に動作） on \u0026hellip; 常に module-aware モードで動作 off \u0026hellip; 常に GOPATH モードで動作（go1.10 までと同じ） auto \u0026hellip; $GOPATH/src 以下で go.mod ファイルが存在しない場合のみ GOPATH モードで動作（go1.15 までのデフォルト動作） go1.15 (released 2020-08-11) GOMODCACHE でモジュールキャッシュ用のディレクトリを $GOPATH/pkg/mod から変更できるようになった。 go1.14 (released 2020-02-25) go1.13 (released 2019-09-03) go1.12 (released 2019-02-25) go mod init で go.mod ファイルにデフォルトで go directive （go のバージョン情報）が入るようになった。 Go tour がメインバイナリに含まれなくなったので、go tool tour は go get -u golang.org/x/tour と実行するようになった。 go1.11 (released 2018-08-24) module-aware（モジュール対応）モード の導入。go コマンドは、コンテキストに応じて GOPATH モードと module-aware モードのどちらかで動作するようになった。 GOPATH モード \u0026hellip; go1.10 までのモードで、コード管理を GOPATH で指定されたディレクトリ内で行う module-aware モード \u0026hellip; コード管理を任意のディレクトリ（モジュールディレクトリ）で行う GO111MODULE による振る舞い 未指定 \u0026hellip; 下記 auto と同様に動作 on \u0026hellip; 常に module-aware モードで動作 off \u0026hellip; 常に GOPATH モードで動作（go1.10 までと同じ） auto \u0026hellip; $GOPATH/src 以下で go.mod ファイルが存在しない場合のみ GOPATH モードで動作（go1.15 までのデフォルト動作） go1.10 (released 2018-02-16) go1.9 (released 2017/08/24) go1.8 (released 2017/02/16) go1.7 (released 2016/08/15) go1.6 (released 2016/02/17) \u0026ndash; 64 ビット MIPS 上の Linux、32 ビット x86 上の Android をサポート go1.5 (released 2015/08/19) \u0026ndash; iOS をサポート go1.4 (released 2014/12/10) \u0026ndash; Android をサポート go1.3 (released 2014/06/18) go1.2 (released 2013/12/01) go1.1 (released 2013/05/13) go1 (released 2012/03/28) \u0026ndash; Linux、Mac OSX に加え、Windows をサポート Release History - The Go Programming Language より"},{url:"/p/rz47adg/",title:"Go 言語のコーディングスタイル（コーディング規約）",date:"2017-08-30T00:00:00Z",body:"Go 言語のコーディングスタイル（コーディング規約） Go 言語には、標準のコーディング規約が用意されており、それに合わせた組み込みのコードフォーマッター (go fmt) も提供されています。 Go 言語のコーディング規約 Go 言語におけるコーディングスタイルは、下記のドキュメントが参考になるでしょう。 Effective Go - The Go Programming Language ポイントを簡単にまとめておきます。 インデントにはハードタブ（タブ文字）を使用 し、ソフトタブ（半角スペース）を使用しない。 １行あたりの文字数に制限はない。もちろん、長すぎる場合は改行してもよい。 連続した変数定義やコメントは縦に揃える type T struct { name string // name of the object value int // its value } 演算子の前後にスペースを入れない。演算子の優先順位を明確にするときのみスペースを入れる。その代わり余計な括弧を使わない。 x\u0026lt;\u0026lt;8 + y\u0026lt;\u0026lt;16 x, y = y, x+y 命名規則 公開メソッド、フィールド: MexedCaps（大文字で始める） 非公開メソッド、フィールド: mixedCaps（小文字で始める） コンストラクタ: NewBook（New + 生成対象の構造体名） １つのメソッドを持つインタフェース: Reader（Read メソッドだけを持つインタフェース） というように、いくつかのフォーマットルールがあるのですが、Go には下記のような自動整形ツールが付属しているので、これを実行して自動で整形してしまうのが手っ取り早いです。 コードを自動整形する (go fmt と gofmt) Go 言語には、コーディング規約に従ってコードを自動整形するためのツール (go fmt) が標準で搭載されています。 例: hello.go ファイルを直接フォーマットする $ go fmt hello.go 上記のように実行すると、hello.go ファイルの内容が整形されて書き換えられます。 指定したソースコードが直接変更される ことに注意してください。 次のように実行すれば、プロジェクト内のすべての .go ファイルをフォーマットできます。 $ go fmt ./... 元のソースコードを書き換えずに標準出力へ整形結果を出力したい場合は、go fmt の代わりに gofmt コマンドを使用します。 例: hello.go のフォーマット結果を標準出力へ出力する $ gofmt hello.go package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello Go\u0026#34;) } go fmt の振る舞いは、gofmt -l -w と同様のようです。"},{url:"/p/rqcwgyj/",title:"Hugo で日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage)",date:"2017-08-29T00:00:00Z",body:"Hugo で日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage) Hugo の記事一覧ページでは、記事の先頭部分を特定の単語数 (70 words) だけサマリー表示するようになっています。 ただし、このワードカウントはデフォルトでは英語などの単語数をベースに計算されているので、日本語などでは正しくカウントされずに、長大なサマリーが表示されてしまいます。 日本語の文字数を正しく数えて、短いサマリーを表示できるようにするには、設定ファイルで下記のように hasCJKLanguage を true に設定します。 config.toml の場合 hasCJKLanguage = true config.yaml の場合 hasCJKLanguage: true これで、Hugo 内部の .Summary や .WordCount が日本語で正しく動作するようになり、短いサマリー文章が表示されるようになります。 各ページごとに設定を行いたい場合は、下記のようにフロントマターで、isCJKLanguage を true に設定します。 --- title: \u0026#34;記事のタイトル\u0026#34; date: \u0026#34;2017-08-29\u0026#34; isCJKLanguage: true --- 記事の本文 設定ファイルでは hasCJKLanguage を設定し、Markdown ファイルのフロントマターでは isCJKLanguage を設定することに注意してください。"},{url:"/p/utmg42x/",title:"Hugo で特定の記事を常にリスト上方に表示する（weight プロパティ）",date:"2017-08-28T00:00:00Z",body:"Hugo で特定の記事を常にリスト上方に表示する（weight プロパティ） Hugo で記事（コンテンツ）の一覧を表示しようとすると、通常は記事の作成日時順に表示されます。 一覧ページで特定の記事を最初に表示したい場合は、記事のフロントマターの weight プロパティで、記事の重要度（整数値）を設定します。 記事のヘッダ (Front matter) の記述例 --- title: \u0026#34;重要な記事\u0026#34; date: \u0026#34;2017-08-28\u0026#34; weight: 1 --- ...本文... weight プロパティに設定した値は、小さいほど重要度が高いと認識されます。 つまり、weight 値を 1 にすると、重要な記事として上の方に表示されます。 2 はその次、3 はさらにその次、というように、昇順に表示されます。 0 は特別で、weight 値を指定していないのと同じ意味になります。 weight 値には、実はマイナスの値も設定することができるため、-99999 といった値を設定しておくと、1 や 2 と設定したものよりも上位に表示されます（優先度がものすごく高いと見なされる）。 weight 値の設定されていない（あるいは weight: 0 に設定した）通常の記事は、どのような weight 値を持つ記事よりも優先度が低いと見なされませます（後ろに表示されます）。"},{url:"/p/q7sdwgy/",title:"Hugo で記事を作成する",date:"2017-08-25T00:00:00Z",body:"Hugo で記事を作成する 記事ファイルを作成する Hugo で公開する Web サイトの記事は、content ディレクトリに Markdown ファイルとして作成します（例: sample.md）。 記事ファイルは、空っぽのテキストファイルから作成していくこともできますが、hugo new コマンドを使用することで、記事のひな形ファイル (archetypes/default.md) をベースにして Markdown ファイルを自動生成することができます。 記事ファイル（Markdown ファイル）を作成 $ hugo new sample.md /Users/maku/my_site/content/sample.md created 上記のように実行すると、content ディレクトリ内に sample.md ファイルが作成されます。 作成されたファイルの先頭部分には、下記のような Front matter というヘッダが記述されています。 このヘッダが、archetypes/default.md をもとにして自動生成されたものです。 content/sample.md --- title: \u0026#34;Sample\u0026#34; date: 2017-08-25T22:55:55+09:00 draft: true --- あとは、タイトル (title) を適切なものに書き換え、Front matter ヘッダ以降に記事の本文を記述していきます。 公開できるレベルまで記述できたら、ヘッダ部分の draft: true の行を削除します。 Archetypes ここで、ベースとなっている archetypes/default.md を覗いてみましょう。 archetypes/default.md --- title: {{ replace .TranslationBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- title フィールドには hugo new コマンドで指定した名前が自動で入り、date フィールドには現在の時刻が自動で入るようになっています。 このファイルの内容をもとに、記事ファイルが作成されていることが分かりますね。 記事作成と同時にエディタで編集を始める hugo new コマンドで記事ファイルを作成するときに、--editor オプションを指定すると、記事ファイルの生成と同時に指定したエディタでファイルを開くことができます。 例: 記事ファイルを作成して vim で開く $ hugo new sample.md --editor vim"},{url:"/p/h2cku5d/",title:"Hugo のテーマを設定する",date:"2017-08-25T00:00:00Z",body:"Hugo のテーマを設定する テーマをダウンロードする Hugo で Web サイトを生成するときは、外観のベースとなる テーマ を設定する必要があります。 テーマを設定せずに hugo コマンドで Web サイトを出力しても、真っ白なページが表示されてしまうだけです。 テーマは自分で作成することもできますが、Hugo Themes というサイトに、有志の人によって作られたテーマが公開されていますので、まずはここからダウンロードして使ってみるのがよいでしょう。 使用方法はテーマごとに少しずつことなるので、詳細はそれぞれのテーマの説明 (README.md) を読んでください。 テーマの ZIP ファイルをダウンロードする方法 例えば、下記の bootstrap4-blog というテーマがよさそうであれば、Download ボタンを押します。 通常は、GitHub のサイトに飛ぶので、Clone or download のボタンを押してテーマをダウンロードしてください。 ダウンロードしたテーマは、プロジェクトの themes ディレクトリに配置します。 このケースでは、themes/bootstrap4-blog ディレクトリとして配置します。 テーマを Git で取得する方法 テーマは GitHub 上で管理されていますので、Git コマンドが使える環境であれば、下記のように git clone してしまうのが簡単です（もちろん先にリポジトリの URL は調べておく必要はありますが）。 $ git clone https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/bootstrap4-blog もし、自分のサイトを Git 管理しているのであれば、次のようにテーマを Git サブモジュール として取り込んでしまうがよいです。 Git サブモジュールのコマンド (git submodule) はちょっと難しいですが、テーマをサブモジュールとして管理すれば、テーマ側の更新を適宜反映できるようになります。 # テーマをサブモジュールとして取り込む $ git submodule add https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/bootstrap4-blog # テーマ側の更新を取り込むとき $ git submodule update --remote --recursive （必要に応じて）テーマごとのセットアップ テーマによっては、外部コンポーネントに依存していて、初期設定が必要なものもあります。 上記の bootstrap4-blog テーマでは、下記のように関連モジュールをインストールしてくださいと説明がありますので、その通りに実行しておきます。 $ npm install $ npm run build ちなみに、npm は Node.js 用のパッケージマネージャで、Node.js をインストールすれば一緒にインストールされます。 使用するテーマを指定する テーマは themes ディレクトリにいくつでもダウンロードしておくことができます。 その中から実際に使用するテーマは、Hugo の設定ファイルの中で以下のように設定します。 config.toml（抜粋） theme = \u0026#34;bootstrap4-blog\u0026#34; テーマを設定したら、hugo コマンドで Web サイトを生成してみてください。 設定したテーマをもとに、public ディレクトリ以下にアップロード用のファイル群が出力されるはずです。 $ hugo hugo server コマンドで、Web サーバを立ち上げる場合にも config.toml で設定したテーマが使用されます。 hugo コマンドを実行するときに、-t オプションで使用するテーマを指定することもできます。 $ hugo -t theme_name （サイトを出力する場合） $ hugo server -t theme_name （Web サーバを立ち上げる場合）"},{url:"/p/wdyk5n7/",title:"カレントディレクトリを気にせずに hugo コマンドを実行する",date:"2017-08-25T00:00:00Z",body:"カレントディレクトリを気にせずに hugo コマンドを実行する hugo コマンドを実行するときに、-s (--source) オプションを使用することで、ソースディレクトリのパスを指定して起動することができます。 例: ~/mysite 以下のソースコードを使って Hugo サーバーを起動する $ hugo server -s ~/mysite 例: ~/mysite 以下の記事を新規作成する $ hugo new sample.md -s ~/mysite 上記の例では、-s ~/mysite というソースディレクトリの指定を末尾に持ってきましたが、hugo の直後に指定しても動作するようです。 これを利用して、下記のようなコマンドエイリアスを作成しておけば、どのディレクトリからでもすぐに記事作成を始められて便利です。 ~/.bash_profile alias hugo-mysite=hugo -s ~/mysite 例えば、下記のように使用することができます。 $ hugo-mysite new sample.md # 記事の作成 $ hugo-mysite server # Hugo サーバーを起動 $ hugo-mysite # サイトをビルド（~/mysite/public に出力）"},{url:"/p/jj7rcvf/",title:"ポート番号を指定して Hugo サーバーを起動する",date:"2017-08-25T00:00:00Z",body:"ポート番号を指定して Hugo サーバーを起動する Hugo サーバーを hugo server コマンドで起動すると、デフォルトでは 1313 ポートを使用する Web サーバが立ち上がります。 ただし、複数の Hugo サーバーを同時に立ち上げようとすると、2 つめ以降の Hugo サーバーにはランダムなポート番号が割り当てられます（おそらく Private ports である 49152～65535 の範囲のポート番号が使用されます）。 任意のポート番号を使うように指定するには、下記のように -p (--port) オプションを使用します。 例: ポート番号 51234 で Hugo サーバーを立ち上げる $ hugo server -p 51234 たくさんの Hugo サーバーを同時に起動するようなケースでは、それぞれのサイトでどのポート番号を使用するかを決めておくとよいでしょう。 例: 3 つの Hugo サーバーを同時に立ち上げる $ hugo server -p 50001 -s ~/mysite1 $ hugo server -p 50002 -s ~/mysite2 $ hugo server -p 50003 -s ~/mysite3 上記のように立ち上げた Web サイトは、それぞれ下記のようなアドレスでアクセスできるようになります。 http://localhost:50001/ http://localhost:50002/ http://localhost:50003/"},{url:"/p/m2oatdw/",title:"Hugo でドラフトページを作成する",date:"2017-08-24T00:00:00Z",body:"Hugo でドラフトページを作成する ドラフト記事 Hugo のドラフト機能は、未完成の記事ファイルを一時的にほかの記事と同じ場所に保存しておくための機能です。 ページの Front matter 部分に、draft: true という記述があると、そのページはドラフトとして扱われます。 YAML 形式の場合 --- draft: true --- 本文 TOML 形式の場合 +++ draft = true +++ 本文 ドラフトとして作成された記事は、デフォルトでは HTML ファイルとして出力されません。 ドラフト記事も出力するようにするには、hugo コマンドに -D (--buildDrafts) オプションを指定します。 ドラフト記事を出力 $ hugo -D # サイトを生成する場合 $ hugo server -D # サーバーを立ち上げる場合 public ディレクトリに出力されたドラフト記事に注意 hugo コマンドは、デフォルトで public ディレクトリに HTML ファイルなどを出力しますが、このとき、public ディレクトリ内に既に存在するドラフト記事を削除することはありません。 $ hugo -D # ここでドラフト記事も含めて生成される $ hugo # 次にドラフトモード OFF で生成しても、既存のドラフト記事が削除されない Web サイトを公開するときは、ドラフト記事が間違ってアップロードされないように気を付けてください。 記事のアップロード前は、public ディレクトリを削除してから hugo コマンドで再生成すると安全です。 Linux / macOS の場合 $ rm -Rf public \u0026amp;\u0026amp; hugo Windows の場合 C:\\\u0026gt; rmdir /s /q public \u0026amp; hugo ドラフト記事の一覧を表示する コマンドラインから コマンドラインで hugo list drafts と実行すると、contents ディレクトリ内の記事のうち、ドラフトとしてマークされている（フロントマターに draft: true と記述されている）ファイルの一覧を確認することができます。 $ hugo list drafts draft.md diaries/temp.md books/work-shift.md 参考: hugo list drafts｜Hugo テンプレートから テンプレートファイル内で、ドラフト記事のリンクを列挙するには以下のようにします。 layouts/index.html（抜粋） \u0026lt;h2\u0026gt;ドラフト記事の一覧\u0026lt;/h2\u0026gt; \u0026lt;ul\u0026gt; {{ range (where .Site.Pages \u0026#34;.Draft\u0026#34; true) }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; ☝️ ワンポイント where .Site.Page \u0026quot;.Draft\u0026quot; true という部分で、ドラフト記事を抽出するための検索条件を指定しています。 サイト内のすべてのページ (.Site.Pages) から、ページ変数の .Draft の値が true であるもの (\u0026quot;.Draft\u0026quot; true) を列挙する、という指定になっています。 テンプレートの中でドラフト記事かどうかを判別する テンプレートファイル の中で、今レンダリングしている記事がドラフトである（フロントマターに draft: true と記述されている）かどうかを調べるには、Page 変数 の .Draft を参照します。 layouts/_default/single.html（抜粋） \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ if .Draft }} \u0026lt;b\u0026gt;注: この記事はまだドラフトです。\u0026lt;/b\u0026gt; {{ end }}"},{url:"/p/bt5enw6/",title:"Hugo で新規の Web サイトを作成する",date:"2017-08-23T00:00:00Z",body:"Hugo で新規の Web サイトを作成する ここでは、Hugo を使用して、新しく Web サイトを構築するための手順を示します。 図: Hugo で生成したサイトの例 サイトのスケルトンを生成する まずは Hugo をインストールして、hugo コマンドを使用できる状態にしてください。 下記のように hugo new site コマンドを使用して、Web サイトのひな型を作成することができます。 新しい Web サイト (my_site) を作成する $ hugo new site my_site Congratulations! Your new Hugo site is created in C:\\Users\\maku\\my_site. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/, or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 生成されるファイル群はものすごくシンプルで、下記のようにファイル２つと、いくつかのディレクトリだけです。 my_site/ +-- config.toml （サイト全体の設定） +-- archetypes/ （新しいページを作成するときのひな形） | +-- default.md +-- content/ （記事を格納。Markdown 形式のファイルを置いていく） +-- data/ （サイト生成時に利用するデータ） +-- layouts/ （レイアウトテンプレート） +-- static/ （画像ファイルなど、サイト生成時にそのままコピーするファイルを置く） +-- themes/ （テーマディレクトリを配置。実際にどのテーマを使用するかは config.toml で指定） サイトのテーマをインストール、設定する 参考: Hugo のテーマを設定する Hugo で新規に Web サイトを生成したら、外観を定義するためのテーマを１つ設定します（何らかのテーマを設定しておかないと、生成されたサイトは空っぽ（真っ白）になってしまいます）。 hugo new site によるサイト生成では、テーマまでは生成されないので、ネット上に公開されているテーマをダウンロードしてきます。 ここでは、mainroad というテーマ を使用してみましょう。 Hugo のテーマは、themes ディレクトリの下に、テーマ用のディレクトリを作って保存します。 テーマ別にディレクトリを分けて保存するので、複数のテーマをあらかじめダウンロードしておくことができます（実際に使用するテーマは簡単に切り替えられます（後述））。 テーマは GitHub で配布されているので、Git がインストールされているのであれば、下記のように簡単にインストールできます。 $ cd themes $ git clone https://github.com/vimux/mainroad themes/mainroad というディレクトリが作成されれば OK です。 あとは、実際にこのテーマを使用するように、Hugo の設定ファイル (config.toml) に下記の一行を追加してください。 config.toml（抜粋） theme = \u0026#34;mainroad\u0026#34; これでテーマの設定は完了です。 サイトのタイトルと言語を設定する サイトの設定ファイルでは、テーマ設定以外にも、サイトタイトル (title) や、全体で使用する言語 (languageCode) の設定を行っておきます。 config.toml baseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;ja-jp\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;mainroad\u0026#34; ☝️ ワンポイント ここで設定した値は、テンプレートファイルの中から、{{ .Site.Title }}、{{ .Site.BaseURL }}、{{ .Site.LanguageCode }} のように参照することができます。 記事を作成する 参考: Hugo で記事を作成する ここでは、サンプル記事を 1 つだけ作成しておきましょう。 次のように hugo new コマンドを実行すると、content ディレクトリ以下に記事ファイル（Markdown ファイル）が自動作成されます。 コマンドはプロジェクトのトップディレクトリで実行してください。 $ hugo new post/sample.md これで content/post/sample.md というファイルが生成されるので、下記のような感じになるように修正してください。 content/post/sample.md --- title: \u0026#34;記事のタイトル\u0026#34; date: 2017-08-25T22:20:24+09:00 --- 記事の本文 記事の本文 記事の本文 ヘッダ部分に、draft: true という行があると、ページが出力されなくなってしまうので、その行は削除してください（参考: Hugo でドラフトページを作成する）。 Hugo の Web サーバーを起動する Web サイトのテーマ設定や記事作成が終わったら、hugo server コマンドを実行して Web サーバーを起動します（実際には、Web サーバーは起動したままで記事の作成を行っていけます）。 $ hugo server Started building sites ... Built site for language en: 0 draft content 0 future content 0 expired content 1 regular pages created 6 other pages created 0 non-page files copied 1 paginator pages created 0 tags created 0 categories created total in 8 ms Watching for changes in C:\\Users\\maku\\my_site\\{data,content,layouts,static,themes} Serving pages from memory Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop Hugo サーバーの起動にかかった時間は、たったの 8ms です。爆速ですね。 Hugo サーバが起動した状態で、Web ブラウザから http://localhost:1313/ にアクセスすると、サイトのトップページが表示されます。 あとは、hugo new コマンドを使って記事をどんどん作成していくだけです。 Hugo サーバは、content ディレクトリ内の変更を監視しており、記事が作成されたり修正されたりした場合に自動的にリロードしてくれるので、Hugo サーバは一度立ち上げたら立ち上げっぱなしで大丈夫です。 記事のカスタマイズ方法は、テーマごとに異なりますので、詳しくは各テーマのサイトを参照してください。"},{url:"/p/r8ufyk5/",title:"Hugo とは／Hugo をインストールする",date:"2017-08-23T00:00:00Z",body:"Hugo とは／Hugo をインストールする Hugo とは Hugo (https://gohugo.io/) Hugo は Jekyll や Middleman と同様の静的サイトジェネレータです。 Markdown 形式などで記述したコンテンツから、HTML ファイルを作成してくれます。 Hugo は Google の Go 言語 で作成されており、他のサイトジェネレータに比べて 動作が非常に速い という特徴を持っています（それに比べて Jekyll は特に遅いですね ^^;）。 公式サイトでも動作の高速さをアピールしており、今後もその方針は変わらなさそうなので安心です。 また、インストールに関しても、他の（Ruby 製や Python 製の）サイトジェネレータは、さまざまな外部モジュールをインストールしなければいけないので時間がかかったりすることがありますが、Hugo であれば一瞬で終わります。 例えば、Windows の実行環境を構築する場合も、hugo.exe という１ファイルを置くだけで終わります。 LiveReload などの機能もデフォルトで組み込まれており、立ち上げまでの導入が非常にシンプルです。 Hugo のインストール Mac OS の場合 Mac の場合は、Homebrew (brew) で簡単に Hugo をインストール できます。 $ brew install hugo すでに Hugo がインストールされている状態で、Hugo を最新バージョンに更新 したいときは次のようにします。 $ brew upgrade hugo 現在インストールされている Hugo のバージョン は次のように確認できます。 $ hugo version Windows の場合 Windows の場合は、Hugo の Releases ページから zip アーカイブ（hugo_extended_0.110.0_windows-amd64.zip など）をダウンロードしてしまうのが手っ取り早いでしょう。 Sass などの機能を使う場合は、hugo_extended で始まるファイルを使わないといけないことに注意してください。 展開した hugo.exe を適当なディレクトリに置いて、パスを通せばインストール完了です。 簡単！ 現在インストールされている Hugo のバージョン は次のように確認できます。 $ hugo version"},{url:"/p/uu32hpo/",title:"（旧）CSS によるフレキシブルボックスの旧式の定義方法",date:"2017-08-03T00:00:00Z",body:"（旧）CSS によるフレキシブルボックスの旧式の定義方法 参考: フレキシブルボックスによるレスポンシブレイアウト フレキシブルボックスの定義に、昔は display: box を使用していましたが、最新の W3C 仕様では display: flex となっています。 Chrome ~20: display:-webkit-box Chrome ~28: display:-webkit-flex Chrome 28~: display:flex Firefox ~21: display:-moz-box Firefox 22~: display:flex IE9: (not supported) IE10: display:-ms-flexbox IE11: display:flex Safari ~6.0: display:-webkit-box Safari 6.1~: display:-webkit-flex Android ~4.3: display:-webkit-box Android 4.4~: display:flex iOS(Safari) ~6.1: display:-webkit-box iOS(Safari) 7.0~: display:-webkit-flex フレキシブルボックス用の display 指定は、このように定義しておけばよさそうです。 display: flex; display: -webkit-flex; display: -webkit-box; display: -moz-box; さらに、伸縮時の割合の指定は、box-flex の代わりに flex-grow を使用します。 flex-grow: 1; -webkit-flex-grow: 1; -webkit-box-flex: 1; -moz-box-flex: 1; 参考: Can I use \u0026hellip; Support tables for HTML5, CSS3, etc 参考: 可変ボックス (\u0026ldquo;Flexbox\u0026rdquo;) レイアウトの更新 (Windows)"},{url:"/octave/",title:"Octave",date:"2017-03-31T00:00:00Z",body:"Octave 行列／ベクトルの作成 行列／ベクトルを作成する 零行列（零行列）を作成する (zeros) 単位行列を作成する (eye) すべての要素が 1 の行列を作成する (ones) ランダムな数値で行列を作成する (rand) 転置行列を作成する 逆行列を作成する (inv) 対角行列を作成する (diag) 行列／ベクトルに対する処理 行列／ベクトルのサイズ（形状）を確認する (size, length) 行列／ベクトルのサイズを変更する 行列／ベクトル内の要素を参照する 行列／ベクトルを結合する 行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う 制御命令／関数 Octave の制御命令: if ~ else Octave の制御命令: switch ~ case Octave の制御命令: for / while / until ループ Octave で関数を定義する (function) ファイル／入出力／表示設定 ファイルに記述したプログラムを実行する（スクリプトファイル） ファイルに記述した関数を実行する（関数ファイル） ファイルに記述したデータを読み込む/保存する (load, save) 出力する桁数を増やす (format) メモ コーディングルールなど インデントは 4。 文字列はシングルクォート (') で囲む。 画像は 400x300 の PNG で出力する (print '-S400,300' fig.png)。 TeX チートシート｜まくろぐ"},{url:"/p/o9qhvyu/",title:"Octave でファイルに記述した関数を実行する（関数ファイル）",date:"2017-03-31T00:00:00Z",body:"Octave でファイルに記述した関数を実行する（関数ファイル） 関数ファイルの基本 Octave で読み込む外部ファイル (.m) が、関数定義 (function) で始まっていると、そのファイルは 関数ファイル として認識され、組み込み関数のように呼び出せるようになります。 関数ファイルの名前は、ファイルの先頭で定義する関数名に合わせます。 次の例では myfunc という関数を定義しているので、ファイル名は myfunc.m とします。 myfunc.m function y = myfunc(x) y = x**2; end 上記のように関数ファイルで定義した関数は、組み込み関数と同じ感覚で呼び出すことができます。 \u0026gt;\u0026gt; myfunc(7) 49 サブファンクション 関数ファイルで定義された関数は、先頭で定義した関数だけが公開されます。 例えば、下記の関数ファイルでは、hello 関数と hello2 関数を定義していますが、外部から呼び出せる関数は hello 関数だけであり、hello2 関数はファイル内からのみ呼び出せるサブファンクション として定義されます。 hello.m % 先頭で定義されているこの関数だけが公開される function hello() disp(\u0026#39;hello\u0026#39;); hello2(); end % 以降の関数はサブファンクションとみなされて外部には公開されない function hello2() disp(\u0026#39;hello2\u0026#39;) end 実行例 \u0026gt;\u0026gt; hello hello hello2 \u0026gt;\u0026gt; hello2 % サブファンクションは外からは直接呼び出せない error: \u0026#39;hello2\u0026#39; undefined near line 1 column 1 プライベートファンクション サブファンクションは、定義したファイル内でしか呼び出すことができないので、いろいろな関数から呼び出したいヘルパー関数を作成したいときには都合が悪いです。 このような場合は、ヘルパー関数を プライベートファンクション として別の関数ファイルに分離しておきます。 作成方法は通常の関数ファイルと同様ですが、作成したファイルを private ディレクトリ内に格納するようにします。 下記の例では、通常の関数ファイル hello.m から、プライベートファンクションとして定義された private_func を呼び出しています。 hello.m function hello() disp(\u0026#39;hello\u0026#39;); private_func(); end private/private_func.m function private_func() disp(\u0026#39;private_func\u0026#39;); end 実行例 \u0026gt;\u0026gt; hello() hello private_func 1 つのファイルで複数の関数を公開する 関数ファイルでは、先頭で定義した関数しか公開されませんが、複数の関数定義を含んだファイルをスクリプトとして実行してしまうことは可能です。 例えば、下記のように、関数 foo と関数 bar の定義を含んだスクリプトを用意して、これをスクリプトとして読み込めば、2 つの関数を外部から呼び出せるようになります。 functions.m 1; % Load as a script function foo() disp(\u0026#39;foo\u0026#39;); end function bar() disp(\u0026#39;bar\u0026#39;); end 先頭が function 定義で始まってしまうと、関数ファイルとして認識されてしまうので、ダミーの 1; というコードを入れて、強制的にスクリプトファイルとして処理されるようにしていることに注意してください。 あとは、このスクリプトを実行すれば、2 つの関数（foo と bar）を任意のタイミングで呼び出せるようになります。 実行例 \u0026gt;\u0026gt; functions % スクリプトとして functions.m を実行 \u0026gt;\u0026gt; foo() foo \u0026gt;\u0026gt; bar() bar"},{url:"/p/vo54icm/",title:"Octave で関数を定義する (function)",date:"2017-03-29T00:00:00Z",body:`Octave で関数を定義する (function) 関数定義の基本 Octave で関数を定義するには、function ~ end の構文を使用します。 例えば、渡された数値の 2 乗を返す関数 myfunc は下記のように定義できます。 myfunc 関数を定義する function ret = myfunc(x) ret = x ** 2; end myfunc 関数を呼び出す y = myfunc(7); %=\u0026gt; 49 戻り値は return で指定するのではなく、関数値用に宣言した変数に代入することで表現することに注意してください。 上記の例では、関数値を表す変数は ret という名前で定義していますが、任意の名前を付けることができます。 もちろん、関数を途中で抜けるときは return を使用することができますが、その場合も戻り値はあらかじめ関数値用の変数に格納しておく必要があります。 途中で関数を抜ける場合 function y = f(x) if x == 0 y = -1; % 戻り値は return では返せない return end ... end 戻り値を持たない関数を定義する 戻り値を持たない関数も同様に定義できます（関数というよりサブルーチンというのが正しいのかも）。 内部で出力処理まで終わらせてしまうような関数がこれにあたります。 function greet(name) printf(\u0026#39;Hello %s\\n\u0026#39;, name); end 多値関数（複数の戻り値を持つ関数）を定義する 関数値としてベクトルを返すように定義すれば、複数の戻り値を持つ関数として扱うことができます。 下記の例では、除算結果の商と剰余を返す関数を定義しています。 2 つの値を返す関数 function [quotient, remainder] = div(x, y) quotient = floor(x / y); remainder = rem(x, y); end 呼び出し方 [a, b] = div(10, 3); printf(\u0026#39;a=%d, b=%d\\n\u0026#39;, x, y); % a=3, b=1 パラメーターにデフォルト値（オプショナル引数）を設定する パラメーター名の後にデフォルト値を指定しておくことができます。 パラメーターを省略して関数を呼び出した場合に、デフォルト値が使用されます。 デフォルト値を持つパラメーター function greet(name = \u0026#39;Maku\u0026#39;) printf(\u0026#39;Hello, %s\\n\u0026#39;, name); end 呼び出し方 greet(); %=\u0026gt; Hello, Maku greet(\u0026#39;John\u0026#39;); %=\u0026gt; Hello, John`},{url:"/p/bi5rv73/",title:"Octave でファイルに記述したデータを読み込む/保存する (load, save)",date:"2017-03-27T00:00:00Z",body:"Octave でファイルに記述したデータを読み込む/保存する (load, save) ファイルからデータを読み込む (load) Octave で、ファイルに保存したデータファイルを読み込むには、組み込み関数の load を使用します。 例えば、下記のような二次元データ（行列データ）があるとします。 mydata.txt 100 200 300 400 500 600 700 800 900 このデータファイルを読み込むには、下記のようにします（あらかじめ cd コマンドで、データファイルのあるディレクトリに移動しておいてください）。 データファイルの内容は、ファイル名と同じ名前の変数に格納されます。 データファイルを読み込む \u0026gt;\u0026gt; load mydata.txt \u0026gt;\u0026gt; mydata mydata = 100 200 300 400 500 600 700 800 900 データファイルの内容を別の名前の変数に格納したいときは、次のように load 関数の戻り値を変数に代入します。 データファイルを指定した変数に読み込む \u0026gt;\u0026gt; A = load(\u0026#39;mydata.txt\u0026#39;) A = 100 200 300 400 500 600 700 800 900 ちなみに、現在定義されている変数の一覧を表示するには、whos コマンドを使用します。 変数の一覧を表示 \u0026gt;\u0026gt; whos Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== mydata 3x3 72 double ファイルから読み込んだ mydata が、サイズ 3x3 のデータとして定義されていることが分かります。 ファイルにデータを保存する (save) 逆に、Octave の実行環境上で作成した行列データなどをデータファイルとして出力するには、save 関数を使用します。 次の例では、行列 A と B のデータを mydata.txt というファイルに保存しています。 行列データをファイルに保存する \u0026gt;\u0026gt; A = [1 2 3; 4 5 6; 7 8 9]; \u0026gt;\u0026gt; B = [100 200 300; 400 500 600]; \u0026gt;\u0026gt; save mydata.txt A B ここでは保存する変数を、save のパラメーターで明示的に列挙していますが、変数の指定を省略すると、ワークスペース内で定義されている変数（whos で出てくるデータ）がすべて保存されます。 save の実行に成功すると、下記のようなファイルが生成されます。 mydata.txt # Created by Octave 4.2.1, Mon Mar 27 22:13:04 2017 GMT \u0026lt;unknown@unknown\u0026gt; # name: A # type: matrix # rows: 3 # columns: 3 1 2 3 4 5 6 7 8 9 # name: B # type: matrix # rows: 2 # columns: 3 100 200 300 400 500 600 save コマンドで作成したファイルには、上記のようにヘッダ情報が付け加えられており、変数名（ここでは A や B）も一緒に保存されています。 このファイルを load で読み込んだときは、ヘッダに記述された変数名でデータがロードされます。 データファイルからすべての変数を復旧する \u0026gt;\u0026gt; clear % ワークスペースの変数をすべてクリア \u0026gt;\u0026gt; load mydata.txt % ファイル読み込み \u0026gt;\u0026gt; whos % 変数を確認 Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== A 3x3 72 double B 2x3 48 double ファイル内の任意のデータだけをロードすることもできます。 下記の例では、mydata.txt に保存された B のデータのみを読み込んでいます。 データファイルから指定した変数のみ復旧する \u0026gt;\u0026gt; clear \u0026gt;\u0026gt; load mydata.txt B % 変数 B だけ取り出す \u0026gt;\u0026gt; whos Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== B 2x3 48 double"},{url:"/p/mgjgq8m/",title:"Octave でファイルに記述したプログラムを実行する（スクリプトファイル）",date:"2017-03-27T00:00:00Z",body:"Octave でファイルに記述したプログラムを実行する（スクリプトファイル） スクリプトファイルと実行方法 Octave では、カレントディレクトリに スクリプト名.m という名前でスクリプトファイルを作成しておくと、下記のようにしてそのスクリプトを実行することができます。 スクリプト名.m の呼び出し \u0026gt;\u0026gt; スクリプト名 ただし、スクリプトファイルが置かれたディレクトリで実行しなければいけません。 カレントディレクトリを移動するには、cd コマンドを実行します。 次のようにしてスクリプトを格納したディレクトリに移動しましょう。 \u0026gt;\u0026gt; cd D: % D ドライブのルートへ移動 カレントディレクトリがどこになっているかを確認するには、pwd コマンドを実行します。 \u0026gt;\u0026gt; pwd ans = C:\\Users\\maku スクリプトの実行例 ここでは、下記のようなスクリプトファイルを用意してみます。 myscript.m [X, Y] = meshgrid(-8:.5:8); R = sqrt(X.^2 + Y.^2) + eps; Z = sin(R) ./ R; figure mesh(X, Y, Z) このファイルが置いてあるディレクトリに移動して、拡張子 .m を除いた部分の名前を入力すると、スクリプトを実行できます。 \u0026gt;\u0026gt; cd somewhere \u0026gt;\u0026gt; myscript 次のようなグラフが表示されれば成功です。 図: myscript.m によるグラフ描画"},{url:"/p/8tddagn/",title:"Octave で対角行列を作成する (diag)",date:"2017-03-27T00:00:00Z",body:"Octave で対角行列を作成する (diag) $$ diag(c_1, c_2, \u0026hellip;, c_n) = \\begin{pmatrix} c_1 \u0026amp; \u0026amp; \u0026amp; 0 \\\\ \u0026amp; c_2 \u0026amp; \u0026amp; \\\\ \u0026amp; \u0026amp; \\ddots \u0026amp; \\\\ 0 \u0026amp; \u0026amp; \u0026amp; c_n \\end{pmatrix} $$ 正方行列のうち、対角成分 (diagonal elements) 以外がすべて零のものを 対角行列 (diagonal matrix) といいます。 Octave の組み込み関数 diag を使用すると、対角行列からの対角成分の抽出や、対角成分からの対格行列の生成を行うことができます。 対角行列から対角成分を抽出する \u0026gt;\u0026gt; A = [3 0 0; 0 -1 0; 0 0 2] A = 3 0 0 0 -1 0 0 0 2 \u0026gt;\u0026gt; v = diag(A) v = 3 -1 2 抽出された対角成分は、列ベクトルとして返されます。 対角成分から対角行列を生成する \u0026gt;\u0026gt; A = diag([3 -1 2]) A = Diagonal Matrix 3 0 0 0 -1 0 0 0 2 指定する対角成分は、行ベクトルでも縦ベクトルでも構いません（上記では行ベクトルを渡しています）。"},{url:"/p/xfuxvwq/",title:"Octave で行列／ベクトルのサイズを変更する",date:"2017-03-27T00:00:00Z",body:"Octave で行列／ベクトルのサイズを変更する 行列サイズを拡張する 既存の行列の存在しない領域の要素に代入を行うと、行列のサイズが自動的に拡張されます。 下記の例では、2x2 の行列に対して、(4,4) の位置に値を代入する操作をしています。 \u0026gt;\u0026gt; A = [1 2; 3 4] A = 1 2 3 4 \u0026gt;\u0026gt; A(4, 4) = 7 A = 1 2 0 0 3 4 0 0 0 0 0 0 0 0 0 7 上記のように、行列のサイズは自動的に拡張されて、4x4 になります。 自動的に拡張されて、値が指定されていない部分の値は 0 が設定されます。 ベクトルのサイズも同様に拡張できます。 \u0026gt;\u0026gt; v = 1:3 v = 1 2 3 \u0026gt;\u0026gt; v(7) = 100 v = 1 2 3 0 0 0 100 もちろん、下記のように行列を結合した場合も、行列のサイズは自動的に拡張されることになります。 \u0026gt;\u0026gt; v = [1 2; 3 4] v = 1 2 3 4 \u0026gt;\u0026gt; v = [v [5 6]\u0026#39;] v = 1 2 5 3 4 6 行列のサイズを縮小する 行列から部分行列を抽出すれば、行列のサイズを縮小したものとして扱うことができます。 下記の例では、ランダムに作成した 5x5 の行列から、3x3 の部分行列を抽出して、自分自身に書き戻しています。 \u0026gt;\u0026gt; A = floor(rand(5)*10) % 0～9 のランダム値で 5x5 行列を生成 A = 6 5 9 6 7 8 8 4 7 4 2 2 3 1 4 3 4 0 3 0 9 6 7 9 3 \u0026gt;\u0026gt; A = A(1:3, 1:3) A = 6 5 9 8 8 4 2 2 3"},{url:"/p/h9pgnw6/",title:"Octave の制御命令: for / while / until ループ",date:"2017-03-27T00:00:00Z",body:"Octave の制御命令: for / while / until ループ Octave のループ構文は、下記のようなものが用意されています。 for ループ while ループ do ~ until ループ Octave には do ~ while ループや、単純な until ループは存在しないことに注意してください。 C++ や Java と同様に、各ループ処理の中では、continue によるループ継続や、break によるループ脱出を行えます。 for ループ for x = ベクトル ... end とすると、ベクトル要素（あるいは行列要素）を 1 つずつ取り出しながらループ処理を行うことができます。 下記の例では、1～5 までの値を順番に足しこんでいく様子を表示しています。 1 ~ 5 まで合計する sum = 0 for x = 1:5 sum += x; disp(sum) end 実行結果 1 3 6 10 15 for ループは入れ子構造で記述することもできます。 下記は 2 重ループで 3x3 の行列を初期化しています。 3x3 行列の初期化 for i = 1:3 for j = 1:3 A(i, j) = i * j; end end disp(A) 実行結果 1 2 3 2 4 6 3 6 9 次の例では、行列 A の各要素をループでひとつずつ取得して表示しています。 組み込み関数の size は行列のサイズを返してくれますが、第２パラメータで 1 と 2 を指定することで、それぞれ行数、列数を返してくれるようになります。 これを利用して、正しい数だけループ処理しています。 行列の要素を行ごとにループ処理 A = [1 2 3; 4 5 6]; for i = 1:size(A, 1) % 行の数だけループ（２回） for j = 1:size(A, 2) % 列の数だけループ（３回） disp(sprintf(\u0026#39;A(%d,%d)=%d\u0026#39;, i, j, A(i,j))) end end 実行結果 A(1,1)=1 A(1,2)=2 A(1,3)=3 A(2,1)=4 A(2,2)=5 A(2,3)=6 下記のように行、列のサイズを別々の変数に取得してしまうのもアリですね。 [i_max, j_max] = size(A); for i = 1:i_max for j = 1:j_max disp(A(i,j)) end end while ループ while ループでは、指定した条件を満たす限りループ処理が継続されます。 i = 0; while (i \u0026lt; 10) ++i endwhile 条件式に true を指定すれば、無限ループを作成することができますが、その場合はループ内で何らかの条件で break しなければいけません。 下記の例では、ユーザが 10 以上の数値を入力するまで、ユーザからの入力を求め続けます。 10 以上の値が入力されるまで繰り返す while true num = input(\u0026#39;num? \u0026#39;); if (num \u0026gt; 10) break end endwhile Octave の if ブロックは、上記のように必ず end で終わらなければいけないことに注意してください（end を省略することはできません）。 do ～ until ループ do ~ until ループは、ある条件を満たすまでループを実行します。 条件判定はブロック内の処理を実行してから行われるため、必ず 1 回はブロック内の処理が実行されます。 i が 10 以上になるまでループ処理 i = 0; do ++i until (i \u0026gt;= 10)"},{url:"/p/4x34ejm/",title:"Octave の制御命令: if ～ else",date:"2017-03-27T00:00:00Z",body:"Octave の制御命令: if ～ else Octave (MATLAB) の if ～ else の構文は以下のようになっています。 if (COND) ... elseif (COND) ... else ... end 条件式では下記のような比較演算子が使用できます。 特に、a と b が等しくないことを表す記号が ~= であることに注意してください。 演算子 意味 a == b a と b が等しい a ~= b a と b が等しくない a \u0026lt; b a が b より小さい a \u0026gt; b a が b より大きい a \u0026lt;= b a が b 以下 a \u0026gt;= b a が b 以上 a a が 0 以外 また、論理演算子を組み合わせて使用できます。 演算子 意味 COND1 || COND2 COND1 あるいは COND2 が真ならば真 COND1 \u0026amp;\u0026amp; COND2 COND1 と COND2 両方が真ならば真 !COND1 真偽値の反転 例: x の値によって分岐する x = 2 if (x == 1) disp(\u0026#39;one\u0026#39;) elseif (x == 2) disp(\u0026#39;two\u0026#39;) else disp(\u0026#39;other\u0026#39;) end"},{url:"/p/r9h53gn/",title:"Octave の制御命令: switch ～ case",date:"2017-03-27T00:00:00Z",body:"Octave の制御命令: switch ～ case 変数に格納された値の種類によって分岐処理を行うには、次のように switch と case で分岐させます。 val = 2 switch val case 1 disp(\u0026#39;one\u0026#39;) case 2 disp(\u0026#39;two\u0026#39;) otherwise disp(\u0026#39;other\u0026#39;) endswitch 下記のように、複数のパターンを１つの case でまとめて処理することもできます。 yesno = \u0026#39;yes\u0026#39;; switch yesno case {\u0026#39;Yes\u0026#39; \u0026#39;yes\u0026#39; \u0026#39;YES\u0026#39; \u0026#39;y\u0026#39; \u0026#39;Y\u0026#39;} value = 1; case {\u0026#39;No\u0026#39; \u0026#39;no\u0026#39; \u0026#39;NO\u0026#39; \u0026#39;n\u0026#39; \u0026#39;N\u0026#39;} value = 0; otherwise error (\u0026#39;invalid value\u0026#39;); endswitch 逆に、下記のように、複数の case を連続して記述する方法はうまくいかないので注意してください（値が 1 のケースは何も処理しないという意味になってしまいます）。 間違った書き方 switch val case 1 % 間違った書き方 case 2 disp(\u0026#39;one or two\u0026#39;) otherwise disp(\u0026#39;other\u0026#39;) endswitch"},{url:"/p/ngxvjuy/",title:"Octave ですべての要素が 1 の行列を作成する (ones)",date:"2017-03-24T00:00:00Z",body:"Octave ですべての要素が 1 の行列を作成する (ones) Octave の組み込み関数 ones を使用すると、すべての要素が 1 である行列を作成することができます。 \u0026gt;\u0026gt; ones(3) ans = 1 1 1 1 1 1 1 1 1 \u0026gt;\u0026gt; ones(2, 4) ans = 1 1 1 1 1 1 1 1 スカラー値を掛けることで、1 以外の任意の値にすることができます。 \u0026gt;\u0026gt; ones(2, 4) * 7 ans = 7 7 7 7 7 7 7 7 ones 関数のドキュメント \u0026gt;\u0026gt; help ones \u0026#39;ones\u0026#39; is a built-in function from the file libinterp/corefcn/data.cc -- ones (N) -- ones (M, N) -- ones (M, N, K, ...) -- ones ([M N ...]) -- ones (..., CLASS) Return a matrix or N-dimensional array whose elements are all 1. If invoked with a single scalar integer argument N, return a square NxN matrix. If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions. To create a constant matrix whose values are all the same use an expression such as val_matrix = val * ones (m, n) The optional argument CLASS specifies the class of the return array and defaults to double. For example: val = ones (m,n, \u0026#34;uint8\u0026#34;)"},{url:"/p/kyjrsit/",title:"Octave でランダムな数値の行列を作成する (rand)",date:"2017-03-24T00:00:00Z",body:"Octave でランダムな数値の行列を作成する (rand) 0 ～ 1 のランダムな実数を生成する 組み込み関数の rand を使用すると、(0, 1) の範囲のランダムな実数を生成することができます。 \u0026gt;\u0026gt; x = rand() x = 0.68694 パラメータとして、行列のサイズを指定することで、ランダムな数値からなる行列を生成することができます。 \u0026gt;\u0026gt; rand(3) ans = 0.21961 0.93511 0.42575 0.40439 0.57059 0.47850 0.33873 0.52912 0.58643 \u0026gt;\u0026gt; rand(2, 4) ans = 0.710878 0.077407 0.991165 0.606275 0.807493 0.428040 0.497468 0.606412 任意の範囲のランダム値を生成する 任意の数値の範囲のランダム値を生成するには、下記のような演算を行います。 例: 0 ～ 10 の範囲のランダム値を生成 \u0026gt;\u0026gt; rand * 10 ans = 8.0312 例: -5 ～ 5 の範囲のランダム値を生成 \u0026gt;\u0026gt; rand * 10 - 5 ans = -4.6596 整数値にしたいときは、floor 関数を使って小数部分を切り捨てます。 例: 0 ～ 9 のランダムな整数を生成 \u0026gt;\u0026gt; floor(rand * 10) ans = 7 行列の要素にも適用できます。 例: 0 ～ 9 のランダムな整数からなる行列を生成 \u0026gt;\u0026gt; floor(rand(3) * 10) ans = 0 6 4 7 9 2 3 4 4"},{url:"/p/fism9pp/",title:"Octave で出力する桁数を増やす (format)",date:"2017-03-24T00:00:00Z",body:"Octave で出力する桁数を増やす (format) Octave の内部では倍精度の浮動小数点数（10 進数で 15 桁程度の精度）で計算が行われていますが、画面出力時のデフォルト桁数は 5 桁に設定されています。 \u0026gt;\u0026gt; pi pi = 3.1416 表示桁数を増やすには、下記のように format 関数を使用します。 表示桁数を増やす \u0026gt;\u0026gt; format long \u0026gt;\u0026gt; pi ans = 3.14159265358979 上記のように、パラメーターとして long を指定すると、倍精度実数の表現限界である 15 桁程度の数値を表示してくれるようになります。 元に戻したい場合は、パラメータなしで format 関数を実行します。 表示桁数を元に戻す \u0026gt;\u0026gt; format \u0026gt;\u0026gt; pi ans = 3.1415 format 関数で指定できるパラメータの詳細は、次のようにヘルプで確認できます。 \u0026gt;\u0026gt; help format"},{url:"/p/h24njtn/",title:"Octave で単位行列を作成する (eye)",date:"2017-03-24T00:00:00Z",body:"Octave で単位行列を作成する (eye) eye 関数 Octave で任意のサイズの 単位行列 \\(I\\) を作成するには、組み込み関数の eye を使用します。 $$ I = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \\ldots \u0026amp; 0 \\\\ \u0026amp; \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 1 \\end{pmatrix} $$ \u0026gt;\u0026gt; eye(3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 \u0026gt;\u0026gt; eye(5) ans = Diagonal Matrix 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1"},{url:"/p/aodnfsx/",title:"Octave で行列／ベクトルのサイズ（形状）を確認する (size, length)",date:"2017-03-24T00:00:00Z",body:"Octave で行列／ベクトルのサイズ（形状）を確認する (size, length) 行列のサイズを調べる (size) Octave の組み込み関数 size を使用すると、行列（あるいはベクトル）の形状（サイズ）を調べることができます。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 \u0026gt;\u0026gt; size(A) ans = 2 3 size メソッドの戻り値自体も、1 行 2 列の行列（行ベクトル）になっています。 \u0026gt;\u0026gt; size(size(A)) ans = 1 2 ベクトルのサイズを調べる (length) ベクトルのサイズを調べるときにも、size 関数を使用することができますが、代わりに length 関数を使用することで、スカラ値でベクトルのサイズを取得することができます。 length 関数は、行ベクトルの場合でも、列ベクトルの場合でも同様な値を返してくれます。 行ベクトルの場合 \u0026gt;\u0026gt; v = [1 2 3 4 5]; \u0026gt;\u0026gt; length(v) ans = 5 列ベクトルの場合 \u0026gt;\u0026gt; v = [1; 2; 3; 4; 5]; \u0026gt;\u0026gt; length(v) ans = 5 上記のように、行ベクトルでも列ベクトルでも共通の値を返してくれるのは、length 関数が 「行のサイズと列のサイズのうち大きい方を返す」 という振る舞いをするからです。 行列に対して length 関数を適用すると、下記のようにあまり意味のない結果を返すことになるので、length 関数はベクトル用だと思って使うのがよいでしょう。 \u0026gt;\u0026gt; length([1 2; 3 4; 5 6; 7 8]) ans = 4 \u0026gt;\u0026gt; length([1 2 3 4 5; 6 7 8 9 10]) ans = 5"},{url:"/p/hfgbxqq/",title:"Octave で行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う",date:"2017-03-24T00:00:00Z",body:"Octave で行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う 行列同士の四則演算 下記のような 2 行 3 列の行列を 2 つ用意します。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 \u0026gt;\u0026gt; B = [10 20 30; 40 50 60] B = 10 20 30 40 50 60 各要素同士の四則演算を行うには、+、-、.*、./ という演算子を使用します。 .* と ./ は、ドットが必要なことに注意してください。 \u0026gt;\u0026gt; A + B ans = 11 22 33 44 55 66 \u0026gt;\u0026gt; A - B ans = -9 -18 -27 -36 -45 -54 \u0026gt;\u0026gt; A .* B ans = 10 40 90 160 250 360 \u0026gt;\u0026gt; A ./ B ans = 0.10000 0.10000 0.10000 0.10000 0.10000 0.10000 行列とスカラ値の演算 行列とスカラ値との四則演算を行うと、各要素の演算でそのスカラ値が使用されます。 \u0026gt;\u0026gt; A + 100 ans = 101 102 103 104 105 106 \u0026gt;\u0026gt; A * 100 ans = 100 200 300 400 500 600 \u0026gt;\u0026gt; A / 100 ans = 0.010000 0.020000 0.030000 0.040000 0.050000 0.060000 \u0026gt;\u0026gt; A - 100 ans = -99 -98 -97 -96 -95 -94 単項演算子を使って各要素の符号を反転することができます。 \u0026gt;\u0026gt; -A ans = -1 -2 -3 -4 -5 -6 次のようにすると、各要素を 2 乗できます。 \u0026gt;\u0026gt; A .^ 2 ans = 1 4 9 16 25 36 各要素の逆数を取ることもできます。 \u0026gt;\u0026gt; 1 ./ A ans = 1.00000 0.50000 0.33333 0.25000 0.20000 0.16667 各行、各列ごとにベクトルを足しこむ 行列に対してベクトルを用いた四則演算を行うと、縦方向、あるいは横方向にベクトルの要素が拡張（コピー）されて演算が行われます。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 \u0026gt;\u0026gt; A + [100 200 300] ans = 101 202 303 104 205 306 \u0026gt;\u0026gt; A + [100; 200] ans = 101 102 103 204 205 206"},{url:"/p/6vpzojf/",title:"Octave で行列／ベクトルを結合する",date:"2017-03-24T00:00:00Z",body:"Octave で行列／ベクトルを結合する 下記のような 2 行 3 列の行列が 2 つあるとします。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 \u0026gt;\u0026gt; B = [11 12 13; 14 15 16] B = 11 12 13 14 15 16 これらの行列を横方向、あるいは縦方向に繋げて新しい行列を作成することができます。 横方向に結合する \u0026gt;\u0026gt; C = [A B] C = 1 2 3 11 12 13 4 5 6 14 15 16 縦方向に結合する \u0026gt;\u0026gt; D = [A; B] D = 1 2 3 4 5 6 11 12 13 14 15 16 横方向に結合する場合は行のサイズ、縦方向に結合する場合は列のサイズが等しくなければいけません。 上記の例の場合は、たまたま行列 A と行列 B の形状が同じなので、どちらの方向にも結合できています。 次のように、直接ベクトルデータを追加するように記述することもできます。 \u0026gt;\u0026gt; C = [A; [7 8 9]] C = 1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt; D = [A [7; 8]] D = 1 2 3 7 4 5 6 8"},{url:"/p/6ss2mk8/",title:"Octave で行列／ベクトル内の要素を参照する",date:"2017-03-24T00:00:00Z",body:"Octave で行列／ベクトル内の要素を参照する 行列内の特定の要素を参照する 下記のような 3x3 の行列があるとします。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6; 7 8 9] A = 1 2 3 4 5 6 7 8 9 この行列の 1 行 2 列の位置の要素を参照するには次のようにします。 各要素を参照する方法です。 1 行 2 列の要素を参照する \u0026gt;\u0026gt; A(1, 2) ans = 2 行列内の要素を行単位、列単位で取得する すべての行や列を表すには、: を使います。 3 行目の要素をすべて取得する（行ベクトル） \u0026gt;\u0026gt; A(3, :) ans = 7 8 9 2 列目の要素をすべて取得する（列ベクトル） \u0026gt;\u0026gt; A(:, 2) ans = 2 5 8 1 行目と 3 行目の要素をすべて取得する \u0026gt;\u0026gt; A([1 3], :) ans = 1 2 3 7 8 9 指定した位置への代入にも使用することができます。 下記の例では、3 行目の各要素を書き換えています。 \u0026gt;\u0026gt; A(3, :) = [10 20 30] A = 1 2 3 4 5 6 10 20 30 末尾のインデックスを表す特殊キーワード end 行列要素を参照するときに、行や列の位置を 開始位置:終了位置 という形で指定すると範囲指定になります。 この 終了位置 には、末尾を表す end を指定することができます。 下記の例では、2 行目から最後の行までの要素を抽出しています。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6; 7 8 9]; \u0026gt;\u0026gt; A(2:end, :) ans = 4 5 6 7 8 9 ベクトル内の特定の要素を参照する ベクトル内の特定の位置の要素を参照するときも、行列と同様にインデックスを指定します。 ただし、ベクトルの場合は指定するインデックスは 1 つだけです。 \u0026gt;\u0026gt; v = [10 20 30 40 50]; \u0026gt;\u0026gt; v(2) ans = 20 上記は行ベクトルのケースですが、列ベクトルの場合も同じように位置指定することができます。 \u0026gt;\u0026gt; v = [10; 20; 30; 40; 50]; \u0026gt;\u0026gt; v(2) ans = 20 範囲指定で部分ベクトルを抽出することもできます。 下記の例では、2 番目から 4 番目までの要素を抽出しています。 \u0026gt;\u0026gt; v = [10 20 30 40 50]; \u0026gt;\u0026gt; v(2:4) ans = 20 30 40 末尾を示す end キーワードも使用できます。 \u0026gt;\u0026gt; v = [10 20 30 40 50]; \u0026gt;\u0026gt; v(2:end) ans = 20 30 40 50"},{url:"/p/fkau9he/",title:"Octave で逆行列を作成する (inv)",date:"2017-03-24T00:00:00Z",body:"Octave で逆行列を作成する (inv) $$ \\begin{bmatrix} 1 \u0026amp; 2 \\\\ 3 \u0026amp; 4 \\end{bmatrix}^{-1} = \\begin{bmatrix} -2 \u0026amp; 1 \\\\ 1.5 \u0026amp; -0.5 \\end{bmatrix} $$ Octave で行列 \\(A\\) の逆行列 \\(A^{-1}\\) を求めるには、組み込み関数の inv を使用します。 \u0026gt;\u0026gt; A = [1 2; 3 4] A = 1 2 3 4 \u0026gt;\u0026gt; inv(A) ans = -2.00000 1.00000 1.50000 -0.50000 元の行列と逆行列の積は、単位行列になります（\\(AA^{-1} = A^{-1}A = I\\)）。 \u0026gt;\u0026gt; A * inv(A) ans = 1.00000 0.00000 0.00000 1.00000 \u0026gt;\u0026gt; inv(A) * A ans = 1.00000 0.00000 0.00000 1.00000"},{url:"/p/o9bmzfy/",title:"Octave で零行列（ゼロ行列）を作成する",date:"2017-03-24T00:00:00Z",body:"Octave で零行列（ゼロ行列）を作成する zeros 関数 $$ O = \\begin{pmatrix} 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; 0 \u0026amp; \\ldots \u0026amp; 0 \\end{pmatrix} $$ Octave でゼロ行列 (zero vector) を作成するには、組み込みの zeros 関数を使用します。 \u0026gt;\u0026gt; O = zeros(3) O = 0 0 0 0 0 0 0 0 0 \u0026gt;\u0026gt; O = zeros(2, 4) O = 0 0 0 0 0 0 0 0 zeros のドキュメント \u0026gt;\u0026gt; help zeros \u0026#39;zeros\u0026#39; is a built-in function from the file libinterp/corefcn/data.cc -- zeros (N) -- zeros (M, N) -- zeros (M, N, K, ...) -- zeros ([M N ...]) -- zeros (..., CLASS) Return a matrix or N-dimensional array whose elements are all 0. If invoked with a single scalar integer argument, return a square NxN matrix. If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions. The optional argument CLASS specifies the class of the return array and defaults to double. For example: val = zeros (m,n, \u0026#34;uint8\u0026#34;)"},{url:"/p/65afkmg/",title:"Octave で行列／ベクトルを作成する",date:"2017-03-23T00:00:00Z",body:"Octave で行列／ベクトルを作成する 行列の定義 ３行２列 $$ A = \\begin{bmatrix} 1 \u0026amp; 2 \\\\ 3 \u0026amp; 4 \\\\ 5 \u0026amp; 6 \\end{bmatrix} $$ A = [1 2; 3 4; 5 6]; 行ごとにセミコロンで区切ります。 ２行３列 $$ A = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\end{bmatrix} $$ \u0026gt;\u0026gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 ベクトルの定義 行ベクトル (row vector) $$ v = \\begin{bmatrix} 1 \u0026amp; 2 \u0026amp; 3 \\end{bmatrix} $$ \u0026gt;\u0026gt; v = [1 2 3] % 行ベクトル v = 1 2 3 列ベクトル (column vector) $$ v = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$ \u0026gt;\u0026gt; v = [1; 2; 3] % 列ベクトル v = 1 2 3 範囲指定でベクトルを生成する コロン : を使用して、数値の範囲を指定してベクトルを生成することができます。 1 から 5 までの連番 \u0026gt;\u0026gt; v = 1:5 v = 1 2 3 4 5 1 から 10 までの範囲で、ステップ数 2 の連番 \u0026gt;\u0026gt; v = 1:2:10 v = 1 3 5 7 9"},{url:"/p/a7z6ojh/",title:"Octave で転置行列を作成する",date:"2017-03-23T00:00:00Z",body:"Octave で転置行列を作成する 転置行列を求める $$ {A} = \\left[ \\begin{array}{ccc} 1 \u0026amp; 2 \u0026amp; 3 \\\\ 4 \u0026amp; 5 \u0026amp; 6 \\end{array} \\right] $$ $$ {A}^{\\mathrm{T}} = \\left[ \\begin{array}{cc} 1 \u0026amp; 4 \\\\ 2 \u0026amp; 5 \\\\ 3 \u0026amp; 6 \\end{array} \\right] $$ 行列 A の転置行列 (transposed matrix) である \\(A^T\\) は、ダッシュ記号 (') を付加するだけで求められます。 \u0026gt;\u0026gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 \u0026gt;\u0026gt; A\u0026#39; ans = 1 4 2 5 3 6 転置行列と共役転置行列 A' で得られる行列は、正確には 共役転置行列 であり、転置行列の各要素の複素共役をとったものになっています。 各要素の値が実数の場合は違いはありませんが、複素数が含まれていると結果が変わってきます。 \u0026gt;\u0026gt; A = [1+2i 3+4i; 5-6i 7-8i] A = 1 + 2i 3 + 4i 5 - 6i 7 - 8i \u0026gt;\u0026gt; A\u0026#39; ans = 1 - 2i 5 + 6i 3 - 4i 7 + 8i 単純な転置行列を求めたい場合は、A' ではなく、A.' とします。 \u0026gt;\u0026gt; A.\u0026#39; ans = 1 + 2i 5 - 6i 3 + 4i 7 - 8i"},{url:"/p/htducs9/",title:"NumPy 配列 (ndarray) の作成方法まとめ",date:"2017-02-27T00:00:00Z",body:"NumPy 配列 (ndarray) の作成方法まとめ NumPy 配列 (ndarray) は、np.array() 関数を使って次のように生成するのが基本ですが、 import numpy as np # 1 次元の場合 a = np.array([1, 2, 3]) print(a[0]) #=\u0026gt; 1 # 2 次元の場合 a = np.array([[1, 2, 3], [4, 5, 6]]) print(a[0]) #=\u0026gt; [1 2 3] print(a[0][2]) #=\u0026gt; 3 NumPy は ndarray インスタンス生成用の様々なユーティリティ関数を提供しています。 全要素が 0 の NumPy 配列 (np.zeros) 零ベクトル np.zeros() 関数で、すべての要素が 0 の配列データ（ベクトル）を作成できます。 データタイプ (dtype) はデフォルトで float64 になりますが、dtype パラメーターで変更することが可能です。 \u0026gt;\u0026gt;\u0026gt; np.zeros(3) array([0., 0., 0.]) \u0026gt;\u0026gt;\u0026gt; np.zeros(3, dtype=\u0026#34;int64\u0026#34;) array([0, 0, 0], dtype=int64) 零行列 すべての要素（成分）が 0 である行列のことを零行列（ゼロ行列; zero matrix）と呼びます。 NumPy で零行列を生成するには、np.zeros 関数の第 1 引数 (shape) にタプル形式で (行サイズ, 列サイズ) を渡します。 \u0026gt;\u0026gt;\u0026gt; np.zeros((2, 3)) array([[ 0., 0., 0.], [ 0., 0., 0.]]) データタイプ (dtype) はデフォルトで float64 になりますが、次のように明示的に指定することが可能です。 a = np.zeros((2, 3), dtype=\u0026#34;int32\u0026#34;) 全要素が 1 の NumPy 配列 (np.ones) 全ての要素が 1 である NumPy 配列を生成するには np.ones 関数を使用します。 第 1 引数 (shape) で要素数を指定します。 多次元配列の場合は、タプル形式で各次元の要素数を指定します。 データタイプ (dtype) はデフォルトで float64 になります。 \u0026gt;\u0026gt;\u0026gt; np.ones(3) array([1., 1., 1.]) \u0026gt;\u0026gt;\u0026gt; np.ones((2, 3)) array([[ 1., 1., 1.], [ 1., 1., 1.]]) \u0026gt;\u0026gt;\u0026gt; np.ones((2, 3), dtype=\u0026#34;int32\u0026#34;) array([[1, 1, 1], [1, 1, 1]]) 単位行列 (np.identity) 単位行列（identity matrix）は、対角線上の要素（対角成分）が全て 1 で、それ以外の要素が全て 0 の正方行列です。 単位行列は、行列の乗法の単位元としての役割を果たします。 np.identity 関数で単位行列の ndarray インスタンスを生成することができます。 行と列のサイズは等しいため、サイズ指定のためのパラメーターは 1 つだけであることに注意してください。 \u0026gt;\u0026gt;\u0026gt; np.identity(3) array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) np.identity() 関数の戻り値は、必ず 2 次元の NumPy 配列になります（shape としては (1, 1) や (2, 2) や (3, 3) のようになります）。 連番からなる NumPy 配列 (np.arange) np.arange 関数を使用して、連番からなる NumPy 配列 (ndarray) を生成することができます。 開始番号 (start) や、1 ステップあたりの変化数 (step) を指定することもできます。 連番の ndarray を生成する \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; np.arange(5) array([0, 1, 2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; np.arange(3, 10) array([3, 4, 5, 6, 7, 8, 9]) \u0026gt;\u0026gt;\u0026gt; np.arange(2, 10, 2) array([2, 4, 6, 8]) \u0026gt;\u0026gt;\u0026gt; np.arange(10, 0, -1) array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) \u0026gt;\u0026gt;\u0026gt; np.arange(1, step=0.1) array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]) データタイプ (dtype) は基本的に int32 になりますが、ステップ数を小数点数で刻むと float64 になります。 関数名は arrange ではなく、arange であることに注意してください（array range の略です）。 np.arange は 1 次元配列を作成しますが、reshape メソッドを使えば多次元配列の形に変換できます。 \u0026gt;\u0026gt;\u0026gt; np.arange(9).reshape((3, 3)) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) ランダムな NumPy 配列 (np.random) np.random.rand() は 0 以上 1 未満のランダム float 値を生成する関数ですが、引数で各次元のサイズを指定することで、ランダムな値を持つ NumPy 配列を生成できます。 似た関数に np.random.randn() がありますが、こちらは標準正規分布に従ったランダム値を生成します。 \u0026gt;\u0026gt;\u0026gt; np.random.rand() # スカラー値 0.5926286463704019 \u0026gt;\u0026gt;\u0026gt; np.random.rand(3) # 1 次元 NumPy 配列 array([0.88829851, 0.22662687, 0.30925015]) \u0026gt;\u0026gt;\u0026gt; np.random.rand(2, 3) # 2 次元 NumPy 配列　array([[0.05874757, 0.31040971, 0.09503772], [0.99130323, 0.34005123, 0.57641306]]) 整数のランダム値が欲しいときは、np.random.randint() を使います。 size パラメーターを指定することで、任意の次元の NumPy 配列を生成できます。 \u0026gt;\u0026gt;\u0026gt; np.random.randint(10) # スカラー値（0 以上 10 未満の整数） 7 \u0026gt;\u0026gt;\u0026gt; np.random.randint(-3, 3) # スカラー値（-3 以上 3 未満の整数） -3 \u0026gt;\u0026gt;\u0026gt; np.random.randint(5, size=3) # 1 次元 NumPy 配列（0 以上 5 未満の整数） array([2, 0, 4]) \u0026gt;\u0026gt;\u0026gt; np.random.randint(5, size=(2, 3)) # 2 次元 NumPy 配列（0 以上 5 未満の整数） array([[0, 4, 3], [2, 4, 4]]) ランダム関数のシード値は、np.random.seed() で設定することができます。 同じシード値を設定すると、生成されるランダム値を再現することができます。 \u0026gt;\u0026gt;\u0026gt; np.random.seed(252525) # シード値を設定 \u0026gt;\u0026gt;\u0026gt; np.random.randint(100) 43 \u0026gt;\u0026gt;\u0026gt; np.random.randint(100) 75 \u0026gt;\u0026gt;\u0026gt; np.random.seed(252525) # 同じシード値を再設定 \u0026gt;\u0026gt;\u0026gt; np.random.randint(100) 43 \u0026gt;\u0026gt;\u0026gt; np.random.randint(100) 75"},{url:"/p/wbudtbr/",title:"Python の Pandas でラベル付き 1 次元データを扱う (pandas.Series)",date:"2017-01-23T00:00:00Z",body:"Python の Pandas でラベル付き 1 次元データを扱う (pandas.Series) Python の Pandas ライブラリは、データ操作および分析を容易にするためのデータ型および関数群を提供します。 Pandas ライブラリの内部では、NumPy ライブラリの多次元配列 (ndarray) や数値演算関数が使用されています。 先に NumPy に慣れておくと理解が早くなります。 参考: NumPy 配列 (ndarray) の基本 pandas.Series はラベル付き 1 次元配列 pandas.Series は、1 次元の NumPy 配列 (ndarray) に、インデックス用のラベルを付加したデータ型です。 通常の配列データは 0、1、2 というインデックスで各要素にアクセスしますが、pandas.Series では各インデックスに意味のあるラベルを付けることができます。 pandas.Series を生成する pandas.Series コンストラクタで、次のように初期データだけを指定すると、通常の配列と同様にインデックスとして 0、1、2 が割り振られます。 sample.py import pandas as pd s = pd.Series([100, 200, 300]) print(s) 実行結果 0 100 1 200 2 300 dtype: int64 各インデックスにラベルを設定する pandas.Series コンストラクタで第 2 引数 (index) を追加指定すると、明示的に各インデックスのラベルを設定することができます。 import pandas as pd s = pd.Series([100, 200, 300], index=[\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;]) # s = pd.Series([100, 200, 300], [\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;]) # 同上 print(s) 実行結果 aaa 100 bbb 200 ccc 300 dtype: int64 次のように、辞書オブジェクトから同様の pandas.Series を生成することもできます。 data = {\u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;ccc\u0026#34;: 300} s = pd.Series(data) Matplotlib による描画 Pandas は Matplotlib と統合されており、簡単にチャート描画を行うことができます。 図: Matplotlib による Pandas の Series データのプロット import matplotlib.pyplot as plt import pandas as pd s = pd.Series([100, 200, 300], index=[\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;]) # 出力設定 fig = plt.figure(facecolor=\u0026#34;white\u0026#34;, layout=\u0026#34;tight\u0026#34;, dpi=72, figsize=(6, 3)) # Pandas の Series データを棒グラフとしてプロット s.plot.bar() # 必要に応じて画面に表示 plt.show() # 画像として保存 fig.savefig(\u0026#34;img-001.svg\u0026#34;)"},{url:"/p/watbs9p/",title:"Python の Pandas でラベル付き 2 次元データを扱う (pandas.DataFrame)",date:"2017-01-23T00:00:00Z",body:"Python の Pandas でラベル付き 2 次元データを扱う (pandas.DataFrame) pandas.DataFrame はラベル付き 2 次元配列 Python の Pandas ライブラリが提供する pandas.DataFrame 型は、テーブル形状のデータを表す 2 次元データ型で、Pandas によるデータ解析の要となるデータ形式です。 内部では NumPy ライブラリの ndarray が利用されていますが、pandas.DataFrame を使うと、X 軸（列）、Y 軸（行）の各インデックスに任意のラベルを付けることができます （1 次元データを表現する pandas.Series 型も用意されています）。 NumPy の ndarray は同じデータタイプの値しか持てませんが、pandas.DataFrame であれば、列ごとに異なるデータタイプの値を保持することができます。 pandas.DataFrame を生成する pandas.DataFrame コンストラクタで、次のように初期値となる 2 次元データだけを渡すと、行と列のラベルとして、0、1、2 という連番が割り振られます。 pandas.DataFrame オブジェクトを print 関数に渡すと、見やすい形で出力してくれます。 sample.py import pandas as pd data = [[100, 200, 300], [400, 500, 600], [700, 800, 900]] df = pd.DataFrame(data) print(df) 実行結果 0 1 2 0 100 200 300 1 400 500 600 2 700 800 900 各インデックスにラベルを設定する pandas.DataFrame コンストラクタの columns パラメータを使うと、X 軸（列）の各インデックスのラベルを設定することができます。 同様に、index パラメータを使うと、Y 軸（行）の各インデックスのラベルを設定することができます。 import pandas as pd data = [[100, 200, 300], [400, 500, 600], [700, 800, 900]] columns = (\u0026#39;x1\u0026#39;, \u0026#39;x2\u0026#39;, \u0026#39;x3\u0026#39;) index = (\u0026#39;y1\u0026#39;, \u0026#39;y2\u0026#39;, \u0026#39;y3\u0026#39;) df = pd.DataFrame(data, columns=columns, index=index) print(df) 実行結果 x1 x2 x3 y1 100 200 300 y2 400 500 600 y3 700 800 900 ディクショナリから DataFrame を生成する Python のディクショナリオブジェクトを pandas.DataFrame に変換することができます。 pandas.DataFrame コンストラクタにディクショナリを渡すと、そのキーがカラム名として使用されます。 ディクショナリから DataFrame を生成する import numpy as np import pandas as pd data = { \u0026#39;A\u0026#39;: 1.0, \u0026#39;B\u0026#39;: [100, 200, 300], \u0026#39;C\u0026#39;: np.array([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]), \u0026#39;D\u0026#39;: pd.Series([0.1, 0.2, 0.3]), \u0026#39;E\u0026#39;: pd.Categorical([\u0026#39;apple\u0026#39;, \u0026#39;lemon\u0026#39;, \u0026#39;peach\u0026#39;]), \u0026#39;F\u0026#39;: pd.date_range(\u0026#39;2017-01-01\u0026#39;, periods=3) } df = pd.DataFrame(data) print(df) 実行結果 A B C D E F 0 1.0 100 a 0.1 apple 2017-01-01 1 1.0 200 b 0.2 lemon 2017-01-02 2 1.0 300 c 0.3 peach 2017-01-03 この例では、キーがたまたまディクショナリの初期化時と同じ順番で並んでいますが、ディクショナリの要素には順序性はないので、このような順番でカラムが並ぶことは保証されていないことに注意してください（カラム名とそれに関連付けられた Series データがあるだけです）。 ランダム値や連番からなる DataFrame を生成する NumPy 配列から pandas.DataFrame を生成することもできます。 NumPy ライブラリには、いろいろな形の NumPy 配列を生成するユーティリティ関数が用意されているので、これを利用してテスト用の pandas.DataFrame を簡単に生成できます。 ランダムな DataFrame import numpy as np import pandas as pd np.random.seed(2525) # 乱数シードを設定 arr = np.random.randint(0, 1000, size=(2, 3)) df = pd.DataFrame(arr, columns=(\u0026#34;x1\u0026#34;, \u0026#34;x2\u0026#34;, \u0026#34;x3\u0026#34;)) print(df) 実行結果 x1 x2 x3 0 636 952 324 1 21 289 966 ランダムな値を使うときは、上記のようにシード値を設定しておくことで、同じデータを再現できるようになります。 連番の DataFrame arr = np.arange(10).reshape((2, 5)) df = pd.DataFrame(arr, columns=(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;)) print(df) 実行結果 A B C D E 0 0 1 2 3 4 1 5 6 7 8 9 参考: NumPy 配列 (ndarray) の作成方法まとめ"},{url:"/p/8j4k3iy/",title:"Python の pandas.DataFrame から部分データを抽出する",date:"2017-01-23T00:00:00Z",body:"Python の pandas.DataFrame から部分データを抽出する Python の pandas ライブラリが提供する pandas.DataFrame はテーブル形式データを保持していますが、ここから部分的なデータを抽出する方法がたくさん用意されています。 サンプルデータ 最初に、後述の説明のためにサンプルデータを用意しておきます。 次のコードでは、10 行 3 列のデータを持つ pandas.DataFrame を生成しています。 import numpy as np import pandas as pd data = np.random.randn(10, 3) # 10x3 の NumPy 配列を生成（標準正規分布の乱数） indices = pd.date_range(\u0026#34;2010-01-01\u0026#34;, periods=10) # 日付の連番からなるインデックスを生成 columns = (\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) # カラム名 my_dataframe = pd.DataFrame(data, index=indices, columns=columns) print(my_dataframe) 実行結果 A B C 2010-01-01 -1.083348 0.780602 -1.249351 2010-01-02 -0.421893 1.417954 2.196932 2010-01-03 -1.129684 -0.751984 0.920735 2010-01-04 -0.668949 -2.082924 -0.018011 2010-01-05 1.542745 -1.014717 -0.587786 2010-01-06 0.535100 -0.680070 0.630020 2010-01-07 0.563422 0.856276 1.343315 2010-01-08 1.586091 -1.304232 -1.084707 2010-01-09 -1.561553 -1.884124 0.849059 2010-01-10 -0.817422 -1.244994 0.143166 行方向（インデックス）で絞り込んで抽出する 先頭／末尾の数データのみ抽出する (DataFrame#head, DataFrame#tail) DataFrame オブジェクトの head メソッドや tail メソッドを使用すると、巨大なデータフレームから、先頭あるいは末尾の数データのみを抽出することができます。 最新のデータを取得したいときや、データ構成を簡単に把握したいときに便利です。 戻り値の型は DataFrame です。 print(my_dataframe.head(3)) # 先頭の 3 つのデータのみ抽出 =\u0026gt; DataFrame print(my_dataframe.tail(3)) # 末尾の 3 つのデータのみ抽出 =\u0026gt; DataFrame 図: pandas.DataFrame の head 関数と tail 関数 実行結果 A B C 2010-01-01 -1.083348 0.780602 -1.249351 2010-01-02 -0.421893 1.417954 2.196932 2010-01-03 -1.129684 -0.751984 0.920735 A B C 2010-01-08 1.586091 -1.304232 -1.084707 2010-01-09 -1.561553 -1.884124 0.849059 2010-01-10 -0.817422 -1.244994 0.143166 head や tail のパラメータを省略すると、デフォルトで 5 つ のデータが抽出されます。 インデックスの範囲指定でデータを抽出する DataFrame を参照するときに、Python のスライス構文を使って、インデックス番号やインデックス名で範囲を指定すると、その範囲の部分データを抽出することができます。 単一のインデックス指定ではなく、どのケースも範囲指定になっていることに注意してください。 戻り値は DataFrame オブジェクトです。 print(my_dataframe[0:3]) # 先頭の 3 つのデータを取得 print(my_dataframe[:3]) # 同上 print(my_dataframe[-2:]) # 末尾の 2 つのデータを取得 print(my_dataframe[\u0026#34;2010-01-05\u0026#34;:\u0026#34;2010-01-07\u0026#34;]) # インデックス名で範囲指定 図: DataFrame から複数の行を抽出 特定のインデックスのデータを抽出する DataFrame の loc メソッドを使用すると、特定のインデックスのデータのみを Series オブジェクトとして取得することができます（配列風に 1 つのラベル名だけを指定してアクセスすると、インデックス名ではなくカラム名を指定したことになってしまうので（列方向の抽出）、インデックス名を指定するための loc が用意されています）。 print(my_dataframe.loc[\u0026#34;2010-01-01\u0026#34;]) # 特定インデックスのデータを取得 =\u0026gt; Series print(my_dataframe.iloc[0]) # 番号指定の場合は iloc を使う =\u0026gt; Series 図: DataFrame から 1 つの行を抽出 実行結果 A -1.083348 B 0.780602 C -1.249351 Name: 2010-01-01 00:00:00, dtype: float64 DataFrame ではカラム名だった A, B, C が、戻り値の Series データではインデックス名になっていることに注意してください。 列方向（カラム）で絞り込んで抽出する 特定のカラムのデータを抽出する DataFrame オブジェクトの [] 演算子でカラム名を 1 つだけ指定すると、そのカラムのすべてのデータが pandas.Series データとして抽出されます。 戻り値は、指定した列のみデータを含む 1 次元データなので pandas.Series 型になります。 ☝️ ワンポイント [] 演算子で単一の値を指定すると、インデックス（行）ではなく、カラム（列）の指定だとみなされることに注意してください。 逆に、インデックスを 1 つだけ指定して特定の行を抽出するには、loc[\u0026quot;インデックス名\u0026quot;] や iloc[インデックス番号] を使用する必要があります。 カラム名 C のデータを Series として取得 print(my_dataframe[\u0026#34;C\u0026#34;]) # =\u0026gt; pandas.Series 図: DataFrame から 1 つの列を抽出 実行結果 2010-01-01 -1.249351 2010-01-02 2.196932 2010-01-03 0.920735 2010-01-04 -0.018011 2010-01-05 -0.587786 2010-01-06 0.630020 2010-01-07 1.343315 2010-01-08 -1.084707 2010-01-09 0.849059 2010-01-10 0.143166 Freq: D, Name: C, dtype: float64 特定のカラムのデータを Series ではなく、DataFrame として抽出するには次のようにします。 カラム名 C のデータを DataFrame として取得 print(my_dataframe[(\u0026#34;C\u0026#34;)]) # =\u0026gt; pandas.DataFrame この記法では、複数のカラムを指定することもできます。 カラム名 A と C のデータを DataFrame として取得 print(my_dataframe[(\u0026#34;A\u0026#34;, \u0026#34;C\u0026#34;)]) # カラム名 A と C の全データを取得 図: DataFrame から複数の列を抽出 インデックスラベルとカラムを両方指定して取得 (loc, iloc) DataFrame の loc[] で、インデックスとカラムの範囲を組み合わせて指定することができます。 戻り値の型はデータの抽出範囲によって変化する ことに注意してください。 取得結果が 1 次元データとなる場合は Series オブジェクト、2 次元データとなる場合は DataFrame オブジェクトとなります。 # 単一インデックス ＋ 単一カラム指定 =\u0026gt; numpy.float64 print(my_dataframe.loc[\u0026#39;2010-01-01\u0026#39;, \u0026#39;A\u0026#39;]) # 単一インデックス ＋ 複数カラム指定 =\u0026gt; pandas.Series print(my_dataframe.loc[\u0026#39;2010-01-01\u0026#39;, [\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;]]) # インデックス範囲指定 ＋ 単一カラム指定 =\u0026gt; pandas.Series print(my_dataframe.loc[\u0026#39;2010-01-01\u0026#39;:\u0026#39;2010-01-03\u0026#39;, \u0026#39;A\u0026#39;]) # 全インデックス指定 ＋ 複数カラム指定 =\u0026gt; pandas.DataFrame print(my_dataframe.loc[:, [\u0026#39;A\u0026#39;, \u0026#39;C\u0026#39;]]) ラベルではなく、インデックス番号で指定する場合は、loc[] の代わりに iloc[] を使用します。 # 先頭のデータ =\u0026gt; pandas.Series print(my_dataframe.iloc[0]) # 先頭から 3 つのデータ =\u0026gt; pandas.DataFrame print(my_dataframe.iloc[0:3]) # 先頭のデータの 2 つ目のカラムの値 =\u0026gt; numpy.float64 print(my_dataframe.iloc[0, 1]) # 全データの 3 つ目までのカラムのデータ =\u0026gt; pandas.DataFrame print(my_dataframe.iloc[:, 0:3])"},{url:"/p/jwfxfvd/",title:"Python の NumPy 配列 (ndarray) の基本",date:"2017-01-01T00:00:00Z",body:"Python の NumPy 配列 (ndarray) の基本 NumPy 配列 (ndarray) とは Python の NumPy ライブラリ (numpy) は、多次元配列を高速かつ便利に扱うための ndarray クラスを提供しています（n-dimensional array の略）。 ndarray は Python 標準のリストと比べて次のような違いがあります。 内部実装に C 言語などの低レベル言語が利用されており、処理が高速でメモリ効率がよい C 言語の配列と同様、単一のデータタイプ で 固定サイズ の配列である（サイズ変更は新しい ndarray の生成になる） 全要素に対するブロードキャスト演算や、行列（ベクトル）演算など、便利な演算方法 が提供されている NumPy はこのような特徴を持つため、次のように様々なライブラリで利用されています。 データ解析ライブラリ: Pandas 画像処理ライブラリ: OpenCV 科学計算ライブラリ: SciPy 機械学習ライブラリ: TensorFlow、scikit-learn プロットライブラリ: Matplotlib つまり、ほとんどの数学的、科学的な処理を行うライブラリは NumPy を利用していると考えられます。 NumPy 配列を生成する（numpy.array 関数） ndarray インスタンスは、numpy.array() 関数で生成することができます。 実際には、numpy ライブラリは np という別名でインポートするのが慣例となっているので、コード中では numpy.array() ではなく np.array() と記述されることが多いです。 1 次元の ndarray 次の例では、1 次元の ndarray インスタンスを生成しています。 1 次元の ndarray を生成 \u0026gt;\u0026gt;\u0026gt; import numpy as np \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; a array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; type(a) \u0026lt;class \u0026#39;numpy.ndarray\u0026#39;\u0026gt; 多次元の ndarray 多次元の ndarray インスタンスも同様に生成できます。 2 次元（2 行 3 列）ndarray を生成 \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]]) \u0026gt;\u0026gt;\u0026gt; a array([[1, 2, 3], [4, 5, 6]]) NumPy 配列の形状（各次元のサイズ）は、shape 属性を参照することで調べることができます。 ndarray の形状を調べる \u0026gt;\u0026gt;\u0026gt; a.shape (2, 3) # 2 行 3 列を表すタプルが返される 行列として扱うには、各行のサイズ（列数）は揃えておく必要があります。 次のように、各行のサイズが異なるとエラーになります。 a = np.array([[1, 2, 3], [4, 5]]) # ValueError! NumPy 配列は 1 つのデータタイプ (dtype) の要素のみを持つ 効率化のため、NumPy 配列に格納される要素の型（データタイプ）は統一されます。 データタイプは ndarray インスタンスの初期化時の要素の値によって自動的に設定されます。 ndarray インスタンスが保持している要素のデータタイプを調べるには、dtype 属性を参照します。 ndarray のデータタイプを調べる \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]]) # 整数値のみで初期化 \u0026gt;\u0026gt;\u0026gt; a.dtype dtype(\u0026#39;int64\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [1.5, 2.5, 3.5]]) # 浮動小数点数を含む値で初期化 \u0026gt;\u0026gt;\u0026gt; a.dtype dtype(\u0026#39;float64\u0026#39;) データタイプは、NumPy 配列の生成時に dtype オプションで明示的に指定することができます。 次の例では、整数値のみで NumPy 配列を初期化していますが、浮動小数点数の要素として扱うように指定しています。 ndarray のデータタイプを指定する \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2, 3], [4, 5, 6]], dtype=\u0026#39;float64\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a.dtype dtype(\u0026#39;float64\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a array([[ 1., 2., 3.], [ 4., 5., 6.]]) NumPy 配列のインデックスアクセスとスライス NumPy 配列 (ndarray) の各要素は、リストと同様にインデックスでアクセスできます。 a = np.array([[1, 2, 3], [4, 5, 6]]) print(a[0][2]) # 3 a[0][2] = 100 # 値の変更 print(a[0]) # [1 100 3] print(len(a)) # 2 print(len(a[0])) # 3 ndarray はリストよりも柔軟なスライスを行うことができます。 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 2 行目だけを取得 print(a[1]) # [4, 5, 6] print(a[1, :]) # 同上 # 2 行目以降を取得 print(a[1:]) # [[4, 5, 6], [7, 8, 9]] print(a[1:, :]) # 同上 # すべての行の 2 列目までを取得 print(a[:, :2]) # [[1, 2], [4, 5], [7, 8]] print(a[:, :-1]) # 同上 # すべての行の列を 1 つ飛びで取得 print(a[:, ::2]) # [[1, 3], [4, 6], [7, 9]] ndarray のスライスは、元の ndarray のデータの参照であることに注意してください。 スライス経由での値の変更は、スライス元の ndarray の変更を意味します。 一方で、Python 標準のリストのスライスは、Shallow Copy（一階層目だけコピー）です。 # NumPy 配列のスライスは元のデータを参照する np_arr = np.array([1, 2, 3]) np_slice = np_arr[:] np_slice[0] = 100 print(np_arr) # [100, 2, 3] # リストのスライスは Shallow Copy（一階層目はコピーによって作られた新しいデータ） py_arr = [1, 2, 3] py_slice = py_arr[:] py_slice[0] = 100 print(py_arr) # [1, 2, 3] NumPy 配列に対する演算（ブロードキャスト） NumPy 配列 (ndarray) やそのスライスに対してスカラー値（単一の値）の四則演算や代入操作を行うと、全ての要素に対してその演算 が実行されます（この仕組みを ブロードキャスト と呼びます）。 これは非常に強力な仕組みで、この仕組みをうまく活用することで、多くの計算をループを記述せずに実装することができます。 ndarray とスカラー値のブロードキャスト演算 a = np.array([[1, 2, 3], [4, 5, 6]]) a[0] = 10 # 1 行目の要素をすべて 10 にする print(a) # [[10, 10, 10], [4, 5, 6]] a -= 1 # すべての要素をマイナス 1 する print(a) # [[9, 9, 9], [3, 4, 5]] a[1] **= 2 # 2 行目の要素をすべて 2 乗する print(a) # [[9, 9, 9], [9, 16, 25]] a[:, 1] = 0 # 全ての行の 2 列目の要素を 0 にする print(a) # [[9, 0, 9], [9, 0, 25]] NumPy 配列 (ndarray) 同士の四則演算も、それぞれ対応する要素に対して演算が行われます。 ただし、形状の異なる NumPy 配列同士で演算しようとすると ValueError が発生します。 行列同士の四則演算 a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([[5, 5, 5], [2, 2, 2]]) c = a + b # [[6, 7, 8], [6, 7, 8]] c = a - b # [[-4, -3, -2], [2, 3, 4]] c = a * b # [[5, 10, 15], [8, 10, 12]] c = a / b # [[0.2, 0.4, 0.6], [2.0, 2.5, 3.0]] c = a // b # [[0, 0, 0], [2, 2, 3]] c = a % b # [[1, 2, 3], [0, 1, 0]] c = a ** b # [[1, 32, 243], [16, 25, 36]] 特に、除算 (a / b) の結果は、float64 型のデータタイプになることに注意してください。 多次元の NumPy 配列と、1 次元の NumPy 配列の演算でもブロードキャストの仕組みが働きます。 列のサイズは等しくないといけません。 行列とベクトルの四則演算 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) b = np.array([1, 2, 3]) c = a + b # [[2, 4, 6], [5, 7, 9], [8, 10, 12]] c = a - b # [[0, 0, 0], [3, 3, 3], [6, 6, 6]] c = a * b # [[1, 4, 9], [4, 10, 18], [7, 16, 27]] c = a / b # [[1.0, 1.0, 1.0], [4.0, 2.5, 2.0], [7.0, 4.0, 3.0]] c = a // b # [[1, 1, 1], [4, 2, 2], [7, 4, 3]] c = a % b # [[0, 0, 0], [0, 1, 0], [0, 0, 0]] c = a ** b # [[1, 4, 27], [4, 25, 216], [7, 64, 729]] 行列演算（内積、外積、転置） NumPy 配列 (ndarray) には、行列の内積、外積、転置などの演算を行うためのメソッドが用意されています。 内積 (dot) a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([1, 2, 3]) result = a.dot(b) # array([14, 32]) 外積 (cross) a = np.array([1, 2, 3]) b = np.array([10, 10, 10]) result = np.cross(a, b) # array([-10, 20, -10]) 転置 (transpose) a = np.array([[1, 2, 3], [4, 5, 6]]) result = a.transpose() # array([[1, 4], [2, 5], [3, 6]]) ちなみに、各メソッドの引数としては、ndarray インスタンスではなく、リストやタプルも渡せるようになっていますが、戻り値は結局 ndarray になります。 result = np.cross([1, 2, 3], (10, 10, 10)) # array([-10, 20, -10])"},{url:"/p/n4n5m3i/",title:"Python でモジュールやパッケージを作成する",date:"2016-12-16T00:00:00Z",body:"Python でモジュールやパッケージを作成する モジュールとパッケージ Python では、再利用可能な関数などを集めたスクリプトファイルのことをモジュールと呼びます。 さらに、同系列のモジュールを集めたものをパッケージと呼びます。 モジュール \u0026hellip; 再利用可能なスクリプト (.py) パッケージ \u0026hellip; 上記のモジュールをディレクトリに集めたもの モジュールやパッケージを作成しておくと、他のファイルから import して使用することができます。 ☝️ Node.js も同じ名前 モジュールやパッケージといった名称は、言語によって使われ方が様々ですが、Node.js に関してはほぼ同じ意味で使われています。 Node.js では、.js ファイルのことをモジュール、それらをまとめたものをパッケージと読んでいます。 モジュールを作成する 下記は、簡単な関数（add と sub）を提供する mymath モジュールを定義する例です。 といっても、単純に関数を定義するだけです。 モジュールは、モジュール名.py というファイル名で作成する必要があります。 mymath.py（モジュールの実装例） def add(a, b): \u0026#34;\u0026#34;\u0026#34;Return the sum of a and b.\u0026#34;\u0026#34;\u0026#34; return a + b def sub(a, b): \u0026#34;\u0026#34;\u0026#34;Subtract b from a.\u0026#34;\u0026#34;\u0026#34; return a - b 上記の mymath.py で定義されている関数を使用するには、Python 標準のモジュールと同様に、import mymath という形でインポートします。 main.py（モジュールの使用例） import mymath if __name__ == \u0026#39;__main__\u0026#39;: print(mymath.add(1, 2)) print(mymath.sub(1, 2)) パッケージを作成する 複数のモジュール (*.py) をディレクトリにまとめたものを パッケージ と呼びます。 下記の例では、mylib ディレクトリに mymath.py を格納することで、mylib パッケージを作成しています。 ちなみに、パッケージ名（ディレクトリ名）には、アンダースコア (_) は含めるべきではない とされています。 このあたりの命名規則に関しては Python のコーディングスタイル を参照してください。 +-- main.py +-- mylib/ +-- mymath.py パッケージ内のモジュールの実装方法は、通常のモジュールの場合と変わりません。 mylib/mymath.py def add(a, b): return a + b def sub(a, b): return a - b mylib パッケージ内の mymath モジュールを使用するには、次のように mylib.mymath という形でインポートします。 main.py import mylib.mymath if __name__ == \u0026#39;__main__\u0026#39;: print(mylib.mymath.add(1, 2)) print(mylib.mymath.sub(1, 2)) このようにパッケージ名とモジュール名を繋げた名前でインポートした場合、関数を呼び出すときもその名前をプレフィックスに付けて呼び出す必要があります（例: mylib.mymath.add(1, 2)）。 Python の部分インポート (partial import) の構文 (from mylib import mymath) を使うと、パッケージ名を省略して呼び出せるようになります。 from mylib import mymath if __name__ == \u0026#39;__main__\u0026#39;: print(mymath.add(1, 2)) print(mymath.sub(1, 2)) モジュール内の関数などを呼び出すときは、import の後ろに記述したシンボル名をプレフィックスとして付けると覚えておけば OK です（例えば上記の場合は、import mymath としているので、add 関数の呼び出し時は mymath プレフィックスを付けて mymath.add とします）。 モジュール内の特定メンバーだけをインポートする 前述の例では、モジュール単位でインポートしましたが、モジュール内の特定のメンバー（関数、クラス、定数など）を指定してインポートすることもできます。 次の例では、mymath モジュール内の、add 関数のみをインポートしています。 関数の呼び出し時に、モジュール名のプレフィックスを付ける必要はありません。 メンバー単位のインポート from mymath import add if __name__ == \u0026#39;__main__\u0026#39;: print(add(1, 2)) パッケージ内のモジュール内の関数をインポートする場合も、ほぼ同じ指定方法でいけます。 from mylib.mymath import add if __name__ == \u0026#39;__main__\u0026#39;: print(add(1, 2)) 別名を付ける (as) インポートするモジュールや関数の名前が長すぎて扱いにくい場合や、名前の衝突が起きてしまう場合は、as キーワードを使って別名を付けることができます。 long_long_module.py をインポートするとき import long_long_module as llm llm.hello() mypackage/long_long_module.py をインポートするとき from mypackage import long_long_module as llm llm.hello() パッケージ内のモジュールから別のモジュールをインポートするときの注意 +-- main.py +-- libs/ +-- mod1.py +-- mod2.py このようなディレクトリ構成で libs パッケージを作っていて、mod1.py から mod2.py をインポートしたいときは、次のように from . を付けて、相対パスインポート の形で記述する必要があります（逆に、ドット (.) を使わないインポートを絶対パスインポートと呼びます）。 libs/mod1.py（パッケージ内モジュールからのインポート） from . import mod2 def hello(): mod2.hello() libs/mod2.py def hello(): print(\u0026#39;hello\u0026#39;) 上記の from . import mod2 となっているところを、単純に import mod2 と書いてしまうと、main.py から次のように mod1 経由で読み込もうとしたときに ModuleNotFoundError: No module named 'mod2' エラーになってしまいます。 main.py from libs import mod1 mod1.hello() ☝️ なぜ相対パスで import しないといけないのか？ パッケージ内モジュールからの絶対パスインポートが失敗する原因は、Python の検索パスの仕組み (sys.path) にあります。 python コマンドで何らかのスクリプト (.py) を起動すると、そのファイルが存在するディレクトリがモジュールの検索パスに追加されます。 上記の例で言うと、main.py と同じディレクトリにあるモジュールであれば絶対パスでインポートできるようになります。 一方で、libs/mod1.py が処理されているときも、libs ディレクトリは検索パスに含まれていないため、import mod2 という絶対パスインポートはエラーになってしまいます（main.py と同じディレクトリの mod2.py を探そうとしてしまう）。 もちろん、main.py からの絶対パスで from libs import mod2 と記述することは可能ですが、それよりは相対パスで from . import mod2 と記述した方が分かりやすいでしょう。 別の階層のモジュールをインポートする 同じパッケージ階層のモジュールをインポートするときは、相対パスで from . import モジュール名 としましたが、1 つ上の階層にあるモジュールをインポートしたいときは、ドットの数を 1 つ増やして from .. import モジュール名 とします。 2 つ上の階層のモジュールをインポートしたければ、さらにドットを増やして from ... import モジュール名 とします。 同じ階層のモジュール（内のメンバー）のインポートする場合 from . import mod from .mod import hello 1 つ上の階層のモジュール（内のメンバー）のインポートする場合 from .. import mod from ..mod import hello 2 つ上の階層のモジュール（内のメンバー）のインポートする場合 from ... import mod from ...mod import hello 例えば、下記のような 2 つのサブパッケージを含むパッケージ mylib があったとします。 +-- mylib/ +-- sub1/ | +-- mod1.py +-- sub2/ +-- mod2.py sub1/mod1.py の中から、sub2/mod2.py をインポートするには下記のように記述します。 sub1/mod1.py from ..sub2 import mod2 def hello(): mod2.hello() パッケージの初期化ファイル (__init.py__) Python 3.3 より前のバージョンでは、パッケージディレクトリに __init__.py というファイルを置かなければ、そのディレクトリをパッケージとして認識させることができませんでした（ImportError: No module named ... というエラーが発生する）。 Python 3.3 以降では単純にディレクトリ内に .py ファイルを放り込んでおけば、そのディレクトリをパッケージとして扱うことができるようになっています（詳細は PEP 420 \u0026ndash; Implicit Namespace Packages を参照）。 パッケージディレクトリに置かれた __init__.py は、そのパッケージ（あるいはその中のモジュール）をインポートしたときに実行されます。 例えば、__init__.py の中で各モジュールをインポートするように記述しておけば、パッケージを利用するときに個々のモジュールを指定してインポートする必要がなくなります（ただし、必要のないモジュールまでデフォルトでインポートしてしまうのは効率が悪いので、オススメはできません）。 ディレクトリ構成 +-- main.py +-- mylib/ （パッケージ） +-- __init__.py +-- mymod1.py （モジュール） +-- mymod2.py （モジュール） mylib/__init__.py from . import mymod1 from . import mymod2 main.py import mylib # これだけで mylib.mymod1 と mylib.mymod2 がインポートされる if __name__ == \u0026#39;__main__\u0026#39;: mylib.mymod1.foo() mylib.mymod2.bar() モジュールのドキュメンテーションコメントを記述する モジュールの先頭に \u0026quot;\u0026quot;\u0026quot;コメント\u0026quot;\u0026quot;\u0026quot; という形式のドキュメンテーションコメントを記述しておくと、そのモジュールのドキュメントして認識されます。 fibo.py \u0026#34;\u0026#34;\u0026#34;Fibonacci numbers module.\u0026#34;\u0026#34;\u0026#34; def fib(n): \u0026#34;\u0026#34;\u0026#34;Print fibonacci series up to n.\u0026#34;\u0026#34;\u0026#34; a, b = 0, 1 while b \u0026lt; n: print(b, end=\u0026#39; \u0026#39;) a, b = b, a+b このように記述したドキュメントは、pydoc コマンドや help 関数などで参照することができます。 $ pydoc fibo Help on module fibo: NAME fibo - Fibonacci numbers module. FUNCTIONS fib(n) Print fibonacci series up to n. FILE D:\\y\\sandbox\\python\\fibo.py パッケージ単位のドキュメントを記述したいときは、そのパッケージの __init__.py の先頭にドキュメンテーションコメントを記述します。 mylib/__init__.py \u0026#34;\u0026#34;\u0026#34;My first package.\u0026#34;\u0026#34;\u0026#34; pydoc コマンドでパッケージドキュメントを参照すると、そのパッケージに含まれているモジュールのリスト (PACKAGE CONTENTS) も表示してくれます。 $ pydoc mylib Help on package mylib: NAME mylib - My first package. PACKAGE CONTENTS mymod1 mymod2 パッケージ内の個々のモジュールのドキュメントを参照したい場合は、pydoc mylib.mymod1 のように、パッケージ名の後ろにドットで繋げてモジュールを指定します。"},{url:"/p/qs6iv8j/",title:"NumPy / pandas / Matplotlib の概要とインストール",date:"2016-12-13T00:00:00Z",body:"NumPy / pandas / Matplotlib の概要とインストール NumPy / pandas / Matplotlib とは NumPy、pandas、Matplotlib などのライブラリは組み合わせて使用することの多いライブラリで、それぞれ下記のような特徴を持っています。 NumPy - 数値計算ライブラリ (numpy.org) C で実装された高速な多次元配列である ndarray（通称 NumPy 配列）、及び関連メソッドを扱うことができます。 Python のみで行列を表現しようとすると、配列の配列（要素ごとに可変長）を作ることになりますが、NumPy 配列ではn x m の固定サイズ、単一タイプのデータとして扱うことで非常に高速な計算処理を行えるようになっています。 pandas \u0026ndash; 数値解析ライブラリ (pandas.pydata.org) R 言語のような数値解析を行うことができるライブラリです。 データファイルの読み込み、加工、集計、可視化までを総合的に行うことができます。 データのプロットには内部で Matplotlib を使用しており、pd.DataFrame.plot() がラッパーとして提供されています。 Matplotlib \u0026ndash; グラフ描画ライブラリ (matplotlib.org) 単独でグラフを描画するために使用できるライブラリですが、pandas による計算結果を描画するために内部で使用されています。 NumPy / pandas / Matplotlib のインストール Python 3.4 以降はパッケージ管理のための pip コマンドが標準で搭載されているので、これを使って NumPy と pandas と Matplotlib をインストールするのがお手軽です。 まずは、pip コマンド自体を最新にアップグレードします。 $ pip install --upgrade pip 引き続き、NumPy と Matplotlib のインストールを行います。 $ pip install numpy $ pip install pandas $ pip install matplotlib これで、import numpy、import pandas、import matplotlib といった感じでインポートできるようになります。 慣例になっている別名 各ライブラリを import するときは、下記のように略称 (plt, np, pd) を定義して使用するのが慣例ととなっています。 import matplotlib.pyplot as plt import numpy as np import pandas as pd トラブルシューティング: tkinter モジュールが見つからない import matplotlib.pyplot などを実行したときに、下記のように tkinter モジュールが足りないというエラーが出ることがあります。 ImportError: No module named \u0026#39;tkinter\u0026#39; tkinter は GUI ライブラリの Tk を Python から利用できるようにしたモジュールです。 Tk 自体はもはや時代遅れの GUI ライブラリですが、matplotlib ではまだ Tk を使用しているので、tkinter のインストールが必要です。 Linux の場合は、python3-tk パッケージを導入すれば、Python 内で tkinter モジュールをインポートできるようになります。 $ sudo apt-get install python3-tk Windows の場合は、Python のインストーラ を実行して、 \u0026ldquo;tcl/tk and IDLE\u0026rdquo; という項目にチェックをいれてインストールしてください。"},{url:"/p/6h2izfh/",title:"Windows で pydoc コマンドを使用できるようにする",date:"2016-12-08T00:00:00Z",body:"Windows で pydoc コマンドを使用できるようにする pydoc コマンドを使用すると、下記のように Python の API ドキュメントを手軽に参照できます。 $ pydoc list.sort Help on method_descriptor in list: list.sort = sort(...) L.sort(key=None, reverse=False) -\u0026gt; None -- stable sort *IN PLACE* Windows では Python をインストールしただけでは pydoc コマンドは使用できませんが、実装自体は Lib/pydoc.py というスクリプトとしてインストールされます。 下記のようなバッチファイルを python.exe と同じディレクトリに作成しておけば、Windows でも pydoc コマンドを使用できるようになります。 pydoc.cmd @python %~dp0\\Lib\\pydoc.py %* 実行例 C:\\\u0026gt; pydoc dict.update Help on method_descriptor in dict: dict.update = update(...) D.update([E, ]**F) -\u0026gt; None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]"},{url:"/p/gxajt4d/",title:"Python で ZIP/JAR ファイルの内容を読み込む (zipfile)",date:"2016-12-06T00:00:00Z",body:"Python で ZIP/JAR ファイルの内容を読み込む (zipfile) Python に標準搭載されている zipfile モジュール を使用すると、ZIP ファイルや JAR ファイルの読み書きを手軽に行うことができます。 ZIP ファイル内のファイル一覧を取得する 下記のサンプルでは、指定した ZIP ファイル内のファイルリストとその（展開後の）サイズを出力します。 zipfile.ZipFile コンストラクタで ZipFile オブジェクトを生成し、infolist メソッドで ZIP 内のファイル情報 (ZipInfo) を取得できます。 dump_zip.py import zipfile with zipfile.ZipFile(\u0026#34;sample.zip\u0026#34;, \u0026#34;r\u0026#34;) as zf: for info in zf.infolist(): if info.is_dir(): continue # ディレクトリ情報は出力せずにスキップ print(f\u0026#34;{info.filename} ({info.file_size} bytes)\u0026#34;) 実行結果 $ python dump_zip.py data/sample1.txt (4560 bytes) data/sample2.txt (2284 bytes) data/sample3.txt (5712 bytes) README.txt (1417 bytes) ファイル名でソートして出力したい場合は、下記のようにいったんリストにしてソートしてしまえば OK です。 with zipfile.ZipFile(\u0026#34;sample.zip\u0026#34;, \u0026#34;r\u0026#34;) as zf: arr = list(zf.infolist()) arr.sort(key=lambda x: x.filename) for info in arr: print(f\u0026#34;{info.filename} ({info.file_size} bytes)\u0026#34;) ZIP ファイル内のファイルを読み込む ZIP ファイル内の個々のファイルの内容を読み込むには、ZipFile#read メソッド を使用します。 このメソッドは、ファイルの内容をバイトデータ (bytes) として返します。 バイトデータをテキストデータに変換するには、bytes#decode メソッドを使用します。 ZIP ファイル内のテキストファイルを読み込む import zipfile with zipfile.ZipFile(\u0026#34;sample.zip\u0026#34;, \u0026#34;r\u0026#34;) as zf: for info in zf.infolist(): if info.is_dir(): continue # ディレクトリならスキップ if not info.filename.endswith(\u0026#34;.txt\u0026#34;): continue # .txt 以外のファイルもスキップ # ファイルのバイトデータを読み込んでテキストに変換する text = zf.read(info).decode(\u0026#34;utf-8\u0026#34;) print(f\u0026#34;=== {info.filename} ===\u0026#34;) print(text) 実行結果 === data/sample1.txt === ...（省略）... === data/sample2.txt === ...（省略）... === data/sample3.txt === ...（省略）... === README.txt === ...（省略）... JAR ファイル内のクラス一覧を取得する JAR ファイルもフォーマット上は ZIP ファイルと同じ構造なので、ZIP ファイルを扱うのと同様に処理することができます。 ここでは、JAR ファイル内の .class ファイルのみを処理するために、ファイルの拡張子が .class であるかを確認しながらループ処理しています。 ここでは、ファイル名から拡張子を抽出するために os.path.splitext を使っていますが、もっと単純に str#endswith などで代用してもよいかもしれません。 dump_classes.py import zipfile import os import sys def iter_classes_in_jar(jar_name): \u0026#34;\u0026#34;\u0026#34;JAR ファイル内の .class ファイルの名前をもとに Java クラス名を列挙します。\u0026#34;\u0026#34;\u0026#34; with zipfile.ZipFile(jar_name, \u0026#34;r\u0026#34;) as zf: for info in zf.infolist(): classname, ext = os.path.splitext(info.filename) if ext != \u0026#34;.class\u0026#34;: continue # .class 以外のファイルはスキップ yield classname if __name__ == \u0026#34;__main__\u0026#34;: jar_name = sys.argv[1] # List all classes for clazz in iter_classes_in_jar(jar_name): print(clazz) 実行結果 $ python dump_classes.py app.jar com/example/myapp/Bar com/example/myapp/Foo com/example/myapp/Main ..."},{url:"/p/6k5m4jy/",title:"Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP)",date:"2016-12-05T00:00:00Z",body:"Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP) python コマンドを単独で実行したときのインタラクティブシェルは、環境変数 PYTHONSTARTUP に指定したスタートアップ・スクリプトを最初に実行します。 これを利用して、日常的に使用したい関数などを自動的に定義することができます。 例えば、下記の例では、ホームディレクトリにある .pythonstartup スクリプトを読み込むように設定しています。 ~/.bash_profile (Linux や Mac OSX の場合） export PYTHONSTARTUP=~/.pythonstartup Windows の場合は、システムのプロパティから環境変数を設定してください（~/ という表記は使用できないので、スタートアップ・スクリプトの位置はフルパスで指定する必要があります）。 コマンドラインから環境変数を設定することもできます。 C:\\\u0026gt; setx PYTHONSTARTUP D:/x/myconf/pythonstartup.py （コマンドプロンプトを再起動して反映） 下記のスタートアップ・スクリプトでは、モジュールのソースコードをさくっと確認するための DEV.code 関数を定義しています。DEV.file 関数の方は、指定したモジュールのコードを Vim エディタで開きます。 ~/.pythonstartup class DEV: @staticmethod def code(obj): import inspect print(inspect.getsource(obj)) @staticmethod def file(obj): import inspect import os os.system(\u0026#39;gvim \u0026#39; + inspect.getfile(obj)) あとは、Python のインタラクティブシェルを起動すれば、上記の関数が定義された状態で起動します。 $ python ... \u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; DEV.code(os.path.split) def split(p): \u0026#34;\u0026#34;\u0026#34;Split a pathname. Return tuple (head, tail) where tail is everything after the final slash. Either part may be empty.\u0026#34;\u0026#34;\u0026#34; seps = _get_bothseps(p) d, p = splitdrive(p) # set i to index beyond p\u0026#39;s last slash i = len(p) while i and p[i-1] not in seps: i -= 1 head, tail = p[:i], p[i:] # now tail has no slashes # remove trailing slashes from head, unless it\u0026#39;s all slashes head = head.rstrip(seps) or head return d + head, tail"},{url:"/p/xbucsaq/",title:"Python の関数やクラスのソースコードを確認する (inspect)",date:"2016-12-05T00:00:00Z",body:"Python の関数やクラスのソースコードを確認する (inspect) 関数のコードを表示する Python のプログラムを作成しているときに、ある関数のソースコードを確認したくなったときは、inspect モジュールの getsource 関数を使用して簡単に調べることができます。 次の例では、Python の対話型シェル（python3 コマンド）を起動して、os.path.abspath 関数の実装コードを確認しています。 例: os.path.abspath の実装コードを確認する \u0026gt;\u0026gt;\u0026gt; import inspect \u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; print(inspect.getsource(os.path.abspath)) def abspath(path): \u0026#34;\u0026#34;\u0026#34;Return an absolute path.\u0026#34;\u0026#34;\u0026#34; path = os.fspath(path) if not isabs(path): if isinstance(path, bytes): cwd = os.getcwdb() else: cwd = os.getcwd() path = join(cwd, path) return normpath(path) （おまけ）シェルスクリプト化しておく 次のようなシェルスクリプト (pycode) を作っておくと、Python の関数の実装コードを簡単に確認できるようになります。 このシェルスクリプトは、PATH の通ったディレクトリに置いて、chmod +x pycode で実行権限を付けておきます。 /Users/maku/bin/pycode #!/bin/bash # # pycode - Python の関数やクラスの実装コードを表示します # # Usage: # $ pycode \u0026lt;モジュール名\u0026gt; \u0026lt;関数名|クラス名\u0026gt; # # 使用例: # $ pycode os path.abspath # # 引数の数を確認 if [ \u0026#34;$#\u0026#34; -ne 2 ]; then echo \u0026#34;Usage: $(basename $0) \u0026lt;モジュール名\u0026gt; \u0026lt;関数名|クラス名\u0026gt;\u0026#34; exit -1 fi # 引数からモジュール名と関数名を取得 module_name=\u0026#34;$1\u0026#34; function_name=\u0026#34;$2\u0026#34; # 関数のコードを表示するための Python コード python_code=$(cat \u0026lt;\u0026lt;END import $module_name import inspect try: function_code = inspect.getsource($module_name.$function_name) print(function_code) except (ImportError, AttributeError): print(f\u0026#34;シンボルが見つかりません: {module_name}.{function_name}\u0026#34;) END ) # Python コマンドを実行して関数のコードを表示 python3 -c \u0026#34;$python_code\u0026#34; 例えば、os モジュールの path.abspath 関数のコードを確認するには次のように実行します。 pycode の使用例 $ pycode os path.abspath 関数が定義されているファイル全体を表示する inspect.getsource 関数でモジュール名を指定すれば、そのモジュール全体のコードを取得することができるのですが、ハイライト表示なしで長いコードが表示されると非常に読みにくいです。 ここでは、モジュールが定義されているファイルそのものをテキストエディタで開く方法を紹介します。 inspect.getfile 関数を使用すると、指定したクラス、関数、オブジェクトなどが定義されているファイルのパスを取得することができます。 例: os モジュールのソースコードのパスを調べる \u0026gt;\u0026gt;\u0026gt; import inspect \u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; inspect.getfile(os) \u0026#39;C:\\\\Python35\\\\lib\\\\os.py\u0026#39; あとは、そのファイルを任意のエディタで開けば OK です。 エディタの実行ファイルにパスが通っているのであれば、os.system 関数を使って、そのエディタでさくっと開くことができます。 例: os モジュールのソースコードを gvim エディタで開く \u0026gt;\u0026gt;\u0026gt; import inspect \u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; os.system(\u0026#39;gvim \u0026#39; + inspect.getfile(os))"},{url:"/java/",title:"Java",date:"2016-11-24T00:00:00Z",body:"Java アノテーション アノテーションとは Java でカスタムアノテーションを作成する Javadoc でアノテーションのサンプルコードを記述するときの @ の扱い マルチスレッド Executor によるタスク処理 (1) Executor インタフェースを使用する Executor によるタスク処理 (2) ExecutorService インタフェースで Executor を停止する Executor によるタスク処理 (3) Future オブジェクトによりタスクの実行結果を取得する Executor によるタスク処理 (4) 既存の Thread から Future オブジェクトを取得する Executor によるタスク処理 (5) ScheduledExecutorService によるタスクのスケジュール BlockingQueue を使ってスレッド間の通信を行う Lock と Condition による条件ごとのスレッド待機 TimeUnit によって単位時間を明確にする スレッドで発生した Uncaught Exception（未捕捉例外）をハンドルする Java のオブジェクトロックは再入可能であることを理解する Boolean 型で synchronized するのは NG ファイル JAR/ZIP jar コマンドで JAR ライブラリを作成する jar コマンドで実行可能な JAR ファイルを作成する JAR ファイルの署名について Zip ファイル内の要素（ファイルとディレクトリ）を列挙する XML DOM プログラミング - XML のルート要素を取得する DOM プログラミング - 子要素のテキストノードの値を取得する DOM プログラミング - 同じタグ名を持つ全ての子要素をループ処理する ファイル一般 Propertiesファイルから設定値を読み込む MANIFEST.MF ファイルの内容を取得する 数値／文字列／ユニコード 数値と文字列の変換方法いろいろ バイト配列から 16 進数文字列を作成する 文字列をデリミタで分割する (String.split) CSV 形式の文字列を配列に分割する (String.split, Pattern.split) 文字列を単語単位で分割する (BreakIterator) 文字列の結合には StringBuffer ではなく StringBuilder を使用する 小文字と大文字の変換を行う 小文字と大文字の判別を行う ある文字が空白文字（スペース）かどうかを判別する 全角文字と半角文字を含んだ文字列を正規化して表記ゆれを吸収する コードポイントに対応するユニコード文字 (char) を取得する ある文字のコードポイントに対応するユニコード名を調べる 対応している文字セット (Charset) の一覧を取得する 文字列が正規表現に完全に一致するか調べる (String.matches) 文字列の一部が正規表現に一致するか調べ、一致した部分をグループごとに抜き出す (Pattern.matcher) 文字列の正規表現に一致した部分を置き換える (String.replaceAll) 複数行のテキストを含んだ String を一行ずつ処理する 組み合わせ 順列 (permutation) を作成する データベース/JDBC JDBC ドライバの一覧を取得する Java から SQLite を扱えるようにする JDBC による DB 操作の流れ JDBC でプレースホルダを使用して SQL クエリを作成する JDBC で最初のレコードだけを取得する 解析／デバッグ コールスタックを表示する Java で Linux の CPU 使用率を調べる SuprressWarnings アノテーションで Checkstyle の警告を抑制する Java ビルドツールのまとめ (Ant, Maven, Gradle) クラスやメソッドの依存関係を調べる (jdeps, cfa) DEBUG フラグでログ出力を ON/OFF するときは、呼び出し側で if 分岐すること その他 Javadoc コメントの書き方 例外のテストを記述する Java7 の try with resources でストリームの close を自動的に行う コレクションクラスのまとめ static ブロックが実行されるタイミング シングルトンクラスの Lazy Loading イディオム オブジェクトプールを実現するためのクラスを実装する JNI (Java Native Interface) の基本 Java でランダムな UUID を生成する enum の各項目に任意のデータを関連付ける 既定の Web ブラウザで URL を開く コラム J2SE から Java SE へ System.out.println() でオブジェクトを出力するときは toString() しない Effective Java や Java の鉄則など コンストラクタの代わりに static ファクトリメソッドを検討する 数多くのコンストラクタパラメータに直面したときにはビルダーを検討する private のコンストラクタか enum 型でシングルトン特性を強制する private のコンストラクタでインスタンス化不可能を強制する 不必要なオブジェクトの生成を避ける 廃れたオブジェクト参照を取り除く ファイナライザを避ける equals をオーバライドする時は一般契約に従う equals をオーバライドする時は常に hashCode をオーバライドする toString を常にオーバライドする clone を注意してオーバライドする Comparable の実装を検討する コンストラクタからオーバライド可能なメソッドを呼び出さない 国際化 Java アプリケーションの国際化 (i18n) と Locale クラス Locale が変わったときに変化すべき表示項目 Swing 基本 Swing で Hello World Swing - Container と JComponent と JFrame の関係 Swing - JPanel に GUI コンポーネントを配置する Swing - 標準的なダイアログいろいろ Swing - OK ボタンと Cancel ボタンのあるダイアログを作る Swing - JDialog のウィンドウサイズを変更できるようにする Swing - スプリッターを配置してウィンドウを分割する Swing - スプリッターを折り畳み可能にする Swing - スプリッターの分割方向を動的に変更する Swing - コンポーネントにツールティップを表示する Swing - ショートカットキーでフォーカスを移動する Swing - 右クリックでポップアップメニューを表示する Swing - ルック＆フィールを切り替える レイアウト Swing - レイアウトマネージャの種類 Swing - デフォルトのレイアウトマネージャについて Swing - BorderLayout でコンポーネントを上下左右中央に並べる Swing - BorderLayout で中央に配置するコンポーネントのデフォルトサイズを設定する Swing - BorderLayout でコンポーネント間のスペースを設定する Swing - BoxLayout でコンポーネントを縦方向、横方向に並べる Swing - BoxLayout で左寄せ／中央寄せ／右寄せ表示する Swing - FlowLayout でコンポーネントを左上から並べる Swing - FlowLayout でコンポーネントが複数行表示されるときに左寄せ／右寄せする コンポーネント（ウィジェット） Swing - JButton（ボタン）にショートカットキーを割り当てる Swing - JComboBox でルック＆フィールの選択肢を表示する Swing - JEditorPane で HTML コンテンツを表示する Swing - JEditorPane で画像ファイルを表示する Swing - JEditorPane にスタイルシート (CSS) を設定する Swing - JEditorPane でハイパーリンク関連のイベントをハンドルする Swing - JEditorPane で先頭部分を表示する Swing - JList で項目のリストを表示する Swing - JList で扱えるモデルクラスを作成する Swing - JList に動的に要素を追加／削除する Swing - JList で項目を選択したときのイベントをハンドルする Swing - JList で最初に表示される行数を指定する Swing - JList で選択されている項目を取得する Swing - JList で単一の項目のみ選択できるようにする Swing - JList で最後の項目を選択する Swing - JList でリスト項目としてチェックボックスを表示する Swing - JSpinner を使って上下矢印で値を入力できるようにする Swing - JTextArea で複数行のテキストを表示する Swing - JTextArea のテキストを画面端で折り返す Swing - JTextArea のテキストを編集不可にする Swing - JTextArea に表示するフォントを設定する Swing - JTextArea でテキストの先頭部分を表示する Swing - JTextField で Enter キーを押したときにテキストを取得する Swing - JTextFiled で Esc キーを押したときにテキストをクリアする Swing - JTextField のテキストを右寄せで表示する Swing - JTextField でテキストの先頭／末尾部分を強制的に表示する Swing - JTree でツリービューを作成する Swing - JTree に動的にノードを追加する Swing - JTree で選択されているノードを取得する Swing - JTree でノードを選択したときのイベントをハンドルする Swing - JTree でルートノードを表示する Swing - JTree で一階層目のノード間に水平線を表示する Swing - JTree で同時に1つのノードしか選択できないようにする Swing - JTree で指定したノードを選択する SWT (Standard Widget Toolkit) SWT - AWT と Swing と SWT と JFace の違い SWT - SWT を使用するための設定 SWT - Mac で SWT を使用する SWT - SWT アプリケーションの雛形コード SWT - SWT の Layout は Composite の入れ子で構成する SWT - RowLayout でウィジェットを縦／横方向に並べる SWT - FillLayout でウィジェットを縦／横に等間隔に並べる SWT - SashForm でウィンドウを分割して配置する SWT - リストボックス (List) を表示する SWT - ツリービュー (Tree) を表示する SWT - いろいろなダイアログ (MessageBox) を表示する SWT - ブラウザウィジェット (Browser) で HTML を表示する SWT - SWT/JFace における色 (Color) 情報の扱い方 SWT - 矢印ボタンを作る SWT - Canvas を使って自由に描画する SWT - Cannot load 32-bit SWT libraries エラーが発生する場合 JFace を使用するための設定 JFace アプリケーションの雛形コード JFace のウィンドウにウィジェットを配置する JFace のウィンドウのタイトルを設定する JFace の ListViewer を使用する JFace の TreeViewer を使用する JFace の TreeViewer を使ってディレクトリツリーを表示する 階層構想を表現した RDB のデータを JFace の TreeViewer でツリー表示する JFace の CheckboxTreeViewer を使用する JFace の TableViewer を使用してテーブルにデータを表示する トラブルシューティング CLASSPATH 関連のエラーに対処する Mac で javac の出力が文字化けする"},{url:"/p/mpqhkpv/",title:"クラスやメソッドの依存関係を調べる (jdeps, cfa)",date:"2016-11-24T00:00:00Z",body:"クラスやメソッドの依存関係を調べる (jdeps, cfa) パッケージ／クラスレベルの依存関係を調べる (jdeps) JDK 8 に付属している jdeps コマンド を使用すると、JAR ファイル（.class ファイル）から、パッケージレベル、あるいは、クラスレベルの依存関係を調べることができます。 パッケージレベルの依存関係を調べる すべての依存を表示（グルーピングして表示） $ jdeps app.jar 1 行ごとに「依存元 -\u0026gt; 依存先」というフォーマットで出力 $ jdeps -v app.jar あるパッケージへの依存のみを抽出したい場合は、-e オプションで次のように指定します。 com.example.util パッケージへの依存のみを表示 $ jdeps -e com.example.util.* app.jar ☝️ ワンポイント 特定のパッケージへの依存は、-p オプションでも検索することができますが、 こちらの場合は、完全にパッケージ名が一致するもののみを抽出します。 あるパッケージより下位のパッケージも含めて検索するには、上記のように -e オプションで正規表現の形でパッケージ名を指定する必要があります。 クラスレベルの依存関係を調べる $ jdeps -verbose:class app.jar メソッドレベルの依存関係を調べる (cfa) YaSuenag さんの作成している cfa (Class File Analyzer) というツールを使用すると、.class ファイルを解析して、メソッドレベルの依存関係を調べることができます。 https://github.com/YaSuenag/cfa/（fork しておく） 実行ファイルは cfa.jar です。 Windows であれば、下記のようなバッチファイルを JAR と同じディレクトリにおいて PATH を通しておくと、どのディレクトリからでも cfa と入力するだけで実行できて便利です。 cfa.cmd @echo off setlocal set jar=\u0026#34;%~dp0%cfa.jar\u0026#34; set java=java.exe if defined JDK_HOME ( set java=%JDK_HOME%\\bin\\java.exe ) %java% -jar %jar% %* endlocal cfa.jar は、JRE ではなく JDK に付属している java コマンド経由で実行する必要があることに注意してください。 実行時に下記のようなエラーが発生する場合は、JRE の java コマンドを参照してしまっている可能性が高いです。 Exception in thread \u0026#34;main\u0026#34; java.io.FileNotFoundException: tools.jar does not exist. このような場合は、JDK_HOME 環境変数に JDK をインストールしたディレクトリパス（例: C:\\jdk1.8.0_65）を設定してください。 上記のバッチファイルでは、この環境変数で設定された JDK の java コマンドを参照するようになっています。 下記は cfa コマンドの使用例です。 メソッドレベルの依存関係を調べる（参照しているクラスやフィールドの情報も表示されます） $ cfa app.jar com.example.aaa と com.example.bbb を参照しているメソッドだけを対象とする $ cfa -c com.example.aaa,com.example.bbb app.jar"},{url:"/p/eezeq4g/",title:"ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast)",date:"2016-10-03T00:00:00Z",body:"ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast) 以下のコマンドは、adb shell でデバイスに接続した状態から実行することを想定しています。 接続と同時に実行するには、adb shell を先頭に追加して実行してください（例: adb shell am start ...）。 Activity（アクティビティ）を起動する シェル上で am start コマンドを実行すると、Intent を発生させて Activity を起動することができます。 am start \u0026lt;INTENT\u0026gt; Intent 引数（\u0026lt;INTENT\u0026gt; の部分）の指定方法は、Specification for INTENT arguments のページに詳しく記載されています。 具体的には、次のようなオプションの組み合わせで Intent を構成します。 -a \u0026lt;ACTION\u0026gt; 例: -a android.intent.action.VIEW -d \u0026lt;DATA_URI\u0026gt; 例: -d content://contacts/people/1 -t \u0026lt;MIME_TYPE\u0026gt; 例: -t image/png -c \u0026lt;CATEGORY\u0026gt; 例: -c android.intent.category.APP_CONTACTS -n \u0026lt;COMPONENT\u0026gt; 例: -n com.example.app/.ExampleActivity 必要に応じて、Bundle データを渡すこともできます。 --esn \u0026lt;EXTRA_KEY\u0026gt; （キーのみ） -e|--es \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_STRING_VALUE\u0026gt; --ez \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_BOOLEAN_VALUE\u0026gt; --ei \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_INT_VALUE\u0026gt; --el \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_LONG_VALUE\u0026gt; --ef \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_FLOAT_VALUE\u0026gt; --eu \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_URI_VALUE\u0026gt; --ecn \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_COMPONENT_NAME_VALUE\u0026gt; --eia \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_INT_VALUE\u0026gt;[,\u0026lt;EXTRA_INT_VALUE...] --ela \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_LONG_VALUE\u0026gt;[,\u0026lt;EXTRA_LONG_VALUE...] --efa \u0026lt;EXTRA_KEY\u0026gt; \u0026lt;EXTRA_FLOAT_VALUE\u0026gt;[,\u0026lt;EXTRA_FLOAT_VALUE...] 下記は、am start コマンドによる Activity の起動例です。 Activity のクラス名（コンポーネント名）を直接指定して起動する $ am start -n com.example.myapp/.MainActivity アクションを指定して起動する ブラウザを起動する（URL をハンドルするアプリを起動する） $ am start -a android.intent.action.VIEW http://google.com/ 電話を掛ける $ am start -a android.intent.action.CALL tel:123456789 着信音の選択画面を表示する am start -a android.intent.action.RINGTONE_PICKER HOME 画面を起動する $ am start -a android.intent.action.MAIN $ am start -a android.intent.action.MAIN -c android.intent.category.HOME サービス (Service) を起動・停止する サービスの起動 am start-service コマンドで任意のサービスを起動することができます。 例えば、アプリのパッケージ名 (com.example.myapp) とサービスのクラス名 (com.example.myapp.services.MyApp) が分かっているのであれば、次のようにサービスを起動できます。 ちなみに、-n オプションの後ろの部分を「コンポーネント名」と呼びます。 $ adb shell am start-service -n com.example.myapp/.services.MyService Starting service: Intent { cmp=com.example.myapp/.services.MyService } Foreground サービスとして起動する場合は、am start-service の代わりに、am start-foreground-service を使用します。 $ adb shell am start-foreground-service -n com.example.myapp/.services.MyService Starting service: Intent { cmp=com.example.myapp/.services.MyService } サービスがちゃんと Foreground で動作しているかは、dumpsys コマンドで確認できます。 $ adb shell dumpsys activity s MyService | grep isForeground isForeground=true foregroundId=2 ... am start-service や am start-foreground-service コマンドでサービスを起動するには、そのサービスが AndroidManifext.xml で公開設定されている必要があります。 android:exported=\u0026quot;false\u0026quot; になっているサービスを起動しようとすると、Error: Requires permission not exported from uid 10077 といったエラーになります。 \u0026lt;service android:name=\u0026#34;com.example.myapp.services.MyService\u0026#34; android:exported=\u0026#34;true\u0026#34; サービスの停止 サービスを停止するには、am stop-service コマンドを使います。 $ adb shell am stop-service -n com.example.myapp/.services.MyService Stopping service: Intent { cmp=com.example.myapp/.services.MyService } Service stopped （おまけ）adb shell am help によるヘルプ表示の抜粋です。 start-service [--user \u0026lt;USER_ID\u0026gt; | current] \u0026lt;INTENT\u0026gt; Start a Service. Options are: --user \u0026lt;USER_ID\u0026gt; | current: Specify which user to run as; if not specified then run as the current user. start-foreground-service [--user \u0026lt;USER_ID\u0026gt; | current] \u0026lt;INTENT\u0026gt; Start a foreground Service. Options are: --user \u0026lt;USER_ID\u0026gt; | current: Specify which user to run as; if not specified then run as the current user. stop-service [--user \u0026lt;USER_ID\u0026gt; | current] \u0026lt;INTENT\u0026gt; Stop a Service. Options are: --user \u0026lt;USER_ID\u0026gt; | current: Specify which user to run as; if not specified then run as the current user. ブロードキャストインテント (Broadcast Intent) を投げる Intent をブロードキャストするには、am start の代わりに am broadcast を使用します。 $ am broadcast -a android.intent.action.XXX 下記は、端末の起動時にブロードキャストされる BOOT_COMPLETED インテントを明治的に投げる例です（root ユーザで実行）。 $ am broadcast -a android.intent.action.BOOT_COMPLETED （おまけ）adb shell am help によるヘルプ表示の抜粋です。 broadcast [--user \u0026lt;USER_ID\u0026gt; | all | current] [--receiver-permission \u0026lt;PERMISSION\u0026gt;] [--allow-background-activity-starts] [--async] \u0026lt;INTENT\u0026gt; Send a broadcast Intent. Options are: --user \u0026lt;USER_ID\u0026gt; | all | current: Specify which user to send to; if not specified then send to all users. --receiver-permission \u0026lt;PERMISSION\u0026gt;: Require receiver to hold permission. --allow-background-activity-starts: The receiver may start activities even if in the background. --async: Send without waiting for the completion of the receiver."},{url:"/p/w6ste5j/",title:"APK のパッケージ依存関係やクラス依存関係を調べる",date:"2016-08-17T00:00:00Z",body:"APK のパッケージ依存関係やクラス依存関係を調べる ここでは、jdeps と dex2jar を使って、APK ファイル内の依存関係を調査する方法を示します。 jdeps と dex2jar JDK 8 にはパッケージ依存関係やクラス依存関係を調べるための jdeps コマンドが標準搭載されました。 jdeps コマンド - Oracle Java Documentation これを使用すると、.class ファイル（あるいは .jar ファイル）を入力情報として、そこから参照しているクラスやパッケージの情報を調べることができるのですが、Android の APK としてビルドされたコードは .dex ファイルになっていますので、まずはこれを通常の .class 形式に変更してやる必要があります。 APK ファイル内の .dex を .class 形式に変換するには、dex2jar というツールを使用します。 dex2jar のダウンロード 上記から、たとえば dex-tools-2.1-20150601.060031-26.zip をダウンロードし、パスの通ったディレクトリに展開すればインストール完了です。 APK ファイルのパッケージ依存、クラス依存情報を調べる まず、d2j-dex2jar コマンドを使用して、APK ファイル内の .dex を .class 形式に変換します。 APK ファイルを unzip して取り出した .dex ファイルを変換することもできますが、下記のように直接 APK ファイルを .jar に変換してしまうのが手っ取り早いです。 apk から jar への変換 $ d2j-dex2jar app/build/outputs/apk/app-debug.apk -o app.jar dex2jar app/build/outputs/apk/app-debug.apk -\u0026gt; app.jar これで .class ファイルの含まれた .jar ファイルが生成されるので、晴れて jdeps コマンドで依存関係を調べられるようになります。 $ jdeps app.jar ... com.example.myapp.function (app.jar) -\u0026gt; android.content 見つかりません -\u0026gt; android.content.pm 見つかりません -\u0026gt; android.os 見つかりません -\u0026gt; android.text 見つかりません -\u0026gt; com.google.android.youtube.player app.jar -\u0026gt; com.example.myapp.common.log app.jar -\u0026gt; com.example.myapp.common.dialog app.jar -\u0026gt; java.io -\u0026gt; java.lang -\u0026gt; java.lang.reflect -\u0026gt; java.text -\u0026gt; java.util ... デフォルトでは上記のようにパッケージ間の依存関係が出力されますが、-verbose:class オプションを指定すれば、クラスレベルで依存関係を出力することができます（大量に出力されます）。 $ jdeps -verbose:class app.jar ... com.example.myapp.function.LoggerService (app.jar) -\u0026gt; android.app.Service 見つかりません -\u0026gt; android.content.ContentResolver 見つかりません -\u0026gt; android.content.Context 見つかりません -\u0026gt; android.content.Intent 見つかりません -\u0026gt; android.net.Uri 見つかりません -\u0026gt; android.os.Handler 見つかりません -\u0026gt; android.os.IBinder 見つかりません -\u0026gt; com.example.myapp.common.log app.jar -\u0026gt; com.example.myapp.common.text app.jar ... ちなみに上記の出力の「見つかりません」というのは、依存先のクラスが格納されたライブラリが見つからないことを示しています。 下記のように、外部 .jar ファイルに対してクラスパスを通してやれば、依存している .jar ファイルの名前も出力されるようになります（下記では、libs_ext というディレクトリに Shared library としての .jar ファイルが格納されているとします）。 # Windows の場合 $ jdeps -cp libs_ext/*;%ANDROID_HOME%/platforms/android-23/* app.jar # Linux の場合 $ jdeps -cp libs_ext/*:$ANDROID_HOME/platforms/android-23/* app.jar Android や Java のコアライブラリが提供しているクラスへの依存情報は不要だという場合は、下記のように -f オプションで必要のない依存情報をフィルタすることができます。 $ jdeps -f \u0026#34;java.*|android.*|dalvik.*\u0026#34; app.jar APK ファイルのメソッドレベルの依存関係を調べる 昔は Android の dexdeps というツールでメソッドレベルの依存関係を調べることができたのですが、このツールは multidex 構成の APK には対応していません（APK 内の１つの DEX ファイルしか解析対象にならない）。 Yasuenag さんの cfa というツールを使用すれば、.class ファイルを解析してメソッドレベルの依存関係を調べることができますので、こちらを利用するのがよいかもしれません。 クラスやメソッドの依存関係を調べる ─ まくまく Java ノート"},{url:"/p/7vwoyht/",title:"モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし）",date:"2016-07-31T00:00:00Z",body:"モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし） モバイルファーストで Web サイトを作成するには、メディアクエリで max-width は使用せずに、min-width を使用するようにしましょう。 そうすると、デフォルトのスタイルが小さい画面用のスタイルとして適用されるため、モバイル画面でどのように表示されるかを先に考えることができます。 画面が広いときと狭い時のレイアウトを切り替える メディアクエリ (@media) を使用すると、画面幅に応じたレイアウトを行うことができます。 例えば、画面幅が広いとき（PC 画面など）のみ blockquote 要素の左マージンを大きくしたい場合は、次のような 2 通りの方法が考えられます。 ここでは、640px を切り替えの基準としています。 方法1. 広い画面をデフォルトのスタイルとする /* デフォルトのスタイル（画面が広いとき） */ blockquote { margin-left: 1em; } /* 639px 以下のスタイル（画面が狭いとき） */ @media (max-width: 639px) { blockquote { margin-left: 0; } } 方法2. 狭い画面をデフォルトのスタイルとする /* デフォルトのスタイル（画面が狭いとき） */ blockquote { margin-left: 0; } /* 640px 以上のスタイル（画面が広いとき） */ @media (min-width: 640px) { blockquote { margin-left: 1em; } } モバイルファーストで考えるのであれば、後者の min-width を使った指定方法をオススメ します。 メディアクエリ (@media) を使ったスタイル定義によって、デフォルトのスタイル定義を上書きするわけですが、デフォルトのスタイルの方を（画面が狭い）モバイルデバイス用に定義しておくことで、最初からモバイルデバイスでの表示を意識した CSS を構築していくことができます。 3 パターン以上の画面サイズに対応する場合 下記は、画面サイズを大・中・小の 3 パターンに分けてスタイル定義したい場合の例です。 ここでは、それぞれの横幅を次のように設定しています。 画面サイズ小: 599px 以下（デフォルト） 画面サイズ中: 600px 以上 画面サイズ大: 1200px 以上 /* デフォルトスタイル（画面サイズ小） */ blockquote { margin-left: 0; } /* 600px 以上のスタイル（画面サイズ中） */ @media (min-width: 600px) { blockquote { margin-left: 1em; background: blue; } } /* 1200px 以上のスタイル（画面サイズ大） */ @media (min-width: 1200px) { blockquote { margin-left: 2em; } } メディアクエリによるスタイル指定は排他的ではないため、複数のスタイル指定が組み合わされる可能性があることに注意してください。 例えば、現在のスクリーン幅が 1500px の場合は、min-width: 600px という条件も、min-width: 1200px という条件も満たすため、画面サイズ「小」「中」「大」のすべてのスタイル指定が適用されます。 ただし、同じプロパティ名が指定されている場合は、より後方で定義されたスタイルによって上書きされます。 上記の例の場合は、blockquote 要素に次のようなスタイルが適用されることになります。 margin-left: 2em; （画面サイズ大のスタイル定義が適用される） background: blue; （画面サイズ中のスタイル定義が適用される） 画面サイズ中 (600px ～ 1199px) のときのみ適用するスタイルを定義したい場合は、次のように、min-width と max-width を組み合わせて条件を設定します。 /* 600px 以上 1199px 以下のスタイル（画面サイズ中） */ @media (min-width: 600px) and (max-width: 1199px) { blockquote { background: blue; } } （おまけ）Sass の mixin によるメディアクエリの簡略化 通常の使い方でメディアクエリを使用すると、各要素のスタイル定義が散らばってしまって管理しにくくなってしまいます。 このような場合は、Sass の mixin 機能を使用すると、スタイル定義をまとめて記述できるようになります。 次の例では、スクリーンサイズ中と大の場合を示す mixin 定義を行っています（ここでは幅の単位に rem を使ってみました）。 sample.scss // スクリーンサイズ中 @mixin screen-size-medium { @media (min-width: 40rem) { @content; } } // スクリーンサイズ大 @mixin screen-size-large { @media (min-width: 60rem) { @content; } } これらの mixin を使用すると、blockquote の 3 種類のレイアウトを下記のようにまとめて記述できます。 blockquote { margin-left: 0; @include screen-size-medium { margin-left: 1em; } @include screen-size-large { margin-left: 2em; } }"},{url:"/p/jfqtfyn/",title:"ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts)",date:"2016-07-15T00:00:00Z",body:"ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts) dumpsys コマンドの activity broadcast サブコマンドを実行すると、ブロードキャストインテントをハンドルするように登録しているレシーバーの一覧を確認することができます。 $ adb shell dumpsys activity broadcasts 実行結果（抜粋） ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts) Registered Receivers: ... * ReceiverList{82bcce 603 com.android.systemui/10019/u0 remote:83b3dc9} app=603:com.android.systemui/u0a19 pid=603 uid=10019 user=0 Filter #0: BroadcastFilter{28557ef} Action: \u0026#34;android.intent.action.TIME_TICK\u0026#34; Action: \u0026#34;android.intent.action.TIME_SET\u0026#34; Action: \u0026#34;android.intent.action.BATTERY_CHANGED\u0026#34; ... AutoVerify=false Filter #1: BroadcastFilter{56b72fc} Action: \u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34; mPriority=1000, mHasPartialTypes=false AutoVerify=false ... Registered Receivers のセクションには、アプリごとにどのようなフィルタでインテントを監視しているかが表示されます。 上記の例では、com.android.systemui アプリが、android.intent.action.TIME_TICK インテントなどのブロードキャストを監視していること示しています。 さらに下の方を見ると、Receiver Resolver Table というセクションがあります。 Receiver Resolver Table: ... Non-Data Actions: ... android.intent.action.BOOT_COMPLETED: BroadcastFilter{10f199e u0 ReceiverList{b1ecbd9 493 system/1000/u0 local:28f4620}} BroadcastFilter{989a5ad u0 ReceiverList{ae0d2c4 493 system/1000/u0 local:48b9d7}} BroadcastFilter{213887b u0 ReceiverList{758680a 493 system/1000/u0 local:513e075}} BroadcastFilter{56b72fc u0 ReceiverList{82bcce 603 com.android.systemui/10019/u0 remote:83b3dc9}} ... こちらは逆に、あるインテント (Action) をどのモジュールが監視しているかのマッピングを示しています。 この例では、BOOT_COMPLETED インテントを監視しているモジュールの一覧を表示しています。"},{url:"/p/v5dcz6f/",title:"CSS で画面サイズによって全体のレイアウトを変更する",date:"2016-07-15T00:00:00Z",body:"CSS で画面サイズによって全体のレイアウトを変更する CSS3 のメディアクエリをうまく使うと、Web ブラウザのウィンドウサイズによって、動的にレイアウトを変更することができます。 全体のレイアウト構成 ここでは、画面の幅によって、下記のように変化するレイアウトを考えてみます。　1000px 超: 固定幅の 2 段組レイアウト 1000px 以下: 可変幅の 2 段組レイアウト（リキッドレイアウト） 700px 以下: シングルカラム 今このページを PC のブラウザで見ているのであれば、下記のデモページを表示して、画面幅を変更してみてください。 画面幅に応じてレイアウトが自動的に変更されるはずです。 （別ページで表示） HTML 要素は下記のようにヘッダー、コンテンツ、サイドバー、フッターと、4 つの部分に分かれています。 \u0026lt;div id=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;header id=\u0026#34;header\u0026#34;\u0026gt;Header\u0026lt;/header\u0026gt; \u0026lt;article id=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;div\u0026gt;Content\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Content\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Content\u0026lt;/div\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;aside id=\u0026#34;sidebar\u0026#34;\u0026gt; \u0026lt;div\u0026gt;Sidebar\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;Sidebar\u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; \u0026lt;footer id=\u0026#34;footer\u0026#34;\u0026gt;Footer\u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; 固定幅の 2 段組レイアウト（画面幅が広いとき） 表示幅が大きいときは、サイズ固定でページを表示します。 分かりやすいように、このレイアウトのときは、周りに青色で枠を表示しています。 #page { width: 980px; margin: 0 auto; border: blue 5px solid; } #header { background-color: lightblue; } #content { width: 680px; float: left; background-color: lightpink; } #sidebar { width: 300px; float: right; background-color: lightgreen; } #footer { clear: both; background-color: lightblue; } 可変幅の 2 段組レイアウト（画面幅が中サイズのとき） 幅が 1000px 以下になると、コンテンツ部分と、サイドバー部分を動的にサイズ変更して画面内に収まるように調整します。 このレイアウトのときは、周りに黄色で枠を表示します。 @media screen and (max-width: 1000px) { #page { width: 98%; border-color: yellow; } #content { width: 70%; } #sidebar { width: 30%; } } シングルカラムレイアウト（画面幅が狭いとき） 幅が 700px 以下（モバイル端末含む）になると、サイドバーは表示しきれないので、画面の下の方に移動させます。 コンテンツとサイドバーの幅を 100% で表示することによって、シングルカラム表示にしています。 このレイアウトのときは、周りに赤色で枠を表示します。 @media screen and (max-width: 700px) { #page { border-color: red; } #content { width: 100%; } #sidebar { width: 100%; } }"},{url:"/p/gorux24/",title:"ADB からキー入力やテキスト入力を行う (input text, input keyevent)",date:"2016-07-14T00:00:00Z",body:"ADB からキー入力やテキスト入力を行う (input text, input keyevent) ADB shell 上で input コマンドを使用すると、任意のキー入力やテキスト入力をエミュレートすることができます。 キー入力の例 (input keyevent) input keyevent コマンドを使用することで、単一のキー入力をエミュレートできます。 $ adb shell input keyevent ENTER # Enter キー $ adb shell input keyevent DPAD_CENTER # D-pad 上の決定キー $ adb shell input keyevent DPAD_RIGHT # 右キー $ adb shell input keyevent POWER # 電源キー $ adb shell input keyevent A # キーボードの A キー $ adb shell input keyevent TV # TV キー（Android TV 用） $ adb shell input keyevent NUMBER_ENTRY # 10-key キー（Android TV 用） $ adb shell input keyevent TV_TERRESTRIAL_DIGITAL # 地デジキー（Android TV 用） パラメータに指定できるキー名は、android.view.KeyEvent クラスに定義されている KEYCODE_XXX という定数の、KEYCODE_ というプレフィックスを除いたものです（参考: KeyEvent クラスの定数一覧）。 長押し input keyevent コマンドの --longpress オプションを指定すると、キーの長押しをエミュレートできます。 次の例では、ENTER キーの長押しを再現しています（ちょっとだけ長押しして、すぐ離す、という操作と同じ振る舞いになります）。 $ adb shell input keyevent --longpress ENTER （応用）sendevent を使う方法 よりローレベルなキー入力を再現したい場合は、sendevent コマンドを使った方法があります。 例えば、「キーを 5 秒間押しっぱなしにする」といった細かい動きを再現したいケースでは input keyevent は使えないので、sendevent を使ったシェルスクリプトなどを作ることになります。 getevent/sendevent で入力デバイスへの入力情報を取得する／入力を行う テキスト入力の例 (input text) テキストエリアなどにフォーカスが当たっているときに、連続したキーボード入力を行ってテキスト入力したいときは、input keyevent の代わりに input text を使用すると便利です。 スペースキーを入力する場合は、%s と指定する必要があります。 $ adb shell input text ABC%sDEF # \u0026#34;ABC DEF\u0026#34; というキーボード入力 $ adb shell input text aAbBcCdD # 大文字と小文字の区別も可能 キーボードやリモコン上のキーシーケンスを送り込んでいるだけなので、マルチバイト文字（日本語など）を直接入力することはできないようです。"},{url:"/p/ycwfweu/",title:"Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd)",date:"2016-07-13T00:00:00Z",body:"Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd) （追記） Android 10 (Q) 以降では、より洗練された Perfetto を使ってパフォーマンス解析できます。 systrace コマンドの基本 Android - Systrace Android - Analyzing UI Performance with Systrace Android SDK に付属している systrace.py スクリプトを使用すると、Android デバイス全体のプロセスに関するプロファイリングを行うことができます（I/O アクセスや UI スレッドの状況など）。 systrace は Python スクリプトとして提供されているため、実行するときは下記のような感じでパラメータを指定して実行します。 例: 10 秒間の systrace 実行する $ cd android-sdk/platform-tools/systrace $ python systrace.py --time=10 -o trace.html sched gfx view wm プロファイルの取得が完了すると、プロファイル結果を表示するための HTML ファイルがカレントディレクトリに作成されます。 Capturing trace......................................................Done. Downloading trace....Done. wrote file://C:\\trace.html この HTML を Web ブラウザで開いてボトルネックの分析を行うことができます。 Web ブラウザ上で ? キーを押すと、使用できるショートカットキーの一覧を確認できます。 バッチファイル化 systrace コマンドを実行するときに、同じようなパラメータを毎回指定するのは面倒ですし、Windows 環境ですと PATH を通したりするのも若干面倒ですので、下記のようなバッチファイルを作成しておくと便利です。 systrace.cmd @echo off setlocal REM ======================================== REM 下記のパスは環境に応じて変更してください REM ======================================== set PYTHON=C:\\app\\Python27\\python.exe set SYSTRACE=%ANDROID_SDK%\\platform-tools\\systrace\\systrace.py @echo on %PYTHON% %SYSTRACE% --time=10 -o trace.html sched gfx view wm ここでは、Android SDK のディレクトリパスが ANDROID_SDK 環境変数に設定されていると想定しています。 環境変数の設定が面倒であれば、バッチファイル内の SYSTRACE 変数の内容を直接いじってしまっても OK です。 このバッチファイルを PATH の通ったディレクトリに置いておけば、どのディレクトリからでも systrace と打つだけでプロファイルを取得できるようになります。 C:\\\u0026gt; systrace Capturing trace..............................................Done. （応用）バッチファイルにパラメータを追加する 下記は上記のバッチファイルをちょっと応用して、計測時間（秒）と、出力ファイル名をパラメータで指定できるようにしたものです。 systrace.cmd (2) @echo off setlocal REM ======================================== REM 下記のパスは環境に応じて変更してください REM ======================================== set PYTHON=C:\\app\\Python27\\python.exe set SYSTRACE=%ANDROID_SDK%\\platform-tools\\systrace\\systrace.py REM 第1パラメータは計測時間（デフォルトは 3 秒） set DURATION=%~1 if \u0026#34;%DURATION%\u0026#34;==\u0026#34;\u0026#34; (set DURATION=3) REM 第2パラメータは出力ファイル名（デフォルトは trace.html） set OUT_FILE=%~2 if \u0026#34;%OUT_FILE%\u0026#34;==\u0026#34;\u0026#34; (set OUT_FILE=trace.html) @echo on %PYTHON% %SYSTRACE% --time=%DURATION% -o %OUT_FILE% sched gfx view wm 例えば、5 秒間計測して、output.html というファイル名で保存するには次のように実行します。 C:\\\u0026gt; systrace 5 output.html パラメータを省略した場合は、計測時間は 3 秒間、出力ファイル名は trace.html になるようにしています。 ちなみに、Windows バッチファイルのコマンドライン引数の扱い方は、下記の記事で詳しく説明しています。 バッチファイルでコマンドライン引数を扱う｜まくまくWindowsノート"},{url:"/p/w6vao2e/",title:"Ruby で adb コマンドの出力結果を処理する",date:"2016-07-06T00:00:00Z",body:"Ruby で adb コマンドの出力結果を処理する 下記は、Ruby スクリプトの中から adb shell コマンドを呼び出して、その出力をハンドルするサンプルです。 ここで定義している adb_shell メソッドは、受け取ったコマンド文字列を adb shell の後ろにくっつけた形のコマンドを実行します（adb_shell('pm list packages') とすると、adb shell pm list packages が実行される）。 sample.rb # Executes the command via \u0026#39;adb shell\u0026#39;. # Obtained result will be passed to the specified block line by line. def adb_shell(command) result = `adb shell #{command}` result.gsub!(\u0026#34;\\n\\n\u0026#34;, \u0026#34;\\n\u0026#34;) # for Windows result.lines { |line| yield line } end # Test if $0 == __FILE__ adb_shell(\u0026#39;pm list packages\u0026#39;) do |line| puts \u0026#39;==\u0026gt; \u0026#39; + line end end 実行結果 $ ruby sample.rb ==\u0026gt; package:android ==\u0026gt; package:android.autoinstalls.config.google.fugu ==\u0026gt; package:com.android.backupconfirm ==\u0026gt; package:com.android.bluetooth ==\u0026gt; package:com.android.certinstaller ==\u0026gt; package:com.android.defcontainer ==\u0026gt; package:com.android.dreams.basic ... 応用として、パッケージ名部分だけを取り出したいのであれば、下記のように正規表現でフィルタしてしまうこともできますね。 adb_shell(\u0026#39;pm list package\u0026#39;) do |line| if line =~ /package:((\\w|.)+)/ puts \u0026#39;==\u0026gt; \u0026#39; + $1 end end 実行結果 $ ruby sample.rb ==\u0026gt; android ==\u0026gt; android.autoinstalls.config.google.fugu ==\u0026gt; com.android.backupconfirm ==\u0026gt; com.android.bluetooth ==\u0026gt; com.android.certinstaller ==\u0026gt; com.android.defcontainer ==\u0026gt; com.android.dreams.basic ..."},{url:"/p/qcvotb4/",title:"IE 8 でも HTML5 の header や footer 要素を使えるようにする",date:"2016-07-01T00:00:00Z",body:"IE 8 でも HTML5 の header や footer 要素を使えるようにする IE 8 では HTML5 の header 要素や footer 要素に適用したスタイルが反映されません。 この問題を解決するには、下記のコードを head セクションに追加します。 \u0026lt;!--[if lte IE 8]\u0026gt; \u0026lt;script src=\u0026#34;http://html5shiv.googlecode.com/svn/trunk/html5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;![endif]--\u0026gt; 新しい要素に対応していないブラウザでは、それらの要素をインライン要素として表示してしまうので、下記のようにブロック要素として定義しておかないといけないのですが、上記のスクリプトはこの設定も行ってくれます。 article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section { display: block; }"},{url:"/p/ghtgxgw/",title:"APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages)",date:"2016-06-27T00:00:00Z",body:"APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages) 指定したパッケージの APK のファイルパスを調べる Android デバイスに adb shell で接続し、pm path \u0026lt;パッケージ名\u0026gt; コマンドを実行すると、指定したパッケージ名の APK ファイルが、デバイス上のどのパスに置かれているかを調べることができます。 com.example.myapp パッケージがどの APK ファイルか調べる $ adb shell pm path com.example.myapp package:/system/app/MyApp/MyApp.apk インストールされているすべての APK のファイルパスとパッケージ名を調べる インストールされている APK パッケージの一覧は、pm list packages コマンドで調べることができます。 インストール済みパッケージの一覧を表示 $ adb shell pm list packages package:com.google.android.apps.mediashell package:com.google.android.katniss package:com.android.providers.calendar package:com.android.tv.settings package:com.android.providers.media ... さらに、-f オプションを指定して実行すると、すべての APK に関するファイルパスとパッケージ名の対応情報を調べることができます。 sort コマンドと組み合わせて使用すると見やすくなります。 APK 名とパッケージ名の対応リスト $ adb shell pm list packages -f | sort package:/system/app/Backdrop/Backdrop.apk=com.google.android.backdrop package:/system/app/BasicDreams/BasicDreams.apk=com.android.dreams.basic package:/system/app/Bluetooth/Bluetooth.apk=com.android.bluetooth package:/system/app/KeyChain/KeyChain.apk=com.android.keychain ... システムにプリインストールされているアプリケーションだけを列挙したい場合は、-s オプションも同時に指定します。 プリインアプリのみ表示 $ adb shell pm list packages -f -s 逆に、ユーザがインストールしたサードパーティ製のアプリだけを列挙したい場合は、-3 オプションを指定します（/data/app 以下に格納されているのが分かります）。 3rd パーティアプリのみ表示 $ adb shell pm list packages -f -3 package:/data/app/com.hulu.livingroomplus.jp-1/base.apk=com.hulu.livingroomplus.jp package:/data/app/com.ted.android.tv-1/base.apk=com.ted.android.tv package:/data/app/tv.pluto.android-1/base.apk=tv.pluto.android"},{url:"/p/u3n5m3j/",title:"Systrace の画面が真っ白になるときの対応方法",date:"2016-06-08T00:00:00Z",body:"Systrace の画面が真っ白になるときの対応方法 追記 (2021-04): 現在は Systrace は deprecated になっており、Perfetto という新しいトレースツールを使うことができます（参考: Perfetto でシステム全体のパフォーマンスを計測する。 過去に systrace で取得したトレースファイルを開きたいときは、Perfetto UI のサイト上で Open with Legacy UI から開くことができます。 Android の DDMS などで利用可能な systrace を実行すると、trace.html ファイルが生成されますが、この中で非推奨になった JavaScript API(Object.observe) を使用しているため、最新の Chrome では表示できない問題が出ています。 参考: http://stackoverflow.com/questions/36865899/react-native-android-systrace-html-is-blank-in-ubuntu-14-04/37008945 上記サイトでの回避策としては、生成された HTML のヘッダに下記を追加することがあげられています。 \u0026lt;script src=\u0026#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 生成される HTML ファイルを毎回修正するのが面倒な場合は、Android SDK のディレクトリにある下記のファイルを編集するという方法もあります。 このファイルに追記した内容は、生成される HTML にも反映されるようになります。 $ANDROID_SDK/platform-tools/systrace/prefix.html \u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head i18n-values=\u0026#34;dir:textdirection;\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ★これを追加"},{url:"/p/39cfimo/",title:"Android アプリのパフォーマンス改善に使用できるツール",date:"2016-06-07T00:00:00Z",body:"Android アプリのパフォーマンス改善に使用できるツール systrace / perfetto: システム全体の負荷状況などを調べる systrace を使用すると、カーネルレベルでの CPU 負荷状況などを調べられるため、システム全体で重くなっている場合などの一次分析に使用できます。 DDMS ツール (monitor.bat) から任意のタイミングでプロファイル取得できます。 （追記） Android 10 (Q) 以降は、より洗練された Perfetto を使用してください。 参考: Perfetto でシステム全体のパフォーマンスを計測する traceview: アプリ内のメソッド呼び出し数などを調べる traceview を使用すると、特定のアプリ内のメソッド単位のプロファイル情報を取得することができます。 メソッド呼び出し回数が想定よりも多くなっているとか、処理に時間がかかりすぎているメソッドなどを発見できます。 DDMS ツールから任意のタイミングでプロファイル取得できます。あるいは、コードに開始／終了タイミングを明示することで、ピンポイントで特定の区間のプロファイルを取得することもできます。 Show GPU overdraw: 同じ領域を何度も描画しないか調べる 開発者オプションで Show GPU overdraw の機能を有効にすると、画面上に重ねて描画される領域があったときに、その領域が描画回数に応じた色で矩形表示されるようになります。 例えば、赤色で矩形表示された場合は、その領域が 3 回以上重複して描画されていることを示しており、プログラム内の描画シーケンスを見直すべきだと分かります。 Show GPU overdraw の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Drawing → Show GPU overdraw)。 Profile GPU rendering: 60FPS で描画できている調べる 開発者オプションで Profile GPU rendering の機能を有効にすると、描画フレームごとに UI スレッドでかかった時間を画面上にバー表示することができます。 緑色のラインは 16.6ms を示しており、このラインを超えるということは 60 FPS で描画できていないということです。メインスレッド上で描画以外の処理を行っていないか見直す必要があります。 Profile GPU rendering の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Monitoring → Profile GPU rendering)。 StrictMode: メインスレッドでの I/O アクセスなどを検出する メインスレッドの処理時間は、UI レスポンスに直接影響を与えるため、I/O アクセスなどの短時間に完了することが保証されない処理はメインスレッド上で実行すべきではありません。 Android には、このようなメインスレッド上で実行すべきではない処理を検出するための StrictMode（厳格モード） が用意されています。 StrictMode の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Monitoring → Strict mode enabled)。 StrictMode は、このように Android の設定から有効にすることもできますし、アプリのコード上で有効にすることもできます。 コード上で StrictMode を有効にすることで、より柔軟な検出方法を設定することができます。 例えば、問題のある処理 (policy violation) が実行されたときに、LogCat のログ上にその呼び出し情報（コールスタックなど）を表示したりできます。 本格的にパフォーマンス改善を進めるときには、このログ出力を頼りにすれば、ぬるぬるサクサクなアプリケーションを作成することができます。"},{url:"/p/9yse3iz/",title:"ADB で指定したアプリを強制終了する (am force-stop)",date:"2016-06-06T00:00:00Z",body:"ADB で指定したアプリを強制終了する (am force-stop) Android 端末に ADB 接続された状態で adb shell am force-stop コマンドを実行すると、任意のアプリケーションを強制終了することができます。 $ adb shell am force-stop com.example.myapp adb shell 接続されている状態であれば、adb shell の部分は省略して実行します。 generic_x86:/ $ am force-stop com.example.myapp ちなみに、インストールされているアプリのパッケージ名一覧は adb shell pm list packages で調べることができます（こちらは am じゃなくて pm コマンドであることに注意してください）。 参考: ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)"},{url:"/p/3tip9yp/",title:"CSS で画像と埋め込み動画のサイズを画面内に収める (max-width)",date:"2016-05-01T00:00:00Z",body:"CSS で画像と埋め込み動画のサイズを画面内に収める (max-width) 画像の最大幅を設定する (max-width) 画像や埋め込み動画を表示するときに、そのままのサイズで表示すると、画面サイズを縮めた場合に、画面内に収まらなくなってしまいます。 次のように max-width を指定しておくと、ブラウザのウィンドウサイズを変更したときや、モバイル端末のような小さな画面サイズで表示したときも、ちゃんと画面内に収まるように表示されます。 img, embed, iframe, object { max-width: 100%; } デモ（別ページで開く） 上記のフレームをブラウザだと思ってサイズを縮めてみてください。 表示領域のサイズ変更に連動して画像サイズも縮小されて表示されるはずです。 画面幅に応じて画像を拡大表示する 逆に、画面（ブラウザ）のサイズを広げた場合は、もともとの画像のサイズ以上の大きさでは表示されません。 画面（ブラウザ）のサイズを広げたときに、そのサイズに連動して拡大して表示したいのであれば、max-width プロパティではなく、単純に width プロパティに 100% 指定します。 img { width: 100%; /* 横幅いっぱいに画像を広げて表示 */ } 横幅いっぱいにまで広げてしまうとさすがに大きすぎるけれど、ある程度まで（例えば、横幅の 80% くらいまで）は広げたいという場合は、min-width を指定することで、「少なくともこのサイズまでは拡大して表示する」、という意味になります。 下記の例ではパーセンテージで横幅を指定していますが、px 単位でも指定することができます。 img { min-width: 80%; max-width: 100%; /* 下記は中央寄せ設定 */ display: block; margin-left: auto; margin-right: auto; } デモ（別ページで開く）"},{url:"/p/ewvaoe3/",title:"Git で他の人が作成したブランチ上で作業する",date:"2016-04-05T00:00:00Z",body:"Git で他の人が作成したブランチ上で作業する GitHub などの共有リポジトリを使用して複数のメンバーで開発を進めている場合、他のメンバーが作成したブランチ（git push されたブランチ）をチェックアウトして共同作業したいことがあります。 そのような場合は、下記のような手順でローカルブランチを作成して編集作業を進めます。 共有リポジトリに push されているブランチをフェッチする (git fetch) 作業用のローカルブランチを作成する (git branch) ローカルブランチをチェックアウトして編集作業を行う (git checkout, git commit) 変更内容を共有リポジトリに push する (git push) 共有リポジトリに push されているブランチをフェッチする まずは、他の人が共有リポジトリ上に作成したブランチをローカルに持ってくる必要があります（--prune オプションを付けると、共有リポジトリ側で削除されているブランチをローカルからも削除してくれます）。 $ git fetch --prune リモートトラッキングブランチの一覧を表示し、対象のブランチをうまく fetch してこれたかを確認しておきます。 $ git branch -r origin/HEAD -\u0026gt; origin/main origin/change-date-format origin/fix-lint-warnings origin/main リモートトラッキングブランチ名は、\u0026lt;リポジトリ\u0026gt;/\u0026lt;ブランチ\u0026gt; という構成になっていますが、clone 元のリポジトリ名は origin というエイリアス名で指定できるようになっています。 作業用のローカルブランチを作成する リモートトラッキングブランチは、あくまでリモートリポジトリ側の内容を追跡するためのものなので、ここに直接修正を加えていくことはできません。 そこで、リモートトラッキングブランチをベースにして、ローカルブランチを作成する必要があります。 次の例では、リモートトラッキングブランチ origin/change-date-format と同名の change-date-format というローカルブランチを作成しています。 $ git branch change-date-format origin/change-date-format Branch \u0026#39;change-date-format\u0026#39; set up to track remote branch \u0026#39;change-date-format\u0026#39; from \u0026#39;origin\u0026#39;. 次のようにして、正しくローカルブランチが作成されていることを確認しておきます。 $ git branch change-date-format * main ローカルブランチをチェックアウトして編集作業を行う あとは、普段通りブランチをチェックアウトして編集作業を行い、コミットしていけば OK です。 $ git checkout change-date-format （編集…） $ git commit 変更内容を共有リポジトリに push する ローカルブランチでの変更作業が終了したら、共有リポジトリ（GitHub など）へ git push して、他のメンバーに編集内容を共有します。 $ git push origin change-date-format ちなみに、リモートトラッキングブランチから作成したブランチの内容を git push する場合は、-u (--set-upstream) オプションを指定してブランチ名を対応付ける必要はありません。 ブランチを作成した時点で、どのリモートブランチと対応付けるべきかが分かっているからです。"},{url:"/p/xikzhtr/",title:"GitHub の Markdown でメールアドレスへのリンクを記述する",date:"2016-02-04T00:00:00Z",body:"GitHub の Markdown でメールアドレスへのリンクを記述する Markdown ファイルの中で、E メールアドレスのリンクを記述するには下記のようにします。 Markdown ファイル抜粋 [表示名](\u0026lt;mailto:xxx@example.com\u0026gt;) 上記のように \u0026lt; と \u0026gt; で囲んだメールアドレスは、出力される HTML の中では、下記のように実体参照による表現に変換されるため、スパムメールの対策にもなります。 変換後の HTML \u0026lt;a href=\u0026#34;\u0026amp;#109;\u0026amp;#097;\u0026amp;#105;\u0026amp;#108;\u0026amp;#116;\u0026amp;#111;:\u0026amp;#120;\u0026amp;#120;\u0026amp;#120;\u0026amp;#064;\u0026amp;#101;\u0026amp;#120;\u0026amp;#097;\u0026amp;#109;\u0026amp;#112;\u0026amp;#108;\u0026amp;#101;\u0026amp;#046;\u0026amp;#099;\u0026amp;#111;\u0026amp;#109;\u0026#34;\u0026gt;表示名\u0026lt;/a\u0026gt; 実際の表示結果は次のような感じになります。 表示名"},{url:"/p/tq3zi5j/",title:"CSS のフレキシブルボックスによるレスポンシブレイアウト",date:"2016-01-01T00:00:00Z",body:"CSS のフレキシブルボックスによるレスポンシブレイアウト CSS のフレキシブルボックスレイアウト機能を利用すると、下記の様な段組レイアウトを簡単に作成することができます。 図: 幅が広いときはサイドバーを表示 HTML \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;sidebar1\u0026#34;\u0026gt;Sidebar 1\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;Main\u0026lt;br\u0026gt;Main\u0026lt;br\u0026gt;Main\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;sidebar2\u0026#34;\u0026gt;Sidebar 2\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; CSS #container { /* フレキシブルボックスレイアウトによる段組 */ display: flex; } #sidebar1, #sidebar2 { width: 100px; background: pink; } #main { /* 画面幅が広い時はこの要素の横幅を拡張する */ flex-grow: 1; background: cyan; } 参考: （旧）フレキシブルボックスの旧式の定義方法 さらに、メディアクエリを利用して、画面幅が一定サイズ以下になったときに、このフレキシブルボックスレイアウトを解除することができます。 例えば、スマートフォンなどで表示する場合に、サイドバーを縦に並べたり、省略してもよいサイドバーを非表示にしたりできます。 下記の例では、画面幅が 400px 以下になった場合にフレキシブルボックスレイアウトを解除し、sidebar1 を横幅いっぱいで表示し、sidebar2 を非表示にしています。 図: 幅が狭いときは縦に並べる /* * レスポンシブデザイン対応。 * 幅が狭い場合は sidebar1 を横幅いっぱいに表示する。 * sidebar2 は非表示にする。 */ @media screen and (max-width: 400px) { #container { display: block; } #sidebar1 { width: auto; } #sidebar2 { display: none; } } JSFiddle で試す 上記の例では、サイドバーを表示するレイアウトをデフォルトのスタイルとして定義しましたが、モバイルファーストの考えを採用するのであれば、幅が狭い場合のレイアウト（縦に並べるレイアウト）をデフォルトのスタイルとして定義してください。 参考: モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし）"},{url:"/p/bz3ga84/",title:"CSS で画像の下に隙間が空くのを防ぐ (vertical-align)",date:"2015-12-07T00:00:00Z",body:"CSS で画像の下に隙間が空くのを防ぐ (vertical-align) img 要素の下にくっつけて別の要素を配置しようとしても、デフォルトではどうしても隙間が空いてしまいます。 HTML 抜粋 \u0026lt;img src=\u0026#34;tree.png\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;img src=\u0026#34;tree.png\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;img src=\u0026#34;tree.png\u0026#34;\u0026gt; 図: 画像の下に隙間ができてしまう例（別ページで開く） これは、img 要素はテキストと同様にベースラインを意識した配置が行われるからです。 下記のように vertical-align プロパティを bottom に設定しておけば、隙間をなくすことができます。 CSS img { vertical-align: bottom; } 図: 画像の下の隙間をなくした例（別ページで開く） この問題が発生しない場合は、プロジェクトで使用しているリセット系の CSS に、すでに上記のような定義が含まれている可能性が高いです。"},{url:"/p/5zj72ei/",title:"Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve)",date:"2015-11-19T00:00:00Z",body:"Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve) urllib.request によるファイルのダウンロード urllib.request.urlretrieve を使用すると、簡単に Web 上のファイルをダウンロードしてローカルファイルとして保存することができます。 urllib.request.urlretrieve 関数 下記の download_file 関数は、指定した URL のファイルをカレントディレクトリにダウンロードします。 import urllib.request import os.path def download_file(url): filename = os.path.basename(url) or \u0026#39;index.html\u0026#39; urllib.request.urlretrieve(url, filename) if __name__ == \u0026#39;__main__\u0026#39;: download_file(\u0026#39;https://example.com/\u0026#39;) ローカルに作成されるファイル名は、os.path.basename を使用して、URL の末尾から切り出しています。 URL の末尾にファイル名らしきものが見つからない場合は、デフォルトファイル名として index.html で保存するようにしています。 テンポラリファイルとしてダウンロードする urllib.request.urlretrieve の 2 番目のパラメータ (filename) を省略すると、テンポラリディレクトリに適当なファイル名で保存されます。 このファイルパスは、戻り値で返されるタプルの先頭に格納されています。 path, headers = urllib.request.urlretrieve(\u0026#39;http://example.com/sample.png\u0026#39;) print(path) #=\u0026gt; c:\\users\\maku\\appdata\\local\\temp\\tmpgujizj urlretrieve により作成された一時ファイルを確実に削除するには、下記のように後始末しておきます。 urllib.request.urlcleanup() このファイルはテンポラリディレクトリに作成されるファイルなので、それほど厳密に削除する必要はないかと思いますが、大量のテンポラリファイルが作られるような場合は実行しておいた方がよいでしょう。 ダウンロード時の HTTP レスポンスヘッダの取得 urllib.request.urlretrieve により、ファイルをダウンロードした際に、ついでに HTTP レスポンスヘッダを取得したい場合 は、下記のように 戻り値のタプルの 2 番目の要素 から取得できます。 path, headers = urllib.request.urlretrieve(\u0026#39;https://www.google.co.jp/images/nav_logo242_hr.png\u0026#39;) for key, val in headers.items(): print(\u0026#39;{0} ===\u0026gt; {1}\u0026#39;.format(key, val)) 実行結果 Content-Type ===\u0026gt; image/png Date ===\u0026gt; Thu, 19 Nov 2015 04:41:09 GMT Expires ===\u0026gt; Thu, 19 Nov 2015 04:41:09 GMT Cache-Control ===\u0026gt; private, max-age=31536000 Last-Modified ===\u0026gt; Thu, 22 Oct 2015 17:33:49 GMT X-Content-Type-Options ===\u0026gt; nosniff Server ===\u0026gt; sffe Content-Length ===\u0026gt; 39373 X-XSS-Protection ===\u0026gt; 1; mode=block Alternate-Protocol ===\u0026gt; 443:quic,p=1 Alt-Svc ===\u0026gt; quic=\u0026#34;www.google.com:443\u0026#34;; p=\u0026#34;1\u0026#34;; ma=600,quic=\u0026#34;:443\u0026#34;; p=\u0026#34;1\u0026#34;; ma=600 Connection ===\u0026gt; close"},{url:"/p/4yiygwe/",title:"Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler)",date:"2015-11-19T00:00:00Z",body:"Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler) urllib.request モジュールを使って Basic 認証の設定された Web サイトにアクセスすると、デフォルトでは下記のようなエラーが発生します。 Basic 認証エラー urllib.error.HTTPError: HTTP Error 401: Authorization Required HTTPBasicAuthHandler を使用すると、各 Web サイトにアクセスするときのユーザ名と、パスワード情報を設定することができます。 具体的には、Basic 認証のかかった Web サイトにアクセスした場合に Web サーバから返される realm 情報 と、ベースとなる URI 情報 に対して、使用するユーザ名とパスワードを関連付けます。 下記のサンプルでは、http://example.com/secret/ 以下にアクセスする際に、Basic 認証のユーザ名、パスワードとして、user1、pass1 を利用するように設定しています。 ここでは、realm 情報は無視し、URI 情報だけに関連付けるようにするため、HTTPPassswordMgrWithDefaultRealm を使用しています。 Basic 認証の付いたサイトにアクセスする import urllib.request import os.path def setup_basic_auth(base_uri, user, password): password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password( realm=None, uri=base_uri, user=user, passwd=password) auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr) opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) def download_file(url): filename = os.path.basename(url) or \u0026#39;index.html\u0026#39; print(\u0026#39;Downloading ... {0} as {1}\u0026#39;.format(url, filename)) urllib.request.urlretrieve(url, filename) if __name__ == \u0026#39;__main__\u0026#39;: setup_basic_auth(\u0026#39;http://example.com/secret/\u0026#39;, \u0026#39;user1\u0026#39;, \u0026#39;pass1\u0026#39;) download_file(\u0026#39;http://example.com/secret/sample.zip\u0026#39;)"},{url:"/p/6vpyp4z/",title:"Python で指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob)",date:"2015-10-30T00:00:00Z",body:`Python で指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob) 指定した拡張子を持つファイルを列挙する ここでは、Python でカレントディレクトリ以下の .java ファイルを列挙する例を示します。 glob を使用する方法（オススメ） glob.iglob 関数や glob.glob 関数を使用すると、いわゆるグロブ（シェルのワイルドカード）によるパターン指定でファイルを列挙することができます。 glob.iglob はジェネレーターで、glob.glob は通常の関数です。 つまり、glob.iglob は for ループでイテレート処理したいとき、glob.glob はリストで取得したいときに使います。 glob.iglob でファイル列挙 import glob for name in glob.iglob(\u0026#34;*.java\u0026#34;): print(name) Python 3.5 以降では、ディレクトリを再帰的にたどるための ** も使用できます。 この場合は recursive パラメータを True に設定します。 glob.iglob で再帰的なファイル列挙 import glob for name in glob.iglob(\u0026#34;**/*.java\u0026#34;, recursive=True): print(name) 実はオブジェクト指向的な方法でファイルパスを扱うための pathlib.Path クラス にも glob メソッドが用意されていて、同様の方法でファイルパスを列挙できます。 この glob メソッドは glob.glob 関数とは異なり、再帰的にディレクトリをたどるようにデフォルトで設定されており、ジェネレーターを返すようになっています。 ややこしいですね。 Path#glob メソッドで再帰的なファイル列挙 from pathlib import Path for name in Path(\u0026#34;.\u0026#34;).glob(\u0026#34;**/*.java\u0026#34;): print(name) os.walk を使用する方法 glob を使用せずに、os.walk などを使用して自力でファイルを検索することもできます。 ここでは、os.walk ですべてのファイルを再帰的に列挙しつつ、fnmatch.fnmatch を使って指定した拡張子に一致するかを調べています。 os.walk で再帰的に .java ファイルを列挙 import fnmatch import os for dirpath, dirs, files in os.walk(\u0026#34;.\u0026#34;): for name in files: if fnmatch.fnmatch(name, \u0026#34;*.java\u0026#34;): print(os.path.join(dirpath, name)) 実は、glob.iglob の実装もこのように os.walk や fnmatch を組み合わせて実装されています。 指定した名前に完全に一致するファイルを検索する ファイル名が完全に一致するファイルを検索したい場合も、glob.iglob を使って検索することができます。 ファイルを１つだけ見つけたい場合は、下記のようにループを break で抜けてしまえばよいでしょう。 カレントディレクトリ以下から指定した名前のファイルを検索 import glob for name in glob.iglob(\u0026#34;**/SampleApp.java\u0026#34;, recursive=True): print(name) break 応用例: 指定した拡張子を持つファイルを grep する 下記の Python スクリプトは、カレントディレクトリ以下のすべての .java ファイルの内容を読み込み、import で始まる行を抽出して出力します。 extract_imports.py（.java ファイル内の import 行を抽出） import glob for filename in glob.iglob(\u0026#34;**/*.java\u0026#34;, recursive=True): with open(filename, encoding=\u0026#34;utf-8\u0026#34;) as f: for i, line in enumerate(f, start=1): if line.startswith(\u0026#34;import \u0026#34;): print(\u0026#34;{} [{}]: {}\u0026#34;.format(filename, i, line.rstrip(\u0026#34;\\r\\n\u0026#34;))) 実行結果 $ python extract_imports.py com/example/myapp/Main.java [1]: import java.util.concurrent.Callable; com/example/myapp/Main.java [2]: import java.util.concurrent.ExecutionException; com/example/myapp/Main.java [3]: import java.util.concurrent.FutureTask; com/example/myapp/Db.java [1]: import java.sql.Connection; com/example/myapp/Db.java [2]: import java.sql.PreparedStatement; ...`},{url:"/p/prbp2g2/",title:"CSS のフローティングボックス (float) を利用したレイアウトを理解する",date:"2015-10-25T00:00:00Z",body:"CSS のフローティングボックス (float) を利用したレイアウトを理解する float プロパティにより後続要素を回りこませる CSS の float プロパティには次のような値を指定することができます。 float: none; /* デフォルト */ float: left; /* フローティングボックスを構成して左端に配置 */ float: right; /* フローティングボックスを構成して右端に配置 */ float プロパティに left を設定すると、その要素は左端に表示され、後続の要素はその反対側（この場合は右側）に回り込んで表示されるようになります。 float を指定しない場合 float: none; デフォルトでは、ブロック要素の後続の要素は別の段落に表示さます。 float: left を指定した場合 float: left; float プロパティに left や right を指定すると、後続の要素は、 回り込んで表示されるようになります。 フローティングボックスの形成 float プロパティに left や right を設定した場合、その要素は フローティングボックス を形成します。 後続の要素は、フローティングボックスが存在しないとして配置されるので、横幅いっぱいのサイズが確保されます。 下記の例は、後続要素に青色の背景色を付けたサンプルです。 float: left; フローティングボックスは 後続要素から見ると あたかもそこには存在しない かのように配置されます。 後続要素の横幅は、フローティングボックスに重なる形で画面いっぱいのサイズになっていることが分かります。 この場合でも、実際に表示されるテキストは重ならないように考慮して描画されることになっています。 フローティングボックスの回りこみの解除 (clear) フローティングボックスの後続の要素は、フローティングボックスに対して回りこむように配置されていきます。 その回りこみを解除して、新しい段落に表示したい場合は、clear プロパティを指定します。 clear: none; /* 回りこみを解除しない（デフォルト） */ clear: left; /* 左側のフローティングボックスへの回りこみを解除 */ clear: right; /* 右側のフローティングボックスへの回りこみを解除 */ clear: both; /* 全てのフローティングボックスへの回りこみを解除 */ clear を指定しない場合 float: left; 後続の 1 つ目の要素 後続の 2 つ目の要素 clear: left; を指定した場合 float: left; 後続の 1 つ目の要素 後続の 2 つ目の要素 (clear: left;) CSS の float プロパティは、この clear 指定を後続の要素に対して指定する必要があるため、レイアウトが難しくなってしまうという欠点があります。 段組を構成したい場合は、CSS3 のグリッドレイアウトやマルチカラムの仕組みを使うことで、よりシンプルにレイアウトを作成することができます。 連続するフローティングボックス float:left を連続して配置 float: left; を設定した要素を連続して配置すると、それら全てのフローティングボックスを回りこむように後続の要素が配置されます。 float: left; float: left; 連続するフローティングボックス が配置されていると、 後続の要素は、 それらすべてを回りこむように配置されます。 float:left と float:right を配置 float プロパティを left に設定した要素と、right に設定した要素を連続して配置すると、それぞれ左側と右側にフローティングボックスが配置されます。 float: left; float: right; 左右にそれぞれフローティングボックスを配置することもできます。 この構成は、昔はサイトヘッダーやサイドバーの表示のためによく使われましたが、現在では代わりにフレックスボックスレイアウトが使われることが多くなっています。"},{url:"/p/xwxdv6y/",title:"Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当）",date:"2015-10-21T00:00:00Z",body:"Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当） Git はファイルの所有者情報なのどメタ情報を管理しませんが、ファイルの実行可能ビットだけは記録する ようになっています（Linux の chmod +x で付加するビット）。 例えば、Windows 上で Linux のシェルスクリプトを作成していて、Git リポジトリにコミットするときは、次のように git update-index コマンドで実行可能ビットを付加してからコミットしなければいけません。 シェルスクリプトに実行可能ビットを付ける $ git update-index --add --chmod=+x \u0026lt;filename\u0026gt; $ git commit Linux 上で作業する場合は、chmod +x で付加した情報が反映されるので、通常通り git add でファイルを追加するだけで OK です。"},{url:"/p/8k5m4k2/",title:"ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk)",date:"2015-10-09T00:00:00Z",body:"ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk) Android SDK に付属している android コマンドの list sdk サブコマンドを使用すると、追加でインストール可能な SDK コンポーネントの一覧を取得することができます。 インストール可能な SDK コンポーネント $ android list sdk --no-ui --all --extended ... ---------- id: 157 or \u0026#34;extra-google-usb_driver\u0026#34; Type: Extra Desc: Google USB Driver, revision 11 By Google Inc. USB Driver for Windows, revision 11 Install path: extras\\google\\usb_driver ---------- id: 158 or \u0026#34;extra-google-webdriver\u0026#34; Type: Extra Desc: Google Web Driver, revision 2 By Google Inc. WebDriver Install path: extras\\google\\webdriver ---------- id: 159 or \u0026#34;extra-intel-Hardware_Accelerated_Execution_Manager\u0026#34; Type: Extra Desc: Intel x86 Emulator Accelerator (HAXM installer), revision 5.5 By Intel Corporation Emulation speedup using Intel? VT processor technology. Read more at www.intel.com/software/android Install path: extras\\intel\\Hardware_Accelerated_Execution_Manager 例えば、以下のようなコンポーネントがリストアップされます。 実行結果の抜粋 id: 4 or \u0026#34;build-tools-23.0.1\u0026#34; id: 25 or \u0026#34;android-23\u0026#34; id: 64 or \u0026#34;sys-img-armeabi-v7a-android-tv-23\u0026#34; id: 100 or \u0026#34;addon-google_apis-google-23\u0026#34; id: 133 or \u0026#34;source-23\u0026#34; id: 143 or \u0026#34;extra-Sony-DeviceProfiles\u0026#34; id: 145 or \u0026#34;extra-android-support\u0026#34; id: 157 or \u0026#34;extra-google-usb_driver\u0026#34;"},{url:"/p/494ernf/",title:"GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する",date:"2015-10-01T00:00:00Z",body:"GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する GitHub の Organization アカウントの新しいパーミッションモデルが公開されました。 参考: New organization permissions now available - The GitHub Blog チームメンテナの設定が可能 チーム内のメンバーに対して、team maintainer という役割を設定できるようになりました（念願！）。 これまでは、各チームに対するメンバー追加を行うときは、Organization の Owners メンバーが追加作業を行う必要がありましたが、この機能によって、チーム内のメンバー管理は、そのチームの代表者 に任せることができるようになります。 チーム内のメンバーを team maintainer に割り当てるには次のようにします。 Organization のトップページから Teams を選択 対象のチームを選択 チームメンテナに設定したいメンバーを選択し、\u0026ldquo;Change role\u0026hellip;\u0026rdquo; → \u0026ldquo;Maintainer\u0026rdquo; を選択 チームメンテナとなったメンバーは、自分の管理するチームに対して、自由にメンバーを参加させたり外したりできます。 チーム名の変更や、チーム内メンバーのチームメンテナへの昇格も自由に行えるようになるため、ある程度責任のあるリーダクラスの人をチームメンテナとして設定すべきです。 参考: Giving \u0026ldquo;team maintainer\u0026rdquo; permissions to an organization member Organization 内のリポジトリに対するデフォルトパーミッションを設定可能 デフォルトパーミッションとして Read/Write 権限を付加しておくことで、Organization 内のメンバー全員に対して、すべてのプロジェクト（リポジトリ）の参照権限、コミット権限を付けることができます。 例えば、直接コミットできるメンバーはプロジェクトごとに限定したいけれど、コードの参照や PullRequest くらいは全メンバーに許可したい、ということが簡単に実現できます（これまでは、プロジェクトに対する参照権限を与えるために、対象のユーザを Read 権限のあるチームに追加させ、そのチームをプロジェクトに登録する、という分かりにくい作業が必要でした）。 メンバー全員に全リポジトリの参照権限を付けるには以下のようにします。 Organization のトップページから Settings を選択 Member privileges を選択 Base permissions の項目を No permission から Read に変更 全メンバーが全プロジェクトの開発に関わっているような Organization では、デフォルトのパーミッションとして Write を設定しておけば、アクセス権限管理のためにチームを作成する必要がなくなります。 チームをまたいだコラボレーションが可能 Organization 内の別のチームのメンバーに対しても自由にコメントできるようになりました（推奨設定: ON）。 PullRequest や Issue などで議論する際に、別のチームのメンバーに対しても @name の形式で通知 できます。 従来のチームの Visible 設定は Secret になっているので、チーム間のコラボレーションを可能にするために、Visible 設定を Visible に変更する必要があります。 Organization のトップページから Teams を選択 対象のチームを選択 Settings ボタンをクリック Team visibility 設定を Visible に変更 メンバーごとのアクセス権を確認可能 各メンバーが、それぞれのリポジトリに対してどのようなアクセス権限（Admin/Write/Read) を持っているかを、一覧で確認することができるようになりました。 Organization のトップページから People を選択 対象のユーザの設定ボタン → Manage を選択 参考: Managing an individual\u0026rsquo;s access to an organization repository Organization 内のリポジトリの作成権限を追加 Owners メンバーでなくても、Organization 内にプロジェクトを自由に作成することができるようになりました。 Organization のトップページから Settings を選択 Member privileges を選択 Repository creation で必要に応じて下記にチェックを入れる Public \u0026hellip; パブリックなリポジトリの作成を許可する Private \u0026hellip; プライベートなリポジトリの作成を許可する Billing information などの管理はさせたくないけれど、プロジェクト作成くらいは各メンバーに自由にさせたいような場合に有効です。 Organization 外のメンバーをプロジェクトメンバーに追加することが可能 今までは、Organization 内のリポジトリ（プロジェクト）に対するアクセス権限は、Organization 内のチーム単位で与える仕組みでしたが、個人単位、かつ、Organization 外のユーザに対しても権限を与えることができるようになりました。 Organization のトップページから Repositories を選択し、対象のリポジトリをクリック プロジェクトの Settings を選択 Collaborators and teams を選択 Collaborators に GitHub のアカウント名やメールアドレスを指定して追加 この機能を使用すると、Private なリポジトリに対しても外部のユーザからのアクセスを許可できてしまうので、Confidential な情報を扱っている場合は注意して設定する必要があります。 ちなみに、Organization 外のメンバーとして誰が登録されているかは、People 一覧のページの Outside collaborators というところから確認できます。"},{url:"/p/ta2kimu/",title:"Viewport とメディアクエリによるレスポンシブ Web デザインの基本",date:"2015-09-22T00:00:00Z",body:"Viewport とメディアクエリによるレスポンシブ Web デザインの基本 Web サイトのレイアウトは、様々な端末、画面サイズで表示されることを想定して作成しなければいけません。 スマホやタブレット、テレビのように物理的に画面サイズが異なることもありますし、PC 上の Web ブラウザのように、ウィンドウサイズがユーザによって自由に変更されることもあります。 スマホやタブレットに備えられている Viewport の機能や、CSS3 の メディアクエリ の仕組みを利用すると、こういった様々な条件での表示に、柔軟に対応することができます。 Viewport の設定 Viewport はスマホなどの物理的に画面が小さいモバイル端末に備えられている機能で、Web ページを部分的に表示するための仮想画面を提供する機能です。 Viewport 設定は、head セクション内に配置する meta 要素で行います。 基本的な viewport 設定 \u0026lt;head\u0026gt; \u0026lt;!-- 省略 --\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; content 属性内で width=device-width と設定しておくことにより、デバイスごとに設定された仮想的な横幅 (device-width) が、Viewport の幅として設定されます。 つまり、デバイスの画面サイズに合わせてコンテンツを表示します。 デバイスの幅に合わせることで、ユーザーがズーム操作をせずにコンテンツを見ることができるようになります。 スマホの場合は、device-width は、320 〜 360px 程度に設定されていることが多いようです（参考サイト）。 この横幅は、後述するメディアクエリの width 判定にも影響します。 initial-scale はページが最初に読み込まれたときのズームレベルで、0 〜 10 の間で指定します。 initial-scale=1 は、通常のズームレベルでページを表示することを意味します。 これにより、ユーザーがページを開いたときにズームアウトまたはズームインする必要がなくなります。 メディアクエリの設定 CSS3 のメディアクエリの仕組みを使用すると、画面の表示サイズに応じて CSS を切り替えることができます。 CSS /* デフォルトのスタイル（300px 未満） */ body { background: pink; } /* 画面幅が 300px 以上の場合のスタイル */ @media screen and (min-width: 300px) { body { background: lightblue; } } /* 画面幅が 600px 以上の場合のスタイル */ @media screen and (min-width: 600px) { body { background: lightgreen; } } （別ページで開く） 上記の例では、画面の幅が 300px 以上になったとき、600px 以上になったときに背景色を変更しています。 1px ～ 299px \u0026hellip; 赤 (pink) 300px ～ 599px \u0026hellip; 青 (lightblue) 600px ～ \u0026hellip; 緑 (lightgreen) この仕組みを使って、画面サイズが変更されたときにレイアウトを変更することで、レスポンシブ Web デザインを実現できます。 CSS 内の @import ディレクティブでもメディアタイプを指定することができます。 TV 上での表示あるいは印刷時の CSS を指定 @import url(\u0026#34;tv_and_print.css\u0026#34;) tv, print; link 要素で外部の CSS ファイルを読み込む場合も、メディアクエリで CSS を切り替えることができます。 /* 画面表示用 or 印刷用 */ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;screen\u0026#34; href=\u0026#34;screen.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;print\u0026#34; href=\u0026#34;print.css\u0026#34;\u0026gt; /* 横幅別 */ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;(max-width: 960px)\u0026#34; href=\u0026#34;max960px.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;(max-width: 320px)\u0026#34; href=\u0026#34;max320px.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;screen and (max-width: 480px)\u0026#34; href=\u0026#34;mobile.css\u0026#34; /\u0026gt; /* 縦表示 or 横表示 */ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;(orientation: portrait)\u0026#34; href=\u0026#34;portrait.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;(orientation: landscape)\u0026#34; href=\u0026#34;landscape.css\u0026#34;\u0026gt; /* カラー or 白黒 */ \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;screen and (color)\u0026#34; href=\u0026#34;color.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;screen and (monochrome)\u0026#34; href=\u0026#34;mono.css\u0026#34; /\u0026gt; 参考リンク: Media Queries - W3C"},{url:"/p/8x8qmy3/",title:"protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions)",date:"2015-08-04T00:00:00Z",body:"protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions) pm list permissions コマンドに -d オプションを付けて実行すると、protectionLevel が dangerous に設定されたパーミッションのみを一覧表示してくれます。 Android M からは、dangerous なパーミッションはユーザが個別に On/Off することができるようになったため、どのようなパーミッションが存在しているのかを把握することがより重要になりました。 shell@xxx:/ $ pm list permissions -d Dangerous Permissions: permission:com.android.providers.tv.permission.READ_EPG_DATA permission:com.android.providers.tv.permission.WRITE_EPG_DATA adb shell で接続する前に実行する場合は、上記のコマンドの先頭に adb shell を付けて実行してください。"},{url:"/p/viry8fo/",title:"パーミッショングループの一覧を表示する (pm list permission-groups)",date:"2015-08-04T00:00:00Z",body:"パーミッショングループの一覧を表示する (pm list permission-groups) パーミッショングループの一覧 Android 端末内にどのようなパーミッショングループが存在しているかを調べるには、adb shell で接続した後に pm list permission-groups コマンドを使用します。 shell@xxx:/ $ pm list permission-groups permission group:android.permission-group.PHONE_CALLS permission group:android.permission-group.WALLPAPER permission group:android.permission-group.MESSAGES permission group:android.permission-group.USER_DICTIONARY permission group:android.permission-group.CALENDAR permission group:android.permission-group.BLUETOOTH_NETWORK ... adb shell で接続前に実行したい場合は、下記のように adb shell に続けてコマンド入力しても OK です。 ホスト側の PC で出力を sort したい場合などはこちらの方が便利かもしれません。 $ adb shell pm list permission-groups | sort permission group:android.permission-group.ACCESSIBILITY_FEATURES permission group:android.permission-group.ACCOUNTS permission group:android.permission-group.AFFECTS_BATTERY permission group:android.permission-group.APP_INFO permission group:android.permission-group.AUDIO_SETTINGS permission group:android.permission-group.BLUETOOTH_NETWORK ... パーミッショングループに属するパーミッションの一覧 それぞれのパーミッショングループが、どのようなパーミッションから構成されているかを調べるには、pm list permissions -g コマンドを使用します。 shell@xxx:/ $ pm list permissions -g All Permissions: group:android.permission-group.PHONE_CALLS permission:android.permission.BIND_INCALL_SERVICE permission:android.permission.READ_PRECISE_PHONE_STATE permission:android.permission.BIND_CONNECTION_SERVICE ... group:android.permission-group.WALLPAPER permission:android.permission.SET_WALLPAPER permission:android.permission.SET_WALLPAPER_HINTS ..."},{url:"/p/nqz8fnu/",title:"Python で HTML をパースする (HTMLParser)",date:"2015-05-18T00:00:00Z",body:"Python で HTML をパースする (HTMLParser) HTMLParser で HTML を処理する Python に標準搭載されている HTML パーサである html.parser.HTMLParser は、イベントドリブンな HTML パーサです。 HTMLParser クラスを継承して独自のパーサを作成し、feed メソッドに HTML テキストを渡すことによってパースを開始します。 下記のサンプルコードでは、開始タグ、終了タグ、テキストデータ、コメントが見つかったときに、それぞれ内容を出力しています。 sample.py from html.parser import HTMLParser # HTMLParser を継承してパーサクラスを作成する class MyParser(HTMLParser): def handle_starttag(self, tag, attrs): print(\u0026#34;START :\u0026#34;, tag, attrs) def handle_endtag(self, tag): print(\u0026#34;END :\u0026#34;, tag) def handle_data(self, data): print(\u0026#34;DATA :\u0026#34;, data) def handle_comment(self, comment): print(\u0026#34;COMMENT:\u0026#34;, comment) # パーサのインスタンスを生成してパースを実行 parser = MyParser() parser.feed(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026#39; \u0026#39;\u0026lt;div class=\u0026#34;class1\u0026#34; id=\u0026#34;id1\u0026#34;\u0026gt;Hello World\u0026lt;/div\u0026gt;\u0026#39; \u0026#39;\u0026lt;!-- I am a comment --\u0026gt;\u0026#39; \u0026#39;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;) 実行結果 START : html [] START : body [] START : div [(\u0026#39;class\u0026#39;, \u0026#39;class1\u0026#39;), (\u0026#39;id\u0026#39;, \u0026#39;id1\u0026#39;)] DATA : Hello World END : div COMMENT: I am a comment END : body END : html HTMLParser は、単純に HTML 要素を前から順番に処理していくだけなので、現在の要素がどのようなコンテキストで記述されているかは、パーサクラス内で判断していくように実装する必要があります。 ローカルの HTML ファイル、Web 上の HTML ファイルを扱う場合 ローカルファイルの内容は、Python 標準の open 関数で読み込むことができます。 ローカルの HTML ファイル text = open(\u0026#39;input.html\u0026#39;).read() Web 上の HTML ファイルの内容も、requests モジュールなどで簡単に読み込めます。 Web 上の HTML ファイル import requests text = requests.get(\u0026#39;http://example.com/\u0026#39;).text あとは、取得した HTML テキストを HTMLParser#feed() に渡してやれば OK です。"},{url:"/p/r7q8q7o/",title:"Python の requests パッケージによる HTTP リクエストの例",date:"2015-05-18T00:00:00Z",body:"Python の requests パッケージによる HTTP リクエストの例 参考: requests パッケージのチートシート requests パッケージのインストール オープンソースの requests パッケージ を使用すると、Python 3 標準の urllib.request よりも簡単に HTTP リクエストを扱うことができます。 例えば、以下のような処理をシンプルなコードで扱うことができます。 Basic 認証、ダイジェスト認証 ファイルのアップロード クッキー SSL 検証 エンコーディング形式の自動判別 コンテンンツが圧縮されていた場合の自動展開 requests パッケージは、pip コマンドで簡単にインストールできます。 request パッケージのインストール $ pip install requests requests モジュールによる HTTP GET リクエスト requests.get 関数を使うと、HTTP GET リクエストでインターネット上のコンテンツをダウンロードすることができます。 requests.get は、戻り値として requests.models.Response オブジェクトを返します。 Web コンテンツのダウンロード import requests res = requests.get(\u0026#39;http://google.com/\u0026#39;) type(res) #=\u0026gt; \u0026lt;class \u0026#39;requests.models.Response\u0026#39;\u0026gt; Response オブジェクトから、ステータスコードや、取得したコンテンツの内容を取得することができます。 requests.get のレスポンスを詳しく見る import requests res = requests.get(\u0026#39;http://google.com/\u0026#39;) print(res.status_code) #=\u0026gt; 200 print(res.status_code == requests.codes.ok) #=\u0026gt; True print(res.ok) #=\u0026gt; True content = res.content #=\u0026gt; コンテンツをバイトデータ (bytes) で取得 text = res.text #=\u0026gt; コンテンツをテキスト (str) で取得 Response#text を使って Unicode のテキストデータを取得することができます。 ダウンロードされたコンテンツからの変換に使われるエンコーディング形式は、HTTP のヘッダ、あるいは HTML 内のヘッダから判断されます。 どちらのヘッダにも指定がない場合は、コンテンツ内の文字列からそれらしきエンコーディング形式が決定されます。 requests モジュールによる HTTP POST リクエスト POST リクエストを送るには、requests.get の代わりに requests.post を使用するだけです。 HTTP の POST リクエストを送る data = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;} res = requests.post(\u0026#39;http://example.com/\u0026#39;, data) print(res.text)"},{url:"/p/r4m4k2i/",title:"Python で HTML をパースする (Beautiful Soup)",date:"2015-05-17T00:00:00Z",body:"Python で HTML をパースする (Beautiful Soup) Beautiful Soup とは Python 標準の html.parser モジュールは、SAX 形式のイベントドリブンなパーサなため、若干扱いにくいところがあります。 Beautiful Soup ライブラリを使用することで、HTML の要素に簡単にアクセスすることができるようになります。 Beautiful Soap Documentation Beautiful Soup パッケージは次のようにインストールできます。 $ pip install beautifulsoup4 HTML をパースする 最初に、HTML 文字列や HTML ファイルから bs4.BeautifulSoup オブジェクトを生成する必要があります。 HTML 文字列から soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(\u0026#34;\u0026lt;html\u0026gt;Hello\u0026lt;/html\u0026gt;\u0026#34;, features=\u0026#34;html.parser\u0026#34;) HTML ファイルから soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(open(\u0026#34;input.html\u0026#34;), features=\u0026#34;html.parser\u0026#34;) Beautiful Soup 自体には Web 上のリソースをダウンロードする機能は備わっていないので、そのようなケースでは、requests モジュールなどで HTML リソースをダウンロードしておいて、BeautifulSoup コンストラクタに渡してやります。 Web 上の HTML リソースから soup を作成（requests モジュールを使用） from bs4 import BeautifulSoup import requests res = requests.get(\u0026#34;https://example.com/\u0026#34;) if res.status_code != requests.codes.ok: print(\u0026#34;Failed to fetch data\u0026#34;) exit(1) soup = BeautifulSoup(res.text, features=\u0026#34;html.parser\u0026#34;) 最初に登場する要素を見つける BeautifulSoup オブジェクトを生成したら、各要素の検索を行えるようになります。 一番簡単なのは、BeautifulSoup オブジェクトのプロパティで HTML 要素のタグ名を指定する方法です。 次の例では、最初に登場する p 要素（bs4.element.Tag オブジェクト）を取得しています。 from bs4 import BeautifulSoup html_doc = \u0026#34;\u0026#34;\u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;foo\u0026#34;\u0026gt;This is \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt; text.\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; \u0026#34;\u0026#34;\u0026#34; soup = BeautifulSoup(html_doc, features=\u0026#34;html.parser\u0026#34;) print(type(soup.p)) # =\u0026gt; \u0026lt;class \u0026#39;bs4.element.Tag\u0026#39;\u0026gt; HTML 要素の Tag オブジェクトを取得できたら、次のように直感的にその内容を参照できます。 print(soup.p) # =\u0026gt; \u0026lt;p class=\u0026#34;foo\u0026#34;\u0026gt;This is \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt; text.\u0026lt;/p\u0026gt; print(soup.p.name) # =\u0026gt; \u0026#39;p\u0026#39; print(soup.p.text) # =\u0026gt; \u0026#39;This is bold text.\u0026#39; print(soup.p[\u0026#34;class\u0026#34;]) # =\u0026gt; [\u0026#39;foo\u0026#39;] print(soup.p.get(\u0026#34;class\u0026#34;)) # =\u0026gt; [\u0026#39;foo\u0026#39;] 属性値の取得方法には [] を使う方法と、get() 使う方法があることに注意してください。 指定した属性値が存在しない場合、[] が KeyError を発生させるのに対し、get() は None を返します。 いろいろな条件で要素を見つける 前述の例では、p 要素を参照するときに soup.p のように記述していました。 その代わりに find メソッドを使用すると、いろいろな条件で HTML 要素を検索することができます。 # 最初の p 要素 elem = soup.find(\u0026#34;p\u0026#34;) # id 属性が sidebar である要素 elem = soup.find(id=\u0026#34;sidebar\u0026#34;) # class 属性に comment を含む要素 elem = soup.find(class_=re.compile(\u0026#34;comment\u0026#34;)) # href 属性に特定のドメイン名を含む a 要素 elem = soup.find(\u0026#34;a\u0026#34;, href=re.compile(\u0026#34;^https://example.com/\u0026#34;)) class キーワードは Python の予約語のため、HTML 要素の class 属性値を検索するには、末尾に _ の付いた class_ というパラメータ名を使用することに注意してください。 すでに find メソッドによって見つけた要素がある場合は、その要素を基準にして子要素を検索することができます。 title = soup.find(\u0026#34;head\u0026#34;).find(\u0026#34;title\u0026#34;) 要素が見つからない場合、find メソッドは None を返します。 特定の条件に一致する要素をすべて見つける 指定したタグ名の要素をすべて取得するには、find_all メソッドを使用します。 戻り値は、bs4.element.ResultSet オブジェクトで、for ループを使って見つかった要素を順番に処理できます。 次の例では、すべての a 要素を取得しています。 a 要素をすべて取得する from bs4 import BeautifulSoup html_doc = \u0026#39;\u0026#39;\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Title\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;https://google.com/\u0026#34;\u0026gt;Google\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;https://yahoo.com/\u0026#34;\u0026gt;Yahoo\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39;\u0026#39;\u0026#39; soup = BeautifulSoup(html_doc, features=\u0026#34;html.parser\u0026#34;) links = soup.find_all(\u0026#34;a\u0026#34;) for link in links: print(link.text) 実行結果 Google Yahoo 見つかった要素の属性は、attrs プロパティで参照できます。 次の例では、HTML 内のすべての a 要素を検索し、その href 属性を出力しています。 links = soup.find_all(\u0026#34;a\u0026#34;) for link in links: if \u0026#34;href\u0026#34; in link.attrs: print(link.text, \u0026#34;:\u0026#34;, link.attrs[\u0026#34;href\u0026#34;]) 実行結果 Google : http://google.com/ Yahoo : http://yahoo.com/ CSS セレクタによる要素の検索 find_all の代わりに、select メソッドを使用すると、CSS セレクタによる要素の検索を行えます。 elems = soup.select(\u0026#34;a\u0026#34;) # すべての a 要素 elems = soup.select(\u0026#34;table tr\u0026#34;) # table 要素以下の tr 要素 elems = soup.select(\u0026#34;.hoge\u0026#34;) # class 属性に hoge を含む要素 elems = soup.select(\u0026#34;table.hoge\u0026#34;) # class 属性に hoge を含む table 要素 elems = soup.select(\u0026#34;#nav\u0026#34;) # id 属性が nav である要素 elems = soup.select(\u0026#34;#nav a\u0026#34;) # id 属性が nav である要素以下の a 要素"},{url:"/p/k5p4axo/",title:"Python で HTTP を扱う方法いろいろ",date:"2015-05-17T00:00:00Z",body:"Python で HTTP を扱う方法いろいろ Python3 の標準 HTTP ライブラリ Python3 には HTTP を扱う、下記のような標準ライブラリが用意されています。 http.client HTTP (RFC 2616) を実装する 低レベルライブラリ。 urllib.request 上記を利用した 高レベルライブラリ。認証やリダイレクトをサポートしています。 オープンソースの HTTP ライブラリ Python に標準で付属している urllib.request パッケージは、比較的低レベルな処理を行うように設計されているため、手っ取り早く HTTP リクエストでデータを取得したい場合は、オープンソースの requests パッケージ を使うとよいでしょう。 requests パッケージは、Python の公式サイトでも推奨されています。 requests パッケージ"},{url:"/p/7o9q8p6/",title:"Python のパッケージ管理ツール (pip) の使い方",date:"2015-05-17T00:00:00Z",body:"Python のパッケージ管理ツール (pip) の使い方 pip とは Python のパッケージ管理ツールである pip コマンドは、従来の setuptools で提供されていた easy_install コマンドを置き換えるものです。 pip コマンドは、主に Python Package Index からパッケージをダウンロードしてインストールします。 pip のインストール Python 3.4 以降の Python インストーラを使用すると、pip コマンドは標準でインストールされます。 下記のいずれかの方法ですでにインストールされているか確認しましょう。 $ pip --version $ python -m pip --version $ python3 -m pip --version 単体でインストールする必要がある場合は、基本的には下記のサイトに従ってインストールします。 Installation - pip documentation pip 1.5.1 までは、setuptools の easy_install コマンドを使用してインストールしていましたが、現在は get-pip.py スクリプトを使ってどの OS 環境でも統一された方法で簡単にインストールすることができます。 pip コマンドのインストール $ curl -kL https://bootstrap.pypa.io/get-pip.py | python3 プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。 pip によるパッケージのインストール、アンインストール $ pip install \u0026lt;package\u0026gt; $ pip install -U \u0026lt;package\u0026gt; # パッケージを最新版にアップグレード $ pip install -I \u0026lt;package\u0026gt; # パッケージをインストールしなおす $ pip uninstall \u0026lt;package\u0026gt; # パッケージのアンインストール プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。 pip コマンドのアップデート pip コマンド自身のバージョン更新は、pip コマンドを使って行うことができます。 $ pip install -U pip"},{url:"/p/x7hr9z7/",title:"GitHub の Organization を構成したときのチームの権限について理解する",date:"2015-05-07T00:00:00Z",body:"GitHub の Organization を構成したときのチームの権限について理解する GitHub の Organization の 4 種類のチーム GitHub で Organization を作成すると、その下に作成したリポジトリは、Organization 内に作成したチーム単位でアクセス権限を設定することになります。 GitHub のサイト にざっと説明がありますが、分かりにくいのでここで補足します。 チーム区分としては、 Owners Admin Write Read に分かれていて、それぞれ異なる権限を持ちます。 Owners チームとその権限 Owners はその名の通り organization 自体の管理者チームであり、デフォルトで存在しているものです。 残りの 3 つ（Admin、Write、Read）とは性質が異なり、削除したり、Owners という名前を変更することはできません。 organization を作成した人が、Owners の最初のメンバになります。 Owners 権限 デフォルトで存在するチームで、その organization に関してすべての権限を持つ Owners に属するメンバは、支払い情報を管理し、クレジットカードなどの登録を行う Owners には必ず 1 人以上が所属している必要がある organization へのメンバ追加が可能 リポジトリを作成可能 チームを作成可能 残りの Admin、Write、Read というのは、後付で作成したチームに対して割り当てる権限を意味しています。 Owners チームは organization 内でひとつしか存在しませんが、Admin、Write、Read 権限を持つチームは複数作ることが可能です。 チームを作成できるのは Owners のメンバだけです。 各リポジトリへのアクセス権限は、このチーム単位で参加者 (contributors) を割り当てることで行います。 例えば、my-project というリポジトリの contributors として、team1 (Write 権限)、team2 (Read 権限) を参加させた場合、team1 に参加しているメンバだけが、my-project へのコミット権限を持つことになります。 リポジトリに対してチームを割り当てることができるのは Owners のメンバだけです。 Admin チームとその権限 チームの作成やリポジトリへの登録は Owners のメンバしか行えませんが、Admin チームに属していれば、リポジトリの作成を行うことができます。 さらに、Admin チームに属するメンバは、その Admin チーム自体へのメンバ追加が可能です。 Admin 権限 リポジトリを作成可能。 organization へのメンバ追加が可能。 Admin チームへのメンバ追加が可能（Admin 以外のチームへのメンバ追加は行えない） リポジトリに Admin チームを登録すると、Admin チームメンバはそのリポジトリの設定変更可能。 Admin チームに属しているけれど、Owner チームには属していないメンバがリポジトリを作成すると、そのリポジトリの contributor に自動的に Admin チームが追加されてしまうようです。 このとき、複数の Admin チームに属していた場合は、その中のいずれかのチームが contributor として登録されます。 Admin チームは扱いにくいですね・・・。 Write / Read チームとその権限 Write 権限、Read 権限については分かりやすく、リポジトリへの push が可能かどうかを示しています。 コードを Read only で見るだけでよいのであれば、そのユーザを Read 権限だけ付いたチームに登録し、そのチームを対象のリポジトリの contributor として登録します。 運用例 例えば、下記のようなルールで運用すると、各リポジトリごとに細かくメンバのアクセス権限を制御することができます。 Owners メンバがリポジトリ（例: rep1）の作成を行う。 Owners メンバがそのリポジトリ用の Write 権限のチーム（例: team-rep1）、Read 権限のチーム（例: team-rep1-ro）を作成し、リポジトリに登録する。 リポジトリ rep1 の開発メンバは team-rep1 に所属させる。 リポジトリ rep1 をリードオンリーで参照させたいメンバは team-rep1-ro に所属させる。 そのリポジトリの設定を Owners メンバ以外に任せたくなったら、そのリポジトリ用の Admin 権限のチーム（例 team-rep1-admin）を作成し、リポジトリに登録する。"},{url:"/p/s8i5cr9/",title:"ESLint で JavaScript コードの静的解析を行う",date:"2015-04-07T00:00:00Z",body:"ESLint で JavaScript コードの静的解析を行う eslint コマンドのインストール ESLint のインストールは、Node.js の npm コマンドで簡単に行うことができます。 eslint のインストール $ npm install -g eslint インストールできたか確認します。 $ eslint --version v0.18.0 次のように .js ファイルを指定することで静的解析を実行できます。 sample.js の静的解析 $ eslint sample.js ESLint の設定ファイル ESLint の設定は、JSON 形式あるいは YAML 形式の .eslintrc ファイルで行います。 以下のような構成で、前提とする実行環境、参照可能なグローバルオブジェクト、適用する Lint ルールの設定、を記述していきます。 .eslintrc ファイルの構成 { \u0026#34;env\u0026#34;: { (1) 実行環境 }, \u0026#34;globals\u0026#34;: { (2) 参照するグローバルオブジェクト }, \u0026#34;rules\u0026#34;: { (3) Lint ルールの設定 } } Node モジュールとして作成する JS ファイルに対しては、package.json の中に ESLint の設定を記述してしまうことができます。 その場合は、下記のように、eslintConfig プロパティの中に同様の設定を記述します。 package.json { \u0026#34;name\u0026#34;: \u0026#34;myapp\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;eslintConfig\u0026#34;: { \u0026#34;env\u0026#34;: { \u0026#34;browser\u0026#34;: true, \u0026#34;node\u0026#34;: true } } } それでは、各項目の順番に設定方法を見ていきます。 (1) Environments - 実行環境の指定 このセクションでは、その JS ファイルがどのような環境で実行されるかを指定します。 例えば、「ブラウザ」上で実行する、「AMD モジュール」として作る、「Node モジュール」として作る、といった前提環境を指定します。 ここで環境を指定することにより、その環境に合わせたグローバルオブジェクトの参照許可や、Lint ルールなどが自動的に設定されます。 指定できる環境の一覧は、 https://eslint.org/docs/user-guide/configuring の Specifying Environments の節に、次のように列挙されています。 browser - browser global variables. node - Node.js global variables and Node.js-specific rules. amd - defines require() and define() as global variables as per the amd spec. mocha - adds all of the Mocha testing global variables. jasmine - adds all of the Jasmine testing global variables for version 1.3 and 2.0. phantomjs - phantomjs global variables. jquery - jquery global variables. prototypejs - prototypejs global variables. shelljs - shelljs global variables. es6 - enable all ECMAScript 6 features except for modules. 例えば、ブラウザ上で実行する JavaScript コードであり、その中で jQuery と RequireJS を使用したいのであれば、下記のように定義します。 .eslintrc（抜粋） { \u0026#34;env\u0026#34;: { \u0026#34;amd\u0026#34;: true, // Refer to define() and require() as AMD modules \u0026#34;browser\u0026#34;: true, // Refer to document object etc. as web browser \u0026#34;jquery\u0026#34;: true // Refer to $ object to use jQuery library }, \u0026#34;globals\u0026#34;: { ... }, \u0026#34;rules\u0026#34;: { ... } } このように環境設定しておくことで、jQuery オブジェクト ($) などのグローバルオブジェクトにアクセスしても、未定義エラーとして検出されないようにすることができます。 (2) Globals - 参照するグローバルオブジェクト このセクションでは、参照可能なグローバル変数を、ひとつずつ明示的に設定することが可能です。 環境設定セクションに \u0026quot;amd\u0026quot;: true と書いてあれば、define() と require() はアクセス可能になるのですが、下記のように明示的に指定することも可能です。 .eslintrc（抜粋） { \u0026#34;env\u0026#34;: { ... }, \u0026#34;globals\u0026#34;: { \u0026#34;define\u0026#34;: true, \u0026#34;require\u0026#34;: true }, \u0026#34;rules\u0026#34;: { ... } } JSLint と同様に、ソースコードの中で、参照可能なグローバルオブジェクトを定義しておくこともできます（変数名の後ろの false は、このファイルで代入を行わないということを示します）。 .js ファイルの中で /*global var1:false, var2:false*/ (3) Rules - 適用する Lint ルールの設定 ルールのセクションでは、実際に適用する Lint ルールの設定を行います（ここが設定が重要）。 各ルールに対しての設定を、下記のようなプロパティの形でひとつずつ指定していきます。 \u0026#34;ルール名\u0026#34;: 適用方法, 適用方法の部分には、そのルールをどう反映するかを表す、0、1、2 のいずれかの値を指定します。 適用方法 0 - off（ルールを無効にする） 1 - warning（警告として検出する） 2 - error（エラーとして検出する） ルール設定には、追加のパラメータを持つものもあり、その場合は配列の形で設定値を記述します。 配列の 1 番目の値として、上記と同様に 0、1、2 のいずれかの適用方法を指定します。 \u0026#34;ルール名\u0026#34;: [適用方法, 追加パラメータ1, 追加パラメータ2] .eslintrc（抜粋） { \u0026#34;env\u0026#34;: { ... }, \u0026#34;globals\u0026#34;: { ... }, \u0026#34;rules\u0026#34;: { /* * Possible Errors */ \u0026#34;valid-jsdoc\u0026#34;: 2, // Ensure JSDoc comments are valid \u0026#34;no-duplicate-case\u0026#34;: 2, // Disallow a duplicate case label \u0026#34;no-empty\u0026#34;: 2, // Disallow empty statements \u0026#34;no-irregular-whitespace\u0026#34;: 2, // Disallow irregular whitespace \u0026#34;no-unreachable\u0026#34;: 2, // Disallow unreachable statements \u0026#34;use-isnan\u0026#34;: 2, // Disallow comparisons with the value NaN /* * Stylistic Issues */ \u0026#34;camelcase\u0026#34;: 1, // Require camel case names \u0026#34;indent\u0026#34;: [1, 2], // An indent should be two spaces \u0026#34;quotes\u0026#34;: [1, \u0026#34;single\u0026#34;, \u0026#34;avoid-escape\u0026#34;], // Surround a string with single quotation /* * Legacy */ \u0026#34;max-len\u0026#34;: [1, 80, 2], // The maximum length of a line } } デフォルトで有効になっているルールに関しては、適用方法として 2（エラーとして検出）が設定されます。 組み込みで用意されているルールの一覧は、下記のサイトで確認することができます。 ESLint - Rules"},{url:"/p/ufcmoxr/",title:"JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint)",date:"2015-04-07T00:00:00Z",body:"JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint) 各ツールのトレンド 2015 年時点では JSHint が一番メジャーですが、これからは ESLint が主流になりそうです。 JSLint は使われなくなりつつあります。 図: JavaScript の静的解析ツールのトレンド それぞれのツールの特徴 JSLint https://jslint.com 初期リリースは 2007 年頃。 作者は Douglas Crockford で、著書に JavaScript Good Parts があり、JSON RFC4627 の仕様策定などを行っている人です。 後出の JSHint に比べると、デフォルトのチェックが厳しいです。 この厳しさは好き嫌いが分かれるところで、逆にチェックの緩い JSHint の方が好まれる理由にもなっています。 JSHint https://jshint.com 初期リリースは 2011 年頃。 作者は Anton Kovalyov（アントン・コバリャノフ）で、JSLint の fork として作られました。 ベースとなった JSLint は便利である一方で、作者 Douglas Crockford の頑固な設定（var 宣言は 1 つにまとめないと必ずエラーなど）が強制されるため、開発者から敬遠される部分が多くありました。 そこで、Anton は、より柔軟な設定を行える JSLint となることを目指して 2011 年に JSHint の開発を始めました。 JSLint と比べると、デフォルト設定におけるチェックが甘いため、有効活用するためには適切な設定を行う必要があります。 設定は JSON 形式のファイル (.jshintrc) で行えます。 JSHint は、インデントのスペース数などのコーディングスタイルに関するチェックを行うことは対象外とすることを決め、そういったチェックは JSCS を使ってくださいということになりました（そこまでやるのなら ESLint を使った方が楽かも）。 ESLint https://eslint.org 初期リリースは 2013 年頃。 作者は Nicholas C. Zakas です。 ルールの拡張を自由に行えることが特徴で、これを Pluggable と読んでいます。 JSLint/JSHint 互換のルールも、デフォルトで Pluggable なルールとして用意されています。 実装的には、Esprima でパースした結果の AST (Abstract Syntax Tree) をそれぞれの Lint ルールに渡すようになっているため、ESLint の本体はクリーンな実装がキープされるようになっています（1-pass で実行されないため若干遅いところが欠点）。 それぞれのルールはルール名で区別され、個別に ON/OFF することができます（0:無効、1:警告として検出、2:エラーとして検出）。 JSLint や JSHint よりも、ドキュメントがしっかりと書かれていて好感が持てます。 JSHint よりも設定を分かりやすく柔軟に記述することができます。 設定ファイルは JSON あるいは Yaml 形式の .eslintrc で記述します。 Node.js アプリでは、package.json 内の eslintConfig フィールドに設定を書くことができます（こちらはもちろん JSON 形式で記述します）。 出力結果もデフォルトで色付けされていたり、エラーメッセージとともにルール ID などが表示されるので、細かいところに手が届いている感じがします。 どのようなコードを検出してくれるか？ ここでは、参考までに、JSLint と JSHint がどのようなコードに対して、どういった警告表示を行ってくれるかを示します。 JSLint と JSHint 共通の検出項目（デフォルト設定時） 関数外で \u0026lsquo;use strict\u0026rsquo; しているときに警告 JSLint: Use the function form of 'use strict'. JSHint: Use the function form of \u0026quot;use strict\u0026quot;. 未定義の変数、関数アクセスの警告 JSLint: 'xxx' was used before it was defined. JSHint: 'xxx' is not defined. 未使用の変数、関数の検出 JSLint: Unused 'xxx'. JSHint: unused variable 'xxx'. eval は使用禁止 JSLint: eval is evil. JSHint: eval can be harmful. 行末にセミコロンがない JSLint: Expected ';' and instead saw 'xxx'. JSHint: Missing semicolon. case が break や return、throw で終わっていない JSLint: Missing 'break' after 'case'. JSHint: Expected a 'break' statement before 'case'. コンストラクタ（new をつけて呼んだ関数）が大文字で始まっていない JSLint: A constructor name 'xxx' should start with an uppercase letter. JSHint: A constructor name should start with an uppercase letter. new Object() の代わりに {} を使う JSLint: Use the object literal notation {} or Object.create(null). JSHint: The object literal notation {} is preferable. JSLint 独自の検出項目（デフォルト設定時） \u0026lsquo;use strict\u0026rsquo;; がない場合に警告 Missing 'use strict' statement. 比較は == や != を使用せずに、=== や !== で行う Expected '===' and instead saw '=='. おかしな条件の検出（switch (1) など） Weired condition. ++ によるインクリメント、\u0026ndash; によるデクリメントはデフォルトで禁止 Unexpected '++'. インデントのスペース数 Expected 'var' at column 3, not column 5. 無名関数の function と () の間にスペースがないことを検出 Expected exactly one space between 'function' and '('. 一行の最大文字数 Line too long. if や for ステートメントは、必ず {} ブロックで囲む Expected '{' and instead saw 'xxx'. 変数定義は関数の先頭でまとめて 1 つの var で行う Move 'var' declarations to the top of the function. Don't declare variables in a loop. Combine this with the previous 'var' statement. JSHint 独自の検出項目（デフォルト設定時） JSHint はデフォルトではほとんどチェックしてくれません。 変数と 0 の比較は \u0026lsquo;===\u0026rsquo; で行う Use '===' to compare with '0'. 使い方 それぞれのツールの使い方は下記を参照してください。 JSLint で JavaScript コードの静的解析を行う JSHint で JavaScript コードの静的解析を行う ESLint で JavaScript コードの静的解析を行う"},{url:"/p/y7o9g7a/",title:"JSHint で JavaScript コードの静的解析を行う",date:"2015-04-07T00:00:00Z",body:"JSHint で JavaScript コードの静的解析を行う JSHint は JavaScript の静的解析ツールのひとつです。 JSLint を元に作成されていますが、より柔軟な設定ができるようになっています。 JSHint のインストール JSHint は JSHint の Web サイト 上に直接コードを記述して実行することもできますが、通常は Node.js によるコマンドライン版（jshint コマンド）を使用します。 Node.js がインストールされている環境であれば、npm (Node Package Manager) コマンドを使用して簡単にインストールすることができます。 jshint のインストール $ npm install -g jshint Windows 7 の場合、上記のようにインストールしたパッケージは、以下のディレクトリに保存されるようなので、このディレクトリに PATH が通っていない場合はコントロールパネルから PATH に追記しておくようにします。 C:\\Users\\\u0026lt;UserName\u0026gt;\\AppData\\Roaming\\npm\\ インストールが終わったら、jshint コマンドが実行できるようになっているはずです。 jshint コマンドの実行 $ jshint --version jshint v2.6.3 JSHint の実行方法 実際に解析を行う場合は、以下のように .js ファイルを指定して実行します。 sample.js を jshint で解析 $ jshint sample.js sample.js: line 8, col 6, Missing semicolon. 1 error 問題が見つからなかった場合は、何も表示されません。 ファイル名の代わりにディレクトリ名を指定すれば、そのディレクトリ以下のすべての .js ファイルに対して実行することもできます。 カレントディレクトリ以下の .js ファイルを解析 $ jshint . JSHint の設定 JSHint はデフォルトの設定では緩いチェックしか行ってくれないので、本格的に使用するには、適切な設定ファイルを用意する必要があります。 JSHint のオプション一覧は下記のサイトで確認することができます。 JSHint Options JavaScript コードのあるディレクトリ内に、JSON 形式の .jshintrc ファイルを置いておくと、jshint コマンドを実行したときにその設定が使われるようになります。 .jshintrc ファイルが見つからない場合は、上位のディレクトリを見つかるまで上りながら探索してくれます。 つまり、プロジェクトの最上位のディレクトリに .jshintrc を置いておけば、下位のディレクトリからその設定を利用して jshint を実行できるということです。 .jshintrc の記述例 { // Enforcing options \u0026#34;camelcase\u0026#34; : true, // 変数名は camelCase で \u0026#34;curly\u0026#34; : true, // if や for の後ろのブロックを表す括弧 {} を強制する \u0026#34;forin\u0026#34;: true, // オブジェクトの for-in では hasOwnProperty でフィルタ \u0026#34;indent\u0026#34; : 2, // インデントはスペース 2 文字 \u0026#34;loopfunc\u0026#34;: true, // ループの中で関数の定義禁止 \u0026#34;maxdepth\u0026#34;: 4, // 関数内の最大ネスト数 \u0026#34;strict\u0026#34; : true, // \u0026#39;use strict\u0026#39;; の強制 \u0026#34;trailing\u0026#34;: true, // 行末の無駄なスペース禁止 \u0026#34;undef\u0026#34;: true, // 未定義のオブジェクトへのアクセスを禁止 \u0026#34;unused\u0026#34;: true, // 未使用のオブジェクトが見つかったら警告 // Environments \u0026#34;browser\u0026#34; : true, // ブラウザ用の変数参照を許可 (例: document オブジェクト) \u0026#34;devel\u0026#34; : true, // alert、console へのアクセスは許す \u0026#34;jquery\u0026#34; : true, // jQuery のグローバルは許す \u0026#34;prototypejs\u0026#34; : true // prototypejs のグローバルは許す } 別の名前の設定ファイルを使いたい場合は、--config オプションでファイル名を指定することができます。 $ jshint --config config.json main.js コードの一部分だけ JSHint のチェックを無効にする ファイル内の一部のコードだけ、JSHint によるチェックを無効にするには、以下のようなコメントでコードを囲みます。 /* jshint ignore:start */ ...ここに記述したコードは JSHint によるチェックの対象外となる... /* jshint ignore:end */ 行末コメントにより、一行だけチェックを無効にすることもできます。 ignoreThis(); // jshint ignore:line"},{url:"/p/os3jvi6/",title:"JSLint で JavaScript コードの静的解析を行う",date:"2015-04-07T00:00:00Z",body:"JSLint で JavaScript コードの静的解析を行う jslist コマンドのインストール JSLint は Web サイト上 (https://jslint.com) でコードを張り付けて実行することができますが、普段の開発では jslint コマンドとして実行できるようにしておいた方が便利です。 多くのスクリプトエンジンによるラッパ実装がありますが、ここでは手軽な Node.js 版の node-jslist をインストールしてみます（あらかじめ Node.js をインストールして、npm コマンドを使えるようにしておく必要があります）。 jslint のインストール $ npm install -g jslint インストールが終わったら、動作確認します。 $ jslint --version node-jslint version: 0.9.0-pre006 JSLint edition 2013-08-26 使い方は簡単で、以下のように解析対象の .js ファイルを指定するだけです。 $ jslint sample.js $ jslint **/*.js # カレントディレクトリ以下の全ての JS ファイルに対して実行 グローバルな変数や関数を参照するときのエラーを抑制する jQuery の $ や、console、document などのグローバル変数（別のファイルで定義されている変数）を参照しようとすると、JSLint は未定義エラーと認識してしまいます。 グローバル変数を参照してもエラーにならないようにするには、global ディレクティブを使用します。 下記の例では、$ と console を参照できるようにしています。 /*global $: false, jQuery: false, console: false */ $(function () { \u0026#39;use strict\u0026#39;; console.log(\u0026#39;hello\u0026#39;); }); global というキーワードの前に、スペースを入れてはいけないことに注意してください。 各変数の後ろの、false という値は、そのグローバル変数に対して、このファイルからは代入を行っていないということを示しています。 複数の JavaScript ファイルからグローバル変数の値を変更することは、メンテナンス性を著しく下げることになるため、通常は上記のように false にしておくのがよいでしょう。"},{url:"/p/ao8p7n4/",title:"Android ビルド環境を構築するための Dockerfile",date:"2015-04-02T00:00:00Z",body:"Android ビルド環境を構築するための Dockerfile 下記の Dockerfile を使うと、Ubuntu 14.04 あるいは、Ubuntu 12.04 をベースにした Android ビルド用の Docker イメージを作成することができます。 Dockerfile (Ubuntu 14.04) FROM ubuntu:14.04 # Set the proxies if needed. # ENV http_proxy http://proxy.example.com:10080/ # ENV https_proxy http://proxy.example.com:10080/ # Suppress errors on interactive installer ENV DEBIAN_FRONTEND noninteractive # To install i386 packages such as zlib1g-dev:i386 RUN dpkg --add-architecture i386 # The following is based on http://source.android.com/source/initializing.html # For installing openjdk-7-jdk, --no-install-recommends option has to be added # not to struggle with \u0026#39;colord\u0026#39; and \u0026#39;sgml-base\u0026#39; errors. RUN apt-get -qq update RUN apt-get install -y openjdk-7-jdk --no-install-recommends RUN apt-get install -y bison g++-multilib git gperf libxml2-utils make zlib1g-dev:i386 zip --no-install-recommends # For the repo command RUN apt-get install -y curl python --no-install-recommends Dockerfile (Ubuntu 12.04) FROM ubuntu:12.04 # Set the proxies if needed. # ENV http_proxy http://proxy.examle.com:10080/ # ENV https_proxy http://proxy.example.com:10080/ # Suppress errors on interactive installer ENV DEBIAN_FRONTEND noninteractive # The following is based on http://source.android.com/source/initializing.html RUN apt-get -qq update RUN apt-get install -y openjdk-7-jdk --no-install-recommends RUN apt-get install -y git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 --no-install-recommends やっていることは、ほぼ下記に記述されている通りです。 http://source.android.com/source/initializing.html ただ、いくつかポイントがあり、下記のような設定を行っています。 インストール時の readline 系エラーの抑制 (ENV DEBIAN_FRONTEND noninteractive) 無駄なパッケージのインストールによるエラー抑制 (apt-get install -y openjdk-7-jdk --no-install-recommends) Ubuntu 14.04 の場合は、i386 系パッケージのインストール設定 (RUN dpkg --add-architecture i386) Ubuntu 14.04 の場合は、repo コマンドのダウンロード＆実行のために curl、python (2.7) を追加インストール 実際に Docker イメージを作成するには、この Dockerfile がカレントディレクトリにある状態で、下記のように実行します。 $ sudo docker build android_ubuntu14 ./ これで、android_ubuntu14 というイメージが作成されるので、あとは、Docker コンテナとして起動できます。 $ sudo docker run -it android_ubuntu14 /bin/bash この Docker イメージは、あくまでビルド環境の構築までしか行っていないため、実際にビルドをする前には、repo を使ったソースコードのダウンロードなどを行う必要があります。 http://source.android.com/source/downloading.html 上記の Android 公式サイトでは、ホームディレクトリの ~/bin に repo コマンドをインストールしていますが、Docker コンテナ上での実行時には、適宜 /opt/bin などに読み替えるとよいでしょう。"},{url:"/p/p4o6m3i/",title:"Docker チートシート／Docker コマンドの一覧",date:"2015-04-02T00:00:00Z",body:"Docker チートシート／Docker コマンドの一覧 Registry / Repository / Image / Tag の概念 図: Docker のコンテナレジストリ／リポジトリ／イメージ／タグの関係 DockerHub などのレジストリ上では、複数のリポジトリが管理されている。 Top-level リポジトリでは、ubuntu や devian といった有名どころなものが管理されている。 Top-level リポジトリ以外に、ユーザリポジトリがあり、こちらは \u0026lt;user\u0026gt;/ というプレフィックスが付く。 各リポジトリ内には複数のイメージがあり、イメージ ID やタグで指定できる。 1 つのイメージに対しては唯一の ID が付けられるが、タグは複数付けられていることがある。 docker image（イメージ関連のコマンド） コマンド 旧コマンド 説明 docker image build docker build Dockerfile からイメージをビルドする Build an image from a Dockerfile docker image history docker history イメージのレイヤ構造を表示する Show the history of an image docker image import docker import tar ファイルからファイルシステムイメージを作成する Import the contents from a tarball to create a filesystem image docker image inspect docker inspect イメージの詳細を表示する Display detailed information on one or more images docker image load docker load tar ファイルや標準入力からイメージをロードする Load an image from a tar archive or STDIN docker image ls docker images イメージの一覧を表示する List images docker image prune なし 使用していないイメージを削除する Remove unused images docker image pull docker pull レジストリからイメージを取得する Pull an image or a repository from a registry docker image push docker push イメージをリポジトリにプッシュする Push an image or a repository to a registry docker image rm docker rmi イメージを削除する Remove one or more images docker image save docker save tar ファイルにイメージを保存する Save one or more images to a tar archive (streamed to STDOUT by default) docker image tag docker tag イメージにタグを付ける Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE docker container（コンテナ関連のコマンド） コマンド 旧コマンド 説明 docker container attach docker attach 動作中のコンテナに標準入力や標準出力を接続する Attach local standard input, output, and error streams to a running container docker container commit docker commit コンテナの変更内容から新しいイメージを作成する Create a new image from a container\u0026rsquo;s changes docker container cp docker cp コンテナとホスト間でファイルをコピーする Copy files/folders between a container and the local filesystem docker container create docker create 新しいコンテナを作成する Create a new container docker container diff docker diff Inspect changes to files or directories on a container\u0026rsquo;s filesystem docker container exec docker exec 動作中のコンテナで新しいプロセスを起動する Run a command in a running container docker container export docker export Export a container\u0026rsquo;s filesystem as a tar archive docker container inspect docker inspect コンテナの詳細情報を表示する Display detailed information on one or more containers docker container kill docker kill Kill one or more running containers docker container logs docker logs Fetch the logs of a container docker container ls docker container list docker container pm docker ps コンテナの一覧を表示する List containers docker container pause docker pause Pause all processes within one or more containers docker container port docker port コンテナとホスト PC のポートマッピング情報を表示する List port mappings or a specific mapping for the container docker container prune なし Remove all stopped containers docker container rename docker rename Rename a container docker container restart docker restart Restart one or more containers docker container rm docker rm Remove one or more containers docker container run docker run 「イメージの取得」「コンテナの作成」「コンテナの起動」を連続して行う Run a command in a new container docker container start docker start 作成済みのコンテナを起動する Start one or more stopped containers docker container stats docker stats Display a live stream of container(s) resource usage statistics docker container stop docker stop Stop one or more running containers docker container top docker top Display the running processes of a container docker container unpause docker unpause Unpause all processes within one or more containers docker container update docker update Update configuration of one or more containers docker container wait docker wait Block until one or more containers stop, then print their exit codes docker network（ネットワーク関連のコマンド） コマンド 説明 docker network connect コンテナをネットワークに接続する (Connect a container to a network) docker network create ネットワークを作成する (Create a network) docker network disconnect コンテナをネットワークから切り離す (Disconnect a container from a network) docker network inspect ネットワークの詳細情報を表示する (Display detailed information on one or more networks) docker network ls ネットワークの一覧を表示する (List networks) docker network prune 未使用のネットワークをすべて削除する (Remove all unused networks) docker network rm ネットワークを削除する (Remove one or more networks) docker volume（ボリューム関連のコマンド） コマンド 説明 docker volume create ボリュームを作成する (Create a volume) docker volume inspect ボリュームの詳細情報を表示する (Display detailed information on one or more volumes) docker volume ls ボリュームの一覧を表示する (List volumes) docker volume prune 使用していないボリュームを削除する (Remove all unused local volumes) docker volume rm ボリュームを削除する (Remove one or more volumes) docker compose（複数コンテナのコントロール） コマンド 説明 docker compose build Build or rebuild services docker compose config Validate and view the Compose file docker compose convert Converts the compose file to platform\u0026rsquo;s canonical format docker compose cp Copy files/folders between a service container and the local filesystem docker compose create Creates containers for a service docker compose down Stop and remove containers, networks docker compose events Receive real time events from containers docker compose exec Execute a command in a running container docker compose images List images used by the created containers docker compose kill Force stop service containers docker compose logs View output from containers docker compose ls List running compose projects docker compose pause Pause services docker compose port Print the public port for a port binding docker compose ps List containers docker compose pull Pull service images docker compose push Push service images docker compose restart Restart containers docker compose rm Removes stopped service containers docker compose run Run a one-off command on a service docker compose start Start services docker compose stop Stop services docker compose top Display the running processes docker compose unpause Unpause services docker compose up Create and start containers docker compose version Show the Docker Compose version information docker context（Docker コンテキストの切り替え） コマンド 説明 docker context create コンテキストを作成する (Create new context) docker context export コンテキストをエクスポートする (Export a context to a tar or kubeconfig file) docker context import コンテキストをインポートする (Import a context from a tar or zip file) docker context inspect コンテキストの詳細情報を表示する (Display detailed information on one or more contexts) docker context list コンテキストの一覧を表示する (List available contexts) docker context rm コンテキストを削除する (Remove one or more contexts) docker context show 現在のコンテキストを表示する (Print the current context) docker context update 既存のコンテキストの設定を変更する (Update a context) docker context use カレントコンテキストを切り替える (Set the default context) その他のコマンド コマンド 説明 docker search Docker Hub 上のイメージを検索する (Search the Docker Hub for images) docker system df Show docker disk usage docker system events Get real time events from the server docker system info Display system-wide information docker system prune 使用していないデータをまとめて削除 (Remove unused data) docker builder prune ビルドキャッシュを削除する (Remove build cache) Docker ファイルの命令 命令 内容 # \u0026lt;comment\u0026gt; # で始まる行はコメント ADD ファイルをイメージ上にコピーする（URL 指定でのダウンロードや、tar ファイルの展開を行う） CMD ENTRYPOINT が未指定、かつ docker container run で何も指定されなかったときに実行するコマンド COPY ファイルをイメージ上にコピーする ENTRYPOINT docker container run 時に実行するコマンド ENV \u0026lt;name\u0026gt; \u0026lt;value\u0026gt; 環境変数を設定する 例: ENV http_proxy http://proxy.example.com:8888/ 例: ENV PATH $PATH:/foo/bar EXPOSE \u0026lt;port\u0026gt; ポートを公開する FROM \u0026lt;repo\u0026gt;:\u0026lt;tag\u0026gt; ベースイメージを指定する LABEL イメージのメタデータとしてラベルを追加する MAINTAINER \u0026lt;name\u0026gt; \u0026quot;\u0026lt;email\u0026gt;\u0026quot; イメージのメタデータとしてメンテナ名を追加する（非推奨） RUN \u0026lt;command\u0026gt; コマンドを実行する（/bin/sh -c による実行） RUN [\u0026quot;\u0026lt;arg1\u0026gt;\u0026quot;, \u0026quot;\u0026lt;arg2\u0026gt;\u0026quot;, \u0026quot;\u0026lt;arg3\u0026gt;\u0026quot;] コマンドを実行する（シェルを使わない） USER RUN、CMD、ENTRYPOINT のコマンドを実行するユーザー VOLUME 共有可能ボリュームをマウントする WORKDIR \u0026lt;path\u0026gt; 作業ディレクトリを設定する。RUN、CMD、ENTRYPOINT、ADD、COPY 実行時のベースディレクトリとなる。RUN cd では次の命令に引き継がれないので注意"},{url:"/p/3i2iygw/",title:"Docker で apt-get install するときに TERM 系のエラーが出る",date:"2015-04-02T00:00:00Z",body:"Docker で apt-get install するときに TERM 系のエラーが出る docker image build などで apt-get install を実行中に、下記のようなエラーが出ることがあります。 debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline このような場合、Dockerfile で下記のように環境変数を設定してから apt-get するとエラーが出なくなります。 ENV DEBIAN_FRONTEND noninteractive あるいは、apt-get 実行時に下記のようにプレフィックスで設定することもできます。 DEBIAN_FRONTEND=noninteractive apt-get install -y ... DEBIAN_FRONTEND というのは、Debian Installer が使うフロントエンド (UI) を指定するもので、noninteractive にすることで、ユーザの入力を受け付けないインストールが可能になります。 参考: http://www.debian.org/releases/sarge/s390/ch05s02.html.ja"},{url:"/p/6g3j2iz/",title:"Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき",date:"2015-04-02T00:00:00Z",body:"Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき ubuntu:14.04 などのベースイメージに対して、zlib1g-dev:i386 などの i386 系のパッケージをインストールしようとしたときに下記のようなエラーがでることがあります。 E: Unable to locate package zlib1g-dev これを防ぐには、Dockerfile で下記のように実行するようにしておきます。 RUN dpkg --add-architecture i386"},{url:"/p/oziyhxf/",title:"リポジトリ名のついていない Docker イメージをすべて削除する",date:"2015-04-02T00:00:00Z",body:"リポジトリ名のついていない Docker イメージをすべて削除する 普通に Docker コンテナ上で編集作業などを行っていると、Docker イメージのキャッシュがどんどん増えていってしまいます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 8a15692b92ea About an hour ago 1.077 GB \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 0bcfd9025fab About an hour ago 1.077 GB \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 4a0a98efbd7e About an hour ago 802.8 MB ... docker image ls コマンドの出力で、REPOSITORY 名が \u0026lt;none\u0026gt; になっているイメージをすべて削除するには、例えば以下のようにします。 $ sudo docker rmi $(docker images | awk \u0026#39;/^\u0026lt;none\u0026gt;/ {print $3}\u0026#39;) 参考: Docker のコンテナイメージを削除する (docker image rm/prune)"},{url:"/p/3yk3j2i/",title:"APK ファイルに署名する (keytool, jarsigner)",date:"2015-03-19T00:00:00Z",body:"APK ファイルに署名する (keytool, jarsigner) APK に署名する方法は、従来の Java で行われていた JAR ファイルへの署名方法と同様です。 下記の JAR ファイルへの署名方法を参考にしてください。 参考: JAR ファイルの署名について - まくまく Java ノート (1) keystore ファイルを作成する ここでは下記の条件でキーを作成します。 作成するキーストアファイル名: MyKeyStore.jks エイリアス名: android 有効期限: 10000日 $ keytool -genkey -v -keystore MyKeyStore.jks -alias android -keyalg RSA -keysize 2048 -validity 10000 Enter keystore password:（キーストアのパスワードを入力） （名前や組織名などを聞かれるので順番に入力していく） (2) keystore ファイルを使って APK に署名する 上記のように作成した keystore ファイルには、非公開鍵と、それに関連付けられた X.509 証明書が含まれており、このファイルを使用して APK に署名を行うことができます。 ここでは、MyApp.apk に署名を行います。 $ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore MyKeyStore.jks MyApp.apk android （キーストアのパスワードを入力）（キーエイリアスのパスワードを入力） (3) APK の署名を確認する $ jarsigner -verify -verbose -certs MyApp.apk 参考: APK ファイルの署名を確認する (4) メモリ使用量を最適化するためのバイトアライメントを実行する $ zipalign -v 4 input.apk output.apk"},{url:"/p/y2biqx6/",title:"Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run)",date:"2015-03-15T00:00:00Z",body:"Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run) コンテナイメージをダウンロードする (docker image pull) Docker でコンテナを作成するためには、ベースとなるイメージが必要です。 多くのイメージが Docker Hub に用意されているので、通常はここからベースとなるイメージを取得します。 ここでは、Ubuntu 20.04 のイメージをダウンロードしてみます。 docker image pull（旧: docker pull）コマンドに、ダウンロードしたいイメージ名 ubuntu と、バージョンを表すタグ 20.04 を指定してダウンロードします。 省略するとデフォルトタグとして、最新バージョンを表す lastest が使用されます。 イメージを取得する $ docker image pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:669e010b58baf5beb2836b253c1fd5768333f0d1dbcb834f7c07a4dc93f474be Status: Downloaded newer image for ubuntu:20.04 docker.io/library/ubuntu:20.04 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。 イメージの一覧を表示する $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB Docker イメージを削除したくなったときは、次のように docker image rm コマンド（旧: docker rmi ）で削除できます。 イメージを削除する $ docker image rm ubuntu:20.04 参考: Docker イメージを削除する (docker image rm) Docker コンテナを起動する (docker container run) docker container run (docker run) コマンドを使うと、指定した Docker イメージからコンテナを起動し、任意のコマンドを実行することができます。 例えば、Ubuntu 20.04 の Docker イメージ上で、echo コマンドを実行するには、以下のようにします。 コンテナを起動する $ docker container run ubuntu:20.04 echo Hello World! Hello World! docker container run コマンドにより、Docker コンテナが起動され、その中で echo が実行されます。 echo コマンドの実行が終わり次第、Docker コンテナはすぐに停止します。 docker container run コマンドで指定したイメージがまだローカルに存在しない場合は、そのイメージを公開レジストリである Docker Hub からダウンロードしてくれます。 なので、実は docker image pull であらかじめイメージを取得しておかなくても、上記の docker container run を直接実行することができます。"},{url:"/p/rwco2dp/",title:"Docker イメージを Docker Hub に登録する (docker image push)",date:"2015-03-12T00:00:00Z",body:"Docker イメージを Docker Hub に登録する (docker image push) 作成した Docker イメージを Docker Hub リポジトリに登録すると、世界中のユーザがそのイメージを使えるようになります（プライベートにすることもできます）。 まずは、下記のサイトで、Docker Hub リポジトリのアカウントを作成しておく必要があります。 https://hub.docker.com アップロード予定の Docker イメージは、下記のように作成済みであるとします。 ローカルのイメージの一覧を確認 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/sample v1 8a6608d7d353 7 minutes ago 188.3 MB Docker イメージのアップロードには、docker image push コマンドを使用します。 レジストリにイメージをデプロイ $ docker image push maku77/sample:v1 ... （Docker Hub のログインパスワードなどを入力） ... Pushing tag for rev [8a6608d7d353] on {https://cdn-registry-1.docker.io/v1/repositories/maku77/sample/tags/v1} Docker Hub で公開されているイメージは、docker search コマンドで検索することができるので、たった今登録したイメージを検索してみます。 レジストリ上のイメージを検索 $ docker search maku77 NAME DESCRIPTION STARS OFFICIAL AUTOMATED maku77/sample 0 これで、任意の Docker ホストからこのイメージをダウンロードして使えるようになりました。 レジストリからイメージを取得 $ docker pull maku77/sample:v1"},{url:"/p/y8cfimp/",title:"Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach)",date:"2015-03-12T00:00:00Z",body:"Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach) 何をするか？ ここでは、Ubuntu の Docker イメージを使ってコンテナを起動し、その上で実行した bash シェルに接続して自由にコマンドを実行できるようにします。 docker container run、start、attach、exec など似たようなコマンドがたくさんありますが、用途はそれぞれ違うのでここでひととおり理解しておきましょう。 コマンド 意味 docker container run 「イメージの取得」「コンテナの作成」「コンテナの起動」を連続して行う docker container start 作成済みのコンテナを「起動」する docker container attach 動作しているコンテナに「接続」する docker container exec 動作しているコンテナで「プロセスを起動」する docker container run はコンテナの「作成」と「起動」 docker container run（旧: docker run）は、もっとも頻繁に紹介されているコマンドですが、内部で複数のことを行うので 一番分かりにくいコマンド かもしれません。 docker container run は次のようなことを一度に実行します。 指定したイメージがなければダウンロード (docker image pull) Docker コンテナを作成する (docker container create) Docker コンテナを起動する (docker container start) 例えば、次のコマンドを実行すると、Docker イメージ (ubuntu:20.04) のダウンロード、Docker コンテナ (mycon) の作成、そのコンテナの起動までを一気に実行します。 $ docker container run --name mycon -it ubuntu:20.04 /bin/bash 各オプションは次のような意味を持っています。 --name mycon … 作成するコンテナに mycon という名前を付ける（省略するとランダムに単語を組み合わせた名前が付けられます。例: cool_blackwell） -i … 標準入力を有効にしたままにする（ようするに現在の端末上からキーボード入力できるようにする） -t … 起動するコマンドに対して TTY 端末を割り当てる（ようするに現在の端末上に bash のプロンプトを表示する） オプションで -i と -t を指定しないと、一瞬で Docker コンテナが終了してしまうので、シェル接続する場合はこれらのオプションを指定する必要があります。 -it というオプション指定は、コンテナ起動してシェル接続する場合のおまじないと考えておけばよいです。 さて、ここで Docker を始めたばかりの人がハマるのが、次のようにコンテナ停止後にふたたび docker container run した場合です。 # 次のようにシェルを終了すると、Docker コンテナが停止する root@65da3272d493:/# exit # 再び run しようとするとエラー！ どうして！？ $ docker container run --name mycon -it ubuntu:20.04 /bin/bash docker: Error response from daemon: Conflict. The container name \u0026#34;/mycon\u0026#34; is already in use by container \u0026#34;65da3272d493c77c2034f58d9a6e0c80f302db3c058e8345e170dc72d67811f4\u0026#34;. You have to remove (or rename) that container to be able to reuse that name. See \u0026#39;docker run --help\u0026#39;. これは、すでに存在する mycon という名前のコンテナをもう一度作成しようとしているからです。 docker container run コマンドが、docker container create を兼ねていることを思い出してください。 コンテナで動作している bash シェルを終了すると Docker コンテナも「停止」するのですが、停止状態のコンテナは残ったままです。 停止状態のコンテナ一覧は、次のようにして確認できます（-a オプションを付けないと、動作中のコンテナしか表示されません）。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65da3272d493 ubuntu:20.04 \u0026#34;/bin/bash\u0026#34; 12 minutes ago Exited (0) 4 minutes ago mycon 停止状態のコンテナがすでに存在するときに、コンテナの起動＆シェルへの接続だけを行うには、次のように docker container start（後述）を使用します。 $ docker container start -ai mycon root@65da3272d493:/# 別の方法として、docker container run の --rm オプションを指定するという方法もあります。 このオプションを指定すると、コンテナが停止したときに、自動的にコンテナが削除されます。 $ docker container run --rm --name mycon -it ubuntu:20.04 /bin/bash 今回の例の場合、シェルから exit すると、mycon コンテナが停止してさらに削除まで行われます。 よって、その後もう一度 docker container run を実行しようとすると、mycon コンテナの作成からやり直しになるので結果的にうまく動作します。 つまり、1 コマンドだけ実行するための使い捨てのコンテナということですね。 すぐに破棄されるので、--name mycon オプションでコンテナに名前を付ける必要はあまりないかもしれません。 docker container start は存在するコンテナを起動する すでに上記で使いましたが、docker container start コマンド（旧: docker start）は「停止状態のコンテナ」を起動するためのコマンドです。 docker container run とは異なり、コンテナの作成は行わないので、存在しないコンテナを起動しようとするとエラーになります。 $ docker container start mycon Error response from daemon: No such container: mycon コンテナを起動するには、あらかじめ docker container create でコンテナを作成しておく必要があります。 過去に docker container run で作成したコンテナでも大丈夫です。 $ docker container create -it --name mycon ubuntu:20.04 /bin/bash 327ad0cfd0047eb90a1ae4ec63769d0680697c48b074d640ed83b793c5d19beb docker container create で作成したコンテナは、次のように停止状態のコンテナの一覧に表示されます。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 327ad0cfd004 ubuntu:20.04 \u0026#34;/bin/bash\u0026#34; 23 seconds ago Created mycon あとは、docker container start でこのコンテナを起動できます。 起動と同時にシェルプロセスに接続するには、-ai オプションを付けます。 $ docker container start -ai mycon root@327ad0cfd004:/# docker container attach は動作しているコンテナに接続する docker container attach コマンド（例: docker attach）は、ローカルの標準入出力をコンテナのプロセス (PID=1) にアタッチします。 この振る舞いを調べるために、まずコンテナを起動してシェルに接続しておきます。 $ docker container create -it --name mycon ubuntu:20.04 /bin/bash $ docker container start -ai mycon root@9bf22d6b0a5c:/# ここで起動した bash シェルのプロセス ID (PID) は 1 になっています。 root@9bf22d6b0a5c:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 10 pts/0 00:00:00 ps 別のローカル端末を起動して、次のように docker container attach すると、上記の PID=1 の bash プロセスの標準入出力に接続されます。 $ docker container attach mycon root@9bf22d6b0a5c:/# 2 つの端末で bash シェルを表示している状態になりますが、どちらも PID=1 の同じプロセスに接続しているため、一方で入力したコマンドの結果がもう一方にも表示されます。 どちらかで exit すると、もう一方のシェルも閉じて Docker コンテナが終了します。 一方の接続だけを切りたい場合は、Ctrl + P Ctrl + Q と入力します。 こうすれば、もう一方のシェルプロセスは残ったままになり、コンテナも終了しません。 docker container exec は動作しているコンテナでプロセスを起動する docker container exec コマンド（旧: docker exec）を使うと、動作しているコンテナ上で新しいプロセスを起動することができます。 これを使うと、1 つのコンテナ上で 2 つのシェルを起動して接続する ということができます。 停止状態のコンテナを指定するとエラーになるので、まずはコンテナを起動してシェル接続しておきます。 この bash シェルの PID は前述のように 1 です。 $ docker container create -it --name mycon ubuntu:20.04 /bin/bash $ docker container start -ai mycon root@e3d9f66349d4:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 10 pts/0 00:00:00 ps この状態で別の端末を起動して、docker container exec で新しい bash シェルを起動して接続します。 この bash シェルは新しいプロセスとして起動するので、別の PID が割り当てられます。 $ docker container exec -it mycon /bin/bash root@e3d9f66349d4:/# ps PID TTY TIME CMD 11 pts/1 00:00:00 bash 20 pts/1 00:00:00 ps これで、1 つのコンテナに 2 つのシェルを起動して接続できました。 一方のシェルを exit で終了しても、もう一方のシェル（およびコンテナ）は実行されたままです。 ここで docker container attach を使うと、同じプロセス (PID=1) に接続されてしまうので、docker container exec の方を使って新しいシェルのプロセスを作るのがポイントです。"},{url:"/p/ow258be/",title:"Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port)",date:"2015-03-12T00:00:00Z",body:"Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port) docker container port コマンドの使い方 docker container port（あるいは docker port）コマンドを使用すると、Docker コンテナの中で公開されているポート番号 (private port) が、ホスト側のどのポート番号にマッピングされているかを調べることができます。 $ docker container port \u0026lt;コンテナ名\u0026gt; [コンテナ側ポート番号] 例えば、my-nginx コンテナの中で Web サーバーが動作しているとして、それがホスト側から見てどのポート番号にマッピングされているかを調べるには以下のようにします。 $ docker container port my-nginx 80/tcp -\u0026gt; 0.0.0.0:8000 80/tcp -\u0026gt; :::8000 この例では、コンテナ側の 80 番ポートが、ホスト側の 8000 番ポートにマッピングされていることがわかります。 つまり、コンテナの Web サーバーには、http://localhost:8000 といったアドレスでアクセスできます。 特定の（コンテナ側の）ポート番号に関してだけ調べることもできます。 次の例では、コンテナ側の 80 番ポートに対して、ホスト側のどのポートがマッピングされているかを調べています。 $ docker container port my-nginx 80 0.0.0.0:8000 :::8000 （おまけ）nginx サーバーを立ち上げて実際に試してみる Alpine Linux をベースにした nginx サーバーのイメージ (nginx:alpine) はとても軽量（20MB くらい）なので、これを利用して、上記の docker container port コマンドを試してみます。 コンテナで nginx サーバーを起動するには次のように実行します。 ここでは、コンテナ名を my-nginx とし、ホスト側の 8000 番ポートとコンテナ側の 80 番ポートを結びつけています。 $ docker container run -d -p 8000:80 --name my-nginx nginx:alpine コンテナが起動したら、ホスト PC 側で http://localhost:8000 にアクセスすると Web ページを表示できます。 この状態で、次のようにポート番号のマッピング情報を確認できます。 $ docker container port my-nginx 80/tcp -\u0026gt; 0.0.0.0:8000 80/tcp -\u0026gt; :::8000 試し終わったら、my-nginx コンテナを削除しておきましょう。 $ docker container rm -f my-nginx"},{url:"/p/5j4k3iy/",title:"Docker のコンテナイメージを作成する (docker image build, docker container commit)",date:"2015-03-12T00:00:00Z",body:"Docker のコンテナイメージを作成する (docker image build, docker container commit) 2 つのイメージ作成方法 Docker イメージの作成方法には、大きく下記の 2 つの方法があります。 Dockerfile にイメージの作成手順を記載しておき、docker image build で作成 OS イメージをインタラクティブモードで起動し、各種設定を行った後に docker container commit で作成 再現性、ポータビリティといった観点から、Dockerfile を扱うアプローチが推奨されています。 docker image build アプローチ Dockerfile という、Docker イメージ作成のための手順書を作成しておくと、docker image build（あるいは docker build）コマンドを使って自動的にイメージを作成することができます。 下記は、Debian のイメージをベースにして、Python 3 をインストールしたイメージを作成する場合の Dockerfile の例です。 Dockerfile # Debian (Wheezy) のイメージをベースにする FROM debian:wheezy # コンテナ構築のためのコマンド実行 RUN apt-get -qq update \u0026amp;\u0026amp; apt-get -y install python3 この Dockerfile を元に Docker イメージを作成するには、下記のように docker image build を実行します。 コンテナイメージのビルド $ docker image build -t \u0026lt;イメージ名\u0026gt; \u0026lt;Dockerfileのあるディレクトリ\u0026gt; -t の後ろに指定するイメージ名は \u0026lt;user\u0026gt;/\u0026lt;repo\u0026gt;:\u0026lt;tag\u0026gt; という構成で指定します。 末尾のタグ名 (:\u0026lt;tag\u0026gt;) を省略すると、自動的に latest というタグが付けられます。 カレントディレクトリに Dockerfile ファイルがある場合は次のような感じでイメージをビルドします。 $ docker build -t maku77/python3:v1 . debian:wheezy のイメージファイルが既に docker pull コマンドなどでローカルにキャッシュされている場合は、そのイメージが利用されるため、イメージ構築はより早く終わります。 docker image ls（あるいは docker images）コマンドで、作成された Docker イメージを確認することができます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/python3 v1 c3d5556730a9 4 minutes ago 93.88 MB debian wheezy d5570ef1464a 4 days ago 84.98 MB ... 作成された Docker イメージ (maku77/python3:v1) からコンテナを起動し、python3 コマンドを実行してみます。 $ docker container run -it maku77/python3:v1 python3 Python 3.2.3 (default, Feb 20 2013, 14:44:27) [GCC 4.7.2] on linux2 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; （おまけ）GitHub 上の Dockerfile からイメージを作成する docker image build コマンドで Dockerfile のあるディレクトリを指定するときに、GitHub のリポジトリを指定することができます。 $ docker mage build -t maku77/sample:v1 git@github.com:maku77/sample docker container commit アプローチ docker container commit（あるいは docker commit）コマンドによるアプローチでは、Docker のコンテナイメージをインタラクティブに作成していくことができます。 コンテナ上でソフトウェアのインストールなどを行い、最後に docker container commit コマンドを実行することにより、コンテナイメージを作成します。 まずは、ベースとなるイメージを指定して Docker コンテナを起動します。 $ docker container run -it ubuntu:14.04 /bin/bash コンテナ上の bash プロンプトが表示されたら、その中で apt-get やファイルの作成などを行い、コンテナイメージの構築作業を進めていきます。 下記の例では、Hello と表示するだけのシェルスクリプト (/greet) を作成しています。 root@c338a2f4c60e:/# cat \u0026gt; greet #!/bin/bash echo Hello （ここで Ctrl-D で終了） root@c338a2f4c60e:/# chmod +x greet root@c338a2f4c60e:/# exit 起動元のシェルに戻ってきたら、docker ps コマンドで、最新のコンテナ ID（あるいは名前）を確認します。 $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c338a2f4c60e ubuntu:14.04 /bin/bash 3 minutes ago Exited (0) About a minute ago loving_torvalds これで、先ほどインタラクティブに構成した Docker コンテナの ID が c338a2、名前が loving_torvalds だということが分かるので、docker container commit コマンドを実行して、コンテナからイメージを生成します。 docker container commit コマンドのフォーマットは下記のようになっています。 docker container commit -a \u0026lt;作者\u0026gt; -c \u0026lt;コメント\u0026gt; \u0026lt;コンテナ\u0026gt; \u0026lt;リポジトリ名\u0026gt;:\u0026lt;タグ名\u0026gt; \u0026lt;コンテナ\u0026gt; には、docker ps コマンドで確認したコンテナ ID か名前を指定します。 リポジトリ名は、Docker Hub の流儀に合わせて、\u0026lt;アカウント名\u0026gt;/\u0026lt;イメージ名\u0026gt; という形で指定します。 例えば、Docker Hub アカウントが maku77 で、sample という名前のイメージを作成する場合は次のようにします。 $ docker commit -a \u0026#39;Maku \u0026lt;maku77@example.com\u0026gt;\u0026#39; -m \u0026#39;First commit\u0026#39; c338a2 maku77/sample:v1 8a6608d7d353d966f5cdc044b48b89158943c2dc9fd08b7a4832b43a21b5df41 コンテナイメージの作成に成功すると、上記のように作成されたイメージの ID が表示されます。 docker image ls コマンドで、実際に新しくイメージが作成されたことを確認できます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/sample v1 8a6608d7d353 7 minutes ago 188.3 MB ubuntu 14.04 2103b00b3fdf 43 hours ago 188.3 MB ... この Docker イメージを使って、先ほど作成した /greet コマンドを実行してみます。 $ docker container run maku77/sample:v1 /greet Hello"},{url:"/p/6ehmpsv/",title:"すべての Docker コンテナを停止／削除する (docker container stop/rm)",date:"2015-03-12T00:00:00Z",body:"すべての Docker コンテナを停止／削除する (docker container stop/rm) 全コンテナを停止する すべての Docker コンテナをまとめて停止するには次のようにします。 これは、docker container ps -a -q コマンドですべてのコンテナ ID を取得できることを利用しているため、Linux や macOS 上でしか実行できません（Windows のコマンドプロンプトでは実行できません）。 すべての Docker コンテナを停止する $ docker container stop $(docker container ps -a -q) 全コンテナを削除する 同様に、次のようにすればすべての Docker コンテナを削除することができます。 すべての Docker コンテナを削除する $ docker container rm $(docker container ps -a -q) 動作中のコンテナも含めてすべて削除したいときは、docker contaier rm に -f オプションを付けて実行する必要があります。 ただし、これはとても危険なので注意して実行してください。"},{url:"/p/47hs3ck/",title:"Docker コンテナの詳細情報を表示する (docker container inspect)",date:"2015-03-11T00:00:00Z",body:"Docker コンテナの詳細情報を表示する (docker container inspect) docker container inspect（あるいは docker inspect）コマンドを使用すると、Docker コンテナの詳細情報を表示することができます。 その Docker コンテナがどのイメージをもとに作成されているのか、環境変数の設定はどうなっているのかなどを JSON 形式で出力してくれます。 $ docker container inspect my-container [ { \u0026#34;Id\u0026#34;: \u0026#34;ac2dc4e539f1bc7c273beb71d03536e83393d7f673d7ba67994569c75173b2a2\u0026#34;, \u0026#34;Created\u0026#34;: \u0026#34;2022-02-25T05:28:16.4553051Z\u0026#34;, \u0026#34;Path\u0026#34;: \u0026#34;/bin/bash\u0026#34;, \u0026#34;Args\u0026#34;: [], \u0026#34;State\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;exited\u0026#34;, \u0026#34;Running\u0026#34;: false, \u0026#34;Paused\u0026#34;: false, \u0026#34;Restarting\u0026#34;: false, \u0026#34;OOMKilled\u0026#34;: false, \u0026#34;Dead\u0026#34;: false, \u0026#34;Pid\u0026#34;: 0, \u0026#34;ExitCode\u0026#34;: 0, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;StartedAt\u0026#34;: \u0026#34;2022-02-25T05:29:17.5120196Z\u0026#34;, \u0026#34;FinishedAt\u0026#34;: \u0026#34;2022-02-25T05:29:22.1845301Z\u0026#34; }, \u0026#34;Image\u0026#34;: \u0026#34;sha256:54c9d81cbb440897908abdcaa98674db83444636c300170cfd211e40a66f704f\u0026#34;, ... } ]"},{url:"/p/dmpsvz3/",title:"Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs)",date:"2015-03-11T00:00:00Z",body:"Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs) コンテナのバックグラウンド起動 (docker container run -d) Docker コンテナ内でプログラムが動作している状態をキープするには、何らかの終了しないプログラムを動かす必要があります（典型的には何らかのサーバープログラムです）。 ここでは、5 秒おきに HELLO と表示するプログラムを動かしてみます。 次のような簡単な bash プログラムです。 /bin/bash -c \u0026#39;while true; do echo HELLO; sleep 5; done\u0026#39; 上記のようなプログラムを、docker run コマンドで単純に Docker コンテナ内で動かすと、起動元の端末（の標準出力）に HELLO と表示され続けてしまいます。 そうではなくて、Docker コンテナ内に閉じて出力するには、docker run コマンドに -d (--detach) オプションを付けて実行します。 $ docker container run --rm -d --name mycon ubuntu:22.04 /bin/bash -c \u0026#39;while true; do echo HELLO; sleep 5; done\u0026#39; 57bf2e3edddf8dcc786ee42e9b2b5a1f50786d80bd45525afa21debcf108613b 引数の意味: --rm … コンテナ停止時にコンテナを自動で削除します。 -d (--detach) … コンテナをバックグラウンドで動作させます。 --name mycon … コンテナに mycon という名前を付けます。 ubuntu:22.04 … イメージとして Ubuntu 22.04 を使用します。 すると、docker container run コマンドを実行した側には HELLO と表示されず、プログラムを実行中の コンテナ ID のみが表示されます。 実行中の Docker コンテナの一覧は、以下のように docker container ps コマンドで確認できます。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 57bf2e3edddf ubuntu:22.04 \u0026#34;/bin/bash -c \u0026#39;while…\u0026#34; 5 seconds ago Up 5 seconds mycon このリストでは、動作中のコンテナのコンテナ ID や、その ID の代わりに使用できる名前（上記では mycon) などを確認できます。 コンテナ内のデーモンの出力内容を確認する (docker container logs) Docker コンテナ内の標準出力に対して出力されている内容を調べるには、docker container logs コマンドを使用します。 $ docker container logs mycon HELLO HELLO HELLO ...（省略）... デフォルトでは、その時点で出力済みの標準出力の内容をすべて出力して docker container logs コマンドは終了します。 Linux の tail -f コマンドのように、標準出力への出力を監視して継続的に出力したい場合は -f オプションを付けます。 $ docker logs -f mycon HELLO HELLO HELLO ...（出力を待機）... 動作中の Docker コンテナを外から停止するには、docker container stop コマンドを使用します。 $ docker container stop mycon mycon $ docker container ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ...（空になっている）... bash に仮想端末を割り当てて終了しないようにする方法 docker container run でコンテナを起動するときに、-t (--tty) オプションで仮想端末 (pseudo-TTY) を割り当てて bash を起動することでも、コンテナを起動したままにできます（Ubuntu イメージはデフォルトで bash を起動するので、末尾の bash は省略できます）。 $ docker container run --rm -dt --name mycon ubuntu:22.04 bash 52ac8c76e47ed495e2698676530c662531782f500504b03daa87da6c634c9fba この状態はちょっと分かりにくいですが、内部的に仮想端末が割り当てられ、そこに繋がった bash がバックグラウンドで動き続けているというイメージです。 -d (--detach) オプションを付けて実行しているので、bash のプロンプトは見えなくなっています。 次のようにすると、確かにコンテナ上で bash が動作し続けていることを確認できます。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 52ac8c76e47e ubuntu:22.04 \u0026#34;bash\u0026#34; 3 minutes ago Up 3 minutes mycon このコンテナ上で新しく bash を起動して何か操作したいときは次のようにします。 $ docker container exec -it mycon bash root@52ac8c76e47e:/# docker container exec コマンドの詳細は下記記事を参照してください。 Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach)"},{url:"/p/s3m4jyg/",title:"Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top)",date:"2015-03-11T00:00:00Z",body:"Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top) docker container top \u0026lt;コンテナ名\u0026gt; コマンドを実行すると、指定した Docker コンテナ内で現在動作しているプロセスを確認することができます（互換性維持のため、docker top コマンドも残されています）。 $ docker container top my-container PID USER COMMAND 854 root python app.py 855 root sleep 1 末尾に ps コマンドのオプションを指定して、出力内容をカスタマイズできます。 次の例では、-o pid,command と指定することで、出力するフィールドを PID と COMMAND のみにしています。 $ docker container top my-container -o pid,command PID COMMAND 2007 /usr/bin/qemu-x86_64 /usr/sbin/mysqld mysqld"},{url:"/p/w69cfim/",title:"Docker のプロキシ設定",date:"2015-03-10T00:00:00Z",body:"Docker のプロキシ設定 Docker ホスト側のプロキシ設定 docker pull などで、Docker Hub リポジトリからイメージを取得するときにプロキシ接続が必要な場合は、Docker コンテナーではなく、Docker ホスト側のプロキシ設定を行う必要があります。 実際には、docker pull コマンドは、docker デーモンに対して命令を送っているだけなので、docker デーモンの方がプロキシ設定を認識する必要があります。 docker デーモンのプロキシ設定は、/etc/default/docker ファイルで行います。 /etc/default/docker（あるいは docker.io） export http_proxy=\u0026#34;http://proxy.example.com:3128/\u0026#34; 設定変更後は、docker デーモンを再起動すれば OK です。 $ sudo service docker.io restart これで、無事にプロキシ経由で docker pull できるようになります。 Docker コンテナ内で使用するプロキシ設定 Docker コンテナの中で、apt-get や curl などを使ったインターネットアクセスを行う場合は、Docker コンテナ側でプロキシの設定を行う必要があります。 docker run で Docker コンテナを起動するときに、-e オプションで http_proxy 環境変数 を渡して起動することができます。 $ sudo docker run -e http_proxy=http://proxy.example.com:8888/ -it debian:wheezy もちろん、Docker コンテナを起動したあとで、コンテナ上のシェルから環境変数を設定することもできます。 $ sudo docker run -it debian:wheezy root@7cb147891556:/# export http_proxy=http://proxy.example.com:8888/ root@7cb147891556:/# Docker イメージとして、必ず特定のプロキシを使うことが決まっているのであれば、Docker イメージを作成する際の Dockerfile にプロキシ設定を埋め込んでしまうこともできます。 このプロキシ設定は、Docker イメージを構築する際の、RUN コマンド (apt-get) にも効いてきます。 Dockerfile FROM debian:wheezy ENV http_proxy http://proxy.example.com:8888/ ENV https_proxy http://proxy.example.com:8888/ RUN apt-get update \u0026amp;\u0026amp; apt-get install python3"},{url:"/p/an7o5m3/",title:"一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録）",date:"2015-03-10T00:00:00Z",body:"一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録） docker コマンドは、内部で socket を使って通信を行っており、一般ユーザからコマンドを実行すると、permission denied で怒られることがあります。 $ docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a 2015/03/10 22:50:19 Get http:///var/run/docker.sock/v1.12/version: dial unix //var/run/docker.sock: permission denied 上記の出力を見ると、var/run/docker.sock ファイルへのアクセス権限がないことが分かります。 このような場合は、次のいずれかの方法で docker コマンドを実行できるようになります。 sudo を付けて実行する ユーザーを docker グループに追加する sudo を付けて実行する方法 sudo をつけてスーパーユーザー権限で docker コマンドを実行する方法です。 $ sudo docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a Server version: 1.0.1 Server API version: 1.12 Go version (server): go1.2.1 Git commit (server): 990021a ユーザーを docker グループに追加する方法 Docker が使用している socket ファイル (/var/run/docker.sock) は、docker グループ からのアクセスを許可しています。 $ ls -l /var/run/docker.sock srw-rw---- 1 root docker 0 3月 10 00:02 /var/run/docker.sock 必要なユーザを、docker グループに追加することで、自由に docker コマンドを実行できるようになります。 $ sudo gpasswd -a maku docker # ユーザ maku を docker グループに追加 $ sudo gpasswd -d maku docker # ユーザ maku を docker グループから外す 上記の設定を反映させるには、一度 Ubuntu などからログアウトする必要があります。"},{url:"/p/96o6n4j/",title:"Docker をインストールする (Docker Desktop / Docker Engine)",date:"2015-03-09T00:00:00Z",body:"Docker をインストールする (Docker Desktop / Docker Engine) Docker 実行環境のインストール Docker の実行環境（docker コマンド）をインストールするには、下記の公式マニュアルの手順に従ってください。 基本的に、Windows や macOS では Docker Desktop、Linux では Docker Engine をインストールすることになります。 https://docs.docker.com/get-docker/ 例: Windows の場合 (Docker Desktop) 例: macOS の場合 (Docker Desktop) 例: Ubuntu の場合 (Docker Engine) 例: Debian の場合 (Docker Engine) 例えば、Linux 環境では次のような感じで Docker Engine をインストールできます（詳細は上記の公式ページを参照してください）。 # インストール $ curl -sSL get.docker.com -o install.sh $ sh install.sh # Docker サービスを systemd で自動起動する設定 $ systemctl enable docker # Docker サービスを直ちに起動 $ systemctl start docker インストール手順を実行後、docker コマンドが使えるようになっていれば準備 OK です。 $ docker system info Docker Desktop について Docker コンテナを動作させるためのコアになる Docker Engine は、Linux OS 上で動作させることを前提としているため、そのままでは Windows や macOS 上で動かすことができません。 Windows や macOS で Docker を動かすには、まず、Linux VM（仮想環境）を立ち上げ、その上で Docker Engine を動作させる、といった複雑な手順が必要です。 とはいえ、それでは手間がかかるので、Windows や macOS には Docker Desktop というソフトウェアが提供されており、これをインストールすると、Linux VM + Docker の実行環境を一度に整えられます（Windows では内部的に WSL2（Windows 標準の仮想環境）が利用されます）。 さらに、Docker Desktop は次のような GUI フロントエンドを備えており、ここから Docker イメージの管理、コンテナの管理、ボリュームの管理などを行えるため非常に便利です。 図: Docker Desktop の画面 Docker Desktop をインストールすると、Docker Engine だけでなく、下記がまとめて使えるようになります。 Docker Engine Docker CLI client Docker Build/BuildKit Docker Compose Docker Content Trust Kubernetes Docker Scan Credential Helper Docker Desktop は Linux VM として、BusyBox ベースの軽量な Alpine Linux を使用しているため、高速に起動することができます。 下手に自分で Linux VM 環境を用意するより快適に使用できます。 2022年2月からは、Docker Desktop を巨大企業（250人以上 or 1,000万ドル以上の収益）で使用する場合は有償 になるため注意してください。 個人利用では引き続き無料（Personal プラン）で使用できます。"},{url:"/p/66q7m2j/",title:"Windows のバッチファイルの実行を途中で終了する (exit /b)",date:"2015-02-09T00:00:00Z",body:"Windows のバッチファイルの実行を途中で終了する (exit /b) バッチファイルの実行を途中で終了したい場合は、次のコマンドを実行します。 EXIT /B バッチファイルの中で単純に exit コマンドを実行すると、バッチファイルを実行していたコマンドプロンプト（コマンドシェル）ごと終了してしまいますが、/B オプション付きで実行すると、コマンドプロンプト自体は終了せずに、バッチファイルの実行だけを終了 してくれます。 sample.cmd @echo off echo AAA exit /b echo BBB 例えば、上記の sample.cmd を実行すると、echo BBB は実行せずに終了します。 実行結果 C:\\\u0026gt; sample AAA"},{url:"/p/xhyhzfv/",title:"Python で JSON 形式のテキストファイルを読み書きする (json.load, json.dump)",date:"2014-11-28T00:00:00Z",body:`Python で JSON 形式のテキストファイルを読み書きする (json.load, json.dump) JSON ファイルを読み込む (json.load) Python に付属している json ライブラリが提供する json.load 関数を使用すると、JSON 形式のテキストファイルを読み込んで、Python のオブジェクトを生成することができます。 json.load 関数のパラメーターには、ファイル名ではなく、ファイルオブジェクト（read 関数を持つオブジェクト）を渡すことに注意してください。 入力ファイル (input.json) { \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;ccc\u0026#34;: 300 } sample.py import json def load_json(filename): \u0026#34;\u0026#34;\u0026#34;JSON ファイルを読み込んで Python オブジェクトとして返します。\u0026#34;\u0026#34;\u0026#34; with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as f: return json.load(f) # テスト obj = load_json(\u0026#34;input.json\u0026#34;) print(obj[\u0026#39;aaa\u0026#39;]) #=\u0026gt; 100 print(obj[\u0026#39;bbb\u0026#39;]) #=\u0026gt; 200 print(obj[\u0026#39;ccc\u0026#39;]) #=\u0026gt; 300 JSON ファイル内の各要素は、次のような対応付けで Python オブジェクトに変換されます。 JSON の型 Python の型 object dict array list string str number int / float true / false True / False null None JSON ファイルではなく、JSON 形式の文字列を読み込みたいときは、json.load の代わりに json.loads 関数を使用します。 参考: JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps) JSON ファイルに書き出す (json.dump) 基本 Python のオブジェクトを JSON 形式のテキストファイルに書き出すには、json.dump 関数 を使用します。 こちらも、パラメーターとしてはファイル名ではなく、ファイルオブジェクト（write 関数を持つオブジェクト）を渡すことに注意してください。 sample.py import json def save_json(filename, obj): \u0026#34;\u0026#34;\u0026#34;Python オブジェクトの内容を JSON ファイルに保存します。\u0026#34;\u0026#34;\u0026#34; with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) as fp: json.dump(obj, fp) # テスト obj = { \u0026#39;ccc\u0026#39;: 300, \u0026#39;aaa\u0026#39;: 100, \u0026#39;bbb\u0026#39;: 200, \u0026#39;data\u0026#39;: [1, 2, 3] } save_json(\u0026#39;output.json\u0026#39;, obj) 出力結果 (output.json) {\u0026#34;ccc\u0026#34;: 300, \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;data\u0026#34;: [1, 2, 3]} 出力形式をカスタマイズする (indent, sort_keys) デフォルトでは、上記のように改行なしのコンパクトな出力になります。 改行やインデントを入れて出力したい場合は、json.dump 関数の引数で、indent=2 のようにインデントサイズを指定します。 また、Python 3.7 以降は辞書オブジェクト (dict) のキーは、挿入された順に出力されるようになっています（デフォルトで collections.OrderedDict 相当の動きになりました）。 アルファベット順に出力したい場合は、sort_keys=True を指定します。 sample.py（修正箇所のみ抜粋） json.dump(obj, fp, indent=2, sort_keys=True) 出力結果 (output.json) { \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;ccc\u0026#34;: 300, \u0026#34;data\u0026#34;: [ 1, 2, 3 ] } 辞書オブジェクトのキーが追加順に出力されるのは地味に便利で、例えば、id プロパティを先頭に出力したい場合は、単純にプログラム内で id を最初に追加するだけで済みます。 book1 = {\u0026#39;id\u0026#39;: 1, \u0026#39;author\u0026#39;: \u0026#39;Author-1\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Title-1\u0026#39;} book2 = {\u0026#39;id\u0026#39;: 2, \u0026#39;author\u0026#39;: \u0026#39;Author-2\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Title-2\u0026#39;} book3 = {\u0026#39;id\u0026#39;: 3, \u0026#39;author\u0026#39;: \u0026#39;Author-3\u0026#39;, \u0026#39;title\u0026#39;: \u0026#39;Title-3\u0026#39;} books = [ book1, book2, book3 ] save_json(\u0026#39;books.json\u0026#39;, books) 要素の順序をもっと細かく制御する方法は、下記の記事を参考にしてください。 dictionary の内部的な要素順序を変更する 日本語をそのまま出力する (ensure_ascii) json.dump 関数は、デフォルトで日本語を Unicode エスケープして出力しようとします（例えば、あ は \\u3042 になります）。 この振る舞いを抑制して、日本語のまま出力するには、引数で ensure_ascii=False を指定します。 import json def save_json(filename, obj): with open(filename, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;, newline=\u0026#39;\\n\u0026#39;) as fp: json.dump(obj, fp, ensure_ascii=False) obj = {\u0026#39;a\u0026#39;: \u0026#39;あいう\u0026#39;} save_json(\u0026#39;output.json\u0026#39;, obj) JSON 文字列に変換する JSON ファイルに出力するのではなく、JSON 形式の文字列を取得したいときは、json.dump の代わりに json.dumps 関数を使用します。 参考: JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps)`},{url:"/p/cp9q7n5/",title:"Python で XML をパースする (ElementTree)",date:"2014-11-28T00:00:00Z",body:"Python で XML をパースする (ElementTree) ElementTree XML API Python 2.5 以降には、XML を扱うための標準 API として、ElementTree XML API が用意されています。 The ElementTree XML API ElementTree では、パースした XML を DOM オブジェクトとしてメモリ上に保持するため、XML データを読み込んだあとは、各 XML 要素へ柔軟にアクセスすることができます。 XML ファイルをパースする ElementTree モジュールが提供している ElementTree.parse 関数を使って、XML ファイルを読み込むことができます。 ElementTree.parse 関数は、読み込んだ XML をパースして ElementTree オブジェクトとして返します。 ElementTree オブジェクトは、XML ツリー全体を表現するオブジェクトです。 XML ツリーの先頭要素を表す Element オブジェクトは、ElementTree#getroot() メソッドで取得することができます。 input.xml（テスト用の XML ファイル） \u0026lt;tree name=\u0026#34;hello\u0026#34;\u0026gt; \u0026lt;trunk\u0026gt;...\u0026lt;/trunk\u0026gt; \u0026lt;/tree\u0026gt; main.py from xml.etree import ElementTree # XML ファイルから ElementTree オブジェクトを生成 tree = ElementTree.parse(\u0026#39;input.xml\u0026#39;) # 先頭要素を表す Element オブジェクトを取得 elem = tree.getroot() print(type(elem)) # =\u0026gt; \u0026lt;class \u0026#39;xml.etree.ElementTree.Element\u0026#39;\u0026gt; print(elem) # =\u0026gt; \u0026lt;Element \u0026#39;tree\u0026#39; at 0x105499c60\u0026gt; print(elem.tag) # =\u0026gt; tree print(elem.attrib) # =\u0026gt; {\u0026#39;name\u0026#39;: \u0026#39;hello\u0026#39;} XML 形式の文字列をパースする XML ファイルではなく、XML 形式のテキストをパースしたいときは、ElementTree.fromstring(str) 関数を使用します。 戻り値は、先頭要素を表す Element オブジェクトになります。 main.py from xml.etree import ElementTree # XML 文字列をパースして Element オブジェクトを生成 elem = ElementTree.fromstring(\u0026#39;\u0026lt;tree name=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;trunk\u0026gt;...\u0026lt;/trunk\u0026gt;\u0026lt;/tree\u0026gt;\u0026#39;) print(elem.tag) #=\u0026gt; tree print(elem.attrib) #=\u0026gt; {\u0026#39;name\u0026#39;: \u0026#39;hello\u0026#39;} Element オブジェクトから要素の情報を取得する Element オブジェクトは 1 つの XML 要素を表現しており、下記のようなプロパティやメソッドが用意されています。 要素に含まれるテキストノードや属性を表すためのオブジェクトは存在せず、Element オブジェクトに付随する情報として管理されていることに注意してください。 属性 説明 Element#tag タグ名を取得 Element#text その要素の先頭にあるテキストノードを取得（\u0026lt;b\u0026gt;これ\u0026lt;/b\u0026gt;） Element#tail その要素の直後にあるテキストノードを取得（\u0026lt;b\u0026gt;...\u0026lt;/b\u0026gt;これ） Element#attrib dictionary 形式で属性をすべて取得 Element#get(key, default=None) 指定したキーの属性を取得 Element#items() (name, value) のペアで属性をすべて取得 Element#keys() 属性のキーをすべて取得 下記の例では、各要素のタグ名や、属性、テキストノードを再帰的に出力しています。 子要素を取得するには、Element 要素自身を for-in ループでイテレートします。 books.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;books\u0026gt; \u0026lt;book id=\u0026#34;001\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title 1\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Author 1\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book id=\u0026#34;002\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title 2\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;Author 2\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/books\u0026gt; parse_books.py from xml.etree import ElementTree def dump_node(node, indent=0): print(\u0026#34;{}{} {} {}\u0026#34;.format(\u0026#39; \u0026#39; * indent, node.tag, node.attrib, node.text.strip())) for child in node: dump_node(child, indent + 1) if __name__ == \u0026#39;__main__\u0026#39;: tree = ElementTree.parse(\u0026#39;books.xml\u0026#39;) dump_node(tree.getroot()) 実行結果 $ python parse_books.py books {} book {\u0026#39;id\u0026#39;: \u0026#39;001\u0026#39;} title {} Title 1 author {} Author 1 book {\u0026#39;id\u0026#39;: \u0026#39;002\u0026#39;} title {} Title 2 author {} Author 2"},{url:"/p/pt6fpx8/",title:"Python で XML を扱う方法いろいろ",date:"2014-11-28T00:00:00Z",body:"Python で XML を扱う方法いろいろ Python には下記のように、標準の XML パーサが複数搭載されています。 xml.etree.ElementTree \u0026hellip; The ElementTree XML API xml.dom \u0026hellip; The Document Object Model API xml.dom.minidom \u0026hellip; Minimal DOM implementation xml.sax \u0026hellip; Support for SAX2 parsers 通常はシンプルな xml.etree.ElementTree を使い、DOM 標準の API を使いたい場合は xml.dom を使用すればよいでしょう。 巨大な XML ファイルを効率的に読み込みたい場合は、SAX API を提供する xml.sax を選択できます。 参考: 20. Structured Markup Processing Tools Beautiful Soup などの 3rd パーティライブラリでも XML を扱うことはできますが、Beautiful Soup はどちらかというと HTML のパースに向いています。 XML のパースは、ほとんどの場合 Python 標準の ElementTree で十分です。"},{url:"/p/fufwevc/",title:"Python で XPath を使って XML 要素を参照する (ElementTree)",date:"2014-11-28T00:00:00Z",body:"Python で XPath を使って XML 要素を参照する (ElementTree) Python 2.5 以降に搭載されている ElementTree XML API は、XPath による要素アクセスをサポートしています。 The Element Tree XML API - XPath support 次の例では、country という名前の要素をすべて取得し、再帰的に子要素を表示しています。 countries.xml（入力ファイル） \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;data\u0026gt; \u0026lt;country name=\u0026#34;Liechtenstein\u0026#34;\u0026gt; \u0026lt;rank\u0026gt;1\u0026lt;/rank\u0026gt; \u0026lt;year\u0026gt;2008\u0026lt;/year\u0026gt; \u0026lt;gdppc\u0026gt;141100\u0026lt;/gdppc\u0026gt; \u0026lt;neighbor name=\u0026#34;Austria\u0026#34; direction=\u0026#34;E\u0026#34;/\u0026gt; \u0026lt;neighbor name=\u0026#34;Switzerland\u0026#34; direction=\u0026#34;W\u0026#34;/\u0026gt; \u0026lt;/country\u0026gt; \u0026lt;country name=\u0026#34;Singapore\u0026#34;\u0026gt; \u0026lt;rank\u0026gt;4\u0026lt;/rank\u0026gt; \u0026lt;year\u0026gt;2011\u0026lt;/year\u0026gt; \u0026lt;gdppc\u0026gt;59900\u0026lt;/gdppc\u0026gt; \u0026lt;neighbor name=\u0026#34;Malaysia\u0026#34; direction=\u0026#34;N\u0026#34;/\u0026gt; \u0026lt;/country\u0026gt; \u0026lt;country name=\u0026#34;Panama\u0026#34;\u0026gt; \u0026lt;rank\u0026gt;68\u0026lt;/rank\u0026gt; \u0026lt;year\u0026gt;2011\u0026lt;/year\u0026gt; \u0026lt;gdppc\u0026gt;13600\u0026lt;/gdppc\u0026gt; \u0026lt;neighbor name=\u0026#34;Costa Rica\u0026#34; direction=\u0026#34;W\u0026#34;/\u0026gt; \u0026lt;neighbor name=\u0026#34;Colombia\u0026#34; direction=\u0026#34;E\u0026#34;/\u0026gt; \u0026lt;/country\u0026gt; \u0026lt;/data\u0026gt; sample.py from xml.etree import ElementTree def dump_node(node, indent=0): print(\u0026#39; \u0026#39; * indent, node.tag, node.attrib) for child in node.getchildren(): dump_node(child, indent + 1) if __name__ == \u0026#39;__main__\u0026#39;: tree = ElementTree.parse(\u0026#39;countries.xml\u0026#39;) root = tree.getroot() for node in root.findall(\u0026#39;./country\u0026#39;): print(\u0026#39;-\u0026#39; * 60) dump_node(node) 実行結果 $ python sample.py ------------------------------------------------------------ country {\u0026#39;name\u0026#39;: \u0026#39;Liechtenstein\u0026#39;} rank {} year {} gdppc {} neighbor {\u0026#39;name\u0026#39;: \u0026#39;Austria\u0026#39;, \u0026#39;direction\u0026#39;: \u0026#39;E\u0026#39;} neighbor {\u0026#39;name\u0026#39;: \u0026#39;Switzerland\u0026#39;, \u0026#39;direction\u0026#39;: \u0026#39;W\u0026#39;} ------------------------------------------------------------ country {\u0026#39;name\u0026#39;: \u0026#39;Singapore\u0026#39;} rank {} year {} gdppc {} neighbor {\u0026#39;name\u0026#39;: \u0026#39;Malaysia\u0026#39;, \u0026#39;direction\u0026#39;: \u0026#39;N\u0026#39;} ------------------------------------------------------------ country {\u0026#39;name\u0026#39;: \u0026#39;Panama\u0026#39;} rank {} year {} gdppc {} neighbor {\u0026#39;name\u0026#39;: \u0026#39;Costa Rica\u0026#39;, \u0026#39;direction\u0026#39;: \u0026#39;W\u0026#39;} neighbor {\u0026#39;name\u0026#39;: \u0026#39;Colombia\u0026#39;, \u0026#39;direction\u0026#39;: \u0026#39;E\u0026#39;} パスの指定を ./country から、. に変更すると、ルート要素からすべての要素を出力できます。"},{url:"/p/o2e43ct/",title:"Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen)",date:"2014-11-28T00:00:00Z",body:"Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen) ここでは、Python の組み込みモジュールである urllib.request を使った HTTP アクセスの例を示します。 urlopen による GET/POST リクエストの基本 urllib.request.urlopen 関数は、http.client.HTTPResponse オブジェクトを返します。 HTTPResponse オブジェクトの read メソッドを呼ぶことで、HTTP レスポンスを取得することができます。 https://example.com のコンテンツ (HTML) を取得する from urllib.request import urlopen with urlopen(\u0026#39;https://example.com/\u0026#39;) as res: text = res.read().decode(\u0026#39;utf-8\u0026#39;) print(text) read メソッドが返すデータはバイナリデータ (bytes) なので、テキストとして扱う場合は、エンコーディング形式（utf-8 など）を指定してデコードする必要があります。 urlopen 関数で取得した HTTPResponse オブジェクトは、リソース解放のために明示的に close() することが推奨されているのですが、上記のように Python 3 の with 文を使用すると、close() 処理を自動化できます。 urlopen の引数に、URL 文字列ではなく、urllib.request.Request オブジェクトを渡すこともできます。 Request オブジェクトを使うと、HTTP ヘッダー情報やプロキシ、HTTP メソッド（GET や POST）の指定などを行えます。 HTTP ヘッダーやプロキシを指定したリクエスト import urllib.request URL = \u0026#39;http://example.com/\u0026#39; req = urllib.request.Request(URL, method=\u0026#39;POST\u0026#39;) req.add_header(\u0026#39;Authorization\u0026#39;, \u0026#39;token %s\u0026#39; % \u0026#39;DUMMY_KEY\u0026#39;) req.set_proxy(\u0026#39;proxy.example.com:8080\u0026#39;, \u0026#39;http\u0026#39;) with urllib.request.urlopen(req) as res: text = res.read().decode(\u0026#39;utf-8\u0026#39;) print(text) 参考: urllib による HTTP リクエスト (2) プロキシ経由でアクセスする 参考: urllib による HTTP 通信 (5) ヘッダを付けてリクエストする データ付きの GET/POST リクエスト GET リクエストにクエリ文字列を付加する https://example.com/?name=まく\u0026amp;age=14 のように、URL 末尾のクエリ文字列の形でデータを送るときは、単純に URL をそのように加工します。 ただし、日本語などの値は URL エンコードされている必要があるため、先に urllib.parse.urlencode を使ってデータをエンコードしてから付加します。 import urllib.parse data = { \u0026#39;name\u0026#39;: \u0026#39;まく\u0026#39;, \u0026#39;age\u0026#39;: 14 } url = \u0026#39;https://example.com/?%s\u0026#39; % urllib.parse.urlencode(data) with urllib.request.urlopen(url) as res: text = res.read().decode(\u0026#39;utf-8\u0026#39;) print(text) POST リクエストで JSON データを送る POST リクエストの Body でデータを送るには、urllib.request.Request のコンストラクタの data パラメータに、送りたいデータをセットします（オブジェクト生成後に data プロパティでセットすることもできます）。 data パラメータがセットされると、method パラメータは自動的に POST が指定されたものとして動作します。 次の例では、POST メソッドで JSON データを送信しています。 import json import urllib.parse import urllib.request url = \u0026#39;http://example.com/\u0026#39; data = { \u0026#39;name\u0026#39;: \u0026#39;まく\u0026#39;, \u0026#39;age\u0026#39;: 14 } headers = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } req = urllib.request.Request( url=url, data=json.dumps(data).encode(\u0026#39;utf-8\u0026#39;), headers=headers) with urllib.request.urlopen(req) as res: text = res.read().decode(\u0026#39;utf-8\u0026#39;) print(text) urlopen のエラーハンドル urlopen 関数は次のようなエラーをスローすることがあります。 urllib.error.URLError \u0026hellip; 指定した URL で Web サーバーと通信できなかった場合にスローされます。例えば、ドメイン名が間違っていたり、プロキシサーバーのアドレスが間違っていると発生します。 urllib.error.HTTPError \u0026hellip; 404 Not Found や、500 Internal Server Error など、Web サーバーから HTTP エラーが返された場合にスローされます。 HTTPError は URLError のサブクラスなので、先にハンドルするようにしてください。 import sys import urllib.request # ... try: with urllib.request.urlopen(req) as res: text = res.read().decode(\u0026#39;utf-8\u0026#39;) print(text) except urllib.error.HTTPError as err: print(\u0026#39;Could not access: %s\u0026#39; % req.full_url, file=sys.stderr) print(err, file=sys.stderr) # HTTP Error 404: Not Found print(err.code, file=sys.stderr) # 404 print(err.reason, file=sys.stderr) # Not Found sys.exit(1) except urllib.error.URLError as err: print(\u0026#39;Could not access: %s\u0026#39; % req.full_url, file=sys.stderr) print(err.reason, file=sys.stderr) sys.exit(1) 例えば、上記のコードで 404 Not Found の HTTPError が発生した場合は次のように出力されます。 最初の 2 行くらいを出力しておけばエラー表示としては十分かと思います。 Could not access: http://example.com/DUMMY HTTP Error 404: Not Found 404 Not Found もう一方のエラーである URLError は、ドメイン名などの間違いで、サーバーと通信できなかった場合に発生します（HTTPError の親クラスなので、正確には HTTPError 発生時にも発生しています）。 Could not access: http://MY-FAKE-DOMAIN.com/ [Errno 8] nodename nor servname provided, or not known HTTPError#code などで HTTP ステータスコードを個別に取得する必要がないのであれば、親クラスの URLError だけでまとめてエラーハンドルしてしまっても OK です。 try: with urllib.request.urlopen(req) as res: text = res.read().decode(\u0026#39;utf-8\u0026#39;) print(text) except urllib.error.URLError as err: print(\u0026#39;Could not access: %s\u0026#39; % req.full_url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) Could not access: http://example.com/DUMMY HTTP Error 404: Not Found"},{url:"/p/ogq5hdy/",title:"Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする",date:"2014-11-28T00:00:00Z",body:"Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする urllib.request を使用した HTTP アクセスは、デフォルトでシステムに設定されたプロキシ設定（http_proxy、https_proxy、ftp_proxy 環境変数など）でアクセスが行われます。 これらのプロキシ設定をそのまま使用してもよいし、Python のコード内で明示的にプロキシを設定することもできます。 現在のプロキシ設定を確認する (getproxies) 現在、システムにどのようなプロキシ設定が反映されているかを調べるには、urllib.request.getproxies 関数を使用します。 import urllib.request print(urllib.request.getproxies()) 実行結果 {\u0026#39;http\u0026#39;: \u0026#39;http://proxy.example.com:8080\u0026#39;, \u0026#39;https\u0026#39;: \u0026#39;https://proxy.example.com:8080\u0026#39;, \u0026#39;ftp\u0026#39;: \u0026#39;ftp://proxy.example.com:8080\u0026#39;} リクエストごとにプロキシを設定する (Request) HTTP リクエストごとに使用するプロキシを明示的に指定したい場合は、Request オブジェクトを作成し、set_proxy メソッドでプロキシを指定します。 あとは、その Request オブジェクトを urllib.request.urlopen() に渡して HTTP リクエストを送信します。 リクエスト単位でのプロキシ設定 import urllib.request req = urllib.request.Request(\u0026#39;https://example.com/\u0026#39;) req.set_proxy(\u0026#39;proxy.example.com:8080\u0026#39;, \u0026#39;http\u0026#39;) req.set_proxy(\u0026#39;proxy.example.com:8080\u0026#39;, \u0026#39;https\u0026#39;) with urllib.request.urlopen(req) as res: html = res.read().decode(\u0026#39;utf-8\u0026#39;) print(html) Request#set_proxy() でプロキシサーバーを指定するときは、http:// や https:// といったスキーム名は省略することに注意してください。 スキーム名を記述してしまうと、プロキシがうまく認識されず、次のような DNS エラーになったりします。 urlopen error [Errno 11001] getaddrinfo failed Request オブジェクトは生成時に URL を指定する必要があるため、アクセス先が変わるごとに生成する必要があることに注意してください。 すべてのリクエストに共通のプロキシを設定する (OpenerDirector + ProxyHandler) OpenDirector を使用すると、異なる URL に対して HTTP リクエストを送信するときに、設定情報を使いまわすことができます。 プロキシの情報を設定したい場合は、下記のように ProxyHandler を作成して OpenDirector オブジェクトのハンドラとして追加します。 OpenDirector オブジェクトは、urllib.request.build_opener 関数で生成することができます。 共通のプロキシ設定 import urllib.request PROXIES = { \u0026#39;http\u0026#39;: \u0026#39;http://proxy.example.com:8080\u0026#39;, \u0026#39;https\u0026#39;: \u0026#39;https://proxy.example.com:8080\u0026#39;, \u0026#39;ftp\u0026#39;: \u0026#39;ftp://proxy.example.com:8080\u0026#39; } proxy_handler = urllib.request.ProxyHandler(PROXIES) opener = urllib.request.build_opener(proxy_handler) with opener.open(\u0026#39;https://example.com/\u0026#39;) as res: html = res.read().decode(\u0026#39;utf-8\u0026#39;) print(html) 上記の例では、OpenerDirector#open() メソッドを使うことで、プロキシ経由の HTTP アクセスを行っています。 別の方法として、あらかじめ urllib.request.install_opener() を使って OpenerDirector をインストールしておく方法があります。 このようにすると、その後のすべての urllib.request.urlopen() によるアクセスをプロキシ経由にすることができます（OpenDirector オブジェクトを使ってアクセスする必要がなくなります）。 import urllib.request PROXIES = { \u0026#39;http\u0026#39;: \u0026#39;http://proxy.example.com:8080\u0026#39;, \u0026#39;https\u0026#39;: \u0026#39;https://proxy.example.com:8080\u0026#39;, \u0026#39;ftp\u0026#39;: \u0026#39;ftp://proxy.example.com:8080\u0026#39; } def setup_proxy(): proxy = urllib.request.ProxyHandler(PROXIES) opener = urllib.request.build_opener(proxy) urllib.request.install_opener(opener) if __name__ == \u0026#39;__main__\u0026#39;: setup_proxy() with urllib.request.urlopen(\u0026#39;https://example.com/\u0026#39;) as res: html = res.read().decode(\u0026#39;utf-8\u0026#39;) print(html)"},{url:"/p/an8o6m4/",title:"Python のワンライナーコマンドで JSON ファイルを整形する (json.tool)",date:"2014-11-28T00:00:00Z",body:"Python のワンライナーコマンドで JSON ファイルを整形する (json.tool) json.tool の基本 Python 2.6 以降には json モジュールが標準搭載されていて、これはコマンドラインからも便利に利用することができます。 下記は、json.tool モジュール を使って JSON 形式のテキスト出力を、きれいに整形しなおして出力するワンライナーの例です。 $ python -mjson.tool input.json # あるいは $ cat input.json | python -mjson.tool ここでは、次のような JSON ファイルを使って試してみます。 スペースはわざとぐちゃぐちゃに入れています。 input.json（入力ファイル） {\u0026#34;ccc\u0026#34; : 300, \u0026#34;aaa\u0026#34;:100, \u0026#34;bbb\u0026#34;:200, \u0026#34;data\u0026#34;: [1,2,3]} 実行例 $ python -mjson.tool input.json { \u0026#34;ccc\u0026#34;: 300, \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;data\u0026#34;: [ 1, 2, 3 ] } キー名でソートして出力する (\u0026ndash;sort-keys) Python 3.7 以降で、キーの順序は入力ファイルのものが保持されるようになりました（内部的に辞書オブジェクト (dict) のキー挿入順序が保持されるようになりました）。 キー順序をアルファベット順にソートして出力したいときは、--sort-keys オプションを指定します。 キー順にソートする $ python -mjson.tool --sort-keys input.json { \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;ccc\u0026#34;: 300, \u0026#34;data\u0026#34;: [ 1, 2, 3 ] } インデントサイズを指定する (\u0026ndash;indent=N) バージョン 3.9 以降では、--indent オプションで、インデントサイズの調整などもできるようになっています。 インデントサイズを 2 にする $ python -mjson.tool --indent=2 input.json { \u0026#34;ccc\u0026#34;: 300, \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;data\u0026#34;: [ 1, 2, 3 ] } インデントや改行なしで出力する (\u0026ndash;compact) 余計なスペースや改行を取り除いて、1 行でコンパクトに出力するには、--compact オプションを使用します。 プログラムへの入力にしか使わない JSON データは、このように圧縮されていると効率的です。 コンパクトに出力する $ python -mjson.tool --compact input.json {\u0026#34;ccc\u0026#34;:300,\u0026#34;aaa\u0026#34;:100,\u0026#34;bbb\u0026#34;:200,\u0026#34;data\u0026#34;:[1,2,3]}"},{url:"/p/huevdub/",title:"Dex 形式の Shared library (JAR) を作成する (dx)",date:"2014-10-30T00:00:00Z",body:"Dex 形式の Shared library (JAR) を作成する (dx) Android デバイスの /system/framework に以下に格納して使用する Shared JAR ライブラリは、DEX 形式にコンパイルされたクラスを含んでいる必要があります。Eclipse などで単純に JAR ファイルを生成すると、PC 用の JAR ライブラリができてしまうので、DEX 形式に変換してから /system/framework にインストールする必要があります。 $ dx --dex --output=output.jar input.jar"},{url:"/p/o2m2ft7/",title:"Git でブランチやタグの作者を調べる (git for-each-ref)",date:"2014-09-18T00:00:00Z",body:"Git でブランチやタグの作者を調べる (git for-each-ref) トピックブランチを使った開発手法を適用していると、トピックブランチの削除忘れなどにより、ブランチが散乱してくることがあります。 このような場合は、誰が作成したブランチが放置されているのか調べる必要があります。 下記は、手っ取り早くブランチの作者を調べる方法です。 まずは、GitHub（中央リポジトリ）上で削除済みのブランチは、ローカルのリモートトラッキングブランチからも削除しておきます。 不要なリモートトラッキングブランチを削除 $ git fetch --prune あとは、次のようにすれば、ブランチやタグ (refs) の作者を調べることができます。 ブランチやタグの作者を調べる $ git for-each-ref --format=%(authorname)%09%09%(refname) | sort maku refs/heads/main maku refs/heads/my-branch john refs/remotes/origin/apply-eslint ripper refs/remotes/origin/gh-pages maku refs/remotes/origin/HEAD maku refs/remotes/origin/main"},{url:"/p/2x9it3c/",title:"APK ファイルの署名を確認する (jarsigner, openssl)",date:"2014-08-22T00:00:00Z",body:"APK ファイルの署名を確認する (jarsigner, openssl) 署名情報を確認する方法 JDK に付属している jarsigner コマンドを使用して、APK ファイルの署名情報を確認することができます。 MyApp.apk の署名を確認する $ jarsigner -verify -certs -verbose MyApp.apk ... sm 21632 Mon Sep 01 17:08:16 JST 2014 lib/libhoge.so X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] s 36381 Fri Oct 03 14:10:34 JST 2014 META-INF/MANIFEST.MF X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] 36434 Fri Oct 03 14:10:34 JST 2014 META-INF/CERT.SF 1203 Fri Oct 03 14:10:34 JST 2014 META-INF/CERT.RSA s = signature was verified m = entry is listed in manifest k = at least one certificate was found in keystore i = at least one certificate was found in identity scope jar verified. 証明書の公開鍵 (Subject Public Key Info) を確認する方法 APK 内の証明書から、公開鍵情報を抽出するには、openssl ツールを使用して下記のように実行します。 $ jar xvf MyApp.apk META-INF # APK内の証明書を抽出 $ openssl pkcs7 -inform DER -in META-INF/CERT.RSA -noout -print_certs -text Certificate: Data: Version: 3 (0x2) Serial Number: 553438828 (0x20fcce6c) Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=Android, CN=Android Debug Validity Not Before: Aug 27 08:19:20 2012 GMT Not After : Aug 20 08:19:20 2042 GMT Subject: C=US, O=Android, CN=Android Debug Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:bb:40:43:86:b6:9e:84:5a:8b:b3:b3:c0:bc:08: f0:8f:28:92:7c:7a:3d:02:44:da:17:4b:d0:a0:c5: 86:eb:f8:b4:2e:3e:3d:10:60:bc:dd:fe:5e:a9:17: c8:ba:eb:bb:fc:96:ff:a2:02:39:77:42:ab:db:0b: d1:9b:09:34:f3:3b:20:89:27:8c:d2:99:0d:2b:e1: 4a:34:49:5a:4a:76:ad:b4:a4:9d:4c:6a:42:fa:07: 0f:b3:ae:90:d3:19:7f:74:78:5d:73:27:f3:52:0b: 82:64:2c:d6:64:e0:c9:56:97:c8:c4:53:e7:35:e5: b6:25:c5:58:cd:85:bd:64:f6:94:da:d1:0e:72:1d: 8f:ad:f8:b8:f7:ae:37:18:70:a2:b7:01:f4:42:c1: 04:bc:3b:b6:a0:85:29:95:5f:e7:c8:82:4b:b0:01: db:1b:5b:06:c2:c1:e1:8d:e6:35:bf:f4:5f:ef:20: b0:7f:f8:b8:36:fa:8d:48:7b:4b:35:c1:6a:a1:42: 1a:e7:df:b2:af:a9:8d:d3:9b:0d:6a:bf:c8:fc:94: 3d:99:61:1c:94:a6:40:1b:94:ac:e6:8e:07:20:77: 39:87:3e:86:38:a6:9e:c1:75:9a:13:99:06:73:b9: d3:22:66:30:2f:e1:ea:4a:01:6e:8d:7d:ed:82:b2: 79:f7 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 8D:5D:22:F1:D1:23:18:0D:B2:6A:B0:2E:71:BE:83:3F:BF:C6:F1:D0 Signature Algorithm: sha256WithRSAEncryption 47:97:ba:aa:e6:c0:52:83:d3:52:0b:be:4f:b9:7b:bd:06:a3: 06:d3:ee:62:89:35:e4:a7:02:fc:99:53:b6:97:23:10:c9:17: 94:c3:e8:4a:70:79:05:5b:1b:d7:6b:f9:45:09:33:8f:a1:ac: cb:60:54:65:13:b4:61:ce:39:0c:40:65:08:6d:d8:ab:03:15: 84:96:55:2e:bd:3f:c1:bb:d5:85:9d:91:91:27:e8:83:e9:17: 0e:31:3d:f3:a4:33:ac:a0:1d:65:65:42:d8:90:e3:3b:e7:04: 42:81:d5:51:b2:0d:cc:b1:d7:64:f1:f7:aa:c8:56:09:ea:7c: af:7b:b4:f0:48:49:b7:7b:1a:c1:1a:a1:8e:1b:46:c5:50:54: e0:a9:c0:63:0e:d4:8d:58:70:77:91:ce:d0:d6:5d:ba:38:f6: ab:2d:16:23:f9:de:61:b1:c0:af:ed:a9:3e:85:f8:ed:da:47: fe:04:58:31:1a:eb:54:8f:fe:1f:a1:68:12:1f:bf:83:31:05: fa:d3:30:d3:52:59:2b:4a:fb:9b:0a:aa:0e:02:b6:b3:39:75: f9:c0:5f:b4:0e:09:f8:f5:80:e3:54:49:c0:33:e4:36:88:42: 34:fa:01:50:03:58:ca:20:0e:44:a1:eb:c2:c2:6e:e6:11:30: ec:77:71:b2"},{url:"/p/t6wfxev/",title:"メモリの使用状況を確認する (dumpsys meminfo)",date:"2014-07-29T00:00:00Z",body:"メモリの使用状況を確認する (dumpsys meminfo) 各プロセスのメモリ使用状況を確認する dumpsys コマンドの meminfo セクションでは、各プロセスのメモリ使用状況を確認することができます。 $ adb shell dumpsys meminfo Applications Memory Usage (kB): Uptime: 169910958 Realtime: 170196415 Total PSS by process: 96302 kB: system (pid 728) 44547 kB: com.android.systemui (pid 965) 32601 kB: com.sonyericsson.android.pobox.imecore (pid 1042) 29610 kB: com.android.settings (pid 8006) 26500 kB: com.sonyericsson.home (pid 1321) 23027 kB: com.facebook.katana (pid 7371) 17963 kB: com.facebook.katana:dash (pid 7641) 13579 kB: com.google.android.gms (pid 5171) ... プロセスを指定してメモリ使用状況を確認する 上記で表示されたパッケージ名や pid を、dumpsys meminfo コマンドの後ろに続けて指定することで、そのプロセスにおける詳細なメモリ使用情報を調べられます。 $ adb shell dumpsys meminfo com.android.phone Applications Memory Usage (kB): Uptime: 170096486 Realtime: 170381943 ** MEMINFO in pid 1066 [com.android.phone] ** Shared Private Heap Heap Heap Pss Dirty Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ Native 20 8 20 2376 2323 48 Dalvik 3236 5256 3156 11108 3032 8076 Cursor 0 0 0 Ashmem 2 4 0 Other dev 4 48 0 .so mmap 564 2232 464 .jar mmap 6 0 0 .apk mmap 955 0 0 .ttf mmap 0 0 0 .dex mmap 0 0 0 Other mmap 2113 16 184 Unknown 1058 484 1056 TOTAL 7958 8048 4880 13484 5355 8124 Objects Views: 0 ViewRootImpl: 0 AppContexts: 13 Activities: 0 Assets: 7 AssetManagers: 7 Local Binders: 45 Proxy Binders: 25 Death Recipients: 5 OpenSSL Sockets: 0 SQL MEMORY_USED: 178 PAGECACHE_OVERFLOW: 32 MALLOC_SIZE: 62 DATABASES pgsz dbsz Lookaside(b) cache Dbname 4 16 22 131/19/2 /data/data/com.android.providers.telephony/databases/telephony.db 4 20 25 1/19/2 /data/data/com.android.phone/databases/rejectmsgs.db プログラムからメモリ使用状況を確認する Android プログラムの実装からメモリ情報を取得するには、android.os.Debug クラスを使用します。 // Native ヒープの使用可能最大サイズ long total = Debug.getNativeHeapSize(); // Native ヒープの残りサイズ long free = Debug.getNativeHeapFreeSize() // Native ヒープの割り当て済みサイズ long alloc = Debug.getNativeHeapAllocatedSize(); デバイス上で procrank が使用できる場合 Android デバイスを debug ビルドパッケージで開発しているときは、Linux の procrank コマンドを使用できるかもしれません。 adb shell で Android デバイスに接続して次のように実行します。 # procrank PID Vss Rss Pss Uss cmdline 890 84456K 48668K 25850K 21284K system_server 1231 50748K 39088K 17587K 13792K com.android.launcher2 947 34488K 28528K 10834K 9308K com.android.wallpaper 987 26964K 26956K 8751K 7308K com.google.process.gapps 954 24300K 24296K 6249K 4824K com.android.phone 948 23020K 23016K 5864K 4748K com.android.inputmethod.latin 888 25728K 25724K 5774K 3668K zygote 977 24100K 24096K 5667K 4340K android.process.acore ..."},{url:"/p/yujway4/",title:"GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages)",date:"2014-07-14T00:00:00Z",body:"GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages) GitHub Pages という機能を使用すると、GitHub 上で Web サイトをホスティングできます。GitHub を開発用にだけ使うのであれば、リポジトリだけ公開しておけばよいのですが、作成したソフトウェアを配布したり、マニュアルを公開するのであれば、GitHub Pages 上で通常の Web サイトとして見えるようにしておくのがよいでしょう。 プロジェクトの Web サイトを作る 各プロジェクト用の GitHub Pages は非常に簡単に作成できます。 各リポジトリに gh-pages という名前のブランチを作り、そこに Web サイトのコンテンツ（index.html など）をコミットすれば、そのプロジェクト用の Web サイトとして見えるようになります。 https://\u0026lt;username\u0026gt;.github.io/\u0026lt;repository\u0026gt;/ Organization を作成している場合は、上記の \u0026lt;username\u0026gt; のところを、\u0026lt;organization\u0026gt; と読み替えてください。 ☝️ GitHub Pages の非公開化 プライベートリポジトリで GitHub Pages (gh-pages) を作ったとしても、Web サイトはインターネット上に公開されてしまうことに注意してください。 プライベートな情報提供サイトを作る場合は、リポジトリの README.md や Wiki を活用するか、独自で Web サーバを立ち上げる必要があります。 あるいは、GitHub Enterprise Cloud という高額なプランを導入すれば、非公開の GitHub Pages を作成することができます。 参考: Changing the visibility of your GitHub Pages site - GitHub Enterprise Cloud Docs ユーザ用、組織用の Web サイトを作る GitHub Pages では、リポジトリごとの Web サイトだけではなく、ユーザや組織用のトップサイトを作成することも可能です。 その場合は、\u0026lt;username\u0026gt;.github.io という名前のリポジトリを作成し、その main ブランチにコンテンツを格納してください（この場合はリポジトリが Web サイト専用になるので、gh-pages ブランチを作る必要がありません）。 下記のようなアドレスで参照できるようになります。 https://\u0026lt;username\u0026gt;.github.io/ GitHub Pages のコンテンツ生成の仕組み \u0026ndash; Jekyll GitHub Pages は内部では Jekyll が動作しており、Markdown 形式で記事を記述したり、ブログのようなものも簡単に作成することができるようになっています。 Jekyll 用のフォーマット（先頭に YAML 形式のヘッダを付ける）で記述したファイルを作成するだけで、自動的に GitHub Pages 側で変換処理が行われ、Web サイトとして表示できるようになります。 Jekyll でどんなことができるかは、Jekyll 本家のサイトを参照しましょう。"},{url:"/p/rcaip63/",title:"Python の関数で可変長引数を扱う (*args, **kwargs)",date:"2014-06-02T00:00:00Z",body:"Python の関数で可変長引数を扱う (*args, **kwargs) 可変長引数 関数に任意の数の引数を渡せるようにするには、パラメーター名の前にアスタリスク (*) を付けます。 下記の print_lines 関数には、任意の数（0 個以上）の文字列を渡すことができます。 def print_lines(*lines: str) -\u0026gt; None: for line in lines: print(line) # 使用例 print_lines(\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;Python\u0026#34;) 実行結果 Hello World Python 関数内では、lines パラメーターは文字列型 (str) のタプルとして参照できます。 任意のキーワード引数を渡せるようにする パラメーター名の前に 2 つのアスタリスク (**) を付けると、任意のキーワード引数を受け取れる関数になります。 パラメーター名には慣例としてよく kwargs が使われます（keyword arguments の略）。 def process_data(**kwargs) -\u0026gt; None: for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) # 使用例 process_data(name=\u0026#34;John\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) process_data(subject=\u0026#34;Python\u0026#34;, level=\u0026#34;Intermediate\u0026#34;, duration=5) 実行結果 name: John age: 30 city: New York subject: Python level: Intermediate duration: 5 関数内では、kwargs パラメーターは辞書オブジェクトとして参照できます。 その他 可変長引数の伝播 可変長引数として受け取ったタプルや辞書オブジェクトを、可変長引数を受け取る別の関数に渡すときは、一度展開して渡す必要があります。 変数名の前に * や ** をつけると展開できます。 def foo(*args, **kwargs): print(args, kwargs) def bar(*args, **kwargs): foo(*args, **kwargs) # タプルや辞書オブジェクトは展開して渡す 各種引数の組み合わせ 次のように、各種引数を組み合わせて定義することもできます。 ただし、可変長引数の後ろにある引数は、キーワード引数の形で指定して呼び出す必要があります。 これは、位置引数の終わり（下記例では \u0026quot;Alias-2\u0026quot;）が可変長引数に渡す引数の終わりと判断されるからです。 def show_book_info(title: str, *aliases: str, note: str, **kwargs) -\u0026gt; None: print(f\u0026#34;Title: {title}\u0026#34;) for alias in aliases: print(f\u0026#34;Alias: {alias}\u0026#34;) print(f\u0026#34;Note: {note}\u0026#34;) for key, value in kwargs.items(): print(f\u0026#34;{key}: {value}\u0026#34;) # 使用例 show_book_info(\u0026#34;Title\u0026#34;, \u0026#34;Alias-1\u0026#34;, \u0026#34;Alias-2\u0026#34;, note=\u0026#34;Note\u0026#34;, tag1=\u0026#34;A\u0026#34;, tag2=\u0026#34;B\u0026#34;) 実行結果 Title: Title Alias: Alias-1 Alias: Alias-2 Note: Note tag1: A tag2: B 参考 Python の関数をキーワード引数を使って呼び出す"},{url:"/p/af7q7n3/",title:"Git 設定のスコープ (local/global/system) を理解する",date:"2014-05-25T00:00:00Z",body:"Git 設定のスコープ (local/global/system) を理解する Git 設定の 3 つのスコープ git config による設定のスコープは 3 種類あり、スコープが狭くなるほど参照時の優先度は高くなります。 下記はそれぞれのスコープでの設定方法を、優先度の高い順に示しています。 カッコの中のファイル名は、コマンドを実行したときの設定値の保存先です。 $ git config --local ... # 各リポジトリごとの設定 (.git/config)（優先度:高） $ git config --global ... # 現在のユーザの共通設定 (~/.gitconfig) $ git config --system ... # システム内の共通設定 (/etc/gitconfig など)（優先度:低） 例えば、global 設定で user.name が Ichiro になっていても、local 設定が Jiro になっていれば、Jiro の方が優先的に使用されます。 プロジェクト（リポジトリ）ごとに固有の設定をする場合は、local なスコープで設定を行うとよいでしょう。 この場合、プロジェクトの作業ツリーのトップにある .git/config に設定が保存されます。 例えば、次のようにして local 設定の user.name と user.email を変更することができます。 $ git config --local user.name maku77 $ git config --local user.email maku77@example.com 上記コマンドを実行した後で、\u0026lt;リポジトリ\u0026gt;/.git/config ファイルを開くと次のように設定情報が保存されていることが分かります。 \u0026lt;リポジトリ\u0026gt;/.git/config（抜粋） [user] name = maku77 email = maku77@example.com 参考: Git の設定値がどのファイルで設定されているか調べる (config \u0026ndash;show-origin) それぞれの設定ファイルをコマンドで開く (git config \u0026ndash;edit) 各スコープの設定ファイルは、git config --edit コマンドで開くことができます。 $ git config --edit # リポジトリの設定ファイルを開く（local 設定） $ git config --edit --local # （同上） $ git config --edit --global # ユーザーの設定ファイルを開く（global 設定） $ git config --edit --system # システムの設定ファイルを開く（system 設定） 使用するエディタは、core.editor 設定や、GIT_EDITOR 環境変数などで指定できます。 参考: コミット時にコメント記述に使用するエディタを設定する (core.editor) Windows の場合のホームディレクトリ (USERPROFILE, HOME) global スコープの設定は、ユーザのホームディレクトリの .gitconfig ファイルに設定値が保存されますが、Windows の場合のホームディレクトリは、デフォルトで USERPROFILE 環境変数で取得できるディレクトリが使用されます。 C:\\\u0026gt; echo %USERPROFILE% C:\\Users\\maku 例えば、上記の場合は C:\\Users\\maku が Git のホームディレクトリとして使用されるので、global スコープの設定は、C:\\Users\\maku\\.gitconfig に保存されます。 ただし、HOME 環境変数が設定されている場合は、そちらのディレクトリがホームディレクトリとして使用されます。"},{url:"/p/x63is5h/",title:"（旧）GitHub のプランと GitHub ライクなツールの比較など（GitHub と GitLab の比較）",date:"2014-05-14T00:00:00Z",body:"（旧）GitHub のプランと GitHub ライクなツールの比較など（GitHub と GitLab の比較） GitHub Public repository と Private repository プラン GitHub は公開リポジトリのみであれば無料で使用できるが、非公開にするには有料。 10 repos で $25/month 20 repos で $50/month GitHub Enterprise（社内サーバ用） GitHub 社が提供している、GitHub の機能をまるごと含めた VM。 サーバは別途用意する必要あり。 社内で GitHub の機能を使ってコード管理したい場合などに有用。 若干高い。20 person で $5,000/year GitLab 特徴 一番メジャーなオープンソースの GitHub クローン 実装は Ruby on Rails. (+ PostgreSQL, Redis, Nginx, Unicorn, etc.) インストールは比較的容易。 Pull Request もどき有り (Merge Request)。ブランチ間のマージも可能。 LDAP 連携。ActiveDirectory 連携。 GitHub より便利なところ ユーザに対して Master 権限と Developer 権限を分けて設定することで、master ブランチへマージできる人を制限できる。これにより、チーム内開発において、トピックブランチを使用した開発を強制できるようになる（GitHub フローなど）。 MergeRequest のコメントで各ユーザが +1 と記述しておくと、MergeRequest のページにその合計数が表示される。これを利用して、「+3 溜まったらトピックブランチをマージしてよい」といった運用を行うことができる。 Gitorious 特徴 若干独自路線気味の GitHub クローン 実装は Ruby on Rails. インストール、サーバ管理に難あり（モジュール依存が多い）。 Pull Request もどき有り (Merge Request)。ブランチ間のマージ機能がないので、GitHub Flow のような開発方法は行えない（2014-05-14 現在）。 権限＆Roll制御。ユーザごとに push 可能なリポジトリを制御可能。"},{url:"/p/ubtbs9p/",title:"Python コードの実行時間を計測する (datetime.now)",date:"2014-05-01T00:00:00Z",body:"Python コードの実行時間を計測する (datetime.now) 下記は datetime モジュールを使って、Python コードの一部の実行時間を計測する例です。 main.py from datetime import datetime start = datetime.now() # ここに実行時間を計測したい処理を記述する print(datetime.now() - start) 実行結果 $ python3 main.py 00:00:01.547393"},{url:"/vim/",title:"Vim",date:"2014-01-27T00:00:00Z",body:"Vim 基本 ヘルプコマンドの使い方 (:help, :helpgrep) 移動 カーソルの移動方法まとめ 画面スクロール方法まとめ カーソル位置にマークしてジャンプしてこれるようにする C/C++ の変数／マクロの定義位置にジャンプする 文字の削除方法まとめ (d, delete) 文字の置換方法まとめ (:s, :substitute) ウィンドウを分割する アンドゥとリドゥ操作 ビジュアルモードの基本 コマンドモード コマンドモードでコマンド入力を補完する コマンドモードでのカーソル移動 ex コマンドの行範囲指定方法いろいろ 検索 Vim 内で grep を実行して見つかったファイルへジャンプする ファイル内の文字列を検索する カーソル位置の単語を検索する カーソル位置の単語に対して任意のコマンド（ヘルプなど）を実行する (keywordprg) 大文字と小文字を区別しないで検索する 検索に関する設定 コマンドライン Vim を起動するときに行番号を指定してファイルを開く サイレントバッチモードで Ex スクリプトをファイルに適用する ファイル ファイルを開く ファイル名を指定してファイルを開く カーソル位置の単語をファイル名としてファイルを開く (gf) 編集中のファイルと拡張子だけが異なるファイルを開く (%\u0026lt;)（Hello.cpp を編集中に Hello.h を開く） ディレクトリエクスプローラー (Explore) を使用してファイルを開く (:E, :Ve, :He) カレントディレクトリを Windows エクスプローラーで開く ファイルを保存する ファイルへの保存コマンド :w、:x の基本 指定した行範囲だけ別のファイルに保存する その他 別ファイルの内容や外部コマンドの実行結果をカーソル位置に挿入する (:read) ファイルのエンコーディング形式、改行コードを変更する (fenc, ff) スワップファイルからファイルを復旧する (:recover) 2 つのファイルの差分を取る・マージする (vimdiff, vim -d) 編集操作 挿入モード（インサートモード）のまま実行できる操作の一覧 XML/HTML の編集に便利なコマンド 文字の追加 補完機能を使用してテキストを入力する 同じテキストを指定した回数だけ繰り返し挿入する 複数行の行頭に同じテキストを追加する 上の行の文字、下の行の文字をコピーする (CTRL-Y, CTRL-E) 削除 空行（改行だけの行）を削除する 行末の余分なスペースをまとめて削除する 記号（引用符など）で囲まれた範囲のテキストを削除する 正規表現にマッチする行を削除する 整形／変換 行を連結する 文字を入れ替える、行を入れ替える（スワップ操作） インデント用のスペースを入力する（シフトコマンド） 選択した範囲を自動インデントする すでに入力されているタブをスペースに変換する (:retab) テキストを中央寄せ／左寄せ／右寄せする 大文字と小文字を変換する カーソル位置の数字をインクリメント／デクリメントする ソート 行をソートして重複行を削除する 行を逆順にソートする カット＆ペースト 挿入モード、コマンドモードでの貼り付け 最後にヤンクしたテキストを確実に貼り付ける 切り取り＆貼り付け操作、レジスタの扱いについて理解する 応用操作 Vim 上でディレクトリツリーを表示する (NERDTree) 折りたたみ機能 (folding) を使用する 指定した行範囲を一時的に表示する 一時的にシェル（ターミナルやコマンドプロンプト）を起動する キーボードマクロを記録して一連のキー入力を繰り返し実行する プリンタで印刷する (hardcopy) 行の情報を表示する ファイルに保存した ex スクリプトを実行する プログラマ向け操作 プログラムの関数定義などにジャンプする（tags ファイルの利用） インストール／環境 MacOSX に香り屋版の GVim をインストールする Vundle をインストールして Vim のプラグイン環境を作る Windows の右クリックから Vim を開けるようにする Windows でファイルを開くときに既存の GVim 内のタブで開く Vim の設定 ファイル・ディレクトリに関する設定と操作 設定ファイルのパスを確認する 設定ファイル (.vimrc) を開く、リロードする モードラインでファイルごとに書式を設定する バックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile) ウィンドウ（タブ）移動時にカレントディレクトリも自動で移動する (autochdir) キーマップ設定 キーマップの基本 (map, noremap) 現在のキーマップの一覧を表示する (map) map、noremap 系コマンドで使用できる特殊キーの一覧 (keycodes) Leader キーを使ったキーコンビネーションを定義する (mapleader) キーマップの例 ショートカットキーで設定ファイル (.vimrc) を開く ショートカットキーで日時を挿入する ショートカットキーでタブを切り替える ショートカットキーでカレントディレクトリを Windows エクスプローラーや Mac の Finder で開く autocmd（自動コマンド）による設定 autocmd で自動コマンドを登録する 編集中のスクリプト（Ruby や Python など）をショートカットキーで実行する 開いたファイルがあるディレクトリをカレントディレクトリにする 表示の設定 行番号を表示する (set number) 80文字目に縦線を表示する (colorcolumn) 構文強調（シンタックスハイライト）を有効にする (syntax) カーソル下の行や列をハイライト表示する (cursorline, cursorcolumn) フォント設定ダイアログを開いてフォントを設定する (guifont) 改行、タブ文字、行末のスペースを表示する (list, listchars) 全角スペースを表示する ■や※などの記号が重なって表示される問題の解決 (ambiwidth) GVim 起動時のウィンドウの幅、高さを設定する (columns, lines) ステータスラインの表示内容を設定する (statusline, laststatus) 入力に関する設定 インサートモード中に Backspace キーや CTRL-W で文字を削除するときの振る舞いを変更する (backspace) タブ文字の設定 (tabstop, expandtab) インデント（シフトコマンド）の設定 (shiftwidth, shiftround) 省略形を用いたテキスト入力を行えるようにする (abbrevaite) スペルチェックを有効にする (spell) 自動インデントモードを有効にする (autoindent, cindent, smartindent) Java や C/C++ のコメント記述に便利な formatoptions の設定 ビジュアルモードで簡単にインデントを行えるようにする Vim プログラミング（マクロ）／特殊用途 （外部サイト）Learn Vimscript the Hard Way カーソル位置の単語を取得する (cword) カーソル位置の文字の文字コードを表示する (ascii)"},{url:"/p/r5fcfgk/",title:"Vim/NeoVim でショートカットキーで .vimrc ファイルを開く",date:"2014-01-27T00:00:00Z",body:"Vim/NeoVim でショートカットキーで .vimrc ファイルを開く ショートカットキーで .vimrc を開く Vim/NeoVim の設定ファイルで、下記のようにキーマッピング設定をしておくと、F1 キーを押すだけで簡単に .vimrc ファイル（NeoVim の場合は init.vim）を開けるようになります。 .vimrc（NeoVim なら init.vim） \u0026#34; F1 キーで設定ファイルを開く if has(\u0026#39;nvim\u0026#39;) \u0026#34;NeoVim の場合 nnoremap \u0026lt;F1\u0026gt; :tabnew \u0026lt;C-R\u0026gt;=expand(stdpath(\u0026#39;config\u0026#39;)) . \u0026#39;/init.vim\u0026#39;\u0026lt;CR\u0026gt;\u0026lt;CR\u0026gt; else \u0026#34;Vim の場合 nnoremap \u0026lt;F1\u0026gt; :tabnew $MYVIMRC\u0026lt;CR\u0026gt; endif ここでは、:tabnew コマンドを使って、新しいタブで設定ファイルを開くようにしています。 NeoVim と Vim で設定ファイルのパスが異なるので、if has('nvim') で分岐しています。 さらに、NeoVim の設定ファイルのパスは、Windows と Linux/macOS で異なりますが、stdpath('config') を使って親ディレクトリのパスを取得すればコードを共通化できます。 参考 Vim/NeoVim の設定ファイルのパスを確認する Vim/NeoVim で設定ファイル (.vimrc) を開く、リロードする"},{url:"/p/ptactsj/",title:"Node.js スクリプトにシェバング (#!` を付けてコマンドとして起動できるようにする",date:"2013-11-19T00:00:00Z",body:"Node.js スクリプトにシェバング (#!` を付けてコマンドとして起動できるようにする 一般的なスクリプト言語と同様に、Node.js で動作させるアプリもシェバング (#!) で node コマンドを指定しておくことができます。 app.js #!/usr/bin/env node console.log(\u0026#39;Hello\u0026#39;); あとは、.js ファイルに実行権限を付けてやれば、コマンドとして扱うことができるようになります。 実行方法 $ chmod +x app.js $ ./app.js Hello"},{url:"/p/ybxfwev/",title:"Python でコマンドライン引数を扱う (sys.argv)",date:"2013-10-20T00:00:00Z",body:"Python でコマンドライン引数を扱う (sys.argv) ここでは、sys.argv でコマンドライン引数を参照する初歩的な方法を説明しますが、ある程度複雑なコマンドライン引数を扱いたいときは、Python の標準ライブラリの argparse モジュールを使う ことをおすすめします。 コマンドライン引数を参照する Python スクリプト起動時にコマンドライン引数として渡された値は、sys.argv で文字列リストの形で参照することができます。 先頭の要素 sys.argv[0] には、python コマンドで指定したスクリプト自身の名前が格納されています。 コマンドライン引数を参照する (sample.py) import sys print(sys.argv) print(len(sys.argv)) 実行例 $ python sample.py aaa bbb ccc [\u0026#39;sample.py\u0026#39;, \u0026#39;aaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccc\u0026#39;] 4 sys.argv の先頭にスクリプト自身の名前が入っているので、len(sys.argv) は少なくとも 1 以上の値になります。 コマンドライン引数が正しく指定されていないときに Usage 表示する 下記は、コマンドライン引数を 1 つも指定せずにスクリプトを実行した場合に使い方 (usage) を表示して終了するサンプルです。 コマンドライン引数が不正なときに終了する (hello.py) import sys import os if len(sys.argv) \u0026lt; 2: # コマンドライン引数が指定されなかった場合は終了 print(f\u0026#34;Usage: python {os.path.basename(sys.argv[0])} \u0026lt;name\u0026gt;\u0026#34;) sys.exit(1) print(f\u0026#34;Hello, {sys.argv[1]}!\u0026#34;) 実行例 $ python hello.py Usage: python hello.py \u0026lt;name\u0026gt; $ python hello.py Maku Hello, Maku! スクリプト名を除いてコマンドライン引数を取得する sys.argv[0] には自身のスクリプトファイル名が含まれています。 純粋にコマンドライン引数だけを取り出したい場合は、sys.argv[1:] のようにインデックス 1 以降を取り出してしまうと分かりやすくなります。 コマンドライン引数がひとつも渡されなかった場合は、sys.argv[1:] は空リストになります。 コマンドライン引数のみを取り出す (sample.py) import sys args = sys.argv[1:] for x in args: print(x) 実行例 $ python sample.py 100 200 100 200 （おまけ）ハッカー流のコマンドライン引数の処理方法 下記は、高校生ハッカーが主人公のドラマ『ブラッディ・マンデイ』の中で、主人公であるファルコンが使ってた方法です。 なんらかの攻撃ツールを即席で実装してたシーン。 強引に sys.argv をスライスしてしまって、正しい数のパラメータを指定されていない場合に、ValueError 例外を発生させてしまうやり方です。 なるほどねー import sys try: host, frm, to = sys.argv[1:4] except ValueError: print(\u0026#34;Usage: %s \u0026lt;host\u0026gt; \u0026lt;from\u0026gt; \u0026lt;to\u0026gt;\u0026#34; % (sys.argv[0])) sys.exit(1)"},{url:"/p/bq6yzpr/",title:"Python で dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault)",date:"2013-06-15T00:00:00Z",body:"Python で dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault) Python の dictionary に値をセットするときに、まだそのキーが存在しない場合だけ新しい値をセットしたい場合は、dict.setdefault() メソッドを使用します。 setdefault() メソッドは、既にキーが存在している場合は格納されている値、存在しない場合は第 2 引数で指定した値を返します。 val = d.setdefault(\u0026#39;key\u0026#39;, \u0026#39;default_value\u0026#39;) つまり、dict.setdefault() は、dict.get() を行いつつ、存在しないキーを指定した場合は、値のセットまで行う という振る舞いをします。 典型的な使用例として、dictionary 要素の値としてリストを格納するというユースケースがあります。 次のように、キーに対応するリストを取り出すときに setdefault() を使えば、キーがまだ存在しないときに自動的に空のリストを生成し、dictionary に登録してくれます。 d = {} l = d.setdefault(\u0026#39;key\u0026#39;, []) # このキーは存在しないので初期値として空リストを格納し、さらにその参照を返す l.append(100) # d[\u0026#39;key\u0026#39;] が [100] になる もう一度、同じキー key で参照しようとすると、今度はすでに dictionary に格納されているリストへの参照を取得することができます。 l = d.setdefault(\u0026#39;key\u0026#39;, []) # このキーは既に存在しているので、格納されているリスト [100] の参照を返す l.append(200) # d[\u0026#39;key\u0026#39;] は [100, 200] になる 上記のコードは、次のように get() メソッドでデフォルト値を指定しておく方法と似ています。 ただし、このようにした場合は、get() によって返された新規リストオブジェクトを忘れずに dictionary に格納しなければいけません。 setdefault() を使わないとちょっと面倒になる l = d.get(\u0026#39;key\u0026#39;, []) l.append(100) d[\u0026#39;key\u0026#39;] = l # デフォルト値が生成されたときのために dictionary に格納する必要がある"},{url:"/p/gwfweub/",title:"JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps)",date:"2013-05-22T00:00:00Z",body:"JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps) Python には JSON フォーマットを扱うための json モジュールが標準搭載（Python 2.6 以降）されており、JSON 形式のテキストと、Python のオブジェクトを相互に変換することができます。 JSON 文字列 → Python オブジェクト (json.loads) JSON 形式の文字列データから、Python オブジェクトを作成するには json.loads 関数 を使用します。 import json data = json.loads(\u0026#39;{\u0026#34;key\u0026#34;:\u0026#34;value\u0026#34;}\u0026#39;) print(data[\u0026#39;key\u0026#39;]) #=\u0026gt; \u0026#39;value\u0026#39; json.loads と似た関数に、json.load 関数がありますが、こちらは文字列ではなく JSON ファイルを読み込みます。 loads の末尾の s は、文字列を受け取ることを示しています。 参考: JSON 形式のテキストファイルを Python オブジェクトとして読み込む (json.load) Python オブジェクト → JSON 文字列 (json.dumps) 逆に、Python オブジェクトから JSON 形式のテキストを生成するには、json.dumps 関数 を使用します。 import json obj = {\u0026#39;aaa\u0026#39;:100, \u0026#39;bbb\u0026#39;:200} json_str = json.dumps(obj) print(json_str) 実行結果 {\u0026#34;bbb\u0026#34;: 200, \u0026#34;aaa\u0026#34;: 100} 整形して出力する (indent=2) 改行を入れた形で見やすく出力したい場合は、json.dumps() 関数の indent パラメータに、インデントのスペース数を指定します（Python 3.2 以降は、インデントに使用する文字列そのものを指定できるようになりました）。 obj = {\u0026#39;aaa\u0026#39;:100, \u0026#39;bbb\u0026#39;:200} json_str = json.dumps(obj, indent=2) print(json_str) 実行結果 { \u0026#34;bbb\u0026#34;: 200, \u0026#34;aaa\u0026#34;: 100 } キーでソートして出力する (sort_keys=True) デフォルトでは、json.dumps() は辞書オブジェクトの要素を追加順に出力します（Python 3.7 より前は不定でした）。 アルファベット順にキー名でソートして出力したい場合は、json.dumps() 関数の sort_keys パラメータを True に設定します。 print(json.dumps(obj, indent=2, sort_keys=True)) 実行結果 { \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200 } 日本語を Unicode エスケープしない (ensure_ascii=False) 日本語を含んだオブジェクトを json.dumps で文字列に変換すると、デフォルトで Unicode エスケープされます。 obj = {\u0026#39;a\u0026#39;: \u0026#39;あいう\u0026#39;} print(json.dumps(obj)) #=\u0026gt; {\u0026#34;a\u0026#34;: \u0026#34;\\u3042\\u3044\\u3046\u0026#34;} これは、XSS などの脆弱性を防ぐためですが、使用用途が限られているのであれば、UTF-8 エンコーディングの日本語をそのまま出力してしまった方がわかりやすいです。 非 ASCII 文字の Unicode エンコーディングを停止するには、ensure_ascii=False オプションを指定します。 obj = {\u0026#39;a\u0026#39;: \u0026#39;あいう\u0026#39;} print(json.dumps(obj, ensure_ascii=False)) #=\u0026gt; {\u0026#34;a\u0026#34;: \u0026#34;あいう\u0026#34;} （おまけ） JSON 文字列を整形する関数を作ってみる 次の pretty_json() 関数は、JSON 形式の文字列データを、きれいにインデントや改行を入れた形に整形します。 まず、json.loads で「JSON文字列→オブジェクト」の変換をしてから、json.dumps で「オブジェクト→JSONテキスト」と逆変換しています。 sample.py import json def pretty_json(json_text): \u0026#34;\u0026#34;\u0026#34;JSON 文字列を読みやすく整形して返します。\u0026#34;\u0026#34;\u0026#34; temp = json.loads(json_text) return json.dumps(temp, indent=2, sort_keys=True) s = \u0026#39;{\u0026#34;aaa\u0026#34;:100, \u0026#34;bbb\u0026#34;:200, \u0026#34;ccc\u0026#34;:300}\u0026#39; print(pretty_json(s)) 実行結果 { \u0026#34;aaa\u0026#34;: 100, \u0026#34;bbb\u0026#34;: 200, \u0026#34;ccc\u0026#34;: 300 } 次のステップとして、パラメーターに文字列ではない通常のオブジェクトを受け取った場合でも JSON 文字列に変換できるようにしてみます。 isinstance 関数を使うと、あるオブジェクトが文字列型 (str) かどうかを判別することができます。 下記の pretty_json() 関数は、JSON 文字列、あるいは任意の Python オブジェクトを受け取って、整形された JSON 文字列として返します。 import json def pretty_json(obj): temp = json.loads(obj) if isinstance(obj, str) else obj return json.dumps(temp, indent=2, sort_keys=True) json_str = \u0026#39;{\u0026#34;aaa\u0026#34;:100, \u0026#34;bbb\u0026#34;:200, \u0026#34;ccc\u0026#34;:300}\u0026#39; json_obj = {\u0026#34;aaa\u0026#34;:100, \u0026#34;bbb\u0026#34;:200, \u0026#34;ccc\u0026#34;:300} print(pretty_json(json_str)) # JSON 文字列も、 print(pretty_json(json_obj)) # オブジェクトもどちらも渡せる ちなみに、Python はコマンドラインで JSON テキストを整形するツール (json.tool) を提供 しているので、ローカルの JSON ファイルをササッと整形したいときにはこちらを使うと便利かもしれません。"},{url:"/p/tr3cmu5/",title:"Python でファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir)",date:"2013-05-08T00:00:00Z",body:"Python でファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir) ファイルあるいはディレクトリが存在するかを調べる Python で、指定した名前のファイル、あるいはディレクトリが存在しているかを調べるには、os.path.exists 関数 を使用します。 シンボリックリンクに対して実行した場合、os.path.exists 関数は、リンク先のファイルの有無を調べます。 sample.txt という名前のファイルかディレクトリが存在するかを調べる import os if os.path.exists(\u0026#39;sample.txt\u0026#39;): print(\u0026#39;Found!\u0026#39;) ファイルの存在、ディレクトリの存在を調べる 前述の os.path.exists は、ファイルあるいはディレクトリの存在を調べますが、ファイルのみ、ディレクトリのみに絞って存在を調べたいときは、os.path.isfile 関数 や os.path.isdir 関数 を使用します。 import os if os.path.isfile(\u0026#39;sample\u0026#39;): print(\u0026#39;sample というファイルが見つかりました\u0026#39;) if os.path.isdir(\u0026#39;sample\u0026#39;): print(\u0026#39;sample というディレクトリが見つかりました\u0026#39;)"},{url:"/p/7pi429n/",title:"HTML 要素を中央寄せ／右寄せで表示する",date:"2013-05-01T00:00:00Z",body:"HTML 要素を中央寄せ／右寄せで表示する 水平方向の中央寄せ 幅 (width) の指定されたブロック要素に対して、margin-left、margin-right をともに auto に設定**すると、中央寄せで表示することができます。 あいうえお CSS div.center { display: block; /* div 要素はもともとブロック要素なので省略可 */ margin-left: auto; margin-right: auto; width: 100px height: 50px; background: blue; color: white; } HTML \u0026lt;div class=\u0026#34;center\u0026#34;\u0026gt;あいうえお\u0026lt;/div\u0026gt; img 要素などのインライン要素は、display: block でブロック要素として扱うことで、同様の方法で中央寄せできます。 HTML \u0026lt;img style=\u0026#34;display: block; margin: auto;\u0026#34; src=\u0026#34;sample.png\u0026#34;\u0026gt; 右寄せ ブロック要素を右寄せで表示するには、margin-left にだけ auto を指定します。 あいうえお .right { display: block; margin-left: auto; /* ...省略... */ } 縦方向の中央寄せ ある要素の display と vertical-align を下記のように設定しておくと、その子要素が縦方向に中央寄せされます。 外側のブロック要素の高さを height プロパティで指定する必要があることに注意してください。 上下の中央寄せ CSS div.center { display: table-cell; /* これと */ vertical-align: middle; /* これで子要素が中央寄せされる */ height: 100px; } div.center_item { text-align: center; background: pink; } HTML \u0026lt;div class=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;center_item\u0026#34;\u0026gt;上下の中央寄せ\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt;"},{url:"/p/cqtwqgx/",title:"Python でリストを昇順ソート／降順ソートする (list.sort/sorted)",date:"2013-04-25T00:00:00Z",body:"Python でリストを昇順ソート／降順ソートする (list.sort/sorted) リストを昇順／降順ソートする (list.sort) 昇順ソート list オブジェクトの sort() メソッドを呼び出すと、要素が昇順ソートされます。 a = [3, 5, 2, 1, 4] a.sort() print(a) #=\u0026gt; [1, 2, 3, 4, 5] sort() メソッドを使用すると、リスト自身の内容が変更されることに注意してください（破壊的メソッドです）。 なお、タプルは不変なので sort() メソッドは使えません（後述の sorted() 関数を使います）。 降順ソート sort() メソッドの reverse=True オプションを指定すると、降順ソートすることができます。 a = [3, 5, 2, 1, 4] a.sort(reverse=True) print(a) #=\u0026gt; [5, 4, 3, 2, 1] ソート結果を新しいリストで取得する (sorted) list.sort メソッドの代わりに sorted 関数を使用すると、元のリストを変更せずに、ソートされた新しいリストを生成することができます。 \u0026gt;\u0026gt;\u0026gt; a = [3, 5, 2, 1, 4] \u0026gt;\u0026gt;\u0026gt; b = sorted(a) \u0026gt;\u0026gt;\u0026gt; a [3, 5, 2, 1, 4] \u0026gt;\u0026gt;\u0026gt; b [1, 2, 3, 4, 5] sorted 関数は、immutable なタプルに対しても適用することができます。 \u0026gt;\u0026gt;\u0026gt; t = (3, 1, 2) \u0026gt;\u0026gt;\u0026gt; sorted(t) [1, 2, 3] 独自クラスのオブジェクトのリストをソートする lt 演算子を定義する方法 独自クラスのオブジェクトのリストを list.sort メソッドや sorted 関数でソートできるようにするには、 __lt__ メソッドを実装します（Less Than (\u0026lt;) の略です）。 次の Person クラスは、ソート時に age プロパティの値で大小比較するように実装しています。 ソート可能な Person クラス class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return(f\u0026#34;{self.name}({self.age})\u0026#34;) def __lt__(self, other): return self.age \u0026lt; other.age if __name__ == \u0026#34;__main__\u0026#34;: p1 = Person(\u0026#34;maku\u0026#34;, 14) p2 = Person(\u0026#34;chiko\u0026#34;, 5) p3 = Person(\u0026#34;ponyo\u0026#34;, 8) persons = [p1, p2, p3] persons.sort() # __lt__ の実装に従ってソート for p in persons: print(p) 実行結果 chiko(5) ponyo(8) maku(14) 応用例として、age プロパティの値が等しい場合にさらに name プロパティの値で比較する、という実装は次のようになります（Python では文字列の大小比較も \u0026lt; で行えます）。 def __lt__(self, other): if self.age == other.age: return self.name \u0026lt; other.name return self.age \u0026lt; other.age ソート実行時に reverse オプションを指定すれば、降順ソートに切り替えられます。 persons.sort(reverse=True) 定義済みの Person クラスに対して、後付けで比較メソッドを追加することもできます。 Person.__lt__ = lambda self, other: self.age \u0026lt; other.age key パラメータを指定する方法 __lt__ メソッドを実装していないクラスのオブジェクトであっても、ソート時に key パラメータを指定すればソートが可能です。 次の例では、Person オブジェクトのリストを、age プロパティの値で昇順ソートするように指定しています。 persons.sort(key=lambda x: x.age) このようにプロパティの値をそのまま比較に使用する場合は、operator モジュールの attergetter を使用すると、より簡潔に記述できるようになります。 from operator import attrgetter persons.sort(key=attrgetter(\u0026#39;age\u0026#39;)) さらに次のようにすれば、age プロパティの値が等しい場合は、name プロパティの値で比較する、という指定が可能です。 persons.sort(key=attrgetter(\u0026#39;age\u0026#39;, \u0026#39;name\u0026#39;)) 参考 dictionary の要素をソートして出力する (sorted)"},{url:"/p/qqkggoz/",title:"Python で dictionary の要素をソートして出力する (sorted)",date:"2013-04-21T00:00:00Z",body:"Python で dictionary の要素をソートして出力する (sorted) キーでソートして出力 Python の dictionary の要素をキー順に取り出すには、dict.keys() メソッドで dictionary からキーの一覧を取り出し、それを sorted() 関数で昇順ソートしてループ処理します。 つまり、キーのリストをソートしているだけです。 キー名で昇順ソート \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;BBB\u0026#39;: 200, \u0026#39;AAA\u0026#39;: 300, \u0026#39;CCC\u0026#39;: 100} \u0026gt;\u0026gt;\u0026gt; for key in sorted(d.keys()): ... print(key, d[key]) AAA 300 BBB 200 CCC 100 キー名で降順ソートしたいときは、sorted() 関数に reverse=True パラメーターを指定します。 キー名で降順ソート \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;BBB\u0026#39;: 200, \u0026#39;AAA\u0026#39;: 300, \u0026#39;CCC\u0026#39;: 100} \u0026gt;\u0026gt;\u0026gt; for key in sorted(d.keys(), reverse=True): ... print(key, d[key]) CCC 100 BBB 200 AAA 300 値でソートして出力 sorted() 関数の key パラメーターをうまく使うと、dictionary の「値」によりソートされたキーを列挙できます。 次の例では、値の昇順 (100, 200, 300) でループ処理しています。 値で昇順ソート \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;BBB\u0026#39;: 200, \u0026#39;AAA\u0026#39;: 300, \u0026#39;CCC\u0026#39;: 100} \u0026gt;\u0026gt;\u0026gt; for key in sorted(d, key=lambda x:d[x]): ... print(key, d[key]) CCC 100 BBB 200 AAA 300 降順ソート (300, 200, 100) したいときは、sorted() 関数に reverse=True パラメーターを指定します。 値で昇順ソート \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;BBB\u0026#39;: 200, \u0026#39;AAA\u0026#39;: 300, \u0026#39;CCC\u0026#39;: 100} \u0026gt;\u0026gt;\u0026gt; for key in sorted(d, reverse=True, key=lambda x:d[x]): ... print(key, d[key]) AAA 300 BBB 200 CCC 100 参考 リストを昇順ソート／降順ソートする (list.sort, sorted) dictionary の内部的な要素順序を変更する (dict, OrderedDictionary) Python 3.7 以降は、dictionary への要素の追加順序が内部的に保持されるようになっています。"},{url:"/p/h3jqpp9/",title:"Python の set オブジェクトで集合演算を行う",date:"2013-04-21T00:00:00Z",body:"Python の set オブジェクトで集合演算を行う Python では、set オブジェクト同士を \u0026amp; や | で演算することによって、簡単に集合演算を行うことができます。 a = {1, 2, 3, 4, 5} b = {3, 4, 5, 6, 7} # 両方に含まれるもの（積集合） s1 = a \u0026amp; b # =\u0026gt; {3, 4, 5} # いずれかに含まれるもの（和集合） s2 = a | b # =\u0026gt; {1, 2, 3, 4, 5, 6, 7} # a にだけ含まれるもの s3 = a - b # =\u0026gt; {1, 2} # b にだけ含まれるもの s4 = b - a # =\u0026gt; {6, 7} # どちらか一方にだけ含まれるもの s5 = a ^ b # =\u0026gt; {1, 2, 6, 7} 参考: 2 つのリストに重複する要素を抽出する（set と \u0026amp;）"},{url:"/p/rr3cmu5/",title:"Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer)",date:"2012-12-09T00:00:00Z",body:"Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) Python がインストールされた環境であれば、コマンドラインから下記のように実行することで簡易 HTTP サーバを立てることができます。 （Python3 の場合）ポート 8000 で HTTP サーバーを起動 $ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... （Python2 の場合）ポート 8000 で HTTP サーバーを起動 $ python -m SimpleHTTPServer 8000 Serving HTTP on 0.0.0.0 port 8000 ... これで、http://localhost:8000/ にアクセスすれば、カレントディレクトリ内のファイルの一覧が表示されます。 開発環境での HTTP 開通テストや、LAN 内の一時的なファイル共有サーバとして使用することができます。"},{url:"/p/ngf6w24/",title:"Vim で正規表現にマッチする行を削除する",date:"2012-12-06T00:00:00Z",body:"Vim で正規表現にマッチする行を削除する 正規表現に一致するテキストが見つかった行をすべて削除する 下記のように実行すると、正規表現に一致するテキストを含む行をまとめて削除することができます。 :g/正規表現/d 例えば、以下のようなファイルリストが書かれたテキストから、バックアップファイル（~ で終わる行）を削除するには、 src/main.h src/main.h~ src/main.cpp src/main.cpp~ 以下のようなコマンドを入力します。 :g/\\~$/d 正規表現に一致するテキストが「見つからない」行をすべて削除する 逆に、指定した正規表現に一致するテキストが 見つからない 行を削除するには、下記のように実行します。 :v/正規表現/d"},{url:"/p/z5ap5bf/",title:"Node.js をインストールする",date:"2012-11-25T00:00:00Z",body:"Node.js をインストールする Node.js とは Node.js は、JavaScript によって記述されたプログラム（スクリプト）を実行するための実行環境です。 JavaScript は、元々は Web ブラウザ内のコンテキストで実行されるスクリプト言語として開発されたものですが、Node.js のランタイム (Windows の場合は node.exe) を使用すると、ネイティブな実行環境で、JavaScript のプログラムを実行することができます。 Python や Ruby のような実行環境が、JavaScript 言語にも提供されたと考えると分かりやすいです。 例えば、Python によるプログラムは以下のように実行しますが、 $ python sample.py 同様に JavaScript で記述したプログラムを、下記のように実行できます。 $ node sample.js Node.js は、内部的には下記のような構成要素で成り立っています。 V8 — Google 製の JavaScript 実行エンジン。 libuv — 非同期イベントライブラリ。Node.js の作者の Ryan Dahl によって作成された。 Node.js では、libuv をベースとする非同期 I/O の仕組みによって、シングルスレッドながらも多くの接続を処理することができるようになっており、サーバサイドのプログラミング言語としても注目を集めています。 Node.js のインストール 各 OS 用の Node.js インストーラが提供されています。 下記のサイトからダウンロードして実行するだけで簡単にインストールできます。 複数バージョンの Node.js 実行環境をインストールしたい場合は、nvm というコマンドラインツールを使って Node.js をインストール してください。 Node.js - https://nodejs.org/ Node.js の実行環境は、デフォルトで下記のようなディレクトリにインストールされます。 Windows の場合: C:\\Program Files\\nodejs\\ Mac OSX の場合: /usr/local/bin/node および /usr/local/bin/npm Node.js 0.6.0 以降は、Node.js 用のパッケージ管理ツールである npm (Node Package Manager) も一緒にインストールされます。 正しくインストールできたかどうかは、下記のようにして確認できます。 $ node -v v16.13.0 $ npm -v 8.1.3"},{url:"/p/pgw5j96/",title:"JavaScript のコーディングスタイル",date:"2012-11-19T00:00:00Z",body:"JavaScript のコーディングスタイル 一般的に採用されている JavaScript のコーディングスタイルのまとめです。 記述フォーマット 一行の最大文字数は 79 文字（改行を入れて 80 文字） インデントはスペース 2 つ（複数行にまたがる時は、スペース 4 つにするか、前の行のドット等に合わせる） ファイルのエンコーディング形式は UTF-8、改行コードは LF (0x0A) ドキュメンテーションコメント ドキュメンテーションコメントは JSDoc で記述します。 /** * Find a person who has a specified nickname. * * @param {String} nickname - The nickname to be searched * @return {Person} A person if found, null if not found */ function findPerson(nickname) { // ... return person; } 命名規則 クラス: ClassName メソッド (public/protected) : methodName メソッド (private) : methodName_ プロパティ (public/protected): propName プロパティ (private): propName_ 変数: varName 定数: CONSTANT_NAME 省略形は先頭文字だけ大文字にします。 Good: Pdf, Id, Xml, Http NG: PDF, ID, XML, HTTP 文字列リテラル 文字列リテラルの定義には、シングルクォーテーションを使います。 これは HTML タグを記述する際に相性がよいからです。 文字列内にシングルクォーテーションが含まれるような場合は、例外的に全体をダブルクォーテーションで囲みます。 クラスの定義方法 （2024 年追記: 現在は class キーワードを使ってクラス定義すればよいです） JavaScript でクラス（正確にはクラス風のオブジェクト）を定義する方法はいろいろありますが、基本は下記のような形式で定義します。 /** @constructor */ function Foo() { this.bar = value; } Foo.prototype.methodName = function() { ... }; プライベートなクラス、メソッド、プロパティは @private を付けて、アンダースコアで終えます。 /** * @private * @constructor */ function PrivateClass_() { /** @private */ this.privateProp_ = 2; } /** @private */ PrivateClass_.privateStaticMethod_ = function() { .. }; /** @private */ PrivateClass_.prototype.privateMethod_ = function() { .. }; その他 無名の関数オブジェクトで済ませられるような場所でも、デバッグしやすくするために、できるだけ関数には名前を付けておくようにします。 参考になるコーディングスタイル Google JavaScript Style Guide 一行原則 80 文字以内。 インデントはスペース 2 文字。 Node.js Style Guide 一行原則 80 文字以内。 インデントはスペース 2 文字。 jQuery のコーディングスタイル カッコ内のスペースの使い方などが、マイナーなのでちょっと嫌。 一行原則 80 文字以内。 インデントはスペース 4 つ（JavaScript の世界では少数派）。"},{url:"/p/bxrtpbp/",title:"JavaScript は Strict モードを有効にすべし (ECMAScript 5)",date:"2012-11-09T00:00:00Z",body:"JavaScript は Strict モードを有効にすべし (ECMAScript 5) Strict Mode を有効にする ECMAScript 5 では、文法チェックを厳しくするための Strict Mode という機能が導入されています。 JavaScript コードの先頭行に、以下のように記述しておくと、Strict Mode が有効になります。 仮に、Strict Mode が使えない環境でこの行が記述されていても、単純に無視されるだけなので、常に記述しておくことをお勧めします。 スクリプト全体を Strict Mode で動かす \u0026#39;use strict\u0026#39;; 関数の中の先頭行で \u0026lsquo;use strict\u0026rsquo; と記述すると、その関数のみが Strict Mode で実行されます。 関数だけを Strict Mode で動かす function hoge() { \u0026#39;use strict\u0026#39;; ... } Strict Mode を有効にすると、例えば、未定義の変数を参照したときに ReferenceError が発生するようになります。 \u0026#39;use strict\u0026#39;; var num1 = 100; print(num1); // OK print(num2); // ReferenceError! Strict Mode のエラーが発生しない分かりにくい例 以下の例では、print(num) の時点で num が定義されていないので、一見 ReferenceError が発生しそうですが、同じスコープの中で num を定義している箇所があればエラーは発生しません。 sample.js \u0026#39;use strict\u0026#39;; print(num); // エラーは発生しない var num = 100; ただし、num を参照した時点では、値がまだ代入されていないので、undefined という値として参照されることになります。 実行結果 $ jrunscript sample.js undefined 参考サイト Strict モード - JavaScript ｜ MDN"},{url:"/p/6m6n5k3/",title:"Linux シェルスクリプト: ユーザー入力を取得する (read)",date:"2012-11-05T00:00:00Z",body:"Linux シェルスクリプト: ユーザー入力を取得する (read) ユーザー入力の基本 bash スクリプトの中で、read 変数名 とすると、ユーザーがキーボードで入力したテキストを変数に取得することができます。 変数名 の部分には、$ プレフィックスを付けないことに注意してください（変数の内容を参照するときは $ が必要です）。 hello.sh #!/bin/sh echo -n \u0026#34;Enter your name: \u0026#34; read name echo \u0026#34;Hello, $name\u0026#34; 実行結果 $ ./hello.sh Enter your name: まくまく Hello, まくまく ☝️ echo の -n オプション echo コマンドの出力はデフォルトで末尾で改行されますが、-n オプションを使うとこの改行を抑制できます。 上記の例のように、プロンプト表示で利用できます。 ユーザーが y を入力したときだけ処理を継続する read コマンドの典型的な使用例として、ユーザーに y/n の選択肢を入力させるものがあります。 次の remove_all 関数は、何もかもを削除する前に、ユーザーに最終確認を行っています。 remove.sh #!/bin/bash function remove_all { echo -n \u0026#39;Are you sure? (y/n): \u0026#39; read input if [ \u0026#34;$input\u0026#34; = \u0026#39;Y\u0026#39; -o \u0026#34;$input\u0026#34; = \u0026#39;y\u0026#39; ]; then echo \u0026#39;All things have been removed!\u0026#39; fi } remove_all if の中で $input の内容を確認するときに、ダブルクォーテーションで囲んでいるのは、ユーザーの入力がなかった場合に空文字 \u0026quot;\u0026quot; を取得するためです。 これがないと、ユーザーが何も入力せずにエンターした場合にエラーになってしまいます。 実行例 $ ./remove.sh Are you sure? (y/n): y All things have been removed! スペースで区切られたユーザー入力を別々の変数に取得する read コマンドの後ろに複数の変数を指定すると、スペースで区切られたユーザー入力を別々の変数に取得することができます。 sample.sh #!/bin/sh read aaa bbb ccc echo \u0026#34;aaa = $aaa\u0026#34; echo \u0026#34;bbb = $bbb\u0026#34; echo \u0026#34;ccc = $ccc\u0026#34; 実行例 $ ./sample.sh 100 200 300 aaa = 100 bbb = 200 ccc = 300 read に指定した変数の数よりも、入力が少ない場合は、変数が空になります。 $ ./sample.sh 100 200 aaa = 100 bbb = 200 ccc = 逆に、入力の方が多い場合は、read コマンドの最後に指定した変数にまとめて格納されます。 $ ./sample.sh 100 200 300 400 500 aaa = 100 bbb = 200 ccc = 300 400 500"},{url:"/p/co9p7nj/",title:"シェルスクリプト: テキストファイルを 1 行ずつ読み込む (read)",date:"2012-11-05T00:00:00Z",body:"シェルスクリプト: テキストファイルを 1 行ずつ読み込む (read) テキストファイルを 1 行だけ読み込む read コマンドは、ユーザからの入力を 1 行取得するために使用できますが、ファイルからの入力を 1 行読み込むのにも使用できます。 sample.sh （input.txt の内容を 1 行だけ読み込む） #!/bin/bash read line \u0026lt; input.txt echo \u0026#34;$line\u0026#34; input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 これだけだとあまり役に立たないので、通常は次のように while ループを組み合わせて、すべての行を読み出します。 テキストファイルから 1 行ずつ読み込む read コマンドと while ループを組み合わせると、テキストファイルのすべての行を 1 行ずつ処理できます。 sample.sh （input.txt の内容を 1 行ずつ読み込む） #!/bin/bash while read line; do echo \u0026#34;$line\u0026#34; done \u0026lt; input.txt input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 BBB 200 CCC 300 ☝️ ワンポイント echo のパラメータ \u0026quot;$line\u0026quot; をダブルクォートで囲んでいることに注意してください。 こうすることで、1 行分の文字列を、ひとつのパラメータとして渡すことができます。 ダブルクォートで囲まないと、echo AAA 100 のように、2 つのパラメータが渡されたかのように処理されてしまうため、連続するスペースが 1 つのスペースに置き換えられて出力されてしまいます。 参考: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ 行頭のスペースが消えてしまうのを防ぐ 例えば、下記のように行頭がインデントされたテキストファイルを読み込むとします。 input.txt（入力データ） ・カテゴリA ・カテゴリA-1 ・カテゴリA-2 ・カテゴリB ・カテゴリB-1 ・カテゴリB-2 このファイルを次のように読み込むと、行頭のスペースが削除されてしまします。 sample.sh #!/bin/bash while read line; do echo \u0026#34;$line\u0026#34; done \u0026lt; input.txt 実行結果 $ ./sample.sh ・カテゴリA ・カテゴリA-1 ・カテゴリA-2 ・カテゴリB ・カテゴリB-1 ・カテゴリB-2 行頭のスペースをそのまま表示したい場合は、次の例のように、組み込み変数 IFS を空文字にセットしてから処理するようにします。 変更した IFS の値は、最後に行儀よく元の値に戻してあげてください（source コマンドなどでスクリプトを読み込んだときに、呼び出し元シェルの IFS の値が変更されたままになってしまうのを防ぐため）。 sample.sh #!/bin/bash old_ifs=$IFS IFS=\u0026#39;\u0026#39; while read line; do echo \u0026#34;$line\u0026#34; done \u0026lt; input.txt IFS=$old_ifs 実行結果 $ ./sample.sh ・カテゴリA ・カテゴリA-1 ・カテゴリA-2 ・カテゴリB ・カテゴリB-1 ・カテゴリB-2 IFS 特殊変数に関しての詳細は、man bash を参照してください。 IFS は内部的な文字列のセパレート処理に使われるキャラクター群を保持しています。"},{url:"/p/wur8gmp/",title:"JavaScript の 6 つの型",date:"2012-10-28T00:00:00Z",body:"JavaScript の 6 つの型 JavaScript is a \u0026ldquo;Loosely Typed Language\u0026rdquo; JavaScript は弱い型付け言語 (A Loosely Typed Language) です。 変数の宣言時に、型を指定する必要はありませんが、内部的には型情報を保持しています。 const s = \u0026#39;Hello World\u0026#39;; // 型指定はしていないが、内部的に文字列型として保持される print(typeof s); // =\u0026gt; string JavaScript の型は 6 種類 JavaScript の型には 5 つの基本型 (primitive value) と、プロパティを持つことができるオブジェクト型があります。 ようするに、全部で 6 つの型があります。 基本型 number（数値） \u0026ndash; 64 bit 浮動小数点数 string（文字列） boolean（真偽値） \u0026ndash; true or false null \u0026ndash; null だけが存在する型 undefined \u0026ndash; 未定義を表す オブジェクト型 5 つの基本型は、ECMAScript の仕様書では、primitive value と呼ばれています。 JavaScript には、C/C++ や Java 言語における char のような 1 文字を格納するための型は存在しないため、長さ 1 の string で代用することになります。 配列に関してはオブジェクト型（Array オブジェクト）に分類されています。 日付を表す Date などもすべてオブジェクト型です。 型情報を調べる (typeof) 変数が参照している値の型を調べるには、typeof を使用します。 リテラルの型を調べることもできます。 print(typeof 100); //=\u0026gt; number print(typeof \u0026#39;xyz\u0026#39;); //=\u0026gt; string print(typeof true); //=\u0026gt; boolean print(typeof null); //=\u0026gt; object print(typeof {}); //=\u0026gt; object print(typeof undefined); //=\u0026gt; undefined null の型が、なぜか object になることに注意が必要です。"},{url:"/p/fueucsa/",title:"Python でユニットテストを記述する (unittest)",date:"2012-07-03T00:00:00Z",body:"Python でユニットテストを記述する (unittest) Python でユニットテストを書くには、unittest モジュール を使用します。 unittest モジュールは、Python 2.1 以降に標準で搭載されています。 テストケースを作成するには、unittest.TestCase を継承したクラスを作成し、test で始まる名前のテストメソッドを記述するだけで OK です。 unittest.main 関数を呼び出すことにより、それらのテストメソッドが自動的に実行されます。 sample.py import unittest class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def decrement(self): self.count -= 1 def get_count(self): return self.count class CounterTest(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def test_increment(self): c = Counter() c.increment() self.assert_(c.get_count() == 1) c.increment() self.assert_(c.get_count() == 2) def test_decrement(self): c = Counter() c.decrement() self.assert_(c.get_count() == -1) c.decrement() self.assert_(c.get_count() == -2) if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() 各テストの実行前と実行後には、setUp() と tearDown() がそれぞれ呼び出されるようになっているので、ここに各テストの共通コードを記述しておくことができます。 上記の例では、共通コードはないので pass とだけ記述しています。 実行結果 $ python3 sample.py .. -------------------------------------- Ran 2 tests in 0.000s OK"},{url:"/p/wnpquuy/",title:"Python で文字列を置換する (str.replace, re.sub, re.subn)",date:"2012-07-03T00:00:00Z",body:"Python で文字列を置換する (str.replace, re.sub, re.subn) Python の文字列オブジェクトの replace メソッドを使うと、その文字列の内容を置換することができます。 正規表現を使った高度な置換を行うには、re モジュールを使用します。 単純な置換 (str.replace) 例: すべての AA を xx に置換する s = \u0026#39;AABBCCAABBCC\u0026#39; s = s.replace(\u0026#39;AA\u0026#39;, \u0026#39;xx\u0026#39;) #=\u0026gt; \u0026#39;xxBBCCxxBBCC\u0026#39; 置換した結果は戻り値として返されるので、元の文字列を変更したい場合は、自分自身に代入する必要があります。 デフォルトではパターンに一致した全ての文字列が置換されます。 例: 最初に見つかった AA を xx に置換 s = \u0026#39;AABBCCAABBCC\u0026#39; s = s.replace(\u0026#39;AA\u0026#39;, \u0026#39;xx\u0026#39;, 1) #=\u0026gt; \u0026#39;xxBBCCAABBCC\u0026#39; 第 3 引数 (count) で、最大いくつまで置換するかを指定 することも可能です。 上記の例では、count=1 と設定することで、最初に一致した部分だけを置換しています。 正規表現を使った置換 (re.sub, re.subn) re モジュールを使うと、正規表現を使った高度な置換を行えるようになります。 正規表現を含む文字列リテラルを記述する場合は、r プレフィックス付けた raw string 記法 (r'...') を使用することで、記号類のエスケープ処理が不要になります。 例: \u0026lsquo;\u0026lt;\u0026rsquo; と \u0026lsquo;\u0026gt;\u0026rsquo; で囲まれた数値を \u0026lsquo;#\u0026rsquo; に置換 import re s = re.sub(r\u0026#39;\u0026lt;\\d+\u0026gt;\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;aaa\u0026lt;100\u0026gt;bbb\u0026lt;200\u0026gt;ccc\u0026#39;) print(s) # =\u0026gt; \u0026#39;aaa#bbb#ccc\u0026#39; str.replace と同様に、第 3 引数 (count) を指定することで、最大いくつまで置換するかを指定できます。 s = re.sub(r\u0026#39;\u0026lt;\\d+\u0026gt;\u0026#39;, \u0026#39;###\u0026#39;, \u0026#39;aaa\u0026lt;100\u0026gt;bbb\u0026lt;200\u0026gt;ccc\u0026#39;, 1) #=\u0026gt; \u0026#39;aaa###bbb\u0026lt;200\u0026gt;ccc\u0026#39; 正規表現を使って置換するときに、マッチした文字列を置換後の文字列に反映させることができます。 正規表現パターンを ( と ) で囲んでグルーピングしておくと、括弧で囲まれた部分に一致した文字列を \\1、\\2、\\3 などで参照できます（後方参照）。 この後方参照を利用するときは、文字列リテラルの前に r を付ける必要があります。 例: * で囲まれたテキストを \u0026lt;b\u0026gt; タグで囲まれたテキストに置換する import re s = re.sub(r\u0026#39;\\*(.+)\\*\u0026#39;, r\u0026#39;\u0026lt;b\u0026gt;\\1\u0026lt;/b\u0026gt;\u0026#39;, \u0026#39;AAA *BBB* CCC\u0026#39;) print(s) # =\u0026gt; \u0026#39;AAA \u0026lt;b\u0026gt;BBB\u0026lt;/b\u0026gt; CCC\u0026#39; 実際にいくつ置換されたかを知る必要がある場合は、re.subn() を使用します。 import re result, num = re.subn(r\u0026#39;(\\d+)\u0026#39;, r\u0026#39;\u0026lt;\\1\u0026gt;\u0026#39;, \u0026#39;aa11bb22cc\u0026#39;) print(result) #=\u0026gt; \u0026#39;aa\u0026lt;11\u0026gt;bb\u0026lt;22\u0026gt;cc\u0026#39; print(num) #=\u0026gt; 2 正規表現パターンをコンパイルして高速化する いろいろなパターンで re.sub 関数による置換を繰り返し実行する場合は、あらかじめ正規表現パターンを re.compile 関数で正規表現オブジェクトにコンパイルしておくと高速に置換処理を行えるようになります（ただし、1 つのパターンのみを連続して使用する場合は、内部でキャッシュが効くため、re.compile 関数を使用する必要はありません）。 下記の例では、HTML ファイル内の日付、時刻と思われる部分を見つけて強調表示する（em タグで囲む）ように置換しています。 import re # 正規表現パターンをコンパイル DATE_PATTERN = re.compile(r\u0026#39;(\\d{4}-\\d{2}-\\d{2})\u0026#39;) TIME_PATTERN = re.compile(r\u0026#39;(\\d\\d:\\d\\d:\\d\\d)\u0026#39;) # 置換処理の実行 with open(\u0026#39;input.html\u0026#39;) as f: for line in f: line = line.rstrip(\u0026#39;\\r\\n\u0026#39;) line = DATE_PATTERN.sub(r\u0026#39;\u0026lt;em\u0026gt;\\1\u0026lt;/em\u0026gt;\u0026#39;, line) line = TIME_PATTERN.sub(r\u0026#39;\u0026lt;em\u0026gt;\\1\u0026lt;/em\u0026gt;\u0026#39;, line) print(line) このように、2 種類の正規表現オブジェクトを繰り返し使用する場合は、re.compile による事前コンパイルが有効です。 文字列中の 1 文字を変更する Python の文字列は Java や C# と同様に immutable（不変）なので、以下のように文字列内の 1 文字だけを置き換えるということはできません。 s = \u0026#39;ABCDE\u0026#39; s[2] = \u0026#39;x\u0026#39; #=\u0026gt; TypeError: \u0026#39;str\u0026#39; object does not support item assignment 文字列中の 1 文字を変更したい場合は、以下のように新しい文字列を作成します。 s = \u0026#39;ABCDE\u0026#39; s = s[:2] + \u0026#39;x\u0026#39; + s[3:] #=\u0026gt; \u0026#39;ABxDE\u0026#39; あるいは、bytearray オブジェクトを変更可能な文字列のように扱うこともできます。 s = bytearray(\u0026#39;ABCDE\u0026#39;.encode()) s[2] = ord(\u0026#39;x\u0026#39;) print(s.decode()) #=\u0026gt; ABxDE 参考 Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re)"},{url:"/p/m2k3jyg/",title:"Python で XML を構築する (minidom)",date:"2012-06-08T00:00:00Z",body:`Python で XML を構築する (minidom) 下記は、Python の minidom モジュールが提供する DOM インタフェースを使用して XML を構築し、XML ファイルとして保存するサンプルです。 sample.py import codecs from xml.dom import minidom def create_xmldoc(): doc = minidom.Document() tree = doc.createElement(\u0026#39;tree\u0026#39;) doc.appendChild(tree) branch = doc.createElement(\u0026#39;branch\u0026#39;) tree.appendChild(branch) leaf = doc.createElement(\u0026#39;leaf\u0026#39;) leaf.setAttribute(\u0026#39;id\u0026#39;, \u0026#39;001\u0026#39;) branch.appendChild(leaf) text = doc.createTextNode(\u0026#39;This is a leaf\u0026#39;) leaf.appendChild(text) return doc def save_xmldoc(xmldoc, filepath): f = codecs.open(filepath, \u0026#39;wb\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) # Text encoding xmldoc.writexml(f, \u0026#39;\u0026#39;, \u0026#39; \u0026#39;*2, \u0026#39;\\n\u0026#39;, encoding=\u0026#39;UTF-8\u0026#39;) # XML header\u0026#39;s encoding f.close() if __name__ == \u0026#39;__main__\u0026#39;: doc = create_xmldoc() save_xmldoc(doc, \u0026#39;output.xml\u0026#39;) codecs.open() で指定する encoding パラメータは、出力するテキストファイル自体のエンコーディング形式を表しており、Document#writexml() で指定する encoding パラメータは、XML のヘッダに書き込まれるエンコーディング形式を表していることに注意してください。 実行結果 (output.xml) \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;tree\u0026gt; \u0026lt;branch\u0026gt; \u0026lt;leaf id=\u0026#34;001\u0026#34;\u0026gt;This is a leaf\u0026lt;/leaf\u0026gt; \u0026lt;/branch\u0026gt; \u0026lt;/tree\u0026gt;`},{url:"/p/ru9mxam/",title:"Python のクラス定義の基本 (class)",date:"2012-06-07T00:00:00Z",body:"Python のクラス定義の基本 (class) class キーワードを使って、Python のクラスを定義することができます。 コンストラクタとインスタンスメソッド メソッドは通常の関数と同様に def キーワードで定義していくのですが、__init__ という名前のメソッドを定義すると、インスタンス生成時（クラス名()）に呼び出されるコンストラクタとして扱われます。 コンストラクタの中では、自分自身のインスタンスを参照するための self を使って、属性の初期化などを行います。 Person クラスを定義してみる class Person: \u0026#34;\u0026#34;\u0026#34;クラスの説明をここに書く\u0026#34;\u0026#34;\u0026#34; def __init__(self, name: str): \u0026#34;\u0026#34;\u0026#34;コンストラクタの説明をここに書く\u0026#34;\u0026#34;\u0026#34; self.name = name def hello(self): \u0026#34;\u0026#34;\u0026#34;メソッドの説明をここに書く\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Hello, {self.name}!\u0026#34;) コンストラクタやメソッドの第 1 引数には、必ず自分自身のインスタンスを参照するための self 引数を配置します。 実際には、名前は何でもよいのですが、公式のスタイルガイドで self という名前を使うことが推奨されています（参考: PEP 8）。 上記のように定義したクラスは、次のように使用することができます。 person = Person(\u0026#34;maku\u0026#34;) # インスタンスを生成する person.hello() # メソッドを呼び出す 実行例 $ python main.py Hello, maku! クラス属性 (class attribute) クラス属性 は、インスタンスを生成せずにアクセスできる属性です。 次のクラスは、num というクラス属性を持っています。 クラス属性には、クラス名.クラス属性名 という形でアクセスできます。 クラス属性を定義する # クラス属性を持つクラス class Holder: num: int = 0 # クラス属性を参照する print(Holder.num) # =\u0026gt; 0 Holder.num = 100 print(Holder.num) # =\u0026gt; 100 クラス定数も同様に定義できます。 名前を大文字にするだけです。 クラス定数を定義する # クラス定数を持つクラス class Author: NAME: str = \u0026#34;Maku\u0026#34; AGE: int = 14 # クラス定数を参照する print(Author.NAME) # =\u0026gt; Maku print(Author.AGE) # =\u0026gt; 14 クラスメソッド (class method) クラスメソッド は、インスタンスを生成せずに呼び出せるメソッドで、@classmethod デコレーターを使って定義します。 クラスメソッドの第 1 引数には、自身のクラスメソッドを示す cls を配置します（この名前も、PEP 8 で推奨されています）。 クラスメソッドの中からは、cls.クラス属性名 という形で、クラス属性にアクセスできます。 クラスメソッドを定義する class Holder: num = 0 @classmethod def print(cls): print(cls.num) if __name__ == \u0026#34;__main__\u0026#34;: Holder.num = 1 Holder.print() # =\u0026gt; 1 クラスメソッドは、ファクトリーメソッドの実装に使われることがあります。 次の mysterios_person メソッドは、特殊な Person インスタンスを生成するためのファクトリーメソッドです。 class Person: def __init__(self, name: str, age: int): self.name = name self.age = age @classmethod def mysterious_person(cls) -\u0026gt; \u0026#34;Person\u0026#34;: return cls(name=\u0026#34;John Doe\u0026#34;, age=20) # 使用例: ファクトリーメソッドでインスタンス生成 person = Person.mysterious_person() 静的メソッド (static method) 静的メソッド は、インスタンスを生成せずに呼び出せるメソッドで、@staticmethod デコレーターを使って定義します。 静的メソッドはクラスメソッドと異なり、第 1 引数で cls を受け取りません。 単なる関数とほぼ同等ですが、クラス内で静的メソッドとして定義することにより、そのクラスに関連するユーティリティ関数であることが明確になります。 また、クラスをインポートするだけで静的メソッドにアクセスできるようになるなどの利点もあります。 class Formatter: # ... @staticmethod def make_indent(level: int) -\u0026gt; str: return \u0026#34; \u0026#34; * 4 * level メソッドや属性を private にする クラス内のメソッドや属性を private 扱いにするには、メソッド名の前にアンダースコア _ を 1 つ付けます。 ただし、これは単なる慣習で、実際には外からアクセスできてしまいます。 class Person: def __init__(self, name: str, age: int): self._name = name self._age = age if __name__ == \u0026#34;__main__\u0026#34;: p = Person(\u0026#34;Maku\u0026#34;, 14) print(p._name) # 見えちゃう print(p._age) # 見えちゃう 外からアクセスできないようにするには、メソッド名の前にアンダースコアを 2 つ付けます。 class Person: def __init__(self, name: str, age: int): self.__name = name self.__age = age if __name__ == \u0026#34;__main__\u0026#34;: p = Person(\u0026#34;Maku\u0026#34;, 14) print(p.__name) # エラー！ print(p.__age) # エラー！ ☝️ Name Mangling アンダースコアを 2 つ付けたときに外から属性にアクセスできなくなるのは、Python の Name Mangling（名前修飾） という仕組みが働いているからです。 属性名がアンダースコア 2 つで始まっていると、Python は内部的にその属性名を _クラス名__属性名 という名前に置き換えます。 この仕組みにより、外部からの不用意なアクセスを避けるとともに、サブクラスで定義された属性の名前との衝突を防ぐ効果があります。"},{url:"/p/guducs9/",title:"Python で XML をパースする (minidom)",date:"2012-06-04T00:00:00Z",body:"Python で XML をパースする (minidom) Python 2.0 以降では、Document Object Model インタフェース (DOM API) の最小の実装として、xml.dom.minidom が搭載されています。 DOM 標準の API を使って操作する必要のない場合は、よりシンプルなインターフェースを提供している ElementTree モジュールを使用する のがよいでしょう。 Document オブジェクトを取得する minidom を使用して、XML の各要素にアクセスするためには、まずは DOM 全体を表現する xml.dom.minidom.Document オブジェクトを取得する必要があります。 データソースとしては、XML ファイル、XML 文字列、Web 上のリソースなどを利用できます。 XML ファイルを扱う場合 from xml.dom import minidom doc = minidom.parse(\u0026#34;input.xml\u0026#34;) print(doc.toxml()) XML 文字列を扱う場合 from xml.dom import minidom xml = \u0026#34;\u0026#34;\u0026#34; \u0026lt;tree\u0026gt; \u0026lt;branch\u0026gt; \u0026lt;leaf id=\u0026#39;1\u0026#39;\u0026gt;Leaf 1\u0026lt;/leaf\u0026gt; \u0026lt;leaf id=\u0026#39;2\u0026#39;\u0026gt;Leaf 2\u0026lt;/leaf\u0026gt; \u0026lt;leaf id=\u0026#39;3\u0026#39;\u0026gt;Leaf 3\u0026lt;/leaf\u0026gt; \u0026lt;/branch\u0026gt; \u0026lt;/tree\u0026gt;\u0026#34;\u0026#34;\u0026#34; doc = minidom.parseString(xml) print(doc.toxml()) Web 上の XML リソースを扱う場合 urllib モジュールを組み合わせて使えば、Web 上の XML も簡単にパースできます。 from urllib.request import urlopen from xml.dom import minidom with urlopen(\u0026#34;https://example.com/test.xml\u0026#34;) as res: doc = minidom.parse(res) print(doc.toxml()) DOM リソースの解放 使用し終わった Document オブジェクトは、ガーベジ・コレクションによって自動的に解放されますが、unlink メソッドで明示的に解放することもできます。 dom.unlink() Document オブジェクトを生成するときに with 構文を使用すれば、unlink 処理を自動化することができます。 with minidom.parse(\u0026#34;input.xml\u0026#34;) as doc: print(doc.toxml()) タグ名を指定して要素を取得する (getElementsByTagName) Document#getElementsByTagName メソッドを使うと、指定したタグ名の要素のリスト（NodeList オブジェクト）を取得することができます。 子ノードを再帰的に検索するので、同じタグ名を持つ要素はすべてリストに含まれます。 ノードが見つからない場合は、None が返されます。 books = doc.getElementsByTagName(\u0026#34;book\u0026#34;) 上記の例では、Document オブジェクトの getElementsByTagName メソッドを呼び出しているので、全てのノードが検索対象になりますが、特定のノード (Element) の getElementsByTagName メソッドを呼び出すと、そのノード以下のノードのみが検索対象となります。 authors = books[0].getElementsByTagName(\u0026#34;author\u0026#34;) sample.py（サンプルコード） from xml.dom import minidom xml = \u0026#39;\u0026#39;\u0026#39; \u0026lt;tree\u0026gt; \u0026lt;branch\u0026gt; \u0026lt;leaf id=\u0026#39;1\u0026#39;\u0026gt;Leaf 1\u0026lt;/leaf\u0026gt; \u0026lt;leaf id=\u0026#39;2\u0026#39;\u0026gt;Leaf 2\u0026lt;/leaf\u0026gt; \u0026lt;leaf id=\u0026#39;3\u0026#39;\u0026gt;Leaf 3\u0026lt;/leaf\u0026gt; \u0026lt;/branch\u0026gt; \u0026lt;/tree\u0026gt;\u0026#39;\u0026#39;\u0026#39; doc = minidom.parseString(xml) elems = doc.getElementsByTagName(\u0026#34;leaf\u0026#34;) for e in elems: print e.attributes[\u0026#34;id\u0026#34;].value print e.firstChild.data 実行結果 $ python3 sample.py 1 Leaf 1 2 Leaf 2 3 Leaf 3 テキストノードの値を取得する diary.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;diary\u0026gt; \u0026lt;entry\u0026gt;ほげほげ\u0026lt;empty/\u0026gt;ぽにょぽにょ\u0026lt;/entry\u0026gt; \u0026lt;/diary\u0026gt; sample.py from xml.dom import minidom def getText(nodeList): text = \u0026#34;\u0026#34; for node in nodeList: if node.nodeType == node.TEXT_NODE: text += node.data return text doc = minidom.parse(\u0026#34;sample.xml\u0026#34;) nodeList = doc.getElementsByTagName(\u0026#34;entry\u0026#34;) print(getText(nodeList[0].childNodes)) 実行結果 ほげほげぽにょぽにょ 属性値を取得する sample.py from xml.dom import minidom doc = minidom.parseString(\u0026#39;\u0026lt;books\u0026gt;\u0026lt;book id=\u0026#34;001\u0026#34;/\u0026gt;\u0026lt;/books\u0026gt;\u0026#39;) elem = doc.getElementsByTagName(\u0026#34;book\u0026#34;)[0] print(elem.getAttributeNode(\u0026#34;id\u0026#34;).nodeValue) 実行結果 001 ノードの子ノードを全て取得する childNodes = node.childNodes ノード名（要素名）を取得する sample.py from xml.dom import minidom doc = minidom.parseString(\u0026#39;\u0026lt;books\u0026gt;\u0026lt;book\u0026gt;\u0026lt;author\u0026gt;AAA\u0026lt;/author\u0026gt;\u0026lt;/book\u0026gt;\u0026lt;/books\u0026gt;\u0026#39;) elem = doc.getElementsByTagName(\u0026#39;book\u0026#39;)[0] print(elem.nodeName) # =\u0026gt; \u0026#34;book\u0026#34; 指定した要素をループで処理する 次の例では、book というタグ名の要素をすべて取得してループ処理しています。 books.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;books\u0026gt; \u0026lt;book id=\u0026#34;100\u0026#34;\u0026gt;Book name1\u0026lt;/book\u0026gt; \u0026lt;book id=\u0026#34;200\u0026#34;\u0026gt;Book name2\u0026lt;/book\u0026gt; \u0026lt;book id=\u0026#34;300\u0026#34;\u0026gt;Book name3\u0026lt;/book\u0026gt; \u0026lt;/books\u0026gt; sample.py from xml.dom.minidom import parse # Parse a xml file. doc = parse(\u0026#34;books.xml\u0026#34;) # Get all book nodes nodeList = doc.getElementsByTagName(\u0026#34;book\u0026#34;) # Show text data. for node in nodeList: print \u0026#34;Book ID =\u0026#34;, node.getAttributeNode(\u0026#34;id\u0026#34;).nodeValue print \u0026#34;Book Name =\u0026#34;, node.childNodes[0].data 実行結果 Book ID = 100 Book Name = Book name1 Book ID = 200 Book Name = Book name2 Book ID = 300 Book Name = Book name3 子ノードをループで処理する 次の例では、books 以下の複数の子ノード (book) をループ処理しています。 books.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;books\u0026gt; \u0026lt;book\u0026gt; \u0026lt;name\u0026gt;Book name1\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;Author 1\u0026lt;/author\u0026gt; \u0026lt;author\u0026gt;Author 2\u0026lt;/author\u0026gt; \u0026lt;author\u0026gt;Author 3\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;book\u0026gt; \u0026lt;name\u0026gt;Book name2\u0026lt;/name\u0026gt; \u0026lt;author\u0026gt;Author 1\u0026lt;/author\u0026gt; \u0026lt;author\u0026gt;Author 2\u0026lt;/author\u0026gt; \u0026lt;/book\u0026gt; \u0026lt;/books\u0026gt; sample.py from xml.dom.minidom import parse # Parse a xml file. doc = parse(\u0026#34;books.xml\u0026#34;) # Get all book nodes nodeList = doc.getElementsByTagName(\u0026#34;book\u0026#34;) # Process book nodes for node in nodeList: # Process book\u0026#39;s child nodes for child in node.childNodes: if child.nodeName == \u0026#34;name\u0026#34;: print \u0026#34;Book name:\u0026#34;, child.childNodes[0].data elif child.nodeName == \u0026#34;author\u0026#34;: print \u0026#34;Author:\u0026#34;, child.childNodes[0].data 実行結果 Book name: Book name1 Author: Author 1 Author: Author 2 Author: Author 3 Book name: Book name2 Author: Author 1 ノードがテキストノードが調べる if node.nodeType == node.TEXT_NODE: print \u0026#34;This is a text node\u0026#34; ノードに属性を追加する／属性の値を変更する Element オブジェクトの setAttribute(self, attname, value) メソッドを使用して、任意のノードの属性を設定することができます。 id 属性の値を変更する from xml.dom import minidom doc = minidom.parseString(\u0026#39;\u0026lt;books\u0026gt;\u0026lt;book id=\u0026#34;old\u0026#34;/\u0026gt;\u0026lt;/books\u0026gt;\u0026#39;) nodeList = doc.getElementsByTagName(\u0026#39;book\u0026#39;) nodeList[0].setAttribute(\u0026#39;id\u0026#39;, \u0026#39;002\u0026#39;) print(doc.toxml()) 実行結果 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt;\u0026lt;books\u0026gt;\u0026lt;book id=\u0026#34;new\u0026#34;/\u0026gt;\u0026lt;/books\u0026gt; テキストノードの値を変更する Element オブジェクトの nodeValue 属性の値を設定することで、テキストノードの値を変更することができます。 テキストノードの値を変更する from xml.dom import minidom doc = minidom.parseString(\u0026#39;\u0026lt;book\u0026gt;Old text\u0026lt;/book\u0026gt;\u0026#39;) nodeList = doc.getElementsByTagName(\u0026#39;book\u0026#39;) bookNode = nodeList[0] bookNode.childNodes[0].nodeValue = \u0026#39;New text\u0026#39; print(doc.toxml()) 実行結果 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; ?\u0026gt;\u0026lt;book\u0026gt;New text\u0026lt;/book\u0026gt;"},{url:"/p/x9xhyhz/",title:"adb から Backup Manager を走らせる (bmgr backup, bmgr restore)",date:"2012-01-26T00:00:00Z",body:"adb から Backup Manager を走らせる (bmgr backup, bmgr restore) Android アプリケーションで BackupAgent を実装しておくと、設定値などを Google アカウントに紐づけてバックアップすることができます。 例えば、Android システム設定のバックアップは SettingsProvider (com.android.providers.settings) の SettingsBackupAgent クラスで実装されています。 アプリケーションの実装で、BackupManager.dataChanged() を読んでおくと、ダーティフラグがセットされて、Android が適切なタイミングで Google のサーバーにバックアップするのですが、adb shell から bmgr コマンドを使うことで、バックアップ、リストアを任意のタイミングで実行できます。 設定を Google サーバへバックアップ adb\u0026gt; bmgr backup com.android.providers.settings adb\u0026gt; bmgr run 設定を Google サーバからリストア adb\u0026gt; bmgr restore com.android.providers.settings 参考: BackupAgent | Android Developers 参考: Android Backup Service を使用して Key-Value ペアをバックアップする"},{url:"/p/dpp4v8n/",title:"JavaScript で文字列をデリミタで分割する／1文字ずつに分割する (String#split)",date:"2012-01-20T00:00:00Z",body:"JavaScript で文字列をデリミタで分割する／1文字ずつに分割する (String#split) JavaScript の文字列を任意の区切り文字で分割するには、split() メソッドを使用します。 カンマで文字列を分割する const s = \u0026#39; aaa, bbb, ccc \u0026#39;; const arr = s.split(\u0026#39;,\u0026#39;); // =\u0026gt; [\u0026#34; aaa\u0026#34;, \u0026#34; bbb\u0026#34;, \u0026#34; ccc \u0026#34;] 区切り文字列の前後の空白を削除したい場合は、以下のように正規表現で区切り文字を指定するとよいでしょう。 const s = \u0026#39; aaa, bbb, ccc \u0026#39;; const arr = s.split(/\\s*,\\s*/); // =\u0026gt; [\u0026#34; aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc \u0026#34;] 元のテキストの先頭や末尾にある空白が残ってしまっていることに注意してください。 これらを削除するには、以下のように最初に trim() で消してしまうのが早いです。 const s = \u0026#39; aaa, bbb, ccc \u0026#39;; const arr = s.trim().split(/\\s*,\\s*/); // =\u0026gt; [\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;] あるいは、以下のように分割した後の各文字列に対して trim() を実行するという方法もありますが、元の文字列に 1 回だけ trim() をかけた方が効率がよいでしょう。 const arr = s.split(\u0026#39;,\u0026#39;).map(function(val, i){ return val.trim() }); 文字列を一文字ずつに分割する split メソッドのパラメータに空文字列 ('') を指定すると、文字列を一文字ずつに分割することができます。 const s = \u0026#39;ABCDE\u0026#39;; const arr = s.split(\u0026#39;\u0026#39;); // =\u0026gt; [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;] for (let i = 0; i \u0026lt; arr.length; ++i) { console.log(arr[i]); }"},{url:"/p/8pnuzk4/",title:"JavaScript で文字列を置換する (String#replace, String#replaceAll)",date:"2012-01-20T00:00:00Z",body:"JavaScript で文字列を置換する (String#replace, String#replaceAll) replace と replaceAll の基本 String#replace() メソッドを使用すると、String オブジェクト内のパターンに一致する文字列を置換することができます。 ABC を XXX に置換 const text = \u0026#39;ABC 123 ABC 123\u0026#39;; const s = text.replace(\u0026#39;ABC\u0026#39;, \u0026#39;XXX\u0026#39;); //=\u0026gt; \u0026#39;XXX 123 ABC 123\u0026#39; replace() メソッドは、自分自身のオブジェクトの内容を変更しないため、置換結果は戻り値として受け取る必要があることに注意してください。 また、デフォルトでは上記のように、最初に見つかった文字列だけ が置換されます。 パターンが複数箇所に一致した場合に、すべて置換するには、次のように String#replaceAll() メソッドを使用します（後述の正規表現パターンを使用する方法もあります）。 すべての ABC を XXX に置換 const text = \u0026#39;ABC 123 ABC 123\u0026#39;; const s = text.replaceAll(\u0026#39;ABC\u0026#39;, \u0026#39;XXX\u0026#39;); //=\u0026gt; \u0026#39;XXX 123 ABC 123\u0026#39; 正規表現パターンに一致する文字列を全て置換する String#replace() メソッドの第 1 引数には、正規表現パターンを渡すこともできます。 正規表現属性の g（グローバル検索）を付ければ、パターンに一致した部分すべてを一括置換することができます（replaceAll() ではなく、replace() ですべて置換できます）。 例: すべての ABC を XXX に置換 const text = \u0026#39;ABC 123 ABC 123\u0026#39;; const s = text.replace(/ABC/g, \u0026#39;XXX\u0026#39;); //=\u0026gt; \u0026#39;XXX 123 XXX 123\u0026#39; 正規表現属性の i を付けると、大文字と小文字を区別せずに一致させることができます。 正規表現属性は複数組み合わせて使用することができます。 例: 大文字と小文字が混在するものを「JavaScript」という表現に統一 const text = `javascript is a versatile language, and understanding JaVaScRiPt is essential for modern web development.`; const s = text.replace(/javascript/gi, \u0026#39;JavaScript\u0026#39;); 正規表現パターンに一致した部分を置換後の文字列で使用する 正規表現を使用した置換が強力なのは、パターンに一致した実際の文字列を、置換後の文字列の中で参照することができることです。 正規表現パターンにマッチした部分全体は、$\u0026amp; で参照することができます（$0 ではないことに注意）。 例: 数値を [ と ] で囲む const re = /\\d+/g; const text = \u0026#39;ABC 123 DEF 456\u0026#39;; const s = text.replace(re, \u0026#39;[$\u0026amp;]\u0026#39;); //=\u0026gt; \u0026#39;ABC [123] DEF [456]\u0026#39; 正規表現の中のパターンを ( と ) でグルーピングしておくと、その中で実際に一致した部分を $1、$2、$3 というキーワードを使って参照することができます（Perl と同様の記法です）。 例: 姓と名を入れ替える const re = /(\\w+)\\s(\\w+)/; const text = \u0026#39;John Smith\u0026#39;; const s = text.replace(re, \u0026#39;$2, $1\u0026#39;); //=\u0026gt; \u0026#39;Smith, John\u0026#39;"},{url:"/p/jjk3jqs/",title:"HTML ファイルの雛形（テンプレート）",date:"2012-01-15T00:00:00Z",body:"HTML ファイルの雛形（テンプレート） ひな形（テンプレート） 最小限のテンプレート \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt; \u0026lt;p\u0026gt;Hello HTML5!\u0026lt;/p\u0026gt; HTML5 では、html、head、body タグの記述を省略できるので、上記のような簡潔な記述でも正しい HTML 文書となります。 CSS や JavaScript コードを追記したバージョン \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: khaki; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;Hello HTML5!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; document.write(\u0026#39;Goodbye!\u0026#39;); \u0026lt;/script\u0026gt; style タグも、script タグも、基本は属性なしで記述できます。 あまり省略しないバージョン \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Page Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { background-color: khaki; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Hello HTML5!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; document.write(\u0026#39;Goodbye!\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTML5 の各要素の省略について HTML5 では、簡潔な記述が行えるように、様々な省略記法が用意されています。 DOCTYPE HTML5 では、DOCTYPE は以下のように簡単に記述できるようになりました。 \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; ↓ \u0026lt;!DOCTYPE html\u0026gt; 本当は DOCTYPE 自体を削除することも検討されたのですが、Internet Explorer がうまくモード認識できないことがあるということで、最低限の宣言だけ残されています。 DTD は誰も使わないのでなくなりました。 html、head、body 要素の省略 html、head、body タグの記述は省略できます。 記述の省略はできますが、もちろん内部的には DOM ツリー上にこれらの要素は存在しています。 Charset Charset の定義は、以下のように簡単になりました。 \u0026lt;meta http-equiv=\u0026#34;content-type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34; /\u0026gt; ↓ \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; style 要素 style 要素の type 属性は省略できるようになりました。 また、media タイプは省略すると all として処理されます。 \u0026lt;style type=\u0026#34;text/css\u0026#34; media=\u0026#34;all\u0026#34;\u0026gt; ... \u0026lt;/style\u0026gt; ↓ \u0026lt;style\u0026gt; ... \u0026lt;/style\u0026gt; script 要素 JavaScript のコードを記述するとき、script 要素に type=\u0026quot;text/javascript\u0026quot; という属性が必要でしたが、省略するとデフォルトで text/javascript と判断されるようになりました。 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; ... \u0026lt;/script\u0026gt; ↓ \u0026lt;script\u0026gt; ... \u0026lt;/script\u0026gt; W3C の資料に下記のように記載があります。 The default, which is used if the attribute is absent, is \u0026ldquo;text/javascript\u0026rdquo;."},{url:"/p/qbmdoef/",title:"Vim の文字の削除方法まとめ (d, delete)",date:"2011-12-21T00:00:00Z",body:"Vim の文字の削除方法まとめ (d, delete) ノーマルモード時 入力 説明 dd 現在行を削除 D 行末までを削除（C なら行末まで削除して入力モードに） diw カーソル位置の単語を削除（単語の後ろのスペースも削除） daw カーソル位置の単語を削除（単語の後ろのスペースは残す） ciw カーソル位置の単語を削除して入力モードへ（単語の後ろのスペースも削除） caw カーソル位置の単語を削除して入力モードへ（単語の後ろのスペースは残す） 入力モード時 入力 説明 C-w カーソル位置から直前の単語までを削除 C-u カーソル位置から行頭までを削除 応用例: パターンに一致する「行全体」を削除する あるパターンに一致する文字列を含む 行全体 を削除したい場合は、行範囲と組み合わせて d (delete) コマンドを使用します。 置換コマンドの s コマンドと同様に、最初に行範囲の指定を行います。 :行範囲 d 行範囲を指定しない場合は、カレント行のみが対象になります。 つまり、:d というコマンドは、dd と同様にカレント行のみを削除します。 入力 説明 :d カレント行を削除 :% d すべての行を削除 :1,10 d 1〜10 行目を削除 :g/temp/ d temp を含む行を削除 :g/^#/ d # で始まる行を削除 :g/^$/ d 空行をすべて削除"},{url:"/p/qqrxpjd/",title:"APK ファイルの情報を表示する (aapt)",date:"2011-09-11T00:00:00Z",body:"APK ファイルの情報を表示する (aapt) Android SDK に付属している aapt (Android Asset Packaging Tool) を使用すると、APK の情報を調べることができます。 主にリソースなどの Asset を対象としたツールですが、バージョン情報や、パーミッション情報なども調べることができます。 aapt コマンドは、昔は build-tools ディレクトリ直下にありましたが、現在は build-tools\\23.0.2 のようなバージョン名のディレクトリ以下にインストールされるようです。 具体的には下記のようなオプションを指定して APK の情報を確認できます（dump パラメータは d と省略できます）。 aapt d badging myapp.apk パッケージ名、アプリ名、バージョン、パーミッション情報、サポートする Locale の一覧などを確認 aapt d permissions myapp.apk 使用しているパーミッション (uses-permission) と、定義しているパーミッション (permission) の一覧 aapt d strings myapp.apk 文字列リソースの一覧 aapt d resources myapp.apk リソースの一覧（大量に出力されるので注意） aapt d xmltree myapp.apk res/animator/fadein.xml 指定した XML リソースのツリー情報 aapt list myapp.apk リソースファイル名の一覧 aapt コマンドのヘルプ パラメータなしで、aapt コマンドを実行すると、下記のようにヘルプが表示されます。 $ aapt Android Asset Packaging Tool Usage: aapt l[ist] [-v] [-a] file.{zip,jar,apk} List contents of Zip-compatible archive. aapt d[ump] [--values] [--include-meta-data] WHAT file.{apk} [asset [asset ...]] strings Print the contents of the resource table string pool in the APK. badging Print the label and icon for the app declared in APK. permissions Print the permissions from the APK. resources Print the resource table from the APK. configurations Print the configurations in the APK. xmltree Print the compiled xmls in the given assets. xmlstrings Print the strings of the given compiled xml assets. aapt p[ackage] [-d][-f][-m][-u][-v][-x][-z][-M AndroidManifest.xml] \\ [-0 extension [-0 extension ...]] [-g tolerance] [-j jarfile] \\ [--debug-mode] [--min-sdk-version VAL] [--target-sdk-version VAL] \\ [--app-version VAL] [--app-version-name TEXT] [--custom-package VAL] \\ [--rename-manifest-package PACKAGE] \\ [--rename-instrumentation-target-package PACKAGE] \\ [--utf16] [--auto-add-overlay] \\ [--max-res-version VAL] \\ [-I base-package [-I base-package ...]] \\ [-A asset-source-dir] [-G class-list-file] [-P public-definitions-file] \\ [-S resource-sources [-S resource-sources ...]] \\ [-F apk-file] [-J R-file-dir] \\ [--product product1,product2,...] \\ [-c CONFIGS] [--preferred-density DENSITY] \\ [--split CONFIGS [--split CONFIGS]] \\ [--feature-of package [--feature-after package]] \\ [raw-files-dir [raw-files-dir] ...] \\ [--output-text-symbols DIR] Package the android resources. It will read assets and resources that are supplied with the -M -A -S or raw-files-dir arguments. The -J -P -F and -R options control which files are output. aapt r[emove] [-v] file.{zip,jar,apk} file1 [file2 ...] Delete specified files from Zip-compatible archive. aapt a[dd] [-v] file.{zip,jar,apk} file1 [file2 ...] Add specified files to Zip-compatible archive. aapt c[runch] [-v] -S resource-sources ... -C output-folder ... Do PNG preprocessing on one or several resource folders and store the results in the output folder. aapt s[ingleCrunch] [-v] -i input-file -o outputfile Do PNG preprocessing on a single file. aapt v[ersion] Print program version. Modifiers: -a print Android-specific data (resources, manifest) when listing -c specify which configurations to include. The default is all configurations. The value of the parameter should be a comma separated list of configuration values. Locales should be specified as either a language or language-region pair. Some examples: en port,en port,land,en_US -d one or more device assets to include, separated by commas -f force overwrite of existing files -g specify a pixel tolerance to force images to grayscale, default 0 -j specify a jar or zip file containing classes to include -k junk path of file(s) added -m make package directories under location specified by -J -u update existing packages (add new, replace older, remove deleted files) -v verbose output -x create extending (non-application) resource IDs -z require localization of resource attributes marked with localization=\u0026#34;suggested\u0026#34; -A additional directory in which to find raw asset files -G A file to output proguard options into. -F specify the apk file to output -I add an existing package to base include set -J specify where to output R.java resource constant definitions -M specify full path to AndroidManifest.xml to include in zip -P specify where to output public resource definitions -S directory in which to find resources. Multiple directories will be scanned and the first match found (left to right) will take precedence. -0 specifies an additional extension for which such files will not be stored compressed in the .apk. An empty string means to not compress any files at all. --debug-mode inserts android:debuggable=\u0026#34;true\u0026#34; in to the application node of the manifest, making the application debuggable even on production devices. --include-meta-data when used with \u0026#34;dump badging\u0026#34; also includes meta-data tags. --pseudo-localize generate resources for pseudo-locales (en-XA and ar-XB). --min-sdk-version inserts android:minSdkVersion in to manifest. If the version is 7 or higher, the default encoding for resources will be in UTF-8. --target-sdk-version inserts android:targetSdkVersion in to manifest. --max-res-version ignores versioned resource directories above the given value. --values when used with \u0026#34;dump resources\u0026#34; also includes resource values. --version-code inserts android:versionCode in to manifest. --version-name inserts android:versionName in to manifest. --replace-version If --version-code and/or --version-name are specified, these values will replace any value already in the manifest. By default, nothing is changed if the manifest already defines these attributes. --custom-package generates R.java into a different package. --extra-packages generate R.java for libraries. Separate libraries with \u0026#39;:\u0026#39;. --generate-dependencies generate dependency files in the same directories for R.java and resource package --auto-add-overlay Automatically add resources that are only in overlays. --preferred-density Specifies a preference for a particular density. Resources that do not match this density and have variants that are a closer match are removed. --split Builds a separate split APK for the configurations listed. This can be loaded alongside the base APK at runtime. --feature-of Builds a split APK that is a feature of the apk specified here. Resources in the base APK can be referenced from the the feature APK. --feature-after An app can have multiple Feature Split APKs which must be totally ordered. If --feature-of is specified, this flag specifies which Feature Split APK comes before this one. The first Feature Split APK should not define anything here. --rename-manifest-package Rewrite the manifest so that its package name is the package name given here. Relative class names (for example .Foo) will be changed to absolute names with the old package so that the code does not need to change. --rename-instrumentation-target-package Rewrite the manifest so that all of its instrumentation components target the given package. Useful when used in conjunction with --rename-manifest-package to fix tests against a package that has been renamed. --product Specifies which variant to choose for strings that have product variants --utf16 changes default encoding for resources to UTF-16. Only useful when API level is set to 7 or higher where the default encoding is UTF-8. --non-constant-id Make the resources ID non constant. This is required to make an R java class that does not contain the final value but is used to make reusable compiled libraries that need to access resources. --shared-lib Make a shared library resource package that can be loaded by an application at runtime to access the libraries resources. Implies --non-constant-id. --error-on-failed-insert Forces aapt to return an error if it fails to insert values into the manifest with --debug-mode, --min-sdk-version, --target-sdk-version --version-code and --version-name. Insertion typically fails if the manifest already defines the attribute. --error-on-missing-config-entry Forces aapt to return an error if it fails to find an entry for a configuration. --output-text-symbols Generates a text file containing the resource symbols of the R class in the specified folder. --ignore-assets Assets to be ignored. Default pattern is: !.svn:!.git:!.ds_store:!*.scc:.*:\u0026lt;dir\u0026gt;_*:!CVS:!thumbs.db:!picasa.ini:!*~ --skip-symbols-without-default-localization Prevents symbols from being generated for strings that do not have a default localization --no-version-vectors Do not automatically generate versioned copies of vector XML resources. 上記の表示は、下記の aapt のバージョンのものです。 $ aapt v Android Asset Packaging Tool, v0.2-2355899"},{url:"/p/mbnw7gq/",title:"Activity の情報を表示する (dumpsys activity)",date:"2011-06-08T00:00:00Z",body:"Activity の情報を表示する (dumpsys activity) Android 端末に adb shell で接続後、dumpsys コマンドを実行すると Activity core サービスの情報を表示できます。 例えば、出力の Activity スタックを確認することで、最前面に表示されているアプリの正体を調べることができます。 dumpsys コマンドをパラメータなしで実行すると、大量のメッセージが表示されてしまうので、activity パラメータを指定して Activity に関する情報だけに絞り込むと見やすくなります。 端末上で実行する場合（adb shell でログイン後） # dumpsys activity adb 経由で実行する場合 $ adb shell dumpsys activity 例えば、以下のようにすれば、Stop 状態のアクティビティ含め、現在起動中のアクティビティの一覧を簡単に調べることができます（ここでは Windows の findstr コマンドを使用しています）。 C:\\\u0026gt; adb shell dumpsys activity activities | findstr /c:\u0026#34;* TaskRecord\u0026#34; * TaskRecord{2758379e #1 A=com.google.android.leanbacklauncher U=0 sz=1} * TaskRecord{18c788c2 #7 A=com.example.myapp1 U=0 sz=1} * TaskRecord{3cffb420 #4 A=com.example.myapp2 U=0 sz=1}"},{url:"/p/xr3n5jk/",title:"APK ファイルを逆コンパイルする (apktool)",date:"2011-05-27T00:00:00Z",body:"APK ファイルを逆コンパイルする (apktool) Apktool を使用すると、APK ファイルを逆コンパイルして、内部のファイルの内容を確認することができます。 Apktool - A tool for reverse engineering Android apk files 使い方は簡単で、次のように解析対象の APK ファイルと、出力先のディレクトリを指定するだけです。 使い方 $ apktool d \u0026lt;APKファイル名\u0026gt; \u0026lt;展開先ディレクトリ\u0026gt;"},{url:"/p/oi67p5c/",title:"python コマンドでワンライナーを実行する (python -c)",date:"2011-05-13T00:00:00Z",body:"python コマンドでワンライナーを実行する (python -c) python コマンドを実行するときに -c オプションを指定すると、コマンドラインで指定した Python コードを直接実行することができます。 このように 1 行で記述したコードは、ワンライナーと呼ばれています。 python のワンライナー実行の例 # Hello World $ python -c \u0026#34;print(\u0026#39;Hello World\u0026#39;)\u0026#34; Hello World # 連番の表示 $ python -c \u0026#34;print([x for x in range(5)])\u0026#34; [0, 1, 2, 3, 4] # 現在時刻の表示 $ python -c \u0026#34;import datetime; print(datetime.datetime.now())\u0026#34; 2023-11-23 16:22:37.530499 # JSON ファイルの特定のキーの値を取得する $ python -c \u0026#34;import json; print(json.load(open(\u0026#39;file.json\u0026#39;))[\u0026#39;key\u0026#39;])\u0026#34; value # CSV ファイルの特定の列を表示する $ python -c \u0026#34;import csv; print([row[\u0026#39;col1\u0026#39;] for row in csv.DictReader(open(\u0026#39;file.csv\u0026#39;))])\u0026#34; [\u0026#39;100\u0026#39;, \u0026#39;200\u0026#39;, \u0026#39;300\u0026#39;]"},{url:"/p/fufwdub/",title:"Linux シェルスクリプト: echo で出力する文字の色を変える",date:"2011-05-11T00:00:00Z",body:"Linux シェルスクリプト: echo で出力する文字の色を変える Linux の echo コマンドで特殊なエスケープシーケンスを出力すると、テキストの文字を変更することができます。 次の Bash スクリプトでは、色を変更しつつ echo 出力する、error / warn / info 関数を定義しています。 sample.sh #!/bin/bash error() { echo -e \u0026#34;\\033[31m$*\\033[00m\u0026#34; \u0026gt;\u0026amp;2 } warn() { echo -e \u0026#34;\\033[33m$*\\033[00m\u0026#34; \u0026gt;\u0026amp;2 } info() { echo -e \u0026#34;\\033[32m$*\\033[00m\u0026#34; \u0026gt;\u0026amp;2 } error \u0026#39;Error message\u0026#39; warn \u0026#39;Warning message\u0026#39; info \u0026#39;Information message\u0026#39; このシェルスクリプトを実行すると、次のように色付きのメッセージが表示されます。 図: echo コマンドの出力色を変更 ちなみに、echo コマンドの末尾の \u0026gt;\u0026amp;2 は、標準エラー出力へ出力することを示しています。 参考: echo の結果を標準エラー出力 (stderr) に出力する (1\u0026gt;\u0026amp;2)"},{url:"/p/or3cmv6/",title:"Linux シェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while)",date:"2011-02-06T00:00:00Z",body:"Linux シェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while) ワイルドカードを使用する方法 ワイルドカード (*) を使って、カレントディレクトリ内のファイルをループ処理することができます。 例: すべてのファイル（ドットファイルを除く）をループ処理 for x in *; do echo \u0026#34;$x\u0026#34; done 特定の拡張子を持つファイルのみを列挙するには次のようにします。 例: すべての PNG ファイルをループ処理 for x in *.png; do echo $x done 次のように一行で書くこともできます。 for x in *.png; do echo \u0026#34;$x\u0026#34;; done find コマンドの結果を使用する方法（再帰的にファイル探索） 下記の例では、find コマンドによって見つかったファイルを while ループで順番に処理しています。 深い階層にあるファイルも再帰的に処理されます。 find . -type f | while read x; do echo \u0026#34;$x\u0026#34; done"},{url:"/p/2wgxfwd/",title:"Traceview でプロファイル情報を表示する",date:"2011-01-14T00:00:00Z",body:"Traceview でプロファイル情報を表示する 参考: Traceview - Android Developers プロファイリングデータを取得する アプリケーション内の特定のコード区間のプロファイリングを行うには、プロファイリンク期間を android.os.debug.Debug クラスの startMethodTracing() と stopMethodTracing() で囲みます。 Debug.startMethodTracing(); ... プロファイリング中 ... Debug.stopMethodTracing(); プロファイリング結果は、/sdcard/dmtrace.trace というバイナリファイルに出力されます。 端末に SD カードが挿入されていないとエラーになります。 startMethodTracing メソッドのパラメータでファイル名のベース名を指定すると、/sdcard/\u0026lt;basename\u0026gt;.trace というファイル名で出力されるようになります。 結局 SD カードに出力されることには変わりありません。 ドキュメントには、 These methods start and stop method tracing across the entire virtual machine. と記述されているので、Debug.startMethodTracing() を呼び出した時点から、アプリケーション全体（正確には Dalvik VM 全体）のプロファイリングが行われることになります。 Activity がそのアプリのエントリポイントとなっているのなら、onCreate(), onDestroy() でそれぞれ、startMethodTracing()、stopMethodTracing() を呼び出すようにすれば、そのアプリ全体のプロファイリングを行うことができます。 プロファイリングデータを表示する Android SDK に含まれている traceview コマンドを使用すると、プロファイリング結果をグラフィカルに表示することができます。 図: Traceview 上記の図では、タイムラインに main スレッドが一本だけ表示されていますが、複数のスレッドが存在すれば、main 以外のスレッドもその下に表示されます。 まずは、/sdcard/dmtrace.trace ファイルを PC に取得します。 C:\\\u0026gt; adb pull /sdcard/dmtrace.trace あとは traceview コマンドのパラメータとして、dmtrace.trace のパスを渡すだけです。 Windows ではフルパスで指定する必要があります。 C:\\\u0026gt; traceview D:\\z\\dmtrace.trace プロファイリングデータからメソッドの呼び出しグラフを作成する $ dmtracedump -g output.png dmtrace.trace ※ dmtracedump は Windows では動作しません。 プロファイリングデータを HTML で出力する $ dmtracedump -h dmtrace.trace \u0026gt; output.html ※ dmtracedump は Windows では動作しません。"},{url:"/p/cv5pi7a/",title:"Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)",date:"2010-08-23T00:00:00Z",body:"Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune) 参考: Git でブランチを削除する (git branch -d/-D) 必要のないリモートブランチを削除（リモートサーバー側） git branch -d コマンドを使ってローカルのブランチを削除しても、GitHub などに既に push されているブランチは削除されません（他のメンバーには、まだブランチが存在しているように見えます）。 GitHub 側のブランチを削除するには、ローカルブランチを削除するのとは別のコマンドを実行する必要があります。 まずは、リモートトラッキングブランチの一覧を確認しておきます。 $ git branch -r origin/HEAD -\u0026gt; origin/main origin/main origin/mybranch1 origin/mybranch2 origin/mybranch3 例えば、この中の mybranch2 を削除したい場合は、以下のようにして origin サーバに削除要求を送ります。 削除したいブランチの名前の前にコロン (:) を付けるのがポイントです。 $ git push origin :mybranch2 git push の 2 番目のパラメータで指定するリファレンス名は、\u0026lt;プッシュ元のブランチ名\u0026gt;:\u0026lt;プッシュ先のブランチ名\u0026gt; という形式を取りますが、このコロンの左側の部分を空にすることで、プッシュ先のブランチを削除する（空にする）という意味になります。 ローカル側のリモートトラッキングブランチを削除する 中央リポジトリ (GitHub) 側のブランチを削除しても、ローカルに作られているリモートトラッキングブランチは削除されません。 以下のように必要のないリモートトラッキングブランチを削除する必要があります。 # フェッチと同時に必要のないリモートトラッキングブランチを削除する（オススメ） $ git fetch --prune # 必要のないリモートトラッキングブランチを削除する $ git remote prune origin あるいは、以下のように指定したリモートトラッキングブランチを削除することもできます。 $ git branch -r -d origin/mybranch 前者の場合は、中央リポジトリ上から実際に削除されたブランチを、ローカルのリモートトラッキングブランチから削除します。 後者の場合は、中央リポジトリは関係なしに、指定したローカルのリモートトラッキングブランチを削除します。"},{url:"/p/whv8ues/",title:"Git の detached HEAD 状態へのチェックアウトとは",date:"2010-08-23T00:00:00Z",body:"Git の detached HEAD 状態へのチェックアウトとは ある Git ブランチのコードをチェックアウトするには、 $ git switch \u0026lt;ブランチ名\u0026gt; のように実行しますが、そのブランチの最新コードではなく、ある特定のバージョン（コミット ID）のソースコードを少しだけ覗いてみたいということがあります。 そのような場合は、ブランチ名の代わりにコミット ID を指定してチェックアウトすることができます。 コミット名を指定して git checkout を実行すると、どのローカルブランチもチェックアウトしていない detached HEAD という状態になります（HEAD が detached されているということ）。 例えば、以下のように git checkout すると、この状態になります。 $ git checkout 0d3ce61 # コミット ID を指定 $ git checkout HEAD^0 # 最新のコミットを指定 $ git checkout HEAD^1 # １つ前のコミットを指定 $ git checkout v2.6.18 # タグで示されるコミットを指定 $ git checkout origin/main # リモートトラッキングブランチを指定 HEAD が detached された状態で git branch を実行すると、どのブランチにもいないことを示す (no branch) が表示されます。 $ git branch * (no branch) main mybranch detached HEAD 状態でも git commit などのコマンドを実行できますが、どのブランチにもいない状態なので、どのブランチの head も更新されません。 再びローカルブランチ名を指定してチェックアウトすると、detached HEAD で行っていた変更を破棄してブランチの最新状態に戻ることができます。"},{url:"/p/6g8n3jw/",title:"Git で他のブランチの最新ファイルを現在のブランチにコピーする (git checkout)",date:"2010-08-20T00:00:00Z",body:"Git で他のブランチの最新ファイルを現在のブランチにコピーする (git checkout) Git では、ファイル単位で他のブランチにコミットされているファイルをコピーしてくることができます。 例えば、現在 main ブランチをチェックアウトしているときに、別のブランチ mybranch の sample.txt の最新をコピーしてきたいときは次のように実行します。 $ git checkout mybranch sample.txt"},{url:"/p/jsctar8/",title:"Bash の変数展開機能を活用する（文字列の置換、デフォルト値など）",date:"2010-07-20T00:00:00Z",body:"Bash の変数展開機能を活用する（文字列の置換、デフォルト値など） Bash の変数は通常 ${x} のような形で参照しますが、様々な変数展開機能を利用すると、変数の存在を確認したり、一部を置換したり、デフォルト値を設定したりすることができます。 下記にざっと紹介しますが、公式なドキュメントは man bash の Parameter Expansion のセクションで参照することができます。 パターン照合演算子 次のような変数展開の構文を使用すると、変数に格納された文字列の一部を置換した文字列を作成することができます。 構文 意味 ${変数/パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（１つだけ） ${変数//パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（すべて） ${変数#パターン} 先頭から最短一致でパターンに一致する部分を取り除く ${変数##パターン} 先頭から最長一致でパターンに一致する部分を取り除く ${変数%パターン} 末尾から最短一致でパターンに一致する部分を取り除く ${変数%%パターン} 末尾から最長一致でパターンに一致する部分を取り除く パターン部分では、ワイルドカード（*、?、[a-z] など）を使用できます。 例: 変数内の b を B に置換する $ x=aaabbbccc $ y=${x/b/B} $ echo $y aaaBbbccc 最初に見つかった文字列だけが置換されていることがわかります。 パターンに一致する文字列をすべて置換するには次のようにします（最初のスラッシュを2つにします）。 $ x=aaabbbccc $ y=${x//b/B} $ echo $y aaaBBBccc 以下のように sed コマンドを使ったのと同様の効果を bash の機能だけで実現できていることになります。 $ y=$(echo $x | sed -e \u0026#39;s/bbb/BBB/g\u0026#39;) 例: フルパスから basename を取り出す 下記の例では /aaa/bbb/ccc という絶対パスから、ベースネーム部分の ccc を抽出しています。 */ というパターンで先頭から最長一致させ、/aaa/bbb/ という部分を取り除いています。 $ x=/aaa/bbb/ccc $ y=${x##*/} $ echo $y ccc ちなみに、ベースネーム部分を取得したいのであれば、通常は basename コマンドを使って以下のようにした方が簡単です。 $ basename $x 例: フルパスから dirname を取り出す 下記の例では、/aaa/bbb/ccc という絶対パスから、ディレクトリ名部分の /aaa/bbb を抽出しています。 /* というパターンで末尾から最短一致させ、/ccc という部分を取り除いています。 $ x=/aaa/bbb/ccc $ y=${x%/*} $ echo $y /aaa/bbb ちなみに、ディレクトリ部分を取得したいのであれば、通常は dirname コマンドを使用して以下のようにした方が簡単です。 $ dirname $x 例: \u0026lsquo;#\u0026rsquo; 以降のコメントを削除する $ line=\u0026#34;aaa bbb # This is a comment\u0026#34; $ line=${line%%#*} $ echo $line aaa bbb line 変数の中を末尾から見て、#* という表現で最長一致する部分を削除してます。 デフォルト値など 構文 意味 ${変数:-word} 変数が未定義のとき word を返す ${変数:=word} 変数が未定義のとき word を代入して返す ${変数:?} ${変数:?word} 変数が未定義のときエラーを表示する ${変数:+word} 変数が定義されているとき word を返す ${param:-word} の使用例 下記は man bash の抜粋です。 Use Default Values. If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted. If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted. 例えば、 x=${count:-0} とすると、$x の値は $count が定義されていなければ 0 になります。 つまり、$count のデフォルト値を 0 とみなして参照していることになります。 この構文は、コマンドライン引数が省略されたときのデフォルト値を設定するために使用できます。 例えば、 filename=${1:-input.txt} とすると、変数 $filename の値は、第1パラメータで指定された値か、あるいはデフォルト値の input.txt になります。 ${param:=word} の使用例 下記は man bash の抜粋です。 Assign Default Values. If parameter is unset or null, the expansion of word is assigned to parameter. The value of parameter is then substituted. Positional parameters and special parameters may not be assigned to in this way. 例えば、 x=${count:=0} とすると、$x の値は $count が定義されていなければ 0 になります。 ここまでは、${count:-0} とした場合と同様ですが、${count:=0} とすると、$count にも 0 が代入されます（代入 = だと考えると分かりやすいですね）。 変数に代入しようとするため、コマンドラインパラメータや関数のパラメータの $1 を参照するときにこの方法は使用できません。 ${param:?word} の使用例 下記は man bash の抜粋です。 Display Error if Null or Unset. If parameter is null or unset, the expansion of word (or a message to that effect if word is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of parameter is substituted. 例えば、下記のようにすると、$count 変数が定義されていないければエラーを出力して終了します。 $ echo ${count:?} -bash: count: パラメータが null または設定されていません ? の後ろに表示するメッセージを指定することもできます。 $ echo ${count:?パラメータが設定されていません} -bash: count: パラメータが設定されていません ${param:+word} の使用例 下記は man bash の抜粋です。 Use Alternate Value. If parameter is null or unset, nothing is substituted, otherwise the expansion of word is substituted. これはちょっと特殊で、変数 $param が定義されているときに、代わりに word の方の値が返されます。 例えば、${count:+1} は、$count が定義されていたら 1 と評価されます。 $ count=9999 $ echo ${count:+1} 1 $ unset count $ echo ${count:+1} 位置指定で部分文字列を抽出する 構文 意味 ${変数:offset} offset で指定した位置から末尾までの文字列を抽出する ${変数:offset:length} offset で指定した位置から length 分の文字列を抽出する $ hoge=ABCDEFGHIJ $ echo ${hoge:3} DEFGHIJ $ echo ${hoge:3:4} DEFG offset や length に負の値を指定して、末尾からの位置を示すこともできます。 ただし、その場合、offset の前に 1 つ以上のスペースが必要です（スペースを入れないと、${変数:-word} という形でデフォルト値が指定されたとみなされてしまいます）。 $ hoge=ABCDEFGHIJ $ echo ${hoge: -3} HIJ $ echo ${hoge: -5:-2} FGH"},{url:"/p/ivbss76/",title:"Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b)",date:"2010-07-19T00:00:00Z",body:"Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) git switch -c コマンドを使用すると、ブランチの作成と、そのブランチへの切り替え（チェックアウト）を同時に行うことができます（昔は同様の振る舞いをする git checkout -b コマンドが使っていました）。 ブランチの作成と切り替えを一度に行う $ git switch -c mybranch # ブランチ mybranch の作成＆チェックアウト Switched to a new branch \u0026#39;mybranch\u0026#39; $ git branch # 現在チェックアウトしているブランチの確認 main * mybranch git branch コマンドでのブランチ作成と同様、ブランチ元のブランチ名を指定することもできます。 $ git switch -c mybranch main"},{url:"/p/9bh2ody/",title:"Git でブランチ名を変更する (git branch -m)",date:"2010-07-19T00:00:00Z",body:"Git でブランチ名を変更する (git branch -m) Git のブランチ名を変更するには以下のように git branch -m コマンドを使用します。 ブランチ名を変更する $ git branch -m new # 現在チェックアウトしているブランチの名前を new に変更 $ git branch -m old new # old ブランチの名前を new に変更 GitHub などのリモートリポジトリに old リポジトリがすでに push されている場合は、次のようにして中央リポジトリ側のリポジトリ名も変更する必要があります。 GitHub 側のブランチ名を変更する $ git push origin new # 新しいブランチ new を push $ git push origin :old # 古いブランチ old を削除 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)"},{url:"/p/8cwbp3e/",title:"Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout)",date:"2010-07-17T00:00:00Z",body:"Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) 作業対象のブランチを切り替えるには、git switch コマンドで切り替え先のブランチ名を指定します（昔は git checkout コマンドが使われていましたが、現在は役割を明確にした git switch コマンドが使われています）。 ブランチを切り替える前に、 git branch コマンドを使用して、現在チェックアウトしているブランチと、切り替え先のブランチ名を確認しておくとよいです。 ブランチの一覧を確認 $ git branch * main my-branch 上記の出力で、現在の作業対象が main であることが分かります。 次のようにすると、作業対象を my-branch ブランチに切り替えることができます。 my-branch ブランチに切り替える $ git switch my-branch Switched to branch \u0026#34;my-branch\u0026#34; 切り替わっていることを確認する $ git branch main * my-branch これで、作業対象のブランチが my-branch に切り替わったので、これ以降の変更作業 (git commit) は、my-branch ブランチだけに反映され、main ブランチには反映されなくなります。"},{url:"/p/x9s8k2e/",title:"Git でブランチを作成する (git branch)",date:"2010-07-17T00:00:00Z",body:"Git でブランチを作成する (git branch) 現在チェックアウトしているブランチから、新しいブランチを作成するには次のコマンドを使用します。 $ git branch \u0026lt;新しいブランチ名\u0026gt; ブランチ元のブランチを指定して、新しいブランチを作成するには次のようにします。 $ git branch \u0026lt;新しいブランチ名\u0026gt; \u0026lt;既存のブランチ名\u0026gt; 例: main ブランチから REL-1.0 ブランチを作成する $ git branch REL-1.0 main git branch コマンドを引数なしで実行すると、ブランチの一覧を確認できます（git branch --list と同等）。 $ git branch REL-1.0 * master 上記の例では、今回作成された REL-1.0 と、デフォルトの master ブランチが存在することが分かります。master の前の * は、現在の作業対象（チェックアウトされているブランチ）が master ブランチであることを示しています。 作業対象を新しいブランチに切り替えるには、git switch コマンドを使用する必要があります。 参考: Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) 参考: Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) 参考: Git で他の人が作成したブランチ上で作業する ちなみに、ローカルで新しく作成したブランチの内容を GitHub などの中央リポジトリに git push するには、次のように実行します。 origin リポジトリへ新しいブランチ REL-1.0 を push $ git push origin REL-1.0 このとき、-u (--set-upstream) オプションを付けて実行すると、リモートブランチ名とローカルブランチ名が対応付けられて、次回からはパラメーターなしで git push できるようになります。 git push -u origin REL-1.0"},{url:"/p/stpfje9/",title:"Git でブランチを削除する (git branch -d/-D)",date:"2010-07-17T00:00:00Z",body:"Git でブランチを削除する (git branch -d/-D) 不要になったブランチを削除するには、git branch -d コマンドでブランチ名を指定します。 削除対象のブランチが作業対象になっていると削除できないので、先に git switch コマンドで別のブランチに切り替えてから削除を実行します。 mybranch ブランチを削除する $ git switch main $ git branch -d mybranch Deleted branch mybranch (was 1cc229d3) 削除しようとしているブランチの変更内容が、ブランチ元にマージされていない場合、以下のようなエラーが表示されます。 error: The branch \u0026#39;mybranch\u0026#39; is not an ancestor of your current HEAD. If you are sure you want to delete it, run \u0026#39;git branch -D mybranch\u0026#39; この場合は、先にブランチ元にマージを実行するか、あるいは、変更内容が完全に消えても構わない場合は -d オプションの代わりに -D オプションを指定して実行します。 マージされていないブランチを強制的に削除する $ git branch -D mybranch 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)"},{url:"/p/cqjv7wv/",title:"Git のコミット時にコメント記述に使用するエディタを設定する (core.editor)",date:"2010-07-17T00:00:00Z",body:"Git のコミット時にコメント記述に使用するエディタを設定する (core.editor) git commit コマンド実行時に、-m オプションでコメントを指定しなかった場合は、コメント入力のためにエディタが起動します。 ここで起動するエディタは自由に変更できます。 操作に慣れた Vim エディタなどを指定しておけば、コミット前の編集画面で操作ミスしてしまうこともなくなるでしょう。 例: エディタを vim に設定する $ git config --global core.editor vim 上記の例では、core.editor 設定を使ってエディタの指定を行っていますが、エディタの指定方法はたくさんあり、Git は次の順番で使用するエディタを判断します。 環境変数 GIT_EDITOR Git の core.editor 設定 環境変数 VISUAL 環境変数 EDITOR vi（Debian、Ubuntu の場合は editor）"},{url:"/p/f844tkg/",title:"Git 用語集",date:"2010-07-17T00:00:00Z",body:"Git 用語集 作業ツリー、ワークツリー (work tree) Git の管理下に入ったローカルのディレクトリツリーを 作業ツリー (work tree) と呼びます。 リポジトリに記録された内容を作業ツリーに展開する操作を チェックアウト (checkout) と呼びます。 git init コマンドなどで作成される .git/ ディレクトリが存在するディレクトリが、作業ツリーのルートになります。 Subversion や CVS では「作業コピー」と呼んでいました。 リポジトリ (repository) 変更履歴などを管理するリポジトリで、Git では必ずローカルディレクトリに存在します。 他のマシン上にあるリポジトリも、ローカルにあるリポジトリも対等の関係にあり、各リポジトリにコミットされた変更内容を互いにやりとりすることでプロジェクト全体の変更の一貫性を保ちます。 一般的には、ある一つのマシンのリポジトリを中央リポジトリとし、そこから最終的なプロジェクトの成果物を生成します。 リポジトリの実体は、作業ツリーのルートにある .git/ ディレクトリです。 ステージする (stage) あるファイルを次回のコミット対象に含めることを、ファイルを ステージする (stage) といいます。 Perforce を使ったことがある人は、p4 edit などによる Perforce サーバへの変更通知と近い概念なので分かりやすいと思います。 Git では、git add や git rm コマンドでファイルを指定すると、その情報が Git のインデックス情報として登録され、次回のコミット対象となります。 ハンク (hunk) ファイル内の連続した変更箇所のこと。 1 つのファイル内に連続した変更箇所が複数あれば、ハンクも複数存在することになります。 Git ではファイル単位で変更を追跡するのではなく、もっと細かいハンク単位で追跡します。 つまり、ファイル内の変更の一部だけをコミットするという作業が行えます。 チェックアウト (checkout) リポジトリに格納されたあるリビジョンの内容を作業ツリーに展開し、ローカルファイルとして見えるようにすることを チェックアウトする (checkout) と言います。 また、チェックアウトされているブランチとは、現在の作業ツリーに反映されているブランチのことで、作業対象になっているブランチのことをいいます。 main ブランチ / master ブランチ git init した後の初期状態で何かファイルをコミットすると、デフォルトで main というブランチが作成され、チェックアウトされた状態になります。 昔は master という名前が使われていましたが、アメリカの BLM 運動をきっかけに差別的で不適切な用語とされ main という名前に置き換えられました。 オブジェクトデータベース (object database) Git プロジェクトのデータベース（オブジェクトデータベース）には、オブジェクト (object) という統一形式でデータが保存されています。 ファイルを表すブロブオブジェクト、ディレクトリを表すツリーオブジェクト、コミットを表すコミットオブジェクトなどが格納されます。 オブジェクトデータベースの実体は、作業ツリーにある .git/objects/ ディレクトリです。 ブロブオブジェクト (blob object) ブロブオブジェクト は、Git で 1 つのファイルの内容を表現するオブジェクトで、オブジェクトデータベースで管理されます。 ツリーオブジェクト (tree object) ツリーオブジェクト は、Git で 1 つのディレクトリの内容を表現するオブジェクトで、オブジェクトデータベースで管理されます。 ツリーオブジェクトには、ディレクトリ内のファイルやディレクトリのパス情報とオブジェクト ID が含まれています。 コミットオブジェクト (commit object) コミットオブジェクト は、Git で 1 つのコミットの内容を表現するためのオブジェクトで、オブジェクトデータベースで管理されます。 コミットオブジェクトには、author（著者）、committer（記録者）、タイムスタンプ、コメントなどの情報が含まれています。"},{url:"/p/xi5sjju/",title:"シェルスクリプト: ある外部コマンドが使用できるかチェックする",date:"2010-06-13T00:00:00Z",body:"シェルスクリプト: ある外部コマンドが使用できるかチェックする シェルスクリプトの中で特定の外部コマンドを使用する必要がある場合、先頭部分でその外部コマンドが使用できる状態かどうかを調べておくと親切です。 例えば、次のようにすれば、ruby コマンドが使用できるかを確認できます。 sample.sh if type -P ruby \u0026gt; /dev/null; then echo \u0026#39;ruby コマンドを使用できます\u0026#39; else echo \u0026#39;ruby コマンドが見つかりません\u0026#39; fi ☝️ type -P コマンド type -P ruby コマンドは、パスの通ったディレクトリから ruby を検索してそのパスを取得するためのものですが、ここでは ruby コマンドが使用できる環境になっているかを確認するために利用しています。 単純に実行すると、検索結果のパスが出力されてしまうので、null デバイスへリダイレクトして出力を抑制しています。 特定のコマンドが使用できない場合にスクリプトを終了させるには、以下のように記述すればよいでしょう。 条件式を ! で反転させていることに注意してください。 if ! type -P ruby \u0026gt; /dev/null; then echo \u0026#39;This script requires Ruby. Please install Ruby first and try again.\u0026#39; \u0026gt;\u0026amp;2 exit -1 fi # 処理を継続"},{url:"/p/r3myewb/",title:"シェルスクリプト: ある環境変数が定義されているかチェックする (test -z)",date:"2010-06-13T00:00:00Z",body:"シェルスクリプト: ある環境変数が定義されているかチェックする (test -z) 環境変数がセットされているかを確認する 下記の例では、SRC_ROOT という環境変数が設定されているかを調べ、設定されていない場合はメッセージを終了しています。 sample.sh #!/bin/bash if [ -z $SRC_ROOT ]; then echo \u0026#39;Please set the \u0026#34;SRC_ROOT\u0026#34; environment variable and try again.\u0026#39; \u0026gt;\u0026amp;2 exit -1 fi echo \u0026#39;Program continues...\u0026#39; ☝️ ワンポイント echo の出力を \u0026gt;\u0026amp;2 とリダイレクトすると標準エラー出力へ出力できます。 実行例 $ ./sample.sh Please set the \u0026#34;SRC_ROOT\u0026#34; environment variable and try again. $ SRC_ROOT=/Users/maku/src ./sample.sh Program continues... （おまけ）test コマンドについて if [ -z $SRC_ROOT ]; then という条件判定は、次のように test コマンドを使うのと同等です。 if test -z $SRC_ROOT; then test -z コマンドは、指定された変数値の文字列長が 0 かどうかを確認するコマンドです。 これを利用して、上記のように 特定の変数値がセットされていない ことを調べることができます。 ちなみに、[ は特殊な記号のように見えますが、実質は test コマンドのエイリアスなので、前後にスペースが必要なことに注意してください。"},{url:"/p/4tbzpyf/",title:"シェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#)",date:"2010-06-13T00:00:00Z",body:"シェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#) 関連記事: Linux シェルスクリプト: コマンドライン引数を取得する ($1, $@, $*) コマンドライン引数が足りないときに Usage 出力して終了する シェルスクリプト起動時に渡されたコマンドライン引数の数は、$# 変数で取得することができます。 シェルスクリプトが最低 2 つのパラメーターを必要としている場合は、先頭部分で下記のようなチェックをするのがよいでしょう。 例: 2 つ以上のパラメーターが必要 #!/bin/bash if [ $# -lt 2 ]; then echo \u0026#34;Usage: $(basename $0) \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt;\u0026#34; \u0026gt;\u0026amp;2 exit -1 fi # 処理を継続 下記はバリエーションです。 例: 1 つ以上のパラメーターが必要 #!/bin/bash if [ ! \u0026#34;$1\u0026#34; ]; then echo \u0026#34;Usage: $(basename $0) \u0026lt;file\u0026gt;\u0026#34; \u0026gt;\u0026amp;2 exit -1 fi # 処理を継続 例: 1 つは引数が必要で、かつ、その名前のファイルが存在する #!/bin/bash if [ ! \u0026#34;$1\u0026#34; ]; then echo \u0026#34;Usage: $(basename $0) \u0026lt;file\u0026gt;\u0026#34; \u0026gt;\u0026amp;2 exit -1 fi if [ ! -f \u0026#34;$1\u0026#34; ]; then echo \u0026#34;$1 is not found\u0026#34; \u0026gt;\u0026amp;2 exit -1 fi # 処理を継続 コマンドライン引数が指定されていないときにデフォルト値を使用する 1 番目のコマンドライン引数を参照するときに ${1:-XXX} とすると、引数を省略したときに XXX というデフォルト値が返されます。 例えば、次の例では、コマンドライン引数で「出力先ディレクトリ」を指定できるようにしていますが、省略した場合のデフォルトとして out ディレクトリを使用するようにしています。 sample.sh #!/bin/bash out_dir=${1:-out} echo out_dir: $out_dir 実行例 $ ./sample.sh foo out_dir: foo $ ./sample.sh foo bar out_dir: foo $ ./sample.sh \u0026#34;foo bar\u0026#34; out_dir: foo bar $ ./sample.sh out_dir: out $ ./sample.sh \u0026#34;\u0026#34; out_dir: out"},{url:"/p/zdxfvct/",title:"Python でモジュールを import する方法のまとめ",date:"2009-11-19T00:00:00Z",body:"Python でモジュールを import する方法のまとめ Python でモジュールをインポートする際に使用される import 構文は、複数の指定方法があるため、初めはやや混乱するかもしれません。 以下に、import のさまざまな指定方法をまとめておきます。 Python のモジュールとパッケージの基本については下記の記事を参考にしてください。 Python でモジュールやパッケージを作成する モジュール単位でのインポート まずは基本から。 モジュール名でインポートする方法です。 この方法でモジュールをインポートした場合は、内部の関数などを参照するときは、モジュール名をプレフィックスとして付けます。 mymod モジュールをインポートする import mymod mymod.hello() パッケージ内のモジュールをインポートするときは、次のいずれかの方法で記述しますが、モジュール内のメンバーを参照するときのプレフィックスが変わってきます。 mypkg パッケージ内の mymod モジュールをインポートする # 方法1 import mypkg.mymod mypkg.mymod.hello() # 方法2 from mypkg import mymod mymod.hello() 2 階層以上のパッケージになっても同様です。 # 方法1 import mypkg.sub.mymod mypkg.sub.mymod.hello() # 方法2 from mypkg.sub import mymod mymod.hello() 特定のメンバーのみをインポート from モジュール名 import 関数名 という構文で、モジュール内の特定の関数だけインポートすれば、モジュール名を指定せずにその関数を直接呼び出せるようになります。 mymod モジュールの hello 関数のみをインポートする from mymod import hello hello() パッケージ内のモジュールに関しても同様です。 mypkg パッケージの mymod モジュールの hello 関数のみをインポートする from mypkg.mymod import hello hello() ワイルドカード (*) を使って、モジュール内のすべてのメンバーをインポートできます（ただし、アンダースコア (_) で始まるメンバーはインポートされません）。 mymod モジュールのすべてのメンバーをインポートする from mymod import * hello() 別名を付けてインポート (as) インポートしたモジュールや関数の名前が長すぎると感じたときは、as キーワードを使用して別名を付けることができます。 別名は、名前のコンフリクトを防ぐためにも使用することがあります。 ElementTree モジュールを ET という別名でインポート import xml.etree.ElementTree as ET tree = ET.parse(\u0026#39;books.xml\u0026#39;) いろいろなインポートのパターン 最後にいろいろなインポートの例を載せておきます。 全部理解できれば、たぶんインポートマスターです。 # モジュール mod をインポート import mod # モジュール mod をインポート（hoge で参照） import mod as hoge # モジュール mod1 と mod2 をインポート import mod1, mod2 # モジュール mod 内の関数 func をインポート from mod import func # モジュール mod 内の関数 func1 と func2 をインポート from mod import func1, func2 # モジュール mod 内の全メンバーをインポート from mod import * # パッケージ pkg 内のモジュール mod をインポート（参照時のプレフィックスは pkg.mod） import pkg.mod # パッケージ pkg 内のサブパッケージ sub 内のモジュール mod をインポート（参照時のプレフィックスは pkg.sub.mod） import pkg.sub.mod # パッケージ pkg 内のモジュール mod をインポート（参照時のプレフィックスは mod） from pkg import mod # パッケージ pkg 内のモジュール mod をインポート（参照時のプレフィックスは hoge） from pkg import mod as hoge # パッケージ pkg 内のモジュール mod 内の関数 func をインポート from pkg.mod import func # 相対パスで同じ階層のモジュール mod をインポート from . import mod # 相対パスで同じ階層のモジュール mod 内の関数 func をインポート from .mod import func # 相対パスで 1 つ上のパッケージ階層のモジュール mod をインポート from .. import mod # 相対パスで 1 つ上のパッケージ階層のモジュール mod 内の関数 func をインポート from ..mod import func"},{url:"/p/bfev6xf/",title:"Python でキーボードからのユーザ入力を取得する (input, getpass)",date:"2009-11-18T00:00:00Z",body:"Python でキーボードからのユーザ入力を取得する (input, getpass) input 関数と getpass 関数 Python 組み込み関数の input 関数を使用すると、画面上にプロンプトを表示して、キーボードからの入力を促すことができます。 name = input(\u0026#34;Please input your name: \u0026#34;) print(\u0026#34;Hello,\u0026#34;, name) パスワードを入力させるときなど、入力した文字を画面上に表示したくない場合は、input 関数の代わりに、getpass モジュールの getpass 関数を使用します。 from getpass import getpass password = getpass(\u0026#34;Password: \u0026#34;) 使用例: 処理を継続するかの確認 ファイルの削除など、危険なコマンドを実行する前に Are you sure? 的な確認メッセージを表示するサンプルコードです。 ユーザーが y あるいは Y 以外の文字を入力すると、そこで処理を打ち切ります。 confirm.py import sys answer = input(\u0026#34;Are you sure? (y/n): \u0026#34;) if (answer.lower() != \u0026#34;y\u0026#34;): sys.exit(0) print(\u0026#34;処理を継続します\u0026#34;) 実行例 $ python confirm.py Are you sure? (y/n): Y 処理を継続します 使用例: 入力したユーザー名とパスワードのチェック 下記のサンプルコードでは、ユーザに「ユーザ名」と「パスワード」のペアを入力させて、それらがあらかじめ登録されたペアと一致しているかをチェックしています。 password.py from getpass import getpass user_db = ( (\u0026#34;user1\u0026#34;, \u0026#34;password1\u0026#34;), (\u0026#34;user2\u0026#34;, \u0026#34;password2\u0026#34;), (\u0026#34;user3\u0026#34;, \u0026#34;password3\u0026#34;), ) user = input(\u0026#34;User: \u0026#34;) pw = getpass(\u0026#34;Password: \u0026#34;) if (user, pw) in user_db: print(\u0026#34;Access granted\u0026#34;) else: print(\u0026#34;Access denied\u0026#34;) 実行例 $ python password.py User: user1 Password:（password1 と入力） Access granted"},{url:"/p/t8o6tum/",title:"Vim で行番号を表示する (number)",date:"2009-09-09T00:00:00Z",body:"Vim で行番号を表示する (number) 行番号の表示・非表示 (number, nonumber) Vim で各行の行頭に行番号を表示するには、:set number を実行します。 逆に、行番号を非表示にするには、:set nonumber を実行します（デフォルト）。 常にこの設定を有効化しておきたいときは、設定ファイル ~/.vimrc（NeoVim なら init.vim）に次のように記述しておきます。 ~/.vimrc set number \u0026#34;Print the line number in front of each line. 行番号のカラー設定 (highlight LineNr) 行番号の背景色や文字色を変更するには highlight (hi) コマンドで、カラーグループ LineNr を設定します。 :highlight LineNr guifg=Black guibg=DarkGray ctermfg=Black ctermbg=DarkGray"},{url:"/p/uatcsaq/",title:"Python のオブジェクトを print 関数で出力できるようにする (__str__)",date:"2009-06-06T00:00:00Z",body:"Python のオブジェクトを print 関数で出力できるようにする (__str__) クラスを定義するときに特殊メソッド __str__ を実装しておくと、print() や str() にそのオブジェクトを渡したときの出力をカスタマイズすることができます。 sample.py class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f\u0026#34;Name={self.name}, Age={self.age}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: p = Person(\u0026#34;Maku\u0026#34;, 14) print(p) 実行結果 $ python sample.py name=Maku, age=14"},{url:"/p/thhwr4b/",title:"Python でディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob)",date:"2009-01-06T00:00:00Z",body:"Python でディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob) ファイルを列挙する（再帰なし） Python の os.listdir 関数を使うと、指定したディレクトリ内のファイルやディレクトリのパスをリストで取得できます。 カレントディレクトリや親ディレクトリを表す . や .. は、列挙の対象に含まれません。 列挙されたパスが、ディレクトリかどうかを調べたいときは os.path.isdir(path)、ファイルかどうかを調べたいときは os.path.isfile(path) で確認できます。 カレントディレクトリ内のディレクトリとファイルを列挙（1 階層のみ） import os for x in os.listdir(\u0026#39;.\u0026#39;): if os.path.isdir(x): print(\u0026#39;DIR:\u0026#39;, x) else: print(\u0026#39;FILE:\u0026#39;, x) ファイルを列挙する（再帰あり） os.listdir で列挙する方法 os.listdir 関数で列挙した要素がディレクトリだった場合に、そのディレクトリに対しても os.listdir 関数を呼び出すようにすれば、ディレクトリ内のすべてのファイルを再帰的に列挙することができます。 import os def enum_files(dir): entries = os.listdir(dir) for x in entries: path = os.path.join(dir, x) if os.path.isdir(path): for _ in enum_files(path): yield _ else: yield path if __name__ == \u0026#39;__main__\u0026#39;: for path in enum_files(\u0026#39;.\u0026#39;): print(path) # print(os.path.abspath(path)) # 絶対パスで出力する場合 os.walk で列挙する方法 os.walk 関数 を使用すると、再帰的なファイル列挙をさらに簡単に記述できます。 下記は 1 つのループ処理で記述していますが、下位のディレクトリにあるファイルまですべて列挙してくれます。 os.walk はデフォルトで再帰的にディレクトリを辿ってくれる ということです。 カレントディレクトリ以下、全ディレクトリの内容を表示 import os for dirpath, dirs, files in os.walk(\u0026#34;.\u0026#34;): print(\u0026#34;-\u0026#34; * 60) print(f\u0026#34;{dirpath} ディレクトリの情報:\u0026#34;) print(f\u0026#34;dirs = {dirs}\u0026#34;) print(f\u0026#34;files = {files}\u0026#34;) os.walk によって取得されるタプル要素には、それぞれ以下のような情報が格納されています。 dirpath \u0026hellip; 現在検索中のディレクトリパス dirs \u0026hellip; dirpath のディレクトリに含まれているディレクトリのリスト files \u0026hellip; dirpath のディレクトリに含まれているファイルのリスト つまり、ディレクトリごとに上記のタプルが返されながらループが進んでいきます。 カレントディレクトリ以下のすべてのファイルのパスだけを列挙するには次のように files（タプルの 3 番目の要素）の内容だけ出力すれば OK です。 起点となるディレクトリのパス (dirpath) と join してやれば、そこからの相対パスを構築できます。 カレントディレクトリ以下のすべてのファイルの相対パスを表示 import os for dirpath, dirs, files in os.walk(\u0026#39;.\u0026#39;): for f in files: print(os.path.join(dirpath, f)) 出力例 ./a.txt ./b.txt ./foo/c.txt ./foo/d.txt ./foo/bar/e.txt ./foo/bar/f.txt ./hoge/g.txt 特定の拡張子のファイルだけ列挙したい場合 は、ファイル名の末尾を str.endswith メソッドでチェックすればよいでしょう。 .png ファイルのみを列挙 for f in files: if f.lower().endswith(\u0026#39;.png\u0026#39;): print(os.path.join(dirpath, f)) endswith() にはタプルを渡せるので、複数の拡張子を OR 条件で列挙することもできます。 .png、.jpg、.svg ファイルを列挙 for f in files: if f.lower().endswith((\u0026#39;.png\u0026#39;, \u0026#39;.jpg\u0026#39;, \u0026#39;.svg\u0026#39;)): print(os.path.join(dirpath, f)) os.path.splitext() を使用すれば、ファイル名をベースネームと拡張子に分離することができますが、拡張子のチェックだけであれば、endswith() を使った方がシンプルです。 glob で列挙する方法 ディレクトリ内の、特定の拡張子を持つファイルをすべて列挙したいときは、glob モジュール の glob.glob 関数を使うのが一番簡単です。 次のようにすると、カレントディレクト以下の .png ファイルをすべて列挙できます。 .png 拡張子を持つファイルを列挙 import os import glob for x in glob.glob(\u0026#39;**/*.png\u0026#39;, recursive=True): print(x) ただし、グロブでは複数の拡張子をまとめて処理できない ので、複数の拡張子のファイルを列挙したい場合は、その数だけ glob.glob() を呼び出さなければいけません。 .png あるいは .jpg 拡張子を持つファイルを列挙 import os import glob PATTERNS = (\u0026#39;**/*.png\u0026#39;, \u0026#39;**/*.jpg\u0026#39;) def multi_glob(patterns): files = [] for p in PATTERNS: files.extend(glob.glob(p, recursive=True)) return files for f in multi_glob(PATTERNS): print(f) このような実装をするのであれば、os.walk を使って列挙した方が早いかもしれません。 参考: Python で指定した拡張子、名前のファイルを列挙する"},{url:"/p/rihibef/",title:"Vim のアンドゥ操作とリドゥ操作",date:"2008-11-13T00:00:00Z",body:"Vim のアンドゥ操作とリドゥ操作 アンドゥ／リドゥの操作方法 Vim でアンドゥ (Undo) 操作、リドゥ (Redo) 操作を行うには、下記のコマンドを使用します。 u \u0026hellip; アンドゥ Ctrl-r \u0026hellip; リドゥ（アンドゥによって取り消された操作を復旧） アンドゥ回数の設定 アンドゥ操作のレベル（制限回数）を変更するには undolevels オプションを設定します。 :set undolevels=300 Linux や Windows では、undolevels の規定値は 1000 なので、通常は変更する必要はないでしょう。"},{url:"/p/c2kx7er/",title:"Linux シェルスクリプト: コマンドライン引数を取得する ($1, $@, $*)",date:"2008-10-29T00:00:00Z",body:"Linux シェルスクリプト: コマンドライン引数を取得する ($1, $@, $*) コマンドライン引数の基本 ($1 ~ $9) bash シェルスクリプト実行時にコマンドラインで渡した引数を参照するには、次のようなパラメーター参照用の特殊変数を使用します。 $1 \u0026hellip; 第 1 パラメーター $2 \u0026hellip; 第 2 パラメーター $3 \u0026hellip; 第 3 パラメーター パラメーターの参照には、$1 〜 $9 が使用できます。 使用することは余りないと思いますが、10 番目以降のパラメータを参照したいときは、${10} のように数値を {} で囲めば参照できます。 sample.sh #!/bin/bash echo \u0026#39;1 番目: \u0026#39; \u0026#34;$1\u0026#34; echo \u0026#39;2 番目: \u0026#39; \u0026#34;$2\u0026#34; echo \u0026#39;3 番目: \u0026#39; \u0026#34;$3\u0026#34; 実行結果 $ ./sample.sh AAA BBB \u0026#34;CCC DDD\u0026#34; 1 番目: AAA 2 番目: BBB 3 番目: CCC DDD コマンドライン引数を指定しなかった場合は、対応する変数は空になります。 $ ./sample.sh AAA 1 番目: AAA 2 番目: 3 番目: ☝️ 変数はダブルクォートで囲む echo の引数として変数の値を渡すときは、\u0026quot;$1\u0026quot; のようにダブルクォートで囲む癖をつけましょう。 $1 のようにそのまま記述してしまうと、変数の値として連続するスペースが含まれていたときに 1 つのスペースにまとめられてしまいます。 ☝️ 引数とパラメーターの違い 正確には、引数 (arguments) という用語は、スクリプトや関数を呼び出す側が渡す値のことを示し、パラメーター (parameters) という用語は、呼び出される側のスクリプトや関数が、その値を参照するときに使う変数のことを示します。 ただ、どちらのケースでもパラメーターという用語を使っているドキュメントもよく見かけるので、あまり気にしないのがよさそうです。 コマンドライン引数にデフォルト値を指定する (${1:-XXX}) コマンドライン引数が指定されなかったときに使用する値として、デフォルト値を指定しておくこともできます。 デフォルト値は、パラメーター参照時に ${1:-デフォルト値} という形で指定します。 下記の例では、1 番目、2 番目、3 番目のコマンドラインパラメーターのデフォルト値を、それぞれ AAA、BBB、CCC に設定しています。 sample.sh #!/bin/bash echo \u0026#39;1 番目: \u0026#39; \u0026#34;${1:-AAA}\u0026#34; echo \u0026#39;2 番目: \u0026#39; \u0026#34;${2:-BBB}\u0026#34; echo \u0026#39;3 番目: \u0026#39; \u0026#34;${3:-CCC}\u0026#34; 実行結果（1 番目の引数のみ指定した場合） $ ./sample.sh 100 1 番目: 100 2 番目: BBB 3 番目: CCC 指定されたコマンドライン引数の数を取得する ($#) シェルスクリプト実行時に渡されたパラメータの数は、$# という特殊変数で取得することができます。 sample.sh #!/bin/bash echo 引数の数: $# 実行結果 $ ./sample.sh 引数の数: 0 $ ./sample.sh AAA 引数の数: 1 $ ./sample.sh AAA \u0026#34;BBB CCC DDD\u0026#34; 引数の数: 2 コマンドライン引数をループで順番に処理する ($@, $*) for ループを使う方法 シェルスクリプト実行時に渡されたコマンドライン引数は、特殊変数 $@ を使って参照することができます。 以下の例では、for in ループを使って、$@ の要素を 1 つずつ取り出して処理しています（おまけでカウンター変数 $count をインクリメントしながらループしてます）。 sample.sh #!/bin/bash count=1 for arg in \u0026#34;$@\u0026#34;; do echo \u0026#34;$count: $arg\u0026#34; let count=$count+1 done 実行結果 $ ./sample.sh AAA BBB \u0026#34;CCC DDD\u0026#34; 1: AAA 2: BBB 3: CCC DDD 実は、特殊変数の指定部分 in \u0026quot;$@\u0026quot; は省略して記述することができます。 sample.sh #!/bin/bash count=1 for arg; do echo \u0026#34;$count: $arg\u0026#34; let count=$count+1 done 明示的に in \u0026quot;$@\u0026quot; を記述する場合は、$@ の部分をダブルクォートで囲むことを忘れないようにしてください（詳しくは後述）。 while ループを使う方法 shift コマンドを実行することで、$1〜$9 に格納されたパラメータを 1 つずつ前にシフトすることができます。 shift コマンドを実行するたびに $1 に格納されていたパラメータは破棄され、パラメータ数を表す $# の値が 1 つずつ減っていきます。 下記の例では、パラメータ数 ($#) が 1 以上の間、処理を続ける while ループを定義しています。 $1 はコマンドラインパラメータの最初の要素を参照する変数ですが、直後の shift によってパラメータを 1 つずつシフトしているので、結果としてすべてのパラメータを順番に参照することができます。 sample.sh #!/bin/bash count=1 while [ \u0026#34;$#\u0026#34; -ge \u0026#34;1\u0026#34; ]; do echo \u0026#34;$count: $1\u0026#34; shift let count=$count+1 done 実行結果 $ ./sample.sh AAA BBB CCC 1: AAA 2: BBB 3: CCC 引数全体を 1 つの文字列として取得する ($*) $@ と似た特殊変数に $* があります。 どちらもパラメータ全体を表す特殊変数ですが、$@ が各パラメータを個別に保持しているのに対し、$* はすべてのパラメータを結合した 1 つの文字列 になっています。 それぞれ、ダブルクォートで囲んで参照した場合と、囲まずに参照した場合の展開方法も含めて理解しておきましょう。 下記のようなサンプルコードと、その振る舞いを対応付けて覚えてしまうのが手っ取り早いです。 sample.sh #!/bin/bash echo -e \u0026#39;\\n=== \u0026#34;$@\u0026#34; の場合 ===\u0026#39; for arg in \u0026#34;$@\u0026#34;; do echo \u0026#34;$arg\u0026#34; done echo -e \u0026#39;\\n=== $@ の場合 ===\u0026#39; for arg in $@; do echo \u0026#34;$arg\u0026#34; done echo -e \u0026#39;\\n=== \u0026#34;$*\u0026#34; の場合 ===\u0026#39; for arg in \u0026#34;$*\u0026#34;; do echo \u0026#34;$arg\u0026#34; done echo -e \u0026#39;\\n=== $* の場合 ===\u0026#39; for arg in $*; do echo \u0026#34;$arg\u0026#34; done 実行結果 $ ./sample.sh \u0026#34;100 200\u0026#34; \u0026#34;CCC DDD\u0026#34; === \u0026#34;$@\u0026#34; の場合 === 100 200 CCC DDD === $@ の場合 === 100 200 CCC DDD === \u0026#34;$*\u0026#34; の場合 === 100 200 CCC DDD === $* の場合 === 100 200 CCC DDD 1 番目の方法が、おそらく想定通りの振る舞いに近いと思います。 \u0026quot;$@\u0026quot; と指定することで、内部的には下記のようにそれぞれの要素をダブルクォート (\u0026quot;) で囲んで指定されたものとみなされるため、正しく 2 つのパラメータとしてハンドルされます。 for arg in \u0026#34;100 200\u0026#34; \u0026#34;AAA BBB\u0026#34;; ... 2 番目の方法のように $@ をダブルクォートで囲まずに渡すと、下記のように各要素が展開して指定されたものとみなされます。 for ループはスペース区切りで各要素が渡されていると判断するため、結果的に 4 つの要素として処理されてしまいます。 for arg in 100 200 AAA BBB; ... 3 番目の方法のように \u0026quot;$*\u0026quot; と指定すると、下記のように全てのパラメータをスペースでつなげ、さらに全体をダブルクォート (\u0026quot;) で囲んで指定されたものとして処理されます。 つまり、ループは \u0026quot;100 200 AAA BBB\u0026quot; という文字列 1 回分しか回りません。 for arg in \u0026#34;100 200 AAA BBB\u0026#34;; do 4 番目の方法のように $* と指定した場合は、2 番目の方法と同様に、すべての要素がスペース区切りで渡されたとみなされます（4 つの要素として処理されます）。 for arg in 100 200 AAA BBB; ... （コラム）$* が使用する IFS 変数について 前述のとおり、全てのパラメータは $* あるいは $@ で参照できます。 $* は環境変数 IFS に設定された最初のセパレータで区切られた単一の文字列として評価され（デフォルトはスペース）、$@ はスペースで区切られた複数の文字列として評価されます。 例えば、次のように実行した場合、 $ ./sample.sh aaa bbb ccc ddd それぞれの値は以下のようになります。 $* → \u0026quot;aaa bbb ccc ddd\u0026quot; $@ → \u0026quot;aaa\u0026quot; \u0026quot;bbb\u0026quot; \u0026quot;ccc\u0026quot; \u0026quot;ddd\u0026quot; $ ./sample.sh \u0026#34;aaa bbb\u0026#34; \u0026#34;ccc ddd\u0026#34; とした場合は、 $* → \u0026quot;aaa bbb ccc ddd\u0026quot; $@ → \u0026quot;aaa bbb\u0026quot; \u0026quot;ccc ddd\u0026quot; となります。 $* はこのような性質を持つため、2 つ目の例のように、スペースを含むパラメータが渡されたときに for ループでうまく扱うことができません。 sample.sh（おそらく間違った実装例） #!/bin/bash for x in $*; do echo \u0026#34;$x\u0026#34; done 実行結果（4つのパラメータとして扱われてしまう） $ ./sample.sh \u0026#34;aaa bbb\u0026#34; \u0026#34;ccc ddd\u0026#34; aaa bbb ccc ddd 実は、IFS 変数の値は変更できる ため、次のようにして改行 1 つ分に変更してやることで、for ループがうまく回るようになります。 sample.sh（推奨はしないがうまく動作する実装例） #!/bin/bash IFS=\u0026#39; \u0026#39; for x in $*; do echo \u0026#34;$x\u0026#34; done unset IFS # デフォルトに戻す（スペースで結合） 実行結果（ちゃんと 2 つのパラメータとして扱われる） $ ./sample.sh \u0026#34;aaa bbb\u0026#34; \u0026#34;ccc ddd\u0026#34; aaa bbb ccc ddd うまく動作するとはいえ、これはとてもトリッキーな方法なので、パラメータをループ処理するときは素直に \u0026quot;$@\u0026quot; を使って次のように書きましょう。 for arg in \u0026#34;$@\u0026#34;; do echo \u0026#34;$arg\u0026#34; done 関連記事 コマンドライン引数の数が正しいかチェックする ($#)"},{url:"/p/hudubr8/",title:"Linuxコマンド: ファイルやディレクトリを検索する (find, grep)",date:"2008-09-08T00:00:00Z",body:"Linuxコマンド: ファイルやディレクトリを検索する (find, grep) find と grep の基本 指定した拡張子のファイルを検索する (find) 次のようにすると、カレントディレクトリ (.) を起点にして、拡張子 .txt を持つファイルを検索して一覧表示することができます。 $ find . -name \u0026#39;*.txt\u0026#39; ファイル内の文字列を検索する (grep) 次のようにすると、指定したテキストファイル内の文字列を検索することができます。 $ grep \u0026#39;検索文字列\u0026#39; hello.txt find で見つけたファイルの中身を grep 検索する find で検索した結果のファイルそれぞれに対して、grep コマンドを実行するには、xargs を組み合わせて使用します。 例: 拡張子に txt を持つファイルを grep $ find . -type f -name \u0026#39;*.txt\u0026#39; | xargs grep \u0026#39;検索文字列\u0026#39; 拡張子などを絞り込まず、単純にそのディレクトリ以下のすべてのテキストファイルを検索するだけでよいのであれば、find を使わず、grep の再帰オプション (-r) を使った方が簡単です。 念のため、テキストファイルのみを grep 対象にするために -I オプション (--binary-files-without-match) も一緒に指定しておきます。 例: すべてのテキストファイルを grep $ grep -r -I \u0026#39;検索文字列\u0026#39; . grep で NOT、AND、OR 検索する NOT 検索 grep の -v オプションを指定すると、指定した 文字列を含まない 行だけを抽出できます。 例: TODO という文字列を含まない行を検索する $ grep -v \u0026#39;TODO\u0026#39; file.txt AND 検索 grep で AND 検索したいときは、grep の検索結果をパイプで繋いでさらに grep 検索してしまうのが簡単です。 例: すべての .txt ファイルから AAA と BBB の両方を含む行を検索する $ find . -name \u0026#39;*.txt\u0026#39; | xargs grep AAA | grep BBB 例: すべての .html ファイルから http: を含む行（ただし http://localhost ではない）を検索する $ find . -name \u0026#39;*.html\u0026#39; | xargs grep \u0026#39;http:\u0026#39; | grep -v \u0026#39;http://localhost\u0026#39; OR 検索 grep で OR 検索したいときは、検索した文字列を -e オプションで複数回指定します。 例: AAA あるいは BBB を含む行を検索する $ grep -e AAA -e BBB file.txt 別の方法として、正規表現（-E オプション）を使用して OR 検索する方法もあります。 $ grep -E \u0026#39;AAA|BBB\u0026#39; file.txt $ egrep \u0026#39;AAA|BBB\u0026#39; file.txt find のオプションいろいろ ファイル名で OR 検索する find でファイル名の OR 検索をするときは、-o オプションで -name などの検索オプションを繋ぎます。 例: .py ファイルと .rb ファイルを検索する $ find . -name \u0026#39;*.py\u0026#39; -o -name \u0026#39;*.rb\u0026#39; ファイル名の大文字と小文字を区別しない (-iname) -name オプションの代わりに -iname オプションを使用すると、ファイル名の大文字と小文字を区別せずにファイル検索することができます。 例: カレントディレクトリ以下の foo.txt や FOO.TXT や Foo.Txt などを検索 $ find . -iname foo.txt 特定のディレクトリを検索対象外にする (-not -path) -not -path あるいは ! -path で検索対象外にするパスのパターンを指定できます。 例: node_modules ディレクトリを検索対象外にする $ find . -name \u0026#39;*.md\u0026#39; -not -path \u0026#39;*/node_modules/*\u0026#39; $ find . -name \u0026#39;*.md\u0026#39; ! -path \u0026#39;*/node_modules/*\u0026#39; 空のファイル／ディレクトリを検索する (-empty) $ find . -type f -empty # サイズが 0 のファイルを検索する $ find . -type d -empty # 空っぽのディレクトリを検索する 相対パスで出力する (-printf \u0026ldquo;%P\\n\u0026rdquo;) 例: src ディレクトリからの相対パスで出力 $ find src -name \u0026#39;*.py\u0026#39; -printf \u0026#39;%P\\n\u0026#39;"},{url:"/p/iumn4xs/",title:"Vim のビジュアルモードの基本",date:"2008-01-15T00:00:00Z",body:"Vim のビジュアルモードの基本 ビジュアルモードの開始・終了 ビジュアルモードは、Vim においてテキストの範囲選択を行うためのモードです。 ノーマルモードで下記のようなコマンドを入力することでビジュアルモードに入ることができます。 入力 説明 v ビジュアルモード（文字単位） V ビジュアルラインモード（行単位） Ctrl-v ビジュアルブロックモード（矩形） ビジュアルモードを抜けてノーマルモードに戻るには、Esc を押すか、何かコマンドを実行します（d で削除するなど）。 コマンドを実行した場合は、選択した範囲に対してコマンドが適用されます。 ビジュアルモードの選択範囲を拡張する カーソル移動で拡張する ビジュアルモードに入った後で o を入力することで、カーソル位置を選択領域の先頭、末尾へ交互に移動することができます。 この状態でカーソルを動かすと、選択領域を自在に伸縮させることができます。 ルールに応じて拡張する ビジュアルモードに入った後で、下記のような操作を行うと、ルールに従って選択範囲を拡張することができます。 入力 説明 ip カーソル位置の段落全体を選択 ap カーソル位置の段落全体を選択（後続の空行も含めて選択） iw カーソル位置の単語全体を選択 aw カーソル位置の単語全体を選択（後続のスペースも含めて選択） i( 括弧 () に囲まれた領域を選択 a( 括弧 () に囲まれた領域を選択（括弧も含めて選択） i{ 括弧 {} に囲まれた領域を選択 a{ 括弧 {} に囲まれた領域を選択（括弧も含めて選択） i[ 括弧 [] に囲まれた領域を選択 a[ 括弧 [] に囲まれた領域を選択（括弧も含めて選択） i\u0026lt; 括弧 \u0026lt;\u0026gt; に囲まれた領域を選択 a\u0026lt; 括弧 \u0026lt;\u0026gt; に囲まれた領域を選択（括弧を含めて選択） 例えば、ビジュアルモードで段落全体（空行で区切られた連続する行）を一気に選択するには、その段落内にカーソルがある状態で ip と入力します。 ノーマルモードから段落全体を選択状態にするには vip と入力すればよいことになります（上のデモアニメを参照）。 「段落選択はビップ」と覚えます。 段落全体を操作対象とする ip は便利なので、是非覚えておきましょう。 他にも下記のようなシーケンスで使用することができます。 dip \u0026#34;段落全体を削除する （vip → d としても同様） yip \u0026#34;段落全体をヤンク（コピー）する （vip → y としても同様） ビジュアルモードに関するヘルプ ビジュアルモードで使用できるコマンドのヘルプを表示するには、そのコマンドのプレフィックスとして v_ を付けて :help コマンドを実行します（参考: Vim の help コマンドの使い方）。 ビジュアルモードの d コマンドのヘルプを表示 :help v_d 同様に、Ctrl-v で入ることのできるビジュアルブロックモードのコマンドのヘルプを表示するには、プレフィックスとして v_b_ を付けます。 ビジュアルブロックモードの r コマンドのヘルプを表示 :help v_b_r 複数行に同じテキストを挿入する 図: 複数行に同じ文字を挿入 Ctrl-v のビジュアルブロックモードで複数行を選択し、Shift-i でテキストを入力すると、その範囲に同じテキストを一気に挿入できます（2 行目以降には Esc を押した段階で挿入されます）。 上記の例では、Java コードの複数行をまとめてコメントアウトしています。 図: 複数行を矩形削除 逆に選択範囲を削除するには、ビジュアルモードで選択した後で、x あるいは d を入力するだけで OK です。"},{url:"/p/zneoq8d/",title:"Vim/NeoVim で設定ファイル (.vimrc) を開く、リロードする",date:"2007-12-26T00:00:00Z",body:"Vim/NeoVim で設定ファイル (.vimrc) を開く、リロードする 設定ファイルを開く（Vim の場合） Vim エディタから設定ファイル（.vimrc や .gvimrc）を開くには、下記のようにします（:e は :edit コマンドの省略系です）。 Vim の設定ファイルを開く（Linux/macOS の場合） :e ~/.vimrc :e ~/.gvimrc Vim の設定ファイルを開く（Windows の場合） :e ~/_vimrc :e ~/_gvimrc 設定ファイルの名前が Linux (.vimrc) と Windows (_vimrc) で微妙に異なるので注意しなければいけませんが、実は、これらの設定ファイル名（パス）は、$MYVIMRC、$MYGVIMRC という変数に格納されているので、次のように実行すれば、環境に依存しない指定方法で設定ファイルを開くことができます。 設定ファイルを開く（OS に依存しない方法） :e $MYVIMRC :e $MYGVIMRC 設定ファイルを開く（NeoVim の場合） NeoVim の設定ファイル (init.vim) を開くには次のようにします。 NeoVim の設定ファイルを開く（Linux/macOS の場合） :e ~/.config/nvim/init.vim NeoVim の設定ファイルを開く（Windows の場合） :e %USERPROFILE%\\AppData\\Local\\nvim\\init.vim 参考: Vim/NeoVim の設定ファイルのパスを確認する 設定ファイルをリロードする 設定ファイルを変更した後で、その内容を反映させるには下記のように :source コマンドでそのファイルを読み込みます。 :source $MYVIMRC :source $MYGVIMRC 参考 ショートカットキーで設定ファイル (.vimrc) を開く"},{url:"/p/7mabuvq/",title:"Vim/NeoVim の設定ファイルのパスを確認する",date:"2007-12-26T00:00:00Z",body:"Vim/NeoVim の設定ファイルのパスを確認する 設定ファイルのパスを調べる Vim や NeoVim の設定ファイル（やディレクトリ）のパスは、:echo コマンドを使って以下のように確認することができます。 Vim の場合: :echo $MYVIMRC 出力例: C:\\Users\\maku\\_vimrc :echo $MYGVIMRC 出力例: C:\\Users\\maku\\_gvimrc NeoVim の場合: :echo stdpath('config') 出力例: C:\\Users\\maku\\AppData\\Local\\nvim デフォルトのパス デフォルトでは、次のようなファイルパスに置かれた設定ファイルが読み込まれます。 Vim の場合 Linux/macOS: ~/.vimrc Windows: %USERPROFILE%/_vimrc（HOME 環境変数が設定されている場合は %HOME%/_vimrc） NeoVim の場合 Linux/macOS: ~/.config/nvim/init.vim Windows: %USERPROFILE%\\AppData\\Local\\nvim\\init.vim Vim/NeoVim の設定ファイルは基本的に自分で作成する必要があります。 設定ファイルの作成 $ touch ~/.config/nvim/init.vim version コマンド Vim の :version コマンドの出力の中央あたりを見ると、起動時に Vim がロードする設定ファイルの一覧を確認することができます。 VIM7.0 (Windows) の :version コマンドの出力（抜粋） ... システム vimrc: \u0026#34;$VIM\\vimrc\u0026#34; ユーザー vimrc: \u0026#34;$HOME\\_vimrc\u0026#34; 第2ユーザー vimrc: \u0026#34;$HOME\\vimfiles\\vimrc\u0026#34; 第3ユーザー vimrc: \u0026#34;$VIM\\_vimrc\u0026#34; ユーザー exrc: \u0026#34;$HOME\\_exrc\u0026#34; 第2ユーザー exrc: \u0026#34;$VIM\\_exrc\u0026#34; システム gvimrc: \u0026#34;$VIM\\gvimrc\u0026#34; ユーザー gvimrc: \u0026#34;$HOME\\_gvimrc\u0026#34; 第2ユーザー gvimrc: \u0026#34;$HOME\\vimfiles\\gvimrc\u0026#34; 第3ユーザー gvimrc: \u0026#34;$VIM\\_gvimrc\u0026#34; デフォルトファイル: \u0026#34;$VIMRUNTIME\\defaults.vim\u0026#34; システムメニュー: \u0026#34;$VIMRUNTIME\\menu.vim\u0026#34; ..."},{url:"/p/96itrdp/",title:"Vim で C/C++ の変数／マクロの定義位置にジャンプする",date:"2007-11-21T00:00:00Z",body:"Vim で C/C++ の変数／マクロの定義位置にジャンプする C/C++ の変数／マクロの定義位置にジャンプ 変数にカーソルを当てた状態で、以下のように入力すると、その変数の定義位置にジャンプすることができます。 コマンド 説明 gd ローカル変数の定義位置へジャンプ gD グローバル変数の定義位置へジャンプ 検索の精度はあまり高くありません。。。 C/C++ のマクロの定義を表示／定義位置へジャンプ C/C++ のマクロは次のような感じで定義されます。 #define BUF_SIZE 256 マクロを使用している場所から、そのマクロの定義（上記のコード）を調べるには、マクロ名にカーソルを当てた状態で次のように入力します。 #include されているファイルの内容も検索してくれます。 コマンド 説明 [D マクロの定義を表示（すべての定義を表示） [d マクロの定義を表示（最初の定義のみ） [Ctrl-d マクロの定義位置へジャンプ"},{url:"/p/9aqzppe/",title:"Python でファイルやディレクトリの名前を変更する (os.rename, os.renames)",date:"2007-11-09T00:00:00Z",body:"Python でファイルやディレクトリの名前を変更する (os.rename, os.renames) os.rename / os.renames 関数 os.rename 関数 を使用して、ファイルやディレクトリの名前を変更することができます。 次の例では、src.txt という名前のファイルを dst.txt という名前にリネームしています。 import os try: os.rename(\u0026#39;src.txt\u0026#39;, \u0026#39;dst.txt\u0026#39;) except Exception as e: print(\u0026#39;Error: {0}\u0026#39;.format(e), file=sys.stderr) os.rename 関数は次のようなエラーを発生させる可能性があります。 通常の使用時にも発生し得るものなので、エラーハンドル処理はちゃんと記述しておくことをお勧めします。 FileExistsError \u0026hellip; Windows で dst がすでに存在する場合。 IsADirectoryError \u0026hellip; Unix で、src がファイルで dst が（存在する）ディレクトリの場合。 NotADirectoryError \u0026hellip; Unix で、src がディレクトリで dst が（存在する）ファイルの場合。 OSError \u0026hellip; Unix で、src がディレクトリで dst が（存在する）ディレクトリで、かつ、dst が空でない場合。dst が空のディレクトリであれば、dst へのリネームは成功します（dst に src の中身が移動した状態になる）。 深いディレクトリ階層にファイルを移動させたいときは、os.renames 関数 を使うのが便利です。 os.renames 関数は、移動先のディレクトリが存在しない場合に自動的に作成してくれます。 os.renames(\u0026#34;src.txt\u0026#34;, \u0026#34;aaa/bbb/ccc/dst.txt\u0026#34;) 上記のようにすると、aaa/bbb/ccc というディレクトリ階層を作ってからファイルを移動してくれます。 os.renames ではなく、os.rename を使用した場合は、aaa/bbb/ccc というディレクトリが存在しないときにエラーになります。 例: ファイル名のプレフィックスに日付 (\u0026rsquo;-YYYYMMDD\u0026rsquo;) を付加する 下記のサンプルスクリプトは、ディレクトリ内のすべての .png ファイルのファイル名を変更し、拡張子の前に -20071109 のような日付を表す文字列を挿入します。 例えば、sample.png というファイル名は sample-20071109.png というファイル名に置換されます。 rename.py import glob import os import re import time time_str = time.strftime(\u0026#39;%Y%m%d\u0026#39;) for old_name in glob.iglob(\u0026#39;*.png\u0026#39;): new_name = re.sub(r\u0026#39;(\\.png)$\u0026#39;, \u0026#39;-\u0026#39; + time_str + r\u0026#39;\\1\u0026#39;, old_name) os.rename(old_name, new_name) 実行例（ディレクトリ内に a.png, b.png, c.png がある場合） $ ls a.png b.png c.png $ python rename.py $ ls a-20071109.png b-20071109.png c-20071109.png"},{url:"/p/i3ao6oc/",title:"Vim でカーソル位置にマークしてジャンプしてこれるようにする",date:"2007-10-07T00:00:00Z",body:"Vim でカーソル位置にマークしてジャンプしてこれるようにする Vim のマーク機能を使用すると、カーソル位置に a～z、あるいは A～Z のマークを付け、別の場所からそこへジャンプして来ることができるようになります。 マークを付ける m に続けて、1 文字のアルファベットを入力すると、現在のカーソル位置にマークを設定することができます。 入力 説明 ma カーソル位置をローカルマーク a として保存（a～z を使用可能） mA カーソル位置をグローバルマーク A として保存（A～Z を使用可能） マーク用のアルファベットとして 小文字の a～z を使用すると、カレントバッファのみに有効なローカルマーク として設定されます。 大文字の A～Z を使用すると、グローバルマーク（ファイルマーク） として設定されます。 ローカルマークはファイルごとに a～z を使用することができ、グローバルマークは全体で A～Z を共有することになります。 マークを設定した位置へジャンプする 入力 説明 `a ローカルマーク a へジャンプ 'a ローカルマーク a の行頭へジャンプ `A グローバルマーク A へジャンプ 'A グローバルマーク A の行頭へジャンプ ローカルマーク (a～z) を指定してジャンプするときは、カレントバッファで開いているファイルに設定されたローカルマークがジャンプ先のターゲットとなります。 一方、グローバルマーク (A～Z) は、マークしたファイルまで一緒に記録されており、Vim でどのファイルを編集中であっても、そのファイルにジャンプすることができます。 頻繁に使用するファイルに mA でグローバルマークを設定しておけば、'A でそのファイルをいつでも簡単に開けるようになります。 また、ジャンプ元とジャンプ先で行ったり来たりするために、下記のようなジャンプコマンドを使用することができます。 入力 説明 `` バッファ内のジャンプ元へジャンプ '' バッファ内のジャンプ元の行頭へジャンプ マークの一覧を表示する 現在設定されているローカルマークとグローバルマークの一覧を表示するには、次のコマンドを実行します。 :marks 応用: 最近開いていたファイルを開く 前回開いていたファイルは、グローバルマーク 0 を指定してジャンプすることで開けます。 \u0026#39;0 もとのファイルに戻ってきたい場合は、グローバルマーク 1 を指定すると戻ってこれます。 \u0026#39;1 もっと前に開いていたファイルも、:marks コマンドでグローバルマークの番号を確認してジャンプすることができます。 応用: マークを利用した編集 `a と入力するとローカルマーク a へ移動しますが、これと d コマンドを組み合わせて使用すれば、カーソル位置からローカルマーク a までのテキストを削除することができます。 ローカルマーク a までを削除する d`a"},{url:"/p/ym9pa88/",title:"Vim でウィンドウを分割する",date:"2007-10-05T00:00:00Z",body:"Vim でウィンドウを分割する Vim のウィンドウを分割すると、複数のファイルの内容を同時に表示しながら作業することができます（同一ファイル内の 2 か所を表示することもできます）。 ウィンドウを分割する 入力 説明 :sp[lit] 上下に分割（編集中のファイルを開く） Ctrl-w s としても OK :vs[plit] 左右に分割（編集中のファイルを開く） Ctrl-w v としても OK :new 上下に分割（空のファイルを開く） Ctrl-w n としても OK :vnew 左右に分割（空のファイルを開く） :sview [file] 閲覧用にファイルを開く :split → :view としても OK ウィンドウを閉じる 入力 説明 Ctrl-w c カレントウィンドウを閉じる (= :q) Ctrl-w q カレントウィンドウを閉じる Ctrl-w o カレントウィンドウ以外を閉じる ウィンドウを切り替える 入力 説明 Ctrl-w w 次のウィンドウへ移動（★最低限これだけ覚えておく） Ctrl-w h 左のウィンドウへ移動 Ctrl-w j 下のウィンドウへ移動 Ctrl-w k 上のウィンドウへ移動 Ctrl-w l 右のウィンドウへ移動 ウィンドウサイズの変更 入力 説明 \u0026lt;NUM\u0026gt;z 指定した行数にウィンドウサイズを変更 Ctrl-w = すべて同じサイズにする（★これが基本） Ctrl-w + ウィンドウを縦に大きくする Ctrl-w - ウィンドウを縦に小さくする Ctrl-w _ ウィンドウを縦に最大化 Ctrl-w \u0026gt; ウィンドウを横に大きくする Ctrl-w \u0026lt; ウィンドウを横に小さくする Ctrl-w | ウィンドウを横に最大化 ウィンドウサイズを大きくするときに、先に数値を入力すると、何行大きくするかを指定できます。 例: 現在のウィンドウを 3 行分大きくする 3 Ctrl-w +"},{url:"/p/kyj2izf/",title:"Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe)",date:"2007-04-10T00:00:00Z",body:"Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe) py2exe を使用すると、Python のスクリプトから Windows 上で実行可能な .exe ファイルを作成することができます。 基本的な使い方 変換対象のスクリプト hello.py と、変換設定ファイル setup.py を用意します。 hello.py print \u0026#39;Hello\u0026#39; setup.py from distutils.core import setup import py2exe setup(console=[\u0026#39;test.py\u0026#39;]) コマンドラインから、次のように実行すると、dist ディレクトリに hello.exe と、必要なライブラリが生成されます。 C:\\\u0026gt; python setup.py py2exe 配布するときは、dist ディレクトリの中身をすべてまとめて配布します。 （応用）wxPython などの GUI アプリケーションの場合 setup.py from distutils.core import setup import py2exe setup(windows=[\u0026#39;test.py\u0026#39;]) GUI を持つアプリケーションで、実行時にコマンドプロンプトを表示したくない場合は、setup メソッドのパラメータとして、console の代わりに windows を指定します。"},{url:"/p/r3m4k2h/",title:"Python でクラスの属性に名前でアクセスする (getattr, setattr)",date:"2007-03-31T00:00:00Z",body:"Python でクラスの属性に名前でアクセスする (getattr, setattr) Python でオブジェクトの属性にアクセスするには、通常 obj.属性名 という構文を使用しますが、次のような仕組みを使うと、属性名を文字列で指定してアクセスすることができます。 ビルトイン関数の getattr / setattr 関数 オブジェクトの __dict__ 属性 変数などに格納した属性名を使えるようになるため、属性名のリストをループ処理したり、あらかじめ属性名が決められない場合に後付けで属性を追加したりすることができます。 getattr/setattr 関数を使う方法 ビルトイン関数の getattr や setattr を使うと、任意のオブジェクトの属性に次のような形式でアクセスできます。 getattr(object, name [, default]) # 属性値の取得 setattr(object, name, value) # 属性値の設定 getattr 関数で指定した名前の属性が見つからない場合は、default 引数で指定した値が返されます。 default 引数が指定されていないと AttributeError が発生するので、できるだけ default 引数は指定しておくのが安全です。 次の例では、属性名のタプル (\u0026quot;name\u0026quot;, \u0026quot;age\u0026quot;) をループ処理して、対応する属性値を順番に取り出しています。 例: person オブジェクトの name 属性と age 属性を参照する class Person: def __init__(self, name: str, age: int): self.name = name self.age = age person = Person(name=\u0026#34;Maku\u0026#34;, age=14) for attr_name in (\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;): attr_val = getattr(person, attr_name) print(f\u0026#34;{attr_name} = {attr_val}\u0026#34;) 実行結果 name = Maku age = 14 __dict__ 属性を使用する方法 特殊属性の __dict__ でも属性値にアクセスできます。 この属性は辞書オブジェクトになっているので、__dict__[\u0026quot;属性名\u0026quot;] という形で参照します。 class MyClass: pass if __name__ == \u0026#34;__main__\u0026#34;: obj = MyClass() # 名前指定で属性値を設定する obj.__dict__[\u0026#34;foo\u0026#34;] = 100 print(obj.foo) # =\u0026gt; 100 # 名前指定で属性値を取得する obj.bar = 200 print(obj.__dict__[\u0026#34;bar\u0026#34;]) # =\u0026gt; 200"},{url:"/p/fdep5i7/",title:"Vim のヘルプコマンドの使い方 (:help, :helpgrep)",date:"2007-03-12T00:00:00Z",body:"Vim のヘルプコマンドの使い方 (:help, :helpgrep) ヘルプの起動／終了 Vim エディタから下記のコマンドを実行することで、ヘルプを起動・終了することができます。 :help \u0026hellip; ヘルプを起動する :q \u0026hellip; ヘルプを終了する ZZ \u0026hellip; ヘルプを終了する :help コマンドに渡すパラメータ :help コマンドの引数に特定のプレフィックスを付けたり、引数を引用符で囲むことで、異なるモードのコマンドのヘルプを見ることができます。 調べる項目 プレフィックスなど 例 Normal mode のキー入力 なし :help u Insert mode のキー入力 i_ :help i_CTRL-N, :help i_\u0026lt;Esc\u0026gt; Visual mode のキー入力 v_ :help v_u Command mode のキー入力 c_ :help c_\u0026lt;Del\u0026gt; ex コマンド : :help :quit オプション 'name' :help 'number' Vim の起動パラメータ - :help -t 特殊なキー入力は、CTRL-A、\u0026lt;Del\u0026gt;、\u0026lt;Esc\u0026gt; のように表現することができます（他のキーの表現方法は :help keycodes で確認できます）。 例: Ctrl-A（normal mode）のヘルプを表示する :help CTRL-A 例: Ctrl-A（insert mode）のヘルプを表示する :help i_CTRL-A 例: Vim の起動パラメータ -t のヘルプを表示する :help -t 例: number オプションのヘルプを見る :help \u0026#39;number\u0026#39; ヘルプファイルを grep する :helpgrep コマンドを使用すると、ヘルプファイル内を grep 検索することができます。 :helpgrep keyword 検索が終了すると、最初にキーワードにヒットした部分のヘルプが表示されるのですが、多くの場合は複数個所がヒットしているはずです。 検索後に :copen コマンドを実行すると、ヒットした行の一覧を表示し、そこから各ヒット位置へジャンプすることができます。 一覧表示のウィンドウは :cclose コマンドで閉じることができます。 ヘルプを起動した後の操作方法 :help コマンドでヘルプを起動した後は、下記の操作で項目間をジャンプすることができます。 Ctrl-] \u0026hellip; |:help| などのリンク先へジャンプ（タグジャンプ） Ctrl-t \u0026hellip; ジャンプ先から戻る Vim の doc ディレクトリ内に tags ファイルが用意されているので、Ctrl-] を使ってカーソル位置の単語に関連するヘルプページにジャンプすることができます。 GUI 版の gvim を使用している場合は、マウスで単語をダブルクリックしても同様にジャンプできます。 例えば、:help で表示されたページの usr_01.txt にカーソルを合わせて Ctrl-] を入力すると、usr_01.txt のヘルプページへジャンプできます。 ジャンプ元に戻って来たい場合は、Ctrl-t と入力します。"},{url:"/p/dsbsaq7/",title:"Python の対話型シェルで使える小技",date:"2007-03-07T00:00:00Z",body:"Python の対話型シェルで使える小技 Python のインタラクティブシェルで _（アンダースコア）を使用すると、 前回評価した値を参照することができます。 \u0026gt;\u0026gt;\u0026gt; [1, 2, 3] [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; len(_) 3"},{url:"/p/f4ckt29/",title:"Python でテキストファイルを読み込む (open, read, readline, readlines)",date:"2007-03-06T00:00:00Z",body:`Python でテキストファイルを読み込む (open, read, readline, readlines) テキストファイルを 1 行ずつ読み込む for-in ループで 1 行ずつ処理する方法 Python の open 関数で生成したファイルオブジェクトを for-in ループでイテレートすることで、テキストファイルを 1 行ずつ読み込むことができます。 Python 2.5 以降であれば、open するときに、with キーワードを使用することによって close 処理を自動化することができます。 ファイルを使用している区間が明示的になるので、この方法を使うのがオススメです。 テキストファイルを 1 行ずつ処理 with open(\u0026#39;input.txt\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: line = line.rstrip(\u0026#39;\\r\\n\u0026#39;) # 改行文字の削除 print(line) # 改行付きで出力 line には改行コードを含むので、line.rstrip('\\r\\n') で末尾の改行系文字を削除しています。 別の方法としては、line 内の改行はそのままで、print(line, end='') として出力時の改行を抑制する方法あります（Python 2.x の頃は print line, のように最後にカンマを付ければ改行抑制できました）。 with によってインデントが深くなってしまうのが嫌な場合は、下記のようにユーティリティ関数を用意しておくのもよいです。 def each_line(filename): with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as f: for line in f: yield line.rstrip(\u0026#39;\\r\\n\u0026#39;) for line in each_line(\u0026#39;input.txt\u0026#39;): print(line) readline で 1 行ずつ読み込む方法 readline メソッドを使うと、次の 1 行を文字列として取得することができます。 ファイルの最後まで読み込み終わると、readline は空文字列 (\u0026quot;\u0026quot;) を返します。 with open(\u0026#39;input.txt\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: while True: line = f.readline() if not line: break line = line.rstrip(\u0026#39;\\r\\n\u0026#39;) print(line) テキストファイルのすべての行を一度に読み込む それほど大きなテキストファイルでなければ、テキストファイル全体の内容を一度にメモリ上に読み出してしまうこともできます。 すべての行を文字列リストとして取得する readlines メソッドで、全ての行を文字列のリスト (list[str]) の形で取得できます。 各要素の末尾には改行が残っています（最終行には改行は含まれていない可能性があります）。 with open(\u0026#39;input.txt\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: lines = f.readlines() #=\u0026gt; list[str] print(lines) 実行結果 [\u0026#39;First line\\n\u0026#39;, \u0026#39;Second line\\n\u0026#39;, \u0026#39;Third line\u0026#39;] 次のようなリスト内包表記を使用して、各行の末尾の空白・改行を削除しながら、リスト形式で読み込むこともできます。 lines = [line.rstrip() for line in open(\u0026#39;input.txt\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;)] すべての行を連結して読み出す（改行文字は残す） read メソッドを使用すると、ファイルの内容すべてを 1 つの文字列変数に取得することができます。 with open(\u0026#39;input.txt\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() #=\u0026gt; str print(content) 実行結果 First line Second line Third line テキストファイルの内容を 1 文字ずつ処理する テキストファイルの内容を read メソッドで一度に読み込み、そのテキストをさらにイテレートすることで、テキストファイルの内容を 1 文字ずつ処理することができます。 input.txt ファイルの内容を 1 文字ずつ処理 with open(\u0026#39;input.txt\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() for ch in content: if ch == \u0026#39;\\n\u0026#39;: print(\u0026#39;改行発見！\u0026#39;) else: print(ch) 次のようなユーティリティメソッドを作っておけば、1 文字ずつ処理するコードを簡単に書けるようになります。 def iter_chars(filename): \u0026#34;\u0026#34;\u0026#34; Reads a text file char by char. \u0026#34;\u0026#34;\u0026#34; with open(filename, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() for ch in content: yield ch # 使用例 for ch in iter_chars(\u0026#39;input.txt\u0026#39;): print(\u0026#39;--\u0026gt; \u0026#39; + ch)`},{url:"/p/pyk3j2h/",title:"Python のコーディングスタイル",date:"2007-02-06T00:00:00Z",body:"Python のコーディングスタイル Python のコーディングスタイルは、PEP 8 や PEP 257 で指針が示されています。 PEP 8 \u0026ndash; Style Guide for Python Code PEP 257 \u0026ndash; Docstring Conventions このページでは主に上記の内容についてまとめていますが、実際に Python のプロジェクトにコーディングスタイルを適用するときは、Black などの Python フォーマッターを導入 することをおすすめします。 Black は、PEP 8 や PEP 257 と若干異なるところがありますが、理にかなったスタイルを強制的に適用してくれます。 命名規則 大文字／小文字 パッケージ名は小文字のみ（例: mypackage） クラス名は大文字で始める（例: MyClass） 関数、あるいは public メソッドは小文字（例: my_public_method） protected メソッドはアンダースコア 1 つで始める（例: _my_protected_method） private メソッドはアンダースコア 2 つで始める（例: __my_private_method） 定数名はすべて大文字（例: MY_CONSTANT） Python の name mangling の仕組みによって、アンダースコア 2 つで始まる名前は、クラス外部、あるいはサブクラスからその名前ではアクセスできないようになっています（正確には _ClassName__method という名前でアクセスできますが）。 この特性を利用して、private メソッドをアンダースコア 2 つで始めるようにするのがよい、ということです。 グローバル領域でのアンダースコアの使用について トップレベルに定義するクラスや関数で、モジュール（ファイル）内に閉じて外部に公開しないものは、プレフィックスとして 1 つのアンダースコアを付けます。 こうすることで、from M import * の形での自動インポートを防ぐことができます。 # モジュール内部で使う関数 def _parse_timestamp_with_tzinfo(value, tzinfo): \u0026#34;\u0026#34;\u0026#34;Parse timestamp with pluggable tzinfo options.\u0026#34;\u0026#34;\u0026#34; ...省略... # モジュール内部で使うクラス class _RetriesExceededError(Exception): \u0026#34;\u0026#34;\u0026#34;Internal exception used when the number of retries are exceeded.\u0026#34;\u0026#34;\u0026#34; pass モジュール名（ファイル）とパッケージ名（ディレクトリ）は、小文字のみで構成します。 モジュール名は、必要があれば単語の区切りのためにアンダースコアを含めてもよいとされていますが、パッケージ名（ディレクトリ）にはアンダースコアを含めてはいけません。 モジュール名にはアンダースコアを含んでもよい (OK: user.py, user_info.py) パッケージ名にはアンダースコアを含めない (OK: game/, NG: game_db/) これらのアンダースコアの扱いに関しては、PEP 0008 (Style Guide for Python Code) の Package and Module Names のセクションにおいて、下記のように記述されています。 Modules should have short, all-lowercase names. Underscores can be used in the module name if it improves readability. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged. その他の命名規則 独自の Exception クラスは、Exception を継承して作成し、サフィックスに Error を付ける（例: HogeHogeError）。 インスタンスメソッドの最初の引数名は self、クラスメソッドの最初の引数名は cls。 予約語と被る attribute 名を使用したい場合は、変に省略名を付けるのではなく、サフィックスとしてアンダースコアを付ける。ただし、class という名前に関しては、class_ でなく cls を用いる。 インデント／スペース インデントは スペース 4 文字。タブは使用しない。 python のコマンドライン引数で -t を指定すればスペースとタブが混在しているときに警告を表示してくれます（-tt オプションならエラーにしてくれる）。 一行は 79 文字（+ 改行）まで。ただし、ドキュメント (docstring) やコメント行は 72 文字まで。 デフォルトパラメータの = の前後にはスペースを入れない。 def complex(real, imag=0.0): return magic(r=real, i=imag) 長い行の途中で改行する場合は、次の行のインデントは前の行の開き括弧の位置に合わせる。演算子の後ろで改行する。 if (width == 0 and height == 0 and color == \u0026#39;red\u0026#39; and emphasis == \u0026#39;strong\u0026#39; or highlight \u0026gt; 100): クラス内のメソッド間は 1 行の空白行で区切る。トップレベルのクラス定義やメソッドは 2 行の空白行で区切る。 ▽このあたりのルールは有名どころの OSS のコードは ちゃんと守ってます が、ドキュメンテーションコメントの最初の動詞に三単現の s を付けない、というルールはあまり守られていないっぽいです。 開き括弧 (、[ の前後に空白スペースを入れない。 コロン :、セミコロン ; の前に空白スペースを入れない。 算術演算子の前後には空白スペースを入れる。 代入文が複数行に渡って続く場合に、= の位置を空白スペースで揃えたりしない。 エンコーディング形式 Python 3.0 からはエンコーディング形式に UTF-8 が推奨される。 コメントや docstring 以外の文字列リテラルで ASCII 意外のエンコーディング形式を使用する場合は、\\x, \\u, \\U でエスケープすること。 インポート import は次の順番で宣言し、各セクションを空白行で区切る。 標準ライブラリ サードパーティ・ライブラリ ローカル・ライブラリ import random import os import socket import dateutil.parser from dateutil.tz import tzutc import foo import foo.bar import は次のように 1 行ずつ分離して行う。 import os import sys ただし、次のような from -- import -- の形式は 1 行で書いても OK。 from subprocess import Popen, PIPE 上記の import 以降が複数行に渡るときは、次のように括弧で囲めば OK。 from botocore.compat import ( json, quote, zip_longest, urlsplit, urlunsplit, OrderedDict, six, urlparse, get_tzinfo_options, get_md5, MD5_AVAILABLE, HAS_CRT ) コメント コメントはセンテンスになっているべきで、最初の文字は大文字で始める。短いセンテンスは最後のピリオドを省略してよいが、通常はピリオドを省略してはならない。 コメントは基本的には英語で。 ブロックコメントの中のパラグラフは、1 つの # を含む行で区切ること。 インラインコメントの # は、ステートメントの後ろに 2 つ以上のスペースを置いてから記述すること。 モジュール（ファイル）や、クラス、関数などのドキュメンテーションコメントは、docstring 形式 での記述が推奨されています。下記記事を参考にしてください。 Docstring でドキュメンテーションコメントを記述する"},{url:"/p/etvrhdd/",title:"Vim のカーソル移動方法まとめ",date:"2007-01-30T00:00:00Z",body:"Vim のカーソル移動方法まとめ カーソル移動（左右） 入力 説明 h 1 文字左へ l 1 文字右へ 0 行頭へ $ 行末へ 5| カレント行の 5 文字目へ ^ 最初の表示可能な文字へ カーソル移動（行番号指定でジャンプ） 入力 説明 gg :1 1 行目へジャンプ 10gg 10G :10 10 行目へジャンプ G :$ 最終行へジャンプ :$-3 最終行より 3 行上へジャンプ :+10 カレント行から 10 行下へジャンプ 応用例: カーソル位置からファイルの最後までを削除 dG カーソル移動（画面内でジャンプ） 入力 説明 H 画面内の一番上にジャンプ（ホーム行） M 画面内の中央行にジャンプ L 画面内の一番下にジャンプ 3H 画面内の一番上から 3 行目にジャンプ 3L 画面内の一番下から 3 行目にジャンプ カーソル移動（ブロック単位でジャンプ） 入力 説明 w 次の単語の先頭へ W 次の単語の先頭へ（後続する記号も単語の一部とみなす） b 前の単語の先頭へ B 前の単語の先頭へ（後続する記号も単語の一部とみなす） e 単語の末尾へ E 単語の末尾へ（後続する記号も単語の一部とみなす） ( 現在の文の先頭へ ) 次の文の先頭へ { 現在の段落の先頭へ（空行で判断） } 次の段落の先頭へ（空行で判断） [[ 現在のセクションの先頭へ（行頭にある { を検索） ]] 次のセクションの先頭へ（行頭にある { を検索） w や b によるカーソル移動時に、どこまでを単語の切れ目と見なすかは、iskeyword オプションによって設定されています。 現在の設定値を見るには次のようにします。 :set iskeyword? 例えば、次のような値が設定されていることを確認できます。 iskeyword=@,48-57,_,192-255 @ は、C 言語の isalpha() が true を返す文字を示しています。 数値は ASCII コードを示しています。 小文字だけを単語に含むことができることを指定するには、次のようにします。 :set iskeyword=a-z 詳しくは、:help 'iskeyword' と :help 'isfname' で確認してください。 カーソル移動（特殊なジャンプ） 入力 説明 Enter 次の行の表示可能な先頭文字へ + 次の行の表示可能な先頭文字へ - 前の行の表示可能な先頭文字へ `` ジャンプ前のカーソル位置へ戻る '' ジャンプ前のカーソル位置へ戻る（表示可能な先頭文字へ） 対応する括弧にジャンプする 入力 説明 % 対になっている括弧へジャンプ ノーマルモードのとき、括弧の上にカーソルを合わせて % と入力することで、対応する括弧（()、{}、[] など）にジャンプすることができます。 括弧の上にカーソルを合わせなくても、カーソル行に対になっている括弧があれば、そこにジャンプすることができます。 このジャンプは、C 言語のコメントの /* と */ にも対応しており、さらに、プリプロセッサの #ifdef と #else、#endif 間のジャンプにも使用することができます。 デフォルトでは % によりマッチさせる括弧の種類は ()、{}、[] になっていますが、matchpairs オプションで変更することができます。 マッチさせる括弧の設定 (~/.vimrc) set matchpairs=(:),{:},[:]"},{url:"/p/gu9om5z/",title:"Vim の画面スクロール方法まとめ",date:"2007-01-30T00:00:00Z",body:"Vim の画面スクロール方法まとめ 画面スクロール操作 画面スクロール コマンド 説明 Ctrl-f 1 画面下へスクロール Ctrl-b 1 画面上へスクロール Ctrl-d 半画面下へスクロール、あるいは scroll オプションで指定された行数だけ下へスクロール Ctrl-u 半画面上へスクロール、あるいは scroll オプションで指定された行数だけ上へスクロール 表示位置を移動 下記の操作では、カーソル位置（行）をキープしたまま、画面の表示位置だけを移動させます。 コマンド 説明 z\u0026lt;CR\u0026gt; カレント行を画面上端へ ※1 zz カレント行を画面中央へ z. カレント行を画面中央へ（カーソルを最初の非空白文字へ） zb カレント行を画面下端へ z- カレント行を画面下端へ（カーソルを最初の非空白文字へ） z+ 画面下端を画面上端へ（これ使い道ある？） Ctrl-y 1 行下へスクロール Ctrl-e 1 行上へスクロール ※1 例えば、ソースコードの関数名を定義している行で、z [Enter] とすれば、その関数の定義が画面上端から表示されます。 z コマンドは、scrolloff オプションに 0 以外が設定されていると、その値によって移動後の表示位置が少々変わります。 z コマンドを実行するときに数値プレフィックスを付けると、カレント行とみなす行番号を指定することができます。 例: 30 行目が画面上端に表示されるように移動 30z[Enter] 画面スクロール量の設定 (scroll) Ctrl-d や Ctrl-u による画面スクロール行数は、scroll オプションで設定できます。 :set scroll=3 scroll オプションのデフォルトは 0 になっており、この場合だけは「画面に表示されている行数の半分だけスクロールする」という特殊な動きをします。 個人的には、一度に画面半分もスクロールされると脳がついていけないので、3 行くらいのスクロールに変更しておくことをオススメします。 ~/.vimrc au BufEnter * set scroll=3 画面上端、下端でのスクロール方法の設定 (scrolljump) 1 番上の行にカーソルがあるときに、さらに上へカーソルを移動させようとするとスクロールが発生します。 このときのスクロール行数は scrolljump オプションで指定することができます（デフォルトは 1）。 :set scrolljump=1 カーソルが画面の上端、下端まで行く前にスクロールを開始するには、scrolloff オプションで何行残してスクロールを開始するかを指定します（デフォルトは 0）。 この値を 0 以外にしておくと、作業効率が上がります。 :set scrolloff=5"},{url:"/p/g5xg2nc/",title:"Python で SQLite データベースを扱う",date:"2007-01-25T00:00:00Z",body:"Python で SQLite データベースを扱う Python は標準ライブラリとして sqlite3 モジュールを備えています。 SQLite3 データベースへの接続 sqlite3.connect 関数でデータベースファイルを指定すると、SQLite3 データベースへの接続（sqlite3.Connection オブジェクト）を取得できます。 指定したデータベースファイルが存在しない場合は新規に作成されます。 SQLite DB へ接続する import sqlite3 # Create a Connection object. conn = sqlite3.connect(\u0026#34;sample.db\u0026#34;) テーブルの作成 SQL コマンドを実行するには、Connection#cursor メソッドで sqlite3.Cursor オブジェクトを作成し、execute メソッドを呼び出します。 次の例では、データベースに新しい memo テーブルを作成しています。 memo テーブルを作成する # Create a Cursor object from Connection object. cur = conn.cursor() # Create a table cur.execute(\u0026#34;\u0026#34;\u0026#34;CREATE TABLE memo (date TEXT, title TEXT, body TEXT)\u0026#34;\u0026#34;\u0026#34;) テーブルにレコードを追加 テーブルを作成するのと同様に、Cursor#execute メソッドを使ってレコードを追加できます。 レコードを追加する # Insert a record cur.execute(\u0026#34;\u0026#34;\u0026#34;INSERT INTO memo VALUES(\u0026#39;2007-01-01\u0026#39;, \u0026#39;Memo1\u0026#39;, \u0026#39;Body1\u0026#39;)\u0026#34;\u0026#34;\u0026#34;) DB-API の ? 文字によるパラメータ置換（プレースホルダ機能）を使えば、各列の値を保持したタプルを渡すことによってレコードを追加することができます。 t = (\u0026#34;2007-01-01\u0026#34;, \u0026#34;Memo1\u0026#34;, \u0026#34;Body1\u0026#34;) cur.execute(\u0026#34;INSERT INTO memo VALUES(?,?,?)\u0026#34;, t) 例えば、下記のようにループでタプルを処理すれば、複数のレコードを一度に追加できます。 tuples = ( (\u0026#34;2007-01-01\u0026#34;, \u0026#34;Memo1\u0026#34;, \u0026#34;Body1\u0026#34;), (\u0026#34;2007-01-02\u0026#34;, \u0026#34;Memo2\u0026#34;, \u0026#34;Body2\u0026#34;), (\u0026#34;2007-01-03\u0026#34;, \u0026#34;Memo3\u0026#34;, \u0026#34;Body3\u0026#34;), ) for t in tuples: cur.execute(\u0026#34;INSERT INTO memo VALUES(?,?,?)\u0026#34;, t) 一方で、以下のように % を使って SQL クエリ文字列を作成してしまうと、SQL インジェクション攻撃に対して脆弱性が残ってしまう可能性が高いので、DB-API の ? を使ったパラメータ置換を行うようにしたほうが安全です。 危険な方法 t = (\u0026#34;2007-01-01\u0026#34;, \u0026#34;Memo1\u0026#34;, \u0026#34;Body1\u0026#34;) cur.execute(\u0026#34;INSERT INTO memo VALUES(\u0026#39;%s\u0026#39;,\u0026#39;%s\u0026#39;,\u0026#39;%s\u0026#39;)\u0026#34;, t) テーブルからレコードを検索 Cursor#execute メソッドで SELECT 文を実行した後は、Cursor オブジェクトをイテレータとして用いることにより、検索結果を順番に取得していくことができます。 レコード検索の基本（Cursor によるイテレート） sample.py cur = conn.cursor() cur.execute(\u0026#34;SELECT * FROM memo\u0026#34;) for row in cur: print(row) 実行結果 (u\u0026#34;2007-01-01\u0026#34;, u\u0026#34;Memo1\u0026#34;, u\u0026#34;Body1\u0026#34;) (u\u0026#34;2007-01-02\u0026#34;, u\u0026#34;Memo2\u0026#34;, u\u0026#34;Body2\u0026#34;) (u\u0026#34;2007-01-03\u0026#34;, u\u0026#34;Memo3\u0026#34;, u\u0026#34;Body3\u0026#34;) 検索結果をひとつだけ取得する (Cursor#fetchone()) Cursor#fetchone メソッドを使うと、検索結果を 1 つだけタプルで取得できます。 sample.py cur.execute(\u0026#34;SELECT * FROM memo\u0026#34;) result = cur.fetchone() print(result) 実行結果 (u\u0026#34;2007-01-01\u0026#34;, u\u0026#34;Memo1\u0026#34;, u\u0026#34;Body1\u0026#34;) 検索結果をリストで取得する (Cursor#fetchall()) Cursor オブジェクトを使って検索結果をイテレートするのではなく、リストデータとして一度に読み取ってしまうこともできます。 sample.py cur.execute(\u0026#34;SELECT * FROM memo\u0026#34;) results = cur.fetchall() print(results) 実行結果 [(u\u0026#34;2007-01-01\u0026#34;, u\u0026#34;Memo1\u0026#34;, u\u0026#34;Body1\u0026#34;), (u\u0026#34;2007-01-02\u0026#34;, u\u0026#34;Memo2\u0026#34;, u\u0026#34;Body2\u0026#34;), (u\u0026#34;2007-01-03\u0026#34;, u\u0026#34;Memo2\u0026#34;, u\u0026#34;Body3\u0026#34;)] 最大 n 個の検索結果をリストで取得する (Cursor#fetchmany(n)) Cursor#fetchmany メソッドを使用すると、指定した数だけレコードを取得できます。 sample.py cursor.execute(\u0026#34;SELECT * FROM memo\u0026#34;) print(cursor.fetchmany(2)) 実行結果 [(u\u0026#34;Title 1\u0026#34;, u\u0026#34;Body 1\u0026#34;), (u\u0026#34;Title 2\u0026#34;, u\u0026#34;Body 2\u0026#34;)]"},{url:"/p/f8v2npx/",title:"Vim の文字の置換方法まとめ (:s, :substitute)",date:"2007-01-08T00:00:00Z",body:"Vim の文字の置換方法まとめ (:s, :substitute) Vim の s (substitute) コマンドを使用すると、ファイル内の任意の範囲のテキストをまとめて置換することができます。 substitute コマンドの基本 substitute コマンドは、ノーマルモード中に下記のように入力して実行します。 :\u0026lt;行範囲\u0026gt; s/\u0026lt;置換前パターン\u0026gt;/\u0026lt;置換後パターン\u0026gt;/\u0026lt;フラグ\u0026gt; 指定した \u0026lt;行範囲\u0026gt; のテキストの中で、\u0026lt;置換前パターン\u0026gt; に一致する文字列を \u0026lt;置換後パターン\u0026gt; に置換します。 substitute コマンドは通常、上記のように省略系の s を使って実行します。 デフォルトでは、行内で最初に見つかった文字列だけを置換しますが、\u0026lt;フラグ\u0026gt; 部分に g（global フラグ）を指定することで、行内のすべての文字列を置換することができます。 :s/old/new/ \u0026#34;カレント行の文字列を置換（1 つだけ置換） :s/old/new/g \u0026#34;カレント行の文字列を置換（すべて置換） 上記のように \u0026lt;行範囲\u0026gt; の指定を省略した場合は、カレント行のみが置換対象になりますが、そのような使い方はまれでしょう。 ファイル内の全ての行を置換対象にしたい場合は、\u0026lt;行範囲\u0026gt; として % を指定します（1,$ としても同様）。 下記の例では、% の後ろにスペースを入れていますが、このスペースは省略することができます。 :% s/old/new/g \u0026#34;ファイル全体の文字列を置換 置換対象とする行範囲を指定したい時は、下記のように明示的に 開始行,終了行 を指定することもできますし、 :1,5 s/old/new/g \u0026#34;1～5行目までを置換対象にする :5,$ s/old/new/g \u0026#34;5行目～最終行までを置換対象にする Shift-V で行選択した状態から、:s/old/new/g と続けて実行することもできます（こちらの方法がオススメ）。 行選択した状態で : をタイプすると、コマンドの入力欄には下記のように表示されますが、これは行選した択範囲を操作対象としていることを示しています。 そのまま s/old/new/g と続けて入力すれば OK です。 :\u0026#39;\u0026lt;,\u0026#39;\u0026gt; 区切り文字にスラッシュ (/) 以外を使用する :s/old/new/g という置換コマンド自体がスラッシュを含んでいるため、置換対象の文字列にスラッシュが含まれる場合は、下記のようにバックスラッシュを使ったエスケープ処理が必要です（/ ではなく \\/ と入力する）。 例: /home/aaa を /home/bbb に置換する (1) :% s/\\/home\\/aaa/\\/home\\/bbb/g このようなエスケープ処理の煩雑さを防ぐために、substitute コマンドでは、セパレータ文字列としてスラッシュ以外のほとんどの種類の記号を使用できるようになっています。 下記の例は、セパレータ文字としてスラッシュの代わりにセミコロン (;) を使用しています。 例: /home/aaa を /home/bbb に置換する (2) :% s;/home/aaa;/home/bbb;g 正規表現を使ったパターン検索 \u0026lt;置換前パターン\u0026gt; の部分では正規表現を使用することができます。 ほとんどの特殊文字（+など）は、バックスラッシュをつけてエスケープしないといけないことに注意してください。 特殊文字 意味 \\a アルファベット文字に一致（[A-Za-z] と同様） \\A 非アルファベット文字に一致（[^A-Za-z] と同様） \\d 数字に一致（[0-9] と同様） \\D 非数字に一致（[^0-9] と同様） \\w 英数字に一致（[0-9A-Za-z] と同様） \\W 非英数字に一致（[^0-9A-Za-z] と同様） \\o 8進数に一致（[0-7] と同様） \\O 非8進数に一致（[^0-7] と同様） \\x 16進数に一致（[0-9A-Fa-f] と同様） \\X 非16進数に一致（[^0-9A-Fa-f] と同様） \\s スペースあるいはタブに一致 \\S スペースでもタブでもない文字に一致 \\t タブ文字に一致 . 任意の 1 文字に一致 \\+ 前の文字の 1 回以上の繰り返し（できるだけ多くの回数に一致） \\{-1,} 前の文字の 1 回以上の繰り返し（最も少ない回数に一致） * 前の文字の 0 回以上の繰り返し（できるだけ多くの回数に一致） \\{-} 前の文字の 0 回以上の繰り返し（最も少ない回数に一致） \\= 前の文字の 0 回、あるいは 1 回に一致（一般的な正規表現の ? に相当） \\\u0026lt; 単語の始まりに一致 \\\u0026gt; 単語の終わりに一致 [ 文字グループの開始 ] 文字グループの終了 ^ 行頭に一致（文字グループの先頭で使用すると「それ以外の文字」の意味になる） $ 行末に一致 パターン|パターン どちらかのパターンに一致 \\(パターン\\) 一致部分を後から参照するためにマークする ほとんどの文字はエスケープしなければいけないので、エスケープしなくてもよい特殊文字を覚えておくのがよいでしょう（.、*、[、]、^、$）。 逆にこれらを、その文字そのものとして扱う場合はエスケープが必要です（例: . という文字に一致させたいなら \\. と入力する）。 [:alnum:] や [:alpha:]、[:digit:] といった文字クラスも使用できますが、上記の特殊文字を覚えておけばほとんどのケースはカバーできます。 例: 単語の境界を意識して child を children に置換する :% s/\\\u0026lt;child\\\u0026gt;/children/g 例: ing で終わる単語を XXX に置換 :% s/\\\u0026lt;[^ ]*ing\\\u0026gt;/XXX/g 例: apple あるいは apples を banana に置換 :% s/apples\\=/banana/g 例: カレント行から 5 行分の行頭に引用記号 (\u0026gt; ) を挿入する :.,+4 s/^/\u0026gt; / 実際には、複数行の行頭に同じテキストを挿入したい場合は、上記のようなコマンドを使用するより、CTRL-V で行頭を矩形選択して SHIFT-I でテキスト入力する、という方法の方が手軽です。 パターンに一致した文字列を置換後パターンの中で参照する \u0026lt;置換前パターン\u0026gt; に実際に一致した文字列は、\u0026lt;置換後パターン\u0026gt; の中で \u0026amp; で参照することができます。 例: ファイル全体の google を google.com に置換する :% s/google/\u0026amp;.com/g 上記のように記述すると、\u0026amp; の部分に google と記述したのと同じ振る舞いをします。 上記の使い方はあまり意味がないかもしれませんが、次のように正規表現を使用してパターンマッチングさせた場合に効果を発揮します（実際に一致した文字列は \u0026amp; で参照するしかありません）。 例: 連続する数字を【】で囲む :% s/\\d\\+/【\u0026amp;】/g \u0026lt;置換前パターン\u0026gt; の中で、\\( と \\) でパターンをグループ化しておくと、後から実際に一致した文字列を \\1 で参照することができます。 複数のグループがある場合は、それぞれ \\1、\\2、\\3 のように参照します。 例: 「」で囲まれた部分を『』で囲みなおす :% s/「\\(.\\{-}\\)」/『\\1』/g \u0026lt;置換前パターン\u0026gt; の中の \\{-} という表現が分かりにくいかもしれませんが、これは直前の文字の 0 回以上の繰り返しで最短一致させる特殊表現です（* を使用すると最長一致になってしまいます）。 この表現を使用することで、下記のように行内にパターン一致する部分が複数登場する場合にもうまく置換できます。 置換前 「これは」 「サンプルの」 「テキストだよ」 置換後 『これは』 『サンプルの』 『テキストだよ』 大文字と小文字を変換する すべての行の Help を大文字の HELP に置換する :% s/help/\\U\u0026amp;/g \\U は、その後ろに続くテキストをすべて大文字に変換します。 \u0026amp; は \u0026lt;置換前パターン\u0026gt; に一致した実際のテキストを表すため、上記の場合は \u0026amp; は help になります。 それがすべて大文字に変換されるため、結果的に HELP に置換されることになります。 カレント行をすべて大文字／小文字に置換する :s/.*/\\U\u0026amp;/g \u0026#34;すべて大文字に置換 :s/.*/\\u\u0026amp;/g \u0026#34;すべて小文字に置換 SHIFT-V で行全体を選択して、U（あるいは u）とタイプしても同様のことを行えます。 パターンに一致する文字列を削除する s コマンドによる置換を行うときに、\u0026lt;置換後パターン\u0026gt; を空っぽにしておけば、\u0026lt;置換前パターン\u0026gt; に一致する文字列を削除することができます。 例: 行頭のスペースとタブをすべて削除する :% s/^\\s\\+// 例: 行末のスペースとタブをすべて削除する :% s/\\s\\+$// Vim では、正規表現の + は \\+ とエスケープしないといけないことに注意してください。 参考: 正規表現にマッチする行を削除する 1 単語ずつ確認しながら置換する c フラグを使う方法 置換時に \u0026lt;フラグ\u0026gt; として c（confirm フラグ）を指定すると、置換対象となる文字列に関して、1 つずつ置換するかどうかを確認しながら置換していくことができます。 置換対象となる文字列が順番にハイライトされていくので、置換するなら y、置換しないなら n を入力していきます。 :% s/old/new/gc 検索しながら繰り返しコマンドで置換する方法 ちょっとマニアックですが、こんな手順で置換を繰り返していくこともできます。 /\u0026lt;単語\u0026gt; で目的の単語を検索。 cw で単語を置き換え、ESC で insert モードを抜ける。 n で次の単語に移り、置換したい場合は . で置換する、という操作を繰り返す。 例: old という単語を検索しながら new に置き換えていく /old cwnew [Esc] nnnn . nnn . この操作例では、まず old というテキストを検索し、cw コマンドでその単語を new に置換しています。 あとは、n で次の置換対象までジャンプし、. で置換コマンドを再実行しています。 置換パターンの中で改行を扱う 置換パターンの中で改行文字を入力するには、CTRL-V → Enter（あるいは CTRL-Q → Enter）とタイプする必要があります。 コマンド入力欄には、^M と表示されて見えます。 例: aaa を bbb[改行]ccc に置換する :% s/aaa/bbb^Mccc/g 例: セミコロンの後ろに改行を挿入する :% s/;/;^M/g"},{url:"/p/ds9wgfz/",title:"Python で 2 つの dictionary をマージする (update)",date:"2005-10-20T00:00:00Z",body:"Python で 2 つの dictionary をマージする (update) dictionary に別の dictionary をマージする Python で 2 つの dictionary オブジェクトをマージするには dict.update() メソッドを使用します。 例えば、d1 という dictionary オブジェクトに、d2 という dictionary オブジェクトの内容をマージするには次のようにします。 \u0026gt;\u0026gt;\u0026gt; d1 = {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;org\u0026#39;: \u0026#39;d1\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d2 = {\u0026#39;three\u0026#39;: 3, \u0026#39;four\u0026#39;: 4, \u0026#39;org\u0026#39;: \u0026#39;d2\u0026#39;} \u0026gt;\u0026gt;\u0026gt; d1.update(d2) \u0026gt;\u0026gt;\u0026gt; d1 {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;org\u0026#39;: \u0026#39;d2\u0026#39;, \u0026#39;three\u0026#39;: 3, \u0026#39;four\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; d2 {\u0026#39;three\u0026#39;: 3, \u0026#39;four\u0026#39;: 4, \u0026#39;org\u0026#39;: \u0026#39;d2\u0026#39;} ポイント d1 の内容は変化しますが、d2 の内容は変化しません。 d1 と d2 に同じキーが存在する場合、d2 の値で上書きされます（上記の例では d1['org'] の値が上書きされています）。 もとの ditionary の内容を変化させずに新しい dictionary を作る 2 つの dictionary オブジェクト（dict1 と dict2）の内容を変化させずに内容をマージするには、** 演算子を使って、次のように新しい dictionary オブジェクトを作成します。 同じキーが存在する場合は、後ろに記述した dictionary の値が優先されます。 \u0026gt;\u0026gt;\u0026gt; dict1 = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; dict2 = {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; merged_dict = {**dict1, **dict2} \u0026gt;\u0026gt;\u0026gt; merged_dict {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; dict1 {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; dict2 {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4} 別の方法として、dict.copy() で dictionary オブジェクトをコピーしておいて、そこに対してマージするという方法もあります。 下記のコードは上記のコードと同じ結果になります。 \u0026gt;\u0026gt;\u0026gt; dict1 = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; dict2 = {\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 4} \u0026gt;\u0026gt;\u0026gt; merged_dict = dict1.copy() # dict1 のコピーを作成 \u0026gt;\u0026gt;\u0026gt; merged_dict.update(dict2) # dict2 をマージ 一般的に、** 演算子を使用した方が、コードをより簡潔に記述することができます。 この方法を用いれば、3 つ以上の dictionary をマージすることができ、マージの際に他のキーと値を追加することも可能です。 merged_dict = {**dict1, **dict2, **dict3, \u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;}"},{url:"/p/83e3wrw/",title:"Python で dictionary からキーや値のリストを作成する (keys, values, items)",date:"2005-10-20T00:00:00Z",body:"Python で dictionary からキーや値のリストを作成する (keys, values, items) Python の dictionary オブジェクトから、「キーのリスト」、「値のリスト」、「キーと値をペアにしたリスト」を取り出すには、それぞれ下記のようなメソッドを使用します。 d.keys() \u0026hellip; キーのリスト（戻り値は dict_keys オブジェクト） d.values() \u0026hellip; 値のリスト（戻り値は dict_values オブジェクト） d.items() \u0026hellip; (キー, 値) というタプルのリスト（戻り値は dict_items オブジェクト） \u0026gt;\u0026gt;\u0026gt; d = {\u0026#39;one\u0026#39;:1, \u0026#39;two\u0026#39;:2, \u0026#39;three\u0026#39;:3} \u0026gt;\u0026gt;\u0026gt; d.keys() dict_keys([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; d.values() dict_values([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; d.items() dict_items([(\u0026#39;one\u0026#39;, 1), (\u0026#39;two\u0026#39;, 2), (\u0026#39;three\u0026#39;, 3)]) [(\u0026#39;three\u0026#39;, 3), (\u0026#39;two\u0026#39;, 2), (\u0026#39;one\u0026#39;, 1)] それぞれの戻り値は dict_* という型のオブジェクトになっており、元のディクショナリ内のデータを参照するためのビューとして働きます。 このビューを介してディクショナリの内容を変更することはできませんが、ディクショナリ側の変更はビューに反映されます。 それぞれのオブジェクトは for ループでイテレートできます。 \u0026gt;\u0026gt;\u0026gt; for k in d.keys(): ... print(k) ... one two three \u0026gt;\u0026gt;\u0026gt; for k, v in d.items(): ... print(\u0026#34;{} -\u0026gt; {}\u0026#34;.format(k, v)) ... one -\u0026gt; 1 two -\u0026gt; 2 three -\u0026gt; 3"},{url:"/p/cmy6ar3/",title:"Python でキーのリストと値のリストを組み合わせて dictionary を生成する (zip)",date:"2005-10-20T00:00:00Z",body:"Python でキーのリストと値のリストを組み合わせて dictionary を生成する (zip) Python の zip 関数と dict 関数を組み合わせることで、「キーのリスト」と「値のリスト」から、新しい dictionary オブジェクトを生成することができます。 \u0026gt;\u0026gt;\u0026gt; keys = [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;] \u0026gt;\u0026gt;\u0026gt; values = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; d = dict(zip(keys, values)) \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3} 2 つのリストの要素数が異なる場合は、少ない方に合わせて生成されます。 \u0026gt;\u0026gt;\u0026gt; keys = [\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;] \u0026gt;\u0026gt;\u0026gt; values = [1, 2] \u0026gt;\u0026gt;\u0026gt; d = dict(zip(keys, values)) \u0026gt;\u0026gt;\u0026gt; d {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2}"},{url:"/memo/",title:"設計ノート",date:"0001-01-01T00:00:00Z",body:"設計ノート 設計ノウハウ／ベストプラクティス 不具合修正に対する向き合い方 動的品質よりも静的品質の向上に力を入れる プログラム内のコメントの書き方 (Javadoc ドキュメンテーションコメントの書き方） アプリ内の名前空間（Java のパッケージ階層）に迷った時のヒント PMD が警告するゴッドクラス (God Class) とは スケジューリングや見積りの段階では要求と設計要素のマトリクスで考える 可変オブジェクトのメンバ参照を返さない プロジェクト内での null の扱い方をルール化する 時制や単数形・複数形を考慮して命名する 肯定形で表現する 単位を明確にする 設定値の伝搬タイミングを意識する 型変換用メソッドは受け取り側クラスに作る 静的チェックのレベルはプロジェクト初期に厳しくする リソースは finally ブロックで閉じる コメント内で使える特殊キーワード（XXX、TODO など）を理解する よいツールの条件 アジャイルプラクティス ─ 無駄な汎用性ではなくシンプルな設計を (YAGNI) テスト テストピラミッドを意識してテストの自動化を進める 単体テスト、結合テスト、システムテスト、受入テストの関係を理解する Jenkins Jenkins CLI を使ってコマンドラインから Jenkins を操作する Groovy スクリプトで Jenkins サーバを制御する Groovy スクリプトで Jenkins 上のすべての Job を制御する Groovy スクリプトで Jenkins 上のすべてのスレーブを制御する Jenkins ジョブの設定 (config.xml) を確認する お試しインスタンスとして Jenkins サーバを起動する Jenkins サーバの設定ファイルの場所 Amazon EC2 に Jenkins をインストールする ツール make を使いこなすためのメモ CPD でコードクローンを発見する TFTP の使い方（TFTP によるファイル転送） Windows (MinGW) で GLUT を使用する Tera Term のマクロで特定の文字列を検出して処理を実行する faceswap/ffmpeg で動画の顔を好きな顔に置き換える 設計ドキュメント／設計ツール Enterprise Architect の図をシンプルにして Power Point に貼り付ける テキストからシーケンス図を作成するツール パッケージ管理 パッケージ管理ツールいろいろ Python のパッケージ管理ツール (pip) ネットワーク／暗号／セキュリティ IP によるインターネットワーキングの基礎（昔々2000年くらいに書いた記事） GENA と SSDP プロトコルを理解する 共通鍵暗号化方式と公開鍵暗号化方式 ダイナミック・ルーティング・プロトコルのメモ ルーティングテーブルの管理 NAT の種類のメモ VMware のネットワーク設定 雑多メモ PIC めもめも（電子工作、PIC アセンブラのメモ） 言語別の構文 - スクリプト言語の文法比較など 意外と知られていない XML 記述のルール XML の名前空間 デザインパターン ─ Visitor パターン ぐちゃぐちゃなコードしかないチーム／プロジェクトに配属された場合のポジティブ思考 ソフトウェア開発参考リンク Introduction to Software Engineering/Quality/Metrics いろんなソフトウェアメトリクス"}];function search(e){const t=searchData(e),n=createHtml(t);showResult(n),showResultCount(t.length,data.length)}function searchData(e){const t=[];if(e=e.trim(),e.length<1)return t;const n=new RegExp(e,"i");for(let s=0;s<data.length;++s){const o=data[s].body.search(n);o!=-1&&t.push([s,o,o+e.length])}return t}function createHtml(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n][0],o=e[n][1],i=e[n][2],a=data[s].url,r=data[s].title,c=data[s].body;t.push(createEntry(a,r,c,o,i))}return t.join("")}function createEntry(e,t,n,s,o){return'<div class="item"><a class="item_title" href="'+e+'">'+t+'</a><div class="item_excerpt">'+excerpt(n,s,o)+"</div></div>"}function excerpt(e,t,n){return[e.substring(t-30,t),"<b>",e.substring(t,n),"</b>",e.substring(n,n+200)].join("")}function showResult(e){const t=document.getElementById("result");t.innerHTML=e}function showResultCount(e,t){const n=document.getElementById("resultCount");n.innerHTML="<b>"+e+"</b> 件見つかりました（"+t+"件中）"}function searchWithHash(){const e=decodeURI(location.hash.substring(1));search(e);const t=document.getElementById("query");t.value!==e&&(t.value=e)}window.addEventListener("DOMContentLoaded",searchWithHash),window.addEventListener("hashchange",searchWithHash),window.addEventListener("load",()=>{const e=document.getElementById("query");e.focus()})</script><script>const SIDEBAR_HIDE_THRESHOLD=800,SIDEBAR_WIDTH=250,OFFSET=10;let w=window.innerWidth;w>=SIDEBAR_HIDE_THRESHOLD&&(w-=SIDEBAR_WIDTH),w-=OFFSET,w>=728?rakuten_size="728x200":w>=600?rakuten_size="600x200":w>=468?rakuten_size="468x160":w>=336?rakuten_size="336x280":w>=300?rakuten_size="300x250":w>=250?rakuten_size="250x250":rakuten_size="200x350",rakuten_design="slide",rakuten_affiliateId="1239b074.74af6526.1239b075.bc72ef6e",rakuten_items="ctsmatch",rakuten_genreId=0,rakuten_target="_blank",rakuten_theme="gray",rakuten_border="off",rakuten_auto_mode="on",rakuten_genre_title="off",rakuten_recommend="on",rakuten_txtColor="333333",rakuten_moverColor="30C030",rakuten_bgColor="FFFFFF",rakuten_captionColor="333333"</script><script src=https://xml.affiliate.rakuten.co.jp/widget/js/rakuten_widget.js></script></div><div class=l-withSidebar__sidebarRight><nav class=navigation><div class=navigation__header>カテゴリ一覧</div><ul><li><a class=navigation__item href=https://maku77.github.io/memo/>いろいろ</a><li><a class=navigation__item href=https://maku77.github.io/android/>Android</a><li><a class=navigation__item href=https://maku.blog/p/8t6hr3d/>Ansible</a><li><a class=navigation__item href=https://maku77.github.io/blender/>Blender</a><li><a class=navigation__item href=https://maku77.github.io/cpp/>C/C++</a><li><a class=navigation__item href=https://maku77.github.io/docker/>Docker</a><li><a class=navigation__item href=https://maku77.github.io/git/>Git</a><li><a class=navigation__item href=https://maku77.github.io/go/>Go言語</a><li><a class=navigation__item href=https://maku77.github.io/gradle/>Gradle</a><li><a class=navigation__item href=https://maku77.github.io/web/>HTML/CSS</a><li><a class=navigation__item href=https://maku77.github.io/hugo/>Hugo</a><li><a class=navigation__item href=https://maku77.github.io/java/>Java</a><li><a class=navigation__item href=https://maku77.github.io/js/>JavaScript</a><li><a class=navigation__item href=https://maku77.github.io/kotlin/>Kotlin</a><li><a class=navigation__item href=https://maku77.github.io/linux/>Linux/Shell</a><li><a class=navigation__item href=https://maku77.github.io/mac/>Mac</a><li><a class=navigation__item href=https://maku77.github.io/middleman/>Middleman</a><li><a class=navigation__item href=https://toushi.maku.blog/p/etedykx/>MetaTrader</a><li><a class=navigation__item href=https://maku77.github.io/nodejs/>Node.js</a><li><a class=navigation__item href=https://maku77.github.io/octave/>Octave</a><li><a class=navigation__item href=https://maku77.github.io/p4/>Perforce</a><li><a class=navigation__item href=https://maku77.github.io/perl/>Perl</a><li><a class=navigation__item href=https://maku77.github.io/php/>PHP</a><li><a class=navigation__item href=https://maku77.github.io/python/>Python</a><li><a class=navigation__item href=https://maku77.github.io/r/>R</a><li><a class=navigation__item href=https://maku77.github.io/ruby/>Ruby</a><li><a class=navigation__item href=https://maku77.github.io/rust/>Rust</a><li><a class=navigation__item href=https://maku77.github.io/sass/>Sass</a><li><a class=navigation__item href=https://maku77.github.io/sed/>sed/awk</a><li><a class=navigation__item href=https://maku77.github.io/sql/>SQL</a><li><a class=navigation__item href=https://maku77.github.io/tradestation/>トレードステーション</a><li><a class=navigation__item href=https://maku77.github.io/vagrant/>Vagrant</a><li><a class=navigation__item href=https://maku77.github.io/vba/>VBA</a><li><a class=navigation__item href=https://maku77.github.io/vim/>Vim</a><li><a class=navigation__item href=https://maku77.github.io/windows/>Windows</a></ul></nav><style>.codoc-support{display:inline-block;margin:0!important;padding:12px!important;width:200px!important;max-width:100%}.codoc-support .codoc-support-title{font-size:smaller!important;white-space:nowrap;margin-bottom:12px!important}.codoc-support .codoc-btn{width:160px!important}</style><script src=https://codoc.jp/js/cms.js data-css=black data-usercode=tp6ZPzTj3w defer></script><div id=codoc-entry-4gYwTntzzw class=codoc-entries data-without-body=1 data-support-button-text="（っ'-')╮シュッ🔴" data-show-like=0 data-show-about-codoc=0 data-show-powered-by=0 data-support-message=まくに投げ銭できます。></div></div></div><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("a[href^=http]");for(let n=0;n<e.length;++n){const t=e[n];if(t.href.startsWith("https://maku77.github.io"))continue;const s=t.getElementsByTagName("img");if(s.length>0)continue;const o=t.getElementsByTagName("svg");if(o.length>0)continue;t.classList.add("externalLinkIcon"),t.setAttribute("target","_blank"),t.setAttribute("rel","noopener")}})</script></body></html>