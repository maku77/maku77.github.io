<!doctype html><html lang=ja-jp><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>サイト内全文検索 - まくまく 天才まくまくノート ノート</title>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-X5962TDYXS"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-X5962TDYXS")</script><link rel=icon sizes="16x16 32x32 48x48 64x64" href=../assets/img/favicon/favicon.ico><link rel=icon sizes=192x192 href=../assets/img/favicon/192x192.png><link rel=apple-touch-icon href=../assets/img/favicon/180x180.png><meta name=twitter:card content="summary"><meta property="og:site_name" content="天才まくまくノート"><meta property="og:title" content="サイト内全文検索"><meta property="og:type" content="article"><meta property="og:url" content="https://maku77.github.io/search/"><meta property="og:locale" content="ja_JP"><meta property="og:image" content="https://maku77.github.io/img/site-logo.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta property="og:description" content="天才星人まくのメモ"><meta property="fb:app_id" content="447708168769292"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6317852277883092" crossorigin=anonymous></script><link rel=stylesheet href=../css/mm/all.min.03f769de5588c124e5b7baaab243e1f44bc5ccf6139987424d26c43c9491512f.css><link rel=stylesheet href=../css/all.min.a1be5c135c2d519bef49b4b099f4964b99ee878b81b26e9bac24497d0a73c31f.css><meta name=robots content="noindex,nofollow"></head><body><div class=l-pageHeader></div><div class=l-withSidebar><div class=l-withSidebar__sidebarLeft><style>#tocStub{position:-webkit-sticky;position:sticky;top:2rem;margin-top:2rem;line-height:1.5;max-height:calc(100vh - 4rem);overflow-y:auto;-webkit-overflow-scrolling:touch}#tocStub ul{font-size:.9em;list-style:none;padding:0;border-top:solid 1px #ccc}#tocStub li{border:solid 1px #ccc;border-right:none;margin-top:-1px}#tocStub a{color:#666;padding:.6em .3em .6em .5em;display:block;text-decoration:none;font-weight:400}.level-2{margin-left:.8em}.level-3{padding-left:1.6em}</style><div id=tocStub></div><script>document.addEventListener("DOMContentLoaded",()=>{function e(e){const t=document.createElement("a");return t.setAttribute("id",e),t}function t(t,n){n.parentNode.insertBefore(e(t),n)}function n(e,t,n){const s=document.createElement("li");return s.classList.add("level-"+e),s.innerHTML='<a href="#'+t+'">'+n+"</a>",s}function s(){const e=document.createElement("ul");return document.querySelectorAll("h2, h3").forEach((s,o)=>{const i="section-"+o;t(i,s);const a=s.tagName.charAt(1)-1;e.appendChild(n(a,i,s.textContent))}),e}document.getElementById("tocStub").appendChild(s())})</script></div><div class=l-withSidebar__content><style>#xSearchBox input{margin:.5em .8em;color:#ff1493;font-size:1.2em;font-weight:bolder}#xSearchBox input::-webkit-input-placeholder{color:pink}#result{margin:1em}.item_title{text-decoration:none;color:#36f;font-weight:bolder}.item_excerpt{background:#fff;margin:.5em 2em 1em;padding:.5em;border:dashed 1px #d3d3d3;font-size:smaller}.item_excerpt b{background:pink}</style><article style="padding:1rem 0"><h2>サイト内全文検索</h2><div id=xSearchBox><input id=query onkeyup='location.replace("#"+this.value)' size=15 autocomplete=off autofocus placeholder=検索ワード>
<span id=inputWord></span> <span id=resultCount></span></div><div id=result></div></article><script>const data=[{url:"/p/9qyei4z/",title:"Neovim設定例: ヤンク時に選択範囲をハイライト表示する (TextYankPost)",date:"2025-11-01T00:00:00+09:00",body:"Neovim設定例: ヤンク時に選択範囲をハイライト表示する (TextYankPost) Vim/Neovim の TextYankPost イベントは、「テキストをヤンク（コピー、カットなども含む）した直後」に自動的に呼ばれるイベントです。 例えば y（ヤンク）や d（削除）、c（変更）などレジスタにテキストが書き込まれる操作の後に自動で発火します。​ 下記の AutoCmd 設定例では、ヤンク操作の直後に選択範囲を一時的にハイライト表示するようにしています。 これにより、どの部分がヤンクされたかを視覚的に確認できるようになります。 ~/.config/nvim/init.lua -- 同じグループのオートコマンドが定義されている場合はクリアする local grp = vim.api.nvim_create_augroup(&#34;MyAutocmds&#34;, { clear = true }) -- ヤンク時に選択範囲をハイライト表示する vim.api.nvim_create_autocmd(&#34;TextYankPost&#34;, { group = grp, desc = &#34;Highlight on yank&#34;, callback = function() vim.highlight.on_yank({ timeout = 300 }) end, })"},{url:"/vim/",title:"Vim",date:"2025-11-01T00:00:00+09:00",body:"Vim 基本 ヘルプコマンドの使い方 (:help, :helpgrep) 移動 カーソルの移動方法まとめ Vim/Neovim の画面スクロール方法まとめ (scroll, scrolljump, scrolloff) カーソル位置にマークしてジャンプしてこれるようにする C/C++ の変数／マクロの定義位置にジャンプする 文字の削除方法まとめ（テキストオブジェクト） (d, delete) 文字の置換方法まとめ (:s, :substitute) ウィンドウを分割する アンドゥとリドゥ操作 (u, Ctrl-r, undolevels) ビジュアルモードの基本 (v, Shift-v, Ctrl-v) コマンドモード (:, /, ?) コマンドモードでのカーソル移動 (Ctrl-B, Ctrl-E, Ctrl-H, Ctrl-U) コマンドモードで入力補完する (Ctrl-D, Tab)) ex コマンドでの行範囲指定方法いろいろ 検索 Vim 内で grep を実行して見つかったファイルへジャンプする (:vimgrep, :grep) Vim でカレントファイル内の文字列を検索する (/, ?, *, #) Vim/Neovim で大文字と小文字を区別しないで検索する (ignorecase, \\c) Vim/Neovim の検索に関する設定 (ignorecase, smartcase, wrapscan, hlsearch, incsearch) コマンドライン Vim を起動するときに行番号や検索パターンを指定してファイルを開く (+n, +/pattern) サイレントバッチモードで ex スクリプトをファイルに適用する (-es) ファイル ファイルを開く ファイル名を指定してファイルを開く (:e, :edit, :view) カーソル位置の単語をファイル名としてファイルを開く (gf, Ctrl-w gf, Ctrl-w f) 編集中のファイルと拡張子だけが異なるファイルを開く (%&lt;)（Hello.cpp を編集中に Hello.h を開く） ディレクトリエクスプローラー (Explore) を使用してファイルを開く (:E, :Ve, :He) Vim でカレントディレクトリを Windows エクスプローラーで開く ファイルを保存する Vim のファイルの保存コマンド :w、:x の基本 Vim で指定した行範囲だけ別のファイルに保存する その他 Vim で別ファイルの内容や外部コマンドの出力を挿入する (:read) Vim でファイルのエンコーディング形式、改行コードを変更する (fenc, ff) Vim でスワップファイルからファイルを復旧する (:recover) Vim で 2 つのファイルの差分を取る・マージする (vimdiff, vim -d) 編集操作 Vim で挿入モード（インサートモード）のまま実行できる操作の一覧 Vim でXML/HTML の編集に便利なコマンド 文字の追加 Vim で補完機能を使用してテキストを入力する Vim で同じテキストを指定した回数だけ繰り返し挿入する Vim で複数行の行頭に同じテキストを挿入する Vim で上の行の文字、下の行の文字をコピーする (CTRL-Y, CTRL-E) 削除 Vim で空行（改行だけの行）を削除する Vim で行末の余分なスペースをまとめて削除する Vim で記号（引用符など）で囲まれた範囲のテキストを削除する Vim で正規表現にマッチする行を削除する 整形／変換 Vim で行を連結する (J, gJ) Vim で文字を入れ替える、行を入れ替える（スワップ操作） (xp, ddp) Vim/Neovim でインデント用のスペースを入力する（シフトコマンド） (&gt;&gt;, &lt;&lt;, Ctrl-T, Ctrl-D) Vim/Neovim で選択した範囲を自動インデントする (=) Vim/Neovim ですでに入力されているタブをスペースに変換する (:retab) Vim でテキストを中央寄せ／左寄せ／右寄せする Vim で大文字と小文字を変換する (U, u) Vim でカーソル位置の数字をインクリメント／デクリメントする (CTRL-A, CTRL-X) ソート Vim で行をソートして重複行を削除する (:sort u) Vim で行を逆順にソートする (:sort!) カット＆ペースト Vim で挿入モード、コマンドモードでの貼り付け Vim で最後にヤンクしたテキストを確実に貼り付ける Vim で切り取り＆貼り付け操作、レジスタの扱いについて理解する 応用操作 Vim 上でディレクトリツリーを表示する (NERDTree) Vim で折りたたみ機能 (folding) を使用する Vim で指定した行範囲を一時的に表示する Vim でキーボードマクロを記録して一連のキー入力を繰り返し実行する Vim で編集中のファイルを印刷する (:hardcopy) Vim で行情報を表示する Vim で外部の ex スクリプトを実行する プログラマ向け操作 Vim でプログラムの関数定義などにジャンプする（tags ファイルの利用） カーソル位置の単語に対して任意のコマンド（ヘルプなど）を実行する (keywordprg) Neovim を manpager として使用する（man ページを Neovim で表示する） インストール／環境 Neovim 用のプラグインマネージャー lazy.nvim をインストールする Vundle をインストールして Vim のプラグイン環境を作る Windows の右クリックメニューに「Vimで開く」を追加する Windows でファイルを開くときに既存の GVim 内のタブで開く Vim の設定 Lua Neovim カスタマイズのために Lua 言語をざっと理解する Neovim の設定ファイル (init.lua) を GitHub や Dropbox で管理する ファイル・ディレクトリに関する設定と操作 Vim/Neovim の設定ファイルのパスを確認する ($MYVIMRC) Vim/Neovim で設定ファイル (.vimrc, init.lua) を開く、リロードする 設定ファイルから別の設定ファイルを読み込む (source, dofile) Vimの設定: モードラインを使ってファイル単位で書式設定する (modeline) Vimの設定: バックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile) Vim/Neovim でウィンドウ（タブ）移動時にカレントディレクトリも自動で移動する (autochdir) キーマップ設定 キーマップの基本 (map, noremap) map、noremap 系コマンドで使用できる特殊キーの一覧 (key-notation, key-codes) 現在のキーマップの一覧を表示する (map) &lt;Leader&gt; キーを使ったキーコンビネーションを定義する (mapleader) キーマップ設定の例 ショートカットキーで設定ファイル (.vimrc, init.lua) を開く ショートカットキーで日時を挿入する ショートカットキーでタブを切り替える ショートカットキーでカレントディレクトリを Windows エクスプローラーや Mac の Finder で開く autocmd（自動コマンド）による設定 autocmd で自動コマンドを登録する autocmd 設定の例 Neovim設定例: ヤンク時に選択範囲をハイライト表示する (TextYankPost) 編集中のスクリプト（Ruby や Python など）をショートカットキーで実行する 開いたファイルがあるディレクトリをカレントディレクトリにする 表示の設定 Vim/Neovim で行番号を表示する (number) Vim/Neovim で80文字目に縦線を表示する (colorcolumn) Vim/Neovim で構文強調（シンタックスハイライト）を有効にする (syntax) Vim/Neovim でカーソル位置の行や列をハイライト表示する (cursorline, cursorcolumn) Vim/Neovim で GUI モード用のフォントを設定する (guifont) 制御文字（改行、タブ文字、行末のスペースなど）を表示する (list, listchars) Vim/Neovim で全角スペースを見えるように表示する Vim/Neovim でステータスラインの表示内容を設定する (laststatus, statusline) Vim で■や※などの記号が重なって表示される問題の解決 (ambiwidth) GVim 起動時のウィンドウの幅、高さを設定する (columns, lines) 入力に関する設定 Vim/Neovim で OS のクリップボードを連動させる (clipboard, unnamed, unnamedplus) Vim/Neovim でタブ文字に関する設定を行う (tabstop, expandtab, softtabstop) Vim/Neovim でインデント（シフトコマンド）を設定する (shiftwidth, shiftround) Vim/Neovim で自動インデントモードを有効にする (autoindent, smartindent, cindent) Vim/Neovim でビジュアルモード中に連続インデントできるようにする インサートモード中に Backspace キーや CTRL-W で文字を削除するときの振る舞いを変更する (backspace) Vim で省略形を用いたテキスト入力を行えるようにする (abbrevaite) Vim でスペルチェックを有効にする (spell) Vimの設定: Java や C/C++ のコメント記述に便利な formatoptions 設定 Vim のインサートモードを抜けるときに自動で IME をオフにする (macOS, Karabiner-Elements) Vim プログラミング（マクロ）／特殊用途 カーソル位置の文字の文字コードを表示する (:ascii) カーソル位置の単語を取得する (&lt;cword&gt;) （参考サイト）Learn Vimscript the Hard Way"},{url:"/p/pzakg36/",title:"Neovim の設定ファイル (init.lua) を GitHub や Dropbox で管理する",date:"2025-10-29T00:00:00+09:00",body:`Neovim の設定ファイル (init.lua) を GitHub や Dropbox で管理する Neovim の設定は ~/.config/nvim/init.lua ファイルに記述しますが、複数の PC で同じ設定を使いたい場合は、GitHub や Dropbox などのクラウドストレージを利用して設定ファイルを共有すると便利です。 ここでは、下記の 2 つの方法を紹介します。 シンボリックリンク／ジャンクションを使う方法 Neovim のランタイムパスを追加する方法 共有する設定ファイルは、下記のようなディレクトリ構造で Git 管理されているとします。 ~/gitwork/nvim-config/ ├── .git/ ├── init.lua └── lua/ ├── options.lua ├── keymaps.lua └── ... シンボリックリンク／ジャンクションを使う方法 特に問題がなければこの方法を使うのが簡単です。 Linux や macOS ではシンボリックリンク、Windows ではジャンクションの機能を使って、Neovim の設定ディレクトリ (~/.config/nvim) の実体を、GitHub や Dropbox で管理されているディレクトリに結び付けるだけです。 Neovim の設定ディレクトリのパスは、OS ごとに異なることに注意してください。 Linux/macOS: ~/.config/nvim Windows: %LOCALAPPDATA%\\nvim （通常は C:\\Users\\&lt;ユーザー名&gt;\\AppData\\Local\\nvim） まず、Neovim の設定ディレクトリ (~/.config/nvim) の中身を Git 管理された共有ディレクトリに移動して、元の ~/.config/nvim ディレクトリは削除しておきます。 その後、次のようにシンボリックリンク／ジャンクションとして ~/.config/nvim を作り直します。 Linux/macOS の場合 ─ シンボリックリンクの作成 ln -s ~/gitwork/nvim-config ~/.config/nvim Windows (PowerShell) の場合 ─ ジャンクションの作成 New-Item -ItemType Junction -Path $env:LOCALAPPDATA\\nvim -Target $env:USERPROFILE\\gitwork\\nvim-config これで、~/.config/nvim/init.lua にアクセスすると、実際には Git で管理されている ~/gitwork/nvim-config/init.lua ファイルが読み込まれるようになります。 ちなみに、Windows のディレクトリ・ジャンクションは管理者権限がなくても作成できます。 Neovim のランタイムパスを追加する方法 Neovim の require() 関数は、ランタイムパス (vim.opt.rtp) に登録されているディレクトリの lua サブディレクトリから Lua モジュールを検索するようになっています。 つまり、ランタイムパスに GitHub や Dropbox で管理されているディレクトリを追加すれば、そこにある Lua モジュールを require() で読み込めるようになります。 例えば、Neovim の設定ファイル ~/.config/nvim/init.lua に次のようなコードを追加します。 ~/.config/nvim/init.lua -- GitHub や Dropbox で管理されている設定ディレクトリをランタイムパスに追加し、 -- その lua ディレクトリ以下の .lua ファイルを require(&#34;モジュール名&#34;) で読み込めるようにする。 local shared_dir = vim.fn.expand(&#34;~/gitwork/nvim-config&#34;) vim.opt.rtp:append(shared_dir) -- 共有ディレクトリにあるルートの init.lua を読み込む dofile(shared_dir .. &#34;/init.lua&#34;) 最後の行で require(&quot;init&quot;) ではなく、dofile() を使ってパス指定で直接 init.lua を読み込んでいることに注意してください。 require() で読み込めるようになるのは、あくまでランタイムパスで登録したディレクトリにある lua ディレクトリ以下のモジュールなので、~/gitwork/nvim-config 直下の init.lua を読み込むには上記のように dofile() を使う必要があります（その先の init.lua 内からは、require(&quot;keymaps&quot;) のようにモジュールを読み込めます）。 ちなみに、Neovim のランタイムパスとして現在どのディレクトリが登録されているかは、Neovim 内で次のコマンドを実行すると確認できます。 init.lua からの require() がうまく動作しない場合などに確認してみてください。 :lua print(vim.inspect(vim.api.nvim_list_runtime_paths())) ☝️ プラグインを lazy.nvim で管理している場合の注意 lazy.nvim が読み込むプラグインの設定ファイルを ~/gitwork/nvim-config/lua/plugins 以下に配置する場合、lazy.nvim 内部のファイル監視機能がうまく動作しないことがあります。 その場合、lazy.nvim の performance.rtp.reset オプションを false 設定することで解決できたりします。 詳しくは lazy.nvim のドキュメントを参照してください。 require(&#34;lazy&#34;).setup({ spec = { { import = &#34;plugins&#34; }, }, install = { colorscheme = { &#34;habamax&#34; } }, checker = { enabled = true }, performance = { rtp = { -- runtimepath の設定をリセットせず、すべてのパスを保持 reset = false, }, }, }) ランタイムパスを追加する方法は柔軟性がありますが、上記のように設定がやや複雑になります。 できれば、前者のシンボリックリンク／ジャンクションを使う方法をお勧めします。`},{url:"/android/",title:"Android",date:"2025-10-10T00:00:00+09:00",body:"Android Android アプリや Android デバイスの開発に役立つかもしれないノートです。 Tools protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions) パーミッショングループの一覧を表示する (pm list permission-groups) ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk) ADB から Backup Manager を走らせる (bmgr backup, bmgr restore) Activity の情報を表示する (dumpsys activity) メモリの使用状況を確認する (dumpsys meminfo) APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages) APK ファイルに署名する (keytool, jarsigner) APK ファイルの署名を確認する (jarsigner, openssl) Dex 形式の Shared library (JAR) を作成する (dx) パフォーマンス Android アプリのパフォーマンス改善のためのチェックリスト dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認） Choreographer で FPS を計測する（Fps クラスの実装） Android アプリのパフォーマンス改善に使用できるツール ADB で描画パフォーマンス計測のデバッグ機能を有効にする Perfetto でシステム全体のパフォーマンスを計測する Traceview でプロファイル情報を表示する 旧）Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd) 旧）Systrace の画面が真っ白になるときの対応方法 エミュレーター Android エミュレーター内のサーバーに外部からアクセスする (adb forward) Android エミュレーターをコマンドラインから操作する (emulator, adb emu) 外部ツールとの連携 Golang で Android 上で動く CLI コマンドを作成する (go build) Ruby で adb コマンドの出力結果を処理する 解析／デバッグ／ADB コマンド APK のパッケージ依存関係やクラス依存関係を調べる (jdeps, dex2jar) APK ファイルを逆コンパイルする (apktool) APK ファイルの情報を表示する (aapt) ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast) ADB で指定したアプリを強制終了する (am force-stop) ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts) Androidメモ: ADB でディレクトリ内のファイルをすべて取得する (adb pull) ADB でスリープ状態に入る／スリープから抜ける Androidメモ: ADB で WakeLock を強制的に外す ADB からキー入力やテキスト入力を行う (input text, input keyevent) ADB で Android 端末のバージョンや API レベルを調べる (getprop) ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages) Androidメモ: TCP/IP で adb 接続する 旧）Android Studio で静的解析プラグインを使用する (CheckStyle, FindBugs) ANR の原因を突き止める Androidメモ: ADB 経由でスクリーンキャプチャを取得する (screencap) Androidメモ: StrictMode を有効にして望ましくない実装を検出する Androidメモ: StrictMode の違反メッセージを Toast で表示する (StrictModeToaster) Logcat Logcat のログ出力をフィルタする 旧）各種デバイスの ADB 接続: Nexus7 (2013) / Xperia Tablet Z / Sony Tablet S / SHARP IS03 旧）Androidメモ: Eclipse から Android SDK を使えるようにする (ADK) ビルド関連／Gradle Android Gradleメモ: Android アプリ用の Gradle スクリプトの基本 Android Gradleメモ: リソース名に正しくプレフィックスが付いているか確認する (resourcePrefix) Android Gradleメモ: Android の Gradle 関連ファイルまとめ Android Gradleメモ: BuildConfig クラスでアプリの動作を切り替える Android Gradleメモ: サブモジュールで使用する SDK バージョンを統一する Android Gradleメモ: 外部から提供された AAR ファイルを利用する Android Gradleメモ: APK ファイル名のサフィックスにバージョンを追加する Android Gradleメモ: Lint エラーが発生した場合もビルドを継続する (abortOnError) Android Gradleメモ: Android アプリが使用している依存ライブラリをツリー構造で表示する（dependencies/androidDependencies タスク） トラブルシューティング: JDK のバージョンが原因でビルドが失敗する場合 repo init でエラーが出る場合 ◆Gradle 全般の説明は → こちら Android Studio Androidメモ: AAR 形式のファイルを作成する/使用する Androidメモ: Android Studio に割り当てるメモリを増やす Androidメモ: Android Studio で新規ファイル作成時に Copyright を自動挿入する Androidメモ: Android Studio の便利なショートカット (1) コードの調査／メソッド間のジャンプ Androidメモ: Android Studio の便利なショートカット (2) ブックマーク Androidベンダー向けメモ（Android デバイス開発者向け） Androidベンダー向けメモ: LowMemoryKiller の仕組み Androidベンダー向けメモ: コンソールからキーの入出力を行う (getevent/sendevent) Androidベンダー向けメモ: root ユーザで adb 接続する Locale Androidベンダー向けメモ: Android の Locale を切り替える（Configuration 値の変更） Androidベンダー向けメモ: Android 4.0 でサポートされている Locale の一覧 Androidベンダー向けメモ: ART/Dalvik VM のバージョンを調べる (dalvikvm -showversion) Androidベンダー向けメモ: make 後の生成イメージが格納されるディレクトリを調べる ($ANDROID_PRODUCT_OUT) Androidベンダー向けメモ: インストールされた各 APK パッケージに割り当てられたユーザー ID を調べる (packages.xml) Androidベンダー向けメモ: Android デバイスのパーティション構成概要 (Nexus7) Androidベンダー向けメモ: android/build/core 以下の *.mk ファイルで定義されている関数 (define) のリスト Androidベンダー向けメモ: 製品にパッケージングする APK を指定する (PRODUCT_PACKAGES) Androidベンダー向けメモ: Make 変数でビルド範囲を制御する Androidベンダー向けメモ: システムプロパティのあれこれ Androidベンダー向けメモ: findmakefile コマンドで Android.mk のあるディレクトリを調べる Androidベンダー向けメモ: libhardware.so が hardware サポートライブラリをロードする仕組み Android アプリ実装／Framework／SDK Androidメモ: Jetpack Compose の宣言型 (declarative) の UI 定義とは？ Androidメモ: Activity の起動モードと起動フラグ（タスクとアフィニティ） Androidメモ: SpeechRecognizer で音声入力を実現する Androidメモ: リソース ID を示す変数やパラメータにアノテーションを付ける Androidメモ: AsyncTask による非同期処理と UI 更新処理 設定（Settings、SharedPreferences） Androidメモ: SharedPreferences でアプリの設定値を保存する Androidメモ: Preference フレームワークを使って設定画面を簡単に作成する Androidメモ: 画面消灯 (SCREEN OFF) までの時間を取得・設定する Androidメモ: 現在のスクリーンレイアウトサイズを取得する (Configuration) ファイル、I/O（入出力）、ネットワーク Androidメモ: ネットワーク情報を取得する (ConnectivityManager, NetworkInfo) Androidメモ: Androidの特殊ディレクトリの情報を取得する (android.os.Environment) Androidメモ: キーイベント (KeyEvent) を見やすく出力する Androidメモ: タッチイベントをハンドルする Androidメモ: Emulator での開発時にキーボードによるキー入力が長押しかどうかを判別する UI（描画） Androidメモ: 常に画面の最前面に表示されたままになる View を作る (TYPE_APPLICATION_OVERLAY) Androidメモ: Kotlin で OpenGL ES を使って 3D 表示するアプリを作る Androidメモ: RecyclerView の基本 Androidメモ: 任意の View をフォーカスする (requestFocus) Androidメモ: ソフトウェアキーボードを常に表示する (setSoftInputMode) Androidメモ: カスタムビューを作成する Androidメモ: カスタムビューの子ビューがフォーカスを得たことを検出する Androidメモ: カスタムビューでソフトウェア D-Pad を表示する Androidメモ: ValueAnimator でアニメーション処理に使用する値を計算する Androidメモ: ScrollView を一番下までスクロールさせる (fullScroll) Androidメモ: Canvas に複数行のテキストを描画する Androidメモ: Canvas への描画時にアンチエイリアスを有効にする (Paint#setAntiAlias) 数値／文字列 Androidメモ: 数値をある範囲内［min, max］に丸める (MathUtils.clamp) Service（サービス） Androidメモ: 同じプロセス内のサービスへバインドする (Local Bind) Androidメモ: 別プロセスのサービスへバインドする (Remote Bind) Androidメモ: サービスからコールバックできるようにする Native レイヤー実装 Android Nativeメモ: C++ 実装用のスマートポインタ (RefBase, sp) を使用する Android Nativeメモ: ネイティブサービスの実装 (1) Binder 関連のクラス Android Nativeメモ: ネイティブサービスの実装 (2) サービスの実装から利用まで Android Nativeメモ: ネイティブサービスの実装 (3) サービスのインタフェースを定義する Android Nativeメモ: ServiceManager に登録されたサービスを列挙する Android Nativeメモ: ネイティブライブラリ (.so) の展開先"},{url:"/p/jhsiowu/",title:"Androidトラブルシューティング: JDK のバージョンが原因でビルドが失敗する場合",date:"2025-10-10T00:00:00+09:00",body:"Androidトラブルシューティング: JDK のバージョンが原因でビルドが失敗する場合 Android プロジェクト内で特定の JDK バージョンによるビルドが要求されている場合、Android Studio 内の JBR (JetBrains Runtime) ではバージョンが合わず、ビルドが失敗することがあります。 そのような場合は、次のように JDK を追加することで解決できます。 Ctrl + Shift + A で &ldquo;Find Action&rdquo; を開く Download JDK... を選択 下のような画面が表示されるので JDK の Version などを指定してダウンロード 図: JDK の追加ダウンロード エラーメッセージの例 A problem occurred configuring project &#39;:app&#39;. &gt; Failed to calculate the value of task &#39;:app:compileDebugJavaWithJavac&#39; property &#39;javaCompiler&#39;. &gt; Cannot find a Java installation on your machine matching this tasks requirements: {languageVersion=17, vendor=any, implementation=vendor-specific} for WINDOWS on x86_64. &gt; No locally installed toolchains match and toolchain download repositories have not been configured. * Try: &gt; Learn more about toolchain auto-detection at https://docs.gradle.org/8.8/userguide/toolchains.html#sec:auto_detection. &gt; Learn more about toolchain repositories at https://docs.gradle.org/8.8/userguide/toolchains.html#sub:download_repositories. &gt; Run with --info or --debug option to get more log output. &gt; Run with --scan to get full insights. &gt; Get more help at https://help.gradle.org. * Exception is: org.gradle.api.ProjectConfigurationException: A problem occurred configuring project &#39;:app&#39;. at org.gradle.configuration.project.LifecycleProjectEvaluator.wrapException(LifecycleProjectEvaluator.java:84) at org.gradle.configuration.project.LifecycleProjectEvaluator.addConfigurationFailure(LifecycleProjectEvaluator.java:77) at org.gradle.configuration.project.LifecycleProjectEvaluator.access$500(LifecycleProjectEvaluator.java:55) Caused by: org.gradle.jvm.toolchain.internal.ToolchainDownloadFailedException: No locally installed toolchains match and toolchain download repositories have not been configured. at org.gradle.jvm.toolchain.internal.install.DefaultJavaToolchainProvisioningService.tryInstall(DefaultJavaToolchainProvisioningService.java:118) at org.gradle.jvm.toolchain.internal.JavaToolchainQueryService.downloadToolchain(JavaToolchainQueryService.java:178) ... 243 more"},{url:"/p/hfwenni/",title:"Neovim を manpager として使用する（man ページを Neovim で表示する）",date:"2025-09-23T00:00:00+09:00",body:"Neovim を manpager として使用する（man ページを Neovim で表示する） Neovim で man ページで開く Neovim は標準でファイルタイププラグインとして :Man を提供しており、man ページを Neovim 内で表示することができます。 Neovim 上で man ページを開く :Man {キーワード} 次のように MANPAGER 環境変数を設定しておくと、ターミナルから man コマンドを実行したときに、Neovim で開いてくれるようになります。 ~/.zshrc など export MANPAGER=&#34;nvim +Man!&#34; :Man の操作方法 man ページを Neovim で開いた後の操作方法は、less ベースの操作方法と同様ですが、:Man ならではの操作方法もあります。 下記あたりを覚えておくと便利です。 gO &hellip; 目次を開く（目次から Enter でジャンプできます） Shift-K / Ctrl-] &hellip; カーソル下のキーワードの man ページへジャンプ Ctrl-O &hellip; ジャンプ前の位置に戻る"},{url:"/gradle/",title:"Gradle",date:"2025-08-26T00:00:00+09:00",body:"Gradle インストールと設定／管理 Gradle をインストールする (macOS/Windows) Gradle のプロキシを設定する (gradle.properties) Gradle デーモンを使って gradle コマンドを高速化する (org.gradle.daemon) Gradle によるビルドのボトルネックを探す（プロファイリング） (--profile) Gradle の基本 Gradle のプロジェクトとタスクとアクションを理解する Gradle 実行時の 3 つのフェーズ (initialization, configuration, execution) Gradle のタスクを定義する (task) Gradle でデフォルトタスクを指定する (defaultTasks) Gradle でタスクの依存関係を表現する (dependsOn) Gradle のタスクに説明を付け、グルーピングする (description, group) 既存の Gradle タスクにアクションを追加する (doLast, doFirst) Gradle Wrapper スクリプト (gradlew) を作成する Gradle Wrapper スクリプト (gradlew) をサブプロジェクトから簡単に呼び出せるようにする Gradle で定義されているタスクの一覧を表示する (gradle tasks) Gradle で Java プロジェクトを扱う (java プラグイン) Gradle で Java プロジェクトをビルドする Gradle で Javadoc API ドキュメントを出力する Gradle で実行可能な JAR ファイルを作成する Gradle で Java プロジェクトをビルドするときのディレクトリ構成を変更する (sourceSets, buildDir) Gradle で独自の Maven リポジトリを使用する Gradle でマルチプロジェクトを扱う Gradle によるマルチプロジェクトの基本 (settings.gradle) Gradle のマルチプロジェクトで依存関係を扱う (dependencies, compile) Gradle でユニットテスト Gradle で JUnit によるユニットテストを実行する Gradle で TestNG によるユニットテストを実行する Gradle で JUnit のカバレッジレポートを生成する (JaCoCo) Gradle でユニットテストの結果をコンソールに詳しく表示する Gradle でユニットテストを並列実行する (test.forkEvery, test.maxParallelForks) Gradle で静的解析 (static analysis) Gradle で Checkstyle による静的解析を実行する Gradle で PMD による静的解析を実行する Gradle で I/O（ファイル入出力、環境変数、ユーザ入力） Gradle でファイルをコピー、リネームするためのタスクを作成する (type: Copy) Gradle のテンプレート機能を使ってファイルを生成する (type: Copy) Gradle でディレクトリ内のファイルを ZIP 圧縮する (type: Zip) Gradle でプロパティファイル (.properties) を読み込む Gradle のプロパティを環境変数 (ORG_GRADLE_PROJECT) で定義する Groovy スクリプト Groovy と Java の違い Groovy で assert を使用する Groovy でメソッドを定義する Groovy でクラスを定義する Groovy で文字列リテラルを扱う Groovy でリスト (List) を扱う Groovy でマップ (Map) を扱う Groovy のクロージャ Groovy でパスワードなどをユーザに入力させる (readPassword) 独自の Gradle プラグインを作成する Gradle プラグインを作成する (1) Plugin クラスの基本 Gradle プラグインを作成する (2) JAR へのパッケージング Android 開発での Gradle ビルド Android に関しては こちらを参照"},{url:"/p/bbkb63f/",title:"Vim のインサートモードを抜けるときに自動で IME をオフにする (macOS, Karabiner-Elements)",date:"2025-05-06T00:00:00+09:00",body:"Vim のインサートモードを抜けるときに自動で IME をオフにする (macOS, Karabiner-Elements) 何をするか？ Karabiner-Elements は、macOS 用のキーボードカスタマイズツールです。 ここでは、Vim のインサートモードを抜けるときに IME を自動でオフにするための、Karabiner-Elements の設定を紹介します。 Karabiner-Elements の設定 設定方法 Karabiner-Elements のメニューから、 Complex Modifications ⇨ Add your own rules を選択し、下記の JSON を貼り付ければ設定完了です。 vim-auto-ime-off.json { &#34;description&#34;: &#34;Vim - Auto IME Off&#34;, &#34;manipulators&#34;: [ { &#34;from&#34;: { &#34;key_code&#34;: &#34;escape&#34; }, &#34;to&#34;: [ { &#34;key_code&#34;: &#34;japanese_eisuu&#34; }, { &#34;key_code&#34;: &#34;escape&#34; } ], &#34;type&#34;: &#34;basic&#34; }, { &#34;from&#34;: { &#34;key_code&#34;: &#34;open_bracket&#34;, &#34;modifiers&#34;: { &#34;mandatory&#34;: [&#34;left_control&#34;] } }, &#34;to&#34;: [ { &#34;key_code&#34;: &#34;japanese_eisuu&#34; }, { &#34;key_code&#34;: &#34;escape&#34; } ], &#34;type&#34;: &#34;basic&#34; }, { &#34;from&#34;: { &#34;key_code&#34;: &#34;caps_lock&#34;, &#34;modifiers&#34;: { &#34;optional&#34;: [&#34;any&#34;] } }, &#34;to&#34;: [ { &#34;set_variable&#34;: { &#34;name&#34;: &#34;caps_lock_pressed&#34;, &#34;value&#34;: 1 } }, { &#34;key_code&#34;: &#34;caps_lock&#34;, &#34;lazy&#34;: true } ], &#34;to_after_key_up&#34;: [ { &#34;set_variable&#34;: { &#34;name&#34;: &#34;caps_lock_pressed&#34;, &#34;value&#34;: 0 } } ], &#34;type&#34;: &#34;basic&#34; }, { &#34;conditions&#34;: [ { &#34;name&#34;: &#34;caps_lock_pressed&#34;, &#34;type&#34;: &#34;variable_if&#34;, &#34;value&#34;: 1 } ], &#34;from&#34;: { &#34;key_code&#34;: &#34;open_bracket&#34; }, &#34;to&#34;: [ { &#34;key_code&#34;: &#34;japanese_eisuu&#34; }, { &#34;key_code&#34;: &#34;escape&#34; } ], &#34;type&#34;: &#34;basic&#34; } ] } 解説 この設定では、下記のようなインサートモードを抜けるキー入力があった場合に、すべて 英数 → ESC と入力したかのように振る舞うようにしています。 ESC Control + [ CapsLock + [ Mac では、英数 キーを押すと IME がオフ、かな キーを押すと IME がオンになります。 Karabiner-Elements では、英数 キーは japanese_eisuu という名前のキーコードとして定義されており、このキーコードを送ることで IME をオフにすることができます。 3 つ目の CapsLock + [ というキーコンビネーションについては注意が必要です。 CapsLock は修飾キーではなく通常のキーとして扱われてしまうので、特殊な処理方法で記述しなければいけません。 上記の設定例では、CapsLock キーを押している間だけ caps_lock_pressed という変数に 1 をセットして、この変数が 1 の状態で [ を押したときに 英数 → ESC と振る舞うようにしています。 あと、Karabiner-Elements でこれ以外にもキー設定を行っている場合は、from プロパティがコンフリクトしていないかの注意も必要です。 Karabiner-Elements の仕様として、同じキーコンビネーションを表す from プロパティが見つかると、最初に見つかったものが優先して使われます。 どうしても設定が重複してしまう場合は、設定自体をうまくマージするか、コンフリクト部分だけを抽出してマージした設定を新しく作り、その設定を最初に読み込むようにします（マージ済みの設定を優先的に使うようにします）。 参考リンク 左手小指だけで IME 操作｜まくろぐ"},{url:"/python/",title:"Python",date:"2025-04-19T00:00:00+09:00",body:"Python はじめに／基本 コーディングスタイル／ドキュメンテーション コーディングスタイル Python のコーディングスタイル Visual Studio Code で Python 用の Linter ＆フォーマッターの Ruff を使う Visual Studio Code で Python 用のフォーマッター (Black) を使う ドキュメンテーション ドキュメンテーションコメント (docstring) を記述する Windows で pydoc コマンドを使用できるようにする 関数やクラスのソースコードを確認する (insepct) 開発ツール／デバッグ／ユニットテスト Python プロジェクト用の爆速パッケージマネージャ uv を導入する 実行環境／仮想環境 python コマンドのバージョンを切り替える (pyenv, py) Python の実行環境を venv で切り替える（仮想環境） Python の実行環境を virtualenv で切り替える（仮想環境）（Python 3.2 以前） パッケージ Python のパッケージ管理ツール (pip) の使い方 Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe) 対話型シェル Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP) Python の対話型シェルで使える小技 テスト Python でユニットテストを記述する (unittest) パフォーマンス Python コードの実行時間を計測する (datetime.now) python コマンド／実行環境 python コマンドでワンライナーを実行する Python スクリプトの中で Python のバージョンを確認する (sys.version) 拡張子に関連付けられたアプリケーションでファイルを開く (os.system) Python の最大再帰数を調べる／変更する Python から外部プログラムを起動する (subprocess.run) 環境変数 環境変数を参照する (os.getenv, os.environ) .env ファイルで環境変数を設定する (python-dotenv) 構文 モジュール / パッケージ Python でモジュールやパッケージを作成する Python でモジュールを import する方法のまとめ import 時のモジュールの検索パスを調べる (sys.path) 型 / 変数 Python の型アノテーションのまとめ Python の型の一覧、ある値の型を調べる (type) Python で定数を定義する (typing.Final) 制御構文 Python の if 構文 Python の switch 構文 range による数値のループ処理いろいろ 三項演算子（条件演算子）を扱う 全てが真 (all)、少なくとも一つが真 (any) かどうか調べる メソッド / 関数 Python の関数をキーワード引数を使って呼び出す Python の関数で可変長引数を扱う (*args, **kwargs) クラス クラス定義の基本 (class) オブジェクトを print 関数で出力できるようにする (__str__) オブジェクトの属性に名前でアクセスする (getattr, setattr) dataclass デコレーターで簡単にデータクラスを定義する 型 数値 2進数、8進数、16進数の数値リテラル 数値と文字（文字列）を変換する (chr, ord, int, hex, oct, bin) 整数の割り算の結果を整数 or 少数点数で取得する 小数点以下を四捨五入する／切り捨てる／切り上げる 独自オブジェクトの配列から最小値、最大値を求める (min_by/max_by) リスト要素の合計値を求める (sum) ランダムな数値（乱数）を生成する (randrange, randint, random, uniform) 階乗を求める (math.factorial) 順列の数 (nPr) を求める 組み合わせの数 (nCr) を求める 文字列 Python の文字列リテラルいろいろ 文字列の中で変数を展開する（書式文字列によるフォーマット） (str#format, % 演算子) 同じ文字列を繰り返した文字列を作成する 文字列の長さを調べる (len) 文字列がある文字列で始まっている／終わっているかを調べる 文字列が正規表現に完全一致するか調べる (re.fullmatch) 文字列内の部分文字列を検索する／抽出する（正規表現） 文字列を置換する (str.replace, re.sub, re.subn) 分割 文字列をデリミタで分割する (split) 文字列を改行で分割して 1 行ずつのリストにする (splitlines) 文字列を 1 文字ずつに分割してリストにする リスト内の要素を結合して文字列にする (join) 文字列を逆順にする（反転させる） ランダムな文字列を生成する (random.choice) Python で UUID を生成する (uuid.uuid4) JSON JSON テキスト ⇔ Python オブジェクトの相互変換 (json.loads, json.dumps) シーケンス (Lists and Tuples) リストとタプルの違い リストとタプルの生成 リストやタプルをサイズを指定して作成する (［］＊ N) 連番からなるリストを生成する (range) リストに要素を追加する／リストを結合する (append, extend, +) リスト／タプルをループで処理する リスト／タプルのサイズを取得する (len) リスト／タプル内の要素をランダムで取得する (random.choice, random.choices, random.sample) リストを昇順ソート／降順ソートする (list.sort/sorted) リストをシャッフルする (random.shuffle) リストから特定の値を持つ要素を削除する (list.remove) リストをフィルタして条件に一致する要素を抽出する (filter) リスト内の特定の値を持つ要素の数を数える (list.count) リスト内の条件に一致する要素の数を数える リスト内の要素をまとめて変更する (map) 二次元配列を作成する 二次元配列をソートする 2 つのリストに重複する要素を抽出する（set と &amp;） 辞書・ディクショナリ (Dictionary) dictionary（辞書）チートシート dictionary（辞書）の基本 dictionary オブジェクトを作成する ({}, dict) dictionary の要素を参照・変更する ([], get) dictionary の要素数を取得する (len) dictionary に指定したキーが存在するか調べる (in) dictionary の要素を削除する (del) dictionary をループ処理する (items, enumerate) dictionary の要素をソートして出力する (sorted) キーでソートしてループ（昇順/降順） 値でソートしてループ（昇順/降順） キーのリストと値のリストを組み合わせて dictionary を生成する (zip) dictionary からキーや値のリストを作成する (keys, values, items) 2 つの dictionary をマージする (update) dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault) dictionary の内部的な要素順序を変更する (dict, OrderedDictionary) セット (Set) set オブジェクトの基本 set オブジェクトで集合演算を行う 入出力 (I/O) コマンドライン引数／標準入力／標準エラー出力 コマンドライン引数 コマンドライン引数を扱う (sys.argv) argparse モジュールでコマンライン引数を扱う キーボードからのユーザ入力を取得する (input, getpass) print print 関数の改行を抑制する print 関数に複数のパラメータを渡した時の接続文字を変更する 標準入力から読み込む (sys.stdin, fileinput) 標準エラー出力へ出力する (sys.stderr) 任意のオブジェクトを見やすく整形して出力する (pprint) パス 実行中のスクリプトのファイル名やパスを取得する パスからファイル名だけを取り出す (basename) パスを結合する (join) パスを指定したディレクトリからの相対パスに変換する (os.path.relpath) ファイル／ディレクトリ 列挙 ディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob) 指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob) コピー／移動／リネーム ファイル／ディレクトリの名前を変更する (os.rename, os.renames) ファイル／ディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move) 作成／削除 ディレクトリを作成する (os.mkdir, os.makedirs) ディレクトリを削除する (os.rmdir) ファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir) Python スクリプトが格納されているディレクトリのパスを取得する テンポラリファイル／ディレクトリを作成する (tempfile) ファイルの読み書き 基本的なファイル読み書き テキストファイルを読み込む (open, read, readline, readlines) テキストファイルを書き込む (open, write, writelines) CSV/TSV CSV ファイルや TSV ファイルを読み込む (csv.reader) JSON ファイル JSON 形式のテキストファイルを読み書きする (json.load, json.dump) Python のワンライナーコマンドで JSON ファイルを整形する (json.tool) YAML ファイル YAML ファイルを扱う HTML ファイル HTML をパースする (HTMLParser) HTML をパースする (BeautifulSoup) XML ファイル XML を扱う方法いろいろ XML をパースする (ElementTree) XML をパースする (minidom) XPath を使って XML 要素を参照する (ElementTree) XML を構築する (minidom) Excel ファイル Excel ファイルを読み込む (xlrd) ZIP/JAR ファイル ZIP/JAR ファイルの内容を読み込む (zipfile) ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive) その他のファイル、応用サンプル HTML ファイルや Markdown ファイルやプレーンテキストに変換する (unstructured) Java や C/C++ のコード中のコメントを削除する 複数ファイルの文字列をまとめて置換する (glob, re) 複数ファイルをまとめて grep する Web / HTTP URL URL 文字列を各パートに分割する (urllib.parse.urlparse) 文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode) HTTP リクエスト Python で HTTP を扱う方法いろいろ urllib.request urllib による HTTP 通信 (1) GET/POST リクエスト (urllib.request.urlopen) urllib による HTTP 通信 (2) プロキシ経由でアクセスする ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve) urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler) urllib による HTTP 通信 (5) ヘッダを付けてリクエストする urllib による HTTP 通信 (6) レスポンスヘッダを取得する requests パッケージのチートシート requests パッケージによる HTTP 通信の例 サンプルコード Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する HTTP サーバー / Web API サーバー Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) Python の FastAPI フレームワークで Web API を実装する 未分類 ハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (hashlib) データベース / SQL Python で SQLite データベースを使用する 日時（日付／時刻） Python で日時（日付／時刻）の情報を扱う (datetime, date, time, timedelta) 現在時刻から YYYY-MM-DD のような日付文字列を生成する (strftime) 画像処理 scikit-image scikit-image で画像処理 scikit-image の data パッケージに含まれるテスト画像を使用する OpenCV OpenCV: 画像を閾値で二値化（白黒画像化）する (cv2.threshold) keras MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists) データ分析 (NumPy / pandas / Matplotlib / scikit-learn) 共通 NumPy / pandas / Matplotlib の概要とインストール NumPy NumPy 配列 (ndarray) の基本 NumPy 配列 (ndarray) の作成方法まとめ pandas pandas でラベル付き 1 次元データを扱う (Series) pandas でラベル付き 2 次元データを扱う (DataFrame) pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) pandas で CSV/TSV ファイルを出力する (pd.to_csv) pandas で DataFrame をループ処理する (iterrows, items) pandas チートシート DataFrame のデータ抽出方法まとめ 具体例 DataFrame のデータ加工方法まとめ DataFrame の欠損値 (NaN) の扱い方まとめ pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix) pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes) pandas の DataFrame のカラムのデータ型を変更する (df.astype) Python データ分析: カテゴリデータを扱う Matplotlib Matplotlib の Axes、Figure、pyplot の関係を理解する Matplotlib によるプロットの例（散布図） scikit-learn scikit-learn 組み込みのデータセットを扱う (sklearn.dataset) wxPython 基本ウィンドウとレイアウト wxPython によるウィンドウ表示の基本 wxPython - Dialog（ダイアログ） wxPython - Frame（フレーム） wxPython - Layout（レイアウト） wxPython - SplitterWindow（スプリッターウィンドウ） 各種コンポーネント wxPython - Button（ボタン） wxPython - CheckBox（チェックボックス） wxPython - CheckListBox（チェック付きリストボックス） wxPython - Choice（プルダウンボックス） wxPython - ComboBox（コンボボックス） wxPython - Gauge（プログレスバー） wxPython - Grid（グリッド） wxPython - HtmlWindow（HTML ウィンドウ） wxPython - ListBox（リストボックス） wxPython - Menu（メニュー） wxPython - RadioButton（ラジオボタン） wxPython - Slider（スライダー） wxPython - SpinCtrl（スピンコントロール） wxPython - StaticText（変更不可のラベル） wxPytnon - StatusBar（ステータスバー） wxPython - TextCtrl（テキスト入力用） その他の wxPython メモ wxPython のイベントハンドラを理解する wxPython アプリケーションのエラー出力方法を理解する wxPython によるグラフィックス処理を理解する wxPython でマウスカーソル関連のイベントを処理する wxPython のコンポーネントをドラッグで動かせるようにする wxPython 関連コラム コラム Python 開発の歴史 Python のインデントによる構造化に慣れる Python のリスト内包表記に慣れる"},{url:"/p/rx77njz/",title:"Python の型アノテーションのまとめ",date:"2025-04-19T00:00:00+09:00",body:"Python の型アノテーションのまとめ Python で変数や関数の戻り値に型アノテーションを付ける方法のまとめです。 Visual Studio Code 上で型チェックを有効にするには、Mypy 拡張 などの type checker をインストールしておく必要があります。 組み込み型 (Built-in types) 基本型 下記は基本型の変数に型アノテーションを付ける例です。 count: int = 1 average: float = 1.0 is_ok: bool = True label: str = &#34;Hello&#34; data: bytes = b&#34;Hello&#34; このように初期値を与える場合は、型アノテーションを省略可能です。 count = 1 average = 1.0 is_ok = True label = &#34;Hello&#34; data = b&#34;Hello&#34; コレクション Python 3.9 以降では、コレクションの型を示すための list、set、dict、tuple を使用できます。 何もインポートせずに使用することができます。 ☝️ 古い書き方（Python 3.8 以前） Python 3.8 以前は typing モジュールの List、Set、Dict、Tuple を使っていました。 from typing import List nums: List[int] = [1, 2, 3] リスト (list) 整数型 (int) の要素を持つリスト my_list: list[int] = [1, 2, 3] セット (set) 文字列型 (str) の要素を持つセット my_set: set[str] = {&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;} 辞書 (dict) 文字列型のキーと int 型の値を持つ辞書 my_dict: dict[str, int] = {&#34;key1&#34;: 10, &#34;key2&#34;: 20} タプル (tuple) 2 つの int 要素と 1 つの str 要素を持つタプル my_tuple: tuple[int, int, str] = (3, 7, &#34;Hello&#34;) tuple は型パラメーターの数と要素数が一致している必要があります。 任意の数の要素を持つタプルを表現するには、以下のように ... を使います。 任意の数の int 要素を持つタプル my_tuple: tuple[int, ...] = (1, 2, 3, 4, 5) 名前付きタプルを定義するときは、typing モジュールの NamedTuple を使用します。 名前付きタプル from typing import NamedTuple class Player(NamedTuple): name: str id: int = 100 p = Player(&#34;Maku&#34;) assert p.name == &#34;Maku&#34; assert p.id == 100 Union と Optional Union（いずれかの型） Union を使うと、複数の型のうち、いずれかを格納できる型を表現できます。 Python 3.10 以降では、Union の代わりに | 演算子を使ってシンプルに記述できるようになりました。 int あるいは str を格納できるリスト型 # Python 3.10 以降 my_list: list[int | str] = [100, &#34;AAA&#34;, 200, &#34;BBB&#34;] # Python 3.9 以前 from typing import List, Union my_list: List[Union[int, str]] = [100, &#34;AAA&#34;, 200, &#34;BBB&#34;] Optional（省略可能な型） Optional を使うと、None が許容される型を表現できます。 Python 3.10 以降では、Optional の代わりに | None とより短く記述できます。 int あるいは None を格納できる型 # Python 3.10 以降 limit: int | None = 10 if is_limited() else None if x is not None: print(f&#34;Limit: {x}&#34;) # Python 3.9 以前 from typing import Optional limit: Optional[int] = 10 if is_limited() else None # Union でも表現可能 limit: Union[int, None] = 10 if is_limited() else None 関数 パラメーターと戻り値の型アノテーション 関数定義では、パラメーターと戻り値の型をアノテートできます。 # 2 つの int を引数に取り、int を返す関数 def sum_two_numbers(a: int, b: int) -&gt; int: return a + b # 1 つの float を引数に取り、str を返す関数 def surface_area_of_cube(edge_length: float) -&gt; str: return f&#34;The surface area of the cube is {6 * edge_length ** 2}.&#34; # 戻り値を返さない関数 def greet(name: str) -&gt; None: print(f&#34;Hello, {name}!&#34;) ちなみに、クラスのコンストラクター __init__() は戻り値を持たないので、戻り値の型アノテーションを付けるときは -&gt; None と記述します。 class User: # __init__ メソッドの戻り値は必ず None （self の型は省略可能） def __init__(self, name: str) -&gt; None: self.name = name ジェネレーター関数 yield を使ったジェネレーター関数は、戻り値の型として Iterator を指定します。 Iterator 型のオブジェクトは、for-in ループや next() 関数で要素を 1 つずつ取り出すことができます。 from collections.abc import Iterator def fib(n: int) -&gt; Iterator[int]: a, b = 0, 1 while a &lt; n: yield a a, b = b, a + b for i in fib(100): print(i, end=&#34; &#34;) # =&gt; 0 1 1 2 3 5 8 13 21 34 55 89 Callable（関数を表す型） typing モジュールの Callable を使うと、関数として呼び出しが可能な型を表現できます。 例えば、f: Callable[[str], int] のように定義した変数 f には、1 つの str 型の引数を取り、int 型の戻り値を返す関数を代入できます。 from typing import Callable def my_func(x: str) -&gt; int: return len(x) f: Callable[[str], int] = my_func print(f(&#34;Hello&#34;)) # =&gt; 5 下記は、リスナー（コールバック関数）をセットできるクラスの実装例です。 リスナーをセットできるクラスの実装例 from typing import Callable class MyClass: # Define a type alias for the listener function Listener = Callable[[str], None] def __init__(self) -&gt; None: self._listeners: list[MyClass.Listener] = [] def add_listener(self, listener: Listener) -&gt; None: self._listeners.append(listener) def remove_listener(self, listener: Listener) -&gt; None: self._listeners.remove(listener) def clear_listeners(self) -&gt; None: self._listeners.clear() def notify(self, arg: str) -&gt; None: for listener in self._listeners: listener(arg) # Example usage if __name__ == &#34;__main__&#34;: def my_listener(arg: str) -&gt; None: print(f&#34;Listener called with argument: {arg}&#34;) my_class = MyClass() my_class.add_listener(my_listener) my_class.notify(&#34;Hello&#34;) # コールバック関数が呼び出される my_class.remove_listener(my_listener) my_class.notify(&#34;Goodbye&#34;) # 何も呼び出されない クラス変数とインスタンス変数 クラス変数 typing モジュールの ClassVar を使うと、インスタンス経由では参照できないクラス変数を表現できます。 class User: # クラス変数の型アノテーションの例 __count: ClassVar[int] = 0 def __init__(self, name: str) -&gt; None: self.name = name # クラス変数の参照方法1 User.__count += 1 @classmethod def get_count(cls) -&gt; int: # クラス変数の参照方法2 return cls.__count user1 = User(&#34;Alice&#34;) user2 = User(&#34;Bob&#34;) user3 = User(&#34;Charlie&#34;) print(User.get_count()) # 3 __count はクラス変数としてアノテートされているので、上記のように User.__count や cls.__count でアクセスします。 self.__count のようにインスタンス変数としてアクセスすることはできません。 インスタンス変数 インスタンス変数は、コンストラクタ内で初期化するときに型アノーテーションを付けることができます。 class ScoreBoard: def __init__(self) -&gt; None: # インスタンス変数の型アノテーションの例 self.scores: list[int] = [] def append_score(self, score: int) -&gt; None: self.scores.append(score) 定数 (Final) typing モジュールの Final を使うと、変更不可な（再代入できない）定数を表現できます。 モジュールレベルの定数 from typing import Final FINAL_INT: Final = 100 FINAL_STR: Final = &#34;Hello&#34; FINAL_LIST: Final = [1, 2, 3] FINAL_DICT: Final = {&#34;key1&#34;: 10, &#34;key2&#34;: 20} FINAL_SET: Final = {&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;} FINAL_TUPLE: Final = (&#34;a&#34;, &#34;b&#34;, 100) もう少し具体的に Final[int] や Final[str] と定義することもできますが、通常は上記のように Final とだけ書けば十分です。 クラス定数も同様に Final を使って表現できます。 クラス定数 from typing import Final class Config: INVALID_ID: Final = -1 列挙型 (Enum) 列挙型は、enum モジュールの Enum クラスを継承したクラスとして表現します。 import enum class Colors(enum.Enum): RED = 1 GREEN = 2 BLUE = 3 print(Colors.RED) # =&gt; Colors.RED print(Colors.RED.name) # =&gt; RED print(Colors.RED.value) # =&gt; 1 列挙型クラスを for-in ループで回すと、値を 1 つずつ参照できます。 for c in Colors: print(f&#34;{c}\\t{c.name}\\t{c.value}&#34;) 出力結果 Colors.RED RED 1 Colors.GREEN GREEN 2 Colors.BLUE BLUE 3 ループ処理できることを示す型 (Iterable) リストやタプルなどのコレクションは、for-in でループ処理することができます。 こういった、ループ処理が可能なオブジェクトを表す型として、Iterable が用意されています。 次の例では、ループ処理可能な数値コレクションを受け取る squares() 関数を定義しています。 from typing import Iterable # define Number type which can be int or float Number = int | float def squares(numbers: Iterable[Number]) -&gt; None: &#34;&#34;&#34;Print the squares of the given numbers.&#34;&#34;&#34; for num in numbers: print(num**2) if __name__ == &#34;__main__&#34;: my_list = [1, 2, 3] my_tuple = (1, 2, 3) my_set = {1, 2, 3} # squares 関数は、リスト、タプル、セットを同じように処理できる squares(my_list) # =&gt; 1 4 9 squares(my_tuple) # =&gt; 1 4 9 squares(my_set) # =&gt; 1 4 9 引数として受け取ったオブジェクトを for-in ループで処理するだけなら、list 型のパラメーターとして定義するより、上記のように Iterable 型として定義した方が汎用性が高くなります。 一方で、関数の戻り値の方としては、具体的な list 型などのオブジェクトを返すようにします。 def squares(numbers: Iterable[Number]) -&gt; list[Number]: &#34;&#34;&#34;Return the squares of the given numbers.&#34;&#34;&#34; return [num**2 for num in numbers] 独自クラスを Iterable な型として扱えるようにするには、以下のように __iter__() メソッドを実装します。 class MyNumbers: def __init__(self, *args: Number): self.numbers = args def __iter__(self): return iter(self.numbers) if __name__ == &#34;__main__&#34;: obj = MyNumbers(1.5, 2, 3) squares(obj) # =&gt; 2.25 4 9"},{url:"/p/d3exkpu/",title:"Neovim カスタマイズのために Lua 言語をざっと理解する",date:"2025-03-05T00:00:00+09:00",body:"Neovim カスタマイズのために Lua 言語をざっと理解する Neovim を Lua スクリプトでカスタマイズできるようになるために、Lua 言語をざっと理解しておきます。 Lua スクリプトの実行方法 コマンドモードから実行する (:lua) ワンライナー程度であれば、Neovim のコマンドモードで :lua を使って直接 Lua コードを実行できます。 コマンドーモードから Lua スクリプトを実行 :lua print(&#34;Hello&#34;) Neovim の設定を変更するときにも使えます。 コマンドーモードからオプションを設定 :lua vim.opt.number = true コマンドラインから実行する (nvim -l) Neovim 自体が Lua の実行環境を備えているので、次のように nvim -l コマンドで Lua スクリプトを実行できます。 hello.lua print(&#34;Hello, Lua!&#34;) Lua スクリプトファイルを実行 $ nvim -l hello.lua Hello, Lua! 編集中のスクリプトを実行する (:luafile %) Neovim で Lua スクリプトを編集しているときに、そのバッファの内容を実行する場合は次のようにします。 カレントバッファの内容を実行 :luafile % Neovim の設定ファイル (init.lua) で以下のような設定をしておけば、.lua ファイルを編集中に（ノーマルモードで） F5 キーを押すだけで実行できるようになります。 ~/.config/nvim/init.lua --- .lua ファイルを編集中に &lt;F5&gt; キーで実行 vim.api.nvim_create_autocmd(&#34;FileType&#34;, { pattern = &#34;lua&#34;, callback = function() vim.keymap.set(&#39;n&#39;, &#39;&lt;F5&gt;&#39;, &#39;&lt;cmd&gt;luafile %&lt;CR&gt;&#39;, { buffer = true }) end }) VS Code で実行する Visual Studio Code で Lua スクリプトを編集する場合は、Code Runner 拡張 をインストールしておくと便利です。 Code Runner 拡張を使うと、各種言語のコードを編集中にショートカットキー (Ctrl+Alt+N) でそのコードを実行できるようになります（あるいはコマンドパレットから Run Code を実行）。 今回は Lua の実行環境として nvim -l コマンドを使うので、VS Code の設定ファイルで以下のように設定しておきます。 settings.json { /* * Code Runner 拡張用の設定 */ &#34;code-runner.executorMap&#34;: { &#34;go&#34;: &#34;go run&#34;, &#34;javascript&#34;: &#34;node&#34;, &#34;lua&#34;: &#34;nvim -l&#34;, &#34;python&#34;: &#34;python&#34; }, &#34;code-runner.saveFileBeforeRun&#34;: true, // 実行前にカレントファイルを保存する &#34;code-runner.runInTerminal&#34;: true, // OUTPUT ではなく TERMINAL タブで実行する // ... } コメント Lua のコメントは 2 つのハイフン (-) で始まります。 -- 行末コメント --[[ これは複数行のコメントです。 ブロックコメントとも言うよ。 ]] 変数とデータ型 変数の定義 local を付けた場合はローカル変数、付けない場合はグローバル変数になります。 変数には任意の型の値を代入できます。 local my_local = 200 my_global = 100 一行でまとめて初期化できます。 local one, two, three = &#34;one&#34;, &#34;two&#34;, &#34;three&#34; データ型 Lua のデータ型は type 関数で調べられます。 print(type(nil)) --&gt; nil（初期化されていない変数は nil になる） print(type(true)) --&gt; boolean print(type(100)) --&gt; number print(type(0.1)) --&gt; number print(type(&#34;Hello&#34;)) --&gt; string print(type(print)) --&gt; function print(type({})) --&gt; table Lua では数値の 0 や空文字列 &quot;&quot; を真偽値 (boolean) として評価すると真値 (= true) とみなされることに注意してください。 if 0 then print(&#34;0 は true&#34;) end if &#34;&#34; then print(&#34;空文字列も true&#34;) end if {} then print(&#34;空テーブルも true&#34;) end nil や false は偽値として扱われます。 文字列 文字列はシングルクォート (') かダブルクォート (&quot;) で囲んで表現します。 複数行の文字列は [[ と ]] で囲みます。 local s = &#34;hello&#34; local s = &#39;world&#39; local s = [[ 複数行の文字列データはこのように記述します。 いわゆるヒアドキュメントです。 ]] -- フォーマット指定する場合は string.format を使います local s = string.format(&#34;%06d&#34;, 1234) -- &gt; 001234 local s = string.format(&#34;%6d&#34;, 1234) -- &gt; 1234（右寄せ6桁） local s = string.format(&#34;%-6d&#34;, 1234) -- &gt; 1234 （左寄せ6桁） local s = string.format(&#34;%.4f&#34;, 0.12) -- &gt; 0.1200 local s = string.format(&#34;%X&#34;, 65535) -- &gt; FFFF よく使う文字列操作には次のようなものがあります。 文字列変数のメソッドとして呼び出す方法 (変数:XXX()) と、関数の形で呼び出す方法 (string.XXX()) があります。 local str = &#34;Hello World&#34; -- 文字列のサイズを取得する print(#str) -- &gt; 11 print(string.len(&#34;ABC&#34;)) -- &gt; 3 -- 文字列を連結する print(str .. &#34; Goodbye&#34;) -- &gt; Hello World Goodbye print(&#34;AAA&#34; .. &#34;BBB&#34;) -- &gt; AAABBB -- 文字列を検索する local first, last = string.find(&#34;foo bar hoge&#34;, &#34;bar&#34;) -- &gt; 5, 7 local first, last = string.find(&#34;foo bar hoge&#34;, &#34;ZZZ&#34;) -- &gt; nil, nil -- 文字列の一部を取り出す print(str:sub(1, 5)) -- &gt; Hello print(str:sub(7)) -- &gt; World print(str:sub(-5)) -- &gt; World print(string.sub(&#34;ABCDE&#34;, 2, 4)) -- &gt; BCD -- 文字列を置換する local replaced = str:gsub(&#34;World&#34;, &#34;Lua&#34;) print(replaced) --&gt; Hello Lua -- 2つ目の戻り値で置換された数を取得できる local replaced, count = string.gsub(&#34;foo bar foo&#34;, &#34;foo&#34;, &#34;AAA&#34;) print(replaced) -- &gt; AAA bar AAA print(count) -- &gt; 2 -- 大文字・小文字変換 print(str:upper()) -- &gt; HELLO WORLD print(str:lower()) -- &gt; hello world -- フォーマット print(string.format(&#34;Hello %s %d&#34;, &#34;World&#34;, 123)) -- &gt; Hello World 123 -- パターンマッチ local matched = string.match(&#34;Hello 123&#34;, &#34;%d+&#34;) print(matched) -- &gt; 123 -- バイトコード print(string.byte(&#34;ABC&#34;, 1)) -- &gt; 65 print(string.char(65)) -- &gt; A print(string.char(65, 66, 67)) -- &gt; ABC print(string.len(&#34;ABCあ&#34;)) -- &gt; 3 -- 繰り返し print(string.rep(&#34;*&#34;, 8)) -- &gt; ******** テーブル (Table) Lua には配列や連想配列を表現するためのテーブル (table) があります。 配列のインデックスは 1 から始まることに気をつけてください。 #arr とすると配列 arr の要素数を取り出せます。 配列としてのテーブル local arr = {&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;} arr[1] = &#34;ZZZ&#34; -- ループ処理 for i = 1, #arr do print(arr[i]) end -- インデックス付きループ処理 for i, v in ipairs(arr) do print(i, v) end 実行結果 ZZZ BBB CCC 1 ZZZ 2 BBB 3 CCC キー名と値のペアを指定することで、連想配列として使用できます。 連想配列としてのテーブル local user = { name = &#34;Maku&#34;, age = 14 } -- キー名によるアクセス print(&#34;name = &#34; .. user.name) print(&#34;age = &#34; .. user.age) -- キーと値でループ処理 for key, value in pairs(user) do print(key .. &#34; = &#34; .. value) end 実行結果 name = Maku age = 14 name = Maku age = 14 配列と連想配列の両方の要素を持つテーブルも作成できます。 配列と連想配列を持つテーブル local data = { &#34;AAA&#34;, &#34;BBB&#34;, name = &#34;Maku&#34;, age = 14 } -- キーと値ですべての要素をループ処理 for key, val in pairs(data) do print(key, val) end -- インデックスでアクセスできる要素のみをループ処理 for i, val in ipairs(data) do print(i, val) end 実行結果 1 AAA 2 BBB name Maku age 14 1 AAA 2 BBB テーブルにセットされたメソッドを呼び出す場合は、変数名:メソッド名 のようにします。 ドットではなく、コロン (:) を使うことに注意してください。 テーブルのメソッドを呼び出す local obj = { name = &#34;Maku&#34;, greet = function(self) print(&#34;I am &#34; .. self.name) end } obj:greet() -- &gt; I am Maku obj.name = &#34;Hemumu&#34; obj:greet() -- &gt; I am Hemumu 関数 (Function) 関数の基本 Lua で関数を定義するには function キーワードを仕様します。 local function greet(name) print(&#34;Hello, &#34; .. name) end greet(&#34;Maku&#34;) --&gt; Hello, Maku 多値関数 Lua の関数は複数の戻り値を返すことができます。 -- 数値配列から最大値とそのインデックスを返します function findMaxValueAndIndex(arr) local max = -math.huge local index = -1 for i = 1, #arr do if arr[i] &gt; max then max = arr[i] index = i end end return max, index end -- 使用例 local arr = {1, 3, 5, 2, 4} local max, index = findMaxValueAndIndex(arr) -- &gt; 5, 3 特定の位置の戻り値だけを取得したいときは、不要な戻り値を _ で受け取るか、select 関数で取得したい戻り値のインデックスを指定します。 local _, index = findMaxValueAndIndex(arr) -- &gt; 3 local index = select(2, findMaxValueAndIndex(arr)) -- &gt; 3 可変長引数 可変長引数は ... で表現します。 -- 任意の数の数値の平均値を計算します。 function average(...) local args = {...} local total = 0 for _, v in ipairs(args) do total = total + v end return total / #args end -- 使用例 print(average(2, 2, 5, 10)) -- &gt; 4.75 デフォルト引数 or 演算子を利用して、引数のデフォルト値を表現することができます（指定されなかった引数が nil になることを利用しています）。 function greet(name, message) message = message or &#34;Hello&#34; print(message .. &#34;, &#34; .. name) end greet(&#34;Maku&#34;) --&gt; Hello, Maku greet(&#34;Maku&#34;, &#34;Goodbye&#34;) --&gt; Goodbye, Maku 名前付き引数 Lua は関数の名前付き引数をサポートしていませんが、テーブルを渡すことで同様のことを実現できます。 function greet(args) local greeting = args.greeting or &#34;Hello&#34; local name = args.name or &#34;Guest&#34; print(greeting .. &#34;, &#34; .. name .. &#34;!&#34;) end greet { greeting = &#34;Hi&#34;, name = &#34;Alice&#34; } greet { name = &#34;Bob&#34; } greet {} テーブルを引数として渡すときは、上記のように呼び出し時の () を省略できます。 演算子 数値演算子 (Arithmetic Operators) 数値演算子は +、-、*、/、/、%、^ が使えます。 print(1 + 2) -- &gt; 3 print(5 - 3) -- &gt; 2 print(2 * 3) -- &gt; 6 print(10 / 3) -- &gt; 3.3333333333333 print(10 % 3) -- &gt; 1 print(2 ^ 10) -- &gt; 1024 print(2 ^ 0.5) -- &gt; 1.4142135623731 Lua には ++、--、+=、-= などの演算子はないので、数値をインクリメントしたい場合は a = a + 1 のように記述します）。 比較演算子 (Comparison Operators) 比較演算子は Java や C とほぼ同じですが、等しくないことを表す演算子は != ではなく ~= です。 -- 数値の比較 print(1 == 2) -- &gt; false print(1 ~= 2) -- &gt; true print(1 &lt; 2) -- &gt; true print(1 &lt;= 2) -- &gt; true print(1 &gt; 2) -- &gt; false print(1 &gt;= 2) -- &gt; false -- 文字列の比較 print(&#34;AAA&#34; == &#34;BBB&#34;) -- &gt; false print(&#34;AAA&#34; ~= &#34;BBB&#34;) -- &gt; true print(&#34;A&#34; &lt;= &#34;B&#34;) -- &gt; true print(&#34;01&#34; &lt; &#34;20&#34;) -- &gt; true -- 数値と文字列を比較すると false print(1 == &#34;1&#34;) -- &gt; false 論理演算子 (Logical Operators) 論理演算子は and、or、not が使えます。 print(true and true) -- &gt; true print(true and false) -- &gt; false print(true or true) -- &gt; true print(true or false) -- &gt; true print(not true) -- &gt; false print(not false) -- &gt; true 論理演算子で繋げた式の結果は、最後に評価された式の値になります。 具体的には、or の場合は最初に真 (true) と評価された値、and の場合は最初に偽 (false) と評価された値になります。 すべての値が偽 (false) と評価された場合は、一番最後の値が返されます。 print(nil or &#34;AAA&#34; or false) -- &gt; AAA（最初に真と評価された値） print(false or nil) -- &gt; nil（すべて偽なので最後の値） print(0 and false and 1) -- &gt; false （最初に偽と評価された値） print(nil and false) -- &gt; false（すべて偽なので最後の値） 制御構文 if-else if a &gt; 0 then print(&#34;a is a positive number&#34;) elseif a &lt; 0 then print(&#34;a is a negative number&#34;) else print(&#34;a is zero&#34;) end for ループ -- 1 から 10 までの数を表示 for i = 1, 10 do print(i) end -- ステップ (-1) を指定して 10 から 1 までの数を表示 for i = 10, 1, -1 do print(i) end while ループ local i = 1 -- i が 10 以下の間ループ while i &lt;= 10 do print(i) i = i + 1 end repeat - until ループ local i = 1 -- i が 10 を超えるまでループ repeat print(i) i = i + 1 until i &gt; 10 もっと学ぶ 以上の文法をざっと理解すれば、ほとんどの Lua スクリプトを読み書きできるはずです。 さらに Lua 言語を学びたい場合は、公式のドキュメントを参照してください。 https://www.lua.org/"},{url:"/p/cfc9tpn/",title:"Neovim 用のプラグインマネージャー lazy.nvim をインストールする",date:"2025-03-02T00:00:00+09:00",body:"Neovim 用のプラグインマネージャー lazy.nvim をインストールする lazy.nvim は、Neovim 用のプラグインマネージャーです。 名前の通り、各種プラグインを必要に応じて遅延ロードしてくれるため、多くのプラグインを導入しても Neovim の起動があまり遅くならないという特徴があります。 lazy.nvim のインストール lazy.nvim は 公式サイトの Installation に記載されている手順に従ってインストールします。 まずは、Neovim の設定ファイルに以下のような行を追加します。 ~/.config/nvim/init.lua require(&#34;config.lazy&#34;) この require により、~/.config/nvim/lua/config/lazy.lua というファイルが読み込まれるようになるので、lazy.nvim 関連の設定はこのファイルに記述していきます。 これは、公式サイトで Structured Setup として紹介されている方法です。 下記の設定も公式サイトに記述されている通りの初期設定ですが、このファイルを作成して Neovim を再起動すれば、lazy.nvim が自動的にインストールされます（内部で git コマンドを使ってダウンロードしています）。 ~/.config/nvim/lua/config/lazy.lua -- Bootstrap lazy.nvim local lazypath = vim.fn.stdpath(&#34;data&#34;) .. &#34;/lazy/lazy.nvim&#34; if not (vim.uv or vim.loop).fs_stat(lazypath) then local lazyrepo = &#34;https://github.com/folke/lazy.nvim.git&#34; local out = vim.fn.system({ &#34;git&#34;, &#34;clone&#34;, &#34;--filter=blob:none&#34;, &#34;--branch=stable&#34;, lazyrepo, lazypath }) if vim.v.shell_error ~= 0 then vim.api.nvim_echo({ { &#34;Failed to clone lazy.nvim:\\n&#34;, &#34;ErrorMsg&#34; }, { out, &#34;WarningMsg&#34; }, { &#34;\\nPress any key to exit...&#34; }, }, true, {}) vim.fn.getchar() os.exit(1) end end vim.opt.rtp:prepend(lazypath) -- Make sure to setup `mapleader` and `maplocalleader` before -- loading lazy.nvim so that mappings are correct. -- This is also a good place to setup other settings (vim.opt) vim.g.mapleader = &#34; &#34; vim.g.maplocalleader = &#34;\\\\&#34; -- Setup lazy.nvim require(&#34;lazy&#34;).setup({ spec = { -- import your plugins { import = &#34;plugins&#34; }, }, -- Configure any other settings here. See the documentation for more details. -- colorscheme that will be used when installing plugins. install = { colorscheme = { &#34;habamax&#34; } }, -- automatically check for plugin updates checker = { enabled = true }, }) これで、lazy.nvim を使用する準備が整いました。 各プラグインの設定は、~/.config/nvim/lua/plugins ディレクトリに .lua ファイルを作成して記述していきます。 よって、lazy.nvim まわりのファイル構成は以下のようになります。 ~/.config/nvim/ ├── lua/ │ ├── config/ │ │ └── lazy.lua │ └── plugins/ （使いたいプラグインがあったらここに .lua ファイルを追加する） │ ├── spec1.lua │ ├── : │ └── spec2.lua └── init.lua 各種プラグインのインストール 新しくプラグインをインストールしたいときは、~/.config/nvim/lua/plugins ディレクトリに .lua ファイルを作成して、そのプラグイン用の設定を記述します。 その後、Neovim を再起動するか :Lazy install でプラグインをインストールできます。 例: ステータスラインをリッチにする (lualine) nvim-lualine/lualine.nvim 図: lualine プラグインによるステータスライン表示 Vim/Neovim の初期状態のステータスラインはとてもそっけないです。 lualine.nvim プラグインを入れると、上記のようなそれっぽいステータスラインを表示することができます。 上記はプラグインを読み込んだだけのデフォルトの表示例ですが、このままでも十分な情報量です。 ~/.config/nvim/lua/plugins/lualine.lua return { &#34;nvim-lualine/lualine.nvim&#34;, dependencies = { &#34;nvim-tree/nvim-web-devicons&#34;, }, event = &#34;VeryLazy&#34;, -- Neovim 起動後に遅延ロードする opts = {}, } 自力でステータスラインの表示設定 (vim.opt.statusline) をしている場合は忘れずに削除しておきます（参考: ステータスラインの表示内容を設定する (statusline, laststatus)）。 例: ファイルツリーを表示する (neo-tree) nvim-neo-tree/neo-tree.nvim ファイル操作を行うために、何らかのファイルツリーを表示するプラグインを入れておくとよいです。 Neotree プラグインは、ファイルの作成、削除、リネームだけでなく、プレビュー表示 (P)、Fazzy Find (/) など便利な機能を備えています。 下記の設定例では、&lt;leader&gt;-e というショートカットキーで Neotree を表示・非表示できるようにしています。 ~/.config/nvim/lua/plugins/neotree.lua return { &#34;nvim-neo-tree/neo-tree.nvim&#34;, branch = &#34;v3.x&#34;, dependencies = { &#34;nvim-lua/plenary.nvim&#34;, &#34;MunifTanjim/nui.nvim&#34;, &#34;nvim-tree/nvim-web-devicons&#34;, -- optional, but recommended }, lazy = false, -- neo-tree will lazily load itself config = function() -- キーマップで簡単に Neotree をトグルできるようにする vim.keymap.set(&#34;n&#34;, &#34;&lt;Leader&gt;e&#34;, &#34;:Neotree toggle&lt;CR&gt;&#34;, { desc = &#34;Toggle Neotree&#34; }) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-e&gt;&#34;, &#34;:Neotree toggle&lt;CR&gt;&#34;, { desc = &#34;Toggle Neotree&#34; }) end, } 例: スクロールを滑らかにする (neoscroll) karb94/neoscroll.nvim Ctrl-F/B/D/U などでスクロールするときにアニメーションさせることができます。 ~/.config/nvim/lua/plugins/neoscroll.lua return { &#34;karb94/neoscroll.nvim&#34;, opts = { duration_multiplier = 0.3, -- 1.0より小さくするとスクロール速度が上がる }, } 例: GitHub Copilot プラグイン Neovim 起動後に、:Copilot auth として GitHub にサインインすると、GitHub Copilot が使えるようになります。 上記の設定では、Insert モードに入ったときに自動的に GitHub Copilot が起動し、随時提案テキストが表示されるようになります。 提案されたテキストを受け入れたいときは &lt;Tab&gt; キーを入力します。 zbirenbaum/copilot.lua ~/.config/nvim/lua/plugins/copilot.lua return { &#34;zbirenbaum/copilot.lua&#34;, event = &#34;InsertEnter&#34;, opts = { suggestion = { auto_trigger = true, keymap = { accept = &#34;&lt;Tab&gt;&#34;, next = &#34;&lt;S-C-Space&gt;&#34;, }, }, filetypes = { gitcommit = true, markdown = true, yaml = true, }, }, } 他のプラグインも同様の手順で追加できます。 便利っ ٩(๑❛ᴗ❛๑)۶ lazy.nvim の設定いろいろ Plugin の更新通知 (checker) require(&#34;lazy&#34;).setup({ -- ... checker = { -- automatically check for plugin updates enabled = false, concurrency = nil, ---@type number? set to 1 to check for updates very slowly notify = true, -- get a notification when new updates are found frequency = 3600, -- check for updates every hour check_pinned = false, -- check for pinned packages that can&#39;t be updated }, -- ... }) lazy.nvim 公式サイトの設定例にあるように、checker = { enabled = true } と設定しておくと Neovim 起動時に # Plugin Updates のような通知が出るようになります。 この通知が煩わしいときは、Plugin の自動更新チェックは無効にしておきましょう。 手動での Plugin 更新は :Lazy → U でいつでもできます。 -- Disable automatic plugin update checks checker = { enabled = false },"},{url:"/p/mq4c72g/",title:"Python の FastAPI フレームワークで Web API を実装する",date:"2025-01-05T00:00:00+09:00",body:"Python の FastAPI フレームワークで Web API を実装する Python の FastAPI フレームワークを使うと、高性能な Web API を簡単に実装できます。 FastAPI で Hello World まずは、FastAPI で Hello World を返す Web API を実装してみます。 ここでは、プロジェクトのパッケージ管理に uv を使います。 uv を使うと、仮想環境 (venv) を意識せずに済むのでとても楽です（参考: uv の基本）。 プロジェクトの作成と FastAPI のインストール（ライブラリ＆CLIツール） $ uv init hello-api $ cd hello-api $ uv add fastapi --extra standard uv add fastapi するときに --extra standard オプションを指定すると、API サーバーを立ち上げるための fastapi コマンド（fastapi-cli、uvicorn パッケージ）なども一緒にインストールされます。 従来の pip でインストールするなら、pip install fastapi[standard] とします。 uv run 経由で fastapi コマンドが実行できるか確認しておきます。 fastapi コマンドのバージョン確認 $ uv run fastapi --version FastAPI CLI version: 0.0.7 Web API 実装として、以下のようなファイルを作成します。 main.py from fastapi import FastAPI app = FastAPI() @app.get(&#34;/&#34;) def read_root(): return {&#34;Hello&#34;: &#34;World&#34;} @app.get(&#34;/items/{item_id}&#34;) def read_item(item_id: int, q: str | None = None): return {&#34;item_id&#34;: item_id, &#34;q&#34;: q} FastAPI サーバーを立ち上げるには、次のように fastapi dev コマンド、あるいは fastapi run コマンドを使用します。 開発時は前者のコマンドを使って、development モードで立ち上げます。 FastAPI サーバーの立ち上げ $ uv run fastapi dev main.py # development モードで起動 $ uv run fastapi run main.py # production モードで起動 これで、下記のようなアドレスにアクセスすることで、API のレスポンスとして JSON データを取得できます。 http://127.0.0.1:8000/ http://127.0.0.1:8000/items/123 http://127.0.0.1:8000/items/123?q=hello さらに、Web ブラウザで http://127.0.0.1:8000/docs にアクセスすると、自動生成された API ドキュメント (Swagger UI) を参照できます。 FastAPI サーバーを development モードで立ち上げている場合は、ソースコードの更新時に自動的にリロードしてくれます。 Docker コンテナとして起動できるようにする Web API サーバーをデプロイするときは、Docker コンテナとして起動できるようにしておくと便利です。 下記は uv で管理されている FastAPI アプリケーションの Docker イメージを作成するための Dockerfile です。 Dockerfile FROM python:3-slim-bullseye # Install uv COPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv # Copy the application into the container COPY . /app # Install the application dependencies WORKDIR /app RUN uv sync --frozen --no-cache # Run the application CMD [&#34;/app/.venv/bin/fastapi&#34;, &#34;run&#34;, &#34;main.py&#34;, &#34;--port&#34;, &#34;8080&#34;] Dockerfile を用意できたら、次のようにビルドして hello-api イメージを作成します。 コンテナイメージのビルド $ docker image build -t hello-api . 次のようにコンテナを起動すると、http://127.0.0.1:8080/ で Web API にアクセスできるようになります。 コンテナの起動 $ docker container run --rm -p 8080:8080 hello-api イメージサイズは 300MB 弱ですが、必要なくなったら削除しておきます。 コンテナイメージの削除 $ docker image rm hello-api"},{url:"/p/fjsfjpw/",title:"Python プロジェクト用の爆速パッケージマネージャ uv を導入する",date:"2024-09-10T00:00:00+09:00",body:"Python プロジェクト用の爆速パッケージマネージャ uv を導入する uv とは Python 用のツール uv は、超高速なプロジェクト＆パッケージマネージャです。 パッケージマネージャと説明されていることが多いですが、どちらかというと Python プロジェクトを総合的に管理するツールです（単なる pip の置き換えではないです）。 uv は Rust で実装されており、従来の pip コマンドを使うよりも数十倍高速だと言われています。 提供元の Astral 社 は、Python 用の高速なツールチェインを作成することをミッションとしており、Python 用の超高速 Linter &amp; Formatter である Ruff を提供している会社でもあります。 uv の特徴 Rust で実装されていてとにかく高速 インストールが簡単で使い方も簡単 もちろんマルチプラットフォーム対応 (macOS/Linux/Windows) モダンな pyproject.toml ベースのプロジェクト管理が可能 uv があれば、Poetry や Rye は必要ありません。uv は Rye の後継という位置づけとのこと。 python コマンド自体のバージョン切り替えが可能 uv があれば、pyenv や py は必要ありません。 意識せずに仮想環境を扱える python コマンドの代わりに uv run を使うだけで仮想環境 (.venv) を作って入って依存解決して実行して抜けてくれます。 python -m venv .venv で仮想環境を作ったり、source .venv/bin/activate で仮想環境に入ったりする必要はありません。 様々な CI 環境での実行が考慮されている 例えば GitHub Actions 用の astral-sh/setup-uv アクションが公式に用意されていて安心です。 その他の特徴は、公式ページを参照 高速かつ全部入りで使いやすいので、2024 年時点の Python プロジェクト管理ツールとしては最も期待が持てそうです。 特に、venv などの仮想環境を意識せずに Python プログラムを 1 コマンドで実行できるのはとても快適です。 若干 Rust の cargo コマンドを意識しすぎな感じもありますが、Astral が Rust ラブなのでしょうがないです（別に悪いことではないです）。 uv のインストール uv のインストール方法は公式ドキュメントに書かれている通りですが、基本的にはどの環境でも 1 行のコマンドを実行するだけです。 事前に Python がインストールされている必要はありません。 インストール $ # macOS/Linux の場合 $ curl -LsSf https://astral.sh/uv/install.sh | sh $ # macOS (Homebrew) の場合 $ brew install uv $ # Windows の場合 $ powershell -ExecutionPolicy ByPass -c &#34;irm https://astral.sh/uv/install.ps1 | iex&#34; uv コマンドが実行できるようになれば成功です。 $ uv version uv 0.4.8 (956cadd1a 2024-09-09) ☝️ uv のインストール先 uv コマンド（および uvx コマンド）は ~/.cargo/bin 以下にインストールされます。 Rust 製のコマンドラインツールはこのディレクトリにインストールされることが決まっています。 1 ファイル（uvx を入れると 2 ファイル）がインストールされるだけなので、とてもシンプルです。 アンインストールは ~/.cargo/bin/uv を削除するだけです。 バージョンアップ インストール済みの uv コマンドをバージョン更新するには次のようにします。 コマンド自身にアップデートの仕組みが入っていると楽ですね。 $ uv self update シェルの補完機能を有効化 bash/zsh/Powershell などのコマンドラインで入力補完機能 (shell autocompletion) を有効化しておくと便利です。 Installation - Shell autocompletion | uv Python プロジェクトを作成する (uv init) pyproject.toml ベースの Python プロジェクトを作成するには、uv init &lt;アプリ名&gt; コマンドを使用します。 $ uv init myapp Initialized project `myapp` at `/Users/maku/myapp` myapp ディレクトリが作成され、次のようなファイルが自動生成されます。 myapp/ - .python-version # uv run コマンド（後述）で使う python のバージョン - README.md # 空っぽの README - hello.py # Hello World プログラム - pyproject.toml # プロジェクトの config ファイル 生成される pyproject.toml の内容は次のような感じになっています。 pyproject.toml [project] name = &#34;myapp&#34; version = &#34;0.1.0&#34; description = &#34;Add your description here&#34; readme = &#34;README.md&#34; requires-python = &#34;&gt;=3.12&#34; dependencies = [] プロジェクト内で Python スクリプトを実行するときは、基本的に python コマンドの代わりに uv run コマンドを使用します。 これにより、自動的にプロジェクト用の仮想環境 (.venv) に入り、依存関係を解決し、uv 管轄の python コマンドでスクリプトを実行してくれます。 Python スクリプトの実行 $ uv run hello.py Using Python 3.12.0 interpreter at: /Users/maku/.pyenv/versions/3.12.0/bin/python3.12 Creating virtualenv at: .venv Hello from myapp! プロジェクト内で最初に uv run コマンドを実行したときは、上記のように自動的に仮想環境用のディレクトリ (.venv) が作成されます。 このメッセージを抑制したいときは -q オプションを指定してください。 プログラムの実行が完了すると、自動的に仮想環境から抜けた状態に戻ります。 つまり、uv run を使うと、仮想環境内で実行しているということすら意識しなくて済むようになります。 ☝️ uv run が気持ち悪い？ Rust プログラマーであれば、uv run は cargo run に相当するコマンドであると考えると分かりやすいです。 最初は python コマンドで実行しないことに違和感があるかもしれませんが、uv run を使うことで多くの恩恵を得られます。 依存パッケージの管理 (uv add/remove) uv 管理下の Python プロジェクトで外部パッケージへの依存を追加するときは、pip install/uninstall の代わりに uv add/remove を使用します。 ここでは、例として toml パッケージをインストールしてみます。 例: toml パッケージを追加 $ uv add toml これにより、仮想環境 (.venv) に toml パッケージがインストールされ、pyproject.toml の dependencies に依存情報が追記されます。 pyproject.toml（抜粋） dependencies = [ &#34;toml&gt;=0.10.2&#34;, ] 既存の hello.py ファイルを編集して、toml パッケージを使うコードに書き換えます。 次の例では、pyproject.toml ファイルの内容をパースして辞書オブジェクト (dict) として取得しています。 hello.py import toml def main(): # Load the configuration file and convert it into a dict config = toml.load(&#34;pyproject.toml&#34;) print(config) if __name__ == &#34;__main__&#34;: main() 実行してみます。 $ uv run hello.py {&#39;project&#39;: {&#39;name&#39;: &#39;myapp&#39;, &#39;version&#39;: &#39;0.1.0&#39;, &#39;description&#39;: &#39;Add your description here&#39;, &#39;readme&#39;: &#39;README.md&#39;, &#39;requires-python&#39;: &#39;&gt;=3.12&#39;, &#39;dependencies&#39;: [&#39;toml&gt;=0.10.2&#39;]}} うまく動きました！ ٩(๑❛ᴗ❛๑)۶ わーぃ ちなみに、他の PC 上でこのプログラムを実行したいときは、プロジェクトのディレクトリに移動して、おもむろに uv run hello.py とするだけで実行できます。 その裏では、uv が (1) 仮想環境の生成、(2) 仮想環境に入る、(3) 依存パッケージのインストール、(4) プログラムの実行、(5) 仮想環境を抜ける、ということを自動でやってくれています。 とっても楽ですね！ （応用）Git にどのファイルをコミットするか？ 下記のファイルにはプロジェクトの実行環境の情報が含まれているので Git にコミットします。 .python-version &hellip; python コマンド自体のバージョン pyproject.toml &hellip; プロジェクトの情報（依存パッケージなど） uv.lock &hellip; 依存パッケージのより詳細なバージョン情報 一方、仮想環境ディレクトリ (.venv) はコミットしないように、.gitignore に次のように記述しておきます。 .gitignore # Ignore Python virtual environment directory .venv/ （応用）uv.lock ファイルとは？ uv.lock ファイルには、pyproject.toml の dependencies で表現しきれない 詳細なパッケージ依存情報 が記述されています （Node.js プロジェクトにおける、packages-lock.json や yaml.lock のようなものです）。 例えば、pyproject.toml に toml&gt;=0.10.2 と記述されている場合、toml パッケージのバージョンは 0.10.2 以上であれば何でもよいということを示していますが、それだけでは実行環境の再現性がなくなってしまうので、uv.lock に実際に使用する具体的なバージョンが記述されます。 uv.lock ファイルの例 version = 1 requires-python = &#34;&gt;=3.12&#34; [[package]] name = &#34;myapp&#34; version = &#34;0.1.0&#34; source = { virtual = &#34;.&#34; } dependencies = [ { name = &#34;toml&#34; }, ] [package.metadata] requires-dist = [{ name = &#34;toml&#34;, specifier = &#34;&gt;=0.10.2&#34; }] [[package]] name = &#34;toml&#34; version = &#34;0.10.2&#34; source = { registry = &#34;https://pypi.org/simple&#34; } sdist = { url = &#34;https://files.pythonhosted.org/packages/be/ba/1f744cdc819428fc6b5084ec34d9b30660f6f9daaf70eead706e3203ec3c/toml-0.10.2.tar.gz&#34;, hash = &#34;sha256:b3bda1d108d5dd99f4a20d24d9c348e91c4db7ab1b749200bded2f839ccbe68f&#34;, size = 22253 } wheels = [ { url = &#34;https://files.pythonhosted.org/packages/44/6f/7120676b6d73228c96e17f1f794d8ab046fc910d781c8d151120c3f1569e/toml-0.10.2-py2.py3-none-any.whl&#34;, hash = &#34;sha256:806143ae5bfb6a3c6e736a764057db0e6a0e05e338b5630894a5f779cabb4f9b&#34;, size = 16588 }, ] uv.lock ファイルは、uv add コマンドで依存パッケージを追加したときに、pyproject.toml と一緒に更新されます。 uv run によるプログラム実行時に更新されることもありますが、それは uv.lock に記述されたバージョンが、pyproject.toml で指定されたバージョン条件を満たしていない場合に限られます（プログラムを実行するたびにパッケージが更新されると大変なので）。 例えば、uv.lock にバージョン 0.10.2 と書かれていて、pyproject.toml に &gt;=0.10.1 と書かれている場合は、0.10.2 &gt;= 0.10.1 で条件を満たすので uv.lock は更新されないし、新しいパッケージがインストールされることもありません。 明示的に最新のパッケージをインストールして uv.lock ファイルを更新するには、次のように uv lock コマンドを使用します。 uv.lock ファイルの更新 $ uv lock --upgrade # 全パッケージを更新する場合 $ uv lock --upgrade-package toml # パッケージを指定して更新する場合 これにより、最新のパッケージを使用できるようになりますが、これはあくまで uv.lock ファイルの更新なので、pyproject.toml で指定している &gt;=0.10.1 などの情報は更新されないことに注意してください。 pyproject.toml 側の dependencies 情報を更新したいときは、uv add toml（あるいは明示的に uv add toml&gt;=0.10.2）などのコマンドを実行してください。 ☝️ uv.lock だけなぜ独自形式なの？ パッケージ管理ツールは大体このような lock ファイルの仕組みを持っていますが、lock ファイルにはまだ標準規格のようなものがないらしいです。 そのため、uv も独自のフォーマットで uv.lock ファイルを作成しています。 （応用）uv で Ruff などのツールをインストールする Python 用の高速 Linter &amp; Formatter である Ruff も uv でインストールできます。 Ruff は開発時に使用するツールなので、uv add --dev で dev 環境用の依存パッケージとしてインストールします。 ruff コマンドのインストール $ uv add --dev ruff pyproject.toml の dev-dependencies に次のように追記されます。 pyproject.toml [project] # ...プロジェクトの設定... [tool.uv] dev-dependencies = [ &#34;ruff&gt;=0.6.5&#34;, ] ☝️ 他の PC で依存パッケージをインストールするには 別の PC 環境などで git clone した直後はこれらの依存パッケージはインストールされていません。 dev 環境用の依存パッケージをまとめてインストールするには、uv sync --dev コマンドを使用します（uv run や uv sync では dev 環境用の依存パッケージはインストールされません）。 これは、GitHub Actions などの CI 環境上でテストツールをインストールするときにも使用します。 インストールしたコマンドを実行するには、uv run コマンドを使用します。 ruff コマンドの実行 $ uv run ruff check # Lint チェック $ uv run ruff format --check # フォーマットチェック $ uv run ruff format # 自動フォーマット エディタとして Visual Studio Code を使っているのであれば、Ruff 拡張を入れてしまうのが手っ取り早かったりします。 参考: VS Code で Python 用の Linter ＆フォーマッターの Ruff を使う｜まくろぐ （応用）GitHub Actions のワークフローに組み込む uv によるパッケージのインストールは高速なので、GitHub Actions などの CI 環境でも uv を使うとよいです。 本家ドキュメント: Using uv in GitHub Actions astral-sh/setup-uv アクション: Python setup uv · Actions · GitHub Marketplace 基本的な流れは次のようになります。 astral-sh/setup-uv アクションを使って uv をインストール uv python install で python をインストール uv sync --dev で dev 環境用の依存パッケージをインストール uv run pytest tests など任意のテストツールや Lint を実行"},{url:"/p/vap3zpa/",title:"HTML の video 要素で Web カメラ（USB カメラ）の映像を表示する",date:"2024-06-24T00:00:00+09:00",body:"HTML の video 要素で Web カメラ（USB カメラ）の映像を表示する Web カメラの表示テスト Web カメラ（USB カメラ）からの入力映像を Web ページ上で表示するテストです。 Enable webcam Web カメラからの入力映像を取得する ブラウザ上の JavaScript で Web カメラ（USB カメラ）からの入力映像を取得するには、MediaDevices オブジェクトの getUserMedia() メソッドを使って、MediaStream を取得します。 navigator.mediaDevices で MediaDevices のシングルトンオブジェクトを参照できるので、通常はこれを使用します。 取得した MediaStream を video 要素の srcObject プロパティにセットすることで、Web カメラの映像を video 要素に流し込むことができます。 HTML &lt;video id=&#34;webcam&#34; playsinline&gt;&lt;/video&gt; JavaScript const video = document.getElementById(&#34;webcam&#34;); // Web カメラのストリームを取得して video 要素に紐付ける navigator.mediaDevices.getUserMedia({ video: true }) .then((mediaStream) =&gt; { video.srcObject = mediaStream; video.play(); }) .catch((err) =&gt; { console.error(&#34;Web カメラの取得に失敗しました:&#34;, err); }); ボタンで Web カメラを On/Off する Web カメラからの MediaStream を取得しようとすると、Web ブラウザ上に「カメラの使用」を許可するかどうかの確認ダイアログが表示されます。 Web サイトを開いたときに急にこのダイアログが出てくるとびっくりしてしまうので、ユーザーが「開始」ボタンをなど押したときにキャプチャを開始するのがよいでしょう。 次の例では、Enable webcam というボタンを配置しています。 ボタンを押すと、Disable webcam に変化します。 HTML &lt;button id=&#34;webcamButton&#34;&gt;Enable webcam&lt;/button&gt; &lt;video id=&#34;webcam&#34; playsinline&gt;&lt;/video&gt; JavaScript const video = document.getElementById(&#34;webcam&#34;); const button = document.getElementById(&#34;webcamButton&#34;); let isWebcamRunning = false; // Webcam の開始／停止用ボタンを押したとき button.addEventListener(&#34;click&#34;, () =&gt; { if (isWebcamRunning) { disableWebcam(); } else { enableWebcam(); } isWebcamRunning = !isWebcamRunning; }); // Webcam を有効化 function enableWebcam() { button.disabled = true; // ボタン連打防止 navigator.mediaDevices.getUserMedia({ video: true }) .then((mediaStream) =&gt; { video.srcObject = mediaStream; video.play(); button.disabled = false; button.innerText = &#34;Disable webcam&#34;; }) .catch((err) =&gt; { console.error(&#34;Web カメラの取得に失敗しました:&#34;, err); }); } // Webcam を無効化 function disableWebcam() { if (video.srcObject) { video.srcObject.getTracks().forEach(track =&gt; track.stop()); button.innerText = &#34;Enable webcam&#34;; video.srcObject = null; } }"},{url:"/web/",title:"HTML/CSS",date:"2024-06-24T00:00:00+09:00",body:"HTML/CSS HTML 全般 HTML ファイルの雛形（テンプレート） Web サイトに favicon を設定する 旧記事 IE 8 でも HTML5 の header や footer 要素を使えるようにする 全体のレイアウト レイアウトの基礎知識 CSS の position プロパティによるレイアウト方法を理解する CSS の box-sizing プロパティで width の計算方法を制御する CSS のふくろうセレクター (* + *) で全要素の上下マージンを設定する CSS で画像の下に隙間が空くのを防ぐ (vertical-align) HTML のリスト要素 (ul, ol, li) のマージン指定方法を理解する CSS のフローティングボックス (float) を利用したレイアウトを理解する HTML 要素を中央寄せ／右寄せで表示する HTML の画像要素 (img) を親要素の左右両端に表示する レスポンシブ Viewport とメディアクエリによるレスポンシブ Web デザインの基本 モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし） CSS で画像と埋め込み動画のサイズを画面内に収める (max-width) CSS のフレキシブルボックスによるレスポンシブレイアウト 旧記事 （旧）フレキシブルボックスの旧式の定義方法 （旧）CSS で画面サイズによって全体のレイアウトを変更する フォント／テキスト フォントサイズは 100% と指定する CSS の rem や em を使用したサイズ指定を理解する pre 要素でもテキストがはみ出さないように折り返す 要素 フォーム 入力フォームに自動的にフォーカスする（autofocus 属性） プレースホルダーで入力フォームに補足説明を表示する（placeholder 属性） 入力必須の入力フォームを指定する（required 属性） 独自の入力フォーマットを指定する（pattern 属性） 入力エリアの入力候補を表示する（autocomplete 属性、datalist 要素） ヘッダ ヘッダ要素に連番を振る メニュー メニューの縦並びと横並びを切り替える メニューの表示位置を固定する メニューの高さを画面の高さに合わせる メニュー要素内でスクロールできるようにする CSS だけで開閉できるアコーディオンメニューを作成する ある位置までスクロールしたら固定されるメニューを作成する 印刷時に特定の要素（メニューなど）を非表示にする リンク 外部リンクに自動的にアイコンを付けて表示する (External link icons) 外部リンクをクリックしたときに必ず新しいタブで開く リンク先ファイルの拡張子によって自動的にアイコンを付けて表示する 画像／ボタン SVG アイコンの色をまわりの文字の色に合わせる SNS ボタンをきれいに並べる CSS セレクタ 結合子を使用して構造に応じてスタイルシートを適用する 子孫セレクタ 子セレクタ（直下セレクタ） 隣接兄弟セレクタ（隣接セレクタ） 一般兄弟セレクタ（間接セレクタ） マルチメディア audio 要素で音声ファイルを再生する video 要素で Web カメラ（USB カメラ）の映像を表示する その他 吹き出し風の見出しを作る Web サイト作成に関するメモ: SEO 対策 jQuery に関しては JavaScript のページを参照 外部サイトリンク HTML5の仕様 (W3C Recommendation) HTML5の文法チェック (W3C Markup Varidation Service) ブラウザのHTML5適合度チェック (HTML5test)"},{url:"/p/vopvucs/",title:"Python データ分析: カテゴリデータを扱う",date:"2024-06-16T00:00:00+09:00",body:"Python データ分析: カテゴリデータを扱う カテゴリデータとは 数値ではなく、カテゴリ名やラベルで表現されるデータをカテゴリデータと呼びます。 カテゴリデータには、本質的に順序関係を持たない名義カテゴリ (nominal category) と、純情関係のある順序カテゴリ (ordinal category) があります。 名義カテゴリ (nominal category) 順序のないカテゴリ 例: りんご、バナナ、オレンジ 例: 赤、青、黄、緑 順序カテゴリ (ordinal category) 順序のあるカテゴリ 例: Low、Middle、High 例: S、M、L、XL ロジスティック回帰やディープラーニングなどのアルゴリズムでは、入力データとして数値を想定しているため、カテゴリデータは数値に変換して扱う必要があります。 名義カテゴリを数値化する（ワンホットエンコーディング） 本質的に順序を持たない名義カテゴリ特徴量（色など）を扱うには、特徴量の個々のクラスに対する 2 値特徴量 (0 or 1) を作成します。 この手法は、機械学習では ワンホットエンコーディング（one-hot encoding)、統計では ダミー変数化 (dymmying) と呼ばれています。 scikit-learn の LabelBinarizer を使う方法 pandas の get_dummies を使う方法 scikit-learn の LabelBinarizer を使う方法 acikit-learn の preprocessing.LabelBinarizer クラスは、シンプルなワンホットエンコード機能を提供します。 次の例では、色を表す名義カテゴリ特徴量を one-hot ベクトル化しています。 import numpy as np import pandas as pd from sklearn.preprocessing import LabelBinarizer feature = np.array([&#34;red&#34;, &#34;blue&#34;, &#34;yellow&#34;, &#34;yellow&#34;, &#34;blue&#34;]) binarizer = LabelBinarizer() feature2 = binarizer.fit_transform(feature) print(feature2) # [[0 1 0] [1 0 0] [0 0 1] [0 0 1] [1 0 0]] 各列がどの色を表現しているかのクラス情報は LabelBinarizer#classes_ で参照できます。 print(binarizer.classes_) # [&#39;blue&#39; &#39;red&#39; &#39;yellow&#39;] one-hot ベクトル化されたデータを元の名義カテゴリデータに戻すには、LabelBinarizer#inverse_transform() を使用します。 feature2 = binarizer.fit_transform(feature) feature3 = binarizer.inverse_transform(feature2) print(feature3) # [&#39;red&#39; &#39;blue&#39; &#39;yellow&#39; &#39;yellow&#39; &#39;blue&#39;] pandas の get_dummies を使う方法 pandas の DataFrame を使っている場合は、pd.get_dummies() 関数を使うと簡単にワンホットエンコードできます。 pd.get_dummies() 関数に DataFrame を渡すと、すべてのカテゴリ特徴量カラム（通常は文字列を含むカラム）をワンホットエンコードしてくれます。 次の例では、col1 カラムを col1_AAA、col1_BBB、col1_CCC という 3 つのカラムに変換し、col2 カラムを col2_X、col2_Y という 2 つのカラムに変換しています。 これらのカラムのことを ダミー特徴量 (dummy feature) と呼びます。 df = pd.DataFrame({ &#34;col1&#34;: [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;, &#34;BBB&#34;, &#34;AAA&#34;], &#34;col2&#34;: [&#34;X&#34;, &#34;Y&#34;, np.nan, &#34;X&#34;, np.nan] }) df2 = pd.get_dummies(df) print(df2) 実行結果 col1_AAA col1_BBB col1_CCC col2_X col2_Y 0 True False False True False 1 False True False False True 2 False False True False False 3 False True False True False 4 True False False False False ワンホットエンコードするカラムを明示的に指定する場合は、columns=[&quot;col1&quot;, &quot;col2&quot;] のように指定してください。 欠損値 (NaN) のカラムも生成するには、dummy_na=True パラメーターを追加します。 &gt;&gt;&gt; pd.get_dummies(df, dummy_na=True) col1_AAA col1_BBB col1_CCC col1_nan col2_X col2_Y col2_nan 0 True False False False True False False 1 False True False False False True False 2 False False True False False False True 3 False True False False True False False 4 True False False False False False True デフォルトでは上記のように bool 型のカラムに変換されますが、dtype=int を指定することで、int 型 (0 or 1) のカラムに変換することができます。 &gt;&gt;&gt; pd.get_dummies(df, dtype=int) col1_AAA col1_BBB col1_CCC col2_X col2_Y 0 1 0 0 1 0 1 0 1 0 0 1 2 0 0 1 0 0 3 0 1 0 1 0 4 1 0 0 0 0 ワンホットエンコードを行う場合、線形依存（多重共線性: multicollinearity）を避けるために 作成された特徴量の 1 つをひとつを捨てる ことが推奨されれています（参考: Dummy Variable Trap in Regression Models）。 この処理は pd.get_dummies() 関数の drop_first フラグを True にセットすることで、簡単に実行できます。 次の実行例では、col1_AAA カラムと col2_X カラムが削除されています。 &gt;&gt;&gt; pd.get_dummies(df, drop_first=True) col1_BBB col1_CCC col2_Y 0 False False False 1 True False True 2 False True False 3 True False False 4 False False False 順序カテゴリを数値化する 順序カテゴリ特徴量は、サイズ (S/M/L) や難易度 (easy/normal/hard) のように、本質的に順序付けが可能なカテゴリ特徴量です。 これらは 1、2、3 のような大小関係のあるデータに置き換えることで、機械学習モデルなどのインプットとして扱えるようになります。 もっともシンプルなやり方は、各クラスのどの数値に対応づけるかを自分で定義して置き換える方法です。 pandas の Series インスタンスの replace() メソッド（あるいは map() メソッド）を使って値を置換できます。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;Level&#34;: [&#34;Easy&#34;, &#34;Normal&#34;, &#34;Hard&#34;, &#34;Hard&#34;, &#34;Easy&#34;] }) # 順序特徴量のマッピング定義 level_mapping = { &#34;Easy&#34;: 1, &#34;Normal&#34;: 2, &#34;Hard&#34;: 3 } # マッピング定義に従って変換 df[&#34;Level&#34;] = df[&#34;Level&#34;].replace(level_mapping) print(df) 実行結果 Level 0 1 1 2 2 3 3 3 4 1 逆変換をして元のラベルに戻すには次のようにします。 # 逆変換用のマッピング定義 inv_level_mapping = { val: key for key, val in level_mapping.items() } df[&#34;Level&#34;] = df[&#34;Level&#34;].replace(inv_level_mapping) scikit-learn の OrdinalEncoder を使う方法もありますが、逆にややこしかったりします。"},{url:"/p/nnhefs3/",title:"Vim/Neovim で OS のクリップボードを連動させる (clipboard, unnamed, unnamedplus)",date:"2024-06-11T00:00:00+09:00",body:"Vim/Neovim で OS のクリップボードを連動させる (clipboard, unnamed, unnamedplus) Vim/Neovim のデフォルト設定では、y でテキストをヤンク（コピー）したときに、OS のクリップボードにテキストの内容がコピーされません。 別のアプリ上で Ctrl+C でコピーした内容も、Vim の p でペーストすることができません。 これでは不便なので、多くの場合は次のように OS のクリップボードと連動させます。 Vim (.vimrc) や Neovim (init.vim) の場合 &#34; OS のクリップボードと連動させる set clipboard+=unnamed,unnamedplus Neovim (init.lua) の場合 -- OS のクリップボードと連動させる vim.opt.clipboard:append({ &#34;unnamed&#34;, &#34;unnamedplus&#34; }) 細かい説明をすると、unnamed というフラグは * レジスターとの連動、unnamedplus というフラグは + レジスターとの連動を意味するのですが、通常は上記のように両方とも設定しておけば問題ありません。 unnamed（* レジスター） &hellip; 主に Linux OS においてマウスで選択したテキスト（選択クリップボード）の内容を、Vim の p で貼り付けられるようにします。 unnamedplus（+ レジスター） &hellip; 一般的な OS における Ctrl+C 操作でコピーしたテキスト（通常のクリップボード）の内容を、Vim の p で貼り付けられるようにします。また、Vim 側で y でヤンクした内容が、OS 側のクリップボードにコピーされるようになります。"},{url:"/p/dnso7ds/",title:"Vim/Neovim の設定ファイルから別の設定ファイルを読み込む (source, dofile)",date:"2024-06-11T00:00:00+09:00",body:"Vim/Neovim の設定ファイルから別の設定ファイルを読み込む (source, dofile) 複数の環境で Vim や Neovim を使用しているときは、設定ファイルを GitHub や Dropbox などの共有サービスで共有すると便利です。 共有した設定ファイルは、Vim の :source や Neovim (Lua) の :dofile() などで読み込むことができます。 Vim (~/.vimrc) の場合 &#34; Linux/macOS の例 source $HOME/Dropbox/share/config/vim/vimrc &#34; Windows の例 source D:/Dropbox/share/config/vim/vimrc Neovim (~/.config/nvim/init.lua) の場合 -- Linux/macOS の例 local home = os.getenv(&#34;HOME&#34;) dofile(home .. &#34;/Dropbox/share/config/nvim/init.lua&#34;) -- Windows の例 dofile(&#34;D:/Dropbox/share/config/nvim/init.lua&#34;)"},{url:"/git/",title:"Git",date:"2024-04-11T00:00:00+09:00",body:"Git GitHub Pull Request のコードレビューワーを自動でアサインする GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages) GitHub Pages で独自の 404 ページを用意する GitHub の Organization を構成したときのチームの権限について理解する GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する GitHub の Markdown でメールアドレスへのリンクを記述する （旧）GitHub のプランと GitHub ライクなツールの比較など GitHub の REST API を使用する GitHub の REST API で Issue 情報を取得する方法いろいろ GitHub の REST API を Python から使用する GitHub で管理している社内リポジトリをトピックで分類する (topics) GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink) GitHub Actions GitHub Actions で GitHub wiki ページを自動更新する GitHub Actions のワークフローをローカルで実行する (act) GitHub で複数アカウントの SSH キーを使い分ける (~/.ssh/config) Git の基本 Git の作業ツリーを作成する (git init, git clone) Git でファイルの変更をステージする（コミットの印をつける）(git add, git rm, git mv) Git で変更をローカルリポジトリにコミットする コミット対象になっているファイルを確認する (git status) Git コマンドの長いオプション名を省略して入力する小技 Git の設定 設定全般 git config で設定すべき一般的な設定項目のまとめ Git 設定のスコープ (local/global/system) を理解する Git の設定値がどのファイルで設定されているか調べる (config --show-origin) git config による設定を削除する (config --unset) コミット時に使用するユーザ名とメールアドレスを設定する (user.name, user.email) コミット、チェックアウト時に改行コードを自動変換する (core.autocrlf, core.safecrlf) コミット時にコメント記述に使用するエディタを設定する (core.editor) Git コマンドの出力をカラフルにする (color.ui) Git コマンドのエイリアスを作成する (alias.xxx) Git コマンドで使用するプロキシを設定する (http.proxy) git プロトコルではなく強制的に https プロトコルで git clone するようにする (url.xxx) Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf) git diff や git status での日本語の文字化けを防ぐ (core.page, core.quotepath) Windows 用の設定 Windows の git diff で改行コードが ^M で表示される問題を解決する (core.whitespace) Windows でパーミッションの違いで diff が表示されてしまうのを防ぐ (core.filemode) msysGit で &ldquo;terminal is not fully functional&rdquo; と怒られる場合の対策 プロンプト設定 bash のプロンプトに Git のカレントブランチ名を表示する (PS1) .gitignore .gitignore ファイルで Git にバージョン管理させないファイルを指定する コミット／履歴の書き換え Git やり直し: 直前のコミットのコメントを修正する Git やり直し: 直前のコミットを取り消す Git やり直し: main ブランチに入れてしまったコミットを別のブランチに移す Git やり直し: 最近のコミットを歴史から抹消する Git やり直し: コミット履歴を書き換えてディレクトリ階層を変更する 変更の一部だけをコミットする ログ (git log) コミットログ表示の基本 コミットログの書き方 コミットログを絞り込んで表示する コミットログにファイル名や変更行数を表示する コミットログの出力形式をカスタマイズする (git log &ndash;pretty, &ndash;date) コミットログにある文字列が含まれているコミットを検索する (git log &ndash;grep) 変更内容にある文字列が含まれているコミットを検索する (git log -G/-S) 指定したディレクトリ以下の変更に関連するコミットログのみ表示する ブランチ間の差分を調べる リモートブランチとローカルブランチの差分を調べる コミットログを標準出力へ出力する 統計情報 ユーザーごとのコミット統計を出力する (git shortlog) あるバージョン間の変更行数（追加＆削除）を集計する (git diff &ndash;stat, git log &ndash;numstat) grep 検索 (git grep) Git リポジトリ内のコードを grep 検索する (git grep) ブランチ (git branch) ブランチを作成する (git branch) ブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) ブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) ブランチを削除する (git branch -d/D) ブランチ名を変更する (git branch -m) ブランチやタグの作者を調べる (git for-each-ref) 他の人が作成したブランチ上で作業する リモートブランチを削除する (git push origin :xxx, git fetch --prune) 他のブランチの最新ファイルを現在のブランチにコピーする (git checkout) detached HEAD 状態へのチェックアウトとは マージ (git merge, git cherry-pick) ブランチでの変更をマージする（直接マージ、スカッシュマージ、チェリーピック） マージ時のコンフリクトを解決する 別ブランチへの複数のコミットを１つのコミットとしてマージする (squash merge) マージのためのコミットを revert する（取り消す） マージ作業に失敗したときにやり直す マージで競合解決が必要なファイルを調べる マージベースとなったコミットを見つける（fast-forward の関係になっているか調べる） 別の Git リポジトリの内容を強引にマージする 差分・パッチファイル (git diff / patch) git diff でファイルの差分を調べる git diff で改行コードの違いを無視する git diff で単語単位で差分を表示する git diff の出力で相対パスを使うようにする git diff で package-lock.json の差分が表示されるのを防ぐ Git でパッチファイルを作成する ファイル操作 git clean で追跡されていないファイルを削除する ファイルを削除せずに Git によるバージョン管理の対象から外す (git rm &ndash;cached) コミットからファイルをチェックアウトする（ファイルを元に戻す） インデックスからファイルをチェックアウトする（ファイルを元に戻す） 特定のバージョンのファイルの内容を確認する (cat-file) タグ (git tag) コミットに対してタグをつけて中央リポジトリにプッシュする (git tag) タグの名前を変更する リポジトリ／サーバー／バックアップ 共有リポジトリを作成する git-daemon による読み取り専用リポジトリの公開 Git リポジトリを移行する リポジトリ内のディレクトリを別リポジトリに切り出す ローカルディレクトリをリモートリポジトリとして使用する リモートリポジトリに略称を付ける 共有リポジトリからの fetch と push ソースコードのアーカイブを作成する hook スクリプト Git の update フックの基本 特定のユーザのみ git push できるように制限する その他 Git 用語集 Git で N 個前のコミットを表現する Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当） git pull の引数省略の仕組み 二要素認証を設定した後に git コマンドが Authentication failed になる場合 Git サブモジュールで別リポジトリの内容を組み込む (git submodule) GitLab（GitHub クローン） GitLab をインストールする GitLab 関連サービスを起動／停止する GitLab のデータをバックアップ／リストアする 起動中の GitLab 関連サービスを調べる GitLab からの通知メールを設定する GitLab リポジトリの Clone URL として表示されるホスト名を変更する GitLab 用 nginx サーバの設定ファイルの場所 GitLab が使用する Unicorn 用のポート番号を変更する GitLab サーバのアクセスログを調べる オワコン情報 (Subversion とか CVS とか） git-svn を使って Git と Subversion を連携する CVS のファイルのパーミッションの扱いについて .svn ディレクトリをまとめて削除する"},{url:"/p/vn9aqfb/",title:"GitHub で複数アカウントの SSH キーを使い分ける (~/.ssh/config)",date:"2024-04-11T00:00:00+09:00",body:"GitHub で複数アカウントの SSH キーを使い分ける (~/.ssh/config) 1 つのクライアント PC で、複数の GitHub アカウントを使い分けたいことがあります。 典型的なのは以下のような 2 つのアカウントの切り替えです。 プライベートの GitHub アカウント 仕事用の GitHub アカウント GitHub の仕様上、複数の GitHub アカウントに同じ SSH キー（公開鍵）を登録することはできないようになっているため、GitHub アカウントごとに必ず異なる SSH キーペアを用意する必要があります。 つまり、クライアント側で接続時に使用する SSH キー（秘密鍵）を切り替えることが、すなわち GitHub アカウントの切り替えを意味します。 SSH クライアント（ssh コマンド）はデフォルトでは ~/.ssh/id_rsa などのパスに配置された SSH 秘密鍵を参照するようになっているため、なんらかの方法で SSH 秘密鍵を切り替えて GitHub に接続する必要があります。 ここでは、~/.ssh/config を使って、使用する SSH キー（秘密鍵）を切り替える方法を説明します。 （必要があれば）SSH キーペアの作成と GitHub への登録 すでに GitHub アカウントへの SSH キーの登録が済んでいる場合はこの説明は飛ばしてください。 SSH キーペアの作成 参考: SSH キーの管理: SSH キーを作成する (ssh-keygen) プライベートのアカウントと、仕事用のアカウントの SSH キーペアを作成します。 キータイプとしては、高速かつ強度のある Ed25519 鍵を使うことにしましょう。 それぞれのキーペアは、~/.ssh/github-maku、~/.ssh/github-work というディレクトリに保存することにします。 $ mkdir ~/.ssh/github-maku $ mkdir ~/.ssh/github-work $ ssh-keygen -t ed25519 -f ~/.ssh/github-maku/id_ed25519 $ ssh-keygen -t ed25519 -f ~/.ssh/github-work/id_ed25519 コマンドプロンプトの場合 cd %USERPROFILE% mkdir .ssh\\github-maku mkdir .ssh\\github-work ssh-keygen -t ed25519 -f .ssh\\github-maku\\id_ed25519 ssh-keygen -t ed25519 -f .ssh\\github-work\\id_ed25519 これで次のようなファイルが作成されます。 ~/.ssh/github-maku/id_ed25519 （プライベート用の秘密鍵） ~/.ssh/github-maku/id_ed25519.pub （プライベート用の公開鍵） ~/.ssh/github-work/id_ed25519 （仕事用の秘密鍵） ~/.ssh/github-work/id_ed25519.pub （仕事用の公開鍵） GitHub アカウントに SSH 公開鍵を登録 生成した SSH キーペアのうち、公開鍵の方をそれぞれの GitHub アカウントに登録します。 GitHub にサインインした状態で、Setting → SSH and GPGkeys のページを開く。 New SSH Key のボタンを押す。 Key の欄に公開鍵 (id_ed25519.pub) の内容を貼り付ける。 Title は何でもよいですが、接続元がわかるように付けておくとよいです（例: WORK-DESKTOP、PRIVATE-LAPTOP）。 SSH クライアントの設定 ~/.ssh/config の設定 参考: SSH キーの管理: SSH の接続先ごとにキーを使い分ける (~/.ssh/config) SSH クライアントの設定ファイル (~/.ssh/config) に次のように設定を追加します。 ~/.ssh/config Host github-maku Hostname github.com User git IdentityFile ~/.ssh/github-maku/id_ed25519 Host github-work Hostname github.com User git IdentityFile ~/.ssh/github-work/id_ed25519 Windows の場合 Windows に搭載された ssh コマンド (C:\\Windows\\System32\\OpenSSH\\ssh.exe) を使う場合も、IdentityFile に Unix 流のパス指定を行えます（~ や / が使えます）。 ただし、Windows 版の git.exe では、組み込みの ssh を使用することができるようになっており、こちらの ssh は内部的な振る舞いが若干異なります。 例えば、Windows 流のパス指定（ディレクトリセパレータはバックスラッシュ \\）を使わなければいけなかったり、HOME 環境変数が指定されているときに %USERPROFILE%/.ssh/config ではなく %HOME%/.ssh/config を参照したりします。 このような統一感のない振る舞いは厄介なので、Windows の git.exe をインストールするときは、外部の ssh コマンドを使用するオプションを選択することをおすすめします。 これで、単独の ssh コマンドを実行したときの振る舞いと、git コマンドで SSH 接続をしたときの振る舞いが共通化されます。 Host の行に指定した名前は、接続先のホストと SSH 秘密鍵をまとめて切り替えるための「接続名」として機能します。 名前の付け方は自由ですが、上記のように &lt;接続先&gt;-&lt;ユーザー&gt; という感じで付けておくとわかりやすいです。 ここでは、~/.ssh 以下に作成したディレクトリ名と合わせて github-maku、github-work としました。 Hostname と User の行は、上記のように GitHub 用の固定値 (github.com と git）を指定しておく必要があります。 IdentityFile には、それぞれの GitHub アカウントで使用する SSH 秘密鍵のパスを指定します。 ☝️ GitHub アカウント名は指定しなくてよいの？ ~/.ssh/config ファイルの中に GitHub アカウント名の記述がないことに気付いたかもしれません。 GitHub アカウントと SSH キーは、GitHub 内部で関連付けられて保持されています。 そのため、SSH 接続時に使用した SSH 秘密鍵から、どの GitHub アカウントで接続したのかが自動的に判別されるようになっています。 接続テスト ~/.ssh/config で定義した接続名で、GitHub に SSH 接続できるかを確認するには次のようにします。 $ ssh -T github-maku Hi maku77! You&#39;ve successfully authenticated, but GitHub does not provide shell access. レスポンスメッセージを見ると、どの GitHub アカウントとして接続されたかが分かります（上記の例では maku77 です）。 ちなみに、github-maku の部分を通常のホスト名 github.com に変えると、デフォルトのパスに置かれた SSH キー（~/.ssh/id_rsa や ~/.ssh/id_ed25519）が使われます。 git コマンドで使用する GitHub アカウントを切り替える git コマンドの接続先は、origin URL として設定されています。 $ git config --get remote.origin.url git@github.com:maku77/private-repo この URL 内の github.com の部分を、~/.ssh/config で定義した接続名に置き換えることで、使用する SSH 秘密鍵（≒ GitHub アカウント）を切り替えることができます。 git clone 時に接続名を指定する もっとも単純なのは、git clone 時に接続名を指定する方法です。 git clone 時に接続名を指定する # プライベートのアカウントで接続する $ git clone github-maku:maku77/private-repo # 仕事用のアカウントで接続する $ git clone github-work:yourcompany/private-repo github-maku の部分を git@github-maku と記述してもよいですが、ユーザー ID は ~/.ssh/config で指定しているので省略できます。 origin URL を書き換える すでに clone 済みのリポジトリがある場合は、その origin URL だけ変更するという方法があります。 $ git remote set-url origin github-maku:maku77/private-repo このコマンドが覚えられない場合は、エディタで .git/config を開いて編集してしまうのでもよいです（こっちの方が楽かも）。 ちゃんと設定されたかは、次のように確認します。 $ git config --get remote.origin.url github-maku:maku77/private-repo # あるいは $ git remote -v origin github-maku:maku77/private-repo (fetch) origin github-maku:maku77/private-repo (push) コミットログ用の名前とメールアドレスの設定 ここまでの説明は、あくまで SSH 接続で使う秘密鍵の切り替え方法であり、git commit 時にログとして残す「名前」や「メールアドレス」は、別途 Git クライアントの設定として切り替える必要があります。 $ git config --local user.name &#34;Taro Yamada&#34; $ git config --local user.email &#34;taro.yamada@example.com&#34; この設定をリポジトリ毎に行うのが面倒な場合は、ディレクトリパスに応じて自動的に切り替える方法があります。 参考: Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf)"},{url:"/p/q3a7jg4/",title:"JavaScript の yield を使ってイテレート可能な関数（ジェネレーター関数）を定義する",date:"2024-03-13T00:00:00+09:00",body:"JavaScript の yield を使ってイテレート可能な関数（ジェネレーター関数）を定義する JavaScript の関数内で yield キーワードを使用すると、関数の呼び出し側でイテレート処理（ループ処理）が可能な関数を定義することができます。 値を生成する関数になるので、ジェネレーター関数 と呼ばれます。 ☝️ ワンポイント yield キーワードは ES2015 (ECMAScript 6) で導入されました。 ジェネレーター関数の基本 下記は number 値を生成するジェネレーター関数の実装例です（TypeScript の型としては Generator を使います）。 ジェネレーター関数を定義するときは、function の代わりに function* を使います。 シンプルなジェネレーター関数 function* counter(): Generator&lt;number&gt; { yield 1; yield 2; yield 3; } ジェネレーター関数が生成する次の値を取得するには、next() メソッドを使用します。 next() メソッドは、value プロパティと done プロパティを持つ IteratorResult を返します。 すべての値の生成が終わると（ジェネレーター関数が return すると）、value プロパティの値は undefined になります。 const gen = counter(); console.log(gen.next().value); // 1 console.log(gen.next().value); // 2 console.log(gen.next().value); // 3 console.log(gen.next().value); // undefined ジェネレーター関数内の処理は、yield が実行されたタイミングで一時停止します。 呼び出し側で next() メソッドが呼び出されたときに実行が再開されます。 ジェネレーターのループ処理 ジェネレーターを for-of ループで処理すると、生成された値を最後まで取得することができます。 このとき、自動的に value プロパティの値を取り出してくれるので、次のようなシンプルなコードで処理できます。 const gen = counter(); for (const num of gen) { console.log(num); } 実行結果 1 2 3 非同期なジェネレーター関数 非同期に実行されるジェネレーター関数を定義することもできます。 戻り値の型は Generator ではなく、AsyncGenerator になります。 AsyncGenerator の next() メソッドを呼び出すと、次の値を取得するための Promise オブジェクトが返されます。 非同期ジェネレーター関数 async function* stringGenerator(): AsyncGenerator&lt;string&gt; { const strs = [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;pen&#39;]; for (const s of strs) { yield await Promise.resolve(s); } } const gen = stringGenerator(); for await (const s of gen) { console.log(s); } 下記はもう少し非同期っぽく、1 秒おきに yield するようにした例です。 async function* stringGenerator(): AsyncGenerator&lt;string&gt; { const strs = [&#39;This&#39;, &#39;is&#39;, &#39;a&#39;, &#39;pen&#39;]; for (const s of strs) { // 1 秒おきに yield yield await new Promise((resolve) =&gt; { setTimeout(() =&gt; resolve(s), 1000); }); } } const gen = stringGenerator(); for await (const s of gen) { console.log(s); }"},{url:"/rust/",title:"Rust",date:"2024-02-21T00:00:00+09:00",body:"Rust はじめに（Rust の実行環境） Rust プログラミングを始める（rustc と cargo コマンド） Rust で自作したプログラムをシステムにインストールする (cargo install) Rust の文法 制御構文 (if, match, while, loop, for) 配列 (array) とタプル (tuple) 構造体 (struct) とタプル構造体 (tuple struct) 所有権 (ownership) と借用 (borrow) 列挙型 (enum) の定義と match, if let による照合 パニック (panic) の扱いについて ジェネリクス構造体・関数を定義する（任意の型を扱えるようにする） オブジェクトのライフタイム（生存期間）を理解する ('static, 'a) 標準ライブラリが提供する型 Option 型の基本 ─ 値の有無を表現する型 Result 型の基本 ─ 成功と失敗を表現する型 (Result::Ok, Result::Error) 各種ライブラリのエラー型と Error トレイト Result 型エイリアスでコードを簡潔にする Result オブジェクトを消費せずに参照する (as_ref, as_mut) ? 演算子でエラーを伝搬させる コレクション ベクター型 (Vec) を扱う ハッシュマップ型 (HashMap) を扱う プロジェクト構成（パッケージ／クレート／モジュール） モジュールを定義する (mod) 文字列と数値 数値 複数の数値の中から最小値・最大値を見つける (min, max) 数値を特定の範囲に収まるように修正する (clamp, min, max) 入出力 (I/O)、ファイル ユーザー入力 コマンドライン引数を扱う (1) std::env::args コマンドライン引数を扱う (2) clap クレート キーボードからの入力を取得する (std::io::Stdin) ファイル／ディレクトリ／パス情報 ディレクトリ内のファイルを列挙する (std::fs::read_dir) ファイルやディレクトリの名前を変更（移動）する (std::fs::rename) ディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all) ファイルやディレクトリのパス文字列を構築／分割する (std::io::Path, PathBuf) ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf) ファイルの読み書き JSON フォーマットを扱う (serde) Excel ファイルを読み込む (calamine) Rust の非同期ランタイム tokio の使い方 (async, await, Future) Web / データベース Rust で HTTP サーバーを作る (axum) Rust で MongoDB を扱う (mongodb) その他 正規表現を扱う (regex) 型の名前を取得する (std::any::type_name) おすすめ書籍 『Programming Rust』 Rust 文法を正しく理解するのに最適な本です。 『Rust for Rustaceans』 Rustacean（Rust プログラマー）としてよりよいコードを記述するための本です。"},{url:"/p/6nce7nw/",title:"Rust の ? 演算子でエラーを伝搬させる",date:"2024-02-21T00:00:00+09:00",body:"Rust の ? 演算子でエラーを伝搬させる エラーの伝搬 (propagating errors) とは Rust でエラーを返す可能性のある関数（Result を返す関数）を呼び出すとき、その戻り値を受けて直ちにエラー処理を行うことは少なく、多くの場合は呼び出し元にエラーを返す（Error 値を伝搬させる）ことになると思います。 let book = match get_book(123) { Ok(book) =&gt; book, Err(err) =&gt; return Err(err.into()), // 呼び出し元にエラーを伝搬 }; このようなケースで、毎回 match を使った条件分岐コードを記述していると、冗長なコードで溢れかえってしまいます。 そこで、Rust はエラーを呼び出し元に伝搬させるための ? 演算子を用意しています（Rust 1.13 以降）。 ? 演算子の使い方 let book = get_book(123)?; このように記述すると、get_book() 関数の戻り値が Result::Ok だった場合はそれを unwrap() した値が book 変数に格納され、戻り値が Result::Err だった場合はそのエラーをそのまま return してくれます。 つまり、前述の match を使ったコードと同じ振る舞いを 1 行で表現することができます。 ? 演算子は、Option を戻り値として返す関数の中でも使用することができます。 その場合、エラー発生時は Option::None を返すという振る舞いになります。 main 関数での具体的な使用例 main() 関数の戻り値の型が、Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; になっているのを見たことがあるかもしれません。 Box&lt;dyn std::error::Error&gt; という型は、Error トレイトを実装したあらゆる型を保持することができる Box 型です。 このような表現にしておくことで、その関数はあらゆる Error 型を返す可能性があることを示すことができます。 例えば、下記の main() 関数は戻り値として汎用的な Result 型を返すように定義しています。 この関数の中では、どんなエラーを返す関数呼び出しでも ? 演算子を使うことができます。 main() 関数の中から、明示的に独自のエラーを返すこともできます。 src/main.rs use std::{env, fs::File, io::Read}; // どんなエラーも扱える Result 型 type Result = std::result::Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;; fn main() -&gt; Result { let args: Vec&lt;String&gt; = env::args().collect(); if args.len() &lt; 2 { eprintln!(&#34;Usage: {} &lt;file&gt;&#34;, args[0]); return Err(&#34;No file specified&#34;.into()); } // ファイルを開いて読み込む let filename = &amp;args[1]; let mut file = File::open(filename)?; // エラーの可能性 let mut buf = String::new(); file.read_to_string(&amp;mut buf)?; // エラーの可能性 // ファイルの内容を出力 println!(&#34;{}&#34;, &amp;buf); Ok(()) } 実行結果 $ cargo run -q -- hoge.txt Error: Os { code: 2, kind: NotFound, message: &#34;指定されたファイルが見つかりません。&#34; }"},{url:"/p/z6e9or8/",title:"Rust の非同期ランタイム tokio の使い方 (async, await, Future)",date:"2024-02-17T00:00:00+09:00",body:"Rust の非同期ランタイム tokio の使い方 (async, await, Future) tokio とは tokio は、Rust 用の非同期処理ランタイムです。 さらに、ネットワークアプリケーションの構築に必要な TCP ソケットなどのライブラリも含まれています。 Rust 言語には、コード上で非同期処理を表現するための async/await 構文が用意されていますが、実際に非同期処理を動かすためのランタイムは標準搭載されていません。 非同期処理用の代表的なランタイムが tokio クレートです。 Rust の async は、ソフトウェアにより非同期処理を実現する仕組みであり、スレッド (std::thread) と比べてコンテキストスイッチのコストがかからないという利点があります。 非同期ランタイムの tokio はサードパーティライブラリとして提供されていますが、非同期処理で使われる Future トレイトなどは Rust に標準搭載されています。 tokio の依存関係の追加 tokio を使用するには、cargo add コマンドで Rust プロジェクトに依存関係を追加します。 ここでは、tokio のすべての機能を有効化するために --features full オプションを指定しています。 $ cargo new myapp # （必要があれば）新規プロジェクトを作成 $ cd myapp $ cargo add tokio --features full cargo add コマンドを使用する代わりに、次のように Cargo.toml ファイルに依存関係を記述しても OK です。 Cargo.toml [dependencies] tokio = { version = &#34;1.36.0&#34;, features = [&#34;full&#34;] } async/await による非同期処理 下記は Rust の async/await 構文の基本的な使い方です。 src/main.rs // 非同期関数は async fn で定義する async fn say_world() { println!(&#34;World&#34;); } #[tokio::main] async fn main() { let future = say_world(); // Future インスタンスが返される println!(&#34;Hello&#34;); // say_world() より先に実行される future.await; // ここで say_world() が実行される } 実行結果 $ cargo run -q Hello World 非同期実行する関数を定義するには、async fn という構文を使用します。 上記の say_world 関数と main 関数は両方とも非同期関数として定義されています。 非同期関数は say_world() のように通常の関数と同じ形で呼び出せますが、このタイミングでは実行されず、代わりに Future インスタンス（Future トレイトを実装した型）を返します。 Future インスタンスが指す非同期関数が実際に実行されるのは、.await を呼び出したときです。 結果として、上記の main 関数を実行すると、Hello、World の順番で出力されます。 .await の呼び出しは、非同期関数 (async fn) の中でしか許可されていません。 上記の main 関数は非同期関数として定義されているので、.await の呼び出しが可能です。 main 関数は非同期処理が可能なコンテキスト（＝ランタイム）で実行されなければいけないので、#[tokio::main] というアノテーションをつけて、非同期処理ランタイムの tokio で実行するよう指示しています。 tokio::spawn で非同期処理をすぐに開始する 前述の例からもわかるように、Future インスタンスの .await を呼び出すまでは、非同期関数の実行は開始されません（これは他の言語とは異なる部分かもしれません）。 でも、これだと、その非同期処理が終わるまでそこで待機してしまうので、他の非同期関数を並行して動かすことができません。 Future が指し示す非同期関数を直ちに実行開始するには、tokio::spawn() に Future インスタンスを渡します。 次の例では、実行完了までに 3 秒かかる関数 (process) を、2 回連続して呼び出しています。 src/main.rc use tokio::time::{sleep, Duration}; // 実行に 3 秒かかる非同期処理 async fn process(name: &amp;str) -&gt; String { println!(&#34;START: {}&#34;, name); sleep(Duration::from_secs(3)).await; println!(&#34;END: {}&#34;, name); format!(&#34;result from {}&#34;, name) } #[tokio::main] async fn main() { // 2 つの Future を取得 let future1 = process(&#34;process-1&#34;); let future2 = process(&#34;process-2&#34;); // Future が示す非同期処理を開始する let task1 = tokio::spawn(future1); let task2 = tokio::spawn(future2); // 非同期処理が完了するのを待つ let result1: String = task1.await.unwrap(); println!(&#34;{}&#34;, result1); let result2: String = task2.await.unwrap(); println!(&#34;{}&#34;, result2); } 実行結果 $ cargo run -q START: process-1 START: process-2 （3 秒待つ） END: process-2 END: process-1 result from process-1 result from process-2 3 秒かかる 2 つの処理を同期実行したら 6 秒かかるところですが、ここでは spawn() で 2 つの非同期処理をほぼ同時に実行開始しているので、合計で 3 秒しかかかりません。 spawn() で開始した非同期処理が完了するのを待機するには、spawn() が返す JoinHandle の .await を呼び出します。 2 つ以上の非同期処理がすべて完了するまで待機したいときは、JoinHandle の .await を個別に呼び出すのではなく、tokio::try_join!() にすべての JoinHandle を渡します。 それぞれの非同期処理の結果はタプルとしてまとめて返されます。 // すべての非同期処理が完了するのを待つ let results = tokio::try_join!(task1, task2).unwrap(); println!(&#34;{}, {}&#34;, results.0, results.1);"},{url:"/p/q49pmjt/",title:"Rust で HTTP サーバーを作る (axum)",date:"2024-02-16T00:00:00+09:00",body:"Rust で HTTP サーバーを作る (axum) axum とは axum は Rust 用の Web フレームワークです。 Repo: https://github.com/tokio-rs/axum/ Docs: https://docs.rs/axum/latest/axum/ axum は Rust の非同期処理ランタイムの代表格である tokio のサブプロジェクトとして公開されました。 そのため、axum を使ったアプリケーション実装では、tokio が提供するフレームワークを組み合わせて使用します。 参考: Rust の非同期ランタイム tokio の使い方 (async/await) Rust 用の Web フレームワークには、他にも Actix Web (actix-web) や Rocket (rocket) などがありますが、axum は後発の Web フレームワークで、公開直後の 2022 年頃から利用者が急増しています。 この人気っぷりは、やはり tokio ファミリーのプロジェクトであることが大きいのでしょう。 axum は、他のフレームワークと違って、get や post マクロなどを使わないのが特徴的で、マクロ疲れしている人にはぴったりです。 その代わりに、リクエストをハンドルする関数に、extractor と呼ばれる引数を配置することで、リクエストの情報を抽出します。 例えば、次のような extractor を、ハンドラー関数の引数として任意の数だけ配置できます。 axum::extract::Path &hellip; パスパラメーター（URL 内のパスの部分的なセグメント）を抽出する axum::extract::Query &hellip; URL の末尾のクエリパラメーターを抽出する axum::extract::Json &hellip; POST メソッドのペイロードとして送られてきた JSON データを抽出する axum::extract::Request &hellip; リクエスト全体を抽出する http::header::Method &hellip; リクエストメソッドを抽出する http::header::HeaderMap &hellip; リクエストヘッダーを抽出する String &hellip; リクエスト本文をそのまま utf-8 文字列で取得する 下記はリクエストに使われた HTTP メソッドとヘッダー、本文（ペイロード）を参照するハンドラー関数の引数の例です。 use axum::http::{Method, HeaderMap}; async fn handler( method: Method, // メソッドを取得したいときはこの引数を配置 headers: HeaderMap, // ヘッダーを取得したいときはこの引数を配置 body: String, // 本文を取得したいときはこの引数を配置 ) { // ... } ここでは、axum を使ってシンプルな HTTP サーバーを実装してみます。 プロジェクトの作成 まず、Rust のプロジェクトを作成します。 ここでは、http-server という名前にします。 プロジェクトの作成 $ cargo new http-server $ cd http-server 必要なライブラリの依存関係を追加します。 通常は、非同期ランタイムの tokio や JSON を扱うための serde も必要になります。 依存情報の追加 $ cargo add axum $ cargo add tokio --features full # 非同期ランタイム $ cargo add serde --features derive # シリアライズ＆デシリアライズ $ cargo add serde_json まずは Hello World サーバーを作ってみる 下記は、Hello, World! というテキストを返すだけの、シンプルな Web サーバーの実装例です。 src/main.rs use axum::{routing::get, Router}; use tokio::net::TcpListener; #[tokio::main] async fn main() { let app = Router::new().route(&#34;/&#34;, get(root)); let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } // 文字列だけを返すハンドラーは、ステータスコード `200 OK` の // `content-type: text/plain; charset=utf-8` のレスポンスになる。 async fn root() -&gt; &amp;&#39;static str { &#34;Hello, World!&#34; } 処理の流れはほとんど明らかだと思いますが、URL のルートパス / に GET メソッドでアクセスしたら root という名前のハンドラー関数が呼ばれる、という実装ですね。 次のようにして Web サーバーを起動できます。 $ cargo run Web サーバーを起動した状態で、別のターミナルや Web ブラウザから http://localhost:8080 にアクセスして、メッセージが返ってきたら成功です。 $ curl localhost:8080 Hello, World! シンプル！ リクエスト時のパスを取得する (axum::extract::Path) リクエストされた URL に含まれるパス情報（例: example.com/users/123 の 123 の部分）を取得したいときは、axum の extractor のひとつである axum::extract::Path を使用します。 次の例では、/users/:id というパスに対するハンドラー関数 get_user() を定義し、:id の位置で指定されたパス文字列を取得しています。 src/main.rs use axum::{extract::Path, routing::get, Router}; use tokio::net::TcpListener; #[tokio::main] async fn main() { let app = Router::new().route(&#34;/users/:id&#34;, get(get_user)); let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn get_user(Path(id): Path&lt;String&gt;) -&gt; String { format!(&#34;User ID: {}&#34;, id) } 実行結果 $ curl 127.0.0.1:8080/users/123 User ID: 123 ちなみに、/users/:user_id/team/:team_id のように 2 つ以上のパスパラメーターを抽出するときは、次のようにタプルを使います。 async fn users_teams_create( Path((user_id, team_id)): Path&lt;(String, String)&gt;, ) { // ... } リクエスト時のクエリ文字列を取得する (axum::extract::Query) 同様に、URL の末尾に指定されたクエリ文字列（例: example.com/search?genre=ACT&amp;year=2000 の genre=ACT&amp;year=2000 の部分）を取得したいときは、axum::extract::Query を使用します。 serde のデシリアライズ機能を使うことで、クエリパラメーターを構造体の形で参照できます。 src/main.rs use axum::{extract::Query, routing::get, Router}; use serde::Deserialize; use tokio::net::TcpListener; #[tokio::main] async fn main() { let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app_router()).await.unwrap(); } fn app_router() -&gt; Router { // クエリパラメーターの型 #[derive(Deserialize, Debug)] #[allow(dead_code)] struct SearchQuery { genre: Option&lt;String&gt;, year: Option&lt;usize&gt;, } // クエリパラメーターのデフォルト値 impl Default for SearchQuery { fn default() -&gt; Self { Self { genre: None, year: None, } } } async fn search(query: Option&lt;Query&lt;SearchQuery&gt;&gt;) -&gt; String { // いずれかのクエリパラメーターが不正な型だった場合は、すべてデフォルト値になる let Query(search_query) = query.unwrap_or_default(); format!(&#34;{:?}&#34;, search_query) } Router::new().route(&#34;/search&#34;, get(search)) } 下記はいろいろなクエリパラメーターでリクエストしたときの、レスポンスの例です。 パラメーターの型が不正なとき（例: year=ABC）は、すべてのパラメーターをデフォルト値（今回はすべて None）として扱っています。 実行結果 $ curl &#34;127.0.0.1:8080/search&#34; SearchQuery { genre: None, year: None } $ curl &#34;127.0.0.1:8080/search?genre=RPG&#34; SearchQuery { genre: Some(&#34;RPG&#34;), year: None } $ curl &#34;127.0.0.1:8080/search?genre=RPG&amp;year=2000&#34; SearchQuery { genre: Some(&#34;RPG&#34;), year: Some(2000) } $ curl &#34;127.0.0.1:8080/search?genre=ACT&amp;year=ABC&#34; SearchQuery { genre: None, year: None } リクエストのメソッドやヘッダー情報を取得する HTTP リクエストに使われたメソッド（GET や POST）を取得したいときは、ハンドラー関数の引数として Method を追加します。 同様に、リクエストヘッダー情報を取得したいときは、ハンドラー関数の引数として HeaderMap を追加します。 src/main.rs use axum::{ http::{HeaderMap, Method}, routing::get, Router, }; use tokio::net::TcpListener; #[tokio::main] async fn main() { // パス `/` で GET と POST の両方をハンドルする let app = Router::new().route(&#34;/&#34;, get(handler).post(handler)); let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn handler( method: Method, // メソッドの extractor headers: HeaderMap, // ヘッダーの extractor ) { println!(&#34;{:?}&#34;, method); println!(&#34;{:?}&#34;, headers); } 下記は、curl コマンドで HTTP リクエストを送ったときのサーバー側の出力を示しています。 実行結果 $ curl &#34;127.0.0.1:8080&#34; GET {&#34;host&#34;: &#34;127.0.0.1:8080&#34;, &#34;user-agent&#34;: &#34;curl/7.79.1&#34;, &#34;accept&#34;: &#34;*/*&#34;} $ curl -X &#34;127.0.0.1:8080&#34; POST {&#34;host&#34;: &#34;127.0.0.1:8080&#34;, &#34;user-agent&#34;: &#34;curl/7.79.1&#34;, &#34;accept&#34;: &#34;*/*&#34;} $ curl &#34;localhost:8080&#34; -H &#34;key:value&#34; GET {&#34;host&#34;: &#34;localhost:8080&#34;, &#34;user-agent&#34;: &#34;curl/7.79.1&#34;, &#34;accept&#34;: &#34;*/*&#34;, &#34;key&#34;: &#34;value&#34;} ステートを保持する (with_state) HTTP はステートレスなプロトコルなので、基本的に各リクエストは独立したものになりますが、Router.with_state() メソッドを使うと、リクエスト間で任意のステート情報を共有することができます。 例えば、次のような用途で使用できます。 アプリケーションの共通設定 データベース接続のプール セッション管理、認証情報の保持 ロードに時間がかかるデータのキャッシュ 次の例では、ステートとして AppState 構造体の値を保持しています。 Router.with_state() でセットしたステート情報は、各ハンドラーの引数として State extractor を配置することで受け取ることができます。 src/main.rs use axum::extract::State; use axum::{routing::get, Router}; use std::sync::Arc; use tokio::net::TcpListener; use tokio::sync::Mutex; // リクエスト間で共有するステートの型 struct AppState { message: String, counter: Mutex&lt;u64&gt;, } #[tokio::main] async fn main() { // ステートの初期化 let app_state = Arc::new(AppState { message: String::from(&#34;Welcome!&#34;), counter: Mutex::new(0), }); let app = Router::new() .route(&#34;/&#34;, get(root)) .with_state(app_state); // ルーター内でステートを共有 let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } // ハンドラーの引数としてステートを受け取る async fn root(State(app_state): State&lt;Arc&lt;AppState&gt;&gt;) -&gt; String { let mut counter = app_state.counter.lock().await; *counter += 1; format!(&#34;{} {}&#34;, app_state.message, *counter) } ハンドラーの中でステートの counter 値をインクリメントしているので、curl や Web ブラウザーでアクセスするたびに次のように出力が変わります。 実行結果 $ curl 127.0.0.1:8080 Welcome! 1 $ curl 127.0.0.1:8080 Welcome! 2 $ curl 127.0.0.1:8080 Welcome! 3 POST リクエストで送られた JSON データを取得する POST メソッドで送られてきた本文を単純な utf-8 文字列として取得するだけであれば、次のようにハンドラー関数に String 型の引数を追加するだけですみます。 async fn handler(body: String) { println!(&#34;{}&#34;, body); } ただ、REST API などを実装しているときは、本文として送られてくるデータは JSON 形式になっていることがほとんどなので、このデータを構造体インスタンスとして参照できると便利です。 axum の JSON extractor と、serde の Deserialize 属性を使うことでこれを実現できます。 次の例では、本文として送られてきた JSON データを CreateTodoPayload 構造体として参照しています。 src/main.rs use axum::{extract::Json, routing::post, Router}; use serde::Deserialize; use tokio::net::TcpListener; #[derive(Debug, Deserialize)] struct CreateTodoPayload { title: String, // 必須のフィールド note: Option&lt;String&gt;, // 省略可能なフィールド } #[tokio::main] async fn main() { let app = Router::new().route(&#34;/todos&#34;, post(create_todo)); let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn create_todo(Json(payload): Json&lt;CreateTodoPayload&gt;) -&gt; String { let title = payload.title; let note = payload.note.unwrap_or_default(); // 省略時は空文字列とする format!(&#34;Created: title={}, note={}&#34;, title, note) } 実行結果 $ curl -X POST &#39;localhost:8080/todos&#39; \\ -H &#39;Content-Type: application/json&#39; \\ --data &#39;{&#34;title&#34;: &#34;Title-1&#34;, &#34;note&#34;: &#34;Note-1&#34;}&#39; Created: title=Title-1, note=Note-1 レスポンスとして JSON データを返す 構造体データを JSON 形式のレスポンスとして返したいときは、ハンドラー関数の戻り値で axum::Json を返します（axum::reponse::Json でも OK）。 Json コンストラクターには、serde の Serialize 属性をつけた構造体インスタンスを渡します。 src/main.rs use axum::{extract::Path, routing::get, Json, Router}; use serde::Serialize; use tokio::net::TcpListener; #[derive(Debug, Serialize)] struct UserInfo { id: String, name: String, } #[tokio::main] async fn main() { let app = Router::new().route(&#34;/users/:id&#34;, get(get_user)); let listener = TcpListener::bind(&#34;0.0.0.0:8080&#34;).await.unwrap(); axum::serve(listener, app).await.unwrap(); } async fn get_user(Path(user_id): Path&lt;String&gt;) -&gt; Json&lt;UserInfo&gt; { // 本当はデータベースなどからユーザー情報を取得する let user_info = UserInfo { id: user_id.clone(), name: format!(&#34;User-{}&#34;, user_id), }; // JSON 形式のレスポンスとして返す Json(user_info) } 実行結果 $ curl &#39;127.0.0.1:8080/users/123&#39; {&#34;id&#34;:&#34;123&#34;,&#34;name&#34;:&#34;User-123&#34;}"},{url:"/p/4xyn2kv/",title:"Matplotlib によるプロットの例（散布図）",date:"2024-02-09T00:00:00+09:00",body:"Matplotlib によるプロットの例（散布図） Python の Matplotlib によるプロットの例です。 すぐに忘れてしまうのでメモメモ( ..)φ 散布図 (scatter diagram) 2 つの特徴量を X/Y 座標値としてプロット 図: 散布図の例 テスト用のサンプルデータ（アヤメの分類データ） def load_data(): from sklearn import datasets iris = datasets.load_iris() # 各サンプルの特徴量には下記の 4 つが含まれている # - sepal length (cm) # - sepal width (cm) # - petal length (cm) # - petal width (cm) features = iris.data # 各サンプルの正解ラベルとして下記のいずれかが含まれている # - 0: setosa # - 1: versicolor # - 2: virginica targets = iris.target return features, targets import matplotlib.pyplot as plt features, targets = load_data() # 2 つの特徴量を X/Y 座標値とした散布図を描画 fig, ax = plt.subplots(figsize=(6, 4), layout=&#34;tight&#34;) ax.set_xlabel(&#34;speal length (cm)&#34;) ax.set_ylabel(&#34;sepal width (cm)&#34;) ax.scatter(x=features[:, 0], y=features[:, 1]) fig.savefig(&#34;img-scatter.svg&#34;) plt.show() Matplotlib で散布図を描画するには、scatter 関数を使用します。 散布図のどの座標に点を打つかは、x、y 引数に、X 軸と Y 軸の座標値リストを渡すことで指示します。 ここでは、features[:, 0] で「speal length (cm)」のリスト、features[:, 1] で「speal width (cm)」のリストを取り出して渡しています。 各点に意味を持たせる 図: 散布図の例 (2) scatter 関数に X/Y 座標値だけを渡すと、前述の例のように、すべての点が同じ記号で表示されます。 c 引数で、各点の値のリストを渡すことで、異なる色で点を打つことができます。 import matplotlib.pyplot as plt features, targets = load_data() # 2 つの特徴量を X/Y 座標値とした散布図を描画 fig, ax = plt.subplots(figsize=(6, 4), layout=&#34;tight&#34;) ax.set_xlabel(&#34;speal length (cm)&#34;) ax.set_ylabel(&#34;sepal width (cm)&#34;) scatter = ax.scatter(x=features[:, 0], y=features[:, 1], c=targets) ax.legend(*scatter.legend_elements()) # 各点の値の凡例を表示 fig.savefig(&#34;img-scatter-2.svg&#34;) plt.show() ちなみに、c 引数で渡している targets 変数には、次のような正解ラベル (0, 1, 2) が含まれています。 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]"},{url:"/docker/",title:"Docker",date:"2024-01-31T00:00:00+09:00",body:"Docker Docker をはじめる（インストールと設定） Docker をインストールする (Docker Desktop / Docker Engine) Docker のプロキシ設定 一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録） Docker の基本的な使い方 Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run) Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach) Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs) Docker Compose の基本（docker コマンドを使いやすくする） Docker コマンドによる操作 Docker チートシート／Docker コマンドの一覧 イメージ (docker image) Docker のコンテナイメージを作成する (docker image build, docker container commit) Docker のコンテナイメージを削除する (docker image rm/prune) （応用）リポジトリ名のついていない Docker イメージをすべて削除する (docker image rm) Docker のコンテナイメージを Docker Hub に登録する (docker image push) Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する Docker Hub のイメージを検索する (docker search) コンテナ (docker container) Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top) Docker コンテナの詳細情報を表示する (docker container inspect) Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port) すべての Docker コンテナを停止／削除する (docker container stop/rm) Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp) ネットワーク (docker network) Docker のネットワークについて理解する (none, host, bridge) Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal) Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh) マウント（ボリューム、バインドマウント、tmpfs マウント） Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfsマウント） Docker Compose Docker Compose の基本 (docker compose up) Docker Compose をデタッチモードで起動する (docker compose up -d) Docker Compose で環境変数を使用する (env_file, environment) Docker コンテキスト (docker context) Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する その他 サーバー再起動時に Docker コンテナを自動起動する トラブルシューティング Docker で apt-get install するときに TERM 系のエラーが出る Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき （旧）Android ビルド環境を構築するための Dockerfile"},{url:"/p/rh8qm2n/",title:"サーバー再起動時に Docker コンテナを自動起動する",date:"2024-01-31T00:00:00+09:00",body:"サーバー再起動時に Docker コンテナを自動起動する VPS などのサーバーを再起動したときに Docker コンテナを自動起動するには、docker container run コマンドでコンテナを起動するときに、--restart フラグを付けて 再起動ポリシー を設定します。 $ docker run -d --restart always redis Docker Compose ファイルを使う場合は次のように記述します。 docker-compose.yml version: &#39;3.8&#39; services: redis: image: redis container_name: redis restart: always 起動方法 $ docker compose up -d 正確には VPS サーバーの再起動時というより、Docker デーモンの再起動時に、コンテナの再起動ポリシーによりコンテナが再起動されるという流れになります。 VPS サーバーが起動したときに Docker デーモンを自動起動するようにする設定は、systemd などのプロセスマネージャーで別途設定しておく必要があります。 ☝️ ワンポイント VPS サーバー再起動時の Docker コンテナー自動起動の流れ: プロセスマネージャー (systemd) により Docker デーモンが起動する Docker の再起動ポリシーによりコンテナが起動する"},{url:"/p/tzwio3y/",title:"corepack を使ってプロジェクト内で使用する pnpm/yarn のバージョンを管理する",date:"2024-01-25T00:00:00+09:00",body:"corepack を使ってプロジェクト内で使用する pnpm/yarn のバージョンを管理する corepack とは Node.js の実行環境には、パッケージマネージャーとして標準で npm コマンドが搭載されていますが、npm の代わりに yarn や pnpm などを導入しているプロジェクトが多くあります。 従来は、これらのコマンドを npm install -g pnpm のように別途インストールする必要がありましたが、Node.js に標準搭載された corepack の仕組みを使用すると、初めからインストールされているかのようにyarn や pnpm コマンドを実行できるようになります。 corepack が使用するパッケージマネージャーは、package.json の packageManager プロパティで宣言しておくことができるので、プロジェクト内で使用するパッケージマネージャーとそのバージョンを統一できます。 ☝️ ワンポイント package.json の packageManager フィールドはプロジェクトが使うパッケージマネージャーとそのバージョンを宣言しているだけで、このフィールドは corepack 専用のフィールドというわけではありません。 あくまで、システムの Node.js 環境で corepack が有効化されている場合に、このフィールドの内容に基づいて yarn や pnpm のバージョンが自動制御される、ということです。 最初の準備（既存の yarn/pnpm の削除と corepack の有効化） もし、npm install や brew でグローバルインストールした yarn や pnpm がある場合は、もう必要ないのでアンインストールしておきましょう。 不要な yarn や pnpm はアンインストール $ npm uninstall -g yarn $ npm uninstall -g pnpm $ brew uninstall yarn $ brew uninstall pnpm corepack コマンドは Node.js 環境に組み込まれていますが、Node.js 21 の時点ではまだ実験段階 (experimental status) のため、corepack enable コマンドを実行して明示的に有効化 (Opt-in) しておく必要があります。 このコマンドは、システム内で一度だけ実行すれば大丈夫です。 corepack によるパッケージマネージャー管理を有効化 $ corepack enable このコマンドを実行することで、node コマンドの実行ファイルが置かれたディレクトリ内に、yarn や pnpm などのシンボリックリンクが生成されます。 これで、システム全体で yarn や pnpm コマンドを実行できるようになります。 各パッケージマネージャーのコマンド（シンボリックリンク）が、node と同じ場所に存在していれば、おそらくうまくいっています。 $ which node npm yarn pnpm /Users/maku/.nvm/versions/node/v21.6.1/bin/node /Users/maku/.nvm/versions/node/v21.6.1/bin/npm /Users/maku/.nvm/versions/node/v21.6.1/bin/yarn /Users/maku/.nvm/versions/node/v21.6.1/bin/pnpm ここで表示されるパス内の v21.6.1 という部分は、yarn、pnpm コマンドのバージョンとは関係ないことに注意してください。 プロジェクト内で使用する yarn や pnpm のバージョンを指定する corepack 経由の yarn や pnpm を使用する場合、package.json ファイルの packageManager プロパティで、使用するパッケージマネージャーとそのバージョンを定義しておくことができます。 ここでは、テスト用の Node.js プロジェクトを作って設定してみます。 テスト用のアプリを新規作成（package.json を生成） $ mkdir myapp &amp;&amp; cd myapp $ npm init -y プロジェクト内で使用するパッケージマネージャーは、corepack use コマンドで指定します。 使用するパッケージマネージャーを定義 $ corepack use npm@* # npm の最新版を使う場合 $ corepack use npm@10 # npm バージョン 10.x.x を使う場合 $ corepack use yarn@* # yarn の最新版を使う場合 $ corepack use yarn@4 # yarn バージョン 4.x.x を使う場合 $ corepack use pnpm@* # pnpm の最新版を使う場合 $ corepack use pnpm@9 # pnpm バージョン 9.x.x を使う場合 例えば、パッケージマネージャーとして pnpm を使うよう指定した場合、package.json ファイルに次のように記録されます。 package.json { &#34;name&#34;: &#34;myapp&#34;, &#34;version&#34;: &#34;1.0.0&#34;, // ... &#34;packageManager&#34;: &#34;pnpm@9.0.0+sha512.b4106707c7225b174...（省略）...&#34; } カレントディレクトリに package.json が存在しない状態で corepack use pnpm@9 を実行すると、以下のような packageManager フィールドのみが存在するファイルが自動生成されます。 package.json { &#34;packageManager&#34;: &#34;pnpm@9.0.0+...&#34; } この状態で、pnpm コマンドを実行すると、指定したバージョンの pnpm が起動するはずです。 $ pnpm --version 9.0.0 あとは、通常通り yarn や pnpm コマンドを使ってパッケージ管理していけば OK です。 $ pnpm add dotenv 使用する pnpm のバージョンは package.json に記述されているので、チーム内の他のメンバーが pnpm コマンドを実行するときも同じバージョンが使われるようになります。 他のメンバー（や CI/CD）の環境でビルドするとき $ corepack enable # （システム内で一度だけ実行） $ pnpm install # 指定された pnpm バージョンを使って依存パッケージをインストール $ pnpm build # build スクリプトの実行 プロジェクト内で使用する pnpm のバージョンを更新したいときは、新しいバージョンを corepack use で指定すれば OK です（package.json の packageManager の項目が更新されます）。 pnpm をバージョンアップ（package.json を自動更新） $ corepack use pnpm@10 # 下記でも package.json を更新してくれるけどハッシュコードが付かないっぽい $ pnpm self-update"},{url:"/nodejs/",title:"Node.js",date:"2024-01-25T00:00:00+09:00",body:"Node.js Node.js 実行環境など Node.js とは／Node.js をインストールする nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager) corepack を使ってプロジェクト内で使用する pnpm/yarn のバージョンを管理する Node.js スクリプトにシェバング (#!) を付けてコマンドとして起動できるようにする Node.js で assert を使用する Node.js で環境変数を参照する (process.env) 環境変数の代わりに .env ファイルを使用する (dotenv) Node.js がどのバージョンの V8 エンジンで動作しているか調べる nodemon で Node.js サーバの再起動を自動化する モジュール／パッケージ Node.js 用モジュールの作り方（require でロード可能な Node モジュールを作成する） Node.js が require() で検索するパスのまとめ 外部の JSON ファイルを読み込む (require) モジュール自身のコードにテストコードを記述する (require.main) npm (Node Package Manager) package.json による依存パッケージの管理方法まとめ npm コマンドで Node.js のパッケージをインストール／アンインストールする (npm install, uninstall) npm コマンドでインストールされている Node.js 用パッケージの一覧を表示する (npm list, ll) npm コマンドでインストール可能なパッケージを検索する (npm search) npm コマンド用に HTTP プロキシを設定する (npm config) npm でインストール可能なパッケージのバージョンを調べる npm run で任意のコマンドを実行する (npm run, npm start) npm run のスクリプトの中でファイルのコピーを行う (cpx) npm run のスクリプトの中でディレクトリを削除する (rimraf) npm run のスクリプトを連続実行・並列実行する (npm-run-all) 入出力 (I/O) 標準出力 (stdout)、標準エラー出力 (stderr) への出力 コマンドライン引数（パラメータ）を取得する (process.argv) キーボードからの入力を取得する (reaqline.question) 外部プログラムを実行してその出力を取得する ファイル／ディレクトリ 実行中の JavaScript ファイルのパスやディレクトリ名を取得する (__filename, __dirname) エントリポイントとなった JavaScript ファイルのパスやディレクトリ名を取得する (require.main.filename) パスを結合する (path.join) 指定したパスがディレクトリかどうか調べる カレントディレクトリ以下のファイルを列挙する CSV CSV ファイルを読み込む Yaml Yaml ファイルを読み書きする (js-yaml) SQLite データベース SQLite を使用する (1) node-sqlite3 のインストール SQLite を使用する (2) node-sqlite3 による逐次処理 SQLite を使用する (3) SELECT 文を実行する MongoDB データベース mongoose (1) mongoose をインストールする mongoose (2) データベースへ接続する mongoose (3) モデルクラスを作成する mongoose (4-1) DB にドキュメントを追加する mongoose (4-2) DB からドキュメントを検索する mongoose (4-3) DB のドキュメントを更新する mongoose (4-4) DB からドキュメントを削除する mongoose と Express で RESTful Web API を作成する mongojs で MongoDB を扱う デバッグ／テスト プログラムの実行時間を計測する (console.time, console.timeEnd) 現在位置のスタックトレースを出力する (console.trace) ネットワーク URL Node.js で URL のパスを結合する (url-join) HTTP 通信 / HTTP サーバ http 標準モジュールを使用して HTTP サーバを立てる http 標準モジュールを使用して HTTP 通信を行う node-fetch モジュールを使用して HTTP 通信を行う request モジュールを使用して HTTP 通信を行う (deprecated) request-promise モジュールを使用して HTTP 通信を行う (deprecated) プロキシ経由の HTTP 通信を行う（global-agent モジュール） プロキシ経由の HTTP 通信を行う（request モジュール） WebSocket 通信 WebSocket のクライアントを作成する Node.js で WebSocket サーバを作る（簡単な echo サーバ） Node.js で WebSocket サーバを作る（chat サーバ） WebSocket サーバに接続してきたクライアントの情報を調べる Web サーバ (Express) Express の特徴 Express をインストールする Express で Web サーバを作成する GET/POST メソッドで送られてきたデータを取得する Express のルート定義の URL のパラメータで数字のみを受け付けるようにする Express で next() により次のハンドラへ処理を委譲する RESTful API として検索用の URL を定義する (req.query) jQuery クライアントと Express サーバで JSON データを送受信する Express サーバの HTTP アクセスログを表示する (express.logger() / morgan) Express サーバの Internal Server Error を分かりやすく HTTP ページで表示する Express の動作環境を切り替える（NODE_ENV 変数） Express で静的ファイル（static ファイル）をホスティングする リバースプロキシ経由で Express サーバにアクセスしたときのクライアントのアドレスを取得する Express でテンプレートエンジンとして Jade を使用する Express で Basic 認証を有効にする Express で CORS の設定を行う（クロスドメインでの Ajax を許可） リバースプロキシ Node.js でお手軽リバースプロキシを作る Node.js の制御構文 例外処理 try ～ catch による例外処理 Uncaught Exception（未捕捉例外）をハンドルする ドメインごとに Uncaught Exception（未捕捉例外）をハンドルする 非同期処理 util.promisify でコールバックベースの関数を Promise 化する async.js による非同期処理 非同期処理のフロー制御を行う (1) async.js を使う準備 非同期処理のフロー制御を行う (2) 複数の非同期処理の結果を同時に取得 (async.parallel) 非同期処理のフロー制御を行う (3) 複数の非同期処理を指定した順に実行する (async.series, async.waterfall)"},{url:"/p/rfduqhx/",title:"pandas で DataFrame をループ処理する (iterrows, items)",date:"2024-01-08T00:00:00+09:00",body:"pandas で DataFrame をループ処理する (iterrows, items) pandas の DataFrame にはブロードキャストによる演算機能が備わっているため、ほとんどの場合はループ処理を記述する必要はありませんが、明示的にループ処理することも可能です。 行のループ処理 (iterrows) df.iterrows() メソッドを使用すると、各行をイテレート処理できます。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;Name&#34;: [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;], &#34;Age&#34;: [25, 30, 35], &#34;City&#34;: [&#34;New York&#34;, &#34;San Francisco&#34;, &#34;Los Angeles&#34;], }) # DataFrame の各行をループ処理 for i, row in df.iterrows(): print(f&#34;{i}: Name={row[&#39;Name&#39;]}, Age={row[&#39;Age&#39;]}, City={row[&#39;City&#39;]}&#34;) 実行結果 0: Name=Alice, Age=25, City=New York 1: Name=Bob, Age=30, City=San Francisco 2: Name=Charlie, Age=35, City=Los Angeles 列のループ処理 (items) df.items() メソッドを使用すると、各列をイテレート処理できます。 ループごとに、各列のラベル名と Series オブジェクトのタプルを取得できます（ラベル名は series.name でも取得できるんですけどね^^）。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;Name&#34;: [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;], &#34;Age&#34;: [25, 30, 35], &#34;City&#34;: [&#34;New York&#34;, &#34;San Francisco&#34;, &#34;Los Angeles&#34;], }) # DataFrame の各列をループ処理 for label, series in df.items(): print(f&#34;{label}: {series.values}&#34;) 実行結果 Name: [&#39;Alice&#39; &#39;Bob&#39; &#39;Charlie&#39;] Age: [25 30 35] City: [&#39;New York&#39; &#39;San Francisco&#39; &#39;Los Angeles&#39;]"},{url:"/hugo/",title:"Hugo",date:"2023-12-28T00:00:00+09:00",body:"Hugo 高速な静的サイトジェネレータ Hugo の使い方です。 Go 言語に関する記事はこちらへ分離しました。 はじめに Hugo とは／Hugo をインストールする Hugo で新規の Web サイトを作成する 記事の作成 Hugo で記事を作成する Hugo でドラフトページを作成する Hugo でドラフトページの一覧を簡単に確認できるようにする Hugo のテーマを設定する Hugo で独自のテーマを作成する Hugo Themes（Hugo テーマの一覧サイト） hugo コマンドと設定ファイル hugo コマンド カレントディレクトリを気にせずに hugo コマンドを実行する (hugo server -s) ポート番号を指定して Hugo サーバーを起動する (hugo server -p) Hugo サーバーで記事生成のキャッシュを無効にする (hugo server --ignoreCache) 複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる 複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir) 使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates) 設定ファイル (config) 日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage) コンフィグファイルに設定した情報を参照する Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics) ページ内に Tex 形式の数式を埋め込めるようにする (MathJax) リンクをページからの相対パスで出力するようにする (relativeurls) Hugo Modules Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する ショートコード (Shortcode) ショートコードの使い方と作り方 ショートコードで本文内に HTML スニペットを埋め込む 独自のショートコードを作成する ショートコードの中からフロントマターのパラメータを参照する ($.Page.Params) ショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params) ソースコードをハイライト表示する (highlight) ショートコードをエスケープ処理してそのまま表示する あるショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode) ショートコードで本文とパラメーターの有無で処理を分岐する ショートコードの例 ローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する SVG ファイルをインラインで埋め込む svg ショートコードを作成する クリックで開閉する accordion ショートコードを作成する Youtube の動画を表示する youtube ショートコード（Hugo 組み込み） テンプレート テンプレートによるレイアウトの基本 レイアウト用のテンプレートの種類を理解する 記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout) サイトのヘッダーとフッターをパーシャルファイルに分離する (partials/header.html, partials/footer.html) ベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html) Hugo のテンプレート文法 Hugo テンプレート内にコメントを記述する ({{/* ... */}}) Hugo テンプレート内で変数を扱う ({{ $x := ... }}) Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range) Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range) Hugo テンプレート内で if や with で分岐処理する Hugo テンプレートで数値によるループ処理を行う (range, seq) Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき） Hugo のパーシャルテンプレートから値を返す（関数化）(return) セクションとページリスト Hugo のセクション機能の基本（記事を階層化する） セクションテンプレート (section.html) の中でセクションのタイトルを表示する セクションの階層構造を取得する (.CurrentSection、.Parent、.Sections) ページタイトルに自動でセクションプレフィックスを付ける ページの階層構造を取得する関数を作成する (get-hierarchy) 一覧表示のサンプルコード サイト内の全ページの一覧を表示する (.Site.Pages) サイト内の全セクションの一覧を表示する (.Site.Sections) カレントセクション直下のページ／セクションの一覧を表示する セクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages) サイト内の全ページの一覧をセクションの階層構造に従って表示する サイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示） 最近更新された記事（新着記事）のリストを表示する ページリスト（記事一覧）に列挙されないページを作る (_build.list) セクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight) タクソノミー（タグとカテゴリー） タクソノミーの基本（タグやカテゴリなど） タクソノミー関連のテンプレートを定義する サイト全体のターム一覧（タグ一覧）を表示する 記事ページに付けられたターム一覧（タグ一覧）を表示する 記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする data ディレクトリ 全ページから参照できるデータを用意する（data ディレクトリ） 参照するデータファイルをショートコードのパラメータで切り替える ページャー（ページネーター） ページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする その他 パンくずリストを表示する JSON-LD のパンくずリストを出力する（SEO 対策） 各ページに目次を表示する (.TableOfContents) ホームページの Page オブジェクトを取得する 各種ページにおいて .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧 次のページ、前のページへのリンクを表示する ファイルが存在する場合のみ処理するコードを記述する (fileExists) Markdown (.md) ファイルのパス情報を取得する Markdown (.md) ファイルを VS Code で開くリンクを表示する Markdown ファイルに本文が記述されていない場合だけ特別な出力をする テンプレートの中で絵文字を使用する (emojify) Hugo 応用 図／画像 画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle) 大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing) favicon.ico をサイトのルートに置く (static) mermaid.js で Markdown 中に UML 図を埋め込む 検索／サーチエンジン 全文検索（インクリメンタルサーチ）の機能を付ける Google カスタム検索を設置して記事を検索できるようにする サーチエンジン用に robots.txt や sitemap.xml ファイルを配置する アドレス／リンク サイト構造を変えてもページの URL が変わらないようにする (Permalink) ページ内リンク（アンカー）を張る 「このページを編集 (Edit this page)」のリンクを表示する 新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo) Sass/SCSS スタイルシートを使用する 特定の記事を常にリスト上方に表示する（weight プロパティ） Python で Markdown ファイルのフロントマターの記述が正しいかチェックする Facebook や Twitter の SNS で URL をシェアするときの表示設定 (OGP: Open Graph Protocol) hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする Hugo のテンプレートやショートコードでランダムな文字列を生成する 記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する トラブルシューティング ドラフト指定したセクションが公開されてしまう Markdown ファイルに記述した HTML コードが削除されてしまう Hugo サーバーで記事の変更内容が反映されない (hugo server --ignoreCache)"},{url:"/p/b9jivoi/",title:"Hugo のショートコードで本文とパラメーターの有無で処理を分岐する",date:"2023-12-28T00:00:00+09:00",body:"Hugo のショートコードで本文とパラメーターの有無で処理を分岐する Hugo のショートコードを呼び出すときに値を渡す方法としては、本文（コンテンツ）として渡す方法と、引数（パラメーター）として渡す方法があります。 次のショートコードは、本文や引数の有無によって処理を分岐する方法を示しています。 layouts/shortcodes/my-shortcode.html &lt;ul&gt; &lt;li&gt;本文: {{ with .Inner }}{{ . }}{{ else }}（なし）{{ end }}&lt;/li&gt; &lt;li&gt;引数: {{ with .Get 0 }}{{ . }}{{ else }}（なし）{{ end }}&lt;/li&gt; &lt;/ul&gt; このショートコードは、Markdown ファイル内で次のように呼び出します。 content/page.md（抜粋） &lt;h3&gt;本文だけある場合&lt;/h3&gt; {{&lt; my-shortcode &gt;}}これは本文{{&lt; /my-shortcode &gt;}} &lt;h3&gt;引数だけある場合&lt;/h3&gt; {{&lt; my-shortcode &#34;これは引数&#34; /&gt;}} &lt;h3&gt;本文と引数の両方がある場合&lt;/h3&gt; {{&lt; my-shortcode &#34;これは引数&#34; &gt;}}これは本文{{&lt; /my-shortcode &gt;}} 出力結果 &lt;ul&gt; &lt;li&gt;本文: これは本文&lt;/li&gt; &lt;li&gt;引数: （なし）&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;引数だけある場合&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;本文: （なし）&lt;/li&gt; &lt;li&gt;引数: これは引数&lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;本文と引数の両方がある場合&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;本文: これは本文&lt;/li&gt; &lt;li&gt;引数: これは引数&lt;/li&gt; &lt;/ul&gt; ☝️ self-closed エラー ショートコードの呼び出し時に引数だけを指定する場合は、self-closed というちょっと特殊な書き方をしなければいけないようです（末尾をスラッシュで終わる）。 これは、ショートコードの中で .Inner（本文）を参照している場合の仕様のようです。 末尾のスラッシュを省略すると、実際には .Inner の値を出力していないのにも関わらず、次のようなエラーが発生してしまいます。 shortcode &#34;my-shortcode&#34; must be closed or self-closed この仕様はちょっとわかりにくいので、Hugo 側で変更して欲しいなぁ。。。"},{url:"/p/nzi6xbm/",title:"Rust で MongoDB を扱う (mongodb)",date:"2023-12-23T00:00:00+09:00",body:"Rust で MongoDB を扱う (mongodb) Rust プログラムから MongoDB にアクセスするには、mongodb クレート を使用します。 各種クレートのインストール cargo add コマンドを使って、次のようなクレートをインストールします。 mongodb &hellip; MongoDB を扱うためのクレート serde &hellip; MongoDB 内の BSON データと Rust の struct を相互変換（シリアライズ／デシリアライズ）するためのクレート tokio &hellip; Rust の async 処理用のランタイム実装を提供するクレート futures &hellip; TryStream と呼ばれる非同期ストリームを操作するための拡張メソッドを使うため（サンプルコード内の cursor.try_next() の部分に必要） # （必要に応じて）プロジェクトの作成 $ cargo new myapp $ cd myapp # クレートのインストール $ cargo add mongodb serde tokio futures Cargo.toml に次のような感じで依存関係が追加されていれば準備 OK です。 Cargo.toml [dependencies] futures = &#34;0.3.29&#34; mongodb = &#34;2.8.0&#34; serde = &#34;1.0.193&#34; tokio = &#34;1.35.1&#34; MongoDB サーバーの準備 接続先の MongoDB サーバーはローカルで起動しておくか、MongoDB Atlas などのクラウドサービスで用意しておいてください。 参考: MongoDB 関連記事｜まくろぐ 以下の説明では、localhost:27017 で MongoDB サーバーが稼働していることを想定しています。 サンプルコード データベースの一覧を取得する 下記のコードは、MongoDB サーバーに接続して、データベースの一覧を列挙する例です。 databases.rs use mongodb::Client; const URI: &amp;str = &#34;mongodb://127.0.0.1:27017&#34;; #[tokio::main] async fn main() -&gt; mongodb::error::Result&lt;()&gt; { // MongoDB サーバーに接続して Client インスタンスを取得 let client = Client::with_uri_str(URI).await?; // データベースを列挙 for db_name in client.list_database_names(None, None).await? { println!(&#34;{}&#34;, db_name); } } 実行結果 $ cargo run -q admin config local コレクション内のドキュメント操作 次の例では、mydb データベース内の books コレクションにドキュメントをいくつか追加し、それらを取り出しています。 ここでは、各ドキュメントを表現する struct として Book 型を定義しています。 books.rs use futures::TryStreamExt; use mongodb::{bson::oid::ObjectId, Client}; use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { #[serde(rename = &#34;_id&#34;, skip_serializing)] id: Option&lt;ObjectId&gt;, title: String, price: i32, } const URI: &amp;str = &#34;mongodb://127.0.0.1:27017&#34;; #[tokio::main] async fn main() -&gt; mongodb::error::Result&lt;()&gt; { // MongoDB サーバーに接続して Client インスタンスを取得 let client = Client::with_uri_str(URI).await?; // books コレクションのハンドルを取得する let books_coll = client.database(&#34;mydb&#34;).collection::&lt;Book&gt;(&#34;books&#34;); // コレクション内のドキュメントをすべて削除する books_coll.drop(None).await?; // コレクションにドキュメントを追加する let books = vec![ Book { id: None, title: &#34;Title-1&#34;.to_string(), price: 1000, }, Book { id: None, title: &#34;Title-2&#34;.to_string(), price: 2000, }, Book { id: None, title: &#34;Title-3&#34;.to_string(), price: 3000, }, ]; books_coll.insert_many(books, None).await?; // コレクション内のすべてのドキュメントを取得する let mut cursor = books_coll.find(None, None).await?; while let Some(book) = cursor.try_next().await? { println!(&#34;{:?}, {}, {}&#34;, book.id, book.title, book.price); } Ok(()) } 実行結果 $ cargo run -q Some(ObjectId(&#34;658721862f9a5832444f7833&#34;)), Title-1, 1000 Some(ObjectId(&#34;658721862f9a5832444f7834&#34;)), Title-2, 2000 Some(ObjectId(&#34;658721862f9a5832444f7835&#34;)), Title-3, 3000 関連リンク Deno で MongoDB を扱う Golang で MongoDB を扱う (go.mongodb.org/mongo-driver)"},{url:"/p/x4z298a/",title:"python コマンドのバージョンを切り替える (pyenv, py)",date:"2023-12-19T00:00:00+09:00",body:"python コマンドのバージョンを切り替える (pyenv, py) 互換性の問題のために、少し古いバージョンの python コマンドを使わなければいけないことがあります（機械学習系のライブラリなど）。 そのようなケースでは、次のようなツールを使って python コマンド自体のバージョンを切り替えると便利です。 pyenv &hellip; Linux または macOS 用の python バージョン切り替えコマンドです。Windows 用の移植もありますが、シェルスクリプトで作られているので、本質的には Linux または macOS 用です。 Python ランチャー (py) &hellip; Windows 用の Python インストーラーを使うと、Python ランチャー（py コマンド）をインストールすることができます。 pyenv コマンド インストール macOS の場合 (Homebrew) $ brew update $ brew install pyenv Linux の場合 $ curl https://pyenv.run | bash チートシート コマンド 説明 pyenv versions インストール済みの Python バージョンの一覧を表示します。現在選択しているバージョンには * 印が付きます。 pyenv version 現在選択している Python のバージョンを表示します。 pyenv install --list インストール可能な Python のバージョンを表示します。 pyenv install 3.10 指定したバージョンの Python をインストールします。マイナーバージョンやパッチバージョンは省略できます。 pyenv uninstall 3.10.13 指定したバージョンの Python をアンインストールします。バージョンは省略できません。 pyenv global 3.10 Python のバージョンを切り替えます（グローバル設定）。 pyenv local 3.10 Python のバージョンを切り替えます（カレントディレクトリ以下）。 --unset を指定するとバージョン指定を解除します。 pyenv shell 3.10 Python のバージョンを切り替えます（現在のシェルのみ）。--unset を指定するとバージョン指定を解除します。 現在の Python バージョンを確認 まず、pyenv versions コマンドで、現在インストールされている Python のバージョン一覧を調べます。 $ pyenv versions system * 3.12.0 (set by /Users/maku/.pyenv/version) system と 3.12.0 がインストールされていることが分かります。 system の方は、pyenv の外の世界でインストールされた python コマンドを示しており、pyenv 管轄の python コマンドを使う場合は使用しません。 3.12.0 の横には * 印が付いているので、この状態で python コマンドを実行すると、バージョン 3.12.0 の Python が起動します。 $ python --version Python 3.12.0 インストール可能な Python バージョンを確認 インストール可能な Python のバージョンは、pyenv install --list コマンドで確認できます。 そのまま実行するとたくさん表示されるので、適宜 grep コマンドをなどを使って絞り込みます。 インストール可能な Python バージョンの一覧（最新の3.x系だけ表示） $ pyenv install --list | grep -E &#34;\\s+3&#34; | tail 3.11.5 3.11.6 3.11.7 3.11.8 3.12.0 3.12-dev 3.12.1 3.12.2 3.13.0a3 3.13-dev 指定したバージョンの Python をインストール 例えば、少し古い Python 3.10.X を使いたくなった場合は、次のように pyenv install コマンドでインストールします。 パッチバージョンを省略すると、その時点での最新のパッチバージョン（例えば 3.10.13）がインストールされます。 Python 3.10 系の最新バージョンをインストール $ pyenv install 3.10 3.13-dev のような開発バージョンをインストールしたい場合は、バージョン名全体を指定する必要があります。 インストールが終わったら、もう一度 pyenv versions コマンドを実行して、正しくインストールされていることを確認します。 $ pyenv versions system 3.10.13 * 3.12.0 (set by /Users/maku/.pyenv/version) 使用する python バージョンを切り替える 普段使用する Python バージョンを切り替えるには、pyenv global コマンドを使います。 $ pyenv global 3.10 $ pyenv versions system * 3.10.13 (set by /Users/maku/.pyenv/version) 3.12.0 $ python --version Python 3.10.13 無事 python コマンドのバージョンが 3.10 系に切り替わっていることを確認できました。 上記の例では、pyenv global コマンドを使って python コマンドのバージョンを切り替えましたが、他にも pyenv local や pyenv shell でスコープを絞って切り替えることができます。 切り替え方法によって、次のように有効期間が異なります。 pyenv global 3.12 グローバルに使用する python コマンドのバージョンを 3.12 に切り替えます。別のシェルを開いた場合にも有効です。内部的には、~/.pyenv/version に指定されたバージョンが保存されているだけです。 pyenv local 3.12 カレントディレクトリ以下で使用する python コマンドのバージョンを 3.12 に切り替えます。プロジェクト内で指定された Python バージョンが必要な場合に指定しておくと便利です。内部的には、カレントディレクトリの .python-version に指定されたバージョンが保存されているだけです。 pyenv shell 3.12 カレントシェルで使用する python コマンドのバージョンを 3.12 に切り替えます。シェルを終了すると元に戻ります。内部的には PYENV_VERSION 環境変数を設定しているだけなので、export PYENV_VERSION=3.12 のようにするのと同じです。 pyenv で複数バージョンの Python をインストールすると、python3.10、python3.12 のようなシンボリックリンクが自動的に作成されます（~/.pyenv/shims/ ディレクトリを参照）。 一時的に使用する Python バージョンを切り替えたいときは、pyenv shell コマンドで切り替えるのではなく、このシンボリックリンクを使った方が早いかもしれません。 3.10 系の python コマンドを起動 $ python3.10 main.py Python ランチャー（py コマンド） Windows の Python 環境では Python ランチャー (py) を使って python コマンドのバージョンを切り替えることができます。 チートシート コマンド 説明 py --list インストール済みの Python バージョンの一覧を表示します。現在選択しているバージョンには * 印が付きます。 py --list-paths 各バージョンの python.exe のフルパスを表示します。 py -3.8 Python 3.8 を起動します。 py -3.8 -m pip install pandas Python 3.8 の環境にパッケージをインストールします。 py -3.8 -m venv venv Python 3.8 の環境で venv 仮想環境を作成します。"},{url:"/js/",title:"JavaScript",date:"2023-12-01T00:00:00+09:00",body:"JavaScript はじめに JavaScript のコーディングスタイル 最初から Strict モードを有効にすべし (ECMAScript 5) JavaScript の 6 つの型 静的解析ツール （旧）JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint) （旧）JSLint で JavaScript コードの静的解析を行う （旧）JSHint で JavaScript コードの静的解析を行う ESLint で JavaScript コードの静的解析を行う（オススメ） デバッグ デバッグ出力用の print 関数の統一について ある処理を 1 秒間に何回実行できるかプロファイリングする 数値／文字列 (Number/String) 数値 実数の小数点数以下を丸めて整数に変換する (floor, ceil, round) 数値の小数点以下 N 桁までに丸めて表示する (toFixed) 文字列 new String は避ける テンプレート文字列の機能で文字列リテラル中の変数を展開する (template literal) (ECMAScript 2015) == と === による文字列比較の違い 文字列を大小比較すると何が起こるか 文字列と文字列、数値を結合する 文字列と数値を変換する 文字列の小文字と大文字を変換する (toLowerCase, toUpperCase) 検索 文字列の中から文字列を検索する (String#search, RegExp#test) 文字列内に NG ワード（禁止語句）が含まれていないか調べる (RegExp#test) 分割／抽出 文字列をデリミタで分割する／1文字ずつに分割する (String#split) 文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec) 置換 文字列を置換する (String#replace, String#replaceAll) 編集 文字列の先頭と末尾の空白を削除する (String#trim) (ECMAScript 2015) 文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd) 文字列の長さを取得する (length) 部分文字列を取得する (substring, slice) 文字列内の1文字を取得する／1文字ずつループ処理する (charAt) 全角文字と半角文字を含んだ文字列を正規化して表記ゆれを吸収する (normalize) (ECMAScript2015) 文字列内のひらがなとカタカナを変換する 旧記事 テンプレートを使ってテキストを生成する (Underscore.js) 配列／連想配列 (Array) 配列の基本 配列に要素を追加・挿入する (push, unshift, splice) 配列と配列を結合する (&hellip;スプレッド演算子, concat) 配列から部分配列を取得する (slice, splice) 配列をコピーする 配列をループで処理する (for, forEach, for-of) 配列をソートする (sort, reverse) 配列にある要素が存在するか調べる (includes, indexOf) 配列の長さを切り詰める (length, splice) 連想配列にキーが存在するか調べる (in) 連想配列の要素（キー）を削除する (delete) 連想配列の要素数を調べる 配列要素をランダムで取り出す 配列の各要素に対して同じ処理を行う (map) 配列の分割代入で複数の値を同時に代入する (Array destructuring) 日時／タイマー (Date/Timer) 日時 Date オブジェクト（日時情報）の作成方法いろいろ Date オブジェクトをいろいろな文字列表現に変換する 他の国のローカルタイム（現地時刻）を文字列形式で取得する Date オブジェクトの日付を加算／減算する Date オブジェクト同士の差分を取る タイマー／パフォーマンス タイマーで任意の関数を呼び出す (setTimeout, setInterval) 精度の高いタイムスタンプを取得する (performance.now()) 処理速度を計測する (performance) 構文 関数 関数を定義する デフォルト引数を扱う関数を定義する (Default parameters) (ECMAScript 2015) 可変長引数を扱う関数を定義する (arguments) 関数の仮引数の数を取得する 渡されたパラメータが関数かどうか調べる 関数オブジェクトから関数名を取得する アロー関数で関数を定義する (ECMAScript 2015) yield を使ってイテレート可能な関数（ジェネレーター関数）を定義する 変数／定数／名前空間 変数定義には var ではなく let や const を使用する (ECMAScript 2015) JavaScript で定数を定義する (const) JavaScript ではグローバル変数も関数も全てプロパティ 関数内からしか参照できないプライベート関数を定義する 分割代入 (Destructuring assignment) 分割代入によりオブジェクトの特定のプロパティだけを単独変数に取得する (Object destructuring) (ECMAScript 2015) オブジェクト オブジェクトの基本 オブジェクトのプロパティを列挙する (for-in) 2つのオブジェクトのプロパティをマージする（&hellip;スプレッド演算子、Object.assign） Property Shorthand の記法で複数の変数をひとつのオブジェクトにまとめる (ECMAScript 2015) クラス クラスを定義する (class) (ECMAScript 2015) クラス定数／クラス変数／クラスメソッドを定義する あるオブジェクトが特定のクラスのインスタンスであるかを調べる (instanceof, constructor) クラスに toString() メソッドを実装する JavaScript 独自拡張 式クロージャ (Expression Closure) その他 JavaScript において偽 (false) と評価される値 入れ子になったループを一度に抜ける（多重ループからの break） ある変数が初期化済みかどうか確認する 外部スクリプトはなぜ (function(){})(); のような書き方をするのか？ 非同期処理 Promise オブジェクトで連続するコールバック処理を簡潔に記述する (ECMAScript 2015) Promise な非同期処理を async/await でさらに読みやすくする (ECMAScript 2017) HTML/DOM 操作 要素 HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索 HTML の DOM 要素を取得する (2) 親要素、子要素、兄弟要素を検索 HTML の DOM ツリーに要素を追加する HTML 要素に独自の data 属性（カスタム属性）を設定する HTML 要素の class 属性の値を追加・削除・トグルする ページ内のヘッダ要素 (h2/h3/h4) から自動的にメニュー (TOC) を生成する HTML 要素のサイズを取得する HTML 要素の位置を取得する ウィンドウ Web ブラウザのページ表示位置を調べる（スクロール位置を取得する） 画像／イメージ 複数の画像ファイルが読み込まれるのを待機する 音声/オーディオ オーディオファイル (mp3) を再生する I/O（入出力） キーボードからの入力を取得する テキストボックスでキー入力したときのイベントをハンドルする (onkeyup) ボタンを押したときのイベントをハンドルする (onclick) プルダウンリストから項目を選択したときのイベントをハンドルする (onchange) レガシーライブラリ jQuery jQuery 本体のロード方法いろいろ jQuery 関連用語 jQuery で Hello World jQuery で要素を追加、移動、コピーする (append, prepend) jQuery で動的にリスト項目 (li) を追加する jQuery でテーブルに動的にレコード (tr) を追加する jQuery で要素を削除する (remove) jQuery の ajax/get/post メソッドが動作しない jQuery でフォームに入力した値を取得する Backbone.js の使い方メモ RequireJS の使い方メモ HTML5 Canvas HTML5 Canvas のサイズ指定について HTML5 Canvas でテキストを描画する HTML5 Canvas に矩形や円を描画する HTML5 Canvas に画像ファイルを描画する HTML5 Canvas 内のマウスドラッグで、描画オブジェクト全体を移動させる HTML5 Canvas のまわりにテレビの枠画像を表示してそれっぽく見せる ウィンドウサイズに応じて HTML5 Canvas のサイズを変更する HTML5 Canvas の描画領域全体をクリアする IE 8 以下でも canvas タグを使用できるようにする Web サイト URL エンコード／デコードを行う (encodeURI, encodeURIComponent) URL 内のハッシュフラグメントの値を扱う (hashchange, location.hash) URL からクエリ文字列を取り出す (window.location.search, URLSearchParams) 実行環境 CORS - Cross-Origin Resource Sharing とは？ Chrome で Ajax (XMLHttpRequest) によるクロスドメイン通信の制約をなくす 使用している Web ブラウザが IE (Internet Explorer) かどうか判別する Node.js ⇒ まくまく Node.js ノート"},{url:"/p/buatano/",title:"JavaScript で文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd)",date:"2023-12-01T00:00:00+09:00",body:"JavaScript で文字列を指定の長さになるまでパディング（埋め合わせ）する (String#padStart, #String#padEnd) padStart と padEnd の基本 JavaScript の String#padStart() および String#padEnd() メソッドを使うと、指定した文字数になるまで文字列を拡張してくれます。 どのような文字で埋め合わせるかは、第 2 引数で指定します。 左側にパディング const s = &#34;ABC&#34;; console.log(s.padStart(2, &#34;x&#34;)); //=&gt; &#34;ABC&#34; console.log(s.padStart(3, &#34;x&#34;)); //=&gt; &#34;ABC&#34; console.log(s.padStart(4, &#34;x&#34;)); //=&gt; &#34;xABC&#34; console.log(s.padStart(5, &#34;x&#34;)); //=&gt; &#34;xxABC&#34; console.log(s.padStart(6, &#34;x&#34;)); //=&gt; &#34;xxxABC&#34; 右側にパディング const s = &#34;ABC&#34;; console.log(s.padEnd(2, &#34;x&#34;)); //=&gt; &#34;ABC&#34; console.log(s.padEnd(3, &#34;x&#34;)); //=&gt; &#34;ABC&#34; console.log(s.padEnd(4, &#34;x&#34;)); //=&gt; &#34;ABCx&#34; console.log(s.padEnd(5, &#34;x&#34;)); //=&gt; &#34;ABCxx&#34; console.log(s.padEnd(6, &#34;x&#34;)); //=&gt; &#34;ABCxxx&#34; 第 2 引数に 2 文字以上の文字列を指定すると、各文字が順番に使われます。 const s = &#34;ABC&#34;; console.log(s.padStart(10, &#34;xyz&#34;)); //=&gt; &#34;xyzxyzxyzxABC&#34; 使用例 byte 数値を二進数文字列にする（8 桁になるまで 0 パディング） function toBinaryString(byteNum) { return byteNum.toString(2).padStart(8, &#34;0&#34;); } console.log(toBinaryString(0)); //=&gt; &#34;00000000&#34; console.log(toBinaryString(3)); //=&gt; &#34;00000011&#34; console.log(toBinaryString(255)); //=&gt; &#34;11111111&#34; コンソール出力用の右寄せ（スペースでパディング） function alignRight(s) { return s.padStart(5); // デフォルトでスペースでパディングされます } console.log(alignRight(&#34;AAA&#34;)); //=&gt; &#34; AAA&#34; console.log(alignRight(&#34;BBBB&#34;)); //=&gt; &#34; BBBB&#34; console.log(alignRight(&#34;CCCCC&#34;)); //=&gt; &#34;CCCCC&#34; console.log(alignRight(&#34;DDDDDD&#34;)); //=&gt; &#34;DDDDDD&#34; 末尾の 4 文字以外を隠す（カード番号や電話番号などに） function hideAllButTheEnd(s) { const last4Chars = s.slice(-4); const maskedStr = last4Chars.padStart(s.length, &#34;*&#34;); return maskedStr; } const cardNumber = &#34;2034399002125581&#34;; console.log(hideAllButTheEnd(cardNumber)); //=&gt; &#34;************5581&#34; ちなみに上記のコードは、MDN の padStart() のドキュメント で紹介されているものです。"},{url:"/p/2tyvjmh/",title:"Python の dictionary（辞書）のチートシート",date:"2023-11-28T00:00:00+09:00",body:"Python の dictionary（辞書）のチートシート コード 説明 d = {} d = dict() dictionary の作成 d = {&quot;key1&quot;: 100} d = dict(key1=100) dictionary の作成と初期化 d = dict(zip([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], [1, 2, 3])) キーのリストと値のリストから dictionary を作成 len(d) 要素数 d[&quot;key&quot;] = 100 要素を追加・上書き val = d[&quot;key&quot;] 要素を取得（キーが存在しないときは KeyError） val = d.get(&quot;key&quot;, default=0) 要素を取得（キーが存在しないときはデフォルト値を返す） val = d.setdefault(&quot;key&quot;, 0) 要素を取得（キーが存在しないときはデフォルト値をセットして返す） keys = d.keys() キーのリストを取得 vals = d.values() 値のリストを取得 items = d.items() (キー, 値) のリストを取得 if &quot;key&quot; in d: キーが存在するか調べる del d[&quot;key&quot;] 要素を削除する（キーが存在しないときは KeyError） for key in d: キーでループ for key, val in d.items(): キーと値でループ for i, key in enumerate(d): 連番とキーでループ for key in sorted(d.keys()): for key in sorted(d.keys(), reverse=True): キーでソートしてループ（昇順/降順） for key in sorted(d, key=lambda x:d[x]): for key in sorted(d, reverse=True, key=lambda x:d[x]): 値でソートしてループ（昇順/降順） d1.update(d2) d1 に d2 をマージ d3 = {**d1, **d2} d1 と d2 をマージした d3 を作成"},{url:"/p/succ4mb/",title:"Python の requests パッケージのチートシート",date:"2023-11-28T00:00:00+09:00",body:'Python の requests パッケージのチートシート インストールとインポート requests パッケージのインストール $ pip install requests requests パッケージのインポート import requests リクエスト コード説明 res = requests.get(URL) GET リクエスト res = requests.get(URL, headers={"key": "val"}) ヘッダーの設定 res = requests.get(URL, params={"key": "val"}) クエリパラメータの設定 res = requests.get(URL, cookies={"key": "val"}) クッキーの設定 res = requests.get(URL, auth=("user", "pass")) Basic 認証 res = requests.get(URL, auth=requests.auth.HTTPDigestAuth("user", "pass")) Digest 認証 res = requests.post(URL, data={"key": "val"}) POST リクエストでペイロード送信（key=val というテキスト） data = {"key": "value"} res = requests.post( "https://example.com", headers={"Content-Type": "application/json"}, data=json.dumps(data) ) POST リクエストでペイロード送信（JSON 形式のテキスト） session = requests.Session() res = session.post(URL1, data=data) res = session.get(URL2) セッションを考慮したリクエスト（URL1 のレスポンスに Set-Cookie ヘッダーが含まれていたら、次の URL2 へのリクエストに自動で Cookie ヘッダーが付く） テスト用には下記のアドレスを使うと便利です。どのようなデータが送信されたかを、JSON 形式のレスポンスとして返してくれます。 GET メソッド用: https://httpbin.org/get POST メソッド用: https://httpbin.org/post レスポンス コード 説明 res.status_code ステータスコード（例: 200） res.ok ステータスコードが 400 未満であれば True（クライアントエラー 4xx もサーバーエラー 5xx も発生していない） res.headers レスポンスヘッダー（dictionary 形式） res.content コンテンツのバイトデータ (bytes) res.text コンテンツのテキストデータ (str) res.json() コンテンツのテキストを JSON フォーマットとみなして Python オブジェクトに変換 with open(&quot;file.txt&quot;, &quot;wb&quot;) as f: f.write(res.content) コンテンツをファイルに保存（ダウンロード） 参考 requests パッケージによる HTTP 通信の例'},{url:"/p/zpdyxso/",title:"Python の dictionary（辞書）の基本",date:"2023-11-23T00:00:00+09:00",body:"Python の dictionary（辞書）の基本 Python の dictionary（辞書）は、キーと値のペアで構成されたオブジェクトです。 他の言語では、マップやハッシュと呼ばれていたりします。 dictionary オブジェクトを生成する ({}, dict) dictionary は {} あるいは、dict() を使って生成できます。 Python の dictionary は、JavaScript のオブジェクトにそっくりです。 空の dictionary を作成する d = {} # 空の辞書を作成する d = dict() # 別の方法 print(type(d)) #=&gt; &lt;class: &#39;dict&#39;&gt; print(len(d)) #=&gt; 0 初期値を持つ dictionary を作成する dictionary オブジェクトを生成するときに、キーと値のペアを列挙することで、初期値を設定できます。 {} を使った初期化用の構文を使うか、dict() 関数にキーワード引数の形で初期値を指定します。 d = {&#39;one&#39;: 1, &#39;two&#39;: 2} # 初期値を持つ辞書を作成する d = dict(one=1, two=2) # 別の方法 print(d[&#39;one&#39;]) #=&gt; 1 print(d[&#39;two&#39;]) #=&gt; 2 print(d[&#39;three&#39;]) #=&gt; KeyError dictionary の要素を参照・変更する ([], get) Python で dictionary オブジェクトの要素を参照するには下記のように [] でキーを指定します。 キーが存在しない場合は、KeyError が発生します。 val = d[&#39;key&#39;] # 要素を参照する d[&#39;key&#39;] = val # 要素を追加する キーが存在しない場合に、デフォルト値を返したい場合は get() メソッドを使用します。 val = d.get(&#39;key&#39;, default=None) 応用: dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault) dictionary の要素数を取得する (len) Python で dictionary オブジェクトの要素数を調べるには、組み込み関数の len() を使用します。 len() 関数は dictionary のメソッドではないことに注意してください。 &gt;&gt;&gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} &gt;&gt;&gt; len(d) 3 ちなみに、list や tuple オブジェクトの要素数や、文字列 (str) の文字数を調べる場合も、同様に組み込み関数の len() を使用します。 dictionary に指定したキーが存在するか調べる (in) Python の dictionary オブジェクトが、指定したキーを持っているかを判別するには、in キーワードを使用します。 if &#39;key1&#39; in d: print(&#39;key1 が存在します&#39;) ☝️ has_key メソッドはなくなった Python 2 の頃は、下記のように has_key() メソッドを使用することができましたが、Python 3 以降は in キーワードしか使用できなくなりました。 if d.has_key(&#39;key1&#39;): print(&#39;key1 が存在します&#39;) dictionary の要素を削除する (del) Python の dictionary から指定したキーの要素を削除するには、del キーワードを使用します。 del d[&#39;key&#39;] 次のサンプルでは、実際に要素が削除されているかを in で確認しています。 &gt;&gt;&gt; d = {&#39;key1&#39;: 100, &#39;key2&#39;: 200} &gt;&gt;&gt; &#39;key1&#39; in d True &gt;&gt;&gt; del d[&#39;key1&#39;] &gt;&gt;&gt; &#39;key1&#39; in d False 削除済みの要素を参照しようとするとエラー (KeyError) になります。 &gt;&gt;&gt; d[&#39;key1&#39;] Traceback (most recent call last): File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt; KeyError: &#39;key1&#39; dictionary をループ処理する 単純なループ dictionary オブジェクトを for-in ステートメントに渡すと、ループ処理でキーを 1 つずつ取り出すことができます。 &gt;&gt;&gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} &gt;&gt;&gt; for key in d: ... print(key, d[key]) ... two 2 three 3 one 1 キーと値のペアを取り出しながらループ (items) dictionary オブジェクトをループ処理するときに、キーと値を同時に取り出しながら処理したい時は items() メソッドを使用します。 &gt;&gt;&gt; d = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} &gt;&gt;&gt; for key, val in d.items(): ... print(key, val) ... two 2 three 3 one 1 ちなみに、Python 2 の頃は iteritems() メソッドを使用できましたが、Python 3 からは items() メソッドのみ使用可能です。 連番を振りながらループ (enumerate) enumerate と組み合わせることで、0 から始まる連番を振りながらループ処理することができます（list オブジェクトも同様のループ処理が可能です）。 &gt;&gt;&gt; for i, key in enumerate(d): ... print(&#39;[{}] {}: {}&#39;.format(i, key, d[key])) ... [0] one: 1 [1] two: 2 [2] three: 3 キーでソートしてループ処理する dictionary の要素をソートして出力する"},{url:"/p/2c29gvn/",title:"Git リポジトリ内のコードを grep 検索する (git grep)",date:"2023-11-15T00:00:00+09:00",body:"Git リポジトリ内のコードを grep 検索する (git grep) git grep とは Git に組み込まれている git grep コマンドを使うと、Git リポジトリ内のコードを対象にした grep 検索を行うことができます。 Linux の grep コマンドを使うのと比べて、次のような利点があります。 OS に依存しない grep コマンドとして使用できる .gitignore で指定されているファイルを無視して検索してくれる ある時点のコードを対象に検索できる（コミットハッシュの指定） ある文字列を含む関数を検索できる（-p オプション） git grep の基本 カレントディレクトリ以下を検索する $ git grep &#34;検索文字列&#34; カレントディレクトリ以下のファイルを対象として git grep するには、上記のように単純に検索文字列を指定するだけで OK です。 もちろん、Git 管理されているディレクトリ以下で実行する必要があります。 検索対象のディレクトリやファイルを指定するには、次のように -- で区切ってからディレクトリ名やファイル名のパターンを指定します。 src ディレクトリ以下を検索する $ git grep &#34;検索文字列&#34; -- src src ディレクトリ以下の .py ファイルを検索する $ git grep &#34;検索文字列&#34; -- &#34;src/**.py&#34; ワイルドカードを指定してファイル名のパターンを指定するときは、&quot;src/**.py&quot; のようにダブルクォートで囲む必要があることに注意してください。 これは、git grep にパラメーターが渡される前にシェルがファイルグロブとして展開してしまうのを防ぐためです。 特定のディレクトリやファイルを検索対象外にしたいときは、:^ というプレフィックスを付けます。 .github ディレクトリや package.json を検索対象外にする $ git grep react -- :^.github &#34;:^package*.json&#34; 拡張正規表現を使って検索したいときは、-E オプションを指定します。 正規表現を使って検索する $ git grep -E &#34;https?://&#34; 特定のコミットハッシュやブランチ、タグのコードを検索対象としたいときは、検索文字列の後ろにコミットハッシュなどを指定します。 コミットハッシュを指定して検索する $ git grep &#34;検索文字列&#34; ba17d26 複数の検索パターンを AND や OR で組み合わせたいときは、-e 検索文字列（または -E 拡張正規表現）というパターン指定を、--and や --or で繋げて指定します。 AND 検索（game と book を両方含む行を検索） $ git grep -e &#34;game&#34; --and -e &#34;book&#34; OR 検索（game または book を含む行を検索） $ git grep -e &#34;game&#34; --or -e &#34;book&#34; git grep の応用的な使い方 git grep のその他のオプションは、git grep -h で確認することができます。 例えば、次のようなオプションが用意されています。 -i, --ignore-case &hellip; 大文字・小文字を区別しない 例: git grep -i &quot;github&quot; -n, --line-number &hellip; 行番号を表示する 例: git grep -n &quot;foobar&quot; -w, --word-regexp &hellip; 単語境界を考慮する 例: git grep -w &quot;Git&quot;__ （Git にはヒットし、GitHub にはヒットしなくなります） -p, --show-function &hellip; ヒットした行を含む関数の先頭行も表示する 例: git grep -p &quot;findUsers&quot; -- &quot;*.ts&quot; （findUsers を呼び出している関数を探すことができます） -h &hellip; 各行の先頭にファイル名を表示しない --recurse-submodules &hellip; サブモジュールのコードも含めて検索する 関数名を検索できる -p, --show-function オプションなどは面白いですね。"},{url:"/p/849syej/",title:"MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists)",date:"2023-11-12T00:00:00+09:00",body:"MNIST の手書き数字データをダウンロードして表示する (keras.datasets.mnists) MNIST とは MNIST (Modified National Institute of Standards and Technology) は、手書き数字認識のためのデータセット で、0 から 9 までの単一の数字が手書きされた 28x28 ピクセルのグレースケール画像が含まれています。 各画像は対応する数字のラベルを持っており、機械学習や深層学習のアルゴリズムのトレーニングやテストに使用されます。 MNIST データの取得 MNIST のデータは、Python の keras.datasets パッケージを使って簡単に取得することができます。 MNIST のデータを取得 import math from keras.datasets import mnist # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # データ形状を確認 print(&#34;X_train: {}&#34;.format(X_train.shape)) print(&#34;y_train: {}&#34;.format(y_train.shape)) print(&#34;X_test: {}&#34;.format(X_test.shape)) print(&#34;y_test: {}&#34;.format(y_test.shape)) 実行結果 X_train: (60000, 28, 28) y_train: (60000,) X_test: (10000, 28, 28) y_test: (10000,) mnist.load_data() が返す MNIST データは、学習用のデータとテスト用のデータに分かれており、それぞれ下記のような内容の NumPy 配列になっています。 X_train 学習用の画像（データ数: 60,000、サイズ: 28x28）。各要素には 0〜255 の輝度値が含まれており、X_train[画像Index][行Index][列Index] で参照できます。 y_train 学習用のラベル（データ数: 60,000）。各要素には 0〜9 の正解ラベルが含まれており、y_train[画像Index] で参照できます。 X_test テスト用の画像（データ数: 10,000、サイズ: 28x28）。各要素には 0〜255 の輝度値が含まれており、X_test[画像Index][行Index][列Index] で参照できます。 y_test テスト用のラベル（データ数: 10,000）。各要素には 0〜9 の正解ラベルが含まれており、y_test[画像Index] で参照できます。 ちなみに、X_train や X_test の X が大文字になっているのは、多次元ベクトルであることを示すための慣例です。 逆に正解ラベルである y_train や y_test は 1 次元データなので y を小文字にしています。 MNIST の手書き画像を表示する matplotlib などを使って、MNIST の画像データを表示することができます。 次の例では、学習用データの先頭の 15 個を表示しています。 図: MNIST に含まれる手書き数字 MNIST の手書き数字を表示する import math from keras.datasets import mnist from matplotlib import pyplot as plt # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # 画像をまとめて表示 def show_images(images, ncols=5): nrows = math.ceil(len(images) / ncols) _, ax = plt.subplots(nrows, ncols, tight_layout=True, figsize=(ncols*1.5, nrows*1.5)) for i, img in enumerate(images): x = i % ncols y = i // ncols axis = ax[x] if nrows == 1 else ax[y][x] axis.set_title(i) axis.imshow(img, cmap=&#34;gray&#34;) plt.show() # 先頭の 15 個の画像を表示 show_images(X_train[:15]) サンプルコード内の show_images 関数は、任意の数の画像を表示できるようにしてあります。 （おまけ）CNN による学習 Keras で CNN モデルを構築して手書き数字画像を学習する実装例です。 from keras.datasets import mnist from keras.models import Sequential from keras.layers import Conv2D, Dense, Dropout, Flatten, MaxPooling2D from keras.optimizers import RMSprop from keras.utils import to_categorical # MNIST の手書き数字データをロード (X_train, y_train), (X_test, y_test) = mnist.load_data() # サイズ情報 WIDTH, HEIGHT = X_train[0].shape # 画像の横幅と高さを取得 CHANNELS = 1 # 画像のチャネル数はグレースケールなので 1 INPUT_SHAPE = (HEIGHT, WIDTH, CHANNELS) OUTPUT_SIZE = 10 # CNN への入力用に三次元データに変換し、画素値を 0〜1 に正規化 X_train = X_train.reshape(-1, HEIGHT, WIDTH, CHANNELS) #=&gt; (60000, 28, 28, 1) X_train = X_train.astype(&#34;float32&#34;) / 255 X_test = X_test.reshape(-1, HEIGHT, WIDTH, CHANNELS) #=&gt; (10000, 28, 28, 1) X_test = X_test.astype(&#34;float32&#34;) / 255 # 正解ラベルを one-hot ベクトル化 y_train = to_categorical(y_train.astype(&#34;int32&#34;), OUTPUT_SIZE) #=&gt; (60000, 10) y_test = to_categorical(y_test.astype(&#34;int32&#34;), OUTPUT_SIZE) #=&gt; (10000, 10) # CNN モデルを作成 model = Sequential() model.add(Conv2D(32, kernel_size=(3, 3), activation=&#34;relu&#34;, input_shape=INPUT_SHAPE)) model.add(Conv2D(64, kernel_size=(3, 3), activation=&#34;relu&#34;)) model.add(MaxPooling2D(pool_size=(2, 2))) model.add(Dropout(0.25)) model.add(Flatten()) model.add(Dense(128, activation=&#34;relu&#34;)) model.add(Dropout(0.5)) model.add(Dense(OUTPUT_SIZE, activation=&#34;softmax&#34;)) # モデルのコンパイル model.compile(loss=&#34;categorical_crossentropy&#34;, optimizer=RMSprop(), metrics=[&#34;accuracy&#34;]) # 学習 hist = model.fit(X_train, y_train, batch_size=128, epochs=6, verbose=1, validation_data=(X_test, y_test)) # 評価 score = model.evaluate(X_test, y_test, verbose=1) print(&#34;accuracy={}, loss={}&#34;.format(score[1], score[0])) # epochs=1 で accuracy=0.983 くらい # epochs=3 で accuracy=0.988 くらい # epochs=6 で accuracy=0.991 くらい"},{url:"/p/jf6kyao/",title:"Python の関数をキーワード引数を使って呼び出す",date:"2023-11-12T00:00:00+09:00",body:"Python の関数をキーワード引数を使って呼び出す 位置引数とキーワード引数 Python の関数を呼び出すときの引数の指定方法には、下記の 2 種類があります。 位置引数 (positional argument) &hellip; 定義された順序通りに引数を渡す方法。 キーワード引数 (keyword argument) &hellip; 引数名=値 のように引数名と値のペアで渡す方法。他の言語だと「名前付き引数」と呼ばれていたりします。 次の例では、2 つの文字列引数を受け取る show_book 関数を、それぞれの引数指定方法で呼び出しています。 def show_book(title: str, author: str) -&gt; None: print(f&#34;{title} by {author}&#34;) # 位置引数 (positional argument) による関数呼び出し show_book(&#34;The Hobbit&#34;, &#34;J.R.R. Tolkien&#34;) # キーワード引数 (keyword argument) による関数呼び出し show_book(author=&#34;J.R.R. Tolkien&#34;, title=&#34;The Hobbit&#34;) 位置引数による呼び出しの方が短く記述できますが、このように同じ型 (str) の引数が複数ある場合は、キーワード引数を使った方が呼び出し順序の間違いによる不具合が入りにくくなります。 後者の呼び出し方を見るとわかるように、キーワード引数を使うと、任意の順番で引数を記述できます。 位置引数とキーワード引数を混ぜて呼び出すこともできますが、すべての位置引数をキーワード引数よりも前に配置する必要があります。 show_book(&#34;The Hobbit&#34;, author=&#34;J.R.R. Tolkien&#34;) # OK show_book(title=&#34;The Hobbit&#34;, &#34;J.R.R. Tolkien&#34;) # Syntax Error ちなみに、キーワード引数を使う場合、= の前後にはスペースを入れないのが慣例です。 デフォルト引数との組み合わせ キーワード引数による関数呼び出しの真価が発揮されるのは、引数にデフォルト値が設定されているときです。 次の draw_rect 関数は、3 つの引数を取りますが、それらすべてにデフォルト値が設定されています。 このような場合、キーワード引数を使って関数を呼び出すことで、任意の引数を省略することができます（位置引数を使うと、後方にある引数しか省略できません）。 def draw_rect(width: int = 10, height: int = 3, char: str = &#34;*&#34;) -&gt; None: &#34;&#34;&#34;指定したサイズの矩形を描画します。&#34;&#34;&#34; assert len(char) == 1, &#34;char argument must be a single character&#34; for _ in range(height): print(char * width) draw_rect() draw_rect(char=&#34;o&#34;) draw_rect(width=20, height=2) draw_rect(char=&#34;x&#34;, width=15) 実行結果 ********** ********** ********** oooooooooo oooooooooo oooooooooo ******************** ******************** xxxxxxxxxxxxxxx xxxxxxxxxxxxxxx xxxxxxxxxxxxxxx シーケンスや辞書オブジェクトを展開して関数に渡す 引数として渡す値を、リストや辞書の形でまとめて定義しておいて、関数呼び出し時に展開して渡すことができます。 リストの内容を位置引数として関数に渡すには、リストオブジェクトの前に * プレフィックスを付けます。 リスト（シーケンス）を位置引数として渡す args = [5, 2, &#34;x&#34;] draw_square(*args) # draw_square(5, 2, &#34;x&#34;) と同様 辞書の内容をキーワード引数として関数に渡すには、辞書オブジェクトの前に ** プレフィックスを付けます。 辞書をキーワード引数として渡す kwargs = {&#34;char&#34;: &#34;x&#34;, &#34;height&#34;: 2} draw_square(**kwargs) # draw_square(char=&#34;x&#34;, height=2) と同様 これらを組み合わせて使用する場合は、引数の基本ルール通り、位置引数を先に配置する必要があります。 args = [3] kwargs = {&#34;char&#34;: &#34;x&#34;} draw_square(5, *args, **kwargs) # draw_square(5, 3, char=&#34;x&#34;) と同様 キーワード引数による呼び出しを強制する 関数のパラメーターとして * とだけ記述すると、それ以降のパラメーターは、関数呼び出し時にキーワード引数の形でしか指定できなくなります。 本質的にオプショナルなパラメーターなどに使うとよさそうです。 次の例では、delay 引数の値を指定するときは、必ず delay=1 のようなキーワード引数の形で指定するよう強制しています。 import time def greet(name: str, *, delay: int = 0) -&gt; None: &#34;&#34;&#34;Greets someone with a delay.&#34;&#34;&#34; time.sleep(delay) print(f&#34;Hello, {name}!&#34;) # 使用例 greet(&#34;Alice&#34;) # OK greet(&#34;Bob&#34;, delay=1) # OK greet(&#34;Carol&#34;, 1) # Error! ちなみに、上記の delay パラメーターのように、キーワード引数での呼び出しを強制したものを、公式ドキュメントでは keyword-only parameters と呼んでいます。 関数定義で、最初のパラメーターに * を配置すれば、すべてのパラメーターを keyword-only parameters にすることができます。 次の show_book 関数を呼び出すには、すべての引数をキーワード引数の形で指定する必要があります。 def show_book(*, title: str, author: str) -&gt; None: &#34;&#34;&#34;Shows book information.&#34;&#34;&#34; print(f&#34;{title} by {author}&#34;) # 使用例 show_book(title=&#34;The Hobbit&#34;, author=&#34;J.R.R. Tolkien&#34;) # OK show_book(author=&#34;J.R.R. Tolkien&#34;, title=&#34;The Hobbit&#34;) # OK show_book(&#34;The Hobbit&#34;, &#34;J.R.R. Tolkien&#34;) # Error! この仕組みを使えば、関数の呼び出し時に引数の指定順序を間違える心配はなくなります（そもそも位置引数が使えなくなるので）。 もちろん、使いすぎは可読性を損なうので要注意です。 （おまけ）デフォルト引数は一度しか初期化されない 引数のデフォルト値としてイミュータブル（可変）なオブジェクトを設定している場合は、関数呼び出し時にそのオブジェクトが使いまわされることに注意してください。 下記の関数の buffer 引数に設定しているデフォルト値 ([]) に値を追加すると、2 度目以降の関数呼び出し時にもその値が残っています。 from typing import List def append_and_dump(val: int, buffer: List[int] = []) -&gt; None: buffer.append(val) # 次の関数呼び出しにも影響する print(buffer) append_and_dump(1) # =&gt; [1] append_and_dump(2) # =&gt; [1, 2] append_and_dump(3) # =&gt; [1, 2, 3] このような振る舞いを防ぐには、引数が省略されたときに明示的に新しいオブジェクトを作成するようにします。 from typing import List def append_and_dump(val: int, buffer: List[int] = None) -&gt; None: if buffer is None: buffer = [] buffer.append(val) print(buffer) append_and_dump(1) # =&gt; [1] append_and_dump(2) # =&gt; [2] append_and_dump(3) # =&gt; [3] 参考 Python の関数で可変長引数を扱う (*args, **kwargs)"},{url:"/p/nz8zoxu/",title:"scikit-image の data パッケージに含まれるテスト画像を使用する",date:"2023-11-10T00:00:00+09:00",body:"scikit-image の data パッケージに含まれるテスト画像を使用する scikit-image の data パッケージ scikit-image の data パッケージには、画像処理のテストに使えるテスト画像データが含まれています。 画像データを読み込むには、画像ごとに用意された関数を呼び出します。 次の例では、data.astronaut() 関数で宇宙飛行士の画像データを取得しています。 画像データは NumPy 配列データ (ndarray) として返されます。 from skimage import data # 画像データを読み込む img = data.astronaut() # 画像データの形式を調べる print(type(img)) #=&gt; &lt;class &#39;numpy.ndarray&#39;&gt; print(img.shape) #=&gt; (512, 512, 3) この画像データのサイズは 512x512 で、カラー画像（3 チャネル）であることが分かります。 読み込んだ画像データを表示する matplotlib パッケージを使えば、画像データ（NumPy 配列）を画面上に出力することができます。 図: skimage.data.astronaut() の画像データ from matplotlib import pyplot as plt from skimage import data # 画像データを読み込む img = data.astronaut() # matplotlib で画面に表示 fig, ax = plt.subplots(figsize=(4, 4), dpi=72) ax.imshow(img) plt.show() # （別の書き方） # plt.figure(figsize=(4, 4), dpi=72) # plt.imshow(img) # plt.show() 他の画像データ scikit-image の data パッケージは他にもいくつかの画像データを提供しています。 下記は汎用的に使える画像データの一覧です（詳しくはこちらの公式ドキュメント）。 イメージ データ取得関数 shape 色 data.astronaut() (512, 512, 3) カラー data.binary_blobs() (512, 512) グレースケール data.brick() (512, 512) グレースケール data.colorwheel() (370, 371, 3) カラー data.camera() (512, 512) グレースケール data.cat() (300, 451, 3) カラー data.checkerboard() (200, 200) グレースケール data.clock() (300, 400) グレースケール data.coffee() (400, 600, 3) カラー data.coins() (303, 384) グレースケール data.grass() (512, 512) グレースケール data.gravel() (512, 512) グレースケール data.horse() (328, 400) グレースケール data.logo() (500, 500, 4) カラー data.page() (191, 384) グレースケール data.text() (172, 448) グレースケール data.rocket() (427, 640, 3) カラー （おまけ）上記の一覧を出力するコード import matplotlib.pyplot as plt from skimage import data images = (&#39;astronaut&#39;, &#39;binary_blobs&#39;, &#39;brick&#39;, &#39;colorwheel&#39;, &#39;camera&#39;, &#39;cat&#39;, &#39;checkerboard&#39;, &#39;clock&#39;, &#39;coffee&#39;, &#39;coins&#39;, &#39;grass&#39;, &#39;gravel&#39;, &#39;horse&#39;, &#39;logo&#39;, &#39;page&#39;, &#39;text&#39;, &#39;rocket&#39;) for name in images: # 画像データの読み込み caller = getattr(data, name) # 関数名から関数を取得 img = caller() # 出力 print(&#34;{} {}&#34;.format(name, img.shape)) plt.figure(figsize=(3, 0.8)) plt.axis(&#39;off&#39;) cmap = plt.cm.gray if img.ndim == 2 else None plt.imshow(img, cmap=cmap) plt.show()"},{url:"/p/apkiihk/",title:"Python の scikit-image で画像処理",date:"2023-11-08T00:00:00+09:00",body:"Python の scikit-image で画像処理 scikit-image とは scikit-image は Pytyon 用の画像処理パッケージで、画像の入出力、変換、表示まで 1 パッケージで容易に行うことができます。 読み込んだ画像データは NumPy 配列として保持されるため、NumPy 配列の各種メソッドを使用して画素値を直接処理することができます。 高速な画像処理が可能なライブラリとして OpenCV などもありますが、scikit-image は OpenCV よりも学習が容易です。 科学的な画像処理には scikit-image、リアルタイムでのコンピュータービジョンタスクには OpenCV、と使い分けるとよさそうです。 scikit-image のインストール scikit-image パッケージは pip install コマンドで簡単にインストールできます（最新バージョンへの更新を兼ねるには -U オプションを付けます）。 依存する numpy、scipy、pillow などのパッケージもまとめてインストールされます。 できれば、venv 環境 にインストールすることをお勧めします。 scikit-image のインストール $ python -m pip install -U scikit-image 画面上に画像を表示する関数 (io.imshow()) を使用する場合は、matplotlib パッケージもインストールしておく必要があります。 matplotlib のインストール $ python -m pip install -U matplotlib Python コードからインポートするパッケージの名前は scikit-image ではなく、skimage なので注意してください。 skimage の機能は、次のようにサブパッケージとして分けられています。 io &hellip; 画像の読み書きや、画面への表示 transform &hellip; 回転などの画像変換処理 color &hellip; 色空間の変換 data &hellip; テスト用の画像データ img = data.astronaut() のようにテスト画像データで簡単にお試しできます。 画像ファイルを読み込む 図: 画像ファイル (cat-64x64.jpg) scikit-image で画像ファイルを読み込むには、io.imread() 関数を使用します。 読み込んだ画像データは、NumPy 配列 (numpy.ndarray) として保持されます。 次の例では、64x64 サイズのカラー画像を読み込んでいます。 from skimage import io img = io.imread(&#34;cat-64x64.jpg&#34;) print(type(img)) # =&gt; &lt;class &#39;numpy.ndarray&#39;&gt; print(img.shape) # =&gt; (64, 64, 3) NumPy 配列の値を出力してみると、各画素値 (R, G, B) の値が格納されていることを確認できます。 print(img) 実行結果 [[[215 238 232] [216 236 234] [219 234 237] ... [119 80 81] [124 88 92] [133 98 102]] ... NumPy 配列は 3 次元ベクトルの形で、[行, 列, チャネル] という構成になっているので、例えば次のようにして画素値を取り出すことができます。 print(img[0, 0]) # =&gt; [215 238 232] （左上の 1 ピクセルの RGB 値） print(img[0, 0, :]) # =&gt; 同上 print(img[0, 0, 0]) # =&gt; 215 （左上 の 1 ピクセルの R 値） print(img[0, 0, 1]) # =&gt; 238 （左上 の 1 ピクセルの G 値） print(img[0, 0, 2]) # =&gt; 232 （左上 の 1 ピクセルの B 値） print(img[0, :, 0]) # =&gt; [215 216 219 ... 133] （1 行目のすべての列のピクセルの R 値） print(img[:, 0, 0]) # =&gt; [215 219 227 ... 146] （1 列目のすべての行のピクセルの R 値） io.imread() で画像を読み込むときに、as_gray=True オプションを指定すると、グレースケール化された NumPy 配列データを取得することができます。 この場合、RGB の 3 チャネルではなく、1 チャネルのデータになるので、NumPy 配列は 2 次元データになります。 img = io.imread(&#34;cat-64x64.jpg&#34;, as_gray=True) print(type(img)) # =&gt; &lt;class &#39;numpy.ndarray&#39;&gt; print(img.shape) # =&gt; (64, 64) print(img[0, 0]) # =&gt; 0.9124701960784314（左上の画素値） 画像を表示する NumPy 配列として保持している画像データを、画面上に表示するには im.imshow() 関数を使用します。 Jupyter Notebook などの GUI 環境を使用していない場合は、続けて im.show() を実行して、各種 OS (Windows/macOS/Linux) のウィンドウを表示する必要があります。 from skimage import io img = io.imread(&#34;cat-64x64.jpg&#34;) io.imshow(img) io.show() 図: io.imshow() による画像表示 画像を表示するだけであれば、実は次のように直接ファイル名を指定するだけで表示できます。 io.imshow(&#34;cat-64x64.jpg&#34;) io.show() 次のように明示的に matplotlib.pyplot モジュールをインポートして使う方法もあります。 matplotlib で細かい出力制御をしたいときは、こちらの方法を使うとよいです。 from matplotlib import pyplot as plt from skimage import io img = io.imread(&#34;cat-64x64.jpg&#34;) plt.imshow(img) plt.show() RGB の各成分を取り出す 図: RGB 各成分の強度をグレースケールで表示 画像データ（NumPy 配列）の 3 次元目には、各画素の RGB 成分が含まれています。 次のように配列スライスを使って、各チャネルの成分を抽出することができます。 RGB の各チャネルを抽出 import matplotlib.pyplot as plt from skimage import io img = io.imread(&#34;cat-64x64.jpg&#34;) img_r = img[:, :, 0] # 全ピクセルの R 成分 img_g = img[:, :, 1] # 全ピクセルの G 成分 img_b = img[:, :, 2] # 全ピクセルの B 成分 # 画像の表示 fig, ax = plt.subplots(1, 4, figsize=(8, 2), dpi=72, layout=&#34;tight&#34;) ax[0].set_title(&#34;RGB&#34;) ax[0].imshow(img) ax[1].set_title(&#34;R&#34;) ax[1].imshow(img_r, cmap=&#34;gray&#34;) ax[2].set_title(&#34;G&#34;) ax[2].imshow(img_g, cmap=&#34;gray&#34;) ax[3].set_title(&#34;B&#34;) ax[3].imshow(img_b, cmap=&#34;gray&#34;) for a in ax: a.set_axis_off() # 軸を表示しない plt.show() 上の例では、imshow() 関数の cmap でカラーマップを gray に指定したので、画素値 0 が黒、画素値 255 が白になるように表示されています。 カラーマップを変更することで、各成分の強度を異なる色表現で表示することができます（参考: Choosing Colormaps in Matplotlib）。 例えば、Grays（あるいは Greys）を使うと、画素値 0 が白、画素値 255 が黒となるようなグレースケールで表示されます。 図: カラーマップに Grays を指定した場合 ax[1].imshow(img_r, cmap=&#34;Grays&#34;) ax[2].imshow(img_g, cmap=&#34;Grays&#34;) ax[3].imshow(img_b, cmap=&#34;Grays&#34;) カラーマップとして Reds、Greens、Blues を指定すると、各チャネルの強度を直感的な色で表示できます。 図: カラーマップに Reds/Greens/Blues を指定した場合 ax[1].imshow(img_r, cmap=&#34;Reds&#34;) ax[2].imshow(img_g, cmap=&#34;Greens&#34;) ax[3].imshow(img_b, cmap=&#34;Blues&#34;)"},{url:"/p/pa2us3b/",title:"pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes)",date:"2023-10-23T00:00:00+09:00",body:"pandas の DataFrame から数値カラムだけ抽出する (df.select_dtypes) Pandas の DataFrame から、数値タイプ（int64 や float64）のカラムだけを抽出するには、df.select_dtypes() メソッドを使用します。 次の例では、サンプルの DataFrame から数値タイプのカラム名を抽出して列挙しています。 import numpy as np import pandas as pd # サンプルの DataFrame を作成 data = { &#39;列1&#39;: [1, 2, 3], &#39;列2&#39;: [1.1, 2.2, 3.3], &#39;列3&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] } df = pd.DataFrame(data) # 数値タイプのカラムを抽出してカラム名のリストを取得 numerical_columns = df.select_dtypes(include=[np.number]).columns # 結果表示 print(numerical_columns) for col in numerical_columns: print(col) 実行結果 Index([&#39;列1&#39;, &#39;列2&#39;], dtype=&#39;object&#39;) 列1 列2 なお、上の例では数値型として np.number を指定していますが、&quot;number&quot; という文字列でも大丈夫です。"},{url:"/p/fk2e74z/",title:"pandas の DataFrame のカラムのデータ型を変更する (df.astype)",date:"2023-10-23T00:00:00+09:00",body:`pandas の DataFrame のカラムのデータ型を変更する (df.astype) Series と DataFrame の astype メソッド pandas の Series/DataFrame オブジェクトのデータ型を変換するには、astype() メソッドを使用します。 参考: pandas.Series.astype 参考: pandas.DataFrame.astype Series の astype() メソッドは、指定したデータ型に変換された新しい Series オブジェクトを返します。 Series のデータ型変換 ser1 = pd.Series([1, 2, 3], dtype=&#34;int64&#34;) # = np.int64 ser2 = ser1.astype(&#34;float64&#34;) # = np.float64 print(ser1.dtype) # int64 print(ser2.dtype) # float64 DataFrame の astype() メソッドを使用すると、複数カラムのデータ型をまとめて変換することができます。 DataFrame のデータ型変換 data = { &#34;列1&#34;: [1, 2, 3, 4], &#34;列2&#34;: [1.5, 2.8, 3.1, 4.3], } df1 = pd.DataFrame(data) df2 = df1.astype({&#34;列1&#34;: &#34;float64&#34;, &#34;列2&#34;: &#34;int32&#34;}) print(df2.dtypes) # int64 float64 print(df2.dtypes) # floay64 int32 もちろん、次のように DataFrame から個々の列を Series として取り出してから変換するのもありです。 df[&#34;列&#34;] = df[&#34;列&#34;].astype(&#34;float64&#34;) 整数にするときの切り捨て／切り上げ／四捨五入 astype() メソッドを使って浮動小数点数型 (float) のデータを整数型 (int) のデータに変換する場合、デフォルトでは少数点数以下は切り捨てられます。 少数点数以下を切り上げたり、四捨五入したい場合は、先に Series オブジェクトに対して、np.ceil() や np.round() などの NumPy 関数を適用しておきます。 df[&#34;列&#34;] = df[&#34;列&#34;].astype(int) # 切り捨て（デフォルト） df[&#34;列&#34;] = np.floor(df[&#34;列&#34;]).astype(int) # 切り捨て（同上） df[&#34;列&#34;] = np.ceil(df[&#34;列&#34;]).astype(int) # 切り上げ df[&#34;列&#34;] = np.round(df[&#34;列&#34;]).astype(int) # 四捨五入 具体例 次の例では、サンプルの DataFrame を作成して、その中の数値カラムの型を変換しています。 DataFrame のデータタイプ変換 import pandas as pd # サンプルの DataFrame を作成 data = { &#34;col-1&#34;: [1, 2, 3, 4], &#34;col-2&#34;: [1.5, 2.8, 3.1, 4.3], &#34;col-3&#34;: [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;] } df = pd.DataFrame(data) print(&#34;変換前 ====================&#34;) print(df.dtypes) print() print(df) # col-1 列を浮動小数点数 (float64)、col-2 列を整数 (int64) に変換 df = df.astype({&#34;col-1&#34;: &#34;float64&#34;, &#34;col-2&#34;: &#34;int64&#34;}) print(&#34;\\n変換後 ====================&#34;) print(df.dtypes) # カラムのデータ型を確認 print() print(df) 実行結果 変換前 ==================== col-1 int64 col-2 float64 col-3 object dtype: object col-1 col-2 col-3 0 1 1.5 A 1 2 2.8 B 2 3 3.1 C 3 4 4.3 D 変換後 ==================== col-1 float64 col-2 int64 col-3 object dtype: object col-1 col-2 col-3 0 1.0 1 A 1 2.0 2 B 2 3.0 3 C 3 4.0 4 D`},{url:"/p/o7qnbeg/",title:"scikit-learn 組み込みのデータセットを扱う (sklearn.dataset)",date:"2023-10-18T00:00:00+09:00",body:"scikit-learn 組み込みのデータセットを扱う (sklearn.dataset) scikit-learn の sklearn.datasets モジュールは、組み込みのデータセットをロードする関数 (load_*) や、インターネット上のデータセットを取得する関数 (fetch_*) を提供しています。 scikit-learn の各種モジュールの振る舞いを学ぶときは、これらのデータセットをサンプルデータとして使うと便利です。 組み込みのデータセット load_ で始まる関数を使用すると、scikit-learn に組み込まれているデータセットを読み込むことができます。 データ数は少ないですが、実験には十分です。 使用例 from sklearn.datasets import load_diabetes diabetes = load_diabetes() 関数名 用途 説明 load_diabetes 回帰 糖尿病 (diabetes) 患者の診断データです。このデータセットは、糖尿病患者の臨床データからなり、主に糖尿病の進行を予測するための回帰分析に使用されます。データには患者の年齢、性別、平均血圧、BMI（Body Mass Index）、血清の 6 つの生化学的特徴（血清中の濃度など）などの特徴が含まれています。1 年後の糖尿病の進行を示す数値を予測します。 load_linnerud 回帰 体力トレーニングの効果に関する 2 つのデータセットです。Physical Exercise Data: このデータセットには、20 人の被験者の体力トレーニングに関する情報が含まれています。特徴量には、腕立て伏せ、仰向けの上体起こし、スクワットの回数が含まれており、これらの情報はトレーニングの効果を示すものです。Physiological Data: このデータセットには、20人の被験者の生理学的データが含まれており、特徴量には体重、腕立て伏せ、仰向けの上体起こし、腕立て伏せと仰向けの上体起こしの最大心拍数などが含まれています。 load_breast_cancer 分類 乳がん (breast cancer) 患者の腫瘍に関するデータで、主に乳がんの分類タスクに使用されます。データには腫瘍の特性に関する情報（腫瘍の半径、テクスチャ、周囲の腫瘍の平滑度など）が含まれており、それぞれのサンプルが「良性」または「悪性」のいずれかに分類されています。 load_digits 分類 手書き数字認識のための画像データです。0 から 9 までの手書き数字の画像が含まれており、各画像は 8x8 ピクセルのグレースケール画像として表現されています。機械学習アルゴリズムを使用して手書き数字を識別するために使用できます。 load_iris 分類 アヤメ（iris）の計測データです。iris データセットは、機械学習の教育と実験用に広く使用されるデータセットの一つです。3 つの異なる種類のアヤメの花の特性が含まれており、各花の 4 つの特徴量が記録されています。これらの特徴量は、がく片（sepal）と花弁（petal）の長さと幅に関するもので、アヤメの種類を分類するために使用できます。 load_wine 分類 ワインの化学的特性に関するデータセットです。異なる種類のワインの特性に関する情報が含まれており、主にワインの分類タスクや品質評価に使用されます。データにはアルコール濃度、酸度、フェノール類の濃度、色の強さ、色の濃さなど、ワインの化学的特性に関する 13 の特徴量が含まれています。各サンプルは 3 つの異なるワインクラス（種類）に属しています。 load_sample_image 画像 指定した画像のデータセットを numpy array として取得できます。&quot;china&quot;: 中国の風景画像で、機械学習のコンピュータビジョンタスクなどで使用されます。&quot;flower&quot;: 花の画像で、画像処理や画像分類のタスクに使用されます。 ダウンロード可能なデータセット fetch_ で始まる関数を使うと、インターネット上で公開されている有名なデータセットを読み込むことができます。 関数名 用途 説明 fetch_california_housing 回帰 カリフォルニアの住宅価格に関するデータセットで、カリフォルニア州の異なる地域（ブロックグループ）に関する住宅価格の情報とその地域の特徴に関する情報を含みます。具体的には、以下の特徴量が含まれています:住宅価格の中央値収入の中央値住宅の年齢の中央値部屋数の中央値寝室数の中央値人口の中央値世帯数の中央値地理的な位置情報（緯度と経度）このデータセットは、住宅価格の回帰分析や予測モデルをトレーニングするために使用されます。 fetch_20newsgroups 分類 20 Newsgroups データセットは、ニュースグループのメッセージからなるテキストデータセットで、クラスタリングやテキスト分類などの自然言語処理タスクのために使用されます。20 の異なるニュースグループが含まれており、それぞれのニュースグループに関するテキストメッセージが含まれています。このデータセットは、カテゴリ分類やテキスト処理の実験に広く使用されます。 fetch_20newsgroups_vectorized 分類 fetch_20newsgroups と同様ですが、ニュース記事がベクトルデータ（特徴量）化されています。 fetch_covtype 分類 木の種類を予測するためのデータセットで、土壌の種類や、標高、傾斜などの情報が含まれています。 fetch_kddcup99 分類 KDD99 のネットワーク侵入検知のコンペで用いられたデータで、持続時間やプロトコルなどの情報から攻撃の種類を予測します。 fetch_lfw_people 分類 LFW（Labeled Faces in the Wild）データセットは、多くの有名人や一般の人々の顔画像です。主に顔認識や顔検出などのコンピュータビジョンタスクの評価に使用されます。顔画像のピクセル値とそれに対応するラベル（各画像の人物の名前）が含まれています。 fetch_lfw_pairs 分類 異なる顔写真のペアで、同じ人物の場合と、異なる人物の場合があります。顔認識モデルのトレーニング、人物の同一性認識、シャッフルされた同一性認識など、さまざまなコンピュータビジョンタスクに使用できます。 fetch_olivetti_faces 分類 Olivetti Research Laboratory が収集した顔画像 (Olivetti Faces) データセットです。40 人の異なる被写体に対する顔画像のコレクションで、各被写体について、10 枚の異なる表情やポーズの画像が含まれています。画像は白黒で、サイズは 64x64 ピクセルです。このデータセットは、顔認識、顔検出、表情認識、顔の特徴量抽出など、さまざまなコンピュータビジョンタスクのトレーニングおよび評価に使用されます。 fetch_rcv1 分類 Reuters Corpus Volume I（RCV1）はニュース記事のコレクションで、カテゴリ分類タスクやトピックモデリングなどの自然言語処理タスクに使用できる大規模なテキストデータセットです。RCV1 データセットには、ニュース記事の本文や関連するカテゴリ情報が含まれています。 fetch_openml その他 OpenML プロジェクトからデータセットをダウンロードします。OpenML は、機械学習コミュニティに対して多くの機械学習データセットを提供するプラットフォームです。OpenML のデータセットは、分類、回帰、クラスタリング、異常検出など、さまざまな機械学習タスクに使用できます。 データセットを pandas のデータフレームにする dataset モジュールが返すデータは numpy.ndarray 形式になっているので、pandas でデータ処理したいときは、DataFrame 形式に変換する必要があります。 diabetes データセットからデータフレームを作成する import pandas as pd from sklearn.datasets import load_diabetes # 糖尿病のデータセットをロード diabetes = load_diabetes() # DataFrame 形式にする df = pd.DataFrame(data=diabetes.data, columns=diabetes.feature_names) print(df.head(3)) # 目的変数（糖尿病の進行状況） print(diabetes.target[:3]) 実行結果 age sex bmi bp s1 s2 s3 \\ 0 0.038076 0.050680 0.061696 0.021872 -0.044223 -0.034821 -0.043401 1 -0.001882 -0.044642 -0.051474 -0.026328 -0.008449 -0.019163 0.074412 2 0.085299 0.050680 0.044451 -0.005670 -0.045599 -0.034194 -0.032356 s4 s5 s6 0 -0.002592 0.019907 -0.017646 1 -0.039493 -0.068332 -0.092204 2 -0.002592 0.002861 -0.025930 [151. 75. 141.] wine データセットからデータフレームを作成する import pandas as pd from sklearn.datasets import load_wine # ワインのデータセットをロード wine = load_wine() # DataFrame 形式にする df = pd.DataFrame(data=wine.data, columns=wine.feature_names) print(df.head(3)) # 目的変数（ワインの種類） print(wine.target[:3]) 実行結果 alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols \\ 0 14.23 1.71 2.43 15.6 127.0 2.80 1 13.20 1.78 2.14 11.2 100.0 2.65 2 13.16 2.36 2.67 18.6 101.0 2.80 flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue \\ 0 3.06 0.28 2.29 5.64 1.04 1 2.76 0.26 1.28 4.38 1.05 2 3.24 0.30 2.81 5.68 1.03 od280/od315_of_diluted_wines proline 0 3.92 1065.0 1 3.40 1050.0 2 3.17 1185.0 [0 0 0]"},{url:"/p/ioj6bqf/",title:"pandas で CSV/TSV ファイルを出力する (pd.to_csv)",date:"2023-10-14T00:00:00+09:00",body:"pandas で CSV/TSV ファイルを出力する (pd.to_csv) 参考 pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) pandas で DataFrame オブジェクトの内容を CSV/TSV ファイルに出力するには、DataFrame#to_csv() メソッドを使用します。 テスト用の DataFrame ここでは、出力用の DataFrame オブジェクトを次のように作成しておきます。 インデックス名に idx1〜idx3、カラム名に col1〜col3 をセットしています。 import numpy as np import pandas as pd np.random.seed(12345) # 乱数の再現性を確保 df = pd.DataFrame({ &#34;col1&#34;: np.random.randint(10, size=3), &#34;col2&#34;: np.random.randint(10, size=3), &#34;col3&#34;: [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;], }, index=[&#34;idx1&#34;, &#34;idx2&#34;, &#34;idx3&#34;]) print(df) 実行結果 col1 col2 col3 idx1 2 4 AAA idx2 5 9 BBB idx3 1 5 CCC CSV/TSV に出力する to_csv() メソッドの基本 パラメーターなしで to_csv() メソッドを呼び出すと、インデックス名やカラム名（CSV のヘッダー行）も含めて出力されます。 これは、パラメーターのデフォルト値が index=True, header=True になっているからです。 df.to_csv(&#34;output.csv&#34;) output.csv ,col1,col2,col3 idx1,2,4,AAA idx2,5,9,BBB idx3,1,5,CCC ちなみに、DataFrame にインデックス名が明示的にセットされていない場合は、次のように 0, 1, 2 という連番が振られます。 output.csv ,col1,col2,col3 0,2,4,AAA 1,5,9,BBB 2,1,5,CCC TSV 形式で出力する (sep) セパレーター文字はデフォルトでカンマ (,) ですが、sep パラメーターで任意のセパレーター文字を設定できます。 タブ (\\t) を指定すれば、TSV ファイルとして出力できます。 TSV 形式で出力する df.to_csv(&#34;output.tsv&#34;, sep=&#34;\\t&#34;) output.tsv col1	col2	col3 idx1	2	4	AAA idx2	5	9	BBB idx3	1	5	CCC インデックス列やヘッダー行を出力しない (index, header) インデックス列を出力したくないときは、index=False パラメーターを指定します。 同様に、ヘッダー行（カラム名）を出力したくないときは、header=False パラメーターを指定します。 インデックス列を出力しない df.to_csv(&#34;output.csv&#34;, index=False) col1,col2,col3 2,4,AAA 5,9,BBB 1,5,CCC インデックス列もヘッダー行も出力しない df.to_csv(&#34;output.csv&#34;, index=False, header=False) 2,4,AAA 5,9,BBB 1,5,CCC インデックス列のカラム名を指定する (index_label) インデックス列のカラム名（ラベル）を指定するには、index_label パラメーターを指定します。 デフォルトでは空文字列になってしまうので、カラム列を出力する場合は、この index_label も設定しておくことをお勧めします。 インデックス列に id というラベルを付ける df.to_csv(&#34;output.csv&#34;, index=True, index_label=&#34;id&#34;) id,col1,col2,col3 idx1,2,4,AAA idx2,5,9,BBB idx3,1,5,CCC"},{url:"/p/rtc38u8/",title:"pandas チートシート - DataFrame の欠損値 (NaN) の扱い方まとめ",date:"2023-09-06T00:00:00+09:00",body:"pandas チートシート - DataFrame の欠損値 (NaN) の扱い方まとめ チートシート（DataFrame の欠損値の扱い） 概要 コード 欠損値を表現する np.nan 欠損値部分を True、それ以外を False にする df2 = df.isnull() 欠損値以外の True、それ以外を True にする df2 = df.notnull() 欠損値を数える df.isnull().sum()df.isnull().sum(axis=1) 非欠損値を数える df.notnull().sum()df.count()df.info() 欠損値がある列／行を探す df.isnull().any()df.isnull().any(axis=1) 欠損値を含む「行」を削除する df.dropna()df.dropna(axis=0)df.dropna(axis=&quot;index&quot;) 欠損値を含む「列」を削除する df.dropna(axis=1)df.dropna(axis=&quot;columns&quot;) 欠損値を補完する df[&quot;列&quot;] = df[&quot;列&quot;].fillna(値)df[&quot;列&quot;].fillna(値, inplace=True) isnull() は isna() のエイリアスです。 Python コードでの欠損値 (NaN) の表現方法 pandas では、値が存在しないことを欠損値 (NaN: Not a Number) が存在すると表現します（プログラム的には何らかの値で「値がない」ことを表現しないといけないため）。 欠損値は、NumPy の np.nan で表現することができます。 import numpy as np print(np.nan) # nan print(type(np.nan)) # &lt;class &#39;float&#39;&gt; ちなみに、CSV ファイルを pd.read_csv() で読み込んだ場合、何も記述されていない部分に欠損値 (np.nan) が格納されます。 逆に値が存在することは、Non-null（非欠損値）と表現したりします。 欠損値部分とそれ以外の要素を True/False 値に変換する (isnull, notnull) DataFrame の isnull() メソッドを使うと、各データが欠損値かどうかを True/False の形で取得できます。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ &#34;title&#34;: [&#34;Title-1&#34;, &#34;Title-2&#34;, np.nan, &#34;Title-4&#34;, &#34;Title-5&#34;], &#34;price&#34;: [1000, np.nan, 3000, 4000, np.nan] }) print(df.isnull()) 実行結果 title price 0 False False 1 False True 2 True False 3 False False 4 False True isnull() の代わりに notnull() を使うと、True/False が反転した結果を得られます。 print(df.notnull()) 実行結果 title price 0 True True 1 True False 2 False True 3 True True 4 True False 欠損値・非欠損値を数える (isnull, notnull, sum, count, info) 欠損値 (NaN) を数える df.isnull() を実行すると、欠損値部分だけが True になった DataFrame を生成できます。 その True の数を sum() で集計すれば、欠損値 (NaN) の数を数えることができます。 &gt;&gt;&gt; df.isnull().sum() title 1 price 2 dtype: int64 これで、title 列には欠損値が 1 つ、price 列には欠損値が 2 つ存在することが分かりました。 特定の列の欠損値 (NaN) の数をスカラー値（整数）で取得するには次のようにします。 例: price 列の欠損値 (NaN) の数を取得 &gt;&gt;&gt; df[&#34;price&#34;].isnull().sum() 2 多くの場合、欠損値は列方向で集計しますが、sum(axis=1) とすることで、行ごとの欠損値数を取得することもできます。 &gt;&gt;&gt; df.isnull().sum(axis=1) 0 0 1 1 2 1 3 0 4 1 dtype: int64 非欠損値 (Non-null) を数える DataFrame の count() メソッドを使うと、各カラムの Non-null 値（非欠損値）の数を簡単に調べることができます。 &gt;&gt;&gt; df.count() # あるいは df.notnull().sum() title 4 price 3 dtype: int64 特定の列の非欠損値 (Non-null) の数をスカラー値（整数）で取得するには次のようにします。 例: price 列の非欠損値 (Non-null) 値の数を取得 &gt;&gt;&gt; df[&#34;title&#34;].count() # あるいは df[&#34;title&#34;].nonnull().sum() 4 非欠損値の数は、info() メソッドの出力の Non-Null Count 列でも確認できます。 &gt;&gt;&gt; df.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 5 entries, 0 to 4 Data columns (total 2 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 title 4 non-null object 1 price 3 non-null float64 dtypes: float64(1), object(1) memory usage: 208.0+ bytes 欠損値がある列／行を探す df.isnull() による欠損値の抽出結果に対して、any() メソッドを適用することで、欠損値の存在する列を調べることができます。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ &#34;title&#34;: [&#34;Title-1&#34;, &#34;Title-2&#34;, &#34;Title-3&#34;], &#34;price&#34;: [1000, np.nan, np.nan], }) print(df.isnull().any()) 実行結果 title False price True dtype: bool この結果から、price 列に欠損値が存在することが分かります。 欠損値の有無を行ごとに調べたいときは、any() メソッドの軸オプションで行方向 axis=1 を指定します。 print(df.isnull().any(axis=1)) 実行結果 0 False 1 True 2 True dtype: bool 欠損値を含む「行」を削除する 欠損値を 1 つでも含む行を削除するには、df.dropna() を使用します（あるいは df.dropna(axis=0) や df.dropna(axis=&quot;index&quot;) でも同様）。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ &#34;title&#34;: [&#34;Title-1&#34;, &#34;Title-2&#34;, np.nan, &#34;Title-4&#34;, &#34;Title-5&#34;], &#34;price&#34;: [1000, np.nan, 3000, 4000, np.nan] }) df2 = df.dropna() print(df2) 実行結果 title price 0 Title-1 1000.0 3 Title-4 4000.0 欠損値の有無を調べる列を絞るには、subset=[&quot;列1&quot;, &quot;列2&quot;] のようなオプションパラメーターで指定します。 指定する列が 1 つだけの場合は、リストではなく subset=&quot;列1&quot; のように指定することもできます。 title 列に欠損値を含む行を削除 &gt;&gt;&gt; df.dropna(subset=[&#34;title&#34;]) title price 0 Title-1 1000.0 1 Title-2 NaN 3 Title-4 4000.0 4 Title-5 NaN 欠損値を含む「列」を削除する 欠損値を 1 つでも含むカラム（列）を丸ごと削除するには、df.dropna(axis=1)（あるいは df.dropna(axis=&quot;columns&quot;)）を使います。 import numpy as np import pandas as pd # テストデータ df = pd.DataFrame({ &#34;col1&#34;: [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;, &#34;DDD&#34;, &#34;EEE&#34;], &#34;col2&#34;: [100, np.nan, 300, 400, 500], &#34;col3&#34;: [1.0, 2.0, np.nan, 4.0, 5.0] }) df2 = df.dropna(axis=1) print(df2) col2 列と col3 列には欠損値 (NaN) が含まれているので、それらの列が丸ごと削除されます。 実行結果 col1 0 AAA 1 BBB 2 CCC 3 DDD 4 EEE col1 列だけの DataFrame になってしまいました。。。 欠損値を補完する Series#fillna(値) メソッドは、Series 内の欠損値 (NaN) 部分を指定した値に置き換えた Series を返します。 DataFrame#fillna(値) メソッドも使えますが、通常は特定列の Series データに対して使うことになると思います。 機械学習において、欠損値が含まれている行をすべて削除 (dropna()) してしまうと、学習に使用するデータ数が不足してしまうことがあります。 そのような場合は、欠損値を平均値や中央値で補完するというテクニックがあります。 age 列の欠損値部分に 0 を入れる df[&#34;age&#34;].fillna(0, inplace=True) df[&#34;age&#34;] = df[&#34;age&#34;].fillna(0) // 同上 age 列の欠損値を平均値 (mean) で補う df[&#34;age&#34;].fillna(df[&#34;age&#34;].mean(), inplace=True) df[&#34;age&#34;] = df[&#34;age&#34;].fillna(df[&#34;age&#34;].mean()) // 同上 age 列の欠損値を中央値 (mode) で補う df[&#34;age&#34;].fillna(df[&#34;age&#34;].mode(), inplace=True) df[&#34;age&#34;] = df[&#34;age&#34;].fillna(df[&#34;age&#34;].mode()) // 同上"},{url:"/p/m4ggdkx/",title:"pandas チートシート - DataFrame のデータ加工方法まとめ",date:"2023-09-04T00:00:00+09:00",body:`pandas チートシート - DataFrame のデータ加工方法まとめ DataFrame 加工のチートシート 作成／追加 df["列"] = スカラー値 新しいカラムの作成（すべて同じ値） df["列"] = シリーズdf.assign(列=シリーズ) 新しいカラムの作成（Series の代入） df2 = df.copy() # shallow copydf2 = df.copy(deep=True) DataFrame のコピー df["列2"] = df["列1"] + 10df["列2"] = df.apply(lambda r: r["列1"] + 10, axis=1) 既存カラムの値を使って新しいカラムを作成 df2 = df[["列1", "列2", "列3"]] カラムの抽出 結合 (concat, merge) new_df = pd.concat([df1, df2]) 複数の DataFrame を縦結合 new_df = pd.merge(df1, df2, on="列", how="inner") 2 つの DataFrame を横結合 削除 (drop, drop_duplicates) df2 = df.drop(columns="列") df2 = df.drop("列", axis=1) 指定したカラムを削除 df.drop(columns="列", inplace=True) df.drop("列", axis=1, inplace=True) del df["列"] ※非推奨 df.pop("列") 指定したカラムを削除（自分自身を変更） df2 = df.drop(index="行") df2 = df.drop("行", axis=0) 指定した行を削除 df.drop(index="行", inplace=True) df.drop("行", axis=0, inplace=True) 指定した行を削除（自分自身を変更） df2 = df[df["列"] != 値] 条件に一致する行を削除 df.drop_duplicates() 重複する行を削除 df.drop_duplicates(keep="last") 重複する行を削除（最初ではなく最後の行を残す） df.drop_duplicates(subset=["X1", "X2"]) 重複する行を削除（指定列の値が等しい行を削除） 置換 (replace) df["列"].replace(置換前の値, 置換後の値) df["列"].replace([前1, 前2, 前3], [後1, 後2, 後3]) 値の置換 ソート (sort_values) df2 = pd.sort_values(by="列") 特定のカラムでソート（昇順） df2 = df.sort_values(by="列", ascending=False) 特定のカラムでソート（降順） カテゴリ変数 (get_dummies) new_df = df.select_dtypes(include="object") カテゴリ変数を抽出した DataFrame を作成 new_df = df.select_dtypes(exclude="object") カテゴリ変数を削除した DataFrame を作成 df2 = pd.get_dummies(df) df2 = pd.get_dummies(df, columns=["列1", "列2"]) 名義カテゴリ特徴量をワンホットエンコードする カラム名／インデックス名 (columns, index, rename) df.columns = [...] df2 = df.rename(colums={...}) カラム名の変更 df.index = [...] df2 = df.rename(index={...}) インデックス名の変更 データ型 (astype) df.loc[:, "列1"] = df.loc[:, "列1].astype(float) df["列1"] = df["列1"].astype(float) 列1のデータ型を変更 df2 = df.astype({"列1": "int64", "列2": "float64"}) 列1と列2のデータ型を変更 数値変換いろいろ y = y.astype("float32") / 255.0 0〜255 (int) の値を 0.0〜1.0 (float) に正規化 y = (y > 0.5).astype(int) 閾値を基準にして 0 or 1 の数値に変換 X -= X.mean(axis=0) 平均値が 0 になるよう値を平行移動 新しいカラムの作成（あるいは上書き） # 値が 0 の新しい列 X1 を作成する（あるいは上書き） df[&#34;X1&#34;] = 0 # 列 X1 の値をもとに新しい列 X2 を作成する（あるいは上書き） df[&#34;X2&#34;] = df[&#34;X1&#34;] + 100 # 既存の DataFrame を変更する場合 df2 = df.assign(X2=df[&#34;X1&#34;] + 100) # 新しい DataFrame を作る場合 # 列 X1 と X2 の値をもとに新しい列 X3 を作成する（あるいは上書き） df[&#34;X3&#34;] = df[&#34;X1&#34;] + df[&#34;X2&#34;] # 既存の DataFrame を変更する場合 df.assign(X3=df[&#34;X1&#34;] + df[&#34;X2&#34;]) # 新しい DataFrame を作る場合 # 任意の変換関数を適用する（下記は np.sqrt 関数で平方根を生成する例） df[&#34;X2&#34;] = df[&#34;X1&#34;].apply(np.sqrt) 複数の DataFrame を縦結合する (pd.concat) 複数の DataFrame を縦方向に結合する（行を増やす）には、pd.concat() 関数に DataFrame のリストを渡します。 import pandas as pd # テストデータ df1 = pd.DataFrame({&#34;col1&#34;: [1, 2, 3], &#34;col2&#34;: [4, 5, 6]}) df2 = pd.DataFrame({&#34;col1&#34;: [7, 8, 9], &#34;col3&#34;: [10, 11, 12]}) # DataFrame を連結する new_df = pd.concat([df1, df2]) print(new_df) 実行結果 col1 col2 col3 0 1 4.0 NaN 1 2 5.0 NaN 2 3 6.0 NaN 0 7 NaN 10.0 1 8 NaN 11.0 2 9 NaN 12.0 片方の DataFrame にしか存在しないカラムの値には NaN が設定されます。 デフォルトでは上記のように、それぞれの DataFrame のもとのインデックス名が保持されます。 インデックス名を振り直すには、ignore_index=True オプションを指定します。 # インデックスを振り直す場合 new_df = pd.concat([df1, df2], ignore_index=True) print(new_df) 実行結果 col1 col2 col3 0 1 4.0 NaN 1 2 5.0 NaN 2 3 6.0 NaN 3 7 NaN 10.0 4 8 NaN 11.0 5 9 NaN 12.0 複数の DataFrame を横結合する (pd.merge) 複数の DataFrame を横方向に結合する（列を増やす）には、pd.merge() 関数を使用します。 引数として、どの列の値で対応づけるか (on) と、どのような結合アルゴリズムを使うか (how) を指定する必要があります。 結合アルゴリズムには次のようなものを指定できます。 内部結合 (how=&quot;inner&quot;) （デフォルト） 両方に同じ値が含まれる行のみを残します（AND のイメージ）。例えば、2 つの DataFrame において、商品 ID が一致する行があれば、その行だけをマージして新しいデータを作成します。 完全外部結合 (how=&quot;outer&quot;) 両方に同じ値が含まれる行があれば、それらは 1 つの行としてマージされ、その他の行はそのまま残されます（OR のイメージ）。片方にしか存在しない項目は欠損値 (NaN) で埋められます。 左外部結合 (how=&quot;left&quot;) 左側（第 1 引数）で指定した DataFrame の行だけが残されます。 右外部結合 (how=&quot;right&quot;) 右側（第 2 引数）で指定した DataFrame の行だけが残されます。 下記のサンプルコードでは、それぞれの結合アルゴリズムでどのような結果になるかを確認しています。 import pandas as pd # サンプルデータ df1 = pd.DataFrame({&#34;Id&#34;: [1, 2, 3], &#34;Name&#34;: [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;]}) df2 = pd.DataFrame({&#34;Id&#34;: [2, 3, 4], &#34;Age&#34;: [25, 30, 35]}) print(&#34;=== INNER JOIN ===&#34;) result_inner = pd.merge(df1, df2, on=&#34;Id&#34;, how=&#34;inner&#34;) print(result_inner) print(&#34;\\n=== OUTER JOIN ===&#34;) result_outer = pd.merge(df1, df2, on=&#34;Id&#34;, how=&#34;outer&#34;) print(result_outer) print(&#34;\\n=== LEFT JOIN ===&#34;) result_left = pd.merge(df1, df2, on=&#34;Id&#34;, how=&#34;left&#34;) print(result_left) print(&#34;\\n=== RIGHT JOIN ===&#34;) result_right = pd.merge(df1, df2, on=&#34;Id&#34;, how=&#34;right&#34;) print(result_right) 実行結果 === INNER JOIN === Id Name Age 0 2 Bob 25 1 3 Charlie 30 === OUTER JOIN === Id Name Age 0 1 Alice NaN 1 2 Bob 25.0 2 3 Charlie 30.0 3 4 NaN 35.0 === LEFT JOIN === Id Name Age 0 1 Alice NaN 1 2 Bob 25.0 2 3 Charlie 30.0 === RIGHT JOIN === Id Name Age 0 2 Bob 25 1 3 Charlie 30 2 4 NaN 35 一致する値を置換する (replace) Series あるいは DataFrame オブジェクトの replace() メソッドを使うと、値の一括置換を行えます。 通常は DataFrame には列ごとに性質の異なるデータが格納されているはずなので、値の置換を行う場合は Series オブジェクト（列）単位で置換します。 次の例では、Class 列の &quot;A&quot; と &quot;B&quot; という値を、それぞれ 0 と 1 に置換しています。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;Price&#34;: [100, 200, 300, 400], &#34;Class&#34;: [&#34;A&#34;, &#34;B&#34;, &#34;A&#34;, &#34;B&#34;] }) # Class 列のカテゴリ変数 (A, B) を数値 (0, 1) に置き換え df[&#34;Class&#34;].replace([&#34;A&#34;, &#34;B&#34;], [0, 1], inplace=True) print(df) 実行結果 Price Type 0 100 0 1 200 1 2 300 0 3 400 1 replace() メソッドで regex=True フラグを指定すると、正規表現 を使った置換が可能です。 次の例では、電話番号を表すフィールドから数値以外の文字を削除しています。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;Name&#34;: [&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;], &#34;Phone&#34;: [&#34;123-4567-8901&#34;, &#34;(0120) 111-2222&#34;, &#34;111 2222 3333&#34;] }) # 数値以外の文字 (\`\\D\`) をすべて削除する df[&#34;Phone&#34;].replace(r&#34;\\D&#34;, &#34;&#34;, regex=True, inplace=True) print(df) 実行結果 Name Phone 0 Alice 12345678901 1 Bob 01201112222 2 Charlie 11122223333 既存カラムの値を使って新しいカラムを作成 既存のカラムのデータ (Series) に対して演算を行うことで、新しいカラム用のデータを作成することができます。 次の例では、姓 カラムと 名 カラムの値をくっつけた 氏名 カラムを作成しています。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;姓&#34;: [&#34;佐藤&#34;, &#34;鈴木&#34;, &#34;田中&#34;], &#34;名&#34;: [&#34;太郎&#34;, &#34;花子&#34;, &#34;次郎&#34;] }) # &#34;姓&#34; と &#34;名&#34; を結合した &#34;氏名&#34; 列を作成 df[&#34;氏名&#34;] = df[&#34;姓&#34;] + df[&#34;名&#34;] print(df) 実行結果 姓 名 氏名 0 佐藤 太郎 佐藤太郎 1 鈴木 花子 鈴木花子 2 田中 次郎 田中次郎 上記のように、+ や - を使ったブロードキャスト演算で新しいカラムを作成してしまうのが一番簡単ですが、より複雑な加工処理を行いたい時は df.apply() メソッドに加工処理を行う関数を渡します（行ごとに処理することを示す axis=1 オプションも付けてください）。 次の例では、メールアドレス（mail カラム）からドメイン部分を抽出した domain カラムを作成しています。 ここでは値の加工に str#split() メソッドを使用しているので、ブロードキャスト演算が使えません。 import pandas as pd # サンプルデータ df = pd.DataFrame({ &#34;mail&#34;: [&#34;host@example.com&#34;, &#34;host@test.org&#34;, &#34;host@sample.net&#34;] }) # &#34;mail&#34; 列からドメイン部分を抽出して新しい列 &#34;domain&#34; を作成する df[&#34;domain&#34;] = df.apply(lambda r: r[&#34;mail&#34;].split(&#34;@&#34;)[1], axis=1) print(df) 実行結果 mail domain 0 host@example.com example.com 1 host@test.org test.org 2 host@sample.net sample.net 特定の列だけを抜き出した DataFrame を作成する ある DataFrame から特定の列だけを抽出した DataFrame を作成したいときは次のようにします。 df2 = df[[&#34;列1&#34;, &#34;列2&#34;, &#34;列3&#34;]] メモリ効率のため、データの実体は共有されることに注意してください（df2 側で値を変更すると、df にも影響します）。 新しいメモリ領域にコピーする場合は、copy() を組み合わせて使用します。 df2 = df[[&#34;列1&#34;, &#34;列2&#34;, &#34;列3&#34;]].copy() 参考: pandas.DataFrame からのデータ抽出方法のチートシート カラムの削除 (drop, del, pop) df.drop() メソッドを使うと、指定したカラムを削除した新しい DataFrame を取得できます。 drop によるカラムの削除 import pandas as pd # テストデータ df = pd.DataFrame({&#34;A&#34;: [1, 2, 3], &#34;B&#34;: [4, 5, 6], &#34;C&#34;: [7, 8, 9]}) # A カラムを削除 df2 = df.drop(columns=&#34;A&#34;) df2 = df.drop(&#34;A&#34;, axis=1) # 同上 # A カラムと B カラムを削除 df2 = df.drop(columns=[&#34;A&#34;, &#34;B&#34;]) df2 = df.drop([&#34;A&#34;, &#34;B&#34;], axis=1) # 同上 Python のリスト API である del や pop でもカラムの削除を行うことができますが、これらは元の DataFrame を変更します（破壊的操作）。 pop は削除した列を Series として返します。 del と pop によるカラムの削除 # A カラムを削除 （df 自身を変更） del df[&#34;A&#34;] # 同上だが削除したカラムを Series として返す series = df.pop(&#34;A&#34;) ☝️ pop の使用例 pop によるカラムの削除は、機械学習用のデータセットから正解ラベルを分離するときに使われたりします。 # 正解ラベルの列 Price を分離 train_X = train.copy() train_y = train_X.pop(&#34;Price&#34;) df.drop() はデフォルトでは新しい DataFrame を返しますが、inplace=True を指定すれば、元の DataFrame を変更できます。 この場合、戻り値は None になります。 # 元の DataFrame 自身を変更する df.drop(columns=[&#34;A&#34;, &#34;B&#34;], inplace=True) 行の削除 (drop) 指定した行を削除 drop による行の削除 import pandas as pd # テストデータ df = pd.DataFrame({&#34;A&#34;: [1, 2, 3], &#34;B&#34;: [4, 5, 6], &#34;C&#34;: [7, 8, 9]}) # 先頭行を削除（インデックスラベルが設定されてない場合） df2 = df.drop(0) df2 = df.drop(0, axis=0) # 同上 df2 = df.drop(index=0) # 同上 # 先頭行を削除（インデックスラベルが設定されている場合） df2 = df.index = [&#34;idx1&#34;, &#34;idx2&#34;, &#34;idx3&#34;] df2 = df.drop(&#34;idx1&#34;) df2 = df.drop(&#34;idx1&#34;, axis=0) # 同上 df2 = df.drop(index=&#34;idx1&#34;) # 同上 # 複数の行をまとめて削除することも可能 df2 = df.drop(index=[0, 1, 2]) df2 = df.drop(index=[&#34;idx1&#34;, &#34;idx2&#34;, &#34;idx3&#34;]) df.drop() はデフォルトでは新しい DataFrame を返しますが、inplace=True を指定すると元の DataFrame を変更できます。 この場合、戻り値は None になります。 # 先頭の行を削除 （元の df 自身を変更） df.drop(index=0, inplace=True) 重複する行を削除 DataFrame#drop_duplicates() メソッドを使うと、同じデータを持つ行を取り除いた DataFrame を作成することができます。 次の例では、1 行目と 3 行目のデータが (100, &quot;x&quot;, 500) で完全に一致しているので、3 行目が削除されています。 import pandas as pd df = pd.DataFrame({ &#34;A&#34;: [100, 100, 100, 200, 300], &#34;B&#34;: [&#34;x&#34;, &#34;y&#34;, &#34;x&#34;, &#34;y&#34;, &#34;x&#34;], &#34;C&#34;: [500, 600, 500, 600, 700], }) new_df = df.drop_duplicates() print(new_df) 実行結果 A B C 0 100 x 500 1 100 y 600 3 200 y 600 4 300 x 700 特定のカラムだけに着目して重複行を判断したいときは、subset=[列, 列, ...] オプションを指定します。 次の例では、少なくとも B 列と C 列の値が等しい行を重複行として取り除いています（部分的に一致する行を削除します）。 new_df = df.drop_duplicates(subset=[&#34;B&#34;, &#34;C&#34;]) print(new_df) 実行結果 A B C 0 100 x 500 1 100 y 600 4 300 x 700 ☝️ 重複している行を確認する df.duplicated() で各行が重複しているかを示すフラグ (True/False) の Series オブジェクトを取得できます。 これを使って元のデータフレームをフィルタすると、重複している行だけを抽出 することができます。 import pandas as pd df = pd.DataFrame({ &#34;A&#34;: [100, 100, 100, 200, 300], &#34;B&#34;: [&#34;x&#34;, &#34;x&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;], }) dup_df = df[df.duplicated(keep=False)] print(dup_df) このコードを実行すると、最初の 3 つの行が重複していることを確認できます。 A B 0 100 x 1 100 x 2 100 x df.duplicated() の戻り値は、デフォルトでは削除すべき行だけが True となります。 例えば、3 つの行が重複している場合、削除すべき 2 つの行のみ True になります。 上記コードのように、df.duplicated() に keep=False オプションを付けることで、3 つの行すべてを True にすることができます。 条件に一致する行を削除 これは発想の転換ですが、「ある列の値が A 以外である行を抽出する」という操作は、「ある列の値が A である行を削除する」という操作になります。 import pandas as pd # テストデータ df = pd.DataFrame({ &#34;grade&#34;: [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;B&#34;, &#34;A&#34;, &#34;B&#34;], &#34;point&#34;: [100, 80, 50, 70, 90, 75] }) # grade 列が A であるものを削除 （= A でないものを抽出する） new_df = df[df[&#34;grade&#34;] != &#34;A&#34;] print(new_df) 実行結果 grade point 1 B 80 2 C 50 3 B 70 5 B 75 特定のカラムでソート テストデータ import numpy as np import pandas as pd df = pd.DataFrame({ &#39;grade&#39;: [&#39;C&#39;, &#39;A&#39;, &#39;B&#39;, np.nan, &#39;B&#39;, &#39;A&#39;], &#39;price&#39;: [50, 100, 150, 70, 30, 200] }) grade カラムでソート &gt;&gt;&gt; df.sort_values(by=&#34;grade&#34;) grade price 1 A 100 5 A 200 2 B 150 4 B 30 0 C 50 3 NaN 70 欠損値 (NaN) を先頭に持ってくる &gt;&gt;&gt; df.sort_values(by=&#34;grade&#34;, na_position=&#34;first&#34;) grade price 3 NaN 70 1 A 100 5 A 200 2 B 150 4 B 30 0 C 50 price カラムで降順ソート &gt;&gt;&gt; df.sort_values(by=&#34;price&#34;, ascending=False) grade price 5 A 200 2 B 150 1 A 100 3 NaN 70 0 C 50 4 B 30 複数カラムでソート &gt;&gt;&gt; df.sort_values(by=[&#34;grade&#34;, &#34;price&#34;], ascending=[True, False]) grade price 5 A 200 1 A 100 2 B 150 4 B 30 0 C 50 3 NaN 70 ソート後にインデックス (0, 1, 2, ...) を振り直す &gt;&gt;&gt; df.sort_values(by=&#34;price&#34;).reset_index() index grade price 0 4 B 30 1 0 C 50 2 3 NaN 70 3 1 A 100 4 2 B 150 5 5 A 200 元のインデックスは index という新規カラムに格納されます。 index カラムが不要な場合は reset_index() メソッドに drop=True を指定します。 カテゴリ変数を抽出／取り除いて DataFrame を作成 df.select_dtypes() を使って、カテゴリ変数の列のみを抽出した DataFrame を作成することができます。 NaN はカテゴリ変数とはみなされません。 import pandas as df # テストデータ df = pd.DataFrame({ &#34;col1&#34;: [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;, &#34;DDD&#34;], &#34;col2&#34;: [&#34;X&#34;, &#34;Y&#34;, &#34;Z&#34;, np.nan], &#34;col3&#34;: [100, 200, 300, 400], &#34;col4&#34;: [1.0, 2.0, 3.0, np.nan], }) # カテゴリ変数だけの DataFrame を作成 new_df = df.select_dtypes(include=[&#34;object&#34;]) print(new_df) print(new_df.columns.to_list()) 実行結果 col1 col2 0 AAA X 1 BBB Y 2 CCC Z 3 DDD NaN [&#39;col1&#39;, &#39;col2&#39;] include パラメーターの代わりに、exclude パラメーターを使うと、指定したタイプの列だけを取り除くことができます。 次の例では、上記の例とは逆に、カテゴリ変数を取り除いた（数値変数のみの）DataFrameを作成しています。 # カテゴリ変数を取り除いた DataFrame を作成 new_df = df.select_dtypes(exclude=[&#34;object&#34;]) print(new_df) print(new_df.columns.to_list()) 実行結果 col3 col4 0 100 1.0 1 200 2.0 2 300 3.0 3 400 NaN [&#39;col3&#39;, &#39;col4&#39;]`},{url:"/p/78ns8r5/",title:"pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table)",date:"2023-09-04T00:00:00+09:00",body:"pandas で CSV/TSV ファイルを読み込む (pd.read_csv, pd.read_table) 参考 pandas で CSV/TSV ファイルを出力する (pd.to_csv) pandas で CSV ファイルを読み込んで DataFrame オブジェクトを生成するには、pd.read_csv() 関数を使用します。 read_csv() 関数は、任意のセパレーター (sep) を指定できるので、CSV ファイルだけでなく、TSV ファイルなども読み込むことができます。 ヘッダーの有無の指定 (header) import pandas as pd # ヘッダー有りの CSV ファイルを読み込む df = pd.read_csv(&#34;input.csv&#34;) # ヘッダー無しの CSV ファイルを読み込む df = pd.read_csv(&#34;input.csv&#34;, header=None) # ヘッダーが 2 行目にある場合 df = pd.read_csv(&#34;input.csv&#34;, header=1) TSV ファイルを読み込む タブ区切りファイル (TSV) を読み込む場合は、pd.read_csv() 関数でセパレーター文字 (sep) を指定するか、pd.read_table() 関数を使用します。 TSV ファイルを読み込む df = pd.read_csv(&#34;input.tsv&#34;, sep=&#34;\\t&#34;) df = pd.read_table(&#34;input.tsv&#34;) # 同上 カラム名を設定する (names) CSV/TSV ファイルから DataFrame オブジェクトを生成するときに names 引数を指定すると、明示的にカラム名をセットすることができます。 この場合、CSV/TSV ファイルの最初の行からデータが始まっているとみなされるため、ヘッダー行を含む CSV/TSV ファイルを読み込む場合、ヘッダー行をうまいこと無視する必要があります。 header=0 を指定して 1 行目がヘッダー行であることを伝えるか、skiprows=1 で単純に 1 行スキップする方法が使えます。 カラム名を設定する # CSV ファイルにヘッダー行が存在しない場合 df = pd.read_csv(&#34;input.csv&#34;, names=[&#34;COL1&#34;, &#34;COL2&#34;, &#34;COL3&#34;]) # CSV ファイルにヘッダー行が存在する場合 df = pd.read_csv(&#34;input.csv&#34;, names=[&#34;COL1&#34;, &#34;COL2&#34;, &#34;COL3&#34;], header=0) df = pd.read_csv(&#34;input.csv&#34;, names=[&#34;COL1&#34;, &#34;COL2&#34;, &#34;COL3&#34;], skiprows=1) もちろん、DataFrame 生成後にカラム名を変更する方法でも OK です。 df = pd.read_csv(&#34;input.csv&#34;) df.columns = [&#34;COL1&#34;, &#34;COL2&#34;, &#34;COL3&#34;] 参考: DataFrame のカラム名やインデックス名を変更する カンマの後ろのスペースを削除する (skipinitialspace) CSV ファイル内のデータが、次のように「カンマ + スペース」で区切られている場合、デフォルトではスペースもデータの一部として扱われます。 input.csv col1, col2, col3 100, AAA, 300 400, BBB, 600 700, CCC, 900 たとえば、2 つ目のカラム名は &quot;col2&quot; ではなく &quot; col2&quot; とみなされてしまいます。 read_csv() 関数の引数として skipinitialspace=True を指定すると、カンマの後のスペースを無視してくれます。 df = pd.read_csv(&#34;input.csv&#34;, skipinitialspace=True) 特定の列をインデックス列として扱う (index_col) 例えば、CSV ファイルの先頭列に次のようにデータの ID (1, 2, 3, &hellip;) が付いているとします。 input.csv ID,col1,col2,col3 1,100,AAA,300 2,400,BBB,600 3,700,CCC,900 pd.read_csv() 関数の index_col パラメーターでカラム名を指定すると、そのカラムを DataFrame のインデックスとして取り込むことができます。 &gt;&gt;&gt; df = pd.read_csv(&#34;input.csv&#34;, index_col=&#34;ID&#34;) &gt;&gt;&gt; df col1 col2 col3 ID 1 100 AAA 300 2 400 BBB 600 3 700 CCC 900 上記ではカラムの名前（文字列）を指定していますが、次のように数値で指定することもできます。 df = pd.read_csv(&#34;input.csv&#34;, index_col=0) 特定の列だけを読み込む (usecols) 多数の列がある CSV ファイルを読み込む場合、必要な列だけを読み込むようにすればメモリ効率がよくなります。 読み込む列を列番号で指定する（0 始まり） df = pd.read_csv(&#34;input.csv&#34;, usecols=[0, 1, 3]) 読み込む列を列名で指定する df = pd.read_csv(&#34;input.csv&#34;, usecols=[&#34;col1&#34;, &#34;col2&#34;, &#34;col4&#34;]) 各カラムのデータタイプを指定する (dtype) 各カラムのデータタイプは CSV に含まれている実際のデータから推測されますが、dtype パラメーターでカラムごとに明示することができます。 適切なデータタイプを設定することで、メモリ使用量の節約に繋がります。 例えば、次のような 3 つのカラムを持つ CSV ファイルを読み込むとします。 input.csv col1,col2,col3 100,A,120.5 200,B,236.3 300,C,398.2 400,A,437.8 500,B,525.8 600,C,671.1 まずは dtype パラメーターなしで CSV ファイルを読み込んで、DataFrame の各カラムのデータタイプや、全体のメモリ使用量を df.info() で確認してみます。 &gt;&gt;&gt; df = pd.read_csv(&#34;input.csv&#34;) &gt;&gt;&gt; df.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 6 entries, 0 to 5 Data columns (total 3 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 col1 6 non-null int64 1 col2 6 non-null object 2 col3 6 non-null float64 dtypes: float64(1), int64(1), object(1) memory usage: 272.0+ bytes データタイプ (dtype) を明示せずに読み込むと、上記のように、整数が int64 型、テキストが object 型、少数点数が float64 型と推測されて DataFrame が生成されます。 実際には、col1 列と col3 列の数値を表現するのに 64 ビットも必要ないかもしれませんし、col2 列は汎用的な object 型ではなく category 型（カテゴリカルデータ）として扱いたいかもしれません。 そのような場合は、dtype で次のようにデータタイプを指定します。 &gt;&gt;&gt; df = pd.read_csv(&#34;input.csv&#34;, dtype={ ... &#34;col1&#34;: &#34;int32&#34;, ... &#34;col2&#34;: &#34;category&#34;, ... &#34;col3&#34;: &#34;float32&#34; ... }) &gt;&gt;&gt; df.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 6 entries, 0 to 5 Data columns (total 3 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 col1 6 non-null int32 1 col2 6 non-null category 2 col3 6 non-null float32 dtypes: category(1), float32(1), int32(1) memory usage: 206.0 bytes 適切なデータタイプを指定することにより、メモリ使用量を 272 バイトから 206 バイトまで減らすことができました。 巨大な CSV ファイルを読み込むときは、この dtype パラメーターと usecols パラメーター を適切に指定することで、メモリ使用量を大幅に削減できます。 ちなみに、上記の例ではカラムごとにデータタイプを指定しましたが、dtype=str のように指定することで、すべてのカラムを文字列データとして扱うことができます。"},{url:"/p/3g687f5/",title:"pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix)",date:"2023-09-04T00:00:00+09:00",body:"pandas の DataFrame のカラム（列）名やインデックス（行）名を変更する (df.rename, df.add_prefix, df.add_suffix) pandas の DataFrame のカラム名やインデックス名を変更方法のまとめです。 カラム名を一括で置き換える (columns) 既存の DataFrame のカラム名（列名）を丸ごと置き換えるには、columns プロパティにカラム名のリストを代入します。 df.columns = [&#34;列名1&#34;, &#34;列名2&#34;, &#34;列名3&#34;] この操作は、既存の DataFrame のカラム名を直接変更します。 カラム名にプレフィックスやサフィックスを追加する (add_prefix, add_suffix) # 全てのカラム名の先頭に X_ を付ける f2 = df.add_prefix(&#34;X_&#34;) # 全てのカラム名の末尾に _X を付ける df2 = df.add_suffix(&#34;_X&#34;) どちらの関数も、カラム名が変更された新しい DataFrame を返します。 元の DataFrame のカラム名は変更されませんが、データ自体は同じメモリ上の値を参照しています。 特定のカラムやインデックスの名前を変更する (rename) カラム名（列名）の変更 df2 = df.rename( columns={ &#34;既存の列名1&#34;: &#34;新しい列名1&#34;, &#34;既存の列名2&#34;: &#34;新しい列名2&#34;, &#34;既存の列名3&#34;: &#34;新しい列名3&#34; } ) インデックス名（行名）の変更 df2 = df.rename( index={ &#34;既存の行名1&#34;: &#34;新しい行名1&#34;, &#34;既存の行名2&#34;: &#34;新しい行名2&#34;, &#34;既存の行名3&#34;: &#34;新しい行名3&#34; } ) DataFrame#rename() 関数は、カラム名やインデックス名が変更された新しい DataFrame を返します。 元の DataFrame のカラム名やインデックス名は変更されませんが、データ自体は同じメモリ上の値を参照しています。 変換関数を指定する方法 rename メソッドの columns 引数（あるいは index 引数）に名前の変換関数を指定すると、すべてのカラム名やインデックス名をまとめて置換できます。 次の例では、変換関数として str.lower を指定しています。 全てのカラム名（列名）を小文字にする df2 = df.rename(columns=str.lower) df2 = df.rename(mapper=str.lower, axis=1) # 同上 全てのインデックス名（行名）を小文字にする df2 = df.rename(index=str.lower) df2 = df.rename(mapper=str.lower, axis=0) # 同上 次の例では、変換関数としてラムダ関数を指定しています。 デフォルトの行番号 (0, 1, 2, ...) から Y1, Y2, Y3, ... のような行名を生成 df2 = df.rename(index=lambda y: &#34;Y{}&#34;.format(y + 1))"},{url:"/p/rnai4ko/",title:"pandas チートシート - DataFrame のデータ抽出方法まとめ",date:"2023-08-27T00:00:00+09:00",body:`pandas チートシート - DataFrame のデータ抽出方法まとめ pandas の DataFrame から部分データを抽出する方法のまとめです。 指定した行と列の抽出 基本的に、行と列の 「名称」による抽出には loc プロパティを使い、「数値」による抽出には iloc プロパティを使用します。 下記の例では、インデックス名（行名）に Y1 〜 Y5、カラム名（列名）に X1 〜 X5 が設定されているものとします。 カテゴリ コード 抽出のイメージ 戻り値の型 スカラー値 df.loc["Y3", "X2"] df.iloc[2, 1] numpy.float64 など 1 行の抽出 df.loc["Y2"] df.loc["Y2", :] df.iloc[1] df.iloc[1, :] Series df.loc[["Y2"]] df.loc[["Y2"], :] df.iloc[[1]] df.iloc[[1], :] DataFrame 複数行の抽出 df.loc["Y2":"Y4"] df.iloc[1:4] df["Y2":"Y4"] df[1:4] DataFrame df.head(2) DataFrame df.tail(2) DataFrame 1 列の抽出 df.loc[:, "X2"] df.iloc[:, 1] df["X2"] Series df.loc[:, ["X2"]] df.iloc[:, [1]] df[["X2"]] DataFrame 複数列の抽出 df.loc[:, ["X2", "X4", "X5"]] df.iloc[:, [1, 3, 4]] df[["X2", "X4", "X5"]] DataFrame 組み合わせ df.loc["Y3":"Y5", "X2"] df.iloc[2:5, 1] Series df.loc["Y3":"Y5", ["X2"]] df.iloc[2:5, [1]] DataFrame df.loc["Y3":"Y5", "X2":"X4"] df.iloc[2:5, 1:4] DataFrame df.loc["Y3":"Y5", ["X2", "X4"]] df.iloc[2:5, [1, 3]] DataFrame 参考: pandas.DataFrame から部分データを抽出する 条件指定による行の抽出 コード 説明 df[df["X1"] >= 10] df.query("X1 >= 10") X1 列の値が 10 以上の行を抽出 df[df["X1"] == 10] df.query("X1 == 10") X1 列の値が 10 の行を抽出 df[df["X1"] != 10] df.query("X1 != 10") X1 列の値が 10 ではない行を抽出 df[df["X1"] == "AAA"] df.query("X1 == 'AAA'") X1 列の値が "AAA" の行を抽出 df[df["X1"].isin(["AAA", "BBB"])] X1 列の値が "AAA" または "BBB" である行を抽出 df[~df["X1"].isin(["AAA", "BBB"])] X1 列の値が "AAA" でも "BBB" でもない行を抽出 df[df["X1"].str.contains("AAA")] X1 列に "AAA" を含む行を抽出 df[~df["X1"].str.contains("AAA")] X1 列に "AAA" を含まない行を抽出 df[df["X1"].notna()] X1 列に値が存在する行を抽出 df[(df["X1"] >= 0) & (df["X1"] < 10)] AND 条件で行を抽出 df[(df["X1"] == 0) | (df["X2"] == "AAA")] OR 条件で行を抽出 df.loc[df["X1"] > 0, ["X1", "X2", "X3"]] 行を抽出して、ついでに列を絞り込む （おまけ）テストデータ 上記の処理を試すための 5 行 5 列のテストデータです。 import numpy as np import pandas as pd data = np.arange(1, 26).reshape((5, 5)) # 5x5 の連番データを作成 columns = [&#34;X%d&#34; % i for i in range(1, 6)] # カラム名 index = [&#34;Y%d&#34; % i for i in range(1, 6)] # インデックス名 df = pd.DataFrame(data, columns=columns, index=index) Python の対話シェルに上記をコピペして DataFrame を作成すれば、df[&quot;X1&quot;] などの結果を調べることができます。 &gt;&gt;&gt; df X1 X2 X3 X4 X5 Y1 1 2 3 4 5 Y2 6 7 8 9 10 Y3 11 12 13 14 15 Y4 16 17 18 19 20 Y5 21 22 23 24 25 &gt;&gt;&gt; df.loc[&#34;Y1&#34;:&#34;Y3&#34;, &#34;X3&#34;:&#34;X5&#34;] X3 X4 X5 Y1 3 4 5 Y2 8 9 10 Y3 13 14 15`},{url:"/p/59ruo5m/",title:"Matplotlib の Axes、Figure、pyplot の関係を理解する",date:"2023-08-04T00:00:00+09:00",body:"Matplotlib の Axes、Figure、pyplot の関係を理解する Figure と Axes Matplotlib の基本的な描画要素として、Figure と Axes があり、Figure の中に複数の Axes を配置できるようになっています。 次のプロット画像には、1 つの Figure の中に、2 つの Axes を配置しています。 図: Figure と Axes の関係 上記画像のコード import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] # Figure の作成 fig = plt.figure(facecolor=&#34;lightskyblue&#34;, layout=&#34;tight&#34;, dpi=72, figsize=(6, 3)) fig.suptitle(&#34;Figure&#34;) # Axes によるプロット ax = fig.subplots(1, 2) ax[0].set_title(&#34;Axes 1&#34;, loc=&#34;left&#34;, fontstyle=&#34;oblique&#34;, fontsize=&#34;medium&#34;) ax[0].plot(x, y) ax[1].set_title(&#34;Axes 2&#34;, loc=&#34;left&#34;, fontstyle=&#34;oblique&#34;, fontsize=&#34;medium&#34;) ax[1].plot(x, y) fig.savefig(&#34;img-001.svg&#34;) Figure オブジェクトの subfigures メソッドや add_subfigure メソッドを使うと、Figure の入れ子構造を作ることができます。 Axes インターフェイスと pyplot インターフェイス Matplotlib を使ったプロット方法には、明示的 Axes インターフェイス を使う方法と、暗黙的 pyplot インターフェイス を使う方法があります。 明示的 Axes インターフェイス (explicit Axes interface) 最初に Figure や Axes オブジェクトの参照を取得し、それらのメソッドを明示的に呼び出して各種パラメーターを設定していく方法です。 オブジェクト指向インターフェイスと呼ばれています。 各オブジェクトを別々に制御できるため、柔軟性が高いです。 import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] fig = plt.figure() # Figure を作成 ax = fig.subplots() # Figure 内に Axes を作成 ax.plot(x, y) # Axes へのプロット # 次のように Figure と Axes をまとめて取得することも可能 # fig, ax = plt.subplots() # ax.plot(x, y) plt.show() Figure#subplots() メソッドあるいは pyplot.subplots() 関数の引数として、プロット領域の分割数（行数と列数）を渡すと、リストの形で Axes オブジェクトを取得することができます。 次のように、プロット先をインデックスで切り替えることができます。 fig, ax = plt.subplots(1, 2) # 1 行 2 列に分割されたプロット領域 (Axes) を作成 ax[0].plot(x, y) # 1 つ目の Axes にプロット ax[1].plot(x, y) # 2 つ目の Axes にプロット 暗黙的 pyplot インターフェイス (implicit pyplot interface) pyplot モジュールが提供する関数を連続して呼び出すことで、内部で描画情報を積み上げていく方法です。 コードとしては、plt.hogehoge() のような関数をたくさん呼び出すことになります。 内部的には Axes オブジェクトのプロット関連メソッドが呼び出されているわけですが、それらの呼び出しは隠蔽されるため、簡単な内容であれば、短いコードで記述することができます。 import matplotlib.pyplot as plt x = [0, 1, 2, 3] y = [0, 8, 2, 10] plt.plot(x, y) # 内部で保持されている Axes にプロットする plt.show() ただし、分割されたチャートを描画するようなケースでは、前述の明示的な Axes を使った方が分かりやすいです。 pyplot インターフェイスを使う方法だと、内部的に現在どの Axes を操作しているのかを意識したコーディングを行う必要があります。 plt.subplot(1, 2, 1) # 1 行 2 列に分割した描画先の 1 つ目の Axes を選択 plt.plot(x, y) # 1 つ目の Axes にプロット plt.subplot(1, 2, 2) # 1 行 2 列に分割した描画先の 2 つ目の Axes を選択 plt.plot(x, y) # 2 つ目の Axes にプロット"},{url:"/p/zfhtasm/",title:"Rust のオブジェクトのライフタイム（生存期間）を理解する ('static, 'a)",date:"2023-07-11T00:00:00+09:00",body:"Rust のオブジェクトのライフタイム（生存期間）を理解する ('static, 'a) ライフタイムの基本 Rust のオブジェクトのライフタイム（生存期間）は、その名の通り、オブジェクトが有効な期間を表しています。 変数とその借用 (borrow) である参照は、異なるライフタイムを持っています。 変数のライフタイム 変数のライフタイムは、その変数が初期化されるときに開始し、スコープを抜けるときに終了します。 スコープを抜けるとき、その変数はドロップ（破棄）され、それ以降は使用できなくなります。 { let s = String::from(&#34;Hello&#34;); // 変数 s のライフタイムはここで終わり、ドロップされる } // 変数 s はここではもう使えない スコープはその変数を囲んでいるブロックであり、専門的には lexical scope と呼ばれます。 そのため、変数のライフタイムのことを lexical lifetime と呼ぶことがあります。 参照のライフタイム 一方で、参照（リファレンス）のライフタイムは、その参照を使う最後の文で終了します。 つまり、参照を使っているコード範囲がそのままライフタイムになるため、とてもシンプルです。 let s = String::from(&#34;Hello&#34;); let r = &amp;s; // 参照 r のライフタイムはここから始まり println!(&#34;{}&#34;, r); // ここで終わる println!(&#34;{}&#34;, s); 参照は、ある変数を借用 (borrow) したものであり、参照のライフタイムが終了しても、その参照先の変数が破棄（ドロップ）されるようなことはありません。 ライフタイムは「変数＞参照」でなければいけない 変数とその参照のライフタイム関係は、次のような入れ子関係になっていなければいけないことは明らかです。 図: 正しいライフタイム関係 次のように、参照のライフタイムが、その参照先のオブジェクトのライフタイムを超えるのはおかしいからです。 図: 誤ったライフタイム関係 次のコードは、参照がライフタイム違反をしている例です。 間違った例 let r; { let num = 1; r = &amp;num; } println!(&#34;{}&#34;, r); // NG! （参照先の num はすでにドロップされている） Rust コンパイラーは内部に borrow checker という仕組みを備えており、上記のような不正なライフタイム関係がないかを確認してくれます。 上記のコードをコンパイルしようとすると、次のようなコンパイルエラーになります。 error[E0597]: `num` does not live long enough このようなシンプルな例であれば、ライフタイム違反をしていることは簡単に分かりますが、関数の戻り値として参照を返す場合や、構造体のフィールドとして参照を持つような場合は、若干複雑になってきます。 以下、これらを順番に見ていきます。 関数の戻り値を参照にする 関数の戻り値として参照を返す場合、次のような種類の参照を返すことが考えられます。 定数オブジェクト（リテラル）の参照 引数として渡された参照に依存する参照 それぞれ、参照先のオブジェクトのライフタイムが、どのように戻り値の参照に影響するかをコンパイラに伝えてやる必要があります。 定数オブジェクト（リテラル）の参照を返す場合 文字列リテラルや数値リテラルなど、プログラムの実行時間とライフタイムが等しいデータを参照として返す場合はシンプルです。 参照を表す &amp; の代わりに、&amp;'static を付けてやれば OK です。 アポストロフィー (') は、それが ライフタイム識別子 (lifetime specifier) であることを示しています。 /// 文字列リテラルの参照を返す関数 fn get_str_ref() -&gt; &amp;&#39;static str { &#34;Hello, world!&#34; } /// 数値リテラルの参照を返す関数 fn get_f64_ref() -&gt; &amp;&#39;static f64 { &amp;1.234 } /// 定数（数値）の参照を返す関数 const NUM: i32 = 777; fn get_const_ref() -&gt; &amp;&#39;static i32 { &amp;NUM } /// 定数（配列）の参照を返す関数 const ARRAY: [i32; 3] = [1, 2, 3]; fn get_array_ref() -&gt; &amp;&#39;static [i32; 3] { &amp;ARRAY } // 使用例 let s = get_str_ref(); //=&gt; &amp;str (&#34;Hello, world!&#34;) let f = get_f64_ref(); //=&gt; &amp;f64 (1.234) let i = get_const_ref(); //=&gt; &amp;i32 (777) let a = get_array_ref(); //=&gt; &amp;[i32; 3] ([1, 2, 3]) println!(&#34;{:?}, {:?}, {:?}, {:?}&#34;, s, f, i, a); 上記の例では、説明のためにすべて参照で返していますが、単純な数値のスカラー値 (i32 や f64) であれば、参照ではなく値として返した方がシンプルです。 引数で渡された参照に依存する参照を返す場合 関数の引数として渡された参照のライフタイムに依存する参照を戻り値として返す場合、そのライフタイムの関係を意識する必要があります。 次のように、参照のパラメーターが 1 つだけの場合、Rust は戻り値の参照もそれと同じライフタイム内で有効である判断してくれるので、問題なくコンパイルできます。 /// 文字列スライスの最初の n 文字を返す fn first_n_chars(text: &amp;str, n: usize) -&gt; &amp;str { &amp;text[..n] } // 以下の参照 r は s のライフタイム内でのみ有効 let s = String::from(&#34;ABCDEF&#34;); let r = first_n_chars(s.as_str(), 3); println!(&#34;{:?}&#34;, r); //=&gt; &#34;ABC&#34; ☝️ 一時インスタンスは渡せない 上記の first_n_chars 関数を次のように呼び出すと、コンパイルエラーになります。 let r = first_n_chars(String::from(&#34;ABCDEF&#34;).as_str(), 3); // エラー！ println!(&#34;{:?}&#34;, r); // ここに到達する時点ですでに r は無効 なぜなら、String インスタンス (&quot;ABCDEF&quot;) のライフタイムが first_n_chars を呼び出している行で終了してしまい、戻り値の参照もその行までしか有効でないからです。 String インスタンスは変数で保持するようにして、その変数が所属するブロックの末尾までライフタイムを伸ばしてやる必要があります。 関数の引数として参照が 2 つ以上渡される場合は、そのまま次のように書くとコンパイルエラーになってしまいます。 fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str { // エラー！ if x.len() &gt; y.len() { x } else { y } } なぜなら、戻り値の参照の有効期間が、参照 x によって決まるものなのか、参照 y によって決まるものなのかを判断できないからです。 Rust コンパイラーは、「戻り値の参照の有効期間を関数のシグネチャから判断できること」を要求します。 上記コードをコンパイルできるようにするには、次のようなライフタイム識別子 'a を付加します。 ライフタイム識別子は、ジェネリクスの型パラメーター (&lt;T&gt;) と同様の形式で宣言しますが、名前をアポストロフィー (') で始めて、小文字を使うところが異なります。 通常は、'a や 'b のような短い名前を使います。 /// 渡された文字列のうち長い方を返す fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str { if x.len() &gt; y.len() { x } else { y } } // 使用例 let s1 = &#34;AAA&#34;; let s2 = String::from(&#34;BBBBB&#34;); let s3 = longest(s1, &amp;s2); //=&gt; &#34;BBBBB&#34; この longest 関数のシグネチャは、「戻り値の参照は、参照 x と参照 y の両方が有効な期間だけ有効である」 ことをコンパイラーに伝えています。 言い換えると、「戻り値の参照は、x と y のライフタイムのうち、短い方の期間だけ有効である」ということです。 上記の使用例では、s1 と s2（の文字列スライス）を引数として渡していますが、戻り値の参照の有効期間は、実質 s2 のライフタイムによって決まります。 s1 の方は、静的な文字列リテラルへの参照であり、明らかに s2 よりもライフタイムが長い（というより死なない）からです。 構造体のフィールドとして参照を持つ 参照フィールドには必ずライフタイムが必要 構造体のフィールドとして参照を持つ場合、ライフタイム識別子の指定が必要です。 次の Excerpt 構造体は、外部テキストの部分テキスト（の参照）を保持する構造体です。 // 参照フィールドを持つ構造体 struct Excerpt&lt;&#39;a&gt; { part: &amp;&#39;a str, } // 使用例 let text = String::from(&#34;ABCDEFGHIJKLMNOPQRSTUVWXY&#34;); let excerpt = Excerpt { part: &amp;text[..5] }; println!(&#34;{:?}&#34;, excerpt.part); //=&gt; &#34;ABCDE&#34; このライフタイム指定 ('a) は、Excerpt のインスタンスは part フィールドのライフタイム内でのみ有効 であることを示しています。 外部のテキストの一部を参照するわけですから、この関係性はすんなり理解できると思います。 上記の使用例では、他の変数 (text) が所有している文字列の中の、先頭 5 文字の部分テキストを excerpt インスタンス内に保持しています。 excerpt インスタンスは、text 変数のライフタイム内でのみ有効です。 ちなみに、フィールド名を持たないタプル構造体の場合も同様です。 下記のタプル構造体は、最初のフィールドが参照になっているため、ライフタイム識別子が必要です。 // 参照フィールドを持つタプル構造体 struct Excerpt&lt;&#39;a&gt;(&amp;&#39;a str, i32, i32); let text = String::from(&#34;ABCDEFGHIJKLMNOPQRSTUVWXY&#34;); let excerpt = Excerpt(&amp;text[..5], 0, 4); println!(&#34;{:?}&#34;, excerpt.0); //=&gt; &#34;ABCDE&#34; 構造体のメソッドを実装する場合 ライフタイム識別子を持つ構造体のメソッドを impl ブロックで実装する場合、その書き出しは次のようになります。 ライフタイム識別子まで含めて構造体の型なので、このように記述する必要があります。 impl&lt;&#39;a&gt; Excerpt&lt;&#39;a&gt; { // ... } インスタンスメソッドの戻り値が参照の場合、その参照はデフォルトで、自分自身のインスタンス (self) のライフタイム内で有効とみなされます。 以下の first_n_chars メソッドは、自身が保持する part フィールドの部分文字列の参照を返していますが、このようなメソッドを定義する場合、ライフタイムの指定は省略することができます。 struct Excerpt&lt;&#39;a&gt; { part: &amp;&#39;a str, } impl&lt;&#39;a&gt; Excerpt&lt;&#39;a&gt; { // 戻り値の参照は、デフォルトで構造体インスタンスが生きている間だけ有効 fn first_n_chars(&amp;self, n: usize) -&gt; &amp;str { &amp;self.part[..n] } } // 使用例 let text = String::from(&#34;ABCDEFGHIJKLMNOPQRSTUVWXY&#34;); let excerpt = Excerpt { part: &amp;text[..5] }; println!(&#34;{:?}&#34;, excerpt.first_n_chars(3)); //=&gt; &#34;ABC&#34; 大体はこのパターンになるので、ほとんどのケースでは、構造体のインスタンスメソッドが参照を返すときにライフタイムの指定は必要ありません。 もちろん、構造体インスタンス自身のライフタイムと関係ない参照を返す場合は、次のようにライフタイムの指定が必要になります。 struct Switch { state: bool, } impl Switch { fn a_or_b&lt;&#39;a&gt;(&amp;self, a: &amp;&#39;a str, b: &amp;&#39;a str) -&gt; &amp;&#39;a str { if self.state { a } else { b } } }"},{url:"/p/23fd7nv/",title:"Rust で数値を特定の範囲に収まるように修正する (clamp, min, max)",date:"2023-07-10T00:00:00+09:00",body:"Rust で数値を特定の範囲に収まるように修正する (clamp, min, max) clamp メソッド Rust である数値を指定した範囲に収まるように修正するには、clamp メソッドを使用します。 次の例では、いろいろな数値を「0 以上 5 以下」の範囲に収まるように修正しています。 println!(&#34;{}&#34;, (-3).clamp(0, 5)); //=&gt; 0 println!(&#34;{}&#34;, 0.clamp(0, 5)); //=&gt; 0 println!(&#34;{}&#34;, 2.clamp(0, 5)); //=&gt; 2 println!(&#34;{}&#34;, 7.clamp(0, 5)); //=&gt; 5 min / max メソッド clamp メソッドは、数値を指定した最小値と最大値の範囲に収まるようにするメソッドでしたが、最小値と最大値のいずれかを指定すればよい場合は、max や min メソッドを使用します。 // 0 以上になるように修正する println!(&#34;{}&#34;, (-5).max(0)); //=&gt; 0 println!(&#34;{}&#34;, 0.max(0)); //=&gt; 0 println!(&#34;{}&#34;, 10.max(0)); //=&gt; 10 // 100 以下になるように修正する println!(&#34;{}&#34;, (-5).min(100)); //=&gt; -5 println!(&#34;{}&#34;, (27).min(100)); //=&gt; 27 println!(&#34;{}&#34;, (999).min(100)); //=&gt; 100"},{url:"/p/be8u7sg/",title:"Rust でジェネリクス構造体・関数を定義する（任意の型を扱えるようにする）",date:"2023-07-09T00:00:00+09:00",body:"Rust でジェネリクス構造体・関数を定義する（任意の型を扱えるようにする） ジェネリクスの基本 Rust の ジェネリクス (generics) の仕組みを使うと、任意の型を扱う処理を 1 つのコードで記述することができます。 まずは、ジェネリクスを使っていないコードから見てみます。 次のサンプルコードでは、整数型 (i32) の座標値を表現する構造体 Point と、その浮動小数点数型 (f64) バージョンである PointF を定義しています。 ジェネリクスを使わない Point 構造体 /// 整数型の座表値 struct Point { x: i32, y: i32, } /// 浮動小数点数型の座標値 struct PointF { x: f64, y: f64, } // 使用例 fn main() { let p1 = Point { x: 0, y: 5 }; println!(&#34;{}, {}&#34;, p1.x, p1.y); let p2 = PointF { x: -1.2, y: 7.4 }; println!(&#34;{}, {}&#34;, p2.x, p2.y); } Rust では、数値だけでも様々なプリミティブ型 (u8, i128, f64, usize, &hellip;) で区別して扱うので、このように扱う数値の種類によってコードを書き分けなければいけません。 一方の型（上記の例では PointF 構造体）だけで実装しようとすると、as を使ったキャストがいたるところに出てくることになります。 そこでジェネリクスの出番です。 ジェネリクスの仕組みでは、構造体や関数の定義時に 型パラメーター を宣言することで、（コンパイル時に決定される）任意の型を扱えるようになります。 次のコードは、ジェネリクス版の Point 構造体です。 汎用的な型パラメーターの名前としては、T を使うのが慣例となっています。 ジェネリクスを使う場合 struct Point&lt;T&gt; { x: T, y: T, } fn main() { let p1 = Point { x: 0, y: 5 }; // Point&lt;i32&gt; とみなされる println!(&#34;{}, {}&#34;, p1.x, p1.y); let p2 = Point { x: -1.2, y: 7.4 }; // Point&lt;f64&gt; とみなされる println!(&#34;{}, {}&#34;, p2.x, p2.y); } これで、様々な数値型の座標値を、Point というジェネリック構造体 1 つで表現できるようになりました！ 複数の型パラメーターを扱う 型パラメーターは任意の数だけカンマで並べて宣言できます。 次の Pair 構造体は、任意の型のフィールド first と second を持つ構造体です。 first と second はそれぞれ別の型の値を保持することができます。 ジェネリックな Pair 構造体 struct Pair&lt;TFirst, TSecond&gt; { first: TFirst, second: TSecond, } fn main() { let pair1 = Pair { first: &#34;key1&#34;, second: &#34;val1&#34; }; // Pair&lt;&amp;str, &amp;str&gt; とみなされる println!(&#34;{:?}, {:?}&#34;, pair1.first, pair1.second); //=&gt; &#34;key1&#34;, &#34;val1&#34; let pair2 = Pair { first: [1, 2], second: 100 }; // Pair&lt;[i32; 2], i32&gt; とみなされる println!(&#34;{:?}, {:?}&#34;, pair2.first, pair2.second); //=&gt; [1, 2], 100 } ジェネリクス関数 関数でも型パラメーターを使うことができます。 次の swap 関数は、2 つの値を受け取り、その順番を入れ替えたタプルを返します。 簡単なジェネリクス関数の例 /// 2 つの要素の順番を入れ替えたタプルを返す fn swap&lt;T1, T2&gt;(a: T1, b: T2) -&gt; (T2, T1) { (b, a) } fn main() { let tuple = swap(100, &#34;hello&#34;); println!(&#34;{:?}, {:?}&#34;, tuple.0, tuple.1); //=&gt; &#34;hello&#34;, 100 // Destructuring の構文でタプル要素を分解して受け取ることもできる let (x, y) = swap(100, &#34;hello&#34;); println!(&#34;{:?}, {:?}&#34;, x, y); //=&gt; &#34;hello&#34;, 100 } ちなみに、Rust でプリミティブ型の値をスワップしたいときは、次のようにタプルの destructuring 構文を使うのが簡単です。 let mut a = 1; let mut b = 2; (b, a) = (a, b); // 値のスワップ"},{url:"/p/e3o2ra3/",title:"Rust で複数の数値の中から最小値・最大値を見つける (min, max)",date:"2023-07-09T00:00:00+09:00",body:"Rust で複数の数値の中から最小値・最大値を見つける (min, max) 2 つの数値から大きい方を取り出す Rust の標準ライブラリが提供しているジェネリクス関数 std::cmp::max を使うと、2 つの数値のうち大きい方の値を取り出すことができます。 let larger = std::cmp::max(2, 5); //=&gt; 5 // 呼び出し時のコードを短くしたいときは次のように use 宣言します // use std::cmp::max; // let larger = max(2, 5); また、数値のプリミティブ型 (i32 や f64) は core::cmp::Ord トレイトを実装しているため、max メソッドでも上記と同様の処理を行えます。 let larger = 2.max(5); //=&gt; 5 前者の関数型と比較して、後者のメソッド型は直感的に理解しにくいかもしれませんが、場面によっては便利です。 例えば、num.max(0) という表現は、num が負の値だったときに、0 になるよう修正する という処理になります。 参考: 数値を特定の範囲に収まるように修正する (clamp, min, max) 複数の数値の中から最大値を取り出す 数値型のベクターや配列から、最大の値を持つ値を取り出すには次のようにします。 Vec&lt;i32&gt; から最大値を取り出す let nums: Vec&lt;i32&gt; = vec![3, 1, 5, 2, 4]; // let nums: [i32; 5] = [3, 1, 5, 2, 4]; if let Some(max) = nums.iter().max() { println!(&#34;Max value: {}&#34;, max); } else { println!(&#34;nums is empty&#34;); } 実行結果 Max value: 5 この場合、max メソッドの戻り値は Option 型 になっており、ベクターや配列が空の場合は None を返すことに注意してください。"},{url:"/p/nfxwcc2/",title:"Rust のパニック (panic) の扱いについて",date:"2023-07-06T00:00:00+09:00",body:"Rust のパニック (panic) の扱いについて パニックとは Rust のパニックはプログラムに不具合があるときに発生するもので、パニックが発生すると、通常はプログラムの動作を継続することができません。 パニックは発生しないようにコーディングすべきです。 パニックを発生させる処理の例: 数値のゼロ除算 配列の範囲外アクセス Option 変数の値が None なのに unwrap したとき Result 変数の値が Err なのに unwrap したとき panic! マクロを呼び出したとき panic! マクロで意図的にパニックを発生させることができますが、プロダクトコードでは呼び出さないようにします（println! と同様の引数を渡すことができます）。 パニック発生時には、unwind the stack（スタック巻き戻し） あるいは、abort the process（プロセス強制終了） のいずれかの処理が実行されます。 unwind the stack（スタック巻き戻し） パニック発生時のデフォルトの動作です。 スタック上のデータが逆順に解放されて、ファイルなどのリソースが閉じられます。 このとき、ユーザー定義の drop メソッドも呼び出されます。 そして、最後に当該スレッドが終了します。 終了するのがメインスレッドであれば、プロセスが終了することになります。 このように、パニックはカレントスレッドに対して発生するものであり、本質的にはプロセス全体を止めるものではないことに注意してください。 abort the process（プロセス強制終了） パニック発生後の drop 中に別のパニックが発生すると、Rust はスタックの巻き戻し処理 (unwind the stack) をあきらめて、プロセスを強制終了します。 コンパイル時に -C panic=abort オプションを指定すると、最初のパニック発生時に、ただちにプロセスが終了するようになります。 エラーを表現する場合は Result 型を使うべし プログラムの実行中には様々なエラーが発生する可能性があります。 Rust で何らかの処理が成功、あるいは失敗（エラー）したことを表現するには、Result 型を使用します。 参考: Result 型の基本 ─ 成功と失敗を表現する型 例えば、ユーザーが指定したファイルを開こうとした際に、ファイルが存在しない場合、エラーとして扱われますが、これはプログラムの不具合ではないため、パニックを引き起こすのは不適切です。 このような一般的なユースケースで発生するエラーを処理する際には、Result 型の Err バリアントを使用してエラーを表現します。 Result 型を使用することで、エラーを適切にハンドルし、処理を続行することが可能です。"},{url:"/p/xqkgvb6/",title:"Python の dataclass デコレーターで簡単にデータクラスを定義する",date:"2023-06-20T00:00:00+09:00",body:"Python の dataclass デコレーターで簡単にデータクラスを定義する dataclass デコレーターによるデータクラス定義の基本 Python の標準ライブラリが提供している dataclasses モジュールの dataclass デコレーターを使うと、少ないコードでデータクラス（データを扱うクラス）を定義することができます。 下記の NamedCounter クラスは 2 つのインスタンス変数（name と counter）を持つクラスの実装例ですが、通常はこのようにコンストラクタ（__init__ メソッド）の中でインスタンス変数を初期化すると思います。 通常のクラス定義方法 class NamedCounter: def __init__(self, name): self.name = name self.count = 0 def increment(self): self.count += 1 def __str__(self): return f&#34;{self.name}: {self.count}&#34; if __name__ == &#34;__main__&#34;: counter = NamedCounter(&#34;hello&#34;) print(counter) # hello: 0 counter.increment() print(counter) # hello: 1 これくらいならよいのですが、インスタンス変数（フィールド）が増えてくると、コンストラクタの記述が面倒になってきます。 クラス定義時に dataclass デコレーターを付けると、このような __init__ の定型処理を自動生成してくれます。 次の例では、dataclass デコレーターを使って、2 つのインスタンス変数 (name, count) を持つクラスを定義しています。 name と count はクラス変数（クラス属性）と同様の記法で定義していますが、dataclass デコレーターを付けた場合はインスタンス変数の定義とみなされることに注意してください。 つまり、name と count の値は、NamedCounter のインスタンスごとに異なる値を保持できます。 dataclass デコレーターを使ったクラス定義 from dataclasses import dataclass @dataclass class NamedCounter: name: str count: int = 0 def increment(self): self.count += 1 if __name__ == &#34;__main__&#34;: counter = NamedCounter(&#34;hello&#34;) print(counter) # NamedCounter(name=&#39;hello&#39;, count=0) counter.increment() print(counter) # NamedCounter(name=&#39;hello&#39;, count=1) 内部的には、次のような __init__ メソッドや __repr__ メソッドが生成されています。 各変数の出力順は、フィールド定義の順番に従います。 def __init__(self, name: str, count: int = 0): self.name = name self.count = count def __repr__(self) -&gt; str: return f&#34;NamedCounter(name=&#39;{self.name}&#39;, count={self.count})&#34; クラス内に明示的に __init__ メソッドや __repr__ メソッドが定義されている場合は、そちらの実装が優先的に使われます。 比較可能なデータクラスを定義する dataclass デコレーターは、同値比較用の __eq__ メソッドもデフォルトで生成してくれます。 つまり、次のように == 演算子や != 演算子による比較が可能になります。 from dataclasses import dataclass @dataclass class Data: name: str count: int if __name__ == &#34;__main__&#34;: print(Data(&#34;a&#34;, 1) == Data(&#34;a&#34;, 1)) # True print(Data(&#34;a&#34;, 1) != Data(&#34;a&#34;, 1)) # False ただし、2 つのインスタンスを大小比較できるようにするには、dataclass デコレーターの order=True フラグを指定する必要があります。 from dataclasses import dataclass @dataclass(order=True) class Data: name: str count: int if __name__ == &#34;__main__&#34;: print(Data(&#34;a&#34;, 1) &lt; Data(&#34;a&#34;, 1)) # False print(Data(&#34;a&#34;, 1) &lt; Data(&#34;b&#34;, 1)) # True print(Data(&#34;a&#34;, 1) &lt; Data(&#34;a&#34;, 2)) # True 不変なデータクラスを定義する (frozen=True) dataclass デコレーターに frozen=True フラグを付けると、そのクラスのインスタンスを不変 (immutable) にすることができます。 つまり、インスタンス生成後にフィールドへの代入ができなくなります。 from dataclasses import dataclass @dataclass(frozen=True) class Data: name: str count: int if __name__ == &#34;__main__&#34;: d = Data(name=&#34;foo&#34;, count=1) d.name = &#34;bar&#34; # dataclasses.FrozenInstanceError d.count = 2 # dataclasses.FrozenInstanceError データクラスのインスタンスを辞書（ディクショナリ）に変換する (asdict) データクラスのインスタンスを dataclasses.asdict 関数 に渡すと、簡単にディクショナリに変換することができます。 データクラスが入れ子になっている場合は、再帰的にディクショナリ化してくれます。 次の例では、Point のリストを保持する PointList のインスタンスをディクショナリに変換しています。 from dataclasses import asdict, dataclass @dataclass class Point: x: int y: int @dataclass class PointList: points: list[Point] if __name__ == &#34;__main__&#34;: points = PointList([Point(1, 2), Point(3, 4)]) d = asdict(points) print(d) # =&gt; {&#39;points&#39;: [{&#39;x&#39;: 1, &#39;y&#39;: 2}, {&#39;x&#39;: 3, &#39;y&#39;: 4}]} print(d[&#34;points&#34;]) # =&gt; [{&#39;x&#39;: 1, &#39;y&#39;: 2}, {&#39;x&#39;: 3, &#39;y&#39;: 4}] print(d[&#34;points&#34;][0]) # =&gt; {&#39;x&#39;: 1, &#39;y&#39;: 2} print(d[&#34;points&#34;][0][&#34;x&#34;]) # =&gt; 1 print(d[&#34;points&#34;][0][&#34;y&#34;]) # =&gt; 2 他の方法として、Python 標準の vars 関数（= __dict__ 属性）でも同じようなディクショナリ変換はできますが、こちらは入れ子構造になったインスタンスを展開してくれません。 print(vars(points)) # =&gt; {&#39;points&#39;: [Point(x=1, y=2), Point(x=3, y=4)]} print(points.__dict__) # =&gt; {&#39;points&#39;: [Point(x=1, y=2), Point(x=3, y=4)]}"},{url:"/p/gn4cn3s/",title:"Python でハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (`hashlib`)",date:"2023-06-09T00:00:00+09:00",body:"Python でハッシュ値 (MD5/SHA-1/SHA-256/SHA-512) を求める (`hashlib`) Python の hashlib 標準ライブラリを使用すると、いろいろなタイプのハッシュ値を求めることができます。 バイトデータのハッシュ値を求める あるバイトデータのハッシュ値を求めるには、hashlib.sha1 や hashlib.sha256 などのコンストラクタでハッシュオブジェクトを生成し、hexdigest メソッドで 16 進数表記のハッシュ値を取得します。 次の例では、MD5、SHA-1、SHA-256 アルゴリズムを使って、b&quot;HelloWorld&quot; というバイトデータのハッシュ値を計算しています。 バイトデータのハッシュ値を求める import hashlib print(hashlib.md5(b&#34;HelloWorld&#34;).hexdigest()) print(hashlib.sha1(b&#34;HelloWorld&#34;).hexdigest()) print(hashlib.sha256(b&#34;HelloWorld&#34;).hexdigest()) 実行結果 68e109f0f40ca72a15e05cc22786f8e6 db8ac1c259eb89d4a131b253bacfca5f319d54f2 872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4 ハッシュ計算に使用するバイトデータは、update メソッドで追加していくことができます。 hash = hashlib.sha1() hash.update(b&#34;Hello&#34;) hash.update(b&#34;World&#34;) print(hash.hexdigest()) # =&gt; db8ac1c259eb89d4a131b253bacfca5f319d54f2 # 以下のようにバイトデータを結合してから update しても結果は同じ hash = hashlib.sha1() hash.update(b&#34;Hello&#34; + b&#34;World&#34;) print(hash.hexdigest()) # =&gt; db8ac1c259eb89d4a131b253bacfca5f319d54f2 文字列のハッシュ値を求める 文字列のハッシュ値を求めるには、エンコーディング形式を指定して、どのようなバイトデータとして扱うかを明確にする必要があります。 次の例では、文字列の encode メソッドで UTF-8 形式のバイトデータを取得しています。 文字列のハッシュ値を求める import hashlib str = &#34;HelloWorld&#34; bytes = str.encode(encoding=&#34;utf-8&#34;) print(hashlib.md5(bytes).hexdigest()) print(hashlib.sha1(bytes).hexdigest()) print(hashlib.sha256(bytes).hexdigest()) 実行結果 68e109f0f40ca72a15e05cc22786f8e6 db8ac1c259eb89d4a131b253bacfca5f319d54f2 872e4e50ce9990d8b041330c47c9ddd11bec6b503ae9386a99da8584e9bb12c4 ファイルのハッシュ値を求める 以下の file_sha256 関数は、指定したファイルの内容からハッシュ値を求めています。 ハッシュ値の計算にはバイトデータが必要なので、ファイルオープン時にバイトモード (&quot;b&quot;) を指定するのがポイントです。 import hashlib def file_sha256(filename: str) -&gt; str: &#34;&#34;&#34; ファイル内容の SHA-256 ハッシュ値を計算し、16 進数文字列として取得します。 &#34;&#34;&#34; with open(filename, mode=&#34;rb&#34;) as f: binary = f.read() return hashlib.sha256(binary).hexdigest() # Python 3.11 以降では次のようにも記述できます # return hashlib.file_digest(f, &#34;sha256&#34;).hexdigest() print(file_sha256(&#34;sample.py&#34;)) 実行結果 d727c62744e193aa6a0d0728e2dc78c0221bd77da2599dc6f86d17a46aa0bea4 使用可能なアルゴリズムの一覧 alogrithms_guaranteed （必ず使えるアルゴリズム） すべてのプラットフォーム使用できることが保証されているアルゴリズムの一覧は、hashlib.algorithms_guaranteed で参照できます。 import hashlib for name in sorted(hashlib.algorithms_guaranteed): print(name) 実行結果（Python 3.10 の場合） blake2b blake2s md5 sha1 sha224 sha256 sha384 sha3_224 sha3_256 sha3_384 sha3_512 sha512 shake_128 shake_256 ここに列挙された名前を使って、hashlib.new(&quot;sha256&quot;) のようにハッシュオブジェクトを生成することができます。 ただし、hashlib.sha256() のような、専用のファクトリー関数が定義されている場合はそちらを使った方が効率的です。 algorithms_available （現在のシステムで使えるアルゴリズム） 現在のシステムで使用できることができるアルゴリズムの一覧は、hashlib.algorithms_available で参照できます。 前述の hashlib.algorithms_guaranteed に含まれているアルゴリズムは、この一覧にも必ず含まれています。 for name in sorted(hashlib.algorithms_available): print(name) 実行結果 blake2b blake2s md4 md5 md5-sha1 mdc2 ripemd160 sha1 sha224 sha256 sha384 sha3_224 sha3_256 sha3_384 sha3_512 sha512 sha512_224 sha512_256 shake_128 shake_256 sm3 whirlpool hashlib.algorithms_available にしか含まれていないアルゴリズムを抽出したい場合は、次のようにセット演算を行います（参考: set オブジェクトで集合演算を行う）。 import hashlib only_in_available = hashlib.algorithms_available - hashlib.algorithms_guaranteed for name in sorted(only_in_available): print(name) 実行結果 md4 md5-sha1 mdc2 ripemd160 sha512_224 sha512_256 sm3 whirlpool 関連リンク HMAC-SHA256 コードを生成する｜まくろぐ"},{url:"/p/o4a37zc/",title:"Python でパスを指定したディレクトリからの相対パスに変換する (os.path.relpath)",date:"2023-06-02T00:00:00+09:00",body:"Python でパスを指定したディレクトリからの相対パスに変換する (os.path.relpath) os.path.relpath の使い方 Python 標準の os.path.relpath 関数 を使うと、パスを表す文字列を、特定のディレクトリからの相対パスに変換することができます。 import os # 元が絶対パスの場合 print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/&#34;)) # =&gt; a/b/c print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a&#34;)) # =&gt; b/c print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/&#34;)) # =&gt; b/c print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/b&#34;)) # =&gt; c print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/b/&#34;)) # =&gt; c print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/b/c&#34;)) # =&gt; . print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/b/c/&#34;)) # =&gt; . print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/b/c/d&#34;)) # =&gt; .. print(os.path.relpath(&#34;/a/b/c&#34;, &#34;/a/b/c/d/e&#34;)) # =&gt; ../.. # 元が相対パスの場合（基本的に同上） print(os.path.relpath(&#34;a/b/c&#34;, &#34;a&#34;)) # =&gt; b/c print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/&#34;)) # =&gt; b/c print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/b&#34;)) # =&gt; c print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/b/&#34;)) # =&gt; c print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/b/c&#34;)) # =&gt; . print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/b/c/&#34;)) # =&gt; . print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/b/c/d&#34;)) # =&gt; .. print(os.path.relpath(&#34;a/b/c&#34;, &#34;a/b/c/d/e&#34;)) # =&gt; ../.. カレントディレクトリからの相対パス os.path.relpath 関数の第 2 引数 (start) を省略すると、カレントディレクトリからの相対パスを返します。 import os os.chdir(&#34;C:/Users/maku&#34;) # ホームディレクトリに移動しておく print(os.path.relpath(&#34;C:/&#34;)) # =&gt; ..\\.. print(os.path.relpath(&#34;C:/Users&#34;)) # =&gt; .. print(os.path.relpath(&#34;C:/Users/&#34;)) # =&gt; .. print(os.path.relpath(&#34;C:/Users/maku&#34;)) # =&gt; . print(os.path.relpath(&#34;C:/Users/maku/a/b/c&#34;)) # =&gt; a\\b\\c 使用例 具体的な使用例としては、あるディレクトリ内のファイルを列挙するときに、そのディレクトリからの相対パスで出力するケースなどがあります。 os.walk でファイル列挙する場合 import os BASE_DIR = &#34;my-dataset&#34; for dirpath, dirs, files in os.walk(BASE_DIR): for name in files: # BASE_DIR ディレクトリからの相対パスを構築 path = os.path.relpath(os.path.join(dirpath, name), BASE_DIR) print(path) Path#glob によるファイル列挙 import os from pathlib import Path BASE_DIR = &#34;my-dataset&#34; for filename in Path(BASE_DIR).glob(&#34;**/*.dat&#34;): # BASE_DIR ディレクトリからの相対パスを構築 path = os.path.relpath(filename, BASE_DIR) print(path)"},{url:"/p/co7o5k2/",title:"Python でテンポラリファイル／ディレクトリを作成する (tempfile)",date:"2023-06-01T00:00:00+09:00",body:`Python でテンポラリファイル／ディレクトリを作成する (tempfile) テンポラリディレクトリを作成する 自動削除されるテンポラリディレクトリ (TemporaryDirectory) Python の tempfile モジュールが提供する TemporaryDirectory クラスを使用して、テンポラリディレクトリを作成することができます。 TemporaryDirectory オブジェクトを with 文に渡すと、as 節の変数として、作成されたテンポラリディレクトリのパスを取得できます。 テンポラリディレクトリの作成 import os import tempfile with tempfile.TemporaryDirectory() as dirname: print(dirname) # =&gt; /tmp/tmp98olubfz print(os.path.isdir(dirname)) # =&gt; True # with を抜けるとテンポラリディレクトリは既に削除されている print(os.path.isdir(dirname)) # =&gt; False テンポラリディレクトリは、with ブロックの実行コンテキストを抜けるときに自動的に削除されることに注意してください（__exit__ メソッドの実装で cleanup メソッドが呼ばれており、自動的にディレクトリが削除される仕組みになっています）。 よって、Python プログラムの中で、明示的にテンポラリディレクトリを削除する必要はありません。 自動削除されないテンポラリディレクトリ (mkdtemp) 実行コンテキストを抜けても自動削除されないテンポラリディレクトリを作成したい場合は、tempfile.TemporaryDirectory クラスの代わりに、tempfile.mkdtemp 関数を使用します。 作成されたテンポラリディレクトリは、プログラムを終了してからユーザーが手動で削除しなければいけないので、分かりやすいディレクトリに作成しておいた方がよいでしょう。 次の例では、カレントディレクトリ (.) に、.tmp サフィックスの付いたテンポラリディレクトリを作成しています。 （自動削除されない）テンポラリディレクトリの作成 import tempfile dirname = tempfile.mkdtemp(dir=&#34;.&#34;, suffix=&#34;.tmp&#34;) print(dirname) # =&gt; ./tmpu57g67kg.tmp この Python プログラムを実行終了した後にも、テンポラリディレクトリが残っていることを確認してください。 ちなみに、dir、prefix, suffix といったパラメーターは、tempfile.TemporaryDirectory クラスのコンストラクタにも指定できますが、あまり使用することはないでしょう（自動削除されるのでパスを知る必要がない）。 参考: Linuxコマンド: テンポラリディレクトリを作成する (mktemp) テンポラリファイルを作成する 自動削除されるテンポラリファイル (TemporaryFile) テンポラリファイルを作成するには、tempfile.TemporaryFile 関数を使用します。 この関数は、open 関数と同様にファイルオブジェクトを返します。 パラメーターにも open 関数と同様のものを指定できます。 次の例では、テキスト形式で読み書き可能なテンポラリファイルを作成しています。 同じファイルオブジェクトで書き込みと読み取りを行うため、mode パラメーターには &quot;w+&quot; を指定しています。 テンポラリファイルの作成 import tempfile with tempfile.TemporaryFile(mode=&#34;w+&#34;, encoding=&#34;utf-8&#34;, newline=&#34;\\n&#34;) as fp: # テンポラリファイルへ書き込む fp.write(&#34;Hello\\n&#34;) fp.write(&#34;World\\n&#34;) # テンポラリファイルの内容を読み込む fp.seek(0) lines = fp.readlines() print(lines) # =&gt; [&#39;Hello\\n&#39;, &#39;World\\n&#39;] TemporaryDirectory と同様に、TemporaryFile で作成したテンポラリファイルは、with 文の実行コンテキストを抜けるときに自動的に削除されることに注意してください。 パスを取得可能なテンポラリファイル (NamedTemporaryFile) テンポラリファイルの名前が必要な場合は、TemporaryFile の代わりに、NamedTemporaryFile を使用する必要があります。 こちらを使わないと、ファイルオブジェクトの name プロパティでファイル名を参照できません。 import tempfile def cat(filename: str) -&gt; None: &#34;&#34;&#34;指定されたファイル名のファイルの内容を標準出力に出力する&#34;&#34;&#34; with open(filename, &#34;r&#34;, encoding=&#34;utf-8&#34;) as fp: print(fp.read()) with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, encoding=&#34;utf-8&#34;, newline=&#34;\\n&#34;) as fp: # テンポラリファイルへ書き込む fp.write(&#34;Line 1\\n&#34;) fp.write(&#34;Line 2\\n&#34;) fp.write(&#34;Line 3&#34;) fp.flush() # テンポラリファイルの名前を使って何らかの処理 cat(fp.name) 自動削除されないテンポラリファイル (mkstemp) 実行コンテキストを抜けても自動削除されないテンポラリファイルを作るには、tempfile.mkstemp 関数を使用します。 指定できるパラメーターは mkdtemp 関数によるディレクトリ作成とほぼ同様で、出力先のディレクトリ (dir) や、プレフィックス (prefix)、サフィックス (suffix) を指定できます。 mkstemp 関数は、戻り値としてテンポラリファイルのデスクリプター (int) とファイル名 (str) を返します。 （自動削除されない）テンポラリファイルの作成 - 方法 1 import tempfile # テンポラリファイルの生成 fd, filename = tempfile.mkstemp(dir=&#34;.&#34;, suffix=&#34;.txt&#34;) print(fd) # =&gt; 3 print(filename) # =&gt; /Users/maku/myapp/tmplal4nz7v.txt # 書き込み with open(filename, mode=&#34;w&#34;, encoding=&#34;utf-8&#34;, newline=&#34;\\n&#34;) as f: f.write(&#34;Hello\\n&#34;) f.write(&#34;World\\n&#34;) # 読み込み with open(filename, mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f: print(f.readlines()) # =&gt; [&#39;Hello\\n&#39;, &#39;World\\n&#39;] # 明示的に削除するなら # os.remove(filename) NamedTemporaryFile 関数で delete=False プロパティを指定することでも、自動削除されないテンポラリファイルを作成できるようです。 （自動削除されない）テンポラリファイルの作成 - 方法 2 import tempfile # テンポラリファイルの生成と書き込み with tempfile.NamedTemporaryFile( mode=&#34;w&#34;, encoding=&#34;utf-8&#34;, newline=&#34;\\n&#34;, dir=&#34;.&#34;, suffix=&#34;.txt&#34;, delete=False ) as fp: filename = fp.name fp.write(&#34;Hello\\n&#34;) fp.write(&#34;World\\n&#34;) # 自動削除しないように設定 (delete=False) したので、テンポラリファイルは残っている with open(filename, mode=&#34;r&#34;, encoding=&#34;utf-8&#34;) as f: print(f.readlines()) # =&gt; [&#39;Hello\\n&#39;, &#39;World\\n&#39;]`},{url:"/p/o6q8p6m/",title:"Python の argparse モジュールでコマンライン引数を扱う",date:"2023-06-01T00:00:00+09:00",body:"Python の argparse モジュールでコマンライン引数を扱う Python が標準ライブラリとして提供している argparse モジュール を使用すると、複雑なコマンドライン引数を扱うスクリプトをシンプルに実装することができます。 単純に sys.argv を使ってコマンドライン引数を扱う方法と比べ、argparse を使うと次のような利点があります。 Linux スタイルの短いオプション (-o) や長いオプション (--output) を簡単に定義できます ユーザーが入力した値を直感的なプロパティとして参照できます（例: args.output）。 ヘルプメッセージを自動で構築してくれます（-h (--help) オプションはデフォルトで生成してくれます） 各オプションの型を定義できます（数値型オプションに文字列が指定されたときに自動でエラーにしてくれます） サブコマンドを簡単に実装できます（例: sample.py &lt;サブコマンド&gt; &lt;引数1&gt; &lt;引数2&gt;） ArgumentParser の基本 argparse モジュールは、次のような流れで使用します。 ArgumentParser クラスのインスタンスを生成する add_argument メソッドでコマンドライン引数の定義を追加していく parse_args メソッドでパースして Namespace オブジェクトを取得する Namespace オジェクトのプロパティでユーザー入力を参照する 次のスクリプトでは、-i (--input) オプションと、-o (--output) オプションを定義しています。 main.py import argparse # コマンドライン引数の仕様を定義してユーザー入力をパースする parser = argparse.ArgumentParser() parser.add_argument(&#34;-i&#34;, &#34;--input&#34;, help=&#34;input file&#34;) parser.add_argument(&#34;-o&#34;, &#34;--output&#34;, help=&#34;output file&#34;, default=&#34;out.txt&#34;) args = parser.parse_args() # =&gt; argparse.Namespace # ユーザーが入力した値を表示する print(f&#34;Input file: {args.input}&#34;) print(f&#34;Output file: {args.output}&#34;) 実行例 $ python main.py Input file: None Output file: out.txt $ python main.py -i input.txt -o output.txt Input file: input.txt Output file: output.txt ヘルプ表示用のオプション -h (--help) は自動で生成してくれます。 自動生成されたヘルプ $ python main.py -h usage: main.py [-h] [-i INPUT] [-o OUTPUT] options: -h, --help show this help message and exit -i INPUT, --input INPUT input file -o OUTPUT, --output OUTPUT output file ユーザーが間違った使い方をしたときは、Usage を表示して終了してくれます。 $ python main.py hoge usage: main.py [-h] [-i INPUT] [-o OUTPUT] main.py: error: unrecognized arguments: hoge $ python main.py -i usage: main.py [-h] [-i INPUT] [-o OUTPUT] main.py: error: argument -i/--input: expected one argument いろいろなコマンドライン引数を定義する ArgumentParser#add_argument メソッドの呼び出し方によって、様々な仕様のコマンドライン引数を定義することができます。 位置引数 (positional argument) parser.add_argument(&#34;name&#34;, type=str, help=&#34;your name&#34;) parser.add_argument(&#34;age&#34;, type=int, help=&#34;your age&#34;) # ... print(f&#34;name={args.name}, age={args.age}&#34;) $ python main.py Maku 14 name=Maku, age=14 順序通り指定しなければいけない単純なコマンドライン引数です。 引数を - や -- で始まらない名前にすると、この位置引数 (positional argument) として扱われます。 位置引数はデフォルトでユーザーによる入力が必須となりますが、nargs=&quot;?&quot; 指定によりオプショナル扱いとなり、さらに default=... 指定によりデフォルト値を設定できます。 デフォルト値は、help パラメーターの中で、%(default)s で参照できます。 parser.add_argument( &#34;output&#34;, nargs=&#34;?&#34;, default=&#34;out.txt&#34;, help=&#34;output file (default: %(default)s)&#34; ) 必須の引数 (required=True) parser.add_argument(&#34;-i&#34;, &#34;--input&#34;, help=&#34;input file&#34;, required=True) # ... print(f&#34;Input file: {args.input}&#34;) - や -- で始まる名前の引数は、デフォルトで省略可能なオプショナル扱いとなりますが、required=True フラグをつけると、ユーザーによる指定が必須になります。 上記の例であれば、ユーザーは -i (--input) オプションを必ず指定する必要があり、args.input には必ず値が入っていることが保証されます。 この required よりも、次の default を使えないかを先に検討してください。 デフォルト値 (default=&hellip;) parser.add_argument( &#34;-c&#34;, &#34;--config&#34;, default=&#34;app.toml&#34;, help=&#34;config file (default: %(default)s)&#34; ) # ... print(f&#34;Config file: {args.config}&#34;) default=... パラメーターを指定すると、ユーザーがそのオプションを指定しなかったときのデフォルト値を設定できます。 上記の例であれば、ユーザーが -c (--config) オプションを省略した場合は app.toml を指定したものとみなされ、args.config には必ず値が入っていることが保証されます。 デフォルト値は、help パラメーターの中で、%(default)s で参照できます。 ユーザーの引数指定を必須にする required=True よりも、まずはこの default パラメーターを使うことを検討すべきです。 on/off フラグ (action=&ldquo;store_true&rdquo;) parser.add_argument( &#34;-v&#34;, &#34;--verbose&#34;, action=&#34;store_true&#34;, help=&#34;increase output verbosity&#34; ) # ... print(args.verbose) $ python main.py False $ python main.py --verbose True action=&quot;store_true&quot; の指定により、True あるいは False の 2 値を表現するオプションを定義できます。 ユーザーが -v (--verbose) オプションを指定したときに、args.verbose の値が True になります。 action=&quot;store_true&quot; の代わりに action=&quot;store_false&quot; とすると、True と False の扱いが反転します（-v オプションを指定したときに args.verbose が False になります）。 選択肢 (choices=[&hellip;]) parser.add_argument( &#34;-t&#34;, &#34;--type&#34;, choices=[&#34;json&#34;, &#34;yaml&#34;, &#34;toml&#34;], default=&#34;json&#34;, help=&#34;file format (default %(default)s)&#34; ) # ... print(args.type) $ python main.py json $ python main.py -t yaml yaml $ python main.py -t hoge usage: main.py [-h] [-t {json,yaml,toml}] main.py: error: argument -t/--type: invalid choice: &#39;hoge&#39; (choose from &#39;json&#39;, &#39;yaml&#39;, &#39;toml&#39;) choices=[...] で選択肢を列挙することによって、ユーザーは制約された選択肢の中からのみ値を指定することができるようになります。 ユーザーが何も入力しなかったときの値は None となりますが、default=&quot;json&quot; のようにデフォルト値を設定しておくこともできます。 上記の例では文字列の選択肢を定義していますが、数値の選択肢も同様に定義できます。 parser.add_argument(&#34;--level&#34;, type=int, choices=[1, 2, 3, 4, 5]) parser.add_argument(&#34;--level&#34;, type=int, choices=range(1, 6)) # 同上 同一オプションが何回指定されたかを取得する (action=&ldquo;count&rdquo;) parser.add_argument(&#34;-v&#34;, action=&#34;count&#34;, default=0, help=&#34;increase output verbosity&#34;) # ... print(args.v) $ python main.py 0 $ python main.py -v 1 $ python main.py -vvv 3 action=&quot;count&quot; とすると、そのオプション自体がユーザーによって何度指定されたかをカウントしてくれます。 冗長レベルを制御するための -v、-vv、-vvv といったオプションはたまに見かけますね。 排他的にしか指定できないオプション (add_mutually_exclusive_group) group = parser.add_mutually_exclusive_group() group.add_argument(&#34;-v&#34;, &#34;--verbose&#34;, action=&#34;store_true&#34;) group.add_argument(&#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;) % python main.py -v -q usage: main.py [-h] [-v | -q] main.py: error: argument -q/--quiet: not allowed with argument -v/--verbose 同時に指定すると意味的に矛盾が生じるようなオプション項目は、排他グループを作成してそこに登録しておきます。 上記の例では、-v (--verbose) オプションと -q (--quiet) オプションは同じ排他グループに属しているため、どちらかしか指定できません。 ヘルプ表示のラベル名を変更する (metavar) parser.add_argument(&#34;input&#34;, metavar=&#34;INPUT_FILE&#34;, help=&#34;input file path&#34;) parser.add_argument(&#34;output&#34;, metavar=&#34;OUTPUT_FILE&#34;, help=&#34;output file path&#34;) $ python main.py -h usage: main.py [-h] INPUT_FILE OUTPUT_FILE ... matavar パラメーターで、ヘルプに表示されるプレースホルダー名を変更できます。 参照時のプロパティ名を変更する (dest) parser.add_argument( &#34;-v&#34;, dest=&#34;verbose&#34;, action=&#34;count&#34;, default=0, help=&#34;increase output verbosity&#34; ) # ... print(args.verbose) 通常、定義したオプション名はそのまま Namespace オブジェクトのプロパティ名となりますが、dest パラメーターでプロパティ名を変更できます。 上記の例では、-v オプションを定義しているので、通常は args.v で参照するところを、args.verbose で参照できるようにしています。 アプリケーションの説明文 ArgumentParser コンストラクタのパラメーターで、ヘルプメッセージで表示する詳細説明を追加できます。 main.py import argparse parser = argparse.ArgumentParser( description=&#34;ヘルプの最初に表示されるプログラムの説明&#34;, epilog=&#34;ヘルプの最後に表示されるプログラムの説明&#34;, ) args = parser.parse_args() 実行例 $ python main.py --help usage: main.py [-h] ヘルプの最初に表示されるプログラムの説明 options: -h, --help show this help message and exit ヘルプの最後に表示されるプログラムの説明 長いメッセージは、ターミナルの横幅に応じて適切な位置で改行して表示してくれるので、Python コード上ではどこで改行するかを気にせずに記述できます（ただし、単語の区切りがない日本語はうまくいきません）。 parser = argparse.ArgumentParser( description=&#34;&#34;&#34; Long long long long long long long long long long long long long long long long long long long description &#34;&#34;&#34; ) 整形済みのテキストとして、Python コード上での改行位置を保って出力するには、formatter_class として RawDescriptionHelpFormatter を指定します。 parser = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, description=textwrap.dedent( &#34;&#34;&#34; Please do not mess up this text! -------------------------------- I have indented it exactly the way I want it &#34;&#34;&#34; ), ) （おまけ）コマンドライン引数を扱うモジュールを切り出す 多くの機能を含む Python スクリプトは、コマンドライン引数の定義も複雑になりがちです。 argparse まわりの処理をモジュールと切り出しておくと、メインスクリプトのコードをシンプルに保つことができます。 args.py（コマンドライン引数を処理するモジュール） import argparse def get_args() -&gt; argparse.Namespace: &#34;&#34;&#34;コマンドライン引数の内容をパースして取得します。&#34;&#34;&#34; # スクリプトの説明を定義 parser = argparse.ArgumentParser( description=&#34;このスクリプトの説明をここに書く&#34;, epilog=&#34;このスクリプトの補足説明をここに書く&#34;, ) # スクリプトの引数を定義 parser.add_argument(&#34;input&#34;, help=&#34;input file&#34;) parser.add_argument(&#34;-o&#34;, &#34;--output&#34;, help=&#34;output file&#34;, default=&#34;out.txt&#34;) return parser.parse_args() 上記のように切り出したモジュールは、メインスクリプトから次のように使用できます。 main.py import args if __name__ == &#34;__main__&#34;: args = args.get_args() print(args.input) print(args.output) すっきり ٩(๑❛ᴗ❛๑)۶"},{url:"/p/o4m4jyg/",title:"Python の import 時のモジュールの検索パスを調べる (sys.path)",date:"2023-05-29T00:00:00+09:00",body:"Python の import 時のモジュールの検索パスを調べる (sys.path) モジュールの検索パスのリストは sys.path Python でモジュールをインポートするには、import モジュール名 のように記述しますが、このときにどのディレクトリのモジュールが検索されるかは、sys.path 変数の値を見ると分かります。 sys.path は検索パスを示す文字列のリスト (list[str]) です。 モジュールの検索パスを列挙する import sys import pprint pprint.pprint(sys.path) 実行結果 [&#39;/Users/maku/myapp&#39;, &#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python310.zip&#39;, &#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10&#39;, &#39;/opt/homebrew/Cellar/python@3.10/3.10.8/Frameworks/Python.framework/Versions/3.10/lib/python3.10/lib-dynload&#39;, &#39;/Users/maku/myapp/.venv/lib/python3.10/site-packages&#39;] sys.path にはどのような検索パスが含まれているか？ sys.path 変数には、自動的に次のようなパスが登録されます。 起動したスクリプトと同じディレクトリ（ただし、python をインタラクティブモードで起動したときは、カレントディレクトリを示す空文字 '' になります） 環境変数 PYTHONPATH に指定したディレクトリ Python インストーラに応じたデフォルトディレクトリ（標準ライブラリのパスなど） 注目すべきは、sys.path の先頭に追加されるパスで、これは起動されたスクリプトが格納されているディレクトリのパスになっています。 例えば、python ~/myapp/main.py と実行したときは、自動的に ~/myapp が検索パスに追加されるため、~/myapp 以下に配置したモジュール (*.py) をインポートできるようになっています。 main.py import mymod # ~/myapp/mymod.py が検索される モジュールの検索パスを追加する PYTHONPATH 環境変数を設定する方法 PYTHONPATH 環境変数に設定したディレクトリパスは、自動的に sys.path に反映されてモジュールの検索パスとして使われます。 Linux や macOS の場合 $ export PYTHONPATH=/path/to/lib1:/path/to/lib2:$PYTHONPATH パスの区切り文字は Linux や macOS ではコロン (:) ですが、Windows の場合はセミコロン (;) になることに注意してください（PATH 環境変数の指定方法と同じです）。 Windows の場合 C:\\&gt; set PYTHONPATH=C:\\path\\to\\lib1;C:\\path\\to\\lib2;%PYTHONPATH% sys.path 変数を変更する方法 sys.path 変数の内容はスクリプト内で変更可能なので、このリストに任意のパスを追加することで、モジュールの検索パスを動的に拡張できます。 sys.path.append(&#34;/path/to/lib1&#34;) sys.path.append(&#34;/path/to/lib2&#34;) モジュールやパッケージを ZIP 化したアーカイブのパスを指定することもできます。 sys.path.append(&#34;./mypkg.zip&#34;)"},{url:"/p/uivwecs/",title:"HTML ファイルや Markdown ファイルをプレーンテキストに変換する (unstructured)",date:"2023-05-26T00:00:00+09:00",body:"HTML ファイルや Markdown ファイルをプレーンテキストに変換する (unstructured) unstructured ライブラリとは Python の unstructured ライブラリは、様々な形式のデータを機械学習システムに投入する前の変換処理などを行ってくれるライブラリです。 例えば、非構造化データ（HTML や Markdown）には、機械学習には必要のないタグが含まれていたりしますが、unstructured を使ってテキストだけを取り出すことができます。 Unstructured-IO/unstructured: Open source libraries and APIs to build custom preprocessing pipelines for labeling, training, or production machine learning pipelines. 現在、ChatGPT などの大規模言語モデル (LLM) を利用したチャットシステムが注目を浴びていますが、社内ドキュメントなどの情報と統合するためには、ユーザー入力から類似ドキュメントを検索する仕組みが必要になります。 このために使用されるのが、テキスト間の類似度に基づいた検索システムであるベクトル検索 DB などです。 そこに登録するドキュメントのベクトルデータ（Embeddings）は、できるだけクリーンなテキストから生成することが望ましいのですが、unstructured ライブラリを使えば、様々な形式のデータからそういったテキストを作成できます。 unstructured ライブラリのインストール unstructured の Installation マニュアル に従って、必要なライブラリをインストールします。 unstructured ライブラリのインストール $ pip install unstructured 後述のプログラムを実行したときに、tabulate が足りないと言われたので入れました。 このあたりは試行錯誤です。 $ pip install tabulate HTML ファイルをプレーンテキストに変換してみる サンプルの入力ファイルとして、次のような HTML ファイルを用意します。 html や body タグを省略していますが、これも正しい HTML5 文書です。 input.html（入力ファイル） &lt;!DOCTYPE html&gt; &lt;meta charset=&#34;UTF-8&#34; /&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;h1&gt;Hello HTML!&lt;/h1&gt; &lt;p&gt;This is &lt;b&gt;bold&lt;/b&gt; text.&lt;/p&gt; &lt;ol&gt; &lt;li&gt;Ordered list item 1&lt;/li&gt; &lt;li&gt;Ordered list item 2&lt;/li&gt; &lt;li&gt; Ordered list item 3 &lt;ul&gt; &lt;li&gt;Unordered list item 1&lt;/li&gt; &lt;li&gt;Unordered list item 2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ol&gt; このファイルを、unstructured ライブラリの partition 関数に渡すと、Element オブジェクトのリストに変換して返してくれます。 Element オブジェクトは、構造的なまとまりごとのテキストを保持しています。 例えば、1 つの段落内のテキストです。 main.py from unstructured.partition.auto import partition elems = partition(filename=&#34;input.html&#34;) #-&gt; List[Element] text = &#34;\\n&#34;.join([str(e) for e in elems]) print(text) このプログラムを実行すると、うまくテキスト部分だけを抽出できていることが分かります。 出力結果 Hello HTML! This is bold text. Ordered list item 1 Ordered list item 2 Ordered list item 3 Unordered list item 1 Unordered list item 2 Markdown ファイルをプレーンテキストに変換してみる Markdown 形式のファイルも、HTML ファイルと同様に partition 関数で処理できます。 input.md（入力ファイル） --- title: &#34;ページタイトル&#34; date: &#34;2023-05-26&#34; --- セクション 1 ---- 文章内には __強調されたテキスト__ も含まれています。 次のようなリストも含まれています。 - 項目 1 - 項目 1-1 - 項目 1-2 - 項目 2 - 項目 3 表も含まれていることがあるよ。 | カラム1 | カラム2 | カラム3 | | ---- | ---- | ---- | | A-1 | A-2 | A-3 | | B-1 | B-2 | B-3 | 先ほどのプログラムの入力ファイル名を input.md に変えるだけで OK です。 main.py from unstructured.partition.auto import partition elems = partition(filename=&#34;input.md&#34;) #-&gt; List[Element] text = &#34;\\n&#34;.join([str(e) for e in elems]) print(text) 出力結果 title: &#34;ページタイトル&#34; date: &#34;2023-05-26&#34; セクション 1 文章内には 強調されたテキスト も含まれています。 次のようなリストも含まれています。 項目 1 項目 1-1 項目 1-2 項目 2 項目 3 表も含まれていることがあるよ。 | カラム1 | カラム2 | カラム3 | | ---- | ---- | ---- | | A-1 | A-2 | A-3 | | B-1 | B-2 | B-3 | HTML や Markdown 専用の関数を使う方法 前述の例では、入力ファイルの種類を自動判別する unstructured.partition.auto.partition 関数を使用しましたが、次のようなファイルタイプ別の関数も用意されています。 HTML 用: unstructured.partition.html.partition_html 関数 Markdown 用: unstructured.partition.md.partition_md 関数 これらの関数を使うと、ファイル名ではなく、文字列や URL で入力データを指定することができます。 from unstructured.partition.html import partition_html from unstructured.partition.md import partition_md elems = partition_html(text=&#34;&lt;p&gt;It is OK.&lt;/p&gt;&#34;) # HTML 形式のテキスト elems = partition_html(url=&#34;https://example.com&#34;) # HTML を取得可能な URL elems = partition_md(text=markdown_text) # Markdown 形式のテキスト elems = partition_md(url=&#34;https://example.com/1.md&#34;) # Markdown を取得可能な URL"},{url:"/p/rr2ahpx/",title:"Python で URL 文字列を各パートに分割する (urllib.parse.urlparse)",date:"2023-05-26T00:00:00+09:00",body:"Python で URL 文字列を各パートに分割する (urllib.parse.urlparse) Python の標準ライブラリの urllib.parse.urlparse 関数を使用すると、URL 形式の文字列から ParseResult オブジェクトを生成することができます。 ParseResult オブジェクトの各プロパティを参照することで、URL の各パート（スキーム、ドメイン、パス、クエリ文字列など）を取り出すことができます。 sample.py（URL 文字列を解析する） from urllib.parse import urlparse url = &#34;https://example.com/p/abcdefg/?foo=1&amp;bar=2#top&#34; parsed_url = urlparse(url) # ParseResult オブジェクトを生成する print(parsed_url.scheme) # =&gt; https print(parsed_url.netloc) # =&gt; example.com print(parsed_url.path) # =&gt; /p/abcdefg/ print(parsed_url.query) # =&gt; foo=1&amp;bar=2 print(parsed_url.fragment) # =&gt; top"},{url:"/p/bp9q8p6/",title:"Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する",date:"2023-05-25T00:00:00+09:00",body:"Web サイトのサイトマップ (sitemap.xml) からすべての URL を抽出する サイトマップとは？ Web サイトのサイトマップファイル (sitemap.xml) には、次のような形で全ページの URL 情報が記載されています。 このファイルは、主に Google などの検索エンジンのために提供されています。 sitemap.xml &lt;urlset xmlns=&#34;http://www.sitemaps.org/schemas/sitemap/0.9&#34; xmlns:xhtml=&#34;http://www.w3.org/1999/xhtml&#34;&gt; &lt;url&gt; &lt;loc&gt;http://example.com/page1/&lt;/loc&gt; &lt;lastmod&gt;2021-01-01&lt;/lastmod&gt; &lt;/url&gt; &lt;url&gt; &lt;loc&gt;http://example.com/page2/&lt;/loc&gt; &lt;lastmod&gt;2022-02-02&lt;/lastmod&gt; &lt;/url&gt; &lt;url&gt; &lt;loc&gt;http://example.com/page3/&lt;/loc&gt; &lt;lastmod&gt;2023-03-03&lt;/lastmod&gt; &lt;/url&gt; &lt;/urlset&gt; sitemap.xml から URL の一覧を取得する 次の Python スクリプトは、上記のような sitemap.xml ファイルから、すべての URL 情報を抽出します。 sitemap.xml ファイル自体のダウンロードには urlopen を使用し、XML のパースには ElementTree を使用しています。 extract-urls.py from urllib.request import urlopen from xml.etree import ElementTree url = &#34;https://example.com/sitemap.xml&#34; def fetch(url: str) -&gt; str: &#34;&#34;&#34;指定した URL のリソースを文字列で取得します。&#34;&#34;&#34; with urlopen(url) as res: return res.read().decode(&#34;utf-8&#34;) def extract_urls(sitemap_xml: str) -&gt; list[str]: &#34;&#34;&#34;sitemap.xml の内容から URL を抽出します。&#34;&#34;&#34; urls = [] root = ElementTree.fromstring(sitemap_xml) # &lt;loc&gt; タグの中身を取得する for loc in root.iter(&#34;{http://www.sitemaps.org/schemas/sitemap/0.9}loc&#34;): urls.append(loc.text) return urls if __name__ == &#34;__main__&#34;: sitemap_xml = fetch(url) urls = extract_urls(sitemap_xml) for url in urls: print(url) 実行結果 http://example.com/page1/ http://example.com/page2/ http://example.com/page3/ （おまけ）URL が示すリソースをまとめてダウンロードする 上記のように作成した URL リストを使って、まとめて HTML ファイルとしてダウンロードするサンプルコードです。 ダウンロードするときのファイル名を自動で生成するのは意外と面倒なので、ここでは単純に 1.html、2.html、3.html といった連番のファイル名で保存しています。 download-htmls.py import os import time from urllib.request import urlretrieve def download_all(urls: list[str], outdir=&#34;out&#34;) -&gt; None: os.makedirs(outdir, exist_ok=True) count = 1 for url in urls: save_path = f&#34;{outdir}/{count}.html&#34; print(f&#34;Downloading {url} =&gt; {save_path}&#34;) try: urlretrieve(url, save_path) count += 1 except Exception as e: # 1 つの URL で 404 エラーなどが発生しても処理は継続する print(e) time.sleep(0.5) # sleep を入れてサーバー負荷を下げる if __name__ == &#34;__main__&#34;: # 本来は sitemap.xml から抽出した URL リストを使う urls = [ &#34;http://example.com/page1/&#34;, &#34;http://example.com/page2/&#34;, &#34;http://example.com/page3/&#34;, ] download_all(urls) 実行結果 Downloading http://example.com/page1/ =&gt; out/1.html Downloading http://example.com/page2/ =&gt; out/2.html Downloading http://example.com/page3/ =&gt; out/3.html"},{url:"/p/st6fpz9/",title:"Hugo で使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates)",date:"2023-04-25T00:00:00+09:00",body:"Hugo で使用していないテンプレートやショートコードを見つける (hugo --printUnusedTemplates) Hugo で四苦八苦しながらテンプレートを開発していると、いつのまにか使われていないテンプレート（.html ファイル）が量産されていたりします。 Hugo サイトのビルド時に、未使用のテンプレートを検出するには、次のように --printUnusedTemplates オプションを付けて実行します。 $ hugo --printUnusedTemplates Start building sites … ...(省略)... WARN 2023/04/25 00:27:35 Template _default/section.backup.html is unused, source file /Users/maku/mysite/themes/maku/layouts/_default/section.backup.html WARN 2023/04/25 00:27:35 Template partials/debug/link-path.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/debug/link-path.html WARN 2023/04/25 00:27:35 Template partials/pager.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/pager.html WARN 2023/04/25 00:27:35 Template partials/top-menu.back.html is unused, source file /Users/maku/mysite/themes/maku/layouts/partials/top-menu.back.html WARN 2023/04/25 00:27:35 Template shortcodes/anchor.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/anchor.html WARN 2023/04/25 00:27:35 Template shortcodes/mermaid.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/mermaid.html WARN 2023/04/25 00:27:35 Template shortcodes/script.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/script.html WARN 2023/04/25 00:27:35 Template shortcodes/workings-and-drafts.html is unused, source file /Users/maku/mysite/themes/maku/layouts/shortcodes/workings-and-drafts.html Total in 239 ms 上記の例では、8 つのテンプレートやショートコードが使われていないことが分かります。 内容を確認して、問題なければ削除してしまいましょう。"},{url:"/p/bqar8o6/",title:"Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する",date:"2023-04-01T00:00:00+09:00",body:'Hugo Modules の仕組みで Hugo サイト用のコンテンツを分割して管理する Hugo Modules とは Hugo Modules の仕組みを使うと、異なるディレクトリに配置されたファイル群をまとめて、1 つの Hugo サイトを構成することができます。 Hugo Module の実体は、Hugo サイト用のファイルが格納されたディレクトリです。 Hugo Module は、ローカル PC 上のディレクトリであってもよいし、GitHub リポジトリ内のディレクトリであっても構いません（通常は GitHub で管理することになるでしょう）。 graph RL subgraph my-hugo-module-1 mod1("Hugo Module") end subgraph my-hugo-module-2 mod2("Hugo Module") end subgraph my-hugo-site mod1_imported("Hugo Module") mod2_imported("Hugo Module") end mod1 -- import --> mod1_imported mod2 -- import --> mod2_imported classDef classMod fill:#36f,color:white,stroke:none class mod1,mod2,mod1_imported,mod2_imported classMod この仕組みは、一見すると、Hugo テーマを Git サブモジュールとして取り込むのと同じように見えますが、Hugo Modules はより柔軟で、コンテンツを含むほとんどのファイルをインポートできます。 現状、下記の 7 つのディレクトリに格納されるファイルを、Hugo Module からインポートすることができます。 archetypes &hellip; 複数サイトでコンテンツ作成用テンプレート (.md) を共有できます。 assets &hellip; 複数サイトでビルド用のアセット（.scss など）を共有できます。 content &hellip; 複数サイトでコンテンツファイル (.md) を共有できます。 data &hellip; 複数サイトでデータ（.yml、.json など）を共有できます。複数の Hugo Module で定義されたデータをマージできます。 i18n &hellip; 複数サイトで翻訳データ (.yml、.json など）を共有できます。複数の Hugo Module で定義された翻訳データをマージできます。 layouts &hellip; 複数サイトでレイアウトやショートコード (.html) を共有できます。 static &hellip; 複数サイトで静的なファイル（.js ファイルなど）を共有できます。 Hugo Modules の仕組みでテーマ系のファイル（assets、layouts、static など）をインポートするようにすれば、もう Git サブモジュールの仕組みを使う必要はありません。 Hugo Modules の特徴をまとめると次のような感じになります。 主に、従来の Git サブモジュールによるテーマ導入の仕組みとの比較です。 Hugo Modules を使えば、前述のような様々なファイルを柔軟に組み合わせることができます。テーマのように完全な layouts を用意する必要はなく、必要なファイルだけを個別にインポートできます。可能性は無限大です。 Hugo Modules を使えば、Git サブモジュールの複雑なコマンド (git submodule) を使う必要がありません。代わりに hugo mod コマンドを使う必要はありますが、Git サブモジュールの更新管理に比べれば分かりやすいです。 Git サブモジュールを使用している場合、git clone 時に --recurse-submodules フラグを指定するなどしてサブモジュールの取り込みを忘れないよう注意する必要がありますが、Hugo Modules の場合は、単純に git clone して hugo serve するだけで、自動的に依存モジュールをインポートしてくれます（GitHub などから取得してくれる）。 Hugo Module 内の各ディレクトリ（Golang 用語ではパッケージ）を、Hugo プロジェクト内のどのディレクトリに展開（マウント）するかを指定できます。Git サブモジュールの場合は、リポジトリ単位でしか展開先を指定できません。 Hugo Modules を使うには、Golang の環境をインストールしておく必要があります。Golang の Go Modules という仕組みをベースにしているので、Golang を使ったことがないと、若干のとっつきにくさはあるかもしれません。とはいえ、基本的には Golang の知識は必要ありません。 事前準備 Golang のインストール Hugo Modules の仕組みは、Golang（Go 言語）の Go Modules という仕組みを利用して提供されています。 Hugo Modules の仕組みを使用するには、Golang の実行環境をインストール しておく必要があります。 Download and install - The Go Programming Language Golang のインストールが完了すると、Hugo Modules 用のサブコマンド (hugo mod) などが正しく動作するようになります。 逆に、Golang がインストールされていない環境で Hugo Modules を使用する Hugo サイトをビルドしようとすると、go コマンドがないというエラーになります（例: Error: failed to download modules: binary with name &quot;go&quot; not found）。 Hugo プロジェクトの作成 テスト用に Hugo サイト（プロジェクト）を作成しておきます。 $ cd ~ $ hugo new site my-hugo-site Hugo サイトを Hugo Module 化する 既存の Hugo サイトで Hugo Modules の仕組みを使用するには、hugo mod init コマンドで、その Hugo サイト自体も Hugo Module として初期化しておく必要があります。 これにより、他の Hugo Module を GitHub などから自動取得できるようになります。 Hugo Module には、（Go Modules の仕組み上）一意のモジュール名 を設定しておく必要があり、通常は GitHub リポジトリのパスを github.com/USER/REPO のような感じで指定します（USER と REPO の部分は適切に置き換えてください）。 Hugo サイトを Hugo Module 化 $ cd ~/my-hugo-site $ hugo mod init github.com/USER/my-hugo-site ☝️ 実はモジュール名は何でもよい 上記の説明では、Hugo Module には github.com/&lt;USER&gt;/&lt;REPO&gt; のような一意の名前を付ける必要があると記述しましたが、正確に言うと、これはインポートされる側の Hugo Module の要件です。 なので、実際には Hugo サイト側（他の Hugo Module をインポートする側）のモジュール名は何でもよかったりします（単純に mysite など）。 Hugo Module 化といっても、このコマンドは、次のような go.mod というファイルを生成するだけです。 最初は、自身のモジュール名と使用した Golang バージョンくらいしか記述されていませんが、このあと Hugo Module を追加するたびにこのファイルに依存関係が追加されていきます。 go.mod module github.com/USER/my-hugo-site go 1.18 Hugo Modules の仕組みでテーマをインポートする GitHub 上で公開されている Hugo テーマ を Hugo Module としてインポートするには、Hugo の設定ファイル（hugo.toml や config.toml）内に次のような module セクションを追加します。 ここでは、PaperMod というテーマを使ってみます。 hugo.toml に追加 [module] [[module.imports]] path = &#39;github.com/adityatelange/hugo-PaperMod&#39; これにより、GitHub リポジトリ上のファイル群が Hugo サイトにマージされてビルドされることになるので、hugo.toml 内のテーマ名指定（theme = \'PaperMod\' など）は必要ありません。 もっと言うと、themes ディレクトリ自体必要ありません。 インポート対象の GitHub リポジトリ（Hugo テーマ）は、Hugo Module として初期化 (hugo mod init) されていなくてもインポートできるようになっています。 つまり、現在公開されている Hugo テーマは、すべてこの仕組みでインポートできます。 ただし、依存関係を正しく管理するため、Hugo テーマは Hugo Module として初期化しておく（つまり、go.mod を配置しておく）ことが推奨されています。 Hugo Module のインポート設定ができたら、Hugo サーバーを起動して正しく Hugo Module がダウンロードされるか確認します。 Hugo サーバーの起動 $ hugo serve http://localhost:1313 にアクセスして、次のように正しくテーマが反映されていれば成功です。 図: Hugo Modules の仕組みでテーマをインポートできた コンテンツを提供する Hugo Module を作ってみる 今度は、コンテンツ（.md ファイル）を提供する Hugo Module を新しく作成してインポートしてみます。 ここでは、最終的に GitHub の https://github.com/USER/my-hugo-module というリポジトリで管理するものとして、モジュール名を付けておきます。 共有可能な Hugo Module を作成する $ mkdir ~/my-hugo-module $ cd ~/my-hugo-module $ hugo mod init github.com/USER/my-hugo-module 次に、この Hugo Module が提供するコンテンツを作成します。 ~/my-hugo-module/content/posts/hello.md --- title: &#34;Hello&#34; date: &#34;2023-04-01&#34; --- Hello, Hugo Modules! これだけで、Hugo Module は完成です。 Hugo サイトの本体側 (my-hugo-site) から、この Hugo Module をインポートするよう設定します。 ~/my-hugo-site/hugo.toml（抜粋） [module] [[module.imports]] path = &#39;github.com/adityatelange/hugo-PaperMod&#39; [[module.imports]] path = &#39;github.com/USER/my-hugo-module&#39; この時点では、この Hugo Module はまだ GitHub 上で管理していないので、Hugo サイトをビルドしようとすると Hugo Module をダウンロードできないというエラーになります。 $ cd ~/my-hugo-site $ hugo ... remote: Repository not found. fatal: repository &#39;https://github.com/USER/my-hugo-module/&#39; not found そこで、一時的に GitHub の URL（モジュールパス）をローカル PC のディレクトリパスに置き換える、Go Modules の replacement 機能を使用します。 置換内容は、Hugo 専用の HUGO_MODULE_REPLACEMENTS 環境変数で設定できます。 ローカル PC 上の Hugo Module を参照して起動 $ export HUGO_MODULE_REPLACEMENTS=&#34;github.com/USER/my-hugo-module -&gt; /Users/maku/my-hugo-module&#34; $ hugo serve 複数の置換設定を行いたいときは、カンマで区切って指定すれば OK です。 これで、正しくすべての Hugo Module をインポートできるようになり、Hugo サイトのビルドに成功するはずです。 今回のケースでは、http://localhost:1313/posts/hello/ にアクセスして記事が表示されれば成功です。 図: コンテンツ用の Hugo Module もインポートできた ちなみに、replacement の置換内容は、go.mod ファイル内の replace ディレクティブ でも設定可能ですが、最終的にはこの設定は削除して、正しく GitHub 上のリポジトリを参照するように戻さなければいけないので、HUGO_MODULE_REPLACEMENTS 環境変数を使った方が都合がよいと思います。 Hugo Module の依存関係を確認する hugo mod graph コマンドを使用すると、（Hugo Module 化した）Hugo サイトが依存している Hugo Module の一覧を確認できます。 Hugo Module の依存グラフを表示 $ cd ~/my-hugo-site $ hugo mod graph github.com/USER/my-hugo-site github.com/adityatelange/hugo-PaperMod@v0.0.0-20230331160356-2210bf20b365 github.com/USER/my-hugo-site /Users/maku/my-hugo-module この例では、Hugo サイト (my-hugo-site) が、2 つの Hugo Module（hugo-PaperMod と my-hugo-module）に依存していることが分かります。 Hugo Module の更新を取り込む GitHub 上で管理されている Hugo Module のファイルが更新された場合に、それを Hugo サイト側に反映するには、hugo mod get -u コマンドを使用します。 Hugo Module の更新 $ hugo mod get -u ./... # すべての Hugo Module を再帰的に更新 $ hugo mod get -u # すべての Hugo Module を更新 $ hugo mod get -u github.com/USER/my-hugo-module # 指定した Hugo Module を更新 $ hugo mod get -u github.com/USER/my-hugo-module@v.1.0.2 # バージョンを指定 （応用）各ディレクトリのマウント先を変更する Hugo Modules は、複数のディレクトリに散らばったファイルを集めて 1 つの Hugo サイトとしてビルドする仕組みなので、どうしてもファイル名の競合が発生してしまう可能性があります。 content ディレクトリ以下の記事ファイルや、static ディレクトリ以下の静的ファイルの名前が、複数の Hugo Module の間で競合してしまった場合、最初に見つかったファイルがビルド対象になります。 例えば、Hugo サイト本体 (my-hugo-site) から、2 つの Hugo Module（my-hugo-module-1、my-hugo-module-2）をインポートしているとして、それぞれが次のように競合する名前（パス）のファイルを持っているとすると、採用されるのは Hugo サイト本体に置かれたファイルだけです。 my-hugo-site/static/js/hello.js &hellip; http://YOUR-SITE/js/hello.js で見えるのはこのファイル my-hugo-module-1/static/js/hello.js &hellip; このファイルは見えなくなる my-hugo-module-2/static/js/hello.js &hellip; このファイルも見えなくなる このように、インポートした Hugo Module のファイルが見えなくなると都合が悪い場合は、Hugo サイトの設定ファイル（hugo.toml や config.toml）の [[module.imports.mounts]] セクションで、ディレクトリ単位でマウント先を変更します。 hugo.toml（抜粋） [module] [[module.imports]] path = &#39;github.com/USER/my-hugo-module-1&#39; [[module.imports.mounts]] source = &#39;static/js&#39; target = &#39;static/mod1/js&#39; [[module.imports]] path = &#39;github.com/USER/my-hugo-module-2&#39; [[module.imports.mounts]] source = &#39;static/js&#39; target = &#39;static/mod2/js&#39; これで、各 Hugo Module のディレクトリが別々のディレクトリにマウントされ、次のような URL でアクセスできるようになります。 http://YOUR-SITE/js/hello.js &hellip; Hugo サイト本体の JS ファイル http://YOUR-SITE/mod1/js/hello.js &hellip; my-hugo-module-1 の JS ファイル http://YOUR-SITE/mod2/js/hello.js &hellip; my-hugo-module-2 の JS ファイル 上記の設定例では、static/js ディレクトリのマウント先を変更していますが、親ディレクトリの static ディレクトリごとマウント先を変更してしまっても OK です。 （応用）GitHub Actions の設定 GitHub Actions を使って Hugo サイトをビルドしている場合は、ワークフロー内で Golang 環境をセットアップするよう指定しておく必要があります。 このセットアップを忘れると、hugo コマンドによるビルド時に次のようなエラーになります（サイト自体を Hugo Module として初期化していない場合も同様のエラーが発生します）。 Error: module &#34;github.com/USER/my-hugo-module&#34; not found; either add it as a Hugo Module or store it in &#34;/home/runner/work/my-hugo-site/my-hugo-site/themes&#34;.: module does not exist ワークフローファイルの中で、actions/setup-go アクションを指定するだけで、Golang の実行環境は簡単にインストールすることができます。 あとは、今まで通り Hugo によるビルドを行うだけで、依存する Hugo Module を自動でダウンロードしてビルドしてくれます。 .github/workflows/hugo-build.yml name: Build Hugo site on: push: branches: [main, master] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: &#39;recursive&#39; # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Go environment uses: actions/setup-go@v4.0.0 with: go-version: &#39;^1.20&#39; - name: Setup Hugo environment uses: peaceiris/actions-hugo@v2.6.0 with: hugo-version: &#39;0.111.3&#39; extended: true # Enable scss - name: Build Hugo site run: hugo --minify # ...'},{url:"/p/gxj4n7q/",title:"Rust でモジュールを定義する (mod)",date:"2023-03-05T00:00:00+09:00",body:"Rust でモジュールを定義する (mod) 規模の大きい Rust プログラムを作る場合、モジュール の仕組みを使ってコードを階層化すると見通しがよくなります。 Rust でモジュールを定義するときは、mod キーワードを使用します。 1 つの .rs ファイルの中にインライン形式でモジュールを定義することも、別ファイルに分けてモジュールを定義することもできます。 クレートとモジュール すべての Rust プログラムはクレート (crate) であり、バイナリクレート か ライブラリクレート のどちらかです。 クレートは、Rust におけるコンパイルの単位です。 バイナリクレート &hellip; 1 つの実行ファイルを作り上げるもの。 ライブラリクレート &hellip; 1 つのライブラリを作り上げるもの。 コンパイルはクレート単位で行われますが、コードレベルの実装では、モジュール という論理的な単位で分割／階層化できるようになっています。 クレートは 1 つ以上のモジュールで構成され、必ず 1 つの ルートモジュール（クレートルート） を持っています。 ルートモジュールのファイル名は決まっていて、バイナリクレートの場合は src/main.rs で、ライブラリクレートの場合は src/lib.rs です。 ルートモジュールはサブモジュールを含むことができ、さらに、サブモジュールも同様にサブモジュールを含むことができます。 クレートの論理的構造（ディレクトリ構造ではない） ルートモジュール (src/main.rs あるいは src/lib.rs) +-- サブモジュール | +-- サブサブモジュール | +-- ... +-- サブモジュール +-- サブサブモジュール +-- ... 上記のように、クレート内のモジュールはルートモジュールを起点とするツリー構造になるため、mod キーワードを使ってモジュールを定義するとき、それは必ず何らかの親モジュールのサブモジュールということになります。 モジュールの作り方 インラインモジュール mod ブロックを使ってサブモジュールを定義することができます。 サブモジュールの実装をブロック内に直接記述するので、インラインモジュール と呼ばれます。 次の例では、calc モジュールを定義して、その中に add 関数を定義しています。 src/main.rs // calc モジュールを定義する mod calc { pub fn add(a: i32, b: i32) -&gt; i32 { a + b } } fn main() { // calc モジュール内の add 関数を呼び出す println!(&#34;{}&#34;, calc::add(1, 2)); } モジュール内で定義した関数は、デフォルトでモジュール内からのみ参照可能 (private) になっているため、別モジュールから add 関数を呼び出せるようにするには pub キーワードを付けて公開設定しておく必要があります（pub の詳細は後述）。 親モジュール（ここではルートモジュール）から calc モジュールの add 関数にアクセスするには、calc::add というパスを使用します。 ファイルモジュール サブモジュールを別ファイルとして実装することもできます。 というより、大きなプロジェクトを管理する場合、こちらのファイルを使ったサブモジュール化が主な使い方になると思います。 例えば、ルートモジュール (main.rs) から呼び出すことのできる calc サブモジュールを作るには、main.rs と同じディレクトリに、calc.rs あるいは calc/mod.rs を配置します。 つまり、ディレクトリ構成は次のようになります。 calc モジュールの配置方法 (1) 2018 edition 以降 src/ +-- main.rs +-- calc.rs calc モジュールの配置方法 (2) 2015 edition 以降 src/ +-- main.rs +-- calc/ +-- mod.rs 別ファイルに分離した calc モジュールのコードは次のようになります。 先ほど mod calc ブロックの中に記述したコードと同じ内容です。 src/calc.rs pub fn add(a: i32, b: i32) -&gt; i32 { a + b } これをルートモジュールから利用するには、次のように mod calc; というモジュール宣言を行うことで、src/calc.rs（あるいは src/calc/mod.rs）の内容を読み込むようコンパイラに指示します。 あとは、先ほどの例と同様、calc::add という形でモジュール内の関数を呼び出せます。 src/main.rs mod calc; // コンパイラに calc.rs（あるいは calc/mod.rs）が存在することを知らせる fn main() { println!(&#34;{}&#34;, calc::add(1, 2)); } サブサブモジュール サブモジュール内でさらに mod キーワードを使えば、ネストする形でサブモジュールを定義することができます（以下、サブサブモジュール）。 ここでは例として、sub という名前のサブモジュールと、subsub という名前のサブサブモジュールを作ることにします。 サブサブモジュールは、サブモジュールと同じ名前のディレクトリ名 (sub) に .rs ファイルを配置することで作成できます。 サブサブモジュールの配置 src/ +-- main.rs +-- sub.rs （サブモジュール） +-- sub/ +-- subsub.rs （サブサブモジュール） あるいは、mod.rs を使う場合は次のような配置になります。 src ディレクトリの一階層目をスッキリさせたいときは、こちらの配置の方がよいですね。 src/ +-- main.rs +-- sub/ +-- mod.rs （サブモジュール） +-- subsub.rs （サブサブモジュール） 以下、それぞれの .rs ファイルの実装例です。 pub キーワードで公開設定しなければいけないのは、サブサブモジュールでも同様です（ここでは文字列定数 MY_NAME を公開設定しています）。 main.rs（ルートモジュール） mod sub; // sub.rs の存在を知らせる fn main() { sub::hello(); //=&gt; &#34;Hello, Maku&#34; } sub.rs（サブモジュール） mod subsub; // sub/subsub.rs の存在を知らせる pub fn hello() { println!(&#34;Hello, {}&#34;, subsub::MY_NAME); } sub/subsub.rs（サブサブモジュール） pub const MY_NAME: &amp;str = &#34;Maku&#34;; デフォルトでは、サブモジュールには、その親モジュールからしかアクセスできないようになっています。 上記の例で言うと、ルートモジュール (main.rs) からの sub モジュールの参照や、sub モジュールからの subsub モジュールの参照は可能ですが、ルートモジュールから直接 subsub モジュールを参照することはできません。 sub モジュールの外から subsub モジュールにアクセスできるようにするには、次のように pub mod を使ってモジュールを公開設定します。 sub.rs pub mod subsub; ここまで、pub キーワードを付けて公開設定してきたのは、モジュール内のメンバー（関数や定数）でしたが、ネストされたモジュールの公開設定も同様の仕組みで行えるということですね。 下記のサンプルコードでは、ルートモジュール (main.rs) から、サブサブモジュールに直接アクセスしています（sub::subsub という階層化されたパスを使用します）。 main.rs（ルートモジュール） mod sub; fn main() { println!(&#34;VALUE_1 = {}&#34;, sub::VALUE_1); //=&gt; 100 println!(&#34;VALUE_2 = {}&#34;, sub::VALUE_2); //=&gt; 200 println!(&#34;VALUE_3 = {}&#34;, sub::subsub::VALUE_3); //=&gt; 300 println!(&#34;VALUE_4 = {}&#34;, sub::subsub::VALUE_4); //=&gt; 400 } sub.rs（サブモジュール） pub mod subsub; // subsub モジュールを公開設定 pub const VALUE_1: i32 = 100; pub const VALUE_2: i32 = 200; sub/subsub.rs（サブサブモジュール） pub const VALUE_3: i32 = 300; pub const VALUE_4: i32 = 400; ちなみに、sub::subsub::VALUE_3 と絶対パス指定している部分は、use を使って次のように省略記述 (subsub::VALUE_3) できるようになります。 main.rs mod sub; use sub::subsub; fn main() { // ... println!(&#34;VALUE_3 = {}&#34;, subsub::VALUE_3); } 公開範囲を制限する ここまでの例では、シンプルな pub 指定による公開設定をしていましたが、これは、正確には 外部のクレートにまで公開する という意味になります。 外部クレートに公開するといっても、実際には、サブモジュールを pub 修飾しない限り、サブモジュール内のメンバーには外からはアクセスできないので、それだけで情報がダダ漏れになるということはありません。 とはいえ、公開範囲はできるだけ絞った方がよく、次のような追加のパス指定で、細かく公開範囲を制御できるようになっています。 指定方法 意味 pub 外部のクレートにまで公開 pub(crate) カレントクレートに公開 pub(super) 親モジュールに公開 （おすすめ） pub(super::super) 親モジュールの親モジュールに公開 pub(in crate::my_mod) 指定したパスのモジュールに公開（上位のモジュールのみを指定可能） （指定なし） プライベート（モジュール内でのみ参照可能） pub(self) 同上（モジュール内でのみ参照可能） 上の指定方法の中でも使っていますが、モジュールパスは次のようなプレフィックスを組み合わせて指定することができます。 self:: &hellip; 自分自身のモジュールからの相対パス super:: &hellip; 親モジュールからの相対パス crate:: &hellip; クレートルートからの絶対パス クレート内でのみ使用する要素には、pub(crate) 以上の公開範囲（つまり pub）を設定する必要はありません。 一般的に、モジュールの依存関係はツリー構造に従ったシンプルな構成になっていると保守しやすいので、まずは pub(super) で公開設定できないかを考えてみるとよいです。"},{url:"/p/22cnw7f/",title:"Rust の文法: 制御構文 (if, match, while, loop, for)",date:"2023-02-13T00:00:00+09:00",body:"Rust の文法: 制御構文 (if, match, while, loop, for) 条件分岐 if 文 (if statement) if n &gt; 0 { println!(&#34;{} is positive&#34;, n); } else if n &lt; 0 { println!(&#34;{} is negative&#34;, n); } else { println!(&#34;{} is zero&#34;, n); } C/C++ と異なり、条件式は () で囲む必要はありません。 ただし、ブロック部分は必ず {} で囲む必要があります。 if 式 (if expression) Rust の if は式として扱うことができるので、分岐後に評価した値を参照することができます（Kotlin などのモダンな言語と同様です）。 下記の変数 s には、n の値に応じて Good あるいは Bad が格納されます。 let s = if n &gt; 0 { &#34;Good&#34; } else { &#34;Bad&#34; }; if を式として使う場合は、必ず else 句が必要なことに注意してください。 また、評価後の値（上記の例では &quot;Good&quot; や &quot;Bad&quot;）の後ろには、セミコロン (;) を付けてはいけません。 セミコロンを付けると、それは式ではなく値を持たない文とみなされてしまうので、if 式の評価結果が空（空タプル ()）になってしまいます。 ☝️ Rust に三項演算子はない Java や C/C++ には三項演算子 (a ? b : c) がありますが、Rust にはこのような三項演算子は存在しません。 if 式を使えば同様のことを表現できるからです。 match 式 (match expression) C/C++ や Java の switch に相当する分岐処理として、Rust では match を使用します。 各分岐処理において、if ... というガード (guard) を付加することで、柔軟な分岐処理を行うことができます。 let n = 5; match n { 0 =&gt; println!(&#34;zero&#34;), // n が 0 の場合 _ if n &lt; 0 =&gt; println!(&#34;negative&#34;), // n が負の場合 _ if n &lt; 10 =&gt; println!(&#34;single digit&#34;), // n が 1 から 9 の場合 _ =&gt; println!(&#34;multiple digits&#34;), // それ以外（n が 10 以上）の場合 } if と同様に、match は式として扱うことができるので、評価後の値を変数などで受け取ることができます。 /// ゲームのジャンル enum Genre { Action, Shooting, Table, Strategy, Rpg } let g = Genre::Action; // ジャンルの略称に変換する let abbr = match g { Genre::Action =&gt; &#34;ACT&#34;, Genre::Shooting =&gt; &#34;STG&#34;, Genre::Table =&gt; &#34;TBL&#34;, _ =&gt; &#34;OTHER&#34;, }; println!(&#34;{}&#34;, abbr); //=&gt; ACT ちなみに、上記の例では列挙型 (enum) の値による分岐処理を行っています。 列挙型の詳細はこちら を参照してください。 ループ while ループ let mut n = 1; while n &lt;= 3 { println!(&#34;n = {n}&#34;); n += 1; } if と同様、条件部分は () で囲まず、ブロック部分は {} で囲みます。 Rust には C/C++ のような do-while 構文はありませんが、break や continue は同様に使用できます。 無限ループにしたいときは、while true とする代わりに、下記の loop を使用します。 loop ループ Rust には、無限ループ用の loop が用意されています。 let mut n = 1; loop { println!(&#34;n = {n}&#34;); n += 1; if n &gt; 3 { break; } } for-in ループ for-in ループは、イテレート可能なコレクション要素を 1 つずつ取り出すときに使用します。 配列要素を 1 つずつ取り出す let arr = [100, 200, 300]; for x in arr { println!(&#34;The value is: {}&#34;, x); } 範囲演算子（.. や ..=）で Range オブジェクトを作れば、数値範囲のループ処理を行えます。 1〜4 のループ (right-exclusive range operator) for i in 1..5 { print!(&#34;{i} &#34;) } 1〜5 のループ (right-inclusive range operator) for i in 1..=5 { print!(&#34;{i} &#34;) } 逆順にループ（5 → 1） for i in (1..=5).rev() { println!(&#34;{i}&#34;); } in の後ろの部分に式を記述した場合、ループの実行前に一度だけ評価されます。 例えば、下記の s.len() 部分は一度だけ実行されます。 for i in 0..s.len() { // ... } for の iteration variable（イテレーション変数）のスコープは for ステートメント内に限定されるので、外側で定義されている変数と同じ名前を使うことができます（推奨はされませんが）。 外側のループを抜ける &#39;outer: loop { for i in 0..5 { println!(&#34;{}&#34;, i); if i == 2 { break &#39;outer; } } } while、loop、for-in ループに 'ラベル名: という形でラベルを付けておくと、ネストされたループを break で抜けることができます。"},{url:"/p/4nx8hqy/",title:"Rust の文法: 所有権 (ownership) と借用 (borrow)",date:"2023-02-13T00:00:00+09:00",body:"Rust の文法: 所有権 (ownership) と借用 (borrow) 所有権 (ownership) Rust においてヒープ上で管理される値には 所有権 (ownership) という概念があり、必ず 1 つの変数だけが所有権を保持しています。 所有権を持つ変数が関数などのスコープから外れるときに、メモリが解放され、値が破棄されます。 この仕組み（制約）により、Rust では、ヒープ上に確保された値がどこで解放されるかをコンパイル時に決定できるようになっています（Java のようなガーベジコレクションが必要ありません）。 Rust で独特なのは、所有権が変数間で移動するところで、次のような操作を行ったときに所有権が移動します（この振る舞いを move と呼びます）。 代入演算子 (=) で別の変数に代入したとき 関数の引数として変数を渡したとき 関数の戻り値として変数を返したとき 代入による所有権の移動 // ヒープ上に String インスタンスが確保され、変数 s1 が所有者 (owner) となる let s1 = String::from(&#34;Hello&#34;); // s1 の所有権が s2 に移動 (move) し、s1 は無効化される let s2 = s1; // コンパイルエラー！（ここでは s1 はもう使えない） println!(&#34;{}, {}&#34;, s1, s2); 次のように clone メソッドで明示的なディープコピーを行えば、所有権は移動しません。 ヒープ上の新しい領域に値がコピーされ、それぞれの変数が別の値の所有者となるからです。 let s1 = String::from(&#34;Hello&#34;); let s2 = s1.clone(); // ディープコピー // s1 も s2 も独立した値の所有者なので両方アクセスできる println!(&#34;{}, {}&#34;, s1, s2); //=&gt; Hello, Hello i32 型などのプリミティブ型に関しては、（ヒープではなく）スタック上 に値が配置されるので、所有権の概念を持ちません。 代入後もすべての変数が有効です。 スタック上に確保される値に所有権はない let a = 100; let b = a; // a も b も有効 println!(&#34;{}, {}&#34;, a, b); //=&gt; 100, 100 プリミティブ型であっても、次のように Box 型でラップすることでヒープ上で管理することができます。 let x = Box::new(7); // x が Box&lt;i32&gt; を所有する let y = x; // 所有権が y に移動し、x は無効化される 借用 (borrow) 所有権の移動 (move) は、関数の引数として変数値を渡すときにも発生します。 下記のコードの calc_len 関数は、引数で渡した変数の所有権を奪ってしまいます。 関数を抜けるときに、その変数は破棄されることになるので、呼び出し元の変数は無効になります。 関数呼び出しにより所有権が奪われる（間違った例） fn calc_len(s: String) -&gt; usize { s.len() } let s = String::from(&#34;Hello&#34;); let len = calc_len(s); // ここで s の所有権が奪われる println!(&#34;{}, {}&#34;, s, len); // エラー！（s はもう有効ではない） これでは変数の値をたかだか 1 回しか参照できなくなってしまうので、Rust は 借用 (borrow) という仕組みを用意することで、所有権を移動させずにその値を参照 できるようにしています。 ある変数に &amp; を付けると、その変数の参照を取得（借用）することができます。 参照の型を表現するときも &amp; プレフィックスを付けて表現します（例: String の参照型は &amp;String）。 let s1: String = String::from(&#34;Hello&#34;); let s2: &amp;String = &amp;s1; // 借用 (borrow) // s1 も s2 も有効 println!(&#34;{} {}&#34;, s1, s2); この仕組みを利用すれば、前述の calc_len を改良して、呼び出し時に所有権を奪わないようにすることができます。 具体的には、次のようにパラメーターの型を参照型にし、呼び出し時に借用した参照を渡すようにします（どちらも &amp; を付けます）。 所有権を奪わない関数の例 // パラメーターの型を参照にした（実際は `&amp;str` の方がよい） fn calc_len(s: &amp;String) -&gt; usize { s.len() } let s = String::from(&#34;Hello&#34;); let len = calc_len(&amp;s); // 借用により s の所有権は奪われない println!(&#34;{}, {}&#34;, s, len); //=&gt; Hello, 5 関数内で作成したインスタンスを戻り値として返す場合は、参照ではなく通常の型で返すのが一般的です。 関数の終わりで所有権が移動するのは正しい振る舞いだからです。 戻り値の型は参照型にしない fn create_message() -&gt; String { let s = String::from(&#34;Hello&#34;); s // 呼び出し側に所有権が移動する（想定通り） } 可変借用 (mutable borrow) 参照経由で値を変更するには、&amp;mut を付けて 可変参照 を作成する必要があります。 ある変数の可変参照を取得することを 可変借用 (mutable borrow) と呼びます。 これと区別するために、通常の借用 (borrow) によって取得した参照のことを、不変参照とよぶことがあります。 // 可変参照で String を受け取って内容を変更する fn add_suffix(s: &amp;mut String) { s.push_str(&#34;BBB&#34;) } let mut s = String::from(&#34;AAA&#34;); add_suffix(&amp;mut s); // 可変借用 (mutable borrow) して作った可変参照を渡す println!(&#34;{}&#34;, s); //=&gt; &#34;AAABBB&#34; 通常の参照 (&amp;) とは異なり、ある変数の 可変参照 (&amp;mut) は 1 度に 1 つまでしか作れない という制約があります。 これは、複数箇所からの同時変更による競合を防ぐための Rust の仕様です。 また、通常の借用で取得した不変参照を保持しているときも、可変参照を作ることはできません。 不変だと思って参照している値が、別の場所から変更されては困るからです。 逆に、可変参照が存在しない状況では、不変参照は同時にいくつでも作成できます。 このあたりの振る舞いは、一般的に Read-Write Lock と呼ばれているデザインパターンそのものです（書き込む人がいなければ、いろんな場所から同時に読み込んでも問題ない）。"},{url:"/p/h8kw8ju/",title:"Rust の文法: 構造体 (struct) とタプル構造体 (tuple struct)",date:"2023-02-13T00:00:00+09:00",body:"Rust の文法: 構造体 (struct) とタプル構造体 (tuple struct) 構造体の基本 Rust の構造体の定義とインスタンス化は直感的です。 構造体を定義するときは struct 構造体名 { ... }、定義済みの構造体をインスタンス化するときは 構造体名 { ... } という構文を使用します。 先頭に struct というキーワードが付くかどうかの違いしかないので、どちらの処理を行っているのか気を付けて読み取ってください。 // 構造体の定義（フィールド名と型を指定していく） struct User { name: String, email: String, active: bool, sign_in_count: u64, } // インスタンス化（フィ―ルド名と初期値を指定していく） let user = User { email: String::from(&#34;maku@example.com&#34;), name: String::from(&#34;maku&#34;), active: true, sign_in_count: 1, }; // フィールドの参照にはドットを使う println!(&#34;{}&#34;, user.name); 構造体のフィールドとして文字列を持ちたいときは、&amp;str（文字列スライス）ではなく String 型を使うことで、構造体インスタンス自身が文字列の所有者になることができます（参考: 所有権と借用）。 構造体インスタンスの参照（借用）経由でフィールドにアクセスする場合もドットが使えます。 let user_ref = &amp;user; // 借用 (borrow) して参照 (&amp;User) を作成 println!(&#34;{}&#34;, user_ref.name); // 参照のフィールドもドットでアクセスする 可変な構造体 (mutable struct) インスタンス生成時に let の代わりに let mut を使うと、可変 (mutable) なインスタンスとなり、すべてのフィールドが再代入可能になります（一部のフィールドだけを再代入可能にすることはできません）。 let mut user = User { // ... }; // 各フィールドに別の値を代入可能 user.name = String::from(&#34;puni&#34;); user.active = false; 次のように、構造体インスタンスを丸ごと入れ替えることもできます。 user = User { email: String::from(&#34;puni@example.com&#34;), name: String::from(&#34;puni&#34;), active: false, sign_in_count: 777, }; フィールド初期化の省略記法 フィールド初期化時に、フィールド名と初期値とする変数名が同じ場合、フィールド名だけを記述する省略記法を使えます。 fn build_user(email: String, name: String) -&gt; User { User { email, // email: email と書くのと同じ name, // name: name と書くのと同じ active: true, sign_in_count: 1, } } このような省略記法は TypeScript (JavaScript) でも採用されています。 部分的に異なるインスタンスを生成する 既存の構造体インスタンスがあるときに、一部のフィールドの値だけが異なる別のインスタンスを生成したいときは、次のように .. を使って残りのフィールドをコピーします。 let user1 = User { email: String::from(&#34;maku@example.com&#34;), name: String::from(&#34;maku&#34;), active: true, sign_in_count: 1, }; let user2 = User { email: String::from(&#34;puni@example.com&#34;), name: String::from(&#34;puni&#34;), ..user1 }; ..user1 の後ろにはカンマ (,) を付けないことに注意してください。 この構文もスプレッド演算子として TypeScript (JavaScript) に採用されています。 タプル構造体 (tuple struct) 構造体のフィールド名を省略した、タプル構造体 (tuple struct) を定義することができます。 通常のタプル に名前を付けたようなものと考えればよいです。 通常のタプルと同様に、各フィールドの値は、.0、.1 のようなインデックスで参照します。 // Point という名前のタプル構造体を定義する struct Point(i32, i32); // 基本的な使い方 let p = Point(100, 200); println!(&#34;{}, {}&#34;, p.0, p.1); //=&gt; 100, 200 通常のタプルと同様に、各フィールドの値を別々の変数に展開することができます。 // 各フィールドの値を別々の変数（x と y）に展開 let Point(x, y) = p; println!(&#34;{x}, {y}&#34;); //=&gt; 100, 200 構造体のデバッグ出力 構造体を定義するときに #[derive(Debug)] という属性を付けておくと（あるいは Debug トレイト を自力で実装しておくと）、println! マクロで、{:?} により構造体の内容をデバッグ出力できるようになります（複数行で整形して出力したいときは {:?} の代わりに {:#?} を使用します）。 #[derive(Debug)] struct Point { x: i32, y: i32, } let p = Point { x: 100, y: 200 }; println!(&#34;{:?}&#34;, p); println!(&#34;{:#?}&#34;, p); 出力結果 Point { x: 100, y: 200 } Point { x: 100, y: 200, } 構造体のメソッドを実装する 構造体のメソッドは、impl ブロック内で定義します。 メソッドの第 1 引数は、構造体インスタンスの参照を示す &amp;self になります（Python の文法と似ています）。 構造体の型は明らかなので、&amp;self に型を指定する必要はありません。 struct Rect { width: u32, height: u32, } // Rect のメソッドを実装する impl Rect { fn area(&amp;self) -&gt; u32 { self.width * self.height } } let r = Rect { width: 5, height: 2 }; println!(&#34;{}&#34;, r.area()); //=&gt; 10 構造体のフィールドを変更したい場合は、メソッドの第 1 引数を &amp;mut self にします。 このメソッドを呼び出す場合は、構造体のインスタンスを生成するときに let mut を使わなければいけないことに注意してください。 impl Rect { // 自身のフィールドの内容を変更するメソッド fn double(&amp;mut self) { self.width *= 2; self.height *= 2; } } let mut r = Rect { width: 5, height: 2 }; r.double(); 関連関数 (associated function) impl ブロック内で &amp;self（や &amp;mut self）を第 1 引数に取らない関数を定義すると、その構造体の 関連関数 (associated function) として扱われます。 他の言語では static メソッドと呼ばれているもので、呼び出し時にインスタンスを必要としません。 関連関数を呼び出すには 構造体名::関数名 という構文を使用します（C++ の static メソッドと同様です）。 関連関数としてファクトリ関数を定義する struct Point { x: f64, y: f64, } impl Point { // 関連関数 (静的メソッド）の定義 fn origin() -&gt; Point { Point { x: 0.0, y: 0.0 } } } // 関連関数を呼び出す let p = Point::origin(); 上の例では origin 関数の戻り値の型を Point としていますが、次のように Self というキーワードを使うことで、impl 対象の構造体の型が指定されたものとみなされます。 impl Point { fn origin() -&gt; Self { Point { x: 0.0, y: 0.0 } } }"},{url:"/p/7r3cmv6/",title:"Rust の文法: 配列 (array) とタプル (tuple)",date:"2023-02-13T00:00:00+09:00",body:"Rust の文法: 配列 (array) とタプル (tuple) 配列 (array) 配列の基本 Rust の配列は、多くの言語と同様に [] を使って生成することができます。 配列の要素の型はすべて同一である必要があり、配列サイズ（要素数）は不変です。 要素数をあらかじめ固定できない場合は、配列の代わりに ベクター (Vec) 型 を使います。 let arr = [0, 1, 2]; // [i32; 3] let arr = [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;]; // [&amp;str; 3] let arr = [true, false, true]; // [bool; 3] 要素の参照は、C/C++ と同様に 0 始まりのインデックス指定で行えます (arr[0])。 配列のサイズ（要素数）は arr.len() で取得できます。 let arr = [&#39;あ&#39;, &#39;い&#39;, &#39;う&#39;]; println!(&#34;{}, {}, {}&#34;, arr[0], arr[1], arr[2]); // あ, い, う println!(&#34;len={}&#34;, arr.len()); // len=3 可変配列 (mutable array) 要素を変更可能にしたいときは、次のように let mut で配列を定義します。 可変というのは、ある位置の値を変更できるという意味であって、配列のサイズや型を変更することはできないことに注意してください。 let mut arr = [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;]; arr[1] = &#34;XXX&#34;; println!(&#34;{:?}&#34;, arr); //=&gt; [&#34;AAA&#34;, &#34;XXX&#34;, &#34;CCC&#34;] 次のように、すべての要素をまとめて入れ替えることもできますが、同じ型＆サイズの配列を代入しなければいけません。 let mut arr = [1, 2, 3]; // [i32; 3] 型の変数 println!(&#34;{:?}&#34;, arr); //=&gt; [1, 2, 3] arr = [4, 5, 6]; // [i32; 3] 型の配列であれば代入できる println!(&#34;{:?}&#34;, arr); //=&gt; [4, 5, 6] 配列のサイズを指定して初期化 セミコロン (;) を使った特殊な構文を使うと、要素の初期値とサイズを指定して配列を生成することができます。 初期値 ABCDE が 3 つ含まれる配列を生成 let arr = [&#34;ABCDE&#34;; 3]; println!(&#34;{:?}&#34;, arr); //=&gt; [&#34;ABCDE&#34;, &#34;ABCDE&#34;, &#34;ABCDE&#34;] タプル (tuple) タプルの基本 タプルは任意の数のフィールドを持つことができる複合型です。 配列と似ていますが、タプルでは各フィールドの型が異なっていても構いません。 let t = (&#34;AAA&#34;, 100, &#39;x&#39;); // 型は推測されるので下記と同様 let t: (&amp;str, i32, char) = (&#34;AAA&#34;, 100, &#39;x&#39;); 各フィールドを参照するには、t.0、t.1、t.2 のように、ドットの後にインデックス番号を指定します。 配列とは異なり、変数に格納されたインデックス番号を使用することはできません（t.index のようには書けません）。 println!(&#34;{}, {}, {}&#34;, t.0, t.1, t.2); //=&gt; AAA, 100, x // まとめて出力する場合は次のようにすると楽 println!(&#34;{:?}&#34;, t); //=&gt; (&#34;AAA&#34;, 100, x) 可変タプル (mutable tuple) 配列と同様、タプルも let mut を付けて定義することで、各フィールドの値を可変にすることができます。 ただし、各フィールドの「型」は変更できないことに注意してください。 let mut t = (&#34;AAA&#34;, 100, &#39;x&#39;); t.0 = &#34;BBB&#34;; t.1 = 200; t.2 = &#39;y&#39;; タプルの分解 次のようにして、タプルの各要素を別々の変数に格納することができます。 let t = (&#34;AAA&#34;, 100, &#39;x&#39;); let (x, y, z) = t; // タプルの分解 println!(&#34;{}, {}, {}&#34;, x, y, z); //=&gt; AAA, 100, x 空タプル (empty tuple) = ユニット (unit) Rust では、値がないことを示す型（値）として、空タプル () が使われます。 これは、1 つもフィールドを持たないタプルで、値も型も () と記述します。 C/C++ void に相当するもので、ユニット (unit) とも呼ばれます。 戻り値を持たない関数は空タプルを返します。 空のブロック ({}) も空タプルを返します。 次の a、b、c はすべて空タプルになります。 let a = (); // 明示的な空タプル let b = {}; // 評価後の値がないブロック let c = (|| {})(); // 戻り値のないクロージャの呼び出し println!(&#34;{:?} {:?} {:?}&#34;, a, b, c); //=&gt; () () () 戻り値を持たない関数を定義するとき戻り値の型は省略できますが、明示的に -&gt; () と記述することもできます。 // 関数 foo と bar は戻り値を持たない （= 空タプルを返す） fn foo() {} fn bar() -&gt; () {} println!(&#34;{:?}&#34;, foo()); // () println!(&#34;{:?}&#34;, bar()); // ()"},{url:"/p/w6cjckc/",title:"WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh)",date:"2023-02-01T00:00:00+09:00",body:"WSL2 内の Docker サーバーに LAN 内の別 PC からアクセスする (netsh) 別 PC から WSL2 内のサーバーへのアクセス Windows の WSL2 環境で Docker コンテナを動かしているとき、そこで起動した Web サーバーなどへは、LAN 内の別 PC からはデフォルトではアクセスできません。 LAN 内の別 PC ---&gt; Windows ---&gt; WSL2 (Docker) このようなアクセスを許可するには、Windows のコマンドプロンプトを管理者として実行し、次のように netsh interface portproxy コマンドでポートフォワード設定をしてやる必要があります。 netsh ユーティリティ（ネットワークサービスシェル）は、Windows 上の様々なネットワーク構成を設定／参照するためのコマンドです。 Windows のポートフォワード設定を追加する C:\\&gt; netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=80 connectaddress=172.28.72.28 connectport=80 上記の例では、外部からの Windows の 80 番ポートへのアクセス (0.0.0.0:80) を、WSL2 の 80 番ポート（この例では 172.28.72.28:80）へ転送するように設定しています。 現在のポートフォワード設定 (portproxy) は次のように確認できます。 Windows のポートフォワード設定を確認する C:\\&gt; netsh interface portproxy show all ipv4 をリッスンする: ipv4 に接続する: Address Port Address Port --------------- ---------- --------------- ---------- 0.0.0.0 80 172.28.72.28 80 必要のなくなったポートフォワード設定は、次のように削除できます（Windows を再起動することでも削除できます）。 削除するときは、転送元のアドレスとポートを指定するだけで OK です。 Windows のポートフォワード設定を削除する C:\\&gt; netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=80 ちなみに、転送先となる WSL2 の IP アドレスは、WSL2 側の bash シェルで、ip a コマンドで調べることができます。 通常は eth0 デバイスに割り当てられた IPv4 アドレス (inet) の部分を参照すれば OK です。 WSL2 の IP アドレスを調べる maku@win:/mnt/c$ ip a show dev eth0 6: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether 00:15:5d:93:85:2c brd ff:ff:ff:ff:ff:ff inet 172.28.72.28/20 brd 172.28.79.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::215:5dff:fe93:852c/64 scope link valid_lft forever preferred_lft forever Windows 側から直接実行したい場合は、wsl -e コマンドが使えます。 C:\\&gt; wsl -e ip a show dev eth0 適当な Web サーバーコンテナを起動して試してみる 今回の構成で接続テストするには、次のように WSL2 側で軽量な nginx コンテナを立ち上げてしまうのがお手軽です。 # Windows から WSL2 の bash シェルを起動 C:\\&gt; bash # WSL2 側で Docker デーモンを起動 maku@win:/mnt/c$ sudo service docker start # nginx コンテナを起動 maku@win:/mnt/c$ docker container run --rm -p 8000:80 nginx:alpine-slim ここでは、コンテナを -p 8000:80 オプション付きで起動し、ホスト側の localhost:8000 へのアクセスを、コンテナの 80 番ポートに転送するよう設定しています。 この状態で、Windows 上のブラウザから http://localhost:8000/ を開くと、WSL2 側の Web サーバーにアクセスできるはずです（WSL2 では、デフォルトで Windows 側の localhost へのアクセスを、WSL2 側に転送してくれるようになりました）。 ただし、この時点では、外部の PC からはまだアクセスできません。 次のように Windows 上でポートフォワード設定を追加する必要があります。 # 管理者権限でコマンドプロンプトを開いてポートフォワード設定 C:\\&gt; netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=8000 connectaddress=172.28.72.28 connectport=8000 ここでのポイントは、転送先のポート番号を 8000 と指定するところです (connectport=8000)。 80 番ポートを使っているのは、あくまで WSL2 の中の Docker コンテナなので、外側からのアクセスには、コンテナ起動時に公開した 8000 番ポートの方を使う必要があります。 これで、外部の PC から WSL2 内の Docker サーバーへアクセスできます（例えば、192.168.1.100:8000 などで）。 ٩(๑❛ᴗ❛๑)۶ わーぃ 将来的には Windows のポートフォワード設定がいらなくなる？ 下記のマイクロソフトのページに、Microsoft は、このエクスペリエンスを改善する方法を検討しています という記載があります（2023-01 時点）。 毎回、netsh でポートフォワード設定を行うのはさすがに面倒なので、この改善が早く実装されるとよいですね。 WSL を使用したネットワーク アプリケーションへのアクセス | Microsoft Learn"},{url:"/p/eefwaa3/",title:"Rust でハッシュマップ型 (HashMap) を扱う",date:"2023-01-25T00:00:00+09:00",body:"Rust でハッシュマップ型 (HashMap) を扱う ハッシュマップの基本 Rust の標準ライブラリとして、キー＆バリューのコレクションを扱うハッシュマップ型 (HashMap&lt;K, V&gt;) が用意されています。 下記は、空のハッシュマップを作成し、キー＆バリューを追加／取得する例です。 use std::collections::HashMap; let mut map = HashMap::new(); map.insert(String::from(&#34;AAA&#34;), 100); map.insert(String::from(&#34;BBB&#34;), 200); map.insert(String::from(&#34;CCC&#34;), 300); println!(&#34;{:?}&#34;, map.get(&#34;AAA&#34;)); //=&gt; Some(100) println!(&#34;{:?}&#34;, map.get(&#34;ZZZ&#34;)); //=&gt; None 上記の例では、HashMap の型パラメーターを省略していますが、insert しているデータから、キーの型は String、値の型は i32 と推測されます。 HashMap のキーの型が String であっても、get メソッドの引数には &amp;str を渡せるようになっています。 ハッシュマップの生成方法 空のハッシュマップを生成する (new, with_capacity) let mut map: HashMap&lt;String, i32&gt; = HashMap::new(); let mut map: HashMap&lt;String, i32&gt; = HashMap::with_capacity(100) 空のマップは new で生成できますが、あらかじめ格納する要素数を想定できるときは with_capacity を使うと効率的です。 HashMap 型には、Vec 型の vec! のようなインスタンス生成用のマクロは用意されていないので、これらの関数を使ってインスタンスを生成する必要があります。 空のハッシュマップには何らかのデータを詰める必要があるので、通常は mutable な変数として定義します。 コンパイラーが、格納するデータから型を推測してくれるので、ほとんどのケースで型情報 (: HashMap&lt;String, i32&gt;) を省略できます。 let mut map = HashMap::new(); let mut map = HashMap::with_capacity(100) タプル（キーと値）のベクターから生成する use std::collections::HashMap; let kv_pairs = vec![ (String::from(&#34;AAA&#34;), 100), (String::from(&#34;BBB&#34;), 200), (String::from(&#34;CCC&#34;), 300), ]; let map: HashMap&lt;_, _&gt; = kv_pairs.into_iter().collect(); このケースでは、collect メソッドに、HashMap 型としてまとめ上げることを知らせるために、HashMap&lt;_, _&gt; という型情報の指定が必要になります。 キーの型と値の型はコンパイラに推測してもらうので、_ とだけ記述しておけば OK です。 HashMap の extend メソッドを使う方法もあります。 use std::collections::HashMap; let vec = vec![(&#34;AAA&#34;, 100), (&#34;BBB&#34;, 200), (&#34;CCC&#34;, 300)]; let mut map = HashMap::new(); map.extend(vec); キーのベクターと値のベクターから生成する use std::collections::HashMap; let keys = vec![String::from(&#34;AAA&#34;), String::from(&#34;BBB&#34;), String::from(&#34;CCC&#34;)]; let values = vec![100, 200, 300]; let map: HashMap&lt;_, _&gt; = keys.iter().zip(values.iter()).collect(); 要素の追加と削除 (insert, remove) HashMap への要素の追加は insert、削除は remove メソッドで行います。 すでに存在するキーに対して insert を実行すると、古い値が上書きされます。 存在しないキーに対して remove を実行した場合は無視されます。 use std::collections::HashMap; let mut map = HashMap::new(); map.insert(String::from(&#34;AAA&#34;), 100); map.insert(String::from(&#34;AAA&#34;), 0); // 上書きする map.insert(String::from(&#34;BBB&#34;), 200); map.remove(&#34;BBB&#34;); // 削除する（BBB が削除される） map.remove(&#34;CCC&#34;); // 削除する（何も起こらない） println!(&#34;{:?}&#34;, map); //=&gt; {&#34;AAA&#34;: 0} remove メソッドは、Option 型 を返すようになっており、削除されたキーに対応する値を取得することができます。 存在しないキーを指定した場合（何も削除されなかった場合）は、None を返します。 if let Some(val) = map.remove(&#34;AAA&#34;) { println!(&#34;削除された値は {} です&#34;, val); } キーに対応する値を取得する (get) HashMap#get メソッドで、指定したキーに対応する値を取得することができます。 戻り値は Option 型 で返されるため、指定されたキーが存在するかを調べつつ値を取り出すことができます。 // HashMap を作成する let mut map = HashMap::new(); map.insert(String::from(&#34;AAA&#34;), 100); // キーに対応する値を取得する let key = String::from(&#34;AAA&#34;); if let Some(val) = map.get(&amp;key) { println!(&#34;{} の値は {} です&#34;, &amp;key, val); } else { println!(&#34;{} が見つかりません&#34;, &amp;key); } 全ての要素をループ処理する HashMap の要素（キー＆バリュー）を 1 つずつ取り出して処理したいときは、iter メソッドを使用します。 let mut map = HashMap::new(); map.insert(String::from(&#34;AAA&#34;), 100); map.insert(String::from(&#34;BBB&#34;), 200); map.insert(String::from(&#34;CCC&#34;), 300); // HashMap::iter() は (&amp;&#39;a key, &amp;&#39;a value) を順不同で返す for (key, value) in map.iter() { println!(&#34;{} =&gt; {}&#34;, key, value); } 実行結果 CCC =&gt; 300 AAA =&gt; 100 BBB =&gt; 200 ループしながら値を書き換えたいときは、iter の代わりに iter_mut を使用して、値への可変参照を取得します。 // HashMap::iter_mut() は (&amp;&#39;a key, &amp;&#39;a mut value) を順不同で返す for (key, value) in map.iter_mut() { *value += 1; println!(&#34;{} の値に 1 を足して {} にしました&#34;, key, value); } 実行結果 BBB の値に 1 を足して 201 にしました CCC の値に 1 を足して 301 にしました AAA の値に 1 を足して 101 にしました キーが見つからない場合に値をセットする (or_insert) // HashMap の作成 let mut map = HashMap::new(); map.insert(String::from(&#34;AAA&#34;), 100); // 指定したキーが存在しなければ新しい値をセットする map.entry(String::from(&#34;AAA&#34;)).or_insert(0); map.entry(String::from(&#34;BBB&#34;)).or_insert(0); println!(&#34;{}&#34;, map.get(&#34;AAA&#34;).unwrap()); //=&gt; 100 println!(&#34;{}&#34;, map.get(&#34;BBB&#34;).unwrap()); //=&gt; 0 or_insert は可変参照を返すので、取り出した値を利用して自分自身の値を書き換えることができます。 次の例では、単語の出現数をカウントしています。 let text = &#34;AAA BBB CCC BBB AAA&#34;; let mut word_count = HashMap::new(); for word in text.split_whitespace() { let count = word_count.entry(word).or_insert(0); *count += 1; } println!(&#34;{:?}&#34;, word_count); //=&gt; {&#34;AAA&#34;: 2, &#34;BBB&#34;: 2, &#34;CCC&#34;: 1} 整数型 (i32) のデフォルト値は 0 なので、or_insert(0) の代わりに or_default() を使うこともできます。"},{url:"/p/4ye2eah/",title:"Rust で Excel ファイルを読み込む (calamine)",date:"2023-01-20T00:00:00+09:00",body:"Rust で Excel ファイルを読み込む (calamine) calamine とは Rust の calamine クレートは、Excel ファイルを読み込むためのライブラリです。 calamine - Rust tafia/calamine: A pure Rust Excel/OpenDocument SpeadSheets file reader: rust on metal sheets 読み込み専用 (read-only) のライブラリですが、ピュアな Rust 実装で軽量です。 作者の tafia (Johann Tuffe) 氏によると、「書き込み (write) はめっちゃ複雑だから対応しないよ。セルのアップデートくらいなら対応するかもね」とのこと。 Rust プロジェクトで次のように依存関係を追加すれば準備完了です。 $ cargo add calamine 以下、Excel ファイルを読み込むサンプルコードです。 ワークシート名のリストを取得する (Xlsx#sheet_names) open_workbook で Excel ファイルを開いて、Xlsx インスタンスを取得するところがすべての始まりです。 Xlsx#sheet_names メソッドで、ワークシート名の一覧を取得できます。 use calamine::{Reader, Xlsx}; fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let workbook: Xlsx&lt;_&gt; = calamine::open_workbook(&#34;sample.xlsx&#34;)?; let sheet_names = workbook.sheet_names(); println!(&#34;{:?}&#34;, sheet_names); Ok(()) } 出力例 [&#34;Sheet1&#34;, &#34;Sheet2&#34;] ワークシートを読み込む (Xlsx#worksheet_range, worksheet_range_at) Xlsx#worksheet_range メソッドで、ワークシート内のデータ（セル）を読み込むことができます。 このようにデータを読み込む場合は、open_workbook で Excel ファイルを開くときに、mutable 変数で受け取る必要があることに注意してください（ワークシートの情報を内部に展開するため）。 use calamine::{Reader, Xlsx}; fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; { let mut workbook: Xlsx&lt;_&gt; = calamine::open_workbook(&#34;sample.xlsx&#34;)?; // Sheet1 という名前のワークシートを読み込む if let Some(Ok(range)) = workbook.worksheet_range(&#34;Sheet1&#34;) { println!(&#34;{:?}&#34;, range); // range は Range&lt;DataType&gt; インスタンス } Ok(()) } 出力例（A1～B2 のセルがある場合） Range { start: (0, 0), end: (1, 1), inner: [String(&#34;A1セル&#34;), String(&#34;B1セル&#34;), String(&#34;A2セル&#34;), String(&#34;B2セル&#34;)] } ワークシート名ではなく、インデックスでワークシートを指定したいときは、worksheet_range の代わりに worksheet_range_at メソッドを使います。 if let Some(Ok(range)) = workbook.worksheet_range_at(0) { println!(&#34;{:?}&#34;, range); } 値を持つセルの範囲を取得する (Range#get_size) Range#get_size メソッドで、ワークシート内のどの範囲（行／列）にセルが存在するかを調べることができます。 上記方法で、Range オブジェクトを取得済みと想定しています。 // range は Range&lt;DataType&gt; インスタンス println!(&#34;rows = {}&#34;, range.get_size().0); println!(&#34;cols = {}&#34;, range.get_size().1); 出力例 1000 30 1 行ずつループ処理する (Range#rows) ここで使用する Excel ファイル (sample.xlsx) の内容は、次のようになっていると想定します。 （空）と書いてあるのは空白セルです。 つまり、3 行 x 3 列で、歯抜けのセルが含まれたワークシートです。 A1セルB1セル（空） A2セルB2セルC2セル （空）B3セル（空） Range オブジェクトの rows メソッドを使って、次のように 1 行ずつループ処理することができます。 各行のカラム数は len() メソッドで取得できますが、この値は最も多くのカラムを含む行に合わせた値になるようです（今回の sample.xlsx では、すべての行のカラム数が 3 になる）。 let mut workbook: Xlsx&lt;_&gt; = calamine::open_workbook(&#34;sample.xlsx&#34;)?; if let Some(Ok(range)) = workbook.worksheet_range_at(0) { for row in range.rows() { println!(&#34;len={}, row={:?}, row[0]={:?}&#34;, row.len(), row, row[0]); } } 出力例 len=3, row=[String(&#34;A1セル&#34;), String(&#34;B1セル&#34;), Empty], row[0]=String(&#34;A1セル&#34;) len=3, row=[String(&#34;A2セル&#34;), String(&#34;B2セル&#34;), String(&#34;C2セル&#34;)], row[0]=String(&#34;A2セル&#34;) len=3, row=[Empty, String(&#34;B3セル&#34;), Empty], row[0]=Empty 空のセルは、DataType 列挙型の Empty バリアントとして表現されます。 ループ時に行のインデックスが欲しければ、enumerate と組み合わせて次のようにします。 for (row_index, row) in range.rows().enumerate() { println!(&#34;{}: {:?}&#34;, row_index, row); } 出力例 0: [String(&#34;A1セル&#34;), String(&#34;B1セル&#34;), Empty] 1: [String(&#34;A2セル&#34;), String(&#34;B2セル&#34;), String(&#34;C2セル&#34;)] 2: [Empty, String(&#34;B3セル&#34;), Empty] すべてのセルを取り出す (Range#cells) Range 内のセルを、行単位ではなくまとめて取得したいときは、Range#cells メソッドを使用します。 let cells = range.cells(); // Cells&lt;DataType&gt; println!(&#34;セルの数 = {}&#34;, cells.len()); for cell in cells { let row = cell.0; let col = cell.1; let data = cell.2; println!(&#34;[{}, {}] = {}&#34;, row, col, data); } 出力例 セルの数 = 9 [0, 0] = A1セル [0, 1] = B1セル [0, 2] = [1, 0] = A2セル [1, 1] = B2セル [1, 2] = C2セル [2, 0] = [2, 1] = B3セル [2, 2] = 各セルの値 (cell.2) は、DataType という列挙型で表現されており、各バリアントで異なるタイプのデータを保持するようになっています。 match 式を使えば、含まれているデータのタイプに応じて分岐処理することができます。 for cell in range.cells() { print!(&#34;[{}, {}] = &#34;, cell.0, cell.1); // セルの位置を表示 match cell.2 { DataType::Empty =&gt; println!(&#34;空っぽのセルです&#34;), DataType::String(s) =&gt; println!(&#34;{} という文字列セルです&#34;, s), DataType::Int(n) =&gt; println!(&#34;{} という整数値セルです&#34;, n), DataType::Float(f) =&gt; println!(&#34;{} という浮動小数点数セルです&#34;, f), DataType::Bool(b) =&gt; println!(&#34;{} という真偽値セルです&#34;, b), DataType::DateTime(d) =&gt; println!(&#34;{} という日時セルです&#34;, d), DataType::Error(e) =&gt; println!(&#34;ERROR: {}&#34;, e), } } 出力例 [0, 0] = A1セル という文字列セルです [0, 1] = B1セル という文字列セルです [0, 2] = 空っぽのセルです [1, 0] = A2セル という文字列セルです [1, 1] = B2セル という文字列セルです [1, 2] = C2セル という文字列セルです [2, 0] = 空っぽのセルです [2, 1] = B3セル という文字列セルです [2, 2] = 空っぽのセルです 空セルや文字列セルかどうかを調べる専用のメソッドも用意されています。 let data = cell.2; println!(&#34;is_empty = {}&#34;, data.is_empty()); println!(&#34;is_string = {}&#34;, data.is_string()); 文字列セルの場合だけ、その文字列を取り出しつつ処理したい場合は、DataType#get_string メソッドで Option&lt;&amp;str&gt; を取得します。 let data = cell.2; if let Some(s) = data.get_string() { println!(&#34;文字列セルの値: {}&#34;, s); } 単一のセルの値を取得する (Range#get_value, get) Range#get_value メソッドで、指定した行・列のセルの値を取得することができます。 戻り値は Option&lt;&amp;DataType&gt; 型になっており、空セルの場合は Option::None が返されます。 let cell = range.get_value((0, 1)); // Option&lt;&amp;DataType&gt; println!(&#34;{:?}&#34;, cell); //=&gt; Some(String(&#34;Hello&#34;))"},{url:"/p/bdp2doy/",title:"Rust でコマンドライン引数を扱う (2) clap クレート",date:"2023-01-12T00:00:00+09:00",body:"Rust でコマンドライン引数を扱う (2) clap クレート clap とは？ clap クレート は、コマンドライン引数のパーサーライブラリで、次のような機能を備えています。 一般的なオプション形式（-a や --name val）や、サブコマンド形式の引数のパース ヘルプ出力 (usage) の自動生成 シェル用の入力補完スクリプト生成（clap_complete クレート） derive マクロにより多くのボイラプレートコードを自動生成してくれるので、コードをシンプルに保ちつつ、高度なコマンドライン引数処理を行うことができます。 clap を使う準備 clap クレートを使うために、最初に Cargo.toml に依存関係を追加しておきます。 clap クレートを使う準備 $ cargo add clap --features derive derive マクロを有効にするために、--features derive オプションが必要です。 次のように依存関係が追加されていれば OK です。 Cargo.toml [dependencies] clap = &#34;4.0.32&#34; clap の基本 任意の構造体定義に、clap が提供する #[derive(Parser)] マクロを付加することで、コマンドライン引数用のバッファとして使えるようになります。 src/main.rs use clap::Parser; /// ヘルプ出力の最初に表示されるテキスト #[derive(Parser)] struct Args { /// 1 番目のパラメーターの説明として表示されるテキスト first: String, /// 2 番目のパラメーターの説明として表示されるテキスト second: u32, } fn main() { let args = Args::parse(); println!(&#34;{:?}, {:?}&#34;, &amp;args.first, &amp;args.second); } 上記のように定義した Args 構造体は、自動的に parse メソッドを備えるようになり、これを main 関数で呼び出すことで、コマンドライン引数をパースしてフィールドに格納してくれます。 下記は、正しくコマンドライン引数を指定した場合の実行結果です。 実行例 $ ./myapp aaa 100 &#34;aaa&#34;, 100 ☝️ cargo コマンドで起動する場合 上記の実行例は、myapp という名前の実行ファイルを生成したと想定しています。 cargo コマンドで直接実行する場合は、次のような感じでコマンドライン引数を指定します。 $ cargo -q run -- aaa 100 -q オプションは Cargo の冗長なメッセージを抑制するもので、-- はそれ以降のコマンドライン引数をプログラム側に渡すことを示しています。 構造体の first フィールドに &quot;aaa&quot; という文字列が格納され、second フィールドに 100 という数値が格納されています。 second フィールドは、u32 型として定義されているので、ユーザーが数値以外を入力すると、clap はヘルプメッセージを出力してプログラムを終了 (Error#exit) します。 メッセージの内容は clap が自動生成してくれます。 不正なコマンドライン引数を指定した場合 $ ./myapp aaa bbb error: Invalid value &#39;bbb&#39; for &#39;&lt;SECOND&gt;&#39;: invalid digit found in string For more information try &#39;--help&#39; これだけでも十分に便利ですが、clap はさらに -h や --help オプションを自動で実装してくれます。 表示されるヘルプメッセージは、構造体のドキュメンテーションコメント (///) の記述から自動生成されます。 実行例 $ ./myapp --help ヘルプ出力の最初に表示されるテキスト Usage: myapp &lt;FIRST&gt; &lt;SECOND&gt; Arguments: &lt;FIRST&gt; 1 番目のパラメーターの説明として表示されるテキスト &lt;SECOND&gt; 2 番目のパラメーターの説明として表示されるテキスト Options: -h, --help Print help information Linux スタイルのコマンドライン引数 -f や --foo のような Linux スタイルのコマンドライン引数を定義するには、構造体のフィールドに #[arg(short, long)] 属性を付加します。 /// Simple program to greet a person #[derive(Parser)] struct Args { /// Name of the person to greet #[arg(short, long)] name: String, /// Number of times to greet #[arg(short, long)] count: u8, /// Run in debug mode #[arg(short, long)] debug: bool, } デフォルトでは、構造体のフィールド名 (name) から、-n や --name といったオプションが自動生成されます。 $ ./myapp --help Simple program to greet a person Usage: myapp --name &lt;NAME&gt; --count &lt;COUNT&gt; Options: -n, --name &lt;NAME&gt; Name of the person to greet -c, --count &lt;COUNT&gt; Number of times to greet -d, --debug Run in debug mode -h, --help Print help information 他にも次のような属性指定が可能です。 #[arg(short)] &hellip; 短い形式のオプション (-n) のみ生成します。 #[arg(long)] &hellip; 長い形式のオプション (--name) のみ生成します。 #[arg(short = 'x')] &hellip; 短い形式のオプション名を -x に変更します。 #[arg(long = &quot;xyz&quot;)] &hellip; 短い形式のオプション名を --xyz に変更します。 省略可能なパラメーターとデフォルト値 構造体のフィールドの型を Option 列挙型 として定義すると、そのコマンドライン引数は省略可能になります。 #[derive(Parser)] struct Args { /// Name of the person to greet #[arg(short, long)] name: Option&lt;String&gt;, /// Number of times to greet #[arg(short, long)] count: Option&lt;u8&gt;, /// Run in debug mode #[arg(short, long)] debug: Option&lt;bool&gt;, } ユーザーがコマンドライン引数を指定しなかった場合、対応するフィールドの値は Option::None となります。 fn main() { let args = Args::parse(); match &amp;args.name { Some(name) =&gt; println!(&#34;Hello, {}&#34;, name), None =&gt; println!(&#34;Who are you?&#34;), } } bool 型のフィールドに関しては、Option 型にしなくても省略可能なフラグとして機能します。 ユーザーがこのフラグを指定しなかった場合は、デフォルト値として false が格納されます。 #[derive(Parser)] struct Args { /// Run in debug mode #[arg(short, long)] debug: bool, } 次のように default_value でデフォルト値を設定しておくこともできます。 この場合も、フィールドを Option 型にする必要はありません。 #[derive(Parser)] struct Args { /// Name of the person to greet #[arg(short, long, default_value = &#34;John Doe&#34;)] name: String, } Linux 形式ではないコマンドライン引数 (positional arguments) も通常は必須のコマンドライン引数として扱われますが、Optional 型にするか、デフォルト値を指定することで、省略可能にすることができます。 #[derive(Debug, Parser)] struct Args { /// Input file name input: Option&lt;String&gt;, /// Output file name #[arg(default_value = &#34;output.txt&#34;)] output: String, } 特定の値だけ指定できるようにする (ValueEnum) 決められた値のいずれかのみを指定できるオプションを定義するには、ValueEnum 使って次のようにします。 ここでは、--format オプションで json、yaml、toml のいずれかを指定できるように実装しています。 ユーザーが --format オプションを指定しなかった場合は、デフォルトで json が使われます。 use clap::{Parser, ValueEnum}; #[derive(Parser)] struct Args { /// Output format #[arg(short, long)] #[clap(value_enum, default_value_t=Format::Json)] format: Format, } #[derive(ValueEnum, Clone, Debug)] enum Format { Json, Yaml, Toml, } fn main() { let args = Args::parse(); println!(&#34;format = {:?}&#34;, args.format); } ヘルプもそれっぽい内容で表示してくれます。 $ ./myapp --help Usage: myapp [OPTIONS] Options: -f, --format &lt;FORMAT&gt; Output format [default: json] [possible values: json, yaml, toml] -h, --help Print help information ヘルプ表示のカスタマイズ 値のプレースホルダー名 (value_name) 値を持つパラメーターの場合、ヘルプ表示においてその値の部分は &lt;フィールド名&gt; というプレースホルダで表示されますが、その表示は value_name でカスタマイズできます。 #[derive(Parser)] struct Args { /// Input file name #[arg(short, long, value_name = &#34;PATH&#34;)] input: PathBuf, } 上記のように指定すると、ヘルプ表示で --input &lt;INPUT&gt; と表示されていた部分が、--input &lt;PATH&gt; という表示に変わります。 ヘルプ表示例 $ cargo fmt &amp;&amp; cargo -q run -- -h Usage: hello --input &lt;PATH&gt; Options: -i, --input &lt;PATH&gt; Input file name -h, --help Print help information 詳細説明 アプリケーションや各パラメーターの詳細説明は次のように記述します。 /// My app /// /// Long long long description. /// Long long long description. /// Long long long description. #[derive(Parser)] struct Args { /// Your name /// /// Long long long description. /// Long long long description. /// Long long long description. name: String, } この詳細説明を表示するには、--help オプションを指定してプログラムを起動します（-h では表示されません）。 $ ./myapp --help My app Long long long description. Long long long description. Long long long description. Usage: myapp &lt;NAME&gt; Arguments: &lt;NAME&gt; Your name Long long long description. Long long long description. Long long long description. Options: -h, --help Print help information (use `-h` for a summary)"},{url:"/p/xdyk5o8/",title:"Rust で JSON フォーマットを扱う (serde)",date:"2023-01-09T00:00:00+09:00",body:"Rust で JSON フォーマットを扱う (serde) Serde とは？ Rust の serde クレート は、Rust プログラム内で定義したユーザー型（struct や enum）を、JSON や YAML、BSON といった様々なデータ形式にシリアライズ／デシリアライズするためのライブラリです。 Serde という名前は、Serialize ＋ Deserialize から来ています。 発音は、すぁーでぃ です。 Serde website serde API documentation Serde を使う準備 Serde を使うためには、ベースとなる serde クレートに加えて、扱いたいデータフォーマット用のクレート（Serializer / Deserialize 実装）を依存関係に追加しておく必要があります。　例えば、JSON であれば serde_json、YAML であれば serde_yaml です。 serde 本体と各データフォーマット用の依存を追加 $ cargo add serde --features=derive $ cargo add serde_json # データフォーマットとして JSON を使う場合 Serde の derive マクロを有効にするために、--features=derive オプションを指定する必要があることに注意してください。 Cargo.toml に次のような依存関係が追加されていれば準備 OK です。 Cargo.toml [dependencies] serde = { version = &#34;1.0.152&#34;, features = [&#34;derive&#34;] } serde_json = &#34;1.0.91&#34; 基本的な使い方 (to_string, from_str) 次のサンプルコードでは、ユーザー定義の構造体 (Book) のインスタンスから JSON 文字列への変換（シリアライズ）と、その逆の、JSON 文字列から構造体インスタンスへの変換（デシリアライズ）を行っています。 注: コードのシンプル化ため、ここでは Result#unwrap メソッドを使っていますが、プロダクトコードでは正しく Result を処理してください（参考: Result の基本）。 src/main.rs use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { id: i32, title: String, } fn main() { // シリアライズ (構造体 → JSON 文字列) // 整形したいときは to_string の代わりに to_string_pretty を使えば OK let book = Book { id: 1, title: String::from(&#34;Title-1&#34;) }; let json = serde_json::to_string(&amp;book).unwrap(); println!(&#34;{}&#34;, json); //=&gt; {&#34;id&#34;:1,&#34;title&#34;:&#34;Title-1&#34;} // デシリアライズ (JSON 文字列 → 構造体) let json = r#&#34;{&#34;id&#34;:2, &#34;title&#34;:&#34;Title-2&#34;}&#34;#; let book: Book = serde_json::from_str(json).unwrap(); println!(&#34;{}, {}&#34;, book.id, book.title); //=&gt; 2, Title-2 } ユーザー定義型（struct や enum）を、任意の Serializer / Deserializer 実装（serde_json など）で変換するには、その型に Serialize トレイト および Desrialize トレイト を実装しておく必要があります。 これは、ユーザー定義型を、Serde が処理できる汎用的なデータモデル に変換するための実装ですが、シンプルな構成の型であれば、上記のように #[derive(Serialize, Deserialize)] 属性を付加するだけで、デフォルト実装を提供してくれます。 ☝️ コンパイル時のコード生成 Serde が提供する derive マクロにより、Serialize と Deserialize の実装がコンパイル時に自動生成されます。 JSON ライブラリの設計によっては、アプリケーションの実行時にデータ型をリフレクションで処理するという方法も考えられますが、Serde は変換用の実装コードをコンパイル時に生成するという設計を採用しています。 これにより、実行時に高速かつ安全に動作することを保証しています。 必要に応じて、serde::ser::Serialize トレイトを実装することで、独自のシリアライズ処理 を提供することができます。 JSON ファイルへの保存と読み込み (to_writer, from_reader) serde_json クレートは、io::Write への書き込みを行う to_writer / to_writer_pretty 関数や、io::Read からの読み込みを行う from_reader 関数を提供しています。 これらの関数を利用して、ファイルやネットワークストリームに対して読み書きを行えます。 JSON ファイルへの保存 src/main.rs use std::{error::Error, fs::File, path::Path}; use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { id: i32, title: String, } fn save_book_to_json_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P, book: &amp;Book) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { let file = File::create(path)?; // std::io::Error の可能性 serde_json::to_writer_pretty(file, book)?; // serde_json::Error の可能性 Ok(()) } fn main() { let book = Book { id: 1, title: String::from(&#34;Title-1&#34;) }; match save_book_to_json_file(&#34;book.json&#34;, &amp;book) { Ok(_) =&gt; println!(&#34;JSON ファイルへの保存に成功しました&#34;), Err(err) =&gt; eprintln!(&#34;JSON ファイルへの保存に失敗しました: {}&#34;, err), } } JSON ファイルの読み込み src/main.ts use std::{error::Error, fs::File, io::BufReader, path::Path}; use serde::{Deserialize, Serialize}; #[derive(Serialize, Deserialize)] struct Book { id: i32, title: String, } fn load_book_from_json_file&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Book, Box&lt;dyn Error&gt;&gt; { let file = File::open(path)?; // std::io::Error の可能性 let reader = BufReader::new(file); // 読み込み時は明示的にバッファリング let book = serde_json::from_reader(reader)?; // serde_json::Error の可能性 Ok(book) } fn main() { match load_book_from_json_file(&#34;book.json&#34;) { Ok(book) =&gt; { println!(&#34;JSON ファイルの読み込みに成功しました&#34;); println!(&#34;内容: {}, {}&#34;, book.id, book.title); } Err(err) =&gt; eprintln!(&#34;JSON ファイルの読み込みに失敗しました: {}&#34;, err), } } フィールド名を変更する デフォルトでは JSON フィールド名は、Rust の構造体のフィールド名がそのまま使われますが、構造体の定義に #[serde(rename_all)] 属性を付けると、対応付ける JSON フィールド名のルールをまとめて変更できます。 JSON フィールド名を camelCase 形式にする #[derive(Serialize, Deserialize)] #[serde(rename_all = &#34;camelCase&#34;)] struct User { avatar_url: String, // JSON フィールド名は &#34;avatarUrl&#34; になる website_url: String, // JSON フィールド名は &#34;websiteUrl&#34; になる } rename_all の値として、他にも次のようなルールを指定できます。 &quot;lowercase&quot; &quot;UPPERCASE&quot; &quot;PascalCase&quot; &quot;camelCase&quot; &quot;snake_case&quot; &quot;SCREAMING_SNAKE_CASE&quot; &quot;kebab-case&quot; &quot;SCREAMING-KEBAB-CASE&quot; 構造体のフィールドに #[serde(rename = &quot;別名&quot;)] 属性を付けると、各フィールドを指定した名前でリネームすることができます。 JSON フィールド名を具体的に指定する #[derive(Serialize, Deserialize)] struct User { #[serde(rename = &#34;id&#34;)] user_id: String, // ... } デシリアライズ時に、別の JSON フィールド名でも読み込めるようにするには、#[serde(alias = &quot;name&quot;)] で別名を指定します。 これは、JSON へのシリアライズには影響しないことに注意してください。 別名は複数指定することができます。 この機能は恒久的には使うべきではないかもしれませんが、JSON ファイルのフォーマットを段階的に移行したいときに便利です。 JSON フィールド名が異なっていても読み込む #[derive(Serialize, Deserialize)] struct User { #[serde(alias = &#34;id&#34;, alias = &#34;ID&#34;, alias = &#34;userId&#34;)] user_id: String, // ... } 参考: Attributes · Serde 未知の JSON フィールドが見つかったらエラーにする デシリアライズしようとしている JSON データに、未知のフィールドが含まれているとき（Rust のユーザー定義型に対応するフィールドがないとき）、デフォルトではそのフィールドの値は無視されます。 つまり、構造体のインスタンスの生成は問題なく実行されます。 JSON データに未知のフィールドが含まれているときにエラーにしたい場合は、ユーザー定義型に deny_unknown_fields 属性 (container attribute) を付加します。 #[derive(Serialize, Deserialize)] #[serde(deny_unknown_fields)] struct Book { // ... } Nullable や存在しない JSON フィールドを扱う JSON の null 値を扱う Rust には null という概念は存在しませんが、値が存在しないかもしれないフィールドは Option 列挙型で表現できます。 例えば、JSON データの title フィールドの値として null が含まれている可能性がある場合は、対応する構造体の title フィールドを次のように Option 型にします。 #[derive(Serialize, Deserialize)] struct Book { id: i32, title: Option&lt;String&gt;, } これで、次のような null 値を含む JSON ファイルを読み込めます。 Rust 側で値を参照すると Option::None という値として参照できます。 book.json（title フィールドの値が null） { &#34;id&#34;: 1, &#34;title&#34;: null } JSON にフィールドが存在しないとき 次のように、JSON データに対象のフィールド自体が存在しない場合も、Option 型でハンドルできます。 この場合も、Option::None という値が格納されます。 book.json（title フィールドが存在しない） { &#34;id&#34;: 1 } 構造体のフィールドを Option 型にする代わりに、#[serde(default)] 属性を付けて、その型のデフォルト値を入れることもできます。 次のように定義すると、JSON データに対応するフィールドが存在しないときに、String 型のデフォルト値である空文字列 (&quot;&quot;) が格納されます（#[serde(default = &quot;func_name&quot;)] として、任意のデフォルト値生成関数を呼び出すこともできます）。 #[derive(Serialize, Deserialize)] struct Book { id: i32, #[serde(default)] title: String, } ただし、これは、JSON にフィールドが存在しない場合のみ機能するもので、値として null が含まれている場合はエラーになることに注意してください（その場合は Option 型を使う必要があります）。 参考: Default value for a field · Serde シリアライズ／デシリアライズの対象外にする 特定の構造体フィールドを Serde のシリアライズ／デシリアライズの対象外にするには、次のような属性をフィールドに付加します。 #[serde(skip)] &hellip; シリアライズとデシリアライズの対象外にする。 #[serde(skip_serializing)] シリアライズの対象外にする。 #[serde(skip_deserializing)] デシリアライズの対象外にする。 デシリアライズの対象外になっている構造体フィールドは、Default::default() が返すデフォルト値で初期化されます。 もし、#[serde(default = &quot;func_name&quot;)] という属性値がセットされている場合は、指定した関数がデフォルト値の生成のために呼び出されます。 他にも、属性を使って次のように細かな制御を行うことができます。 // Option 値が None のときは JSON フィールドを出力しない #[serde(skip_serializing_if = &#34;Option::is_none&#34;)] comment: Option&lt;String&gt;, // 文字列が空の場合は JSON のフィールドを出力しない、ただし、読み込み時は空文字列として初期化する #[serde(default, skip_serializing_if = &#34;String::is_empty&#34;)] serial: String, // ベクターが空の場合は JSON のフィールドを出力しない、ただし、読み込み時は空のベクターとして初期化する #[serde(default, skip_serializing_if = &#34;Vec::is_empty&#34;)] authors: Vec&lt;String&gt;, // マップが空の場合は JSON のフィールドを出力しない、ただし、読み込み時は空のマップとして初期化する #[serde(default, skip_serializing_if = &#34;HashMap::is_empty&#34;)] attributes: HashMap&lt;String, String&gt;, 形式の不明な JSON ファイルを読み込む (serde_json::Value) どのようなフィールドが含まれているかわからない JSON ファイルを読み込む場合は、任意の JSON データ型を示す serde_json::Value として読み込みます。 serde_json::Value は次のような定義の列挙型 (enum) で、JSON で表現できるデータ型がバリアントとして定義されています。 pub enum Value { Null, // null Bool(bool), // bool Number(Number), // 数値 String(String), // 文字列 Array(Vec&lt;Value&gt;), // 配列 Object(Map&lt;String, Value&gt;), // オブジェクト } ここでは、次のような JSON ファイルを読み込んでみます。 「オブジェクトの配列」の形になっているということまでは分かっているものとします。 games.json [ { &#34;title&#34;: &#34;Final Fantasy&#34;, &#34;genre&#34;: &#34;RPG&#34; }, { &#34;title&#34;: &#34;Sqoon&#34;, &#34;genre&#34;: &#34;STG&#34;, &#34;price&#34;: 4900 }, { &#34;title&#34;: &#34;Gimmick&#34;, &#34;note&#34;: &#34;プレミア価格&#34; } ] 次の例では、games.json を Value 型として読み込み、その内容を表示しています。 src/main.rs use serde_json::Value; use std::fs::File; use std::io::BufReader; // games.json を読み込んで Value 型で返す fn load_games() -&gt; Value { let file = File::open(&#34;games.json&#34;).expect(&#34;ファイルが開けませんでした。&#34;); let reader = BufReader::new(file); serde_json::from_reader(reader).expect(&#34;JSON の解析に失敗しました。&#34;) } fn main() { let games_json: Value = load_games(); // JSON 全体は配列なので Value::Array として参照する if let Value::Array(games) = &amp;games_json { for game in games { // 個々の要素は Value::Object として取り出す for (key, value) in game.as_object().unwrap() { println!(&#34;{}: {}&#34;, key, value); } println!(&#34;--------------------&#34;); } } else { println!(&#34;JSON のルート要素は配列でなければいけません。&#34;); } } 実行結果 $ cargo run -q genre: &#34;RPG&#34; title: &#34;Final Fantasy&#34; -------------------- genre: &#34;STG&#34; price: 4900 title: &#34;Sqoon&#34; -------------------- note: &#34;プレミア価格&#34; title: &#34;Gimmick&#34; -------------------- まず、下記の行で games.json ファイル全体を汎用的な Value 型として読み出しています。 let games_json: Value = load_games(); Value は列挙型なので、その内容を参照するには、if let 構文でどのバリアントなのかを判別してから参照する必要があります（参考: enum 型の使い方）。 今回の games.json は配列形式で記述されていると想定し、次のようにして Value::Array バリアント（内容は Vec&lt;Value&gt; 型）として参照しています。 if let Value::Array(games) = &amp;games_json { // ... games を Vec&lt;Value&gt; 型として参照できる ... } Value::Array バリアントとして取り出した games は Vec&lt;Value&gt; 型なので、for-in ループで列挙することができます。 そして、games の中の個々の要素 game はオブジェクト形式なので、Value::Object バリアントとして参照することができます。 下記のコードでは、as_object() を使って Value::Object バリアントとして取り出していますが、ここでも if let を使って Value::Object バリアントかどうかを判別するのでも OK です。 for game in games { for (key, value) in game.as_object().unwrap() { println!(&#34;{}: {}&#34;, key, value); } } このようにすれば、どんなフィールドを持っているか不明な JSON ファイルを処理できますが、できればデータ型をちゃんと定義して扱いたいですね。"},{url:"/p/r7sdwgy/",title:"Rust で正規表現を扱う (regex)",date:"2023-01-08T00:00:00+09:00",body:"Rust で正規表現を扱う (regex) Rust の regex クレート を使うと、正規表現を使った様々な文字列処理を行うことができます。 Rust (Cargo) プロジェクト内で以下のように実行して Cargo.toml に依存関係を追加すれば regex の使用準備は完了です。 $ cargo add regex Cargo.toml [dependencies] regex = &#34;1.7.0&#34; パターンに一致するか調べる (is_match) Regex#is_match メソッドを使うと、引数で渡した文字列に、Regex のパターンに一致する部分文字列が含まれているかを調べることができます。 use regex::Regex; let re = Regex::new(r&#34;\\d{4}-\\d{2}-\\d{2}&#34;).unwrap(); let input = &#34;Today&#39;s date is 2023-01-07.&#34;; if re.is_match(input) { println!(&#34;日付らしき文字列が見つかりました&#34;); } Regex#is_match メソッドは、パターンに一致する文字列が部分的にでも見つかれば true を返します。 文字列全体がパターンに一致するかどうかを調べたい場合は、パターンに ^（行頭）と $（行末）を含めて、r&quot;^\\d{4}-\\d{2}-\\d{2}$&quot; のようにします。 パターンに一致した位置を調べる (find, find_iter) Regex#find メソッドは、パターンに一致する部分文字列が見つかったときに regex::Match オブジェクトを返します。 見つからない場合は Option::None を返します。 Match のメソッドを使って、実際に一致した部分文字列や、その位置を取得できます。 連続する数値を探す let re = Regex::new(r&#34;\\d+&#34;).unwrap(); let input = &#34;server: ok=100 changed=50 unreachable=0 failed=3&#34;; match re.find(input) { Some(m) =&gt; println!(&#34;Found `{}` at {}-{}&#34;, m.as_str(), m.start(), m.end()), None =&gt; println!(&#34;Not found&#34;), } 実行結果 Found `100` at 11-14 Regex#find は最初に見つかった部分文字列だけを返しますが、複数回マッチさせたい場合は、代わりに Regex#find_iter メソッドで regex::Matches オブジェクトを取得します。 Matches は Iterator を実装しているので、ループ処理が可能です。 let re = Regex::new(r&#34;\\d+&#34;).unwrap(); let input = &#34;server: ok=100 changed=50 unreachable=0 failed=3&#34;; for m in re.find_iter(input) { println!(&#34;Found `{}` at {}-{}&#34;, m.as_str(), m.start(), m.end()); } 実行結果 Found `100` at 11-14 Found `50` at 23-25 Found `0` at 38-39 Found `3` at 47-48 グルーピングして部分文字列を抽出する (captures, captures_iter) Regex#captures メソッドは、パターン中の括弧 (()) でグルーピングされた部分を一度に抽出して、regex::Captures オブジェクトを返します。 Captures は Vec と同様にアクセス（[] や get）することができ、インデックス 0 には、パターンに一致した文字列全体が格納されています。 let re = Regex::new(r&#34;(\\d{4})-(\\d{2})-(\\d{2})&#34;).unwrap(); let input = &#34;Eiichi Shibusawa was born on 1840-02-13 and died on 1931-11-11.&#34;; match re.captures(input) { Some(caps) =&gt; { println!(&#34;年月日: {}&#34;, &amp;caps[0]); println!(&#34;年: {}&#34;, &amp;caps[1]); println!(&#34;月: {}&#34;, &amp;caps[2]); println!(&#34;日: {}&#34;, &amp;caps[3]); } None =&gt; println!(&#34;Not found&#34;), } 実行結果 年月日: 1840-02-13 年: 1840 月: 02 日: 13 複数回マッチさせたいときは、captures の代わりに captures_iter を使用します。 for caps in re.captures_iter(input) { println!(&#34;年: {}, 月: {}, 日: {}&#34;, &amp;caps[1], &amp;caps[2], &amp;caps[3]); } 実行結果 年: 1840, 月: 02, 日: 13 年: 1931, 月: 11, 日: 11 正規表現パターンの中で、キャプチャグループに名前を付けるには (?P&lt;name&gt;exp) というシンタックスを使用します。 let re = Regex::new(r&#34;(?P&lt;year&gt;\\d{4})-(?P&lt;month&gt;\\d{2})-(?P&lt;day&gt;\\d{2})&#34;).unwrap(); let input = &#34;Eiichi Shibusawa was born on 1840-02-13 and died on 1931-11-11.&#34;; for caps in re.captures_iter(input) { println!( &#34;年: {}, 月: {}, 日: {}&#34;, &amp;caps[&#34;year&#34;], &amp;caps[&#34;month&#34;], &amp;caps[&#34;day&#34;] ); } パターンに一致する部分を置換する (replace, replace_all) Regex#replace メソッドを使用すると、正規表現パターンに一致した部分を任意の文字列に置換できます。 最初に一致した部分だけでなく、一致した部分をすべて置換したいときは、Regex#replace_all メソッドを使用します。 let re = Regex::new(r&#34;[m|M]aku&#34;).unwrap(); let input = &#34;I am maku. You are not Maku.&#34;; let output = re.replace_all(input, &#34;####&#34;); println!(&#34;{}&#34;, output); //=&gt; &#34;I am ####. Your are not ####.&#34; パターンの中で括弧 (()) を使ってキャプチャグループを構成しておけば、実際に一致した部分文字列を、置換文字列の中で $1 や $2 で参照できます。 ハイフン (-) で繋がった単語の前後を入れ替える let re = Regex::new(r&#34;\\b(\\w+)-(\\w+)\\b&#34;).unwrap(); let input = &#34;AAA BBB-CCC DDD EEE-FFF GGG&#34;; let output = re.replace_all(input, &#34;$2-$1&#34;); println!(&#34;{}&#34;, output); //=&gt; &#34;AAA CCC-BBB DDD FFF-EEE GGG&#34;"},{url:"/p/z3gts64/",title:"Rust の Result オブジェクトを消費せずに参照する (as_ref, as_mut)",date:"2023-01-08T00:00:00+09:00",body:"Rust の Result オブジェクトを消費せずに参照する (as_ref, as_mut) 通常、Result オブジェクトを match や unwrap、ok メソッドなどでハンドルすると、その Result は消費されます（所有権が移動します）。 この振る舞いを防ぐには、as_ref や as_mut メソッドを使います。 std::result::Result のメソッド pub const fn as_ref(&amp;self) -&gt; Result&lt;&amp;T, &amp;E&gt; pub fn as_mut(&amp;mut self) -&gt; Result&lt;&amp;mut T, &amp;mut E&gt; as_ref メソッドで取得した Result オブジェクト経由で Ok/Err バリアントを参照すれば、それらのオブジェクトが消費されずに済みます。 let ok_opt = result.as_ref().ok(); // 借用 (borrow) // ... // ここでまだ result の Ok/Err は有効"},{url:"/p/ez9gpw5/",title:"Rust の Result 型エイリアスでコードを簡潔にする",date:"2023-01-08T00:00:00+09:00",body:"Rust の Result 型エイリアスでコードを簡潔にする Rust の std::io モジュールの関数は、戻り値として Result&lt;T, std::io::Error&gt; 型のオブジェクトを返すのですが、Result::Err バリアント部分の型は std::io::Error でいつも同じなので、簡潔に記述できるように、次のような std::io::Result というエイリアス型が定義されています。 std::io::Result pub type Result&lt;T&gt; = Result&lt;T, Error&gt;; // 後ろの Error は std::io::Error ここで定義している Result 型は、基礎となる std::result::Result とは別物なので注意してください。 std::io::Result という型を、std::result::Result と std::io::Error を組み合わせて定義しています。 std::io::Result を使うと、例えば、String を成功値 (Ok バリアントのフィールド) とする Result は、io::Result&lt;String&gt; と簡潔に記述することができます。 下記が具体的な使用例です。 use std::io; /// 標準入力から 1 行読み込みます fn get_string() -&gt; io::Result&lt;String&gt; { let mut buffer = String::new(); io::stdin().read_line(&amp;mut buffer)?; Ok(buffer) } 上記の get_string() 関数の戻り値の型 io::Result&lt;String&gt; は、実際には std::result::Result&lt;String, std::io::Error&gt; と同等です。 関数の処理が成功したときに値を返す必要がない（Ok バリアントのデータが必要ない）場合は、もっとシンプルに io::Result&lt;()&gt; という型になります。 fn foo() -&gt; io::Result&lt;()&gt; { // ... Ok(()) } Result&lt;()&gt; といった表現が出てきた場合、どこかにこういったエイリアス型が定義されているはずです。"},{url:"/p/8amv5eo/",title:"Rust の各種ライブラリのエラー型と Error トレイト",date:"2023-01-08T00:00:00+09:00",body:"Rust の各種ライブラリのエラー型と Error トレイト いろんな Error 実装がある Rust には、成功と失敗を表現するための標準的な型である std::result::Result 型が用意されています。 std::result::Result enum Result&lt;T, E&gt; { Ok(T), Err(E), } Result を返す関数内でエラーが発生した場合は、Err バリアントのフィールドに具体的なエラーオブジェクトを詰めて返すことになるのですが、このエラーオブジェクトの型として、各ライブラリが独自のエラー型を定義しています。 下記はその一例です。 std::io::Error std::fmt::Error std::str::Utf8Error std::num::ParseIntError 同じエラー型を使っているつもりでも、上記のように実体は異なる定義だったりするので注意してください。 Error トレイト Rust は共通のエラーインタフェースとして、次のような std::error::Error トレイト を定義しています。 前述の各種エラー型は、この Error トレイトを実装しています。 pub trait Error: Debug + Display { fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + &#39;static)&gt; { ... } fn description(&amp;self) -&gt; &amp;str { ... } fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; { ... } fn provide(&amp;&#39;a self, demand: &amp;mut Demand&lt;&#39;a&gt;) { ... } } Error は、Debug と Display も備えていることがわかります。 そのため、ほとんどのエラー型は、次のような共通のコードで解析することができます。 println!(&#34;ERROR: {}&#34;, err); // Display による簡潔なエラー情報 println!(&#34;ERROR: {:?}&#34;, err); // Debug によるデバッグ情報（技術的な情報） err.source() メソッドを使えば、そのエラー型の発生原因となったエラー型を取得できます。 戻り値は Option 型になっており、自分自身のエラー型がルートの発生源であれば、err.source() は None を返します。 ☝️ 独自のエラー型を定義する場合の推奨方法 Error トレイトを実装する std::error::Error トレイトを実装することで、共通のメソッドを使ってエラーを解析できるようになります。例えば、Error#source メソッドでエラーの発生源を調べることができます。 source の実装は、内部で保持している Error オブジェクトを返すだけで済みます。 Display と Debug を実装する これらを実装することで、クライアントがエラーの内容を出力できるようにしておきます（Error トレイトを実装するとき、自動的にこれらの実装も必要になります）。 Display の内容は、1 行で簡潔に「何が悪かったのか」分かるような表現にします。 他のレポートにネストされる形で表示されたりするので、基本的には すべて小文字 で、末尾のピリオドは付けない ようにします。 Debug が提供する情報は、Display よりも具体的になるようにします。例えば、オープンに失敗したファイルの名前や、ポート番号などの情報を含めます。多くのケースでは、#[derive(Debug)] を採用できます。 Send と Sync を実装する 可能であれば、スレッド境界を越えられるように Send と Sync を実装しておきます。エラー型がスレッドセーフになっていなければ、きっとそのクレートはマルチスレッドなコンテキストでは利用できません。 static なライフタイムを持たせる 'static にすることで、エラー情報を用意にコールスタックに乗せることができるようになります。"},{url:"/p/jku3biq/",title:"Rust でベクター型 (Vec) を扱う",date:"2023-01-07T00:00:00+09:00",body:"Rust でベクター型 (Vec) を扱う Vec 型とは？ Rust のベクター型 (Vec&lt;T&gt;) は、特定の型 (T) の要素を保持する可変長配列です。 サイズが固定であれば、通常の配列 (array) を使った方が効率的です。 次の例では、Vec::new 関数で空の Vec&lt;i32&gt; インスタンスを作成し、push メソッドにより動的に要素を追加しています。 let mut v: Vec&lt;i32&gt; = Vec::new(); // 型は推論されるので省略可能 v.push(10); v.push(20); v.push(30); println!(&#34;{:?}&#34;, v); //=&gt; [10, 20, 30] 動的に要素を追加／削除するためには、Vec 変数は mut を付けて定義しておく必要があります。 この例の場合、push メソッドの使い方から、要素の型は i32 であることが推測されるので、Vec インスタンスの作成時に型注釈を省略することができます（ほとんどのケースでは省略できます）。 let mut v = Vec::new(); Vec インスタンスの作成方法 // 空の Vec を作成する let mut v: Vec&lt;i32&gt; = Vec::new(); // vec! マクロで初期値を指定して作成する let mut v: Vec&lt;i32&gt; = vec![]; let mut v = vec![10, 20, 30]; let mut v = vec![0; 3]; //=&gt; [0, 0, 0] // Range を collect して連番の Vec を作成する let mut v: Vec&lt;i32&gt; = (0..3).collect(); //=&gt; [0, 1, 2] let mut v: Vec&lt;i32&gt; = (0..=3).collect(); //=&gt; [0, 1, 2, 3] let mut v: Vec&lt;i32&gt; = (0..=3).rev().collect(); //=&gt; [3, 2, 1, 0] Vec の要素を参照する [] で参照する [] 演算子により、指定したインデックスの要素を取得することができます。 不正なインデックスを指定すると、panic が発生してプログラムが強制終了します。 let v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; let ch1 = v[0]; // &#39;A&#39; let ch2 = v[1]; // &#39;B&#39; let ch3 = v[2]; // &#39;C&#39; let ch4 = v[3]; // panic が発生！ get で参照する get メソッドを使うと、Option 型 で要素を取得することができます。 引数で正しいインデックスを指定すると、要素をデータとして持つ Some バリアントが返され、不正なインデックスを指定すると、None バリアントが返されます。 戻り値を match や if let でハンドルすることで、安全に要素を取得することができます。 let v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; // if let を使う方法 if let Some(elem) = v.get(0) { println!(&#34;最初の要素は {} です&#34;, elem); } // match を使う方法 match v.get(10) { Some(elem) =&gt; println!(&#34;要素の値は {} です&#34;, elem), None =&gt; println!(&#34;不正なインデックスです&#34;), } Vec 要素をループ処理する for in ループで Vec に格納された要素を 1 つずつ取り出すことができます。 ループ時に所有権の移動を防ぐため、&amp; を付けて不変参照（スライス）を取得します。 let v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; for elem in &amp;v { // v.iter() でも可 // elem は &amp;char 型の不変参照 println!(&#34;{}&#34;, elem); } ループで各要素の可変参照を取得すると、要素の値を変更することができます。 let mut v = vec![100, 200, 300]; for elem in &amp;mut v { // v.iter_mut() でも可 // elem は &amp;mut i32 型の可変参照 *elem *= 2; } println!(&#34;{:?}&#34;, v); //=&gt; [200, 400, 600] enumerate と組み合わせると、インデックス番号を取得しながらループ処理できます。 let v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; for (index, elem) in v.iter().enumerate() { println!(&#34;{}:{}&#34;, index, elem); } Vec 要素を追加／削除する 末尾に要素を追加する (push) let mut v = vec![]; v.push(10); 末尾の要素を取り出して削除する (pop) let mut v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; // if let で 1 つ取り出す if let Some(elem) = v.pop() { println!(&#34;{elem}&#34;); } // while let で全部取り出す while let Some(elem) = v.pop() { println!(&#34;{elem}&#34;); } 指定したインデックスの要素を削除する (remove) let mut v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; v.remove(1); println!(&#34;{:?}&#34;, v); //=&gt; [&#39;A&#39;, &#39;C&#39;] 指定したインデックスの前に挿入する (insert) let mut v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; v.insert(1, &#39;X&#39;); println!(&#34;{:?}&#34;, v); //=&gt; [&#39;A&#39;, &#39;X&#39;, &#39;B&#39;, &#39;C&#39;] enum で複数の型の要素を保持する Vec&lt;T&gt; 型には、1 種類の型 T の要素しか格納できませんが、列挙型 (enum) の要素を保持するようにすれば、実質的に複数の型の要素を保持することができます。 Rust の列挙型は、各バリアントが異なる型のデータを持つことができるからです。 // 列挙型のバリアントで異なる型のデータを保持するようにする enum Cell { /// 整数値を保持するセル Int(i32), /// 浮動小数点数を保持するセル Float(f64), /// テキストを保持するセル Text(String), } // 各バリアントで必要なデータを保持して Vec 要素として格納する let cells = vec![ Cell::Int(7), Cell::Text(String::from(&#34;AAA&#34;)), Cell::Float(12.34), ]; // Vec の各要素（列挙型）をループ処理 for elem in &amp;cells { match elem { Cell::Int(x) =&gt; println!(&#34;Int: {}&#34;, x), Cell::Float(x) =&gt; println!(&#34;Float: {}&#34;, x), Cell::Text(x) =&gt; println!(&#34;Text: {}&#34;, x), } } その他の Vec 操作 ソートする (sort) let mut v = vec![3, 9, 1, 7, 5]; v.sort(); println!(&#34;{:?}&#34;, v); //=&gt; [1, 2, 3, 4, 5] 逆順にする (reverse) let mut v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; v.reverse(); println!(&#34;{:?}&#34;, v); //=&gt; [&#39;C&#39;, &#39;B&#39;, &#39;A&#39;] 指定したインデックスの要素を入れ替える (swap) let mut v = vec![&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; v.swap(1, 2); println!(&#34;{:?}&#34;, v); //=&gt; [&#39;A&#39;, &#39;C&#39;, &#39;B&#39;] 連続する要素を 1 つにまとめる (dedup) let mut v: Vec&lt;i32&gt; = vec![5, 5, 2, 2, 2, 1, 4, 2]; v.dedup(); println!(&#34;{:?}&#34;, v); //=&gt; [5, 2, 1, 4, 2] 条件に一致する要素だけ残して削除する (retain) 3 の倍数だけ残す let mut v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]; v.retain(|x| x % 3 == 0); println!(&#34;{:?}&#34;, v); //=&gt; [3, 6, 9] 条件に一致する要素を抽出して別の Vec として取得する (filter) 3 の倍数を抽出して Vec を作る let v1 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]; let v2: Vec&lt;i32&gt; = v1.into_iter().filter(|x| x % 3 == 0).collect(); println!(&#34;{:?}&#34;, v2); //=&gt; [3, 6, 9] ループしながら要素を編集する Vec の各要素に 100 を足すいろいろな方法です。 for-in を使う方法（インデックスでループ） let mut v = vec![1, 2, 3]; for i in 0..v.len() { v[i] += 100; } println!(&#34;{:?}&#34;, v); //=&gt; [101, 102, 103] 各要素を参照するためだけにインデックスを使うのはかっこよくないので、次のように各要素をイテレートするとよいです。 for-in &#43; &amp;mut でループ処理 for x in &amp;mut v { *x += 100; } iter_mut メソッドの戻り値 (IterMut) を使って次のように書くこともできます。 for-in &#43; iter_mut でループ処理 for x in v.iter_mut() { *x += 100; } iter_mut で取得したイテレーターの for_each メソッドを使うと、クロージャで変換処理をコンパクトに記述できます。 iter_mut &#43; for_each でループ処理 v.iter_mut().for_each(|x| *x += 100); 不変の Vec インスタンスの内容から別の Vec インスタンスを生成するには、次のようにします。 iter &#43; map &#43; collect で新規 Vec を生成 let v1: Vec&lt;i32&gt; = vec![1, 2, 3]; let v2: Vec&lt;i32&gt; = v1.iter().map(|x| x + 100).collect();"},{url:"/p/ffqyajs/",title:"Rust で列挙型 (enum) を定義して match、if let で照合する",date:"2023-01-06T00:00:00+09:00",body:"Rust で列挙型 (enum) を定義して match、if let で照合する 列挙型は、あらかじ定義された値（列挙子やバリアントと呼びます）の内、いずれかの値をとることができる型です。 Rust の列挙型は、各バリアントに任意の値を保持することができるので非常に強力です。 列挙型は構造体 (struct) と同様に、impl ブロックを使ったメソッド定義を行えます。 列挙型の基本 列挙型は enum キーワードを使って定義します。 列挙型がとりうる値のことを バリアント (variant) と呼びます。 次の Fruit 列挙型は、バリアントとして Apple、Banana、Orange を持ちます。 enum 型を定義する // Fruit 列挙型を定義する #[derive(Debug)] enum Fruit { Apple, Banana, Orange, } // Fruit インスタンスを生成する let f = Fruit::Apple; println!(&#34;{:?}&#34;, f); //=&gt; Apple println!(&#34;{}&#34;, f as i32); //=&gt; 0 上記のように列挙型の定義時に #[derive(Debug)] 属性を付けておくと、println! マクロで列挙型変数の値を {:?} で参照できるようになります。 あるいは、as i32 を使って、バリアントが持つ 内部的な整数値を取り出す こともできます。 match による分岐 match 構文によりパターンマッチにより、列挙型変数の値に基づいて分岐処理を行うことができます。 次の例では 3 つのパターンで分岐していますが、これらのパターンごとの記述を Rust では アーム (arm) と呼びます。 各アームはカンマ (,) で区切って記述します。 match による分岐 let f = Fruit::Banana; match f { Fruit::Apple =&gt; println!(&#34;I like apples&#34;), Fruit::Banana =&gt; println!(&#34;I like bananas&#34;), Fruit::Orange =&gt; println!(&#34;I like oranges&#34;), } Rust の match は式として扱われる ので、評価結果を変数などで受け取ることができます。 let message = match f { Fruit::Apple =&gt; &#34;I like apples&#34;, Fruit::Banana =&gt; &#34;I like bananas&#34;, Fruit::Orange =&gt; &#34;I like oranges&#34;, }; println!(&#34;{}&#34;, message); ファットアロー (=&gt;) の右側に複数の文を並べたいときは、全体を {} で囲んでブロック化します。 閉じ括弧の後ろにカンマを付ける必要はありません。 match f { Fruit::Apple =&gt; { let msg = &#34;I like apples&#34;; println!(&#34;{}&#34;, msg); } Fruit::Banana =&gt; println!(&#34;I like bananas&#34;), Fruit::Orange =&gt; println!(&#34;I like oranges&#34;), } match で複数のバリアントや残り全てにマッチさせる match ブロックの中で、複数のバリアントで共通の処理を行いたい場合は、バリアントをパイプ記号 (|) で列挙します。 また、「その他のバリアントすべて」にマッチさせたいときは、アンダースコア (_) 記号を使います（これは、C/C++ や Java の default ケースに相当するものです）。 アンダースコアはすべての値に一致してしまうため、最後のアームとして配置する必要があります。 // トランプのスート（マーク）を表現する列挙型 enum Suit { Clubs, Spades, Diamonds, Hearts } let s = Suit::Clubs; match s { Suit::Clubs | Suit::Spades =&gt; println!(&#34;Its color is black&#34;), _ =&gt; println!(&#34;Its color is red&#34;), } 未使用バリアントの警告を抑制する アプリケーションの中で、使用していないバリアントがあると、Rust コンパイラーは次のような警告を出します。 warning: variants `Apple` and `Orange` are never constructed これは、デフォルトで #[warn(dead_code)] 属性が設定されており、未使用コードが警告されるようになっているからです。 未使用コードの警告を抑制するには、列挙型の定義時に、#[allow(dead_code)] 属性を追加します。 #[allow(dead_code)] enum Fruit { Apple, Banana, Orange } // Banana しか使っていないけど警告は出なくなる let f = Fruit::Banana; バリアントに値を持たせる enum 型の各バリアントは、任意の型のデータを保持することができます。 しかも バリアントごとに異なる型のデータを持つことができる ので、C/C++ の union（共用体）のような感覚で使用することができます。 enum Message { Quit, // データを持たない Move { x: i32, y: i32 }, // 無名の構造体データを持つ Write(String), // 1 つの String を持つ（タプル構造体） ChangeColor(i32, i32, i32), // 3 つの整数値を持つ（タプル構造体） } let m = Message::Quit; let m = Message::Move { x: 5, y: 2 }; let m = Message::Write(String::from(&#34;Hello&#34;)); let m = Message::ChangeColor(255, 255, 0); match による分岐時に、各バリアントに格納されているデータを取り出すことができます。 match m { Message::Quit =&gt; println!(&#34;Quit&#34;), Message::Move { x, y } =&gt; println!(&#34;Move to: {}, {}&#34;, x, y), Message::Write(s) =&gt; println!(&#34;Write: {}&#34;, s), Message::ChangeColor(r, g, b) =&gt; println!(&#34;Change color to: {}, {}, {}&#34;, r, g, b), } 上記の例では、各バリアントが持つデータを変数で取り出していますが、変数の代わりにリテラル値を指定すると、そのリテラル値に一致するデータが格納されている場合の処理を記述することができます。 また、格納されているデータを使用しない場合は、変数名の代わりにアンダースコア (_) を指定します。 match m { Message::Move { x: 0, y: 0 } =&gt; println!(&#34;Move to the origin&#34;), Message::Move { x, y } =&gt; println!(&#34;Move to {}, {}&#34;, x, y), Message::Write(_) =&gt; println!(&#34;Something written&#34;), Message::ChangeColor(r, _, _) =&gt; println!(&#34;Red value is: {}&#34;, r), _ =&gt; (), // Nothing to do } 列挙値を if let で処理する 列挙型のすべてのバリアントを包括的に処理する必要がなく、特定のバリアントのみ興味がある場合は、match の代わりに if let 構文でパターンマッチを行うことができます。 マッチングのルールは match と同様です。 次の例では、Color 列挙型の変数の値が赤色を示す値かどうかを調べています。 #[allow(dead_code)] enum Color { Red, Blue, Rgb(u8, u8, u8), // タプルデータを持つ Hsv { h: u8, s: u8, v: u8 }, // 構造体データを持つ } let c = Color::Red; if let Color::Red = c { println!(&#34;赤色です&#34;); } let c = Color::Rgb(255, 0, 0); if let Color::Rgb(255, 0, 0) = c { println!(&#34;これも赤色です&#34;); } let c = Color::Hsv { h: 0, s: 100, v: 100 }; if let Color::Hsv { h: 0, s: 100, v: 100 } = c { println!(&#34;またまたこれも赤色です&#34;); } Color::Rgb や Color::Hsv のように、データを持つバリアントの場合は、if let で分岐処理するときに同時にそのデータを取り出すことができます。 このあたりの振る舞いも、match によるパターンマッチと同様です。 let c = Color::Rgb(255, 0, 0); if let Color::Rgb(r, g, b) = c { println!(&#34;r={}, g={}, b={}&#34;, r, g, b); } let c = Color::Hsv { h: 0, s: 100, v: 100 }; if let Color::Hsv { h, s, v } = c { println!(&#34;h={}, s={}, v={}&#34;, h, s, v); } バリアントが持つデータのうち、参照する必要がないフィールドがある場合は、変数名の代わりにアンダースコア (_) を配置しておきます。 let c = Color::Rgb(255, 255, 0); if let Color::Rgb(255, g, _) = c { // タプルの最初の値が 255 の場合のみ、2 番目の値を変数 g で取り出す println!(&#34;g={}&#34;, g); } let c = Color::Hsv { h: 0, s: 100, v: 100 }; if let Color::Hsv { h: 0, s, v: _ } = c { // フィールド h の値が 0 の場合のみ、フィールド s の値を取り出す println!(&#34;s={}&#34;, s); } 列挙型にメソッドを定義する 列挙型にも 構造体 (struct) と同様に、メソッドを定義することができます。 次の例では、WebEvent 列挙型に dump メソッドを定義しています。 メソッドの中では、自身の列挙型名 (WebEvent) の代わりに Self というエイリアスを使用できます。 enum 型にメソッドを追加する enum WebEvent { PageLoad, KeyPress(char), Click { x: u32, y: u32 }, } impl WebEvent { fn dump(&amp;self) { match self { Self::PageLoad =&gt; println!(&#34;page loaded&#34;), Self::KeyPress(c) =&gt; println!(&#34;pressed &#39;{}&#39;&#34;, c), Self::Click { x, y } =&gt; println!(&#34;clicked at x={}, y={}&#34;, x, y), } } } let e = WebEvent::Click { x: 5, y: 7 }; e.dump(); //=&gt; &#34;clicked at x=5, y=7&#34; パラメーターのルールも構造体と同様で、第 1 引数に &amp;self があれば、呼び出し時にインスタンスが必要な「メソッド」となり、&amp;self がなければ、呼び出し時にインスタンスが必要ない「関連関数」となります。 それ以降のパラメーターは、メソッド（または関連関数）の呼び出し時に渡した引数を受け取るために使用します。 パラメーター有りのメソッドを追加する enum Operation { Add, Subtract, } impl Operation { /// バリアントに応じた演算を行う fn run(&amp;self, a: i32, b: i32) -&gt; i32 { return match self { Self::Add =&gt; a + b, Self::Subtract =&gt; a - b, }; } } let op = Operation::Add; println!(&#34;{}&#34;, op.run(1, 2)); //=&gt; 3 バリアントが内部的に持つ整数値を取り出す C/C++ と同様に、Rust の列挙型のバリアントも、内部的には 0 始まりの整数値で管理されています。 この値は、as i32 で取り出すことができます。 enum Color { Red, Green, Blue, } println!(&#34;{}&#34;, Color::Red as i32); //=&gt; 0 println!(&#34;{}&#34;, Color::Green as i32); //=&gt; 1 println!(&#34;{}&#34;, Color::Blue as i32); //=&gt; 2 let red = Color::Red; let green = Color::Green; let blue = Color::Blue; println!(&#34;{}&#34;, red as i32); //=&gt; 0 println!(&#34;{}&#34;, green as i32); //=&gt; 1 println!(&#34;{}&#34;, blue as i32); //=&gt; 2 C/C++ と同様、この整数値は任意の値にオーバーライドすることができます。 enum Color { Red = 0xff0000, Green = 0x00ff00, Blue = 0x0000ff, } println!(&#34;{:08x}&#34;, Color::Red as i32); //=&gt; 00ff0000 println!(&#34;{:08x}&#34;, Color::Green as i32); //=&gt; 0000ff00 println!(&#34;{:08x}&#34;, Color::Blue as i32); //=&gt; 000000ff"},{url:"/p/9m6m5m3/",title:"Rust の Option 型の基本 ─ 値の有無を表現する型",date:"2023-01-06T00:00:00+09:00",body:"Rust の Option 型の基本 ─ 値の有無を表現する型 Option 型とは？ 多くのオブジェクト指向言語には、オブジェクトが存在しないことを示す null という値が用意されていますが、Rust には null は存在しません。 Rust の設計者は、null という概念が不具合の温床となっていると判断しました。 その代わりに、Rust には std::option::Option という組み込みの列挙型 (enum) が用意されており、ある値が存在しているか を表現できるようになっています。 そして、この設計は null を使った表現よりも柔軟で、かつ安全です。 Option 型の定義はとてもシンプルで、次のような感じの列挙型 (enum) として定義されています。 Option 型の定義 pub enum Option&lt;T&gt; { Some(T), // T 型の何らかの値 None, // 値が存在しない } Some バリアントが「（任意の型 T の）値が存在する」ことを示し、None バリアントが「値が存在しない」ことを示します。 つまり、Some と None で値の有無を表現しつつ、値が存在する場合はその値を Some バリアントから取り出せるようになっています。 例えば、値が存在しないかもしれない String 型（他の言語では Nullable な String 型）は、Option&lt;String&gt; 型として表現することができ、その Some 値と None 値を次のように生成できます。 let some_val: Option&lt;String&gt; = Some(String::from(&#34;Hello&#34;)); let none_val: Option&lt;String&gt; = None; // 他の言語では null や nil に相当 こんな感じで別名を付けると理解しやすいでしょうか。 type NullableString = Option&lt;String&gt;; let some_val: NullableString = Some(String::from(&#34;Hello&#34;)); let none_val: NullableString = None; Option は単なる列挙型なので、本来はバリアントを参照するときに Option::Some や Option::None と記述しなければならないはずですが、デフォルトで Some や None と短く記述できるようになっています。 Option 型は頻繁に参照するので、そのシンボルが Rust の初期化処理 (prelude) でロードされるようになっており、このような省略記述が可能になっています。 Option 型の値を match で処理する 下記の関数は、引数で受け取った文字列を数値に変換し、Option&lt;i32&gt; 型の値として返しています。 つまり、Some&lt;i32&gt; あるいは None というバリアントを返します。 数値としてパースできない文字列が渡されたときは、None を返すようにしています（Rust 以外の言語であれば、null を返したり、例外を発生させたりするところです）。 /// 数値っぽい文字列を数値に変換します。 fn parse_num_str(s: &amp;str) -&gt; Option&lt;i32&gt; { match s { &#34;one&#34; | &#34;一&#34; =&gt; Some(1), &#34;two&#34; | &#34;二&#34; =&gt; Some(2), &#34;three&#34; | &#34;三&#34; =&gt; Some(3), _ =&gt; None, } } 戻り値の Option&lt;i32&gt; は列挙型の値なので、次のように match で分岐処理しつつ、Some バリアントに含まれている i32 値を取り出すことができます（参考: 列挙型 (enum) ）。 let num_opt = parse_num_str(&#34;三&#34;); match num_opt { Some(num) =&gt; println!(&#34;The number is {}&#34;, num), None =&gt; println!(&#34;Could not parse&#34;), } Option 型の値を if let で処理する Option 型の値として Some バリアントが返された場合のみ何らかの処理をしたいときは、match の代わりに if let 構文を使うとシンプルに記述できます。 Some が返された場合のみ処理する let num_opt = parse_num_str(&#34;三&#34;); if let Some(num) = num_opt { // ここで num は i32 型の値になっている println!(&#34;The number is {}&#34;, num); } match 構文と同様に、特定のリテラル値に一致するかどうかを調べることもできます。 let num_opt = parse_num_str(&#34;三&#34;); if let Some(3) = num_opt { println!(&#34;Found: three&#34;); } None かどうかをチェックする (is_none) Option 列挙型の値が None バリアントかどうかを確認したいときは、is_none() メソッドを使うのがシンプルです。 値が存在しないときに早期リターンしたいケースで使えるかもしれません。 逆に Some バリアントかどうかを調べる is_some() も用意されていますが、あまり使うことはないでしょう。 let num_opt = parse_num_str(&#34;ほげ&#34;); if num_opt.is_none() { eprintln!(&#34;Parse error&#34;); return; } // もちろん次のように書いても OK // if let None = num_opt { ... } Option 列挙型には、Some バリアントが保持するデータをダイレクトに取り出すための unwrap というメソッドが用意されていますが、このメソッドは None バリアントに対して呼び出すと panic が発生するので危険です。 ただ、上記のように None のケースを排除できていれば、安全に unwrap することができます。 // Some バリアントであることがわかっていれば unwrap で安全に値を取り出せる let num = num.unwrap(); println!(&#34;The number is {}&#34;, num); None だった場合に代替値を使う (unwrap_or, unwrap_or_else) Some バリアントが保持するデータを取り出す unwrap メソッドは、None バリアントに対して呼び出すと panic が発生してしまう危険なメソッドですが、代わりに unwrap_or メソッドを使うと、None だった場合に代替値を返すことができます。 次の例では、get_user_id 関数が返す Option 値が None だった場合に、代替値として -1 を使うようにしています。 fn get_user_id(name: &amp;str) -&gt; Option&lt;i32&gt; { match name { &#34;root&#34; =&gt; Some(0), &#34;maku&#34; =&gt; Some(1), _ =&gt; None, } } let opt_id = get_user_id(&#34;unknown&#34;); let id = opt_id.unwrap_or(-1); // opt_id が None のとき -1 になる println!(&#34;{}&#34;, id); //=&gt; -1 unwrap_or メソッドで指定する代替値は、メソッドの引数として渡すことになるので、そこに何らかの式を指定すると必ず評価されてしまうことに注意してください。 // get_default_id 関数は必ず呼び出されてしまう let id = opt_id.unwrap_or(get_default_id()); この振る舞いを防ぐには、unwrap_or の代わりに unwrap_or_else メソッドを使用して、None 時に呼び出す関数を渡すようにします。 次の例では、関数名を指定する代わりに匿名関数（ラムダ式）を渡しています。 // opt_id が None のときのみ get_default_id 関数が呼び出される let id = opt_id.unwrap_or_else(|| get_default_id()); 似たようなメソッドに、unwrap_or_default がありますが、こちらは代替値としてその型のデフォルト値（i32 なら 0、String なら &quot;&quot;、Vec なら vec![]）を返します。 場面によっては便利かもしれませんが、若干意図が伝わりにくい気がします。 let opt_id = get_user_id(&#34;unknown&#34;); let id = opt_id.unwrap_or_default(); //=&gt; 0 unwrap_or 系のメソッドを使ったコードは、次のような if let でも同様のことを行えることに気がつくかもしれません。 ただ、このようなコードは可読性が悪いので、unwrap_or 系のメソッドをうまく使いこなしたいところです。 let id = if let Some(id) = opt_id { id } else { -1 }; 結局 Option 型の値はどうやってハンドルすればよいの？ 以上のように、Option 型の値はいろいろなハンドル方法がありますが、どのようにハンドルするかは、次のような優先度で考慮すればよいと思います。 match で Some と None の両方のケースをハンドルする match は Option のバリアントが包括的に処理されているかをコンパイル時に確認してくれるので安全です。 if let でハンドルする 特定の Some 値にしか興味がない場合は、if let でその値を取り出すことを考えます。ただし、想定外のバリアント値を見過ごすことがないように、else ブロックを配置しておくと安全です。 unwrap_or 系のメソッドでハンドルする データが存在しなかった場合にデフォルト値で済ませられる場合は、unwrap_or 系メソッドを使うと簡潔なコードになります。 その他のメソッドでハンドルする 十分に注意して Option 型のその他のメソッドを使用します。特に、panic を発生させる unwrap() メソッドなどは、プロダクトコードでは使わないようにするのが無難です。"},{url:"/p/wu6gqz9/",title:"Rust でコマンドライン引数を扱う (1) std::env::args",date:"2023-01-04T00:00:00+09:00",body:"Rust でコマンドライン引数を扱う (1) std::env::args Rust プログラムに渡されたコマンドライン引数を扱う方法として、std::env::args 関数 を使う方法を説明します。 この関数は標準で呼び出すことができるのでお手軽ですが、リッチなコマンドライン引数を提供したいときは、clap クレートを使う方法 がおすすめです。 std::env::args の基本 std::env::args 関数は、イテレート可能な std::env::Args オブジェクトを返します。 1 番目の要素には実行したファイルの名前（相対パス）が含まれており、2 番目以降にコマンドライン引数が格納されています。 src/main.rs use std::env; fn main() { // std::env::Args を取得してループ処理 for arg in env::args() { println!(&#34;{arg}&#34;); // arg は単純な String 型 } } cargo run でコマンドを実行する場合、プログラムに渡すコマンドライン引数は、次のように -- の後ろに指定します。 実行例 $ cargo -q run -- --aaa 100 200 target/debug/sample --aaa 100 200 -- というセパレーターを入れないと、--aaa オプションが、cargo 側のオプションとして渡されてしまうので注意してください。 Iterator トレイトの nth メソッド を使って、インデックス指定で参照することもできます。 ユーザーがコマンドライン引数を指定しなかった場合は、Option::None が返されることに注意してください。 let first_arg: String = std::env::args().nth(1).unwrap(); let second_arg: String = std::env::args().nth(2).unwrap(); ベクター型で処理する (collect) std::env::args 関数の戻り値 Args は、次のように Vec&lt;String&gt; 型に変換してしまうと扱いやすいです。 use std::env; fn main() { let args: Vec&lt;String&gt; = env::args().collect(); // すべての内容をダンプ println!(&#34;{:?}&#34;, args); // 各パートを取り出す println!(&#34;The number of arguments is {}&#34;, args.len()); println!(&#34;My path is {}&#34;, args[0]); println!(&#34;The remaining arguments are {:?}&#34;, &amp;args[1..]); // 必須の引数を表現したい場合 if args.len() &lt; 2 { eprintln!(&#34;The dir_name argument is required&#34;); std::process::exit(1); } let dir_name = args.get(1).unwrap(); println!(&#34;dir_name = {}&#34;, dir_name); } 次のステップ Rust でコマンドライン引数を扱う (2) clap クレート"},{url:"/p/owbo2dp/",title:"Rust で自作したプログラムをシステムにインストールする (cargo install)",date:"2023-01-02T00:00:00+09:00",body:"Rust で自作したプログラムをシステムにインストールする (cargo install) 何をするか？ Rust で自作したコマンドラインツール (CLI) は、プロジェクトのワーキングディレクトリ以下で cargo run で実行できますが、毎回ディレクトリを移動するのは面倒です。 cargo install コマンド で、パスの通ったディレクトリに実行ファイルをインストールすれば、どのディレクトリからでもコマンドを実行できるようになります。 自作コマンドをインストールする (cargo install) Rust のプロジェクトがなければ、次のように適当に作ってください。 ここでは、hello-rust という名前のプログラムを作成することにします。 $ cargo new ~/hello-rust $ cd ~/hello-rust ローカルで開発している Rust プログラムをシステムにインストールするには、次のように cargo install コマンドを実行します。 このとき、--path オプションで Cargo.toml ファイルがあるディレクトリを指定する必要があります。 自動的にリリースモードでビルド (cargo build -r) してからインストールしてくれるので、あらかじめビルドしておく必要はありません。 $ cargo install --path . Installing hello-rust v0.1.0 (/Users/maku/hello-rust) Compiling hello-rust v0.1.0 (/Users/maku/hello-rust) Finished release [optimized] target(s) in 0.35s Installing /Users/maku/.cargo/bin/hello-rust Installed package `hello-rust v0.1.0 (/Users/maku/hello-rust)` (executable `hello-rust`) 生成された実行ファイル (hello-rust) は、~/.cargo/bin ディレクトリにインストールされます（インストール先は --root オプションで変更できます）。 このディレクトリにパスが通っていれば、次のようにコマンド実行できるようになっているはずです。 $ hello-rust Hello, world! 自作コマンドをアンインストールする (cargo unintall) cargo install でインストールした自作コマンドをアンインストールするには、Cargo.toml ファイルのあるディレクトリで、cargo uninstall コマンドを実行します。 $ cd ~/hello-rust $ cargo uninstall Removing /Users/maku/.cargo/bin/hello-rust インストールされたプログラムは、~/.cargo/bin ディレクトリ以下に 1 つのバイナリファイルとして存在しているので、単純にそのファイルを削除するだけでも OK です。 $ rm ~/.cargo/bin/hello-rust"},{url:"/p/36hr2bj/",title:"ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf)",date:"2023-01-01T00:00:00+09:00",body:"ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf) Path と PathBuf Rust には、ファイルやディレクトリのパス情報を扱うための std::path::Path struct が用意されています。 Path の mutable 版（可変）である、std::path::PathBuf struct を使うと、パス情報を動的に組み立てていくことができます。 次の例では、パス形式の文字列リテラルから Path と PathBuf のインスタンスを生成しています。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(&#34;/dir1/dir2/file.txt&#34;); let path_buf = PathBuf::from(&#34;/dir1/dir2/file.txt&#34;); println!(&#34;{:?}&#34;, path); //=&gt; &#34;/dir1/dir2/file.txt&#34; println!(&#34;{:?}&#34;, path_buf); //=&gt; &#34;/dir1/dir2/file.txt&#34; } ☝️ パスを文字列で取り出す Path や PathBuf インスタンスから、パスを表現する文字列を取得したければ次のように記述できます。 let path = Path::new(&#34;/aaa/bbb/ccc&#34;); let s = path.to_string_lossy(); assert_eq!(s, &#34;/aaa/bbb/ccc&#34;); ただ、実際のプロダクトコード内でパス情報を扱うときは、Path オブジェクトのまま扱った方が都合がよいので、実際にこのような処理が必要になることはあまりありません。 例えば、ファイルを扱う std::fs モジュールの各種関数は、パスを表す文字列と Path インスタンスのどちらも扱えるようになっています。 パスを分解する Path や PathBuf の、次のようなメソッドを使うことで、/dir1/dir2/file.txt のようなパス文字列から、親ディレクトリ名や、ベースネーム、拡張子名などを抽出することができます。 メソッド 戻り値の型 意味 Path#parent() Option&lt;&amp;Path&gt; 親ディレクトリ Path#file_name() Option&lt;&amp;OsStr&gt; ファイル名 Path#file_stem() Option&lt;&amp;OsStr&gt; ベースネーム（ファイル名から拡張子を除いたもの） Path#extension() Option&lt;&amp;OsStr&gt; 拡張子 例: フルパスの場合 use std::ffi::OsStr; use std::path::Path; fn main() { let path = Path::new(&#34;/dir1/dir2/file.txt&#34;); assert_eq!(path.parent(), Some(Path::new(&#34;/dir1/dir2&#34;))); assert_eq!(path.file_name(), Some(OsStr::new(&#34;file.txt&#34;))); assert_eq!(path.file_stem(), Some(OsStr::new(&#34;file&#34;))); assert_eq!(path.extension(), Some(OsStr::new(&#34;txt&#34;))); } 拡張子が存在しない場合、Path#extension() の戻り値は（Option enum の）None になります。 例: ファイル名だけの場合 use std::ffi::OsStr; use std::path::Path; fn main() { let path = Path::new(&#34;file&#34;); assert_eq!(path.parent(), Some(Path::new(&#34;&#34;))); assert_eq!(path.file_name(), Some(OsStr::new(&#34;file&#34;))); assert_eq!(path.file_stem(), Some(OsStr::new(&#34;file&#34;))); assert_eq!(path.extension(), None); } パスを構築する パスを結合する PathBuf struct は、パスを動的に組み立てていくための push、pop、set_file_name、set_extension といったメソッドを備えています。 PathBuf::push メソッドを連続して使うと、各階層のディレクトリ名、ファイル名を末尾に繋げていくことができます。 use std::path::PathBuf; fn main() { let mut path = PathBuf::new(); path.push(&#34;/&#34;); path.push(&#34;aaa&#34;); path.push(&#34;bbb&#34;); path.push(&#34;ccc.txt&#34;); assert_eq!(path, PathBuf::from(&#34;/aaa/bbb/ccc.txt&#34;)); } Path struct は immutable（不変）なので、自分自身を変更する push メソッドは備えていませんが、代わりに、パス結合後の結果を戻り値として返す Path#join メソッドを備えています。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(&#34;/aaa/bbb&#34;); let path_buf = path.join(&#34;ccc.txt&#34;); assert_eq!(path_buf, PathBuf::from(&#34;/aaa/bbb/ccc.txt&#34;)); } Path から PathBuf を生成する (to_path_buf) Path#to_path_buf メソッドを使うと、同一のパスを表す PathBuf を生成することができます。 次の例では、Path から PathBuf を生成し、さまざまな編集メソッドを使って新しいパス情報を構築しています。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(&#34;/aaa/bbb/ccc.txt&#34;); let mut path_buf = path.to_path_buf(); // PathBuf を生成 path_buf.pop(); // 親ディレクトリへ (&#34;/aaa/bbb&#34;) path_buf.pop(); // 親ディレクトリへ (&#34;/aaa&#34;) path_buf.push(&#34;xxx&#34;); // パスを結合 (&#34;/aaa/xxx&#34;) path_buf.push(&#34;yyy&#34;); // パスを結合 (&#34;/aaa/xxx/yyy&#34;) path_buf.set_extension(&#34;txt&#34;); // 拡張子をセット (&#34;/aaa/xxx/yyy.txt&#34;) assert_eq!(path_buf, PathBuf::from(&#34;/aaa/xxx/yyy.txt&#34;)); } ファイル名／拡張子を置換する (PathBuf::set_file_name, Path::with_file_name) パスのファイル名部分だけを変更したいときは、PathBuf::set_file_name メソッドを使います。 このメソッドは、パスの末尾がファイル名であるか、ディレクトリ名であるかは考慮しないので注意してください。 use std::path::PathBuf; fn main() { let mut path_buf = PathBuf::from(&#34;/aaa/bbb/ccc&#34;); path_buf.set_file_name(&#34;XXX.txt&#34;); assert_eq!(path_buf, PathBuf::from(&#34;/aaa/bbb/XXX.txt&#34;)); } ファイル名部分の置換には、Path::with_file_name を使うこともできます。 Path インスタンスは immutable（不変）なので、置換結果は戻り値として返されます。 use std::path::{Path, PathBuf}; fn main() { let path = Path::new(&#34;/aaa/bbb/ccc&#34;); let path_buf = path.with_file_name(&#34;XXX.txt&#34;); assert_eq!(path_buf, PathBuf::from(&#34;/aaa/bbb/XXX.txt&#34;)); } 同様に使えるメソッドとして、拡張子部分だけを置換する PathBuf::set_extension や Path::with_extension も用意されています。"},{url:"/p/fbkt3ah/",title:"ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf)",date:"2023-01-01T00:00:00+09:00",body:"ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf) Path や PathBuf 構造体が備えている is_file メソッドや is_dir メソッドを使うと、そのそのパスに対応するファイルやディレクトリが存在するかを調べることができます。 他にも、パスが絶対パスか相対パスかを調べるメソッドなどが用意されています。 メソッド名 戻り値の型 意味 Path::is_file() bool そのパスが示す ファイルが存在するか を調べます。シンボリックリンクの場合は、リンク先のファイルが存在するかを調べます。ファイルのアクセス権がない場合は、false を返します。 Path::is_dir() bool そのパスが示す ディレクトリが存在するか を調べます。シンボリックリンクの場合は、リンク先のディレクトリが存在するかを調べます。ディレクトリのアクセス権がない場合は、false を返します。 Path::is_symlink() bool そのパスが示す シンボリックファイルが存在するか を調べます。リンク先のファイルやディレクトリが存在するかまではチェックしません（シンボリックリンクが壊れていても true を返します）。 Path::is_absolute() bool そのパスが 絶対パスか を調べます。 Path::is_relative() bool そのパスが 相対パスか を調べます。 Path::has_root() bool そのパスが ルートセパレーターを持つか を調べます（ほぼ is_absolute と同義）。 use std::path::Path; fn main() { // 存在するファイル（相対パス指定）の場合 let path = Path::new(&#34;Cargo.toml&#34;); assert_eq!(path.is_file(), true); assert_eq!(path.is_dir(), false); assert_eq!(path.is_symlink(), false); assert_eq!(path.is_absolute(), false); assert_eq!(path.is_relative(), true); assert_eq!(path.has_root(), false); // 存在しないファイル（絶対パス指定）の場合 let path = Path::new(&#34;/nonexisting/file/path&#34;); assert_eq!(path.is_file(), false); assert_eq!(path.is_dir(), false); assert_eq!(path.is_symlink(), false); assert_eq!(path.is_absolute(), true); assert_eq!(path.is_relative(), false); assert_eq!(path.has_root(), true); }"},{url:"/p/zju5eow/",title:"Rust でディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all)",date:"2022-12-30T00:00:00+09:00",body:"Rust でディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all) ディレクトリを作成する (create_dir) Rust でディレクトリを作成するには、std::fs::create_dir 関数 を使用します。 カレントディレクトリに aaa ディレクトリを作成 use std::fs; fn main() -&gt; std::io::Result&lt;()&gt; { fs::create_dir(&#34;aaa&#34;)?; Ok(()) } すでに同名のディレクトリが存在している場合など、ディレクトリを作成できない場合はエラーが発生します。 use std::fs; fn main() { match fs::create_dir(&#34;aaa&#34;) { Ok(_) =&gt; println!(&#34;ディレクトリを作成しました&#34;), Err(_) =&gt; eprintln!(&#34;ディレクトリを作成できませんでした&#34;), } } 複数階層のディレクトリを作成する (create_dir_all) 深い階層のディレクトリを一気に作成するには、create_dir の代わりに create_dir_all 関数 を使用します。 このメソッドは、すでに存在しているディレクトリを指定してもエラーにならない ので、create_dir より使い勝手はよいかもしれません。 aaa/bbb/ccc ディレクトリが存在しなければ作成する use std::fs; fn main() { fs::create_dir_all(&#34;aaa/bbb/ccc&#34;).unwrap(); // 成功する前提で unwrap } ディレクトリを削除する (remove_dir) 既存の（空の）ディレクトリを削除するには、std::fs::remove_dir 関数を使用します。 この関数は、Linux の rmdir コマンドと同様、空のディレクトリしか削除できないことに注意してください（DirectoryNotEmpty エラーが発生します）。 存在しないディレクトリを削除しようとした場合もエラーが発生します。 ディレクトリ aaa を削除する use std::fs; fn main() -&gt; std::io::Result&lt;()&gt; { fs::remove_dir(&#34;aaa&#34;)?; Ok(()) } 空でないディレクトリを削除する (remove_dir_all) ディレクトリ内に含まれているファイルやディレクトリも含めて丸ごと削除してしまうには、remove_dir 関数の代わりに remove_dir_all 関数 を使用します。 この関数も、存在しないディレクトリを指定するとエラーになります。 次の例では、Path#is_dir 関数でディレクトリの存在を確認してから削除しています。 ディレクトリ aaa を中身も含めて削除する use std::{fs, path::Path}; fn main() { let dir_name = &#34;aaa&#34;; if Path::new(dir_name).is_dir() { // ディレクトリが存在するなら丸ごと削除 match fs::remove_dir_all(dir_name) { Ok(_) =&gt; println!(&#34;Directory `{}` has been removed&#34;, dir_name), Err(e) =&gt; eprintln!(&#34;Failed to remove {}: {}&#34;, dir_name, e), } } else { // ディレクトリは存在しなかった println!(&#34;Directory {} does not exist&#34;, dir_name); } } 参考 ファイルやディレクトリの名前を変更する (std::fs::rename)"},{url:"/p/2kv6eub/",title:"Rust でディレクトリ内のファイルを列挙する (fs::read_dir)",date:"2022-12-30T00:00:00+09:00",body:"Rust でディレクトリ内のファイルを列挙する (fs::read_dir) read_dir 関数の基本 Rust の標準モジュール std::fs の read_dir 関数 を使うと、ディレクトリ内のファイルやディレクトリを列挙することができます。 std::fs::read_dir 関数 pub fn read_dir&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;ReadDir&gt; 列挙結果には、カレントディレクトリ (.) や親ディレクトリ (..) は含まれないので、自然な列挙が可能です。 src/main.rs use std::fs; fn main() { let entries = fs::read_dir(&#34;.&#34;).unwrap(); // ReadDir を取得 // ループで Result&lt;DieEntry, Error&gt; をひとつずつ処理 for entry in entries { // DirEntry#file_name() でファイル名（ディレクトリ名）を取得できる println!(&#34;{:?}&#34;, entry.unwrap().file_name()); } } 実行結果 &#34;Cargo.toml&#34; &#34;target&#34; &#34;Cargo.lock&#34; &#34;.gitignore&#34; &#34;.git&#34; &#34;src&#34; エラーチェックする 上記ではコードを簡素化するために Result#unwrap メソッドを使っていますが、万が一 Err 値が返された場合は panic が発生してしまうので、プロダクトコードでは unwrap メソッドは使うべきではありません。 Result が Ok 値を持っているかを調べつつ、その値を取り出すには、次のように if let 構文を使用できます。 他の実装例 use std::fs; fn main() { if let Ok(entries) = fs::read_dir(&#34;.&#34;) { for entry in entries { if let Ok(entry) = entry { println!(&#34;{:?}&#34;, entry.file_name()); } } } } Path インスタンスを取得する DirEntry#file_name() でファイル名 (OsString) を取得する代わりに、DirEntry#path() を使って PathBuf オブジェクトを取得できます。 PathBuf は、パス情報を扱ういろいろなメソッドを提供しています。 let path = entry.path(); // PathBuf を取得 println!(&#34;file_name = {:?}&#34;, entry.file_name()); println!(&#34;is_file = {}&#34;, path.is_file()); println!(&#34;is_dir = {}&#34;, path.is_dir()); println!(&#34;is_absolute = {}&#34;, path.is_absolute()); 参考: ファイルやディレクトリの存在を調べる (std::io::Path, PathBuf) 参考: ファイルやディレクトリのパス文字列を構築／分割する (std::path::Path, PathBuf) ディレクトリ内のファイルリストを Vec で取得する 前述のように、Rust でディレクトリ内のファイルを列挙しようとすうと、少し面倒なコードになります。 下記のユーティリティ関数 read_dir_entries を使うと、指定したディレクトリに含まれているファイルやディレクトリの名前 (PathBuf) を Vec 形式でまとめて取得できます。 use std::{ fs, io, path::{Path, PathBuf}, }; /** 指定したディレクトリ内のすべてのファイル（ディレクトリ）のパス情報を取得します。 */ fn read_dir_entries&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;PathBuf&gt;&gt; { let mut entries = fs::read_dir(path)? .map(|res| res.map(|e| e.path())) .collect::&lt;Result&lt;Vec&lt;_&gt;, io::Error&gt;&gt;()?; entries.sort(); Ok(entries) } fn main() { match read_dir_entries(&#34;.&#34;) { Ok(entries) =&gt; println!(&#34;{:?}&#34;, entries), Err(e) =&gt; eprintln!(&#34;ERROR: {}&#34;, e), } } 実行結果 [&#34;./.git&#34;, &#34;./.gitignore&#34;, &#34;./Cargo.lock&#34;, &#34;./Cargo.toml&#34;, &#34;./src&#34;, &#34;./target&#34;]"},{url:"/p/raiqzbr/",title:"Rust でファイルやディレクトリの名前を変更（移動）する (std::fs::rename)",date:"2022-12-30T00:00:00+09:00",body:"Rust でファイルやディレクトリの名前を変更（移動）する (std::fs::rename) Rust でファイルやディレクトリの名前を変更するには、std::fs::rename 関数 を使用します。 rename 関数は、ファイルの移動にも使用できます。 ファイルの名前を変更する a.txt を b.txt にリネームする use std::{fs, io}; fn main() -&gt; io::Result&lt;()&gt; { fs::rename(&#34;a.txt&#34;, &#34;b.txt&#34;)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイル名の代わりにディレクトリ名を指定すれば、ディレクトリ名を変更することができます。 rename 関数には Path インスタンスを渡すこともできます。 use std::{fs, io, path::Path}; fn main() -&gt; io::Result&lt;()&gt; { let path_from = Path::new(&#34;a.txt&#34;); let path_to = Path::new(&#34;b.txt&#34;); fs::rename(&amp;path_from, &amp;path_to)?; // 失敗時は io::Error を伝搬 Ok(()) } ファイルを移動する rename 関数の移動先パスとして、ディレクトリ階層を含むファイルパスを指定すれば、ファイルをそのディレクトリに移動することができます。 このとき、ファイル名を変更すれば、移動とファイル名の変更が同時に行われます（逆に言うと、移動だけしたいのであれば、同じファイル名を指定する必要があります）。 a.txt を aaa/bbb/ccc.txt として移動する use std::{fs, io}; fn main() -&gt; io::Result&lt;()&gt; { // 移動先のディレクトリが存在しなければ先に作成しておく fs::create_dir_all(&#34;aaa/bbb&#34;)?; // ファイルを移動＆リネームする fs::rename(&#34;a.txt&#34;, &#34;aaa/bbb/ccc.txt&#34;)?; Ok(()) } 移動先のディレクトリはあらかじめ存在していなければいけないので、上記では create_dir_all 関数で先にディレクトリを用意しています（すでに存在していれば無視されます）。 参考: ディレクトリを作成・削除する (std::fs::create_dir, create_dir_all, remove_dir, remove_dir_all) 次の move_file ユーティリティ関数は、移動先のディレクトリが存在していないときに自動的に作成してくれます。 use std::{fs, io, path::Path}; /// from が示すファイル／ディレクトリを、to のパスへ移動（とリネーム）します。 /// to には移動後のファイル／ディレクトリ名を含んでいる必要があります。 /// to が親ディレクトリを持つ場合、そのディレクトリを先に作成します。 fn move_file(from: &amp;Path, to: &amp;Path) -&gt; io::Result&lt;()&gt; { // 移動先のディレクトリが存在しなければ先に作成しておく if let Some(parent) = to.parent() { fs::create_dir_all(parent)?; } // ファイルを移動＆リネームする fs::rename(&amp;from, &amp;to)?; Ok(()) } fn main() { let path_from = Path::new(&#34;a.txt&#34;); let path_to = Path::new(&#34;aaa/bbb/ccc.txt&#34;); match move_file(&amp;path_from, &amp;path_to) { Ok(_) =&gt; println!(&#34;Success!&#34;), Err(err) =&gt; eprintln!(&#34;ERROR: {}&#34;, err), } }"},{url:"/p/eamw7fp/",title:"Rust でキーボードからの入力を取得する",date:"2022-12-29T00:00:00+09:00",body:"Rust でキーボードからの入力を取得する std::io::Stdin の read_line 関数を使うと、ユーザーのキーボード入力を読み取ることができます。 main.rs use std::io::{self, Write}; fn main() { print!(&#34;Please input your name: &#34;); // プロンプトを表示して入力を促す io::stdout().flush().unwrap(); // 上記出力を強制フラッシュ let mut line = String::new(); // 入力用のバッファ io::stdin() .read_line(&amp;mut line) // キーボードからの入力（標準入力）を 1 行読み込む .expect(&#34;Failed to read line&#34;); // 戻り値の Result が Err の場合は終了 println!(&#34;Hi, {}!&#34;, line.trim_end()); // 末尾の改行コードは trim_end で削除可能 } 実行例 Please input your name: Maku Hi, Maku!"},{url:"/p/m9vdtaq/",title:"Rust で型の名前を取得する (std::any::type_name)",date:"2022-12-29T00:00:00+09:00",body:"Rust で型の名前を取得する (std::any::type_name) std::any::type_name 関数を使うと、型パラメーターで指定した型の名前を、文字列表現で取得することができます。 次の例では、String 型の型名を取得しています。 let name = std::any::type_name::&lt;String&gt;(); println!(&#34;{}&#34;, name) //=&gt; alloc::string::String 返される文字列の形式は明確には仕様化されておらず、Rust のバージョンごとに変わったりするので、この文字列に依存したビジネスロジックは記述すべきではない とされています（診断用にのみ使用できます）。 次のようなユーティリティ関数を作成すれば、任意のリテラル値や変数の型を簡単に調べることができます。 fn print_type_of&lt;T&gt;(_: T) { println!(&#34;{}&#34;, std::any::type_name::&lt;T&gt;()) } fn main() { print_type_of(0); //=&gt; i32 print_type_of(0b1111); //=&gt; i32 print_type_of(0i8); //=&gt; i8 print_type_of(0u64); //=&gt; u64 print_type_of(0.1); //=&gt; f64 print_type_of(0.1e5); //=&gt; f64 print_type_of(0.1f32); //=&gt; f32 print_type_of(0.1e5f32); //=&gt; f32 print_type_of(&#39;a&#39;); //=&gt; char print_type_of(&#34;Hello&#34;); //=&gt; &amp;str }"},{url:"/p/us2ahpw/",title:"Rust の Result 型の基本 ─ 成功と失敗を表現する型",date:"2022-12-29T00:00:00+09:00",body:"Rust の Result 型の基本 ─ 成功と失敗を表現する型 Result 型とは？ Rust の標準ライブラリには、std::result::Result という列挙型 (enum) が用意されており、何らかの処理が「成功」したこと、あるいは「失敗」したことを表現するために使われます（仕組み的には、値の「有無」を表現する Option 型 と同様です）。 他の言語では、例外 (exception) の仕組みでエラーの発生を表現したりしますが、Rust では Result 型を使ってエラーを表現します（Rust には例外の仕組みが存在しません）。 Result 列挙型のバリアントとしては、次のように Ok と Err だけが定義されており、それぞれが何らかの処理の「成功」と「失敗」を表現します。 Result 型の定義 enum Result&lt;T, E&gt; { Ok(T), // T 型の成功値 Err(E), // E 型の失敗値 } 成功と失敗を表すだけであれば、bool 型だけで表現できそうですが、Result 型は Ok と Err というバリアントが任意の値を持つことができるようになっているので、成功した場合の結果や、失敗した場合の理由を表現することができます。 また、何らかのメソッドが Result 型を返すとき、その値を呼び出し側で利用していないと、コンパイラが警告を出してくれるため、エラーのハンドル忘れを防ぐ効果 があります。 Result 型の概念は、他のモダンな言語でも採用されています（例: Kotlin の Result 型）。 これらのシンボルはデフォルトでインポートされるようになっており、Result、Ok、Err と記述するだけで使用することができます（Result::Ok や Result::Err のように記述する必要はありません）。 Result を処理する Result インスタンスから Ok バリアントや Err バリアントの情報を取り出すには、match 式や if let 式を使います。 以下のサンプルコードでは、str::parse メソッドで、数値を含む文字列をパースして i32 値に変換しています。 パースに成功すると Ok バリアントが返されるので、そこからパース結果を取り出すことができます。 パースに失敗すると Err バリアントが返されるので、そこからエラー情報（ParseIntError など）を取り出すことができます。 match 式 Result 列挙型のバリアント（Ok と Err）を漏れなくハンドルしたいときは、match 式を使用します。 let result = &#34;123&#34;.parse::&lt;i32&gt;(); match result { Ok(num) =&gt; println!(&#34;数値 {} としてパースできました&#34;, num), Err(err) =&gt; println!(&#34;パースできませんでした: {}&#34;, err), } if let 式 処理の成功時に Ok バリアントが持つ値を取り出すだけでよければ、if let 構文を使うと簡潔に記述できます。 let result = &#34;123&#34;.parse::&lt;i32&gt;(); if let Ok(num) = result { println!(&#34;数値 {} としてパースできました&#34;, num); } is_ok / is_err メソッド 処理に成功したか、失敗したかだけを確認するには、is_ok や is_err メソッドを使用します。 if result.is_ok() { println!(&#34;成功しました&#34;); } if result.is_err() { println!(&#34;失敗しました&#34;); } unwrap 系メソッド Ok バリアントが含むデータをダイレクトに取り出したいときは、unwrap 系のメソッドを使用します。 ただし、unwrap メソッドは Result の値が Err のときに呼び出すとパニックが発生するので、ほとんどのケースでは使用を避けるべきです（即席の使い捨てプログラムを作るときは便利ですが）。 let result = &#34;ほげ&#34;.parse::&lt;i32&gt;(); // 成功時は i32 値を返し、失敗時はパニックが発生する let num = result.unwrap(); // unwrap の代わりに expect を使うと、パニック時のメッセージを指定できる let num = result.expect(&#34;Failed to parse&#34;); unwrap の代わりに unwrap_or メソッドを使用すると、Err のときに使用する代替値を指定できます。 こちらはパニックが発生しないので安全です。 let num = result.unwrap_or(0); // パースに失敗したときは 0 が返される let num = result.unwrap_or_default(); // 同上（整数型のデフォルト値 0 が使われる） 代替値の生成にコストがかかる場合は、unwrap_or_else メソッドを使って代替値を生成する関数を渡すようにします。 この関数は Err 時にしか呼び出されません。 次の例では、クロージャの形で代替値の生成処理を指定しています。 // パースに失敗したときは代替値生成用の関数を呼び出す let num = result.unwrap_or_else(|_| create_default_value()); // 代替値を生成する関数（本当はコストのかかる処理という想定） fn create_default_value() -&gt; i32 { 999 } クロージャにはエラー値（この場合は ParseIntError）が渡されますが、今回は使わないのでアンダースコア (_) で受け取って無視しています。 Result 型を返す関数の実装例 下記の divide 関数は、整数値の割り算を行う関数です。 計算に成功すると、その結果 (i32) を含む Result::Ok を返し、計算に失敗すると、エラーメッセージ (&amp;str) を含む Result::Err を返します。 fn divide(numerator: i32, denominator: i32) -&gt; Result&lt;i32, &amp;&#39;static str&gt; { if denominator == 0 { return Err(&#34;0 で割ることはできません&#34;); } Ok(numerator / denominator) } match divide(5, 0) { Ok(num) =&gt; println!(&#34;割り算の結果: {}&#34;, num), Err(err) =&gt; println!(&#34;エラー発生: {}&#34;, err), } Result::Ok バリアントに値を設定する必要がないときは、値がないことを示す空タプル () を使って、Ok(()) を返すようにします。 main() 関数の実装でよく見ると思います。 fn perform(action: &amp;str) -&gt; Result&lt;(), &amp;&#39;static str&gt; { if action == &#34;dance&#34; { Ok(()) } else { Err(&#34;実行できませんでした&#34;) } } let result = perform(&#34;sing&#34;); match result { Ok(_) =&gt; println!(&#34;実行完了&#34;), Err(err) =&gt; println!(&#34;エラー: {}&#34;, err), } Result 型でエラーのハンドル忘れを防ぐことができるのはなぜか？ Result 型の定義には、次のように #[must_use] アノテーションが付いているため、何らかのメソッドが戻り値として Result を返したとき、その値を無視できないようになっています（参考: Result 型のコード）。 Result の実装（抜粋） // ... #[must_use = &#34;this `Result` may be an `Err` variant, which should be handled&#34;] pub enum Result&lt;T, E&gt; { // ... } 何らかのメソッドが返した Result を、match や if let で「消費」することで、この警告は表示されなくなります。 参考: The must_use attribute - The Rust Reference"},{url:"/p/96o6xfv/",title:"Rust プログラミングを始める（rustc と cargo コマンド）",date:"2022-12-11T00:00:00+09:00",body:"Rust プログラミングを始める（rustc と cargo コマンド） Rust 関連コマンドのインストール Rust のインストール Rust コンパイラ (rustc) や Rust 用のパッケージマネージャー (cargo) は、下記の公式サイトの手順で簡単にインストールできます。 推奨されている方法でインストールすると、Rust 関連のコマンドをアップデートするための rustup コマンドもインストールされます。 公式サイト: Rust をインストール - Rustプログラミング言語 Rust のインストール方法の例（Linux/macOS の場合） $ curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 標準構成でインストールすると、Rust 関連の各コマンドが ~/.cargo/bin/ ディレクトリにインストールされます。 Rust 関連コマンドの一覧 $ ls ~/.cargo/bin cargo* clippy-driver* rust-lldb* rustup* cargo-clippy* rls* rustc* cargo-fmt* rust-gdb* rustdoc* cargo-miri* rust-gdbgui* rustfmt* Rust のバージョンアップ 一度 rustup コマンドのインストールが済んでしまえば、上記の Rust 関連コマンド（Rust ツールチェイン）は次のようにまとめてアップデートできます。 Rust ツールチェインの更新 $ rustup update Rust のアンインストール Rust 関連コマンドを削除したいときも、rustup コマンドを使用します。 次のようにすると、rustup コマンドを含む、すべての Rust 関連コマンドがアンインストールされます（$HOME/.cargo/bin ディレクトリも削除されます）。 Rust ツールチェインのアンインストール $ rustup self uninstall rustc コマンドで Rust コードをビルドする 次の main.rs ファイルは、Rust 言語の Hello World プログラムです。 main.rs fn main() { println!(&#34;Hello, world!&#34;); } この main.rs ファイルをコンパイルするには、rustc コマンドを使用します。 デフォルトでは、.rs ファイルのベース名と同じ名前の実行ファイルが生成されます。 Rust コード (.rs) のコンパイル $ rustc main.rs $ ./main Hello, world! -o オプションで、生成する実行ファイル名を指定することもできます。 $ rustc -o hello main.rc $ ./hello Hello, world! 普段の開発では rustc コマンドを直接使うことは少なく、より包括的なパッケージングツールである cargo コマンドを使うのが一般的です。 cargo コマンドで Rust プロジェクトを作成する Rust のデフォルトのビルドシステムである cargo コマンドを使用すると、依存ライブラリの管理や、プロジェクトのパッケージング処理を行うことができます。 Rust プロジェクトの開発は、通常、この cargo コマンドを使って進めることになります。 プロジェクトの作成 (cargo new/init) cargo で新しいプロジェクト (cargo package) を作成するには、cargo new コマンドを使用します（既存のディレクトリを使う場合は、cargo init コマンドを使用します）。 Rust プロジェクトの新規作成 $ cargo new hello Created binary (application) `hello` package このように実行すると、新規プロジェクト用の hello ディレクトリが生成されます。 この中には、Rust プロジェクトの設定ファイルである Cargo.toml や、プログラムのエントリポイントとなる src/main.rs ファイルが含まれています。 また、Git リポジトリとしての初期化も済んでおり、すぐに git commit していけるようになっています。 hello/ ├── .git/ ├── .gitignore ├── Cargo.toml └── src/ └── main.rs ビルドと実行 (cargo run/build) プロジェクトのディレクトリ内で、cargo run コマンドを実行することで、プログラムを実行することができます。 プロジェクトのビルドと実行 $ cargo run Finished dev [unoptimized + debuginfo] target(s) in 0.00s Running `target/debug/hello` Hello, world! cargo のログ出力を抑制するには、-q (--quite) オプションを追加します。 $ cargo run -q Hello, world! ログ出力から分かるように、内部的にビルドされてできたプログラムは、target ディレクトリ以下に配置されます。 デフォルトではデバッグモードでビルドされるので、target/debug/&lt;実行ファイル名&gt; というパスで実行ファイルが生成されます。 -r (--release) オプションを付けてリリースモードでビルドすると、target/release/&lt;実行ファイル名&gt; というパスに生成されます。 ビルド関連の cargo サブコマンドには、次のようなものがあります。 コマンド 説明 cargo clean target ディレクトリの削除 cargo build ビルド（debug モード） cargo build -r ビルド（release モード） cargo run ビルド＆実行（debug モード） cargo run -r ビルド＆実行（release モード） これで、Rust でプログラミングを始める準備が整いました！ ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/iudtbr8/",title:"GitHub Actions のワークフローをローカルで実行する (act)",date:"2022-12-09T00:00:00+09:00",body:"GitHub Actions のワークフローをローカルで実行する (act) act とは？ act コマンド は、Casey Lee 氏 (@nektos) が作成した、GitHub Actions ワークフローをローカル実行するためのコマンドです。 nektos/act: Run your GitHub Actions locally 🚀 通常、GitHub Actions のワークフローを実行するには、ワークフローファイル (.github/workflows/*.yml) を作成して、GitHub へコミット＆プッシュする必要がありますが、act コマンドを使うと、ローカルのワークフローファイルをそのまま実行できます。 ローカルでの実行を主目的とした、タスクランナーとしての利用も可能です。 act コマンドは、GitHub Blog でも紹介されています。 Docker と act のインストール act はワークフローの実行環境として Docker コンテナを利用するので、Docker 環境はあらかじめインストールしておいてください。 Docker Desktop をインストールすれば、簡単に Docker 環境が整います。 Docker Desktop act コマンドは Go 言語で実装されており、各 OS 用の実行ファイルが提供されています。 下記の公式ページの説明に従って、OS ごとのパッケージ管理コマンドでインストールしてしまうのが簡単です。 nektos/act: Run your GitHub Actions locally 🚀 例えば、macOS であれば brew install act、Windows であれば choco install act-cli などでインストールできます。 インストールが終わって、次のように実行できるようになっていれば準備完了です。 $ act --version act version 0.2.34 act でワークフローを実行する ワークフローファイル (.yml) の準備 ワークフローファイルがないと始まらないので、まずは GitHub で管理されているリポジトリにワークフローファイルを用意します。 既存のワークフローファイルがなければ、次のように適当に作成してください。 .github/workflows/*.yml というパスで配置すれば、YAML ファイル名は何でも構いません。 .github/workflows/sample.yml name: GitHub Actions Demo run-name: ${{ github.actor }} is testing out GitHub Actions 🚀 on: [push] jobs: Explore-GitHub-Actions: runs-on: ubuntu-latest steps: - run: echo &#34;🎉 The job was automatically triggered by a ${{ github.event_name }} event.&#34; - run: echo &#34;🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!&#34; - run: echo &#34;🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.&#34; - name: Check out repository code uses: actions/checkout@v3 - run: echo &#34;💡 The ${{ github.repository }} repository has been cloned to the runner.&#34; - run: echo &#34;🖥️ The workflow is now ready to test your code on the runner.&#34; - name: List files in the repository run: ls ${{ github.workspace }} - run: echo &#34;🍏 This job&#39;s status is ${{ job.status }}.&#34; お試し用の GitHub リポジトリの準備が面倒な場合は、下記リポジトリを clone してください。 $ git clone https://github.com/maku77/p-iudtbr8 act コマンドの実行 act コマンドは、デフォルトで push イベントを発生させる ので、上記のワークフロー定義のように、on: [push] トリガーが設定されたものが実行されます。 act の初回起動時には、実行環境とする Docker イメージの選択肢が表示されます。 今回のような簡単な処理であれば、一番小さなイメージ (Micro) を選択しておけば OK です。 $ act ? Please choose the default image you want to use with act: - Large size image: +20GB Docker image, includes almost all tools used on GitHub Actions (IMPORTANT: currently only ubuntu-18.04 platform is available) - Medium size image: ~500MB, includes only necessary tools to bootstrap actions and aims to be compatible with all actions - Micro size image: &lt;200MB, contains only NodeJS required to bootstrap actions, doesn&#39;t work with all actions Default image and other options can be changed manually in ~/.actrc (please refer to https://github.com/nektos/act#configuration for additional information about file structure) [Use arrows to move, type to filter, ? for more help] Large Medium &gt; Micro 実行用の Docker イメージのダウンロードが完了すると、ワークフロー内のジョブが実行されます。 act コマンドの出力例 [GitHub Actions Demo/Explore-GitHub-Actions] 🚀 Start image=node:16-buster-slim [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker pull image=node:16-buster-slim platform= username= forcePull=false [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker create image=node:16-buster-slim platform= entrypoint=[&#34;/usr/bin/tail&#34; &#34;-f&#34; &#34;/dev/null&#34;] cmd=[] [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker run image=node:16-buster-slim platform= entrypoint=[&#34;/usr/bin/tail&#34; &#34;-f&#34; &#34;/dev/null&#34;] cmd=[] [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo &#34;🎉 The job was automatically triggered by a push event.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/0] user= workdir= | 🎉 The job was automatically triggered by a push event. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo &#34;🎉 The job was automatically triggered by a push event.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo &#34;🐧 This job is now running on a Linux server hosted by GitHub!&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/1] user= workdir= | 🐧 This job is now running on a Linux server hosted by GitHub! [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo &#34;🐧 This job is now running on a Linux server hosted by GitHub!&#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo &#34;🔎 The name of your branch is refs/heads/main and your repository is maku77/p-iudtbr8.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/2] user= workdir= | 🔎 The name of your branch is refs/heads/main and your repository is maku77/p-iudtbr8. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo &#34;🔎 The name of your branch is refs/heads/main and your repository is maku77/p-iudtbr8.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main Check out repository code [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker cp src=../mnt/d/y/gitwork/maku77/p-iudtbr8/. dst=/mnt/d/y/gitwork/maku77/p-iudtbr8 [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main Check out repository code [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo &#34;💡 The maku77/p-iudtbr8 repository has been cloned to the runner.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/4] user= workdir= | 💡 The maku77/p-iudtbr8 repository has been cloned to the runner. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo &#34;💡 The maku77/p-iudtbr8 repository has been cloned to the runner.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo &#34;🖥️ The workflow is now ready to test your code on the runner.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/5] user= workdir= | 🖥️ The workflow is now ready to test your code on the runner. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo &#34;🖥️ The workflow is now ready to test your code on the runner.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main List files in the repository [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/6] user= workdir= | README.md [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main List files in the repository [GitHub Actions Demo/Explore-GitHub-Actions] ⭐ Run Main echo &#34;🍏 This job&#39;s status is success.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🐳 docker exec cmd=[bash --noprofile --norc -e -o pipefail /var/run/act/workflow/7] user= workdir= | 🍏 This job&#39;s status is success. [GitHub Actions Demo/Explore-GitHub-Actions] ✅ Success - Main echo &#34;🍏 This job&#39;s status is success.&#34; [GitHub Actions Demo/Explore-GitHub-Actions] 🏁 Job succeeded 何らかのコマンドが足りないというエラーが出たら、Docker の実行イメージを変えて実行してみてください。 使用する Docker イメージを変更する act のワークフロー実行に使用する Docker イメージを切り替えたくなったら、公式サイトの configuration の項目 に従って設定してください。 例えば、Medium Docker Image (ubuntu-latest) を使いたくなった場合は、カレントディレクトリ、あるいはホームディレクトリに .actrc というファイルを作成して、次のように記述すれば OK です。 これは、ワークフローファイルの中で、runs-on: ubuntu-latest と指定されたときに、具体的にどの Docker イメージを使用するかを示しています。 ~/.actrc -P ubuntu-latest=catthehacker/ubuntu:act-latest このファイルは、act コマンドに渡すデフォルトのオプションを列挙したものです。 act コマンド実行時に次のように直接オプション指定しても OK です。 $ act -P ubuntu-latest=catthehacker/ubuntu:act-latest いろんな使い方 push 以外のイベントを発生させる $ act pull_request act コマンドは、最初の引数でイベント名を受け取ります（デフォルトは pull）。 例えば上記のように実行すると、on: [pull_request] と定義されているワークフローが実行されます。 ワークフローの一覧 $ act --list Stage Job ID Job name Workflow name Workflow file Events 0 log-the-inputs log-the-inputs dispatch.yml dispatch.yml workflow_dispatch 0 specific_review_requested specific_review_requested pull.yml pull.yml pull_request 0 Explore-GitHub-Actions Explore-GitHub-Actions GitHub Actions Demo sample.yml push act コマンドの -l (--list) オプションで、ワークフローの定義一覧を表示できます（要するに、.github/workflows 以下の .yml ファイルの内容の一覧です）。 トリガーとなるイベントの一覧もここで確認できます。 シークレットを渡す $ act -s MY_SECRET1=value1 -s MY_SECRET2=value2 $ act --secret-file my.secrets GitHub 上で設定するシークレット変数をシミュレートするために、-s (--secret) オプションを使用できます。 あるいは、--secret-file オプションで、キー＆バリュー情報を列挙したシークレットファイルを読み込むことができます（このオプションを指定しなくても、act はデフォルトで .secrets という名前のファイルを読み込みます）。 シークレットファイルのフォーマットは .env と同等です。 my.secrets # この行はコメント MY_SECRET1=value1 MY_SECRET2=value2"},{url:"/linux/",title:"Linux/Shell",date:"2022-12-05T00:00:00+09:00",body:"Linux/Shell シェルスクリプト / Bash プログラミング シェルスクリプトのコーディングスタイル 変数 変数の基本 定数を定義する (readonly) 配列を扱う 数値を扱う 数値変数を加算／減算する ランダムな数値を取得する ($RANDOM) シェル変数/環境変数がセットされているか調べる Bash の変数展開機能を活用する（文字列の置換、デフォルト値など） 制御構文 if-else による分岐処理 case による分岐処理 for/while によるループ処理 ループ内での複数の出力をまとめてリダイレクト、パイプ処理する 起動時の処理 コマンドライン引数 コマンドライン引数の基本 ($1, $@, $*) コマンドライン引数の数が正しいかチェックする ($#) 名前付きのコマンドラインオプションを扱う (getopts) ある環境変数が定義されているかチェックする (test -z) ある外部コマンドが使用できるかチェックする (type -P) シェルスクリプトを実行したユーザの名前を調べる ($USER) 関数 関数を定義する (function) 関数へパラメータを渡す ($1, $2, $3) 関数内でローカル変数を扱う (local) 関数から戻り値を返す ($?) 関数のデフォルト引数を定義する パス 絶対パスと相対パスの変換 (basename, dirname) カレントディレクトリや指定したファイルの絶対パスを取得する 実行中のシェルスクリプトのファイル名を取得する ($0) 実行中のシェルスクリプトがあるディレクトリの絶対パスを取得する 実行中のシェルスクリプトがあるディレクトリに移動する 入出力 (I/O) echo の結果を標準エラー出力 (stderr) に出力する (1&gt;&amp;2) echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ echo で出力する文字の色を変える ユーザ入力を取得する (read) ディレクトリ内のファイルを順に処理する (for, while) 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read) テキストファイルを 1 行ずつ読み込む (read) expect で外部コマンドの出力を待機する 日時 今日の日付から YYYYMMDD のような文字列を作成する (date) トラブルシューティング 改行コードが原因の関数定義の syntax error Linux コマンド全般 コマンド ファイルやディレクトリを検索する (find, grep) ディレクトリ内のファイルを zip ファイルにバックアップする rsync コマンドでディレクトリを同期する 行番号付きでテキストファイルの内容を出力する (cat -n, cat -b) あるファイルがテキストファイルかどうか調べる (file) リダイレクトとパイプ処理のまとめ Linux でリダイレクトによってファイルが上書きされてしまうのを防ぐ (set -o noclobber) Windows で Linux 系のコマンドを使用できるようにする (Gow) curl で HTTP のレスポンスヘッダのみを確認する例 ls コマンドが使えないときに echo コマンドで代用する ls コマンドでパターンに一致するファイルだけを列挙する システム／管理 Linux カーネル／OS のバージョンを調べる bash のバージョンを調べる ($BASH_VERSION) Linux の各種 ID（プロセス ID やユーザ ID など）についてのメモ カーネルに渡されたパラメータを調べる (/proc/cmdline) Linux のメモリ情報を調べるコマンド NTP でシステム時刻を設定する Deep Learning や仮想通貨のマイニング時に CPU 使用率が 100% になってしまうのを防ぐ (cpulimit) Linux システムコールを使用して core dump を吐かないようにする (setrlimit) D-Bus D-Bus 全般 D-Bus 関連用語 D-Bus 関連リンクと関連ツール GDBus と dbus-glib dbus-glib dbus-glib 開発用ライブラリをインストールする dbus-glib で method call を実装する（ヘッダファイルの生成） dbus-glib で method call を実装する（サーバ側の実装） dbus-glib で method call を実装する（クライアント側の実装） GDBubs GDBus で簡単な P2P（クライアント＆サーバ）アプリを実装する GDBus サーバから signal を発行する GDBus でバイナリデータ（バイト配列）を受け取る方法 glib の GVariant を使ってみる D-Bus Java D-Bus Java をインストールする D-Bus Java で Session bus に接続してメソッドを呼び出す D-Bus Java で P2P D-Bus サーバに接続してメソッドを呼び出すサンプル dbus-python dbus-python の公式サンプルコード dbus-python で Session bus を使用するサーバ＆クライアントを実装する（単純なメソッドの実装） dbus-python で Session bus を使用するサーバ＆クライアントを実装する（シグナルの実装） dbus-python で D-Bus の P2P クライアントを実装する"},{url:"/p/2fyizgw/",title:"Linuxシェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts)",date:"2022-12-05T00:00:00+09:00",body:"Linuxシェルスクリプト: 名前付きのコマンドラインオプションを扱う (getopts) Bash 組み込みの getopts コマンドを使用すると、シェルスクリプトに渡されたコマンドラインオプション (-a など）を解析することができます。 getopts は 1 文字のオプションしか扱えないことに注意してください。 引数なしのオプション 下記は getopts の基本的な使用例です。 getopts のオプション文字列として abc を指定することにより、このシェルスクリプトで、-a、-b、-c という 3 種類のオプションを受け取れるようになっています。 ユーザーが指定したオプションが、1 文字ずつ opt 変数に格納されるので、その値で case による分岐処理を行います。 sample.sh #!/bin/bash while getopts &#39;abc&#39; opt; do case &#34;${opt}&#34; in a) echo &#34;オプション -a を指定しました&#34; ;; b) echo &#34;オプション -b を指定しました&#34; ;; c) echo &#34;オプション -c を指定しました&#34; ;; esac done 実行例 $ ./sample.sh -a オプション -a を指定しました $ ./sample.sh -a -c オプション -a を指定しました オプション -c を指定しました $ ./sample.sh -x ./sample.sh: illegal option -- x 最後の実行例から分かるように、getopts は定義されていないオプション (-x) を指定したときに、自動的にエラーメッセージ (illegal option) を出力します。 このエラー出力を抑制するには、次のように、オプション文字列の先頭に : を付け、:abc のように指定します。 不正なオプションが指定された場合は、opt 変数の値が ? になるので、自分でエラー処理を行うことも可能です。 sample.sh #!/bin/bash while getopts &#39;:abc&#39; opt; do case &#34;${opt}&#34; in a) echo &#34;オプション -a を指定しました&#34; ;; b) echo &#34;オプション -b を指定しました&#34; ;; c) echo &#34;オプション -c を指定しました&#34; ;; ?) echo &#34;不正なオプション&#34; &gt;&amp;2 ;; esac done ちなみに、echo の末尾の &gt;&amp;2 は、標準エラー出力への出力を意味しています（参考: echo の結果を標準エラー出力 (stderr) に出力する）。 引数ありのオプション getopts では、次のような引数ありのオプションを扱うこともできます。 $ ./sample -b 100 -c 200 引数ありのオプションにしたいときは、オプション文字列の対象文字の後ろに : を付けます。 次の例では、-b オプションと -c オプションに引数を指定できるようにしています。 オプションに指定した引数の値は、$OPTARG 変数で参照できます。 sample.sh #!/bin/bash while getopts &#39;ab:c:&#39; flag; do case &#34;${flag}&#34; in a) echo &#34;オプション -a を指定しました&#34; ;; b) echo &#34;オプション -b を指定しました（引数=${OPTARG}）&#34; ;; c) echo &#34;オプション -c を指定しました（引数=${OPTARG}）&#34; ;; esac done 実行例 $ ./sample.sh -a -b 100 オプション -a を指定しました オプション -b を指定しました（引数=100） なお、引数ありのオプション（b: など）にした場合は、引数を指定しなかった場合はエラーになります。 $ ./sample.sh -b ./sample.sh: option requires an argument -- b getopts の実践的な使用例 sample.sh #!/bin/bash usage() { cat 1&gt;&amp;2 &lt;&lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .) -v Use verbose output EOF exit -1 } outdir=&#39;.&#39; verbose=&#39;&#39; while getopts &#39;:d:vh&#39; opt; do case &#34;${opt}&#34; in d) outdir=&#34;${OPTARG}&#34; ;; v) verbose=&#39;true&#39; ;; h) usage ;; ?) usage ;; esac done if [ ! -z &#34;$verbose&#34; ]; then echo &#34;Verbose mode&#34; fi echo Output directory is &#34;${outdir}&#34; 実行例 $ ./sample.sh Output directory is . $ ./sample.sh -d out -v Verbose mode Output directory is out $ ./sample.sh -h Usage: sample.sh [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .) -v Use verbose output"},{url:"/p/q2k3j2h/",title:"Linuxメモ: echo の結果を標準エラー出力 (stderr) に出力する",date:"2022-12-05T00:00:00+09:00",body:"Linuxメモ: echo の結果を標準エラー出力 (stderr) に出力する 標準エラー出力への出力 echo コマンドの出力結果を、デフォルトの標準出力ではなく、標準エラー出力に出力するには、末尾で 1&gt;&amp;2 のようにリダイレクトします（&gt;&amp;2 という省略形でも OK）。 #!/bin/bash echo &#34;Hello World&#34; 1&gt;&amp;2 このように出力先を制御したプログラムは、実行結果をリダイレクトしたり、パイプ接続した場合の振る舞いに影響してきます。 sample.sh #!/bin/bash echo AAA echo BBB 1&gt;&amp;2 echo CCC 上記のプログラムの出力結果を out.txt というファイルにリダイレクトすると、ターミナル上には BBB という標準エラー出力のみが表示されます。 実行例 $ ./sample.sh &gt; out.txt BBB out.txt の内容 AAA CCC cat の場合 cat コマンドによるヒアドキュメントでも、標準エラー出力に出力できます。 cat 1&gt;&amp;2 &lt;&lt;EOF AAA AAA AAA BBB BBB BBB CCC CCC CCC EOF シェルスクリプトの Usage 出力などに便利です。 usage() { cat 1&gt;&amp;2 &lt;&lt;EOF Usage: $(basename $0) [OPTIONS] Options: -h Display this message -d DIR Output directory (default: .) -v Use verbose output EOF exit -1 } その他の出力先制御 コマンドの出力をさまざまな形でリダイレクトすることで、本来の標準出力、標準エラー出力への出力を次のように振り分けることができます。 コマンド形式 標準出力 標準エラー出力 command STDOUT STDERR command 1&gt;&amp;2 command &gt;&amp;2 STDERR STDERR command 2&gt;&amp;1 STDOUT STDOUT command &gt; /dev/null ─ STDERR command &gt; /dev/null 2&gt;&amp;1 ─ ─ command &gt; file FILE STDERR command &gt; file 2&gt;&amp;1 FILE FILE command 2&gt;&amp;1 &gt; file FILE STDOUT STDOUT: 標準出力 / STDERR: 標準エラー出力 / FILE: ファイル / ─: 出力されない 例えば echo Hello とすると、通常は Hello が標準出力に出力されますが、echo Hello 1&gt;&amp;2 とすると、標準出力が標準エラー出力に切り替わって Hello が標準エラー出力に出力されるようになります。 読み解き方: &amp;1 &hellip; 現在、標準出力 (1) に割り当てられている出力先 &amp;2 &hellip; 現在、標準エラー出力 (2) に割り当てられている出力先 1&gt;&amp;2 &hellip; 標準出力 (1) の出力先を &amp;2 に切り替える 2&gt;&amp;1 &hellip; 標準エラー出力 (2) の出力先を &amp;1 に切り替える &gt; file &hellip; 標準出力 (1) の出力先を file に切り替える"},{url:"/p/f2eggno/",title:"GitHub Actions で GitHub wiki ページを自動更新する",date:"2022-11-28T00:00:00+09:00",body:"GitHub Actions で GitHub wiki ページを自動更新する 何をするか？ GitHub で管理しているリポジトリに対してコミット＆プッシュが行われたときに、自動的に GitHub wiki 側のリポジトリの内容（Markdown ファイル）を更新するようにしてみます。 例えば、プロダクトのソースコードからドキュメントを自動生成して、開発者がいつでも GitHub wiki ページで参照できるようにしておくと便利です。 図: GitHub wiki ページの自動生成 wiki ページの更新には GitHub Actions のワークフローを使い、次のように自動実行されるよう設定します。 メインリポジトリを対象としたプッシュで GitHub Actions ワークフローを起動 メインリポジトリと wiki リポジトリのソースコードを取得 何らかの外部ツールを実行して Markdown ファイルを生成 Markdown ファイルを wiki リポジトリにコミット＆プッシュ ワークフローの中で GitHub wiki のリポジトリをチェックアウトしているので、あらかじめ対象リポジトリの wiki を作成しておいてください（トップページだけで OK）。 ワークフローファイルの作成 GitHub wiki を自動更新するための、Actions のワークフローファイルを作成します。 .yml 拡張子のファイルを .github/workflows ディレクトリ以下に配置してコミットすれば、GitHub サービス側でワークフローとして認識してくれます。 ここでは、update-wiki.yml というファイル名にしてみました。 .github/workflows/update-wiki.yml name: Update wiki pages on: push: branches: [ main, master ] workflow_dispatch: jobs: update-wiki: runs-on: ubuntu-latest timeout-minutes: 3 steps: - name: Check out main repo uses: actions/checkout@v3 - name: Check out wiki repo uses: actions/checkout@v3 with: repository: &#34;${{ github.repository }}.wiki&#34; path: .wiki - name: Update wiki pages run: echo -e &#34;# Hello\\n\\n$(date)&#34; &gt; .wiki/hello.md - name: Stage and count changes working-directory: .wiki id: staging run: | git add . echo &#34;NUM_OF_STAGED=$(git diff --staged --name-only | wc -l)&#34; &gt;&gt; $GITHUB_OUTPUT - name: Commit wiki pages working-directory: .wiki if: steps.staging.outputs.NUM_OF_STAGED &gt; 0 run: | git config user.email &#34;41898282+github-actions[bot]@users.noreply.github.com&#34; git config user.name &#34;github-actions[bot]&#34; git commit -m &#34;${GITHUB_WORKFLOW}&#34; git push 定義しているジョブは、update-wiki というジョブ 1 つだけです。 以下、このジョブの各ステップを順番に見ていきます。 メインリポジトリのチェックアウト - name: Check out main repo uses: actions/checkout@v3 公式の actions/checkout アクションを使って、メインリポジトリのコードをチェックアウトしておきます。 実は今回のサンプルでは、メインリポジトリのコードは利用していないのですが、ソースコードをもとに wiki ページを生成するのであれば必要になるでしょう。 Markdown ファイルを生成するためのスクリプトが、メインリポジトリの tools ディレクトリなどに入っているかもしれません。 wiki リポジトリのチェックアウト - name: Check out wiki repo uses: actions/checkout@v3 with: repository: &#34;${{ github.repository }}.wiki&#34; path: .wiki wiki リポジトリの名前は、${{ github.repository }}.wiki で参照できるので、actions/checkout アクションでリポジトリ名を指定してチェックアウトします。 チェックアウト先として、.wiki という名前の作業ディレクトリを作成しています。 後のステップで、この中に Markdown ファイルを生成（修正）してコミットすることになります。 wiki ページ（Markdown ファイル）更新 - name: Update wiki pages run: echo -e &#34;# Hello\\n\\n$(date)&#34; &gt; .wiki/hello.md ここが wiki ページ生成の本質的なステップで、.wiki ディレクトリの中に Markdown ファイルを生成（修正）します。 ここではシンプルに、Hello というタイトルと現在の日時が書き込まれた hello.md ファイルを作成していますが、通常はもっと複雑な更新作業になるので、外部ツールなどを呼び出して Markdown ファイルを生成することになります。 例えば、次のようにメインリポジトリ側のシェルスクリプトを呼び出します（引数で出力先ディレクトリ .wiki の絶対パスを渡しておくと親切です）。 - name: Update wiki pages run: ./tools/update-wiki.sh $GITHUB_WORKSPACE/.wiki ちなみに、シェルスクリプトを Windows でコミットするときは、次のようにして実行権限を付けてコミットします。 $ git update-index --add --chmod=+x tools/update-wiki.sh 変更内容のステージング - name: Stage and count changes working-directory: .wiki id: staging run: | git add . echo &#34;NUM_OF_STAGED=$(git diff --staged --name-only | wc -l)&#34; &gt;&gt; $GITHUB_OUTPUT 前述のステップで生成した Markdown ファイルを、wiki リポジトリの方にステージング (git add) します。 ここでのポイントは、いくつのファイルがステージング状態になったか（変更されたか）を、$GITHUB_OUTPUT に出力しておくことです。 例えば、3 つのファイルが変更されている場合は、NUM_OF_STATE=3 のようなキー＆バリューを出力しておきます。 この値は、次のステップで使用します。 wiki リポジトリへのコミット＆プッシュ - name: Commit wiki pages working-directory: .wiki if: steps.staging.outputs.NUM_OF_STAGED &gt; 0 run: | git config user.email &#34;41898282+github-actions[bot]@users.noreply.github.com&#34; git config user.name &#34;github-actions[bot]&#34; git commit -m &#34;${GITHUB_WORKFLOW}&#34; git push 最後に、自動生成した Markdown ファイルを wiki リポジトリへコミット＆プッシュします。 このステップは、前段のステップでセットした出力内容 steps.staging.outputs.NUM_OF_STAGED の値が 0 より大きいとき、つまり、コミットすべきファイルが存在するときのみ実行します。 wiki ページを変更する必要がない場合は、このステップはスキップされて、ワークフローの実行は終了します。 上記のように自力で git commit コマンドを呼び出す場合は、Git の user.email と user.name を設定しておかないとエラーになることに注意してください。 上記の例では、コミュニティで提案されている github-actions[bot] というユーザーを設定しています（参考: Set git user and email）。 このユーザーを指定しておくと、コミット履歴などで次のようなアイコンが表示されるようになります。 図: GitHub Actions ユーザーによる変更履歴 テスト ワークフローファイルを main ブランチにコミットし、GitHub へプッシュすると、自動的に Markdown ファイル (hello.md) が生成され、wiki リポジトリ側にコミットされます。 次のようなページが生成されていれば成功です。 図: GitHub Actions で自動生成された wiki ページ できたー ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/5f2j2hz/",title:"Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する",date:"2022-11-27T00:00:00+09:00",body:"Docker Compose でリバースプロキシを立てて別の Docker Compose 内のコンテナに接続する 何をするか？ 複数の Web アプリを 1 つの VPS（レンタルサーバー）でホスティングする場合、一般的にはリバースプロキシ（nginx など）を立てて、各 Web アプリのバックエンドに繋ぐことになります。 例えば、nginx のバーチャルホスト機能を使って、app1.example.com というアドレスと app2.example.com というアドレスでアクセスされたときに、それぞれ別の Web アプリサーバー（バックエンド）に処理を振り分けます。 ここでは、リバースプロキシと 2 つの Web アプリを別々の Docker Compose で立ち上げて連携する方法を説明します。 図: リバースプロキシによる Docker Compose 連携 1 セットの Web アプリであれば、1 つの Docker Compose 内に関連するコンテナをすべて含めてしまうのが楽ですが、ここでは、独立した 2 つの Web アプリを 1 つの物理サーバー (VPS) 上で運用することを考えているので、別々の Docker Compose に分けています。 もちろん、各アプリが使用する DB コンテナなどは、それぞれの Docker Compose 内にある想定ですが、上記の図では省略しています。 ここで紹介しているソースコードは GitHub に置いてあります。 テスト用の事前準備（hosts ファイル） 今回使用する nginx の設定ファイルでは、app1.example.com と app2.example.com という仮のドメインを使用していますが、本来は実在するドメインでなければいけません。 この設定のままテストしたい場合は、OS の hosts ファイルに次のようなエントリを追加して、ローカルホスト (127.0.0.1) を指すように設定しておきます。 # For development 127.0.0.1	app1.example.com 127.0.0.1	app2.example.com 例えば、macOS の場合は、次のように hosts ファイルを開いて編集します。 hosts ファイルを編集（macOS の場合） $ sudo vi /private/etc/hosts これで、Web ブラウザで http://app1.example.com/ や http://app2.example.com/ にアクセスしたときに、http://localhost/ にアクセスしたのと同じように振る舞うようになります。 ブリッジネットワークの作成 Docker Compose で起動したコンテナ群は、デフォルトで {ディレクトリ名}_default という名前のブリッジネットワークに接続されますが、ここでは reverse-proxy-network という名前のネットワークを生成して、そこにリバースプロキシと連携するすべてのコンテナを接続するようにします。 Docker ネットワークの作成 $ docker network create reverse-proxy-network ネットワーク名は Docker ホスト内で一意になっている必要がありますが、1 つの Docker ホスト (= VPS) 内に複数のリバースプロキシを立てることはあまりないでしょうし、この名前 (reverse-proxy-network) で大丈夫だと思います。 Web アプリ用の Docker Compose 2 つの Web アプリ用の docker-compose.yml ファイルと、テスト用の index.html ファイルを、次のようなディレクトリ構造で用意します。 - webapp1/ +-- docker-compose.yml +-- public/index.html （I am webapp1 と表示するだけ） - webapp2/ +-- docker-compose.yml +-- public/index.html （I am webapp2 と表示するだけ） 下記は、1 つ目の Web アプリの docker-compose.yml ファイルの設定例です。 2 つ目の Web アプリはほぼ同様の内容なので省略します（エイリアス名の app1-container というところが app2-container に変わるだけです）。 webapp1/docker-compose.yml services: app: image: nginx:alpine volumes: - ./public:/usr/share/nginx/html networks: default: reverse-proxy-network: aliases: - app1-container networks: reverse-proxy-network: external: true ポイントは、外部で定義したネットワーク reverse-proxy-network に、nginx コンテナを接続しているところです。 external: true を指定するのを忘れると、この Docker Compose 内に閉じたネットワーク (webapp1_reverse-proxy-network) が生成されてしまうので注意してください。 あと、バックエンド DB などのコンテナに接続できるようにするために、自動生成される default ネットワークにも繋いでおきます（実際のネットワーク名は webapp1_default などになります）。 さらに、リバースプロキシ側からこの nginx サーバーを参照しやすいように、コンテナのエイリアス名 app1-container を設定しています。 これを設定しなくても、webapp1-app-1 のようなディレクトリ名から自動生成されたコンテナ名でアクセスすることはできますが、ちょっと分かりにくいので、エイリアス名を付けておくことをおすすめします。 エイリアス名は、ネットワーク内で一意になっていれば十分です。 サービスのプロパティで container_name: app1-container のようにすると、コンテナ名自体を変更することができますが、コンテナ名は Docker ホスト内で一意でないといけないので、エイリアス名を使った方がよいでしょう。 ちなみに、この nginx サーバーは、同一ネットワーク内のリバースプロキシからのみ接続できれば良いので、Docker ホスト (VPS) 側へのポート公開設定は必要ありません。 リバースプロキシ用の Docker Compose リバースプロキシ用の Docker Compose は次のようなディレクトリ構成で作成します。 - reverse-proxy/ +-- docker-compose.yml +-- conf.d/example.com.conf （nginx の設定ファイル） リバースプロキシの Compose ファイルでも、Web アプリ側と同じ reverse-proxy-network に接続するように設定します。 こちらは特にコンテナのエイリアス名などは設定する必要はありませんが、インターネット経由でアクセスできるように、Docker ホストのポートフォワード設定 (80:80) をしておく必要があります。 reverse-proxy/docker-compose.yml services: reverse-proxy: image: nginx:alpine ports: - &#34;80:80&#34; volumes: - ./conf.d:/etc/nginx/conf.d networks: - reverse-proxy-network networks: reverse-proxy-network: external: true nginx の設定ファイルは、バインドマウントで下記のファイルを使用するように設定しています。 reverse-proxy/conf.d/example.com.conf server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app1.example.com; location / { proxy_pass http://app1-container/; } } server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app2.example.com; location / { proxy_pass http://app2-container/; } } この nginx のバーチャルホスト設定により、インターネット側からのアクセスが次のように各 Web アプリのコンテナに転送されるようになります。 http://app1.example.com/ でのアクセス → http://app1-container/ へ転送 http://app2.example.com/ でのアクセス → http://app2-container/ へ転送 Docker Compose の起動 2 つの Web アプリと、リバースプロキシの Docker Compose を次のように起動します。 すべての Docker Compose を起動 # webapp1 ディレクトリで $ docker compose up -d # webapp2 ディレクトリで $ docker compose up -d # reverse-proxy ディレクトリで $ docker compose up -d リバースプロキシ (nginx) の設定内で、Web アプリのコンテナ（エイリアス名）を参照しているため、上記のような順番で起動しなければいけないことに注意してください。 これで、Web ブラウザから http://app1.example.com/ というアドレスでアクセスしたときは I am webapp1、http://app2.example.com/ というアドレスでアクセスしたときは I am webapp2 と表示されるはずです。 できたー ٩(๑❛ᴗ❛๑)۶ わーぃ テストが終わって、Docker Compose をすべて停止したいときは、起動時と同様に各ディレクトリ内で docker compose down していくか、次のように -p オプションでプロジェクト名を指定して停止します。 あと片づけ $ docker compose -p reverse-proxy down $ docker compose -p webapp1 down $ docker compose -p webapp2 down おつかれ様でしたー。 （おまけ）コンテナ名ではなくポート番号で連携させる 上記の説明では、リバースプロキシとする nginx と、2 つの Web サーバーをコンテナ名で連携させましたが、Web サーバー側のポートを公開すれば、ポート番号で連携させることも可能です。 各 Web サーバーを単独で立ち上げてアクセスするケースがある場合は、こちらの方が都合がよいかもしれません。 例えば、2 つの Web サーバーをそれぞれ 8001 番、8002 番ポートで公開すれば、リバースプロキシからは次のようなアドレスでアクセスできます（参考: Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal)）。 host.docker.internal:8001 host.docker.internal:8002 この場合、リバースプロキシの設定は次のようになります。 reverse-proxy/conf.d/example.com.conf server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app1.example.com; location / { proxy_pass http://host.docker.internal:8001/; } } server { listen 80; # IPv4 listen [::]:80; # IPv6 server_name app2.example.com; location / { proxy_pass http://host.docker.internal:8002/; } } 各コンテナ用の Compose ファイルは次のようになります。 reverse-proxy/docker-compose.yml services: reverse-proxy: image: nginx:alpine ports: - &#34;80:80&#34; volumes: - ./conf.d:/etc/nginx/conf.d webapp1/docker-compose.yml services: app: image: nginx:alpine volumes: - ./public:/usr/share/nginx/html ports: - &#34;${PORT:-8001}:80&#34; webapp2/docker-compose.yml services: app: image: nginx:alpine volumes: - ./public:/usr/share/nginx/html ports: - &#34;${PORT:-8002}:80&#34; ☝️ Docker ポート公開に注意 現時点での Docker (ver.20) では、公開ポートの設定で 8001:80 と指定すると、iptables 設定に穴が開いてインターネット上にポート 8001 番が公開されてしまうことに注意してください。 内部的な設定の優先度の問題で、Ubuntu のファイアウォール (ufw) などで公開していないポートに関してもアクセス可能になってしまいます。 確実にホスト内からのアクセスに限定するには、ports フィールドの指定で、127.0.0.1:8001:80 のようにループバックアドレスを合わせて指定します。"},{url:"/p/qatbs9p/",title:"Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する",date:"2022-11-26T00:00:00+09:00",body:"Docker コンテキストを切り替えてリモートホスト上で Docker コマンドを実行する Docker コンテキストとは？ Docker コンテキストは、ひとことで言うと、Docker CLI で入力したコマンド (docker) の操作対象ホストを切り替えるための仕組みです。 図: Docker コンテキストの切り替え 例えば、Conoha などの VPS サーバー や、Azure (ACI)、AWS (ECS) といったクラウドサービス上の Docker エンジンに対して、ローカルホストから docker コマンドを実行できるようになります。 カレントコンテキストは、docker compose use コマンドで簡単に切り替えることができるので、ローカルでのコンテナのテストが終わったら、コンテキストを Azure (ACI) に切り替えてクラウド環境上で docker compose up するといったことが簡単にできます。 当然、接続先のコンテナサービスごとに接続プロトコルは異なるのですが、Docker は標準で Azure や AWS をターゲットとしたコンテキストの作成に対応しており、実際に docker コマンドを実行するときは接続プロトコルを意識しないで済むようになっています。 ここでは、より汎用的な SSH 接続を用いるコンテキストを作成し、リモートホスト上の Docker エンジンに対して Docker コマンドを実行してみます。 前提条件: リモートホストに Docker がインストールされていること リモートホストに SSH キーで SSH 接続できるようなっていること（参考: SSH の使い方） 接続先のユーザーが sudo なしで docker コマンドを実行できるようなっていること（参考: docker グループへの追加） デフォルト・コンテキスト Docker Desktop をインストールすると、デフォルトのコンテキストとして、default という名前のコンテキストが作成されます。 Docker コンテキストの一覧を表示するには、docker context ls コマンドを使用します。 Docker コンテキストの一覧を確認する $ docker context ls NAME TYPE DESCRIPTION DOCKER ENDPOINT KUBERNETES ENDPOINT ORCHESTRATOR default * moby Current DOCKER_HOST based configuration unix:///var/run/docker.sock swarm default コンテキストのエンドポイントは unix:///var/run/docker.sock となっており、これはローカルホスト上の Docker デーモンに対して Docker コマンドを実行することを示しています。 リモートホストへの SSH 接続設定 SSH 接続に使用するユーザー情報などは、~/.ssh/config ファイルにまとめて記述しておくと便利です。 というか、これを使わないと、細かい接続設定を行うのが困難なので作成しておきましょう。 ~/.ssh/config Host conoha Hostname example.com Port 22 User maku IdentityFile ~/.ssh/id_ed25519 ここでは、Conoha VPS を使う想定で、設定名を conoha にしましたが、このあたりは自由に決めてください。 SSH キー（秘密鍵）にパスフレーズが設定されている場合は、SSH agent に秘密鍵とそのパスフレーズを設定しておく必要があります。 SSH agent に秘密鍵を登録しておく $ ssh-add ~/.ssh/id_ed25519 Enter passphrase for /Users/maku/.ssh/id_ed25519: （秘密鍵のパスフレーズを入力） Identity added: /Users/maku/.ssh/id_ed25519 (maku@macbook.local) SSH 接続用の Docker コンテキストを作成する 新しい Docker コンテキストを作成するには、docker context create コマンドを使用します。 --docker オプションを次のように指定すると、SSH 接続用のコンテキストを作成できます。 Docker コンテキストを作成する $ docker context create --docker &#34;host=ssh://conoha&#34; my-context ssh://conoha という接続 URI では、前述の ~/.ssh/config で設定した名称を使用していることに注意してください。 ssh://maku@example.com:22 のように、明示的な URI を指定することもできます。 次のように実行すると、新しいコンテキスト my-context が作成されていることを確認できます。 $ docker context ls NAME TYPE DESCRIPTION DOCKER ENDPOINT KUBERNETES ENDPOINT ORCHESTRATOR default * moby Current DOCKER_HOST based configuration unix:///var/run/docker.sock swarm my-context moby ssh://conoha この段階では、まだカレントコンテキストは default のままです。 コンテキストを切り替えて Docker コマンドを実行する 使用する Docker コンテキストを切り替えるには、docker context use コマンドを使用します。 コンテキストを my-context に切り替える # コンテキストを切り替え $ docker context use my-context my-context # カレントコンテキストを確認（アクティブなコンテキストに * 印が付いている） $ docker context ls NAME ...(省略)... my-context * ...(省略)... default ...(省略)... # 次のようにカレントコンテキスト名だけ表示することも可能 $ docker context show my-context あとは、いつも通り docker コマンドを実行すると、SSH 接続先の Docker ホストで処理されるようになります。 $ docker container run --rm hello-world 例えば、リモートホスト側で次のような感じで Web サーバーを起動し、ローカルホスト側からアクセスできるようになります（もちろんポートが適切に開放されている必要があります）。 # リモートホスト上の Web サーバー（nginx コンテナ）を起動 $ docker container run --rm -d -p 8000:80 --name web nginx # ローカルホストからアクセス $ curl http://example.com:8000 # リモートホスト上の Web サーバーを停止 $ docker container stop web 上記の例では、あらかじめ docker context use コマンドで使用するコンテキストを切り替えておきましたが、docker コマンド実行時に --context オプションでコンテキスト名を指定することもできます。 次のように実行すれば、各コンテキストで使用する Docker ホストの詳細情報を確認できます。 コンテキストを明示して実行 $ docker --context default info # デフォルトコンテキスト（ローカルホスト）で実行 $ docker --context my-context info # 今回作成したコンテキスト（リモートホスト）で実行 本番環境用のコンテキストは常に選択していると危険なので、--context オプションでのみ使用した方がよいかもしれません。 $ docker --context production compose up -d Docker コンテキストを削除する 必要なくなった Docker コンテキストは、docker context rm コマンドで削除できます。 $ docker context use default # デフォルトコンテキストに戻しておく $ docker context rm my-context # 不要なコンテキストを削除 $ docker context ls # コンテキストの一覧を確認 NAME ...(省略)... default * ...(省略)... バインドマウント時の注意 Docker コンテキストとバインドマウントを組み合わせて使用するときは、マウント時の source パスの指定方法に注意する必要があります。 source パスを下記例の ./meili_data のように相対パスで記述すると、それは docker コマンドを実行する PC 上のカレントパスとして展開されます。 docker-compose.yml（バインドマウント） version: &#34;3.9&#34; services: meilisearch: image: &#34;getmeili/meilisearch:v1.6&#34; container_name: meilisearch ports: - &#34;7700:7700&#34; environment: - MEILI_ENV=production - MEILI_NO_ANALYTICS=true - MEILI_MASTER_KEY volumes: - type: bind source: ./meili_data target: /meili_data bind: create_host_path: true # ./meili_data が存在しなければ作成 例えば、カレントディレクトリが /Users/maku/myproject の状態で docker --context my-context compose up -d と実行すると、my-context コンテキストが指し示すリモートホスト上に /Users/maku/myproject というディレクトリが生成されてしまいます（存在しなければ）。 このパスは、おそらくリモートホスト上では意味を持ちません。 このような振る舞いを防ぐには、source パスを最初から絶対パスで指定する必要があります。 volumes: - type: bind source: /opt/meili_data # ターゲットホスト上の絶対パスを想定して記述 target: /meili_data bind: create_host_path: true あるいは、バインドマウントではなく、ボリュームマウント を使ってしまうのが手っ取り早いです。 ボリュームマウントを使用すると Docker のシステムがデータを一元管理してくれるため、ファイルシステム上のパスに関連する問題が発生しなくなります。 docker-compose.yml（ボリュームマウント） version: &#34;3.9&#34; services: meilisearch: image: &#34;getmeili/meilisearch:v1.6&#34; container_name: meilisearch ports: - &#34;7700:7700&#34; environment: - MEILI_ENV=production - MEILI_NO_ANALYTICS=true - MEILI_MASTER_KEY volumes: - type: volume # ボリュームマウントを使用する source: meili_data # 一番下で定義しているボリュームを指定 target: /meili_data volume: nocopy: true # ボリューム生成時にコンテナから内容をコピーしない # 作成するボリュームの定義 volumes: meili_data: # name: meili_data # プロジェクト名のプレフィックスを付けたくないとき"},{url:"/p/dsctaq7/",title:"Git サブモジュールで別リポジトリの内容を組み込む (git submodule)",date:"2022-11-13T00:00:00+09:00",body:"Git サブモジュールで別リポジトリの内容を組み込む (git submodule) Git サブモジュールとは Git サブモジュールは、既存の別リポジトリの内容を、サブディレクトリの形で参照できるようにする仕組みです。 例えば、次のようなディレクトリ構成のプロジェクトがあったとします。 my-project/ +-- src/ +-- my-libs/ ★別リポジトリをサブモジュールとして組み込む ここでは、別リポジトリで管理している共有ライブラリを my-libs サブディレクトリの形で参照できるようにしています。 NPM や Maven などのパッケージレジストリから共有ライブラリを取り込む方法もありますが、Git サブモジュールの仕組みを使うと、メインプロジェクトでの開発と共有ライブラリの開発を並行して進められる ようになります。 Git サブモジュールで特徴的なのは、メインプロジェクトからはサブモジュールの内容を コミットハッシュのみで追跡する ということです。 この振る舞いを理解してしまえば、Git サブモジュールを使いこなすのは難しくありません。 サブモジュール側の変更履歴は、あくまでサブモジュール側の Git リポジトリで管理されます。 つまり、サブモジュール側のリポジトリで大量のコミットが行われていたとしても、メインプロジェクト側のリポジトリサイズが増加していくということはありません。 メインプロジェクト側では、どの時点でのスナップショット（のコミットハッシュ）を参照するかを指定するだけです。 サブモジュールとして取り込む Git リポジトリの URL は柔軟に切り替えることができます。 Git サブモジュールの利用例 共有ライブラリ用のリポジトリがあるけれど、NPM や Maven などのパッケージリポジトリにはリリースしていないとき、サブモジュールとして共有ライブラリを取り込む。メインプロジェクト側の開発中に、並行して共有ライブラリのコードを修正したい場合も同様。 頻繁に更新されるファイルがあるけれど、メインプロジェクト側のコミット履歴には残したくないとき、別リポジトリでそのファイルを管理し、サブモジュールとして取り込む。 別リポジトリをサブモジュールとして追加する (git submodule add) 既存の別リポジトリの内容（前述の例では共有ライブラリ）を、カレントプロジェクトにサブモジュールとして組み込みたいときは、git submodule add コマンドを使用します。 $ git submodule add &lt;別リポジトリのURL&gt; [ローカルディレクトリ] 例えば次のように実行すると、 $ git submodule add https://github.com/maku77/my-libs ローカルに my-libs というディレクトリが作成されて、サブモジュールとして参照できるようになります。 別のディレクトリ名で取り込みたい場合は、末尾にディレクトリ名を追加で指定します。 初めてサブモジュールが追加されると、.gitmodules というメタ情報ファイルが作成されます。 ここには、サブモジュールごとのリポジトリ URL とローカルディレクトリのパスが記録されています。 このファイルをコミットすることで、他の開発者がサブモジュールとして管理されているファイルを取得できるようになります。 .gitmodules [submodule &#34;my-libs&#34;] path = my-libs url = https://github.com/maku77/my-libs 最初に説明した通り、サブモジュールの内容はコミットハッシュでのみ追跡されています。 各サブモジュールのディレクトリに、どのコミットハッシュの内容が取得されているかは、git submodule status コマンドで確認することができます。 $ git submodule status ffb0ef23b9cc39d05b860d2379977268b2f44194 my-libs (heads/main) あとは、今回作成された .gitmodules ファイルと my-libs ディレクトリを git commit すれば作業完了です。 ちなみに、サブモジュールとして追加された my-libs ディレクトリは、次のような特殊モード (160000) のファイルとして登録され、コミットハッシュのみが記録されています。 $ git diff --staged my-libs diff --git a/my-libs b/my-libs new file mode 160000 index 0000000..ffb0ef2 --- /dev/null +++ b/my-libs @@ -0,0 +1 @@ +Subproject commit ffb0ef23b9cc39d05b860d2379977268b2f44194 サブモジュールを含むリポジトリをクローンする (git submodule init, git submodule update) サブモジュールを含むリポジトリ（.gitmodules を含むリポジトリ）をクローンした直後は、サブモジュール用のディレクトリは空っぽになっています。 $ git clone https://github.com/maku77/my-project $ cd my-project $ ls my-libs （空っぽ） .gitmodules ファイルの内容に基づいてサブモジュールを利用し始めるには、git submodule init コマンドを実行します。 $ git submodule init Submodule &#39;my-libs&#39; (https://github.com/maku77/my-libs) registered for path &#39;my-libs&#39; これにより、ワーキングディレクトリ内の各サブモジュールディレクトリを、どのリポジトリ URL にマッピングすべきかが .git/config ファイルに保存されます。 この時点では、まだ my-libs ディレクトリは空っぽの状態で、実際にサブモジュールのファイル群を取得するには、git submodule update コマンドを実行する必要があります。 サブモジュールがさらに別のサブモジュールを含んでいる場合は、--recursive オプションを付けるとまとめて取得できます。 基本的には、このオプションは常に付けておけばよいでしょう。 サブモジュールのファイルを取得 $ git submodule update --recursive Cloning into &#39;/Users/maku/y/gitwork/maku77/my-project/my-libs&#39;... Submodule path &#39;my-libs&#39;: checked out &#39;ffb0ef23b9cc39d05b860d2379977268b2f44194&#39; これで、メインプロジェクト (my-project) からサブモジュール (my-libs) のファイルを参照できるようになります。 クローン直後に git submodule init と git submodule update を実行するのは、ほとんど定型作業になっているので、これらをまとめて実行する git submodule update --init コマンドが用意されています。 init と update を一気に実行 $ git submodule update --init --recursive Submodule &#39;my-libs&#39; (https://github.com/maku77/my-libs) registered for path &#39;my-libs&#39; Cloning into &#39;/Users/maku/y/gitwork/maku77/my-project/my-libs&#39;... Submodule path &#39;my-libs&#39;: checked out &#39;ffb0ef23b9cc39d05b860d2379977268b2f44194&#39; さらに、git clone と git submodule init、git submodule update を同時にやってしまう、git clone --recurse-submodules コマンドも用意されています。 サブモジュールを含むリポジトリをクローンする場合は、このコマンドを使えば一撃でクリア です。 クローンしてサブモジュールも取得 $ git clone --recurse-submodules https://github.com/maku77/my-project メインプロジェクト内でサブモジュールのファイルを修正する メインプロジェクトでの作業中に、サブモジュールのファイルを修正したくなった場合は、サブモジュールのディレクトリに移動して、サブモジュール側の Git リポジトリの修正作業を行います。 メインプロジェクト側ではサブモジュールの修正内容は管理しない（コミットハッシュだけ記録している）ので、サブモジュール側の修正は、サブモジュール側のリポジトリにコミット＆プッシュする必要があります。 典型的な作業順序は次のようになります。 サブモジュールのディレクトリに移動する サブモジュール内でブランチを切り替える サブモジュール内のファイルを修正＆コミット＆プッシュ メインプロジェクトに戻り、サブモジュールディレクトリをコミット（コミットハッシュの更新） あくまで 2 つのリポジトリで別々に修正作業を行う感じですね。 初期状態では、サブモジュール側のチェックアウト状態は detached HEAD（どのブランチも選択しておらず、特定のコミットハッシュを選択している状態）になっているので、作業対象となるブランチに切り替えてから修正作業を行います。 サブモジュール側のファイルを更新 $ cd my-libs $ git branch * (HEAD detached at bb1319a) main $ git switch main $ （何らかのファイル修正） $ git add . $ git commit $ git push ここでサブモジュール側の更新を（GitHub などへ）プッシュしておかないと、他の開発者がメインプロジェクト側で git submodule update しようとしたときに、対象のコミットハッシュが見つからない、といったことになるので注意してください。 サブモジュール側の修正が完了したら、メインプロジェクト側に戻り、参照するサブモジュールのコミットハッシュを最新のものに更新します。 $ cd .. # メインプロジェクトのルートへ戻る $ git add my-libs # サブモジュールの最新のコミットハッシュをステージング $ git commit $ git push メインプロジェクトの更新内容を確認してみると、コミットハッシュの更新のみになっていることが分かります。 $ git show ... -Subproject commit 540bb2831ae6478bf43ce6f8ab7aff09e23946b7 +Subproject commit fd80dfabbc154de89f12a9c617f0d76efbdb00eb git show コマンドや git log -p コマンドは、サブモジュール側の変更内容 (diff) として、上記のようなコミットハッシュしか表示してくれませんが、--submodule オプションを付けて実行すると、コミットハッシュの代わりにサブモジュールのコミットログを確認できます。 $ git show --submodule ... Submodule common 540bb28..fd80dfa: &gt; Add sidebar component ☝️ プッシュしていないコミットハッシュを参照してしまうのを防ぐ サブモジュール側の変更をプッシュする前に、メインプロジェクト側でそのコミットを参照する変更をプッシュしてしまうと、最新コードがビルドできない状態になってしまいます（サブモジュールを git submodule update で取得できない）。 このような事態を防ぐために、git push コマンドには、--recurse-submodules というオプションが用意されています。 このオプションで check や on-demand といった値を指定すると、次のように振る舞いが変化します。 git push --recurse-submodules=check &hellip; プッシュされていないサブモジュールのコミットを参照していたら、実行を中止する git push --recurse-submodules=on-demand &hellip; プッシュされていないサブモジュールのコミットを参照していたら、サブモジュール側を先にプッシュする サブモジュール側のリポジトリの更新内容を取り込む (git submodule update &ndash;remote) サブモジュールとして参照しているリポジトリに更新があった場合、その内容を取得するには、git submodule update --remote コマンドを使用します。 サブモジュールの内容を更新 $ git submodule update --remote --recursive --remote オプションを付けずに実行した場合は、カレントプロジェクトで記録されているコミットハッシュ値でファイルを取得するという意味になります。 なので、参照している共有ライブラリ側で独立して更新された内容を取り込むには、--remote オプションが必要です。 デフォルトではすべてのサブモジュールを更新しようとしますが、特定のサブモジュールだけ更新することもできます。 指定したサブモジュールのみ更新 $ git submodule update --remote --recursive lib1 lib2 lib3 上記のように git submodule update --remote を実行すると、サブモジュール側のチェックアウト状態は、ふたたび detached HEAD になります。 つまり、完全にリモートリポジトリ側 (GitHub) の最新のコミットを参照する状態に置き換えられます。 サブモジュール側に、まだプッシュされていないローカルコミットがあり、その内容とマージしたいときは、--merge オプションを付けて次のように実行します。 サブモジュールのローカルコミットにリモートコミットをマージ $ git submodule update --remote --recursive --merge --merge オプションを付けずに実行して、サブモジュールにローカルコミットした内容が見えなくなってしまっても慌てる必要はありません。 いかなる場合でもコミットログは残っている（git log --all ですべて確認できる）ので、適切なブランチに適切なコミットをマージするだけです。 $ cd my-libs # サブモジュールへ移動 $ git switch main # マージ先のブランチに切り替え $ git merge fd5ccb6 # リモート側の最新 (detached HEAD) をマージ $ git add . $ git commit $ git push とはいえ、git submodule update --remote を実行する前に、サブモジュール内で行った修正はコミット＆プッシュまで済ませておく、という手順にした方が混乱せずに済むでしょう。 他の開発者が行ったサブモジュールのコミットハッシュ更新を反映する (git pull &ndash;recurse-submodules) メインプロジェクト内のサブモジュールを更新した場合（コミットハッシュ値を更新した場合）、他の開発者もそのコミットハッシュに対応するサブモジュールのコードを取得する必要があります。 そのためには、git pull でメインプロジェクトの更新内容を取り込んだ後に、git submodule update を実行します。 $ git pull $ git submodule update --recursive この作業も定型の操作になるので、まとめて実行する git pull --recurse-submodules というコマンドが用意されています。 $ git pull --recurse-submodules サブモジュールを削除する (git submodule deinit) サブモジュールが必要なくなったら、次のように登録情報やローカルに残ったファイルを削除できます。 # .git/config からエントリを削除（git submodule init で追加されたもの） $ git submodule deinit &lt;ディレクトリ名&gt; # .gitmodules ファイル内のセクションを削除（git submodule add で追加されたもの） $ git config -f .gitmodules --remove-section submodule.&lt;ディレクトリ名&gt; # ローカルに残ったディレクトリを削除 $ rm -rf &lt;ディレクトリ名&gt; $ rm -rf .git/modules/&lt;ディレクトリ名&gt; # 変更をコミット＆プッシュ $ git add . $ git commit $ git push 複数のサブモジュールをまとめて操作する (git submodule foreach) これまでに述べてきたように、Git サブモジュールはあくまで別リポジトリのリファレンスとして動作するため、メインプロジェクト上で git コマンドを実行しても、コミットハッシュくらいしか参照できません。 git submodule foreach COMMAND コマンドを使うと、各サブモジュール内で任意のコマンド (COMMAND) を実行したかのように振る舞わせることができます。 git submodule foreach の使用例 # すべてのサブモジュール内で git diff を実行 $ git submodule foreach &#34;git diff&#34; # すべてのサブモジュール内で git branch を実行 $ git submodule foreach &#34;git branch&#34; Git サブモジュール用の便利なエイリアス Git サブモジュールをうまく扱うには、Git コマンドに様々なオプションを付けて操作する必要があります。 次のように、よく使いそうなコマンドをエイリアスとして登録しておくと便利です。 $ git config --global alias.sclone &#39;clone --recurse-submodules&#39; $ git config --global alias.supdate &#39;submodule update --remote --recursive --merge&#39; $ git config --global alias.sdiff &#39;!&#39;&#34;git diff &amp;&amp; git submodule foreach &#39;git diff&#39;&#34; $ git config --global alias.spush &#39;push --recurse-submodules=on-demand&#39; git sclone &hellip; git clone すると同時にサブモジュールの内容も取得する git supdate &hellip; 全サブモジュールの最新バージョンのファイルを取得する（ローカルコミットがあればマージ） git sdiff &hellip; 全サブモジュールの変更内容を含んだ diff を表示する git spush &hellip; プッシュ時にサブモジュール側のコミットを先にプッシュする Git サブモジュール関連のコマンドのまとめ コマンド 説明 git clone --recurse-submodules &lt;URL&gt; git clone すると同時にサブモジュールも取得する git submodule add &lt;URL&gt; サブモジュールを追加する git submodule status サブモジュールのコミットハッシュを表示する git submodule init ローカルのインデックスでサブモジュールを管理し始める git submodule update --recursive コミットハッシュに従ってサブモジュールを取得する git submodule update --init --recursive init と update を同時に実行する git submodule update --remote --recursive サブモジュールの最新バージョンを取得する git pull --recurse-submodules git pull と同時に update を実行する git push --recurse-submodules=on-demand プッシュ時にサブモジュール側のコミットを先にプッシュする"},{url:"/windows/",title:"Windows",date:"2022-11-09T00:00:00+09:00",body:"Windows Windows バッチファイル 環境 Windows で Ruby や Python のスクリプトを組み込みコマンドのように使用する 環境変数が設定されているかどうか調べる (if defined) バッチファイルが管理者として実行されているか調べる 構文 バッチファイルの FOR ループ (1) 数値、ファイル集合、ディレクトリ集合のループ処理 バッチファイルの FOR ループ (2) テキストファイル、コマンド出力を 1 行ずつループ処理 バッチファイルを途中で終了する (exit /b) バッチファイルでサブルーチンを定義する、別のバッチファイルを呼び出す (call, setlocal) 長いコマンドを複数行に分けて記述する 入出力 (I/O) バッチファイルでコマンドライン引数を扱う バッチファイルでプロンプトを表示してユーザー入力を促す (set /p) 標準出力 (stdout) と標準エラー (stderr) への出力をファイルに保存する echo で改行だけ出力する／改行しないで出力する 複数のコマンドの出力をまとめてリダイレクトする バッチファイルでコマンドの実行結果を変数に格納する ファイル／ディレクトリ／パス バッチファイルのファイル名やディレクトリ名を取得する DIR コマンドでファイルやディレクトリを再帰的に検索する DIR コマンドでファイルやディレクトリを OR 検索する カレントディレクトリ以下のファイルやディレクトリを順に処理する findstr でファイル内の文字列を検索する 既にディレクトリが存在している場合の mkdir のエラーを抑制する 複数のファイルを連結する 日時 バッチファイル内で日時を出力する (%DATE%, %TIME%) バッチファイル内で日時を元にファイル名を作成する バッチファイル内で1日後の日時を取得する（時刻の演算） コマンドプロンプト コマンドプロンプトを管理者権限 (Administorator) で起動する コマンドプロンプトの文字色と背景色を変更する コマンドプロンプトのプロンプト表示を変更する コマンドプロンプトからウィンドウサイズを変更する doskey を使ってコマンドプロンプト用のマクロを登録する コマンドプロンプトから複数のコマンドを並列実行する (start) ファイル／ディレクトリ／パス カレントディレクトリのパスを取得する コマンドプロンプトでディレクトリ内のファイルをすべて削除する (del, rmdir) コマンドプロンプトからインターネット上のファイルをダウンロードする (bitsadmin) Windows の便利操作／ショートカット Windows でキーボード操作だけで様々なフォルダを素早く開く Windows の設定／管理／セキュリティ タスク管理 Windows で実行中のプロセス（タスク）の一覧を表示する (tasklist) Windows で実行中のプロセス（タスク）を終了 (kill) する (taskkill) Windows で任意のコマンド（タスク）を自動実行する (schtasks) Windows OS のバージョン情報をコマンドラインから調べる NIC に割り当てられた MAC アドレスを調べる (getmac) コマンドラインから Windows サービスを管理する Administrator で Windows にログオンできるようにする Windows のアカウント名を変更する ドメインユーザーにローカル PC の Administrator 権限を与える 日本語キーボードのノート PC で英字配列の USB キーボードを使用する Windows のユーザのパスワードの有効期限を無期限に設定する xcopy でディレクトリ内のファイルをバックアップする NTP による時刻同期情報を取得する (w32tm) ネットワーク Windows ファイアウォールで特定のポートを開放する ネットワーク切り替え時に PC 名ですぐに検索できるようにする（NetBios 名の再登録） Windows のログオフ時にネットワーク接続を維持する Windows の DNS キャッシュをクリアする MS Office Excel Excel のブック、ワークシート、セルの関係を理解する Excel の行・列の表示／非表示をショートカットキーで素早く切り替える Excel で点数などから順位を求める（RANK.EQ関数） Excel で順位セルの値通りに並び替えて表示する VBA マクロに関してはこちらを参照 PowerPoint PowerPoint で使いこなすとかっこいいショートカット SVG ファイルを EMF ファイルに変換して PowerPoint に貼り付ける PowerPoint プレゼン資料でおすすめのフォント設定 Word Word で章・節・項の見出しを作成する Word で章・節・項の「見出しマップ」を表示する Word で章・節・項の見出しの表示スタイルを変更する Word で章・節・項の見出しに連番（段落番号）を自動で振る Word で章・節・項の見出しから目次を作成する Outlook Outlook で返信メールのメッセージの行頭に引用記号 (&gt;) を付ける Outlook の予定表を他のユーザから見えるようにする Windows API Legacy API プロセス・ハンドルについて Windows の静的ライブラリと動的ライブラリ 指定したウィンドウ (HWND) を確実にアクティブにする 現在使用中の Windows OS のバージョンを調べる Windows API ですべてのウィンドウを列挙し、特定の条件にマッチするウィンドウを取得する Windows API でスクリーンセーバーの起動時間を取得／設定する .NET 日付／時刻 .NET - 時刻部分をすべて 0 にした DateTime インスタンスを作成する .NET - DateTime インスタンスと文字列を相互に変換する .NET - 現地時刻（ローカルタイム）と世界協定時刻 (UTC) の扱いを理解する その他 .NET - System.Data.SQLite で SQLite データベースを使用する .NET - XML 形式の設定ファイルを XPath で操作するサンプル .NET - ツリーノードのドラッグ＆ドロップの流れ .NET - ツリーノードを右クリックしたときにそのノードを選択状態にする"},{url:"/p/2dn6njw/",title:"Windows のバッチファイルでプロンプトを表示してユーザー入力を促す (set /p)",date:"2022-11-09T00:00:00+09:00",body:"Windows のバッチファイルでプロンプトを表示してユーザー入力を促す (set /p) set /p コマンドの使い方 Windows のコマンドプロンプトで SET /P コマンドを実行すると、任意のプロンプトを表示して、ユーザーにキーボード入力を促すことができます。 SET /P 変数=[プロンプト文字列] ユーザーが入力したテキストは、指定した変数に格納されるので、後から %変数名% という形で参照することができます。 次の例では、ユーザーにプロジェクト名の入力を促し、入力結果を PjName という変数に格納しています。 sample.cmd @echo off setlocal set /p PjName=&#34;Project name? &#34; echo 入力したプロジェクト名は %PjName% です 実行例 Project name? HelloWorld 入力したプロジェクト名は HelloWorld です 具体的な使用例 set /p コマンドを実行する前に、入力候補を表示するという利用方法も考えられます。 次のサンプルバッチファイルは、Android のエミュレーター (AVD) を起動するためのものですが、起動可能なデバイス (AVD) の候補を表示して、ユーザーにどのデバイスを起動するかを選択させています。 emu.cmd @echo off setlocal echo Available AVDs: emulator -list-avds set /p AvdName=&#34;Which AVD do you want to start? &#34; if &#34;%AvdName%&#34;==&#34;&#34; ( echo ERROR: No AVD specified. exit /b ) emulator @%AvdName% 実行例 Available AVDs: phone-s phone-t tv-s tv-t Which AVD do you want to start? phone-t 参考: Windows のバッチファイルの実行を途中で終了する (exit /b)"},{url:"/p/zgyhygw/",title:"Android エミュレーターをコマンドラインから操作する (emulator, adb emu)",date:"2022-11-08T00:00:00+09:00",body:"Android エミュレーターをコマンドラインから操作する (emulator, adb emu) emulator コマンドと adb コマンド Android SDK に付属している emulator コマンドや adb コマンドを使うことで、Android のエミュレーターを操作することができます。 emulator コマンド エミュレーター端末 (= AVD: Android Virtual Device) の一覧を表示したり、エミュレーター端末を起動したりするのに使うコマンドです。 adb コマンド エミュレーター端末が起動した後に、コマンドを送り込んで各種操作を行います。adb はエミュレーター専用のコマンドではありませんが、adb emu のようなエミュレーターに特化したサブコマンドがあります。 emulator コマンドは、Android SDK をインストールしたディレクトリの emulator ディレクトリに格納されています。 例えば次のようなパスにあります（ユーザー名が maku の場合）。 Windows の場合: C:\\Users\\maku\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe macOS の場合: /Users/maku/Library/Android/sdk/emulator/emulator 次のような感じで OS のパスを通しておくと、どこからでもコマンドを実行できるようになります。 ~/.zlogin（macOS で zsh の場合） export ANDROID_HOME=~/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin export PATH=$PATH:$ANDROID_HOME/platform-tools export PATH=$PATH:$ANDROID_HOME/emulator export PATH=$PATH:$ANDROID_HOME/tools ☝️ emulator/emulator と tools/emulator tools ディレクトリにも同名の emulator コマンドがあったりしますが、こちらではなく、emuator ディレクトリの方にあるコマンドを使うのが正解のようです。 なので、パスを通すときは、emulator ディレクトリが先に来るように指定しておく必要があります。 emulator コマンドの使用例 AVD（エミュレーター端末）のリストを表示する (emulator -list-avds) $ emulator -list-avds phone-s phone-t tv-s tv-t AVD 名には、上記のようなシンプルな名前を付けておくのがおすすめです。 エミュレーターを起動するときに AVD を指定するのが楽になります。 エミュレーターを起動する (emulator) $ emulator @AVD_NAME $ emulator -avd AVD_NAME ここで指定する AVD 名は、前述の emulator -list-avds コマンドで表示されたものの中から選択します。 AVD 名の一覧を表示して、ユーザーに起動する AVD を選択させるバッチファイルなどを作っておくと便利です。 emu.cmd（AVD を選択して起動するバッチファイル） @echo off setlocal echo Available AVDs: emulator -list-avds set /p AvdName=&#34;Which AVD do you want to start? &#34; if &#34;%AvdName%&#34;==&#34;&#34; ( echo ERROR: No AVD specified. exit /b ) emulator @%AvdName% adb コマンドの使用例 稼働中のエミュレーターの一覧を表示する (adb devices) $ adb devices List of devices attached emulator-5554	device emulator-5556	device 上記の例では、2 つのエミュレーターが起動しており、それぞれのシリアル（識別子のようなもの）は emulator-5554 と emulator-5556 であることがわかります。 複数のエミュレーターが起動している場合、ほとんどのケースでは adb コマンド実行時に操作対処とするエミュレーターを -s オプションで指定する必要があります。 シリアルを指定して adb コマンド実行 $ adb -s emulator-5554 logcat adb devices コマンドで -l オプションを指定すると、さらに詳細な情報を表示できます。 $ adb devices -l List of devices attached emulator-5554 device product:sdk_gphone64_arm64 model:sdk_gphone64_arm64 device:emulator64_arm64 transport_id:1 emulator-5556 device product:sdk_google_atv64_amati_arm64 model:sdk_google_atv64_amati_arm64 device:emu64a transport_id:2 この出力の末尾には、各エミュレーター端末のトランスポート ID が表示されており、これをシリアルの代わりに使うことができます。 $ adb -t 1 logcat エミュレーターを停止する (adb emu kill) $ adb emu kill $ adb -s emulator-5554 emu kill # 複数のエミュレーターを起動している場合 画面上からエミュレーターが消えているのに、なぜかエミュレーターが起動し続けている（adb devices のリストから消えない）という状態になってしまった場合は、このコマンドを実行すれば確実に終了できます。 Android OS を再起動する / AVD を再起動する Android の再起動 $ adb reboot エミュレーター内で動作している Android を再起動します。 BOOT_COMPLETED インテントまわりのテストをするときに必要になったりします。 エミュレーター (AVD) 自体を再起動したいときは次のように実行します。 AVD (Emulator) の再起動 $ adb emu restart その他の adb emu サブコマンド $ adb emu rotate # 画面を回転 $ adb emu avd name # AVD 名を表示 $ adb emu avd status # AVD の状態を表示 $ adb emu avd bugreport # バグレポートを生成 adb emu コマンドにはあまりドキュメントがなかったりしますが、adb emu help-verbose で簡単なコマンド一覧を表示できます。 もしかすると便利なコマンドが見つかるかもしれません。"},{url:"/p/kziyhzg/",title:"fmt.Println による構造体の出力をカスタマイズする (Stringer)",date:"2022-11-05T00:00:00+09:00",body:`fmt.Println による構造体の出力をカスタマイズする (Stringer) Golang での構造体の出力 Golang の構造体の内容は、fmt パッケージの各種関数で出力できるようになっています。 次のコードでは、Game 構造体の内容をいくつかの方法で出力しています。 package main import &#34;fmt&#34; type Game struct { Title string Price int } func main() { g := &amp;Game{Title: &#34;ドンキーコング&#34;, Price: 4500} fmt.Println(g) // &amp;{ドンキーコング 4500} fmt.Printf(&#34;%v\\n&#34;, g) // &amp;{ドンキーコング 4500} fmt.Printf(&#34;%+v\\n&#34;, g) // &amp;{Title:ドンキーコング Price:4500} fmt.Printf(&#34;%#v\\n&#34;, g) // &amp;main.Game{Title:&#34;ドンキーコング&#34;, Price:4500} } こういった出力で十分であればよいのですが、異なる出力が欲しいときは、次に説明する Stringer インタフェースを実装することで対応できます。 String 関数による出力のカスタマイズ fmt パッケージで構造体を文字列表現に変換するとき、内部で String 関数が呼び出されます。 String 関数は、fmt パッケージの Stringer インタフェースとして定義されています。 type Stringer interface { String() string } 例えば、Game 構造体の出力をカスタマイズしたいときは、次のように String() 関数を実装します。 type Game struct { Title string Price int } // Game 構造体の文字列表現 func (g Game) String() string { return fmt.Sprintf(&#34;「%s」 %d円&#34;, g.Title, g.Price) } すると、fmt パッケージの各種関数による出力は次のように変化します。 func main() { g := &amp;Game{Title: &#34;ドンキーコング&#34;, Price: 4500} fmt.Println(g) // 「ドンキーコング」 4500円 fmt.Printf(&#34;%v\\n&#34;, g) // 「ドンキーコング」 4500円 fmt.Printf(&#34;%+v\\n&#34;, g) // 「ドンキーコング」 4500円 fmt.Printf(&#34;%#v\\n&#34;, g) // &amp;main.Game{Title:&#34;ドンキーコング&#34;, Price:4500} } Golang のソースコード表現を表す %#v の出力だけは変化しないようです。 構造体の内容をきれいな JSON 形式で出力したければ、json パッケージを使って次のように実装できます（参考: Golang で JSON を扱う）。 func (g Game) String() string { bytes, err := json.MarshalIndent(g, &#34;&#34;, &#34; &#34;) if err != nil { // Cyclic data structures が見つかった時の対策 return g.Title } return string(bytes) } 出力例 { &#34;Title&#34;: &#34;ドンキーコング&#34;, &#34;Price&#34;: 4500 } ただ、デバッグ用途の出力であれば、素直に出力専用の関数を定義した方がよさそうです。 func PrintGame(g *Game) { bytes, _ := json.MarshalIndent(g, &#34;&#34;, &#34; &#34;) fmt.Println(string(bytes)) }`},{url:"/go/",title:"Golang",date:"2022-11-05T00:00:00+09:00",body:"Golang はじめに／実行環境 はじめに Go 言語とは？／Go をインストールする Go 言語で Hello World をコンパイル、実行する Go 言語のコーディングスタイル（コーディング規約） Go ツアーを起動して Go 言語の基本を勉強する go install のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin) （旧）GOPATH によるコードの一元管理 パッケージとモジュール パッケージの作成とインポート (import) Go でコマンドラインツールを作って GitHub で公開する （旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する Go の文法 型 Go 言語の組込み型一覧 変数を定義する (var)／ゼロ値について 配列とスライスを扱う マップを扱う (map) ポインタを扱う (＊) 定数を定義する (const) 組込み型に独自の型名を付ける (type) 型キャストと型アサーションによる型変換 制御構文 if による条件分岐 switch による条件分岐 for によるループ処理 関数を定義する (func) パニックによるエラー処理 (panic, recover) 構造体（クラス） 構造体を定義する (struct) 構造体のコンストラクタ（ファクトリ関数）を定義する メソッドを定義する（レシーバ付き関数） Go 言語のインタフェースの扱いを理解する (interface) インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding) 構造体にタグ情報を追加する (struct tags) fmt.Println による構造体の出力をカスタマイズする (Stringer) その他 ジェネリクスで複数の型を扱える関数を定義する (Generics) 標準パッケージ／外部パッケージの利用 文字列／数値 文字列の処理いろいろ 空文字列のチェック / 文字列の連結 / 文字列の分割 ファイル／ディレクトリ ファイルを読み書きする (os, io) JSON 形式の文字列やファイルを扱う (encoding/json) CSV 形式の文字列やファイルを扱う (encoding/csv) テンプレート機能を使用する (text/template, html/template) カレントディレクトリのパスを取得する (os.Getwd) サーバー HTTP サーバーを作成する (net/http) GraphQL サーバーを作成する (gqlgen) gqlgen で子フィールドの情報を返すリゾルバーを実装する データベース (DB) RDB（リレーショナルデーターベース）を扱う (database/sql) MongoDB を扱う (go.mongodb.org/mongo-driver) その他 コマンドライン引数を扱う (os.Args, flags) 時刻データを扱う (time) ベンチマークを行う (testing.B) 環境変数を扱う (os.Getenv, os.LookupEnv) ランダム値（乱数）を扱う (math/rand, crypto/rand)"},{url:"/p/xssnvmh/",title:"Golang の文字列操作いろいろ",date:"2022-11-04T00:00:00+09:00",body:"Golang の文字列操作いろいろ Go 言語の文字列操作に関するメモです。 空文字列と nil のチェック 文字列が空かどうか調べる var s string // s := &#34;&#34; と同じ（string のゼロ値は空文字列） fmt.Println(s == &#34;&#34;) //=&gt; true fmt.Println(len(s) == 0) //=&gt; true string 変数の内容が空文字列かどうかの確認は、s == &quot;&quot; と len(s) == 0 のどちらでも OK です。 文字列ポインタが nil あるいは空文字を指しているかを調べる golibs/strutil/strutil.go package strutil func NilOrEmpty(s *string) bool { return s == nil || *s == &#34;&#34; } 文字列を連結する 文字列同士の連結（&#43; 演算子） s1 := &#34;AAA&#34; s2 := s1 + &#34;BBB&#34; //=&gt; &#34;AAABBB&#34; 文字列同士の連結（&#43;= 演算子） s := &#34;AAA&#34; s += &#34;BBB&#34; //=&gt; &#34;AAABBB&#34; 文字列スライスの連結 (strings.Join) // import &#34;strings&#34; ss := []string{&#34;AA&#34;, &#34;BB&#34;, &#34;CC&#34;} result := strings.Join(ss, &#34;-&#34;) //=&gt; &#34;AA-BB-CC&#34; 書式文字列で連結 (strings.Join) str := &#34;ABC&#34; num := 100 result := fmt.Sprintf(&#34;%s%d&#34;, str, num) //=&gt; &#34;ABC100&#34; 効率のよい連続連結 (strings.Builder) // import &#34;strings&#34; var buf strings.Builder // bytes.Buffer buf.WriteString(&#34;AAA&#34;) buf.WriteString(&#34;BBB&#34;) buf.WriteRune(&#39;X&#39;) buf.WriteRune(&#39;Y&#39;) buf.WriteByte(90) // &#39;Z&#39; result := buf.String() //=&gt; &#34;AAABBBXYZ 繰り返し文字列 (string.Repeat) // import &#34;strings&#34; s := strings.Repeat(&#34;X&#34;, 4) //=&gt; &#34;XXXX&#34; 文字列を分割する (strings.Split) 区切り文字列（セパレーター）で分割する (strings.Split) s := &#34;AA, BB, CC&#34; // 単純な分割 ss1 := strings.Split(s, &#34;,&#34;)) //=&gt; [&#34;AA&#34;, &#34; BB&#34;, &#34; CC&#34;] // 単純な分割（最大分割数 N 個） ss2 := strings.SplitN(s, &#34;,&#34;, 2)) //=&gt; [&#34;AA&#34;, &#34; BB, CC&#34;] // 区切り文字列を残す ss3 := strings.SplitAfter(s, &#34;,&#34;)) //=&gt; [&#34;AA,&#34;, &#34; BB,&#34;, &#34; CC&#34;] // 区切り文字列を残す（最大分割数 N 個） ss4 := strings.SplitAfterN(s, &#34;,&#34;, 2) //=&gt; [&#34;AA,&#34;, &#34; BB, CC&#34;] strings.SplitN の最大分割数 n に 0 を指定すると戻り値は nil になります。 n に負の値（-1 など）を指定すると、分割数を制限しません（strings.Split と同じ動作になります）。 分割後に区切り文字列（セパレーター）の前後のスペースを削除するには strings.TrimSpace 関数を使用します。 ss := strings.Split(&#34;AA, BB, CC&#34;, &#34;,&#34;) for i := range ss { ss[i] = strings.TrimSpace(ss[i]) } 区切り文字列として正規表現を使う (regexp.Regexp) 文字列をカンマで分割（カンマの後ろのスペースを削除） re := regexp.MustCompile(`,\\s*`) ss := re.Split(&#34;AA, BB, CC&#34;, -1) //=&gt; [&#34;AA&#34;, &#34;BB&#34;, &#34;CC&#34;] (*Regexp) Split メソッドの第 2 引数には、strings.SplitN と同様に最大分割数を指定します。 最大分割数を制限しないのであれば、-1 を指定しておけば大丈夫です。 2 つに分割する (strings.Cut) 文字列を区切り文字（セパレーター）で高々 2 つに分割する場合は、strings.Split よりも strings.Cut の方が便利かもしれません。 strings.Cut を使うと、分割された 2 つの文字列と、セパレーターが見つかったかどうかを別々の変数で取得できます。 before, after, found := strings.Cut(&#34;AAA, BBB&#34;, &#34;,&#34;) fmt.Println(before) //=&gt; &#34;AAA&#34; fmt.Println(after) //=&gt; &#34; BBB&#34; fmt.Println(found) //=&gt; true スペースや改行で分割する (strings.Fields) ss := strings.Fields(&#34; AA BB\\t\\tCC\\nDD&#34;) //=&gt; [&#34;AA&#34;, &#34;BB&#34;, &#34;CC&#34;, &#34;DD&#34;] strings.Fields 関数は、文字列をスペース系の文字（スペース、タブ、改行）で分割します。 CLI ツール（コマンドラインツール）の出力を加工したいときなどに便利です。 連続するスペースは、1 つのセパレーターとして扱われます。 スペースとみなされる文字は unicode.IsSpace で true と判断される文字です。 文字単位で分割する ss := strings.Split(&#34;ABCあへ&#34;, &#34;&#34;)) //=&gt; [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;あ&#34;, &#34;へ&#34;] strings.Split の区切り文字列（セパレーター）に空文字列を指定すると、UTF-8 文字単位 で分割されます。"},{url:"/p/q6r98p8/",title:"Android エミュレーター内のサーバーに外部からアクセスする (adb forward)",date:"2022-10-21T00:00:00+09:00",body:"Android エミュレーター内のサーバーに外部からアクセスする (adb forward) Android エミュレーターへのポート転送 (adb forward) サーバー機能を持つ Android アプリをエミュレーターで動作させているときに、ホスト PC の外からエミュレーター内のサーバーにアクセスするには、adb forward コマンドによるポート転送の設定が必要です。 例えば、次のようにフォワード設定すると、ホスト PC の 9080 番ポートへのアクセスが、エミュレーターの 8080 番ポートへ転送されるようになります。 PC の 9080 ポートをエミュレーターの 8080 ポートへ転送 $ adb forward tcp:9080 tcp:8080 9080 次の図は、Android エミュレーターを動かしている開発用 PC (192.168.1.1) を経由して、エミュレーター内の Web サーバーにアクセスする構成を示しています。 図: adb forward によるポート転送 外部の端末（PC やスマホ）から見ると、開発 PC (192.168.1.1) 上で Web サーバーが動いているかのように見えます。 Web ブラウザーで http://192.168.1.1:9080 という URL を開けば、エミュレーター内の Web サーバーに繋がります。 開発 PC 上で Web ブラウザーを開いてアクセスする場合は、自分自身にアクセスする形になるので、http://localhost:9080 や http://127.0.0.1:9080 のようなループバックアドレスを指定します。 この構成は、Android アプリ内のサーバープログラムを、PC 上のツールを使ってデバッグしたいときに便利です。 正確に言うと、adb forward によるポート転送はエミュレーター専用というわけではないので、USB で接続されている Android 端末への転送も可能です。 ただ、通常、物理スマホなどは直接 LAN に繋がっていることが多いので、ポート転送が必要になるケースは少ないでしょう（adb shell ip addr で端末のアドレスを確認して直接アクセスした方が早い）。 ちなみに、現在のポート転送設定は adb forward --list コマンドで確認できます。 ポート転送設定の一覧 $ adb forward --list Y7HRR58M60D tcp:9080 tcp:8080 転送設定を削除したいときは、adb forward --remove/--remove-all コマンドを使用します。 ポート転送設定を削除 $ adb forward --remove tcp:9080 # 個別に削除 $ adb forward --remove-all # すべて削除 エミュレーターからホスト PC を参照する エミュレーター内で動くプログラムから、ホスト PC を IP アドレスで参照したいときは、10.0.2.2 という特殊なループバックアドレスを使用します。 localhost や 127.0.0.1 というアドレスは、エミュレーター内のデバイスのループバックアドレスであることに注意してください。 図: エミュレーターからホスト PC を参照する ホスト PC を参照した結果、そのポートが adb forward で転送設定されている場合は、そのパケットはさらに別のエミュレーターに転送されます。 例えば、以下の構成では、Emulator 2 からのホスト PC へのアクセス (10.0.2.2:9080) が、Emulator 1 へポート転送されるようになっているため、結果的にエミュレーター間の通信が実現できています。 図: エミュレーター間の通信 （おまけ）テスト用の Web サーバー実行ファイル 本記事の構成を試してみたいときは、コマンドラインで実行できる簡易 Web サーバーがあると便利です。 下記は、Golang 製の簡単な Web サーバーの実装例です。 ポート番号 8080 で待ち受け、Hello という文字列を返します。 IP アドレス部分に 0.0.0.0 を指定しているのは、外部のネットワークからのアクセスを許可するためです。 hello.go package main import ( &#34;log&#34; &#34;net/http&#34; ) // 0.0.0.0 の部分を省略すると、同一ネットワークからしかアクセスできないので注意 const addr = &#34;0.0.0.0:8080&#34; func main() { http.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, _ *http.Request) { w.Write([]byte(&#34;Hello&#34;)) }) log.Printf(&#34;Serving on: %s\\n&#34;, addr) log.Fatal(http.ListenAndServe(addr, nil)) } 次のような感じでビルドして Android 端末に転送すれば、Web サーバーを起動できます。 $ GOOS=linux GOARCH=arm go build -o hello hello.go $ adb push hello /data/local/tmp $ adb shell /data/local/tmp/hello 2022/10/21 20:25:47 Serving on HTTP port: 8080 Web サーバーを停止したいときは、Ctrl + C で終了するだけで OK です。 ホスト PC 上で別のターミナルを開いて、ポート転送設定 (adb forward) すれば、ホスト PC の IP アドレスを使って Web サーバーにアクセスできるはずです。 $ adb forward tcp:9080 tcp:8080 9080 $ curl localhost:9080 Hello ネットワークまわりのテストをしたいときに便利です ٩(๑❛ᴗ❛๑)۶ わーぃ 参考: Golang で Android 上で動く CLI コマンドを作成する (go build)"},{url:"/p/ftducta/",title:"Golang で Android 上で動く CLI コマンドを作成する (go build)",date:"2022-10-21T00:00:00+09:00",body:"Golang で Android 上で動く CLI コマンドを作成する (go build) 何をするか？ Golang（Go 言語）のクロスコンパイル機能を使うと、Android 上で動作するコマンドラインツール (CLI) を簡単に作成することができます。 Android 端末上で何らかの解析をするときに、Android 組み込みの Linux コマンドだとちょっと足りないな、といったときに便利です。 ここでは、Golang で簡単な Hello World アプリをビルドして、Android 端末上で動かしてみます。 Go 言語全般に関してはこちらを参照 → まくまく Golang ノート Android 端末の CPU アーキテクチャを確認しておく Golang でのクロスコンパイル時に CPU アーキテクチャを指定する必要があるので、対象の Anrdoid 端末のアーキテクチャを先に確認しておきます。 adb shell で Android 端末にシェル接続して、uname -a コマンドの末尾あたりで確認してしまうのが手っ取り早いです。 $ adb shell uname -a Linux localhost 5.10.100 #1 SMP PREEMPT Thu Mar 17 17:10:36 UTC 2022 aarch64 arm や aarch という文字列が入っていたら、ARM アーキテクチャの CPU だと思ってよいです。 Golang プログラムをビルドする 下記は、Golang の Hello World プログラムです。 hello.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello World&#34;) } Android 端末上で動く実行ファイルを生成するために、GOOS 環境変数で linux、GOARCH 環境変数で arm を指定してビルドします。 ちなみに、エミュレーター用にビルドするのであれば、おそらくアーキテクチャの指定は必要ないです。 Anrdoid 用にビルド（Linux/macOS の場合） $ GOOS=linux GOARCH=arm go build -o hello hello.go Anrdoid 用にビルド（Windows の場合） &gt; set GOOS=linux &gt; set GOARCH=arm &gt; go build -o hello hello.go これで、実行ファイル hello が生成されます。 Android 端末上で実行ファイルを起動する 作成した実行ファイル (hello) を adb push で Android 端末に転送し、Android 端末上で実行してみます。 転送先ディレクトリとしては、アクセス制限の緩い /data/local/tmp を使います。 # hello を転送する $ adb push hello /data/local/tmp # hello を実行する $ adb shell chmod +x /data/local/tmp/hello $ adb shell /data/local/tmp/hello Hello World うまく動きました ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/uft7jv9/",title:"Golang で MongoDB を扱う (go.mongodb.org/mongo-driver)",date:"2022-10-16T00:00:00+09:00",body:"Golang で MongoDB を扱う (go.mongodb.org/mongo-driver) Golang を使って MongoDB サーバーに接続する方法の説明です。 Golang 用の MongoDB ドライバー go.mongodb.org/mongo-driver/mongo モジュールは、Golang 用の MongoDB 公式ドライバーです。 Golang のプロジェクトをモジュールモードで初期化して、go get で依存関係を追加すれば MongoDB にアクセスする準備は完了です。 $ mkdir example-mongo $ cd example-mongo $ go mod init example-mongo $ go get go.mongodb.org/mongo-driver/mongo MongoDB サーバーの準備 接続先の MongoDB サーバーはローカルで起動しておくか、MongoDB Atlas などのクラウドサービスで用意しておいてください。 参考: MongoDB 関連記事｜まくろぐ 以下の説明では、localhost:27017 で MongoDB サーバーが稼働していることを想定しています。 MongoDB に接続する MongoDB へ接続するためのクライアント設定は、options.ClientOptions インスタンスで表現します。 このインスタンスは options.Client() 関数で生成できるので、あとは各種セッターメソッドでオプション指定していきます。 MongoDB Atlas などのサービスを使っているのであれば、接続文字列が提供されているはずなので、それをそのまま ApplyURI メソッドに渡してやるだけで最低限の接続設定は完了します（参考: 接続文字列の形式）。 main.go（localhost:27017 への接続例） package main import ( &#34;context&#34; &#34;fmt&#34; &#34;log&#34; &#34;go.mongodb.org/mongo-driver/mongo&#34; &#34;go.mongodb.org/mongo-driver/mongo/options&#34; ) // MongoDB サーバーの接続文字列 const uri = &#34;mongodb://localhost:27017&#34; func main() { ctx := context.Background() // 接続文字列の設定 opt := options.Client().ApplyURI(uri) if err := opt.Validate(); err != nil { log.Fatal(err) } // MongoDB サーバーへの接続 client, err := mongo.Connect(ctx, opt) if err != nil { log.Fatal(err) } // 関数を抜けるときに自動クローズ defer func() { if err := client.Disconnect(ctx); err != nil { log.Fatal(err) } }() // Ping してみる if err := client.Ping(ctx, nil); err != nil { log.Fatal(err) } fmt.Println(&#34;Ping to MongoDB server succeeded&#34;) } 実行結果 $ go run . Connected to MongoDB クラス化で見通しをよくする 次のように構造体で mongo.Client インスタンスを保持するようにすれば、コレクション操作などをメソッドの形にまとめることができます。 接続先のアドレスを MONGODB_URI のような環境変数で設定できるようにしておくと、様々な環境で実行できるプログラムになります。 db/mydb.go package db import ( &#34;context&#34; &#34;log&#34; &#34;os&#34; &#34;go.mongodb.org/mongo-driver/mongo&#34; &#34;go.mongodb.org/mongo-driver/mongo/options&#34; ) type MyDb struct { client *mongo.Client } func (db *MyDb) getUri() (uri string) { uri = os.Getenv(&#34;MONGODB_URI&#34;) if uri == &#34;&#34; { log.Println(&#34;Env variable `MONGODB_URI` is not set, use `mongodb://localhost:27017` instead.&#34;) uri = &#34;mongodb://localhost:27017&#34; } return uri } func (db *MyDb) Connect(ctx context.Context) (err error) { opt := options.Client().ApplyURI(db.getUri()) if err = opt.Validate(); err != nil { return err } db.client, err = mongo.Connect(ctx, opt) return err } func (db *MyDb) Disconnect(ctx context.Context) error { return db.client.Disconnect(ctx) } // （テスト用）接続確認 func (db *MyDb) Ping(ctx context.Context) (err error) { if err = db.client.Ping(ctx, nil); err != nil { return err } fmt.Println(&#34;Ping to MongoDB server succeeded&#34;) return nil } main.go package main import ( &#34;context&#34; &#34;log&#34; &#34;time&#34; &#34;example-mongo/db&#34; ) func main() { ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() // MongoDB サーバーへの接続 mydb := &amp;db.MyDb{} if err := mydb.Connect(ctx); err != nil { log.Fatal(err) } defer mydb.Disconnect(ctx) // Ping してみる if err := mydb.Ping(ctx); err != nil { log.Fatal(err) } } BSON 形式について MongoDB はコレクション内のドキュメントを、BSON 形式 で保存しています。 BSON は JSON をバイナリ形式にして効率的なやりとりを行えるようにしたフォーマットです。 Golang で MongoDB のデータ操作を行うには、次のような変換処理 (marshalling/unmarshalling) が必要です。 Marshalling &hellip; 「Golang オブジェクト → BSON」の変換 Unmarshalling &hellip; 「BSON → Golang オブジェクト」の変換 この変換処理には、MongoDB 公式の mongo-driver パッケージに含まれている bson モジュールが使用されます。 import &#34;go.mongodb.org/mongo-driver/bson&#34; Golang の struct（構造体）を marshal/unmarshal しようとすると、公開された（大文字で始まる）フィールドのみ が変換対象になります。 また、BSON キー名は、struct のフィールド名を すべて小文字に変換したもの になります。 type Book struct { Title string // BSON キー名は &#34;title&#34; になる Authors []string // BSON キー名は &#34;authors&#34; になる } デフォルトの変換ルールでは不十分なときは、Golang の struct tags の仕組み を使うことで、ある程度カスタマイズできます。 type Student struct { FirstName string `bson:&#34;first_name,omitempty&#34;` LastName string `bson:&#34;last_name,omitempty&#34;` Address Address `bson:&#34;inline&#34;` Age int } 例えば上記のようにタグ指定しておけば、FirstName フィールドの BSON キー名は firstname ではなく first_name になり、ゼロ値のときは空文字列 (&quot;&quot;) が保存されるのではなく BSON キー自体が省略されます。 Address 構造体の各フィールドはフラット化されて、FirstName や LastName と同じ階層に保存されます。 コレクションを操作する MongoDB サーバーへの接続が済んだら、あとは mongo.Collection の各種メソッドを使って、コレクション内のドキュメントを操作できます。 コレクションにドキュメントを追加する (InsertOne) 次の例では、testdb データベースの books コレクションに、Book 構造体のデータを保存しています。 // MongoDB のコレクションに格納するドキュメントの型 type Book struct { Title string Authors []string `bson:&#34;omitempty&#34;` } // 追加するドキュメントを生成 book := &amp;Book{Title: &#34;Title-1&#34;} // 追加を実行 (InsertOne) result, err := client.Database(&#34;testdb&#34;).Collection(&#34;books&#34;).InsertOne(ctx, book) if err != nil { log.Fatal(err) } log.Printf(&#34;Book inserted %v\\n&#34;, result) コレクションから 1 つのドキュメントを取得する (FindOne) 次の例では、books コレクションから、title キーが Title-1 に一致するドキュメントを検索しています。 FindOne メソッドは、指定した条件（フィルター）に一致するドキュメントが複数あっても、1 つのドキュメントのみを返します。 検索フィルターとして使っている bson.M 構造体は、マップ形式の BSON データを表現するためのものです。 // 検索フィルター filter := &amp;bson.M{&#34;title&#34;: &#34;Title-1&#34;} // 検索を実行 (FindOne) result := client.Database(&#34;testdb&#34;).Collection(&#34;books&#34;).FindOne(filter) // 結果をデコードして Golang オブジェクトとして参照する var book Book if err := result.Decode(&amp;book); err != nil { log.Fatal(err) } log.Printf(&#34;%#v\\n&#34;, book) コレクションから複数のドキュメントを取得する (Find) フィルターで指定した条件に一致するすべてのドキュメントを取得したいときは、FindOne の代わりに Find メソッドを使用します。 Find メソッドは、*mongo.Cursor オブジェクトを返すので、これを使って取得した複数のドキュメントを参照できます。 ドキュメント内のすべてのドキュメントを取得したいときは、Find メソッドに空っぽのフィルター (bson.D{}) を指定します。 // 検索フィルター（すべてのドキュメントを取得する場合） filter := &amp;bson.D{} // 検索を実行 (Find) coll := client.Database(&#34;testdb&#34;).Collection(&#34;books&#34;) cursor, err := coll.Find(ctx, filter) // 結果をデコードして Golang オブジェクトとして参照する var books []Book if err := cursor.All(ctx, &amp;books); err != nil { log.Fatal(err) } log.Printf(&#34;%#v\\n&#34;, books) 関連リンク Deno で MongoDB を扱う Rust で MongoDB を扱う (mongodb)"},{url:"/p/wdvdtap/",title:"gqlgen で子フィールドの情報を返すリゾルバーを実装する",date:"2022-10-05T00:00:00+09:00",body:"gqlgen で子フィールドの情報を返すリゾルバーを実装する 何をするか？ Golang の GraphQL ライブラリである gqlgen を使って、GraphQL スキーマからサーバー実装用のコードを自動生成するときに、オブジェクト型の子フィールド用のリゾルバーを生成する方法を説明します。 gqlgen の基本的な使い方は下記を参照してください。 参考: GraphQL サーバーを作成する (gqlgen) デフォルト設定でコード生成した場合 ここでは、入力用の GraphQL スキーマとして次のようなファイルを使うことにします。 オブジェクト型として Book と Author があり、Author は Book の author フィールドとしてのみ使用されています。 graph/schema.graphqls type Query { books: [Book!]! } type Book { id: ID! title: String! author: Author } type Author { id: ID! name: String! } gqlgen generate すると、次のようなモデル（型情報）コードが生成されます。 graph/model/models_gen.go // Code generated by github.com/99designs/gqlgen, DO NOT EDIT. package model type Author struct { ID string `json:&#34;id&#34;` Name string `json:&#34;name&#34;` } type Book struct { ID string `json:&#34;id&#34;` Title string `json:&#34;title&#34;` Author *Author `json:&#34;author&#34;` } さらに、リゾルバーのテンプレートコードとして次のようなメソッドが自動生成されるのですが、デフォルトの設定 (gqlgen.yml) では、Query 型のフィールドに対応するリゾルバーメソッドしか生成されません。 例えば、今回のスキーマの場合 books フィールドを取得するためのリゾルバーメソッドのみが生成されます。 graph/schema.resolvers.go（抜粋） // Books is the resolver for the books field. func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { panic(fmt.Errorf(&#34;not implemented: Books - books&#34;)) } ちなみに、上記メソッドシグネチャ内の、queryResolver と Books という名前は、「Query オブジェクト型の books フィールドを取得するためのリゾルバー」であることを示しています。 Book オブジェクト型の author フィールドを取得するためのリゾルバーは生成されないので、books フィールド用のリゾルバー実装だけで、すべての子フィールドのデータを返すように実装しなければいけません。 例えば、2 つの書籍データを返すリゾルバー実装は次のような感じになります（強引にハードコードしてます）。 func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { // フェイクデータ（本当は別パッケージ化して db.GetBooks() のようにすべき） books := []*model.Book{ { ID: &#34;book-id-1&#34;, Title: &#34;Book title 1&#34;, Author: &amp;model.Author{ID: &#34;author-id-1&#34;, Name: &#34;Author name 1&#34;}, }, { ID: &#34;book-id-2&#34;, Title: &#34;Book title 2&#34;, Author: &amp;model.Author{ID: &#34;author-id-2&#34;, Name: &#34;Author name 2&#34;}, }, } return books, nil } オブジェクト型のフィールドがこれくらいシンプルであれば何とかなるのですが、入れ子構造が深くなってくると、子孫フィールドをすべて処理しなければならず大変です。 また、上記の例では、クライアントから author フィールドが要求されているかどうかにかかわらず著者情報を DB からフェッチしており（今回はハードコードですが）、それも無駄です。 さらに、フィールドに検索やフィルタ用の引数が追加されたら、その引数に応じたデータフェッチ処理を行わなければならず、ますます複雑になってきます。 クライアントから実際に指定されたフィールド引数の値は、リゾルバーのパラメーターとして渡される context.Context オブジェクトを使って graphql.GetFieldContext(ctx) のようにすれば参照できるのですが、これはこれで大変です。 author フィールド用のリゾルバーを、別メソッドとして定義できれば、実装がぐっと楽になります。 フィールド用のリゾルバーを生成する やりたいことは、GraphQL スキーマで定義した Book オブジェクト型の author フィールドの専用リゾルバーを生成する、ということです。 そのためには、gqlgen の設定ファイル (gqlgen.yml) の models プロパティで次のように設定します。 gqlgen.yml（抜粋） models: Book: fields: author: resolver: true # ... 「Book 型のフィールドである author のリゾルバーを生成する」という設定です。 そのまんまですね。 このように設定した状態で、gqlgen generate を実行すると、リゾルバーのテンプレートとして次のようなコードが生成されるようになります。 graph/schema.resolvers.go（抜粋） // Author is the resolver for the author field. func (r *bookResolver) Author(ctx context.Context, obj *model.Book) (*model.Author, error) { panic(fmt.Errorf(&#34;not implemented: Author - author&#34;)) } // Books is the resolver for the books field. func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { panic(fmt.Errorf(&#34;not implemented: Books - books&#34;)) } Book オブジェクト型の author フィールドを処理するための専用のリゾルバーメソッド (*bookResolver) Author が生成されたので、books リゾルバー側の実装では author フィールドを処理する必要がなくなります。 下記はフェイクデータを使用したリゾルバー実装例です。 // Author is the resolver for the author field. func (r *bookResolver) Author(ctx context.Context, obj *model.Book) (*model.Author, error) { // author フィールド用のフェイクデータ（親オブジェクト型 Book の情報を利用して実装できる） author := &amp;model.Author{ ID: &#34;author-id-&#34; + obj.ID, Name: &#34;Author name of &#34; + obj.Title, } return author, nil } // Books is the resolver for the books field. func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) { // books フィールド用のフェイクデータ（ここで author フィールドのデータは返さなくてよい） books := []*model.Book{ {ID: &#34;book-id-1&#34;, Title: &#34;Book title 1&#34;}, {ID: &#34;book-id-2&#34;, Title: &#34;Book title 2&#34;}, } return books, nil } 前述の (*queryResolver) Books リゾルバーのみを使った実装よりも、だいぶ分かりやすくなったと思います。 もちろん、クライアントから author フィールドを要求されなかった場合は、(*bookResolver) Author リゾルバーが呼び出されることはないので、余計な DB フェッチが行われる心配もありません。 バッチシですね！ ちなみに、フィールド引数を扱うときもほぼ同様の実装で対応できます。 例えば、GraphQL スキーマの Book オブジェクト型の author フィールドに、次のような realName パラメータを追加したとします（本名を取得するためのフラグのつもり）。 graph/schema.graphqls type Book { id: ID! title: String! author(realName: Boolean = false): Author } すると、author フィールド用のリゾルバーメソッドのパラメーターにも realName が追加されるので、その情報を使ってリゾルバーを実装することができます。 graph/schema.resolvers.go（抜粋） // Author is the resolver for the author field. func (r *bookResolver) Author(ctx context.Context, obj *model.Book, realName *bool) (*model.Author, error) { // Book 型の author フィールドの値を構築（本当は DB などからフェッチ） name := &#34;Author name of &#34; + obj.Title if *realName { name += &#34; (REAL NAME)&#34; } author := &amp;model.Author{ ID: &#34;author-id-&#34; + obj.ID, Name: name, } return author, nil } 言語仕様上、Golang 関数の realName パラメーターではデフォルト値が表現できていませんが、クライアントからのクエリで realName 引数が省略された場合は、ちゃんと GraphQL スキーマで定義されたデフォルト値（今回は false) を受け取れるようになっています（これは gqlgen フレームワーク側の仕組みです）。 完璧ですね！"},{url:"/p/cp8o6m2/",title:"Golang のジェネリクスで複数の型を扱える関数を定義する (generics)",date:"2022-09-25T00:00:00+09:00",body:"Golang のジェネリクスで複数の型を扱える関数を定義する (generics) Golang のジェネリクスを使用すると、複数の型を扱う関数を定義できます。 ジェネリクスは別の言語ではごく一般的な機能として提供されていますが、シンプルな言語仕様を理想としている Golang では当初提供されていませんでした。 ただ、ジェネリクスを望む声は多く、Golang ver 1.8 で導入されることになりました。 ジェネリクスを使わない場合 次のコードの SumInt64 関数と SumFloat64 関数は、両方とも数値スライスの要素を足し合わせる関数ですが、パラメーターの型が int64 と float64 で異なっているため、別々の関数として定義しています。 package main import &#34;fmt&#34; // int64 スライスの全要素を足し合わせた結果を返します。 func SumInt64(vals []int64) int64 { var sum int64 for _, v := range vals { sum += v } return sum } // float64 スライスの全要素を足し合わせた結果を返します。 func SumFloat64(vals []float64) float64 { var sum float64 for _, v := range vals { sum += v } return sum } func main() { fmt.Println(SumInt64([]int64{100, 200, 300})) //=&gt; 600 fmt.Println(SumFloat64([]float64{0.1, 0.2, 0.3})) //=&gt; 0.6 } でも、SumInt64 と SumFloat64 の実装はほぼ同じなので、別の関数として実装するのは無駄な気がします。 さらに悲しいことに、次のように定義された MyInt 型のスライスを SumInt64 関数に渡そうとしてもエラーになります。 type MyInt int64 fmt.Println(SumInt64([]MyInt{1, 2, 3})) // エラー（MyInt は int64 ではない） そこで、ジェネリクスの出番です。 ジェネリクスの基本 ジェネリクス対応の関数を定義するには、関数名の後ろにブラケット ([]) で囲んだ 型パラメーター (type parameters) を記述し、その型を関数内で使用します。 次の Sum 関数は、int64 と float64 のどちらの型のスライスでも引数に指定できるようにしています。 // 数値型スライスの全要素を足し合わせた結果を返します。 func Sum[T int64 | float64](vals []T) T { var sum T for _, v := range vals { sum += v } return sum } [T int64 | float64] という型パラメーターは、int64 と float64 のいずれかである型 T を定義しています。 型 T が実際にどの型として扱われるかは、コンパイル時に判断されます。 型 T は、関数のパラメータ、戻り値、本体の実装のどの部分でも使用することができます。 ジェネリクス対応した関数は、通常の関数と同じように呼び出すことができます。 ints := []int64{100, 200, 300} fmt.Println(Sum(ints)) //=&gt; 600 floats := []float64{0.1, 0.2, 0.3} fmt.Println(Sum(floats)) //=&gt; 0.6 めでたし、めでたし！ といきたいところですが、ここで注意しないといけないのは、[T int64 | float64] のような型パラメータは、正確に int64 型と float64 型のどちらかしか扱えないということです。 例えば、次のように定義した MyInt 型を使おうとするとエラーになります。 type MyInt int64 ints := []MyInt{100, 200, 300} fmt.Println(Sum(ints)) // エラー (ノ_・、) MyInt の本質的な型は int64 なのに、それを Sum 関数で受け取れないのは悲しすぎます。 この問題に対応するために、Golang は 基礎型 (underlying type) という概念を導入しました。 上記の場合、MyInt の underlying type は int64 です。 型パラメーターにおいて、underlying type が int64 である型を示すためには、前にチルダを付けて、~int64 のように表現します。 次の Sum 関数の型パラメーター T は、underlying type が int64 あるいは float64 である型を扱うことができます。 func Sum[T ~int64 | ~float64](vals []T) T { // ... } func main() { type MyInt int64 ints := []MyInt{100, 200, 300} fmt.Println(Sum(ints)) //=&gt; 600（MyInt スライスを渡せた！） } 型パラメーターの定義するときは、利便性を考慮して underlying type で指定することが多くなると思います。 呼び出し時に型引数が必要な場合 前述のような型パラメーター T の実際の型はコンパイル時に自動的に判断（推測）されますが、呼び出し時に明示的に型を指定しないといけないケースがあります。 典型的には、引数から型パラメーターの型が推測できないケースです。 次のサンプルコードの MakeRandomSlice 関数は、指定したサイズのランダムなスライスを生成する関数ですが、生成すべきスライス要素の型 T は、size 引数からは推測できません。 そこで、呼び出し時に MakeRandomSlice[int32](3) のように、どの型のスライスを生成するかを明示してやる必要があります。 このブラケットで囲んだ [int32] の部分を、型引数 (type arguments) と呼びます。 package main import ( &#34;crypto/rand&#34; &#34;encoding/binary&#34; &#34;fmt&#34; ) // 指定した型、サイズのランダムスライスを生成します。 func MakeRandomSlice[T ~int32 | ~float32](size int) []T { var vals = make([]T, 0, size) var v T for i := 0; i &lt; size; i++ { binary.Read(rand.Reader, binary.LittleEndian, &amp;v) vals = append(vals, v) } return vals } func main() { // int32 型のランダムスライスを生成する ints := MakeRandomSlice[int32](3) fmt.Println(ints) //=&gt; [-717388130 -1507011086 854848415] // float32 型のランダムスライスを生成する floats := MakeRandomSlice[float32](3) fmt.Println(floats) //=&gt; [4.4246736e+08 7.834249e-16 1.5574595e+29] } 制約インタフェース (constraint interface) 浮動小数点数を扱う型パラメーターは、次のような感じで定義できますが、複数の関数でこのような記述を毎回行うのは面倒です。 [T ~float32 | ~float64] 次のようなインタフェース型を定義しておくと、型パラメーターをシンプルに記述できるようになります。 Golang のチュートリアルでは、こういったインタフェースのことを、制約インタフェース (constraint interface) と呼んでいます。 type Float interface { ~float32 | ~float64 } このように定義した制約インタフェース Float は、次のように型パラメーター部分で使用できます。 func Max[T Float](a, b T) T { if a &gt; b { return a } return b } 実は、こういった基本的な型の制約インタフェースは、公式の constraints パッケージ で定義されています。 type Signed interface { ~int | ~int8 | ~int16 | ~int32 | ~int64 } type Unsigned interface { ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr } type Integer interface { Signed | Unsigned } type Float interface { ~float32 | ~float64 } type Complex interface { ~complex64 | ~complex128 } type Ordered interface { Integer | Float | ~string } 次のサンプルコードでは、constraints パッケージが提供する constraints.Ordered 制約インタフェースを使用しています。 このインタフェースは、大小比較が可能な基本型を表現しています（これには string 型も含まれます）。 package main import ( &#34;fmt&#34; &#34;golang.org/x/exp/constraints&#34; ) func Max[T constraints.Ordered](a, b T) T { if a &gt; b { return a } return b } func main() { fmt.Println(Max(100, 200)) //=&gt; 200 fmt.Println(Max(&#34;A&#34;, &#34;B&#34;)) //=&gt; B } 複数の型パラメーター 1 つの関数で複数の型パラメーターを扱いたいときは、カンマ (,) で区切って並べます。 次の Sum 関数は、数値型の値を持つマップを受け取り、その値の合計値を返します。 package main import &#34;fmt&#34; type Number interface { ~int64 | ~uint64 | ~float64 } // マップの値を足し合わせます。 func Sum[K comparable, V Number](m map[K]V) V { var sum V for _, v := range m { sum += v } return sum } func main() { ints := map[string]int64{ &#34;AAA&#34;: 1, &#34;BBB&#34;: 2, &#34;CCC&#34;: 3, } fmt.Println(Sum(ints)) //=&gt; 6 } comparable というのは、Golang 組み込みのインタフェース型であり、このように型パラメーター部分で使うことが想定されています。 comparable は、その値が == や != で比較することが可能であることを示しており、これはつまり、マップのキーとして扱える型であることを示しています。"},{url:"/p/graq8o5/",title:"Golang でランダム値（乱数）を扱う (math/rand, crypto/rand)",date:"2022-09-24T00:00:00+09:00",body:"Golang でランダム値（乱数）を扱う (math/rand, crypto/rand) Golang でランダム値を扱うパッケージは以下の 2 つが用意されています。 math/rand &hellip; 擬似乱数生成器 (pseudo-random number generator)。初期化のための Seed によって生成される一連の乱数が決定するため、再現性がある。高速な生成が可能だが、生成されるランダム値が予測され得るため、暗号系技術での使用には適さない。 crypto/rand &hellip; 暗号論的擬似乱数生成器（CSPRNG: cryptographically secure pseudo random number generator)。生成されるランダム値を予測するのが困難で、暗号系技術での使用に適している。例えば、秘密鍵の生成や、Nonce 値の生成に用いることができる。math/rand に比べ、crypto/rand でのランダム値生成は時間がかかる。 math/rand による乱数生成 math/rand パッケージのランダム生成器 (*rand.Rand) は、rand.New コンストラクタで生成します。 典型的には、現在時刻を元にしたシードを与えて初期化します。 *rand.Rand を生成する方法 seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) val := r.Float64() // 乱数を生成（rand.Rand のメソッド） あるいは、rand.Seed 関数で、トップレベル関数用のシードを設定することもできます。 こちらの方法を使う場合は、*rand.Rand インスタンスを生成する必要はありません。 トップレベル関数用のシードを設定する方法 seed := time.Now().UnixNano() rand.Seed(seed) val := rand.Float64() // 乱数を生成（rand のトップレベル関数） math/rand パッケージは、次のような乱数生成関数を提供しています。 メソッド 説明 戻り値の型 値の範囲 Int31() 0 以上の 31 ビット整数 int32 0 〜 2,147,483,647 Int31n(n) 0 以上 n 未満の 31 ビット整数 int32 0 〜 n（n ≧ 1） Uint32() 0 以上の 32 ビット整数 uint32 0 〜 4,294,967,295 Int63() 0 以上の 63 ビット整数 int64 0 〜 9,223,372,036,854,775,807 Int63n(n) 0 以上 n 未満の 63 ビット整数 int64 0 〜 n（n ≧ 1） Uint64() 0 以上の 64 ビット整数 uint64 0 〜 18,446,744,073,709,551,615 Int() 0 以上の整数（少なくとも 32 ビット） int 0 〜 システム依存 Intn(n) 0 以上 n 未満の整数（少なくとも 32 ビット） int 0 〜 n（n ≧ 1） Float32() 浮動小数点数（float32 型） float32 [0.0, 1.0)（0.0 以上 1.0 未満） Float64() 浮動小数点数（float64 型） float64 [0.0, 1.0)（0.0 以上 1.0 未満） math/rand による乱数生成の例 package main import ( &#34;fmt&#34; &#34;math/rand&#34; &#34;time&#34; ) func main() { seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) fmt.Println(r.Int31()) // 1401608483 (int32) fmt.Println(r.Uint32()) // 3362137694 (uint32) fmt.Println(&#34;-------&#34;) fmt.Println(r.Int63()) // 9200732467715261966 (int64) fmt.Println(r.Uint64()) // 17815840155156866386 (uint64) fmt.Println(&#34;-------&#34;) fmt.Println(r.Float32()) // 0.34179267 (float32) fmt.Println(r.Float64()) // 0.7233553795829966 (float64) fmt.Println(&#34;-------&#34;) fmt.Println(r.Int31n(10000)) // 1451 (int32) fmt.Println(r.Int63n(10000)) // 7504 (int64) } Read(p []byte) メソッドを使用すると、任意の長さのバイト配列を生成することができます。 4 バイト分のランダム配列を生成 bytes := make([]byte, 4) r.Read(bytes) fmt.Println(bytes) // [231 52 121 45] crypto/rand による乱数生成 予測の難しい乱数値が欲しいときは、math/rand パッケージの代わりに crypto/rand を使用します。 パッケージ内部の乱数生成には、Linux 系 OS では /dev/urandom や getentropy(2)、Windows では RtlGenRandom API が使われています。 次の例では、rand.Int 関数を使って、0 以上 n 未満のランダム整数 (*big.Int) を生成しています。 シードによる初期化は必要ありません。 package main import ( &#34;crypto/rand&#34; &#34;fmt&#34; &#34;math/big&#34; ) func main() { // 0 以上 n 未満のセキュアなランダム整数を生成 var n int64 = 1_000_000_000 val, err := rand.Int(rand.Reader, big.NewInt(n)) if err != nil { panic(err) } fmt.Println(val.Int64()) //=&gt; 721357881 } crypto/rand パッケージは、math/rand ほど柔軟なランダム生成関数を備えていませんが、encoding/binary パッケージと組み合わせて使用すると、任意の型にランダム値を詰めることができます。 package main import ( &#34;crypto/rand&#34; &#34;encoding/binary&#34; &#34;fmt&#34; ) func main() { var v int32 // 任意の型を指定可能 binary.Read(rand.Reader, binary.LittleEndian, &amp;v) fmt.Println(v) //=&gt; 2017071203 } math/rand と同様、crypto/rand でも指定した長さのバイト配列を生成することができます。 func main() { bytes := make([]byte, 4) rand.Read(bytes) fmt.Println(bytes) //=&gt; [235 16 197 104] } （応用）crypto/rand で math/rand のシードを生成する 現在時刻を math/rand のシードに使うのは抵抗があるけど、crypto/rand ほどセキュアな乱数は必要ないという場合は、シードの生成のみを crypto/rand で行うという方法があります。 main.go package main import ( cryptorand &#34;crypto/rand&#34; &#34;encoding/binary&#34; &#34;fmt&#34; &#34;math/rand&#34; ) // 予測困難なシードで math/rand を初期化 func initRandomSeed() { var seed int64 if err := binary.Read(cryptorand.Reader, binary.LittleEndian, &amp;seed); err != nil { panic(err) } rand.Seed(seed) } func main() { initRandomSeed() for i := 0; i &lt; 20; i++ { fmt.Print(rand.Intn(10), &#34; &#34;) // 0 〜 9 のランダム整数を生成 } fmt.Println() } 実行結果 $ go run main.go 9 8 9 7 3 3 0 2 1 4 9 9 2 6 1 6 0 5 8 1 （応用）ランダムな文字列を生成する 次の RandomId 関数は、指定した長さのランダムな文字列を生成します（例: m6t2j7a）。 strutil/strutil.go package strutil import ( cryptorand &#34;crypto/rand&#34; &#34;encoding/binary&#34; &#34;fmt&#34; &#34;math/rand&#34; &#34;os&#34; &#34;time&#34; ) func init() { initRandomSeed() } // 指定した長さのランダム文字列を生成します func RandomId(length int) string { const CANDIDATES = &#34;23456789abcdefghijkmnopqrstuvwxyz&#34; const LEN_CAND = len(CANDIDATES) bytes := make([]byte, 0, length) // 必要な capacity は明確 for i := 0; i &lt; length; i++ { bytes = append(bytes, CANDIDATES[rand.Intn(LEN_CAND)]) } return string(bytes) } // 予測困難なシードで math/rand を初期化します func initRandomSeed() { var seed int64 if err := binary.Read(cryptorand.Reader, binary.LittleEndian, &amp;seed); err != nil { fmt.Fprintln(os.Stderr, &#34;WARN: Seed creation by crypto/rand failed, so current time was used instead&#34;) seed = time.Now().UnixNano() } rand.Seed(seed) } main.go（使用例） package main import ( &#34;fmt&#34; &#34;hello/strutil&#34; ) func main() { fmt.Println(strutil.RandomId(7)) //=&gt; &#34;m6t2j7a&#34; } 参考: ランダム ID 生成ツール｜まくろぐ"},{url:"/p/egs2bjt/",title:"Golang でカレントディレクトリ、実行ファイルのパスを取得する (os.Getwd, os.Executable)",date:"2022-09-23T00:00:00+09:00",body:"Golang でカレントディレクトリ、実行ファイルのパスを取得する (os.Getwd, os.Executable) カレントディレクトリのパス (os.Getwd) Golang でカレントディレクトリのパスを取得するには、os.Getwd 関数 を使用します。 戻り値は、カレントディレクトリを示す 絶対パス（フルパス） の文字列になります。 カレントディレクトリは、go run コマンドなどを実行したときのディレクトリのことであり、.go ファイルのあるパスではないことに注意してください。 main.go package main import ( &#34;fmt&#34; &#34;os&#34; ) func main() { dir, err := os.Getwd() if err != nil { panic(err) } fmt.Println(dir) } 実行結果 $ cd /Users/maku/hello $ go run main.go /Users/maku/hello $ cd /Users/maku $ go run hello/main.go /Users/maku 実行中のファイルのパス (os.Executable) 実行中のファイル (executable) のフルパスを取得するには、os.Executable 関数 を使用します。 main.go package main import ( &#34;fmt&#34; &#34;os&#34; ) func main() { path, err := os.Executable() if err != nil { panic(err) } fmt.Println(path) } 実行結果 $ cd ~/hello $ go build -o myexe main.go $ ./myexe /Users/maku/hello/myexe go run コマンドで .go ファイルを指定して実行した場合は、内部的にビルドされて生成された実行ファイルのパスが表示されます。 $ go run main.go /var/folders/g7/08g8xg4x7_lb3k_tgpwwdfmr0000gn/T/go-build9032354/b001/exe/main 応用例として、実行ファイルのあるディレクトリのパスを取得したい場合は、filepath.Dir 関数を組み合わせて使用します。 package main import ( &#34;fmt&#34; &#34;os&#34; &#34;path/filepath&#34; ) func main() { exePath, err := os.Executable() if err != nil { panic(err) } exeDir := filepath.Dir(exePath) fmt.Println(exePath) //=&gt; /Users/maku/hello/myexe fmt.Println(exeDir) //=&gt; /Users/maku/hello } 実行ファイルと同じディレクトリにあるリソースファイルのパスを構築したければ、以下のように filepath.Join でパスを繋ぎます。 dataPath := filepath.Join(exeDir, &#34;data.txt&#34;) //=&gt; /Users/maku/hello/data.txt とはいえ、前述の通り、os.Executable が返すパスは、go run main.go のように .go ファイルを指定して実行した場合はおそらく想定外のものになるので、リソースファイルのパスはコマンドライン引数や環境変数で指定するのが無難です。 参考: Golang でコマンドライン引数を扱う (os.Args, flags) 参考: Golang で環境変数を扱う (os.Getenv, os.LookupEnv)"},{url:"/p/6k5m3iz/",title:"Golang で CSV 形式の文字列やファイルを扱う (encoding/csv)",date:"2022-09-20T00:00:00+09:00",body:"Golang で CSV 形式の文字列やファイルを扱う (encoding/csv) Golang 標準パッケージの encoding/csv を使用すると、CSV 形式のテキストやファイルを Golang の string 配列で読み書きできます。 CSV はカンマ区切りの単純なフォーマットなので、自力でテキストファイルを読み書きすれば済んでしまいそうですが、改行やダブルクォート (&quot;) 含むフィールドの扱い方 (RFC 4180) など、微妙に考慮しないといけない部分もあるので、やはり専用の Reader/Writer 実装を使った方が安心です。 import &#34;encoding/csv&#34; このパッケージは、主に次のクラスを提供しています。 csv.Reader &hellip; CSV の読み出しに使用 csv.Writer &hellip; CSV の書き込みに使用 パッケージ名に csv という名前が使われていますが、オプション指定によりタブ区切り形式の TSV データを扱うこともできます（後述）。 CSV ファイル／テキストを読み出す (csv.Reader) CSV 形式のファイルやテキストを読み出すには、csv.NewReader コンストラクタで csv.Reader を生成します。 func csv.NewReader(r io.Reader) *csv.Reader このコンストラクタは、データソースを読み出すための io.Reader を受け取るようになっているので、CSV テキストを扱いたいときは strings.Reader を、CSV ファイルを扱いたいときは os.File を渡してやれば OK です（どちらも io.Reader のメソッド Read を実装しています）。 あとは、次のようなメソッドで各レコードを文字列スライスとして読み出すことができます。 // 1 つのレコードを読み出す func (r *csv.Reader) Read() (record []string, err error) // すべてのレコードを読み出す func (r *csv.Reader) ReadAll() (records [][]string, err error) CSV ファイル読み出しの実装例 input.csv（入力ファイル） name,age,blood_type Asuka,14,A Maya,24,A Ritsuko,30,B main.go package main import ( &#34;encoding/csv&#34; &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;os&#34; ) func main() { file, err := os.Open(&#34;input.csv&#34;) if err != nil { log.Fatal(err) } defer file.Close() reader := csv.NewReader(file) for { record, err := reader.Read() // CSV を 1 レコードずつ読み込み if err == io.EOF { break // 最後まで読み出した } if err != nil { log.Fatal(err) // 読み出し時にエラー発生 } // 1 レコード分のデータを出力（record は []string 型） fmt.Println(record) } } 実行結果 $ go run main.go [name age blood_type] [Asuka 14 A] [Maya 24 A] [Ritsuko 30 B] 2 次元スライスに一括で読み出す (os.ReadAll) (*csv.Reader) Read の代わりに (*csv.Reader) ReadAll メソッドを使用すると、CSV の全レコードを 2 次元スライス ([][]string) 変数に一括で読み出すことができます。 大きな CSV ファイルを扱わないことが分かっているのであれば、こちらを使った方が手っ取り早いかもしれません。 reader := csv.NewReader(file) records, err := reader.ReadAll() if err != nil { log.Fatal(err) } // records は [][]string 形式のデータ for _, fields := range records { fmt.Println(fields) // fields は []string（CSV の 1 レコード） } CSV テキストを扱う 文字列変数に格納された CSV 形式のテキストを扱いたいときは、文字列から生成した strings.Reader を csv.NewReader 関数に渡して、csv.Reader を生成します。 残りの処理は、CSV ファイルを扱う場合と同様です。 main.go text := `name,age,blood_type Asuka,14,A Maya,24,A Ritsuko,30,B ` reader := csv.NewReader(strings.NewReader(text)) 入力時のオプション csv.Reader の各種オプションプロパティで、CSV 読み込み時の振る舞いを制御できます。 これにより、TSV（タブ区切り）形式やコメント (#) 入りのファイルを扱うことができます。 reader := csv.NewReader(file) reader.Comma = &#39;\\t&#39; // 区切り文字（タブ文字を指定すれば TSV ファイルを扱える） reader.Comment = &#39;#&#39; // この文字で始まる行をコメント行とみなす reader.TrimLeadingSpace = true // 各フィールドの先頭の空白を削除する CSV ファイルを書き込む (csv.Writer) 文字列スライスを CSV ファイルに出力したいときは、書き込み用にオープン (os.Create) した os.File インスタンスを csv.NewWriter 関数に渡して、csv.Writer を生成します。 (*osv.Writer) Write メソッドを呼び出すごとに、1 つの文字列スライス（CSV レコード）を出力します。 ただし、出力処理は内部的にバッファリングされるので、最後に (*osv.Writer) Flush メソッドを呼び出す必要があることに注意してください。 次の例では、defer で呼び出すようにしています。 package main import ( &#34;encoding/csv&#34; &#34;log&#34; &#34;os&#34; ) func main() { // 出力用にファイルをオープン file, err := os.Create(&#34;output.csv&#34;) if err != nil { log.Fatal(err) } defer file.Close() // CSV 形式でデータを書き込む writer := csv.NewWriter(file) defer writer.Flush() // 内部バッファのフラッシュは必須 writer.Write([]string{&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;}) writer.Write([]string{&#34;100&#34;, &#34;200&#34;, &#34;300&#34;}) writer.Write([]string{&#34;XXX&#34;, &#34;YYY&#34;, &#34;ZZZ&#34;}) } output.csv（出力結果） AAA,BBB,CCC 100,200,300 XXX,YYY,ZZZ 文字列の 2 次元スライスをまとめて書き出したい場合は、Write の代わりに WriteAll メソッドを使用します。 WriteAll を使う場合は内部で Flush を呼び出してくれるので、明示的に Flush を呼び出す必要はありません。 records := [][]string{ {&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;}, {&#34;100&#34;, &#34;200&#34;, &#34;300&#34;}, {&#34;XXX&#34;, &#34;YYY&#34;, &#34;ZZZ&#34;}, } writer := csv.NewWriter(file) writer.WriteAll(records) TSV 形式で出力したいときは、csv.Writer の Comma プロパティにタブ文字 (\\t) を指定してから Write / WriteAll メソッドを呼び出します。 writer := csv.NewWriter(file) writer.Comma = &#39;\\t&#39;"},{url:"/p/kgzfwdt/",title:"Golang で RDB（リレーショナルデーターベース）を扱う (database/sql)",date:"2022-09-17T00:00:00+09:00",body:"Golang で RDB（リレーショナルデーターベース）を扱う (database/sql) Golang の database/sql パッケージ を使用すると、Postgres、MariaDB (MySQL)、SQLite といった RDB 系のデータベースを共通のインタフェースで操作することができます。 database/sql を使ってコーディングしておけば、将来的な RDBMS の乗り換えが容易になります。 ドライバーのインストール database/sql はデータベース操作用の抽象化レイヤーを提供するだけなので、実際にデータベースに接続するには、それぞれのデータベースごとのドライバーが必要です。 ドライバーは SQLDrivers の一覧ページ から好きなものを選択します。 例えば、mattn 氏の SQLite 用ドライバーを使う場合は、次のように go.mod の依存関係を更新し、 $ go get github.com/mattn/go-sqlite3 Go プログラム内で次のようにインポートしておきます（先にインポート文を書いてから go get . とする方法もあります）。 import ( &#34;database/sql&#34; _ &#34;github.com/mattn/go-sqlite3&#34; ) ☝️ ブランク・インポートが必要 アプリケーションのコードの中でドライバーが提供する関数を直接参照しない場合は、上記のようにアンダースコアを使ったブランク・インポートを行い、go mod tidy 時にこの行が削除されないようにしておく必要があります。 インポート行が削除されてしまうと、database/sql パッケージがドライバーを見つけられれず、unknown driver &quot;sqlite3&quot; (forgotten import?) といったエラーが発生します。 データベースへの接続 (sql.Open, DB.Ping) データベースに接続（ドライバーをオープン）するには、sql.Open 関数 を使用します。 func Open(driverName, dataSourceName string) (*sql.DB, error) 第 1 引数には使用するドライバーの名前（例: mysql、sqlite3）、第 2 引数にはドライバーごとの接続文字列 (DSN: data source name) を指定します。 SQLite3 の場合は、接続文字列はデータベースファイル名なので、とてもシンプルです。 db, err := sql.Open(&#34;sqlite3&#34;, &#34;./books.db&#34;) sql.Open() が返す *sql.DB インスタンスを使って、データベースの各種操作を行うことになります。 package main import ( &#34;database/sql&#34; &#34;log&#34; _ &#34;github.com/mattn/go-sqlite3&#34; ) func main() { // データベースをオープン db, err := sql.Open(&#34;sqlite3&#34;, &#34;./books.db&#34;) if err != nil { log.Fatal(err) } defer db.Close() // ... データベースを操作 ... } SQLite の場合は接続文字列はシンプル（ファイル名のみ）ですが、MySQL や Postgres などでは複雑な接続文字列を指定する必要があります。 そのため、データベースドライバーによっては、接続文字列を構築するためのユーティリティ関数が提供されていることがあります。 MySQL 用の接続文字列を構築する // Specify connection properties. cfg := mysql.Config{ User: os.Getenv(&#34;DB_USER&#34;), Passwd: os.Getenv(&#34;DB_PASS&#34;), Net: &#34;tcp&#34;, Addr: &#34;127.0.0.1:3306&#34;, DBName: &#34;sample&#34;, } // Get a database handle. db, err = sql.Open(&#34;mysql&#34;, cfg.FormatDSN()) データベースのオープンに成功したら、(*sql.DB) Ping メソッドを実行することで、実際にデーターベースが操作可能な状態になっているかを確認できます（実際のアプリで Ping メソッドを呼び出す必要はありません）。 func checkIfDatabaseIsReady(db *sql.DB) { if err := db.Ping(); err != nil { log.Fatal(err) } log.Println(&#34;Database is ready&#34;) } CRUD 操作 (DB.Query, DB.Exec) データベースからレコードを取得するには (*sql.DB) Query 系メソッド、その他の更新操作には (*sql.DB) Exec 系メソッドを使用します。 レコードの取得 (SELECT) func (db *DB) Query(query string, args ...any) (*Rows, error) func (db *DB) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error) func (db *DB) QueryRow(query string, args ...any) *Row func (db *DB) QueryRowContext(ctx context.Context, query string, args ...any) *Row 更新操作 (CREATE TABLE, ALTER TABLE, DROP TABLE, INSERT, UDPATE, DELETE) func (db *DB) Exec(query string, args ...any) (Result, error) func (db *DB) ExecContext(ctx context.Context, query string, args ...any) (Result, error) CREATE TABLE 次の例では、簡単な books テーブルを作成しています。 更新操作なので、(*sql.DB) Exec / (*sql.DB) ExecContext メソッドを使用します。 func createBooksTable(db *sql.DB) { _, err := db.Exec(`CREATE TABLE IF NOT EXISTS books( id TEXT PRIMARY KEY NOT NULL, title TEXT NOT NULL, price INTEGER NOT NULL)`) if err != nil { log.Fatal(err) } } INSERT テーブルにレコードを追加するときも、(*sql.DB) Exec / (*sql.DB) ExecContext メソッドを使用します。 func insertSampleRecord(db *sql.DB) { // INSERT の実行 query := `INSERT INTO books (id, title, price) VALUES (?, ?, ?)` result, err := db.Exec(query, &#34;id-1&#34;, &#34;Title 1&#34;, 1000) if err != nil { log.Fatal(err) } // 挿入されたレコード数を取得 count, err := result.RowsAffected() if err != nil { log.Fatal(err) } log.Printf(&#34;%d rows inserted&#34;, count) } 同様のクエリで複数のレコードを登録する場合は、(*sql.DB) Prepare メソッドで、Prepared statement (sql.Stmt) を生成すると便利です。 func insertSampleRecords(db *sql.DB) { // Prepared statement を作成する stmt, err := db.Prepare(&#34;INSERT INTO books (id, title, price) VALUES (?, ?, ?)&#34;) if err != nil { log.Fatal(err) } defer stmt.Close() // 複数のレコードを追加する for i := 1; i &lt;= 3; i++ { id := fmt.Sprintf(&#34;id-%d&#34;, i) title := fmt.Sprintf(&#34;Title %d&#34;, i) price := 1000 * i _, err := stmt.Exec(id, title, price) if err != nil { log.Fatal(err) } } } SELECT SELECT でレコードを取得するときは、(*sql.DB) Query / (*sql.DB) QueryContext メソッドを使用します。 戻り値の *sql.Rows で取得したレコードを参照できます。 func queryBooks(db *sql.DB) { // クエリ実行 rows, err := db.Query(&#34;SELECT id, title, price FROM books&#34;) if err != nil { log.Fatal(err) } defer rows.Close() // レコードを 1 件ずつ取り出す for rows.Next() { var id string var title string var price int64 if err := rows.Scan(&amp;id, &amp;title, &amp;price); err != nil { log.Fatal(err) } log.Printf(&#34;%s, %s, %d\\n&#34;, id, title, price) } if err := rows.Err(); err != nil { log.Fatal(err) } } 取得するレコードが 1 件だけだとわかっている場合は、効率のよい (*sql.DB) QueryRow / (*sql.DB) QueryRowContext メソッドを使用します。 これらのメソッドは、1 件のレコードを参照するための *sql.Row を返します。 このメソッドは必ず成功し、エラーが発生することはありません（Scan 時のエラーを確認するだけで十分だからです）。 func queryBook(db *sql.DB) { bookId := &#34;id-1&#34; row := db.QueryRow(&#34;SELECT title, price FROM books WHERE id = ?&#34;, bookId) var title string var price int64 if err := row.Scan(&amp;title, &amp;price); err != nil { if err == sql.ErrNoRows { log.Fatalf(&#34;Book not found (id=%s)\\n&#34;, bookId) } log.Fatal(err) } log.Printf(&#34;%s, %d&#34;, title, price) } WHERE 条件に一致するレコードが複数ある場合は、(*sql.DB) QueryRow メソッドは最初のレコードのみを返します。 条件に一致するレコードが見つからない場合は、(*sql.Row) Scan を呼び出したときに sql.ErrNoRows が返されます。 トランザクション処理 (DB.BeginTx) データベースのトランザクションは、複数の更新要求をアトミックに処理するための仕組みです。 複数の更新処理を一括でコミットするか、すべてなかったことにすることができます（ロールバック）。 (*sql.DB) BeginTx メソッドを使うとトランザクション処理を実行するための *sqlTx インスタンスを取得できます。 func (*sql.DB).BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) レコードの更新を行うときに、(*sql.DB) Exec の代わりに (*sql.Tx) Exec を呼び出すことで、その更新処理は 1 つのトランザクション内での処理とみなされます。 func updateRecordsWithTransaction(db *sql.DB) error { tx, err := db.BeginTx(context.Background(), nil) if err != nil { return err } defer tx.Rollback() // コミットしなかった場合は自動でロールバック // 関連する更新処理をトランザクション内で実行する if _, err := tx.Exec(&#34;...省略...&#34;); err != nil { return err } if _, err := tx.Exec(&#34;...省略...&#34;); err != nil { return err } // トランザクション処理をコミット if err := tx.Commit(); err != nil { return err } return nil } 一連の処理が終わったあとに、(*sql.Tx) Commit メソッドか、(*sql.Tx) Rollback メソッドを呼び出す必要があります。 上記のようにトランザクション開始直後に Rollback を defer 呼び出ししておけば、関数内で Commit が呼ばれなかったときに自動でロールバックしてくれます（Commit が呼ばれた場合は、Rollback は実行されません）。 NULL 値を含むレコードを扱う テーブルスキーマで NOT NULL 宣言されていないカラムには、NULL 値が格納されている可能性があります。 NULL 値を含むレコードを Scan するときに、バッファーとして string や int64 などのプリミティブな変数を使用するとエラーが発生します。 Scan error on column index 2, name &ldquo;price&rdquo;: converting NULL to int64 is unsupported NULL 値を含む可能性があるレコードを Scan する場合は、次のような NULL 値を扱える専用の型を使用します。 sql.NullBool sql.NullFloat64 sql.NullInt32 sql.NullInt64 sql.NullString sql.NullTime これらの型は、値が NULL でないことを調べるための Valid プロパティを持っています。 Valid が true の場合は、各カラムの値を安全に参照できます。 func queryBook(db *sql.DB) error { id := &#34;id-1&#34; row := db.QueryRow(&#34;SELECT title, price FROM books WHERE id = ?&#34;, id) // NULL 値を考慮した Scan var title sql.NullString var price sql.NullInt64 if err := row.Scan(&amp;title, &amp;price); err != nil { return err } // Nullable な title カラムを参照する if title.Valid { log.Printf(&#34;title = %s\\n&#34;, title.String) } else { log.Println(&#34;title is NULL&#34;) } // Nullable な price カラムを参照する if price.Valid { log.Printf(&#34;price = %d\\n&#34;, price.Int64) } else { log.Println(&#34;price is NULL&#34;) } return nil }"},{url:"/p/hxyiu7g/",title:"Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf)",date:"2022-09-12T00:00:00+09:00",body:"Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf) 何をするか？ 会社用と個人用の GitHub ユーザーを使い分けている場合、リポジトリへのコミット時に正しいユーザーでコミットログを残すように注意しなければいけません。 多くのリポジトリを扱っている人は、次のような感じで GitHub organization ごとにディレクトリを分けて管理するなどの工夫をしていると思います（リポジトリ名だけだと重複するので）。 ~/gitwork/ +-- company/ ... 会社用のリポジトリ（会社用のユーザー Rei Ayanami を使いたい） | +-- repo1/ | +-- repo2/ | +-- repo3/ +-- maku77/ ... 個人用のリポジトリ（個人用のユーザー maku77 を使いたい） +-- repo4/ +-- repo5/ +-- repo6/ company は自分の会社で使っている GitHub organization 名、maku77 は自分の GitHub アカウント名だと考えてください。 ここでは、上記のようにディレクトリを階層化してリポジトリを管理しているときに、ディレクトリ単位で自動的に Git クライアントの設定を切り替える方法を示します。 具体的には、company ディレクトリ以下のリポジトリで作業しているときは、会社用の Git ユーザー名とメールアドレスを使い、maku77 ディレクトリ以下のリポジトリで作業しているときは、個人用のユーザー名とメールアドレスを使うようにします。 リポジトリごとに local 設定 (.git/config) をするのもよいのですが、扱うリポジトリが増えてくるといちいち設定するのが大変なので、親ディレクトリの company、maku77 単位でまるっと設定を入れ替えます。 参考: Git 設定のスコープ (local/global/system) を理解する 設定ファイルの自動切換え（includeIf ディレクティブ） Git クライアントの設定ファイル（~/.gitconfig など）には、もともと別の設定ファイルをインクルードする機能 (include ディレクティブ）があるのですが、Conditional includes（条件付きインクルード） の仕組みを使うと、指定した条件に一致したときのみ設定ファイルをインクルードすることができます。 この仕組みを利用して、次のような条件付きインクルードを行えば、Git のユーザー設定をディレクトリごとに自動で切り替えることができます。 ~/gitwork/company 以下のリポジトリであれば、~/.gitconfig-company をインクルードする ~/gitwork/maku77 以下のリポジトリであれば、~/.gitconfig-maku77 をインクルードする 条件付きインクルードを行うには、includeIf ディレクティブを使用します。 ここでは、ユーザー単位の global 設定でこの設定を行います。 ~/.gitconfig ファイルを開いて次のような感じで記述します（Windows では git config --edit --global コマンドで開いた方が安全かもしれません）。 ~/.gitconfig [includeIf &#34;gitdir:~/gitwork/company/&#34;] path = ~/.gitconfig-company [includeIf &#34;gitdir:~/gitwork/maku77/&#34;] path = ~/.gitconfig-maku77 ☝️ コマンドで設定する方法 ~/.gitconfig ファイルを直接編集せずに、次のようにコマンドラインから設定することもできます（たぶんファイルを直接編集した方が楽です）。 $ git config --global includeIf.&#34;gitdir:~/gitwork/company/&#34;.path &#34;.gitconfig-company&#34; $ git config --global includeIf.&#34;gitdir:~/gitwork/maku77/&#34;.path &#34;.gitconfig-maku77&#34; あとは、上記のファイルからインクルードしているファイルを次のような感じで作成します。 ~/.gitconfig-company [user] name = Rei Ayanami email = 会社用のメールアドレス ~/.gitconfig-maku77 [user] name = maku77 email = 個人用のメールアドレス これで設定は完了です。 対象リポジトリのディレクトリへ移動して、それぞれの設定ファイルの内容が反映されているかを確認しておきます。 $ cd ~/gitwork/company/repo1 $ git config --show-origin user.name file:C:/Users/maku/.gitconfig-company Rei Ayanami $ cd ~/gitwork/maku77/repo4 $ git config --show-origin user.name file:C:/Users/maku/.gitconfig-maku77 maku77 ☝️ ワンポイント git config コマンドの --show-origin オプションは、設定ファイルのパスを出力するためのオプションです。 参考: Git の設定値がどのファイルで設定されているか調べる (config --show-origin) includeIf ディレクティブは、Git リポジトリとして初期化された（.git がある）ディレクトリ以下でのみ有効なことに注意してください。 今回の例でいうと、~/gitwork/company 直下で作業しているときは有効ではなく、~/gitwork/company/repo1 の下で作業しているときに有効になります。 （応用）デフォルト設定とオーバーライド ほとんどのリポジトリで使う設定を ~/.gitconfig に記述しておき、特定のリポジトリ用の設定だけを includeIf ディレクティブでインクルードするという方法もあります。 つまり、通常はデフォルト設定 (~/.gitconfig) を使い、必要に応じて設定をオーバーライド (~/.gitconfig-xxx) する方法です。 ~/.gitconfig（ほとんどのケースで使うデフォルト設定） [user] name = Rei Ayanami email = rei.ayanami@example.com [includeIf &#34;gitdir:~/gitwork/maku77/&#34;] path = ~/.gitconfig-maku77 ~/.gitconfig-maku77（個人用の設定） [user] name = maku77 email = maku77@example.com 参考 Git 設定のスコープ (local/global/system) を理解する Git の設定値がどのファイルで設定されているか調べる (config --show-origin)"},{url:"/p/o8vbo2f/",title:"Golang でコマンドライン引数を扱う (os.Args, flags)",date:"2022-09-09T00:00:00+09:00",body:"Golang でコマンドライン引数を扱う (os.Args, flags) Golang でコマンドライン引数を扱うには、標準パッケージの os や flags を使用します。 os.Args &hellip; 単純に文字列配列で参照する場合 flags パッケージ &hellip; -key value スタイルのオプションを扱う場合 文字列配列でコマンドライン引数を参照する (os.Args) os.Args という文字列配列を参照すると、コマンド実行時に指定したファイル名と、コマンドライン引数を取得することができます。 次のサンプルコードでは、この配列のサイズと、各要素を出力しています。 main.go package main import ( &#34;fmt&#34; &#34;os&#34; ) func main() { fmt.Printf(&#34;Length = %d\\n&#34;, len(os.Args)) for i, arg := range os.Args { fmt.Printf(&#34;[%d] %s\\n&#34;, i, arg) } } 実行例 $ go build -o hello.exe # ビルド $ hello AAA BBB &#34;CCC DDD&#34; Length = 4 [0] hello [1] AAA [2] BBB [3] CCC DDD 上記の &quot;CCC DDD&quot; のように、コマンドライン引数をダブルクォート (&quot;) で囲むことで、1 つの引数として扱われます。 ちなみに、os.Args[0] に入る実行ファイルの名前は、コマンドラインで指定した通りの文字列になることに注意してください。 次のように呼び出し方を変えると、os.Args[0] の内容も変わります。 $ hello → hello $ ./hello → ./hello $ hello.exe → hello.exe $ .\\myapp\\hello.exe → .\\myapp\\hello.exe 実行ファイルの名前をフルパスで取得したいときは、os.Executable 関数 を使用できます。 オプション引数をパースする（flag パッケージ） flag パッケージの基本 Golang 標準の flag パッケージ を使用すると、次のような形式のオプション引数を扱うことができます。 -x -x 100 -aaa --aaa -aaa 100 -aaa=100 --aaa 100 --aaa=100 flag パッケージでは、次のような関数でオプションの定義と、値の取得を同時に行います。 オプションの型 (string, int, bool) によって関数が分かれています。 // 指定された値を戻り値で取得するバージョン func String(name string, value string, usage string) *string func Int(name string, value int, usage string) *int func Float64(name string, value float64, usage string) *float64 func Bool(name string, value bool, usage string) *bool // 第 1 引数に渡した変数に値を取得するバージョン func StringVar(p *string, name string, value string, usage string) func IntVar(p *int, name string, value int, usage string) func Float64Var(p *float64, name string, value float64, usage string) func BoolVar(p *bool, name string, value bool, usage string) 例えば、user という名前の文字列型のオプションを定義するには次のようにします。 2 番目のパラメーター (value) はデフォルト値で、3 番目のパラメーター (usage) はヘルプテキストです。 func main() { user := flag.String(&#34;user&#34;, &#34;UNKNOWN&#34;, &#34;user name&#34;) // *string flag.Parse() fmt.Println(*user) } ユーザーが入力した値は、関数の戻り値として取得できるのですが、実際に入力値がパースされるのは flag.Parse 関数を呼び出したときだということに注意してください。 flag.String 関数の戻り値がポインタ型になっているのは、このように後から値が設定されるためです。 flag.Parse 関数を呼び出す前に flag.Bool 関数の戻り値を参照すると、必ずデフォルト値（上記例では UNKNOWN）になってしまうので注意してください。 下記は、アプリケーションを myapp という名前でビルドして、いろいろな形でオプション指定した場合の結果です。 $ myapp UNKNOWN $ myapp --user maku maku $ myapp --user=hoge hoge flag パッケージを使うと、ヘルプメッセージを表示するための -h や --help オプションも暗黙的に定義されます。 $ myapp -h Usage of myapp: -user string user name (default &#34;UNKNOWN&#34;) 各オプションの使い方を間違えた場合は、そのオプションに関するヘルプメッセージを表示してくれます。 $ myapp --user flag needs an argument: -user Usage of myapp: -user string user name (default &#34;UNKNOWN&#34;) int 型のオプション (flag.Int) と bool 型のオプション (flag.Bool) は、次のような入力値が正しい値だと判断されます。 flag.Int() &hellip; 1234, 0664, 0x1234, -1 flag.Bool() &hellip; 1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False 変数にオプション値を取得するバージョン 末尾に Var の付く次のようなバージョンの関数を使うと、第 1 引数で指定した変数にオプション値を取得することができます。 func StringVar(p *string, name string, value string, usage string) func IntVar(p *int, name string, value int, usage string) func Float64Var(p *float64, name string, value float64, usage string) func BoolVar(p *bool, name string, value bool, usage string) 次の例では、options 構造体の各フィールドに様々な型のオプション値を格納しています。 main.go package main import ( &#34;flag&#34; &#34;fmt&#34; ) var options struct { isDark bool targetEnv string retryCount int } func parseOptions() { flag.BoolVar(&amp;options.isDark, &#34;dark&#34;, false, &#34;enables dark mode&#34;) flag.StringVar(&amp;options.targetEnv, &#34;env&#34;, &#34;development&#34;, &#34;target environment&#34;) flag.IntVar(&amp;options.retryCount, &#34;retry&#34;, 0, &#34;how many times to retry&#34;) } func main() { parseOptions() fmt.Printf(&#34;%+v\\n&#34;, options) } 実行例 $ myapp {isDark:false targetEnv:development retryCount:0} $ myapp --dark --env production --retry 100 {isDark:true targetEnv:production retryCount:100} $ myapp -h Usage of myapp: -dark enables dark mode -env string target environment (default &#34;development&#34;) -retry int how many times to retry オプション名のエイリアス オプション名としてロングバージョンとショートバージョンを設定したい場合（例: --port と -p）、flag.IntVar や flag.StringVar 関数を同じ変数に対して繰り返し適用します。 var options struct { port int } func parseOptions() { const ( defaultPort = 1234 portUsage = &#34;port number&#34; ) flag.IntVar(&amp;options.port, &#34;port&#34;, defaultPort, portUsage) flag.IntVar(&amp;options.port, &#34;p&#34;, defaultPort, portUsage+&#34; (shorthand)&#34;) flag.Parse() } ヘルプ表示は次のように分かれて表示されてしまうみたいですが、そこは目をつぶります。 $ myapp --help Usage of myapp: -p int port number (shorthand) (default 1234) -port int port number (default 1234)"},{url:"/p/dsbs9p5/",title:"Golang で JSON 形式の文字列やファイルを扱う (encoding/json)",date:"2022-09-04T00:00:00+09:00",body:"Golang で JSON 形式の文字列やファイルを扱う (encoding/json) Golang 標準パッケージの encoding/json を使用すると、Golang のオブジェクトと JSON テキストを相互に変換することができます。 import &#34;encoding/json&#34; Go と JSON の型を変換するとき、次のように対応付けられます（Channel など、一部扱えないデータはあります）。 Go の型 JSON の型 bool boolean float64 number string string []interface{} 配列 map[string]interface{} オブジェクト nil null デフォルトでは、Go の構造体のフィールド名がそのまま JSON のプロパティ名になりますが、構造体フィールドのタグで JSON のプロパティ名を指定する ことができます。 構造体のフィールドがポインタ型である場合は、ポインタが指す実際の値を使って JSON データに変換してくれます。 JSON のプロパティ名を指定する Golang の構造体は、各フィールドにタグという情報を追加 できるようになっています。 encoding/json パッケージは、構造体の json タグを読み取って、JSON データに変換したときのプロパティ名として使用するようになっています。 type Person struct { Name string `json:&#34;name&#34;` Age int `json:&#34;age&#34;` } 上記ように json タグ設定した構造体を、encoding/json パッケージの各種メソッドで JSON に変換すると、次のような感じの JSON データになります。 json タグで指定した通り、プロパティ名がすべて小文字になっていることが分かります。 {&#34;name&#34;:&#34;まく&#34;,&#34;age&#34;:14} さらに、json タグでは次のようなオプション指定もできるようになっています（omitempty や - の部分）。 type Book struct { Title string `json:&#34;title&#34;` // ベーシックな使い方 Price int `json:&#34;price,omitempty&#34;` // ゼロ値の場合はこのフィールドを出力しない Author string `json:&#34;-&#34;` // このフィールドは出力しない } 参考: Golang の構造体にタグ情報を追加する (struct tags) Go オブジェクト → JSON 文字列 json.Marshal 関数を使用すると、任意の Go オブジェクト（構造体）を JSON 形式の文字列データに変換できます。 func json.Marshal(v any) ([]byte, error) 構造体の 公開されたフィールド（大文字で始まるもの）のみ が JSON 出力されます。 変換後のデータは、具体的には UTF-8 エンコーディング形式のバイト配列 ([]byte) です。 次の例では、Person 構造体のデータを JSON 文字列に変換しています。 type Person struct { Name string `json:&#34;name&#34;` Age int `json:&#34;age&#34;` } func main() { p := Person{&#34;まく&#34;, 14} bytes, err := json.Marshal(p) if err != nil { log.Fatal(err) } fmt.Println(string(bytes)) //=&gt; {&#34;name&#34;:&#34;まく&#34;,&#34;age&#34;:14} } 改行やインデントを含む整形された JSON テキストが欲しい場合は、json.Marshal の代わりに json.MarshalIndent 関数を使用します。 bytes, err := json.MarshalIndent(p, &#34;&#34;, &#34; &#34;) JSON 文字列 → Go オブジェクト JSON 形式の文字列データ ([]byte) を Go のオブジェクトに変換するには、json.Unmarshal 関数を使用します。 func json.Unmarshal(data []byte, v any) error 次の例では、JSON 文字列を Person 構造体のデータに変換しています。 type Person struct { Name string `json:&#34;name&#34;` Age int `json:&#34;age&#34;` } func main() { jsonBytes := []byte(`{&#34;name&#34;:&#34;まく&#34;,&#34;age&#34;:14}`) var p Person if err := json.Unmarshal(jsonBytes, &amp;p); err != nil { log.Fatal(err) } fmt.Printf(&#34;%+v\\n&#34;, p) //=&gt; {name:まく age:14} fmt.Println(p.Name) //=&gt; まく fmt.Println(p.Age) //=&gt; 14 } Go オブジェクト → JSON ファイル Go の構造体を JSON ファイルに出力するには、os.File オブジェクトを json.NewEncoder に渡して Encoder を作成し、(*json.Encoder).Encode メソッドでデータを書き込みます。 func json.NewEncoder(w io.Writer) *json.Encoder func (*json.Encoder).Encode(v any) error 次の例では、Person 構造体の内容を person.json ファイルに出力しています。 main.go package main import ( &#34;encoding/json&#34; &#34;log&#34; &#34;os&#34; ) type Person struct { Name string `json:&#34;name&#34;` Age int `json:&#34;age&#34;` } func main() { // 書き込むデータ p := Person{&#34;まく&#34;, 14} // JSON ファイルを新規作成（既に存在する場合は上書き） file, err := os.Create(&#34;person.json&#34;) if err != nil { log.Fatal(err) } defer file.Close() // JSON ファイルに書き込み encoder := json.NewEncoder(file) if err := encoder.Encode(p); err != nil { log.Fatal(err) } } 出力結果 (person.json) {&#34;name&#34;:&#34;まく&#34;,&#34;age&#34;:14} 改行やインデントを含む整形された JSON ファイルとして出力したい場合は、Encode メソッドで出力する前に、SetIndent メソッドでインデントの設定を行います。 encoder := json.NewEncoder(file) encoder.SetIndent(&#34;&#34;, &#34; &#34;) // スペース 2 文字をインデントに使う 出力結果 (person.json) { &#34;name&#34;: &#34;まく&#34;, &#34;age&#34;: 14 } 参考: Golang でファイルを読み書きする (os, io) JSON ファイル → Go オブジェクト JSON ファイルを読み込んで、Go のオブジェクトに変換するには、os.File オブジェクトを json.NewDecoder に渡して Decoder を作成し、(*json.Decoder).Decode メソッドで Go の変数へデータを展開します。 func json.NewDecoder(r io.Reader) *json.Decoder func (*json.Decoder).Decode(v any) error JSON のスキーマが完全に分かっている場合 次の例では、person.json ファイルの内容を Person 構造体に変換しています。 person.json（入力ファイル） { &#34;name&#34;: &#34;まく&#34;, &#34;age&#34;: 14 } main.go package main import ( &#34;encoding/json&#34; &#34;log&#34; &#34;os&#34; ) type Person struct { Name string `json:&#34;name&#34;` Age int `json:&#34;age&#34;` } func main() { // JSON ファイルを読み出し用にオープン file, err := os.Open(&#34;person.json&#34;) if err != nil { log.Fatal(err) } defer file.Close() // JSON ファイルの内容を Person 構造体データとして読み出す var p Person decoder := json.NewDecoder(file) if err := decoder.Decode(&amp;p); err != nil { log.Fatal(err) } log.Printf(&#34;%+v\\n&#34;, p) //=&gt; {name:まく age:14} } JSON のスキーマが不明な場合 具体的な構造体の型を設定せずに、map[string]any 型の変数に JSON ファイルの内容を読み出すこともできます。 これは、キーの型が文字列で、値の型が不明 (any / interface{}) なマップです。 この場合、少なくとも JSON ルート階層のフィールドはキー名で参照できますが、その値は any 型になるので、実際に値を扱う段階で型アサーションにより具体的な型を指定する必要があります。 あるいは、リフレクションで各フィールドの情報を列挙することが可能です。 // JSON ファイルの内容を map 型の Go オブジェクトとして読み出す var rawJson map[string]any decoder := json.NewDecoder(file) if err := decoder.Decode(&amp;rawJson); err != nil { log.Fatal(err) } // ルート階層のフィールドを参照する（値は any 型なので型アサーションして使う） name := rawJson[&#34;name&#34;].(string) age := rawJson[&#34;age&#34;].(float64) fmt.Println(name) fmt.Println(age) // リフレクションで内容を調べても OK refVal := reflect.ValueOf(rawJson) for it := refVal.MapRange(); it.Next(); { fmt.Printf(&#34;key = %s\\n&#34;, it.Key()) } 参考: Golang でファイルを読み書きする (os, io)"},{url:"/p/hxhzfbs/",title:"Golang の構造体にタグ情報を追加する (struct tags)",date:"2022-09-03T00:00:00+09:00",body:"Golang の構造体にタグ情報を追加する (struct tags) 構造体タグ (struct tags) の基本 Go 言語の構造体 (struct) では、各フィールドの末尾に、タグ (struct tags) と呼ばれるメタ情報を付加することができます。 JSON データを扱うプログラムの構造体で、`json:&quot;id&quot;` のような記述があるのを見かけたことがあるかもしれません。 下記の例は、タグを追加した Book 構造体の例です。 type Book struct { Title string `label:&#34;タイトル&#34;` Price int `label:&#34;価格&#34;` } 各タグは、タグ名:&quot;タグ値&quot; というフォーマットの文字列リテラルで設定します。 コロン (:) の前後にスペースを入れてはいけません。 Golang の言語仕様 (Struct types) では、任意の文字列リテラルを配置できると記述されていますが、VS Code などの Lint 系プラグインでは、上記のようなフォーマットで記述していないと警告が出たりするので、このフォーマットで記述しておくのが無難です。 通常はダブルクォート (&quot;) のエスケープをしなくて済むように、バッククォート (`) で囲んだ Raw string literals（生文字列リテラル） を使います。 構造体タグを参照する 構造体の各フィールドに付加したタグを参照するには、reflect パッケージを使ったリフレクションを利用します。 次の例では、各フィールドの label タグの値を出力しています。 main.go package main import ( &#34;fmt&#34; &#34;reflect&#34; ) type Book struct { Title string `label:&#34;タイトル&#34;` Price int `label:&#34;価格&#34;` } func main() { book := Book{Title: &#34;Golang入門&#34;, Price: 2000} // リフレクションで構造体の各フィールドをループ処理 t := reflect.TypeOf(book) for i := 0; i &lt; t.NumField(); i++ { fieldName := t.Field(i).Name tag := t.Field(i).Tag fmt.Printf(&#34;%s フィールドの label タグの値は「%s」だよ\\n&#34;, fieldName, tag.Get(&#34;label&#34;)) } } 実行結果 $ go run main.go Title フィールドの label タグの値は「タイトル」だよ Price フィールドの label タグの値は「価格」だよ 上記の例では、タグ値の取得に tag.Get メソッドを使用していますが、設定されていないタグ名を指定すると、戻り値は空文字列 (&quot;&quot;) になります。 tag.Get の代わりに tag.Lookup メソッドを使用すると、タグの有無を判別することができます。 タグ値として空文字列を設定することに意味を持たせたい場合はこちらを使用します。 if label, ok := tag.Lookup(&#34;label&#34;); ok { fmt.Printf(&#34;%s フィールドの label タグの値は「%s」だよ\\n&#34;, fieldName, label) } else { fmt.Printf(&#34;%s フィールドに label タグはないよ\\n&#34;, fieldName) } 複数のタグ情報を設定する 1 つのフィールドに複数のタグ情報を設定したいときは、タグ名:&quot;値&quot; をスペースで区切って並べます。 type Book struct { Title string `json:&#34;title&#34; label:&#34;タイトル&#34;` Price int `json:&#34;price&#34; label:&#34;価格&#34;` } 各タグの値を参照するには、前述の例のように tag.Get あるいは tag.Lookup メソッドを使用します。 jsonTag := reflect.TypeOf(book).Field(0).Tag.Get(&#34;json&#34;) labelTag := reflect.TypeOf(book).Field(0).Tag.Get(&#34;label&#34;) タグ値の解釈方法は自由 タグ値は文字列形式の値ですが、この文字列をどのように解釈するかは自由です。 例えば、Golang の encoding/json 標準パッケージは、json タグに指定した文字列を JSON のプロパティ名として使用しますが、カンマで区切ってオプション設定を行えるようになっています。 type Book struct { Title string `json:&#34;title&#34;` // ベーシックな使い方 Price int `json:&#34;price,omitempty&#34;` // ゼロ値の場合はこのフィールドを出力しない Author string `json:&#34;-&#34;` // このフィールドは出力しない } 参考: Golang で JSON 形式の文字列やファイルを扱う"},{url:"/p/v48adgi/",title:"Golang で GraphQL サーバーを作成する (gqlgen)",date:"2022-08-20T00:00:00+09:00",body:"Golang で GraphQL サーバーを作成する (gqlgen) Go 言語用の GraphQL ライブラリ gqlgen を使って、GraphQL サーバーを作ってみます。 gqlgen は、スキーマファーストの設計を採用しており、最初に GraphQL スキーマを定義し、それに合わせて各クエリ用のリゾルバーを実装していきます。 リゾルバーの雛形は、gqlgen generate というコマンドで生成できます。 Go プロジェクトを作成して gqlgen コマンドをインストールする Go プロジェクトの作成 まずは、Go のプロジェクトを Go Modules として作成します。 モジュール名は適当に example.com/myapp としておきます。 $ mkdir myapp &amp;&amp; cd myapp $ go mod init example.com/myapp これで、myapp ディレクトリ内に go.mod ファイルが生成されます。 gqlgen コマンドのインストール gqlgen コマンドは github.com/99designs/gqlgen という Go モジュールとして提供されています。 Go 言語の慣例として、プロジェクトのビルドに必要なツールのモジュール依存情報は、tools.go というファイルに記述すべしとされているので、次のような内容で作成しておきます（参考: How can I track tool dependencies for a module?）。 tools.go //go:build tools package tools import ( _ &#34;github.com/99designs/gqlgen&#34; ) go get コマンドを実行して、プロジェクトの go.mod に gqlgen コマンド用のモジュール依存情報を追加します。 指定可能なバージョンは gqlgen の Release ページ で確認してください。 $ go get github.com/99designs/gqlgen@latest # 最新バージョンを使う場合（go get . でも OK） $ go get github.com/99designs/gqlgen@v0.17.14 # バージョンを指定する場合 次のように gqlgen コマンドを実行できるようになれば OK です。 $ go run github.com/99designs/gqlgen version v0.17.14 ☝️ なぜ tools.go が必要？ tools.go ファイルがなくても、go get コマンドで gqlgen 関連の依存情報を追加することはできます。 ただ、go mod tidy コマンドで依存情報を整理すると、Go コードから参照されていないモジュールの依存情報は go.mod ファイルから削除されてしまうので、何らかの Go コードで gqlgen コマンド用のモジュールをインポートしておかなければいけません。 そのために使われるファイルが tools.go です。 さらに、このファイルの先頭に、//go:build tools という特殊なタグ (Build Constraints) を記述しておくことで、アプリ本体のビルド時には tools.go は無視してくれるようになります。 gqlgen プロジェクトのスケルトンを生成する (gqlgen init) gqlgen init コマンドを使用すると、gqlgen プロジェクトのスケルトンコードを生成することができます。 ここから先は、本家のチュートリアル 通りにコードを修正していきます。 $ go run github.com/99designs/gqlgen init Creating gqlgen.yml Creating graph/schema.graphqls Creating server.go Generating... Exec &#34;go run ./server.go&#34; to start GraphQL server この時点で、次のようなディレクトリ構成になっているはずです。 ★ が付いているのが gqlgen init で生成されたファイルです。 go.mod go.sum gqlgen.yml ★ gqlgen の設定ファイル graph/ ★ GraphQL スキーマやそのリゾルバー実装は基本的にここに入れる generated/ ★ gqlgen が自動生成するファイル群 generated.go ★ 触らない model/ ★ GraphQL クエリで取得するデータの型情報 models_gen.go ★ schema.graphqls に基づいて自動生成される（触らない） resolver.go ★ GraphQL サーバーが読み込むリゾルバー。自力で実装する schema.graphqls ★ GraphQL のスキーマファイル。ここから定義していく schema.resolvers.go ★ 上記スキーマ用のリゾルバー実装。resolver.go から参照する server.go ★ GraphQL サーバー本体（main パッケージの main 関数） tools.go 生成された GraphQL スキーマファイルを覗いてみると、どうやら TODO を管理する API のサンプルになっているようです。 ルートクエリとして todos、mutation 用に createTodo が定義されています。 graph/schema.graphqls type Todo { id: ID! text: String! done: Boolean! user: User! } type User { id: ID! name: String! } type Query { todos: [Todo!]! } input NewTodo { text: String! userId: String! } type Mutation { createTodo(input: NewTodo!): Todo! } ちなみに、GraphQL スキーマファイルは、拡張子が .graphqls であれば、複数のファイルに分割されていても大丈夫です（gqlgen.yml 設定ファイルで、schema: [graph/*.graphqls] のように指定されているからです）。 ここで GraphQL サーバーを起動してみたいところですが、悲しいことに、スケルトンとして生成されたファイルはチュートリアル用で不完全なので、以下のようにリゾルバーの実装を少し修正する必要があります（サーバーの起動自体はできますが、クエリ時に panic が発生します）。 GraphQL リゾルバーの実装 graph/resolver.go package graph import &#34;example.com/myapp/graph/model&#34; type Resolver struct { todos []*model.Todo } resolver.go は、GraphQL リゾルバーのルート定義的なファイルです。 GraphQL サーバーが利用する Resolver 構造体の型を定義しておきます。 Resolver は、model.Todo のスライス (todos) を保持しています。 この値は GraphQL サーバーが動作している間だけメモリ上に保持されます（いわゆるステートです）。 サーバー本体 (server.go) の実装を見てみると、サーバー生成時に、&amp;graph.Resolver{} といった感じで上記の struct 値が生成されていることがわかります。 肝心のリゾルバー関数の定義が見当たりませんが、それらは graph/schema.resolvers.go という別ファイルで定義するようになっています。 Go 言語の仕様上、同じパッケージ内であればどのファイルで定義してもよいのですが、graph/schema.graphqls というスキーマファイル名に対応するリゾルバーファイル名になっているようです（このあたりのファイル構成は gqlgen のバージョンによって変わるかもしれません）。 graph/schema.resolvers.go // createTodo mutation 用のリゾルバー func (r *mutationResolver) CreateTodo(ctx context.Context, input model.NewTodo) (*model.Todo, error) { todo := &amp;model.Todo{ Text: input.Text, ID: fmt.Sprintf(&#34;T%d&#34;, rand.Int()), User: &amp;model.User{ID: input.UserID, Name: &#34;user &#34; + input.UserID}, } r.todos = append(r.todos, todo) return todo, nil } // todos query 用のリゾルバー func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) { return r.todos, nil } mutation 操作用の CreateTodo 関数と、query 操作用の Todos 関数の実装が空っぽになっているので、次のような感じで実装します。 やっていることは単純で、CreateTodo 関数で model.Todo オブジェクトを生成して Resolver の todos スライスに追加し、Todos 関数でそのスライスの内容を返すように実装しています。 todos スライスの値はメモリ上に保持されるので、GraphQL サーバーを起動してから createTodo mutation を呼び出し、続けて todos query を呼び出せば、その値を取得できるはずです。 ここまで実装できたら、次のように GraphQL サーバーを起動します。 $ go run server.go 2022/08/20 22:59:26 connect to http://localhost:8080/ for GraphQL playground Web ブラウザで http://localhost:8080/ を開くと、次のように GraphiQL が起動して、任意のクエリをテストできます。 図: GraphiQL の画面 初期状態では Resolver の todos スライスが空っぽなので、todos クエリをかけても何も返って来ません。 次のように createTodo mutation で TODO を追加してから、 mutation createTodo { createTodo(input: { text: &#34;ゴミ捨て&#34;, userId: &#34;1&#34; }) { id text done } } 続けて次のように todos クエリを実行すると、 query findTodos { todos { id text done user { name } } } 次のような結果 (JSON) が返って来ます。 { &#34;data&#34;: { &#34;todos&#34;: [ { &#34;id&#34;: &#34;T5577006791947779410&#34;, &#34;text&#34;: &#34;ゴミ捨て&#34;, &#34;done&#34;: false, &#34;user&#34;: { &#34;name&#34;: &#34;user 1&#34; } } ] } } これでチュートリアル的な GraphQL サーバーの実装は完成です。 上記の TODO 情報は、サーバーを起動している間のみ有効です。 GraphQL サーバーを CORS 対応する Web ブラウザ上で動作させる JavaScript（クライアントサイド JS）から、GraphQL サーバーにアクセスする場合、おそらく GraphQL サーバー側で CORS（クロスドメインアクセス）用の対応が必要になります。 rs/cors パッケージを使うと簡単に CORS 対応のための HTTP レスポンスを返すことができます。 rs/cors パッケージの依存を追加 $ go get github.com/rs/cors 具体的には、HTTP サーバーのミドルウェアとして、cors.Cors オブジェクトが提供するハンドラー実装を挟むようにします。 server.go（抜粋） // import &#34;github.com/rs/cors&#34; func main() { // ... srv := handler.NewDefaultServer(generated.NewExecutableSchema( generated.Config{Resolvers: &amp;graph.Resolver{}} )) handler := cors.Default().Handler(srv) // ★CORS レスポンス対応 http.Handle(&#34;/query&#34;, handler) log.Fatal(http.ListenAndServe(&#34;:&#34;+port, nil)) } CORS 対策はあくまで HTTP サーバーに必要なものであって、GraphQL サーバーを実装しているかどうかは本質的には関係ないことに注意してください。 参考: Golang で HTTP サーバーを作成する (net/http, rs/cors) スキーマファイル更新時の作業 スキーマファイル (graph/schema.graphqls) を更新した場合は、次のコマンドを実行して、自動生成された各種 .go ファイルを更新する必要があります。 スキーマの更新を Go コードに反映 $ go run github.com/99designs/gqlgen generate 上記コマンド実行後は、主に下記のファイルを見直す必要があります。 graph/model/models_gen.go &hellip; スキーマの各オブジェクト型に対応する Golang 構造体が想定通り生成されているかを確認します。 graph/schema.resolvers.go &hellip; スキーマの Query 型や Mutation 型の各フィールドに対応するリゾルバー関数のひな形が追加されているはずなので、それらの関数の本体を実装します。 スキーマファイルの更新のたびに、上記のような長い go run コマンドをタイプするのは面倒なので、graph/resolver.go あたりに、次のように //go:generate ディレクティブを記述しておくと便利です。 graph/resolver.go package graph //go:generate go run github.com/99designs/gqlgen generate import &#34;example.com/myapp/graph/model&#34; type Resolver struct { todos []*model.Todo } すると、次のように実行するだけで、.go ファイルの更新を行えるようになります（//go:generate ディレクティブは、Golang 標準の仕組みです）。 $ go generate ./... GraphQL スキーマの型と Golang の型の対応 gqlgen が GraphQL スキーマから Golang のコード (graph/model/models_gen.go) を生成するときに、どのように型をマッピングするかのまとめです。 GraphQL 標準の型 GraphQL 標準のスカラー型は ID、String、Boolean、Int、Float の 5 種類です。 下記はそれらと Golang の型の対応です。 GraphQL の型 Golang (gqlgen) 意味 ID! string ユニークな ID ID *string ユニークな ID (nullable) String! string 文字列 String *string 文字列 (nullable) Boolean! bool 真偽値 Boolean *bool 真偽値 (nullable) Int! int 整数 Int *int 整数 (nullable) Float! float64 浮動小数点数 Float *float64 浮動小数点数 (nullable) [String!]! []string 文字列の配列 [String!] []string 文字列の配列 (nullable) [String]! []*string 文字列 (nullable) の配列 [String] []*string 文字列 (nullable) の配列 (nullable) Golang のスライス型（[]string など）は、nil になり得るので、GraphQL スキーマの [String!]! も [String!] も、Golang の型にしたときは同じ []string になります（もちろん、GraphQL サーバーとしては、nil と空スライス []string{} は別データとして扱います）。 gqlgen パッケージの変換実装は このあたり にあります。 カスタムスカラー型 次のようにスキーマ内でカスタムスカラーを定義すると、デフォルトで Golang の String 型にマッピングされます。 GraphQL スキーマ &#34;&#34;&#34; The International Standard Book Number (ISBN) is a numeric commercial book identifier that is intended to be unique. &#34;&#34;&#34; scalar ISBN フォーマットの決まった文字列（日時、メールアドレス、URL など）は、とりあえずカスタムスカラー型としてスキーマ定義しておくとよさそうです。 フォーマットの検証などをしたくなったら、カスタムスカラー型に MarshalGQL / UnmarshalGQL メソッドを追加することで対応できます（参考: Custom scalars with user defined types — gqlgen）。 Enum 型 下記は、リストのソート順序を示す列挙型のスキーマ定義例です。 GraphQL スキーマ &#34;&#34;&#34; Specifies how items in a list are sorted. &#34;&#34;&#34; enum SortOrder { &#34;Unordered (arbitrary order)&#34; NONE &#34;Ascending order&#34; ASC &#34;Descending order&#34; DESC } これを gqlgen で Golang の型に変換すると、次のような SortOrder (≒ String) 型、および、その定数群として出力されます。 Golang には列挙型 (enum) というものは存在しないのでこうなるのですが、SortOrder 型の型チェックが働くのでこれで十分なのです。 models_gen.go（自動生成された Go コード） // Specifies how items in a list are sorted. type SortOrder string const ( // Unordered (arbitrary order) SortOrderNone SortOrder = &#34;NONE&#34; // Ascending order SortOrderAsc SortOrder = &#34;ASC&#34; // Descending order SortOrderDesc SortOrder = &#34;DESC&#34; ) あと、次のようなマーシャリング用のメソッド (MarshalGQL / UnmarshalGQL) も出力されます。 func (e SortOrder) IsValid() bool { switch e { case SortOrderNone, SortOrderAsc, SortOrderDesc: return true } return false } func (e SortOrder) String() string { return string(e) } func (e *SortOrder) UnmarshalGQL(v interface{}) error { str, ok := v.(string) if !ok { return fmt.Errorf(&#34;enums must be strings&#34;) } *e = SortOrder(str) if !e.IsValid() { return fmt.Errorf(&#34;%s is not a valid SortOrder&#34;, str) } return nil } func (e SortOrder) MarshalGQL(w io.Writer) { fmt.Fprint(w, strconv.Quote(e.String())) } 参考リンク gqlgen で子フィールドの情報を返すリゾルバーを実装する"},{url:"/p/goruwy4/",title:"Golang で HTTP サーバーを作成する (net/http, rs/cors)",date:"2022-08-20T00:00:00+09:00",body:`Golang で HTTP サーバーを作成する (net/http, rs/cors) Hugo 標準ライブラリの net/http パッケージ (src) は、HTTP クライアント／サーバーを作成するためのパッケージです。 ここでは、この net/http パッケージを使って、簡単な Web サーバーを実装してみます。 最小限の HTTP サーバーを作る main.go package main import ( &#34;log&#34; &#34;net/http&#34; ) func main() { // ポート番号 8080 で待ち受けを開始 log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil)) } これがおそらく Golang における最小の HTTP サーバー実装です。 http.ListenAndServe 関数 で、指定したアドレスとポート番号で待ち受けを開始しています。 ここではポート番号 8080 だけを指定しているため、localhost:8080 で待ち受けることになります。 ☝️ log.Fatal で囲んでいるのはなぜ？ http.ListenAndServe 関数はサーバーの起動に失敗すると error オブジェクトを返します。 log.Fatal 関数で囲んでいるのは、エラーが発生した場合にその内容を出力してから終了するためです。 例えば、サーバーを 2 回続けて起動しようとしたときに、ポート番号が使用中であることを表示してくれます。 逆にサーバーの起動に成功した場合は、http.ListenAndServe 関数は戻ってこないので、log.Fatal 関数が実行されることはありません。 サーバーを Ctrl + C で終了したときも、log.Fatal 関数は実行されません。 このイディオムは、net/http パッケージのドキュメントでも使われています。 go run main.go でプログラムを起動してから、Web ブラウザで http://localhost:8080/ にアクセスするとレスポンスを確認できます。 ただし、まだ何もコンテンツを返していないので、404 page not found エラーが返ってきます。 サーバーを停止するときは、Ctrl + C と入力します。 ハンドラー関数を登録する (http.HandleFunc) Web サーバーがコンテンツを返すようにするには、リクエスト時の URL とレスポンスの内容を対応づける必要があります。 ここでは、次のようにコンテンツを返すようにしてみます。 http://localhost:8080/foo/ へのアクセス → Hello-1 というレスポンスを返す http://localhost:8080/bar/ へのアクセス → Hello-2 というレスポンスを返す 次のサンプルコードでは、特定のパスにアクセスされたときに呼び出されるハンドラー関数を設定しています。 main.go（全体のコード） package main import ( &#34;io&#34; &#34;log&#34; &#34;net/http&#34; ) func main() { // ハンドラー関数を定義する handler1 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, &#34;Hello-1\\n&#34;) } handler2 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, &#34;Hello-2\\n&#34;) } // パスとハンドラー関数を結びつける http.HandleFunc(&#34;/foo/&#34;, handler1) http.HandleFunc(&#34;/bar/&#34;, handler2) // Web サーバーを起動する log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil)) } HTTP リクエストを処理するハンドラー関数は、次のようなシグネチャの関数として実装します。 http.ResponseWriter と *http.Request を受け取る関数です。 type HandlerFunc func(ResponseWriter, *Request) 今回は次のようなハンドラー関数を定義しています。 レスポンスの内容（テキスト）を http.ResponseWriter に書き込むときには、io.WriteString や fmt.Fprint、fmt.Fprintf などを使用できます（これは、http.ResponseWriter が io.Writer インタフェースを実装しており、それを受け取る関数に渡せるようになっているからです）。 2 番目のパラメーター (*http.Request) は参照していないので、変数名を _ にしています。 handler1 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, &#34;Hello-1\\n&#34;) // fmt.Fprint(w, &#34;Hello-1\\n&#34;) } handler2 := func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, &#34;Hello-2\\n&#34;) // fmt.Fprint(w, &#34;Hello-2\\n&#34;) } HTTP リクエストを受信したときにこれらのハンドラー関数が呼び出されるようにするには、http.HandleFunc 関数 を使用します。 http.HandleFunc(&#34;/foo/&#34;, handler1) http.HandleFunc(&#34;/bar/&#34;, handler2) 任意のオブジェクトをハンドラーとして登録する (http.Handle) 前述の例では、http.HandleFunc 関数でハンドラー関数を登録しましたが、代わりに http.Handle 関数 を使うと、任意のオブジェクトをハンドラーとして登録することができます。 このオブジェクトは Web サーバーの起動中は破棄されないので、ステート（状態）を持ったハンドラーとして使用できます。 ハンドラーとなる型は、次のようなシグネチャのメソッドを持っている必要があります（http.Handler インタフェースとして定義されています）。 実装方法は、前述のハンドラー関数と同様です。 ServeHTTP(w http.ResponseWriter, r *http.Request) 次の countHandler は、呼び出されるたびに自身の count フィールドをインクリメントし、その値をレスポンスとして返します。 handler.go package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;sync&#34; ) // カウンターを持つ HTTP リクエストハンドラー type countHandler struct { mutex sync.Mutex // guards count count int } func (h *countHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { h.mutex.Lock() defer h.mutex.Unlock() h.count++ fmt.Fprintf(w, &#34;Count: %d\\n&#34;, h.count) } このハンドラーを登録するには、次のようにします。 main.go package main import ( &#34;log&#34; &#34;net/http&#34; ) func main() { http.Handle(&#34;/count&#34;, new(countHandler)) log.Fatal(http.ListenAndServe(&#34;:8080&#34;, nil)) } http://localhost:8080/count/ にアクセスして、次のようなレスポンスが返って来れば成功です。 Count の値はブラウザをリロードするたびに 1 つずつ増えていきます。 Count: 1 ハンドラーはどこに登録されているのか？ これまでのサンプルコードでは、ハンドラーを登録するときに、http.HandleFunc 関数や http.Handle 関数を使ってきましたが、これらは単なる関数です。 これらに渡したハンドラー関数やハンドラーオブジェクトが、どのように Web サーバーと結び付けられているのか疑問に感じたかもしれません。 その謎は、net/http パッケージのコードを覗いてみると分かります。 net/http/server.go（抜粋） func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) } func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) { DefaultServeMux.HandleFunc(pattern, handler) } どちらの関数も、内部的には DefaultServeMux という http.ServeMux オブジェクトにハンドラーを登録しています。 ServeMux は、ハンドラーを束ねるハンドラーです（Composite パターン）。 そして、次のように第 2 引数を nil にして Web サーバーを起動すると、この DefaultServeMux がハンドラーとして使われるようになっています。 http.ListenAndServe(&#34;:8080&#34;, nil) 第 2 引数で別のハンドラーオブジェクトを指定してしまうと、http.HandleFunc 関数や http.Handle 関数で登録したハンドラーは呼び出されなくなってしまうので注意してください。 次のようにすれば、独自の ServeMux オブジェクトを作成して、Web サーバーの待ち受けを開始することができます。 func main() { // 独自の ServeMux を作成してハンドラーを登録していく mux := http.NewServeMux() mux.HandleFunc(&#34;/foo/&#34;, func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, &#34;I am foo&#34;) }) mux.HandleFunc(&#34;/bar/&#34;, func(w http.ResponseWriter, _ *http.Request) { io.WriteString(w, &#34;I am bar&#34;) }) // Web サーバーの待ち受けを開始 log.Fatal(http.ListenAndServe(&#34;:8080&#34;, mux)) } 静的ファイルをホスティングする (http.FileServer) ハンドラー実装として、http.FileServer を使うと、ローカルディレクトリに配置した静的ファイル（HTML ファイルなど）を簡単にホスティングできます。 public ディレクトリ内のファイルを公開する package main import ( &#34;fmt&#34; &#34;log&#34; &#34;net/http&#34; ) const port = 8080 const directory = &#34;public&#34; func main() { // 指定したディレクトリをホスティングする handler := http.FileServer(http.Dir(directory)) http.Handle(&#34;/&#34;, handler) // サーバーの待ち受けを開始 log.Printf(&#34;Serving %s on HTTP port: %d\\n&#34;, directory, port) log.Fatal(http.ListenAndServe(fmt.Sprintf(&#34;:%d&#34;, port), nil)) } シンプルに書きたいのであれば、次のように 1 行で書くこともできます。 func main() { log.Fatal(http.ListenAndServe(&#34;:8080&#34;, http.FileServer(http.Dir(&#34;.&#34;)))) } CORS アクセス対応する (rs.cors) Web ブラウザ上で動作するクライアントサイド JavaScript から、別ドメインの Web サーバーにアクセスしてデータを取得するには、CORS (Cross-Origin Resource Sharing) 用のレスポンスヘッダーを返す必要があります。 下記は、JSON データを返す簡単な Web サーバー実装です。 main.go（CORS 未対応） package main import ( &#34;log&#34; &#34;net/http&#34; ) func main() { mux := http.NewServeMux() mux.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, r *http.Request) { w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;) w.Write([]byte(&#34;{\\&#34;hello\\&#34;: \\&#34;world\\&#34;}&#34;)) }) log.Fatal(http.ListenAndServe(&#34;:8080&#34;, handler)) } http://localhost:8080/ にアクセスすると、{&quot;hello&quot;: &quot;world&quot;} という JSON データが返ってくるはずなのですが、別ドメインの Web サーバーにより配信された JavaScript から次のようにアクセスすると、CORS ポリシーによりブラウザがアクセスをブロックしてしまいます。 クライアントサイド JS fetch(&#39;http://localhost:8080/&#39;) .then((response) =&gt; response.json()) .then((data) =&gt; console.log(data)) アクセスがブロックされたことは、Web ブラウザのコンソールログを見るとわかります。 Access to fetch at &lsquo;http://localhost:8080/&rsquo; from origin &lsquo;http://localhost:3000&rsquo; has been blocked by CORS policy: No &lsquo;Access-Control-Allow-Origin&rsquo; header is present on the requested resource. If an opaque response serves your needs, set the request&rsquo;s mode to &rsquo;no-cors&rsquo; to fetch the resource with CORS disabled. Golang の rs/cors パッケージ を使用すると、簡単に CORS 対応用の HTTP レスポンスヘッダーを返すことができます。 rs/cors の依存情報を追加 $ go get github.com/rs/cors main.go（CORS 対応版） package main import ( &#34;log&#34; &#34;net/http&#34; &#34;github.com/rs/cors&#34; ) func main() { mux := http.NewServeMux() mux.HandleFunc(&#34;/&#34;, func(w http.ResponseWriter, _ *http.Request) { w.Header().Set(&#34;Content-Type&#34;, &#34;application/json&#34;) w.Write([]byte(&#34;{\\&#34;hello\\&#34;: \\&#34;world\\&#34;}&#34;)) }) // CORS レスポンスヘッダーの追加 c := cors.Default() handler := c.Handler(mux) log.Fatal(http.ListenAndServe(&#34;:8080&#34;, handler)) } 追加したコードは、下記の部分です。 c := cors.Default() handler := c.Handler(mux) 既存のハンドラー (mux) を、デフォルトの cors.Cors インスタンスが持つハンドラーでラップしています。 これにより、次のようなクロスドメインアクセスを許可するレスポンスヘッダーが付加されるようになります。 Access-Control-Allow-Origin: * 上記のように cors.Default() が返す cors.Cors インスタンスを使うと、すべてのドメインからの GET/POST アクセスを許可しますが、次のように独自の cors.Cors オブジェクトを作成して受け入れるドメインや HTTP メソッドを指定することができます。 // CORS レスポンス対応（OPTIONS プリフライトリクエストなどに対応） c := cors.New(cors.Options{ AllowedOrigins: []string{&#34;http://localhost:3000&#34;, &#34;http://foo.com&#34;}, AllowedMethods: []string{http.MethodGet, http.MethodPost, http.MethodDelete, http.MethodOptions}, AllowedHeaders: []string{&#34;*&#34;}, AllowCredentials: true, }) CORS アクセスの問題がどうしても解決できないときは、次のように、すべての接続を許可する CORS 設定 (cors.AllowAll()) を試してみるとよいです。 c := cors.AllowAll() handler := c.Handler(mux)`},{url:"/p/oj3izfu/",title:"Hugo で新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo)",date:"2022-08-17T00:00:00+09:00",body:"Hugo で新しいページや別のサイトへ自動でリダイレクトする (aliases, redirectTo) 既存の Web ページの URL を変更した場合は、古い URL にアクセスしたときに自動的に新しい URL にリダイレクトされるようにしておくと親切です。 ここでは、2 種類のリダイレクト方法を説明します。 aliases を使う方法 &hellip; 同じ Hugo サイト内でリダイレクトする redirectTo を使う方法（独自） &hellip; 別のサイトへリダイレクトする aliases を使う方法 同一の Hugo サイト内でページの URL を変更した場合は、新しいページのフロントマターに aliases プロパティを追加し、以前の URL を列挙しておきます。 古いページの Markdown ファイルは削除します。 content/new-page/_index.md --- title: &#34;新しい URL のページ&#34; date: &#34;2022-08-17&#34; aliases: - /old-page - /old-page2 - /old-page3 --- 本文... 上記のように記述しておくと、古いページの URL (https://examle.com/old-page) にアクセスしたときに、新しいページの URL (https://example.com/new-page) にリダイレクトしてくれます。 この仕組みは単純で、aliases に列挙した URL に対応するように、Hugo が次のような内容のファイルを出力しています。 public/old-page/index.html &lt;!DOCTYPE html&gt; &lt;html lang=&#34;ja-jp&#34;&gt; &lt;head&gt; &lt;title&gt;https://example.com/new-page/&lt;/title&gt; &lt;link rel=&#34;canonical&#34; href=&#34;https://example.com/new-page/&#34;&gt; &lt;meta name=&#34;robots&#34; content=&#34;noindex&#34;&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0; url=https://example.com/new-page/&#34;&gt; &lt;/head&gt; &lt;/html&gt; meta 要素を使って、Web ブラウザに新しい URL にジャンプするように指示しています。 さらに、link 要素の Canonical URL として新しい URL を設定することで、Google などの検索エンジンに、正しい URL はこちらですよと知らせています。 redirectTo を使う方法（独自） 応用として、別の Web サイトにリダイレクトしたい場合を考えてみます。 前述の aliases を使う方法は、あくまで同じ Hugo サイト内でのリダイレクトを想定しています。 別ドメインへのリダイレクトを行う方法は Hugo 標準では用意されていないようなので、フロントマターに独自のプロパティ redirectTo を指定できるようにしてみます。 まず、リダイレクト用の出力を行えるように、独自の redirect レイアウトテンプレートを作っておきます。 内容は、Hugo の aliases.html を真似しています（.Permalink の部分を .Params.redirectTo に置き換えています）。 layouts/redirect.html &lt;!DOCTYPE html&gt; &lt;html{{ with site.LanguageCode | default site.Language.Lang }} lang=&#34;{{ . }}&#34;{{ end }}&gt; &lt;head&gt; &lt;title&gt;{{ .Params.redirectTo }}&lt;/title&gt; &lt;link rel=&#34;canonical&#34; href=&#34;{{ .Params.redirectTo }}&#34;&gt; &lt;meta name=&#34;robots&#34; content=&#34;noindex&#34;&gt; &lt;meta charset=&#34;utf-8&#34;&gt; &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0; url={{ .Params.redirectTo }}&#34;&gt; &lt;/head&gt; &lt;/html&gt; あとは、リダイレクトさせたいページのフロントマターで、このレイアウトを使うように指定すれば OK です。 リダイレクト先の URL は、redirectTo プロパティで設定します。 さらに、_build プロパティ を指定して、ページのコレクションとして列挙されないようにしておくのがよさそうです。 content/old-page/_index.md --- title: &#34;別のサイトへリダイレクトさせたいページ&#34; layout: redirect redirectTo: &#34;https://google.com&#34; _build: { list: false } --- これで、https://example.com/old-page/ にアクセスしたときに、https://google.com にリダイレクトされるようになります。"},{url:"/p/4ox6dmu/",title:"Golang で環境変数を扱う (os.Getenv, os.LookupEnv)",date:"2022-08-13T00:00:00+09:00",body:`Golang で環境変数を扱う (os.Getenv, os.LookupEnv) Go 言語で OS の環境変数を扱うには、標準ライブラリの os パッケージ を使用します。 環境変数を参照する (os.Getenv, os.LookupEnv) os.Getenv 関数 を使うと、特定の環境変数を参照することができます。 指定した名前の環境変数が設定されていない場合は、空文字列 (&quot;&quot;) を返します。 main.go package main import ( &#34;fmt&#34; &#34;os&#34; ) func main() { shell := os.Getenv(&#34;SHELL&#34;) if shell == &#34;&#34; { fmt.Println(&#34;環境変数 SHELL が設定されていません&#34;) return } fmt.Printf(&#34;SHELL = %s\\n&#34;, shell) } 環境変数の値として、明示的に空文字列が設定されていることを判別したい場合は、os.Getenv の代わりに os.LookupEnv 関数 関数を使用します。 os.LookupEnv は、2 番目の bool 型戻り値で、環境変数が設定されているかどうかを返します。 val, ok := os.LookupEnv(key) if !ok { fmt.Printf(&#34;%s not set\\n&#34;, key) } else { fmt.Printf(&#34;%s=%s\\n&#34;, key, val) } 文字列リテラルで環境変数を参照する (s.ExpandEnv) 環境変数の値を文字列に展開したいことはよくあります。 そのような場合は、os.ExpandEnv 関数 を使用すると、文字列リテラル内で $key や \${key} という形で環境変数を展開できます。 s := os.ExpandEnv(&#34;環境変数 HOME の値は \${HOME} です&#34;) fmt.Println(s) すべての環境変数を参照する (os.Environ) os.Environ 関数 は、すべての環境変数を文字列配列で返します。 ただし、それぞれの要素は key=value という文字列になっているので、キーと値を別々に取り出したい場合は、= で文字列分割する必要があります。 package main import ( &#34;fmt&#34; &#34;os&#34; &#34;strings&#34; ) func main() { for _, env := range os.Environ() { arr := strings.SplitN(env, &#34;=&#34;, 2) key, val := arr[0], arr[1] fmt.Printf(&#34;%s =&gt; %s\\n&#34;, key, val) } } （おまけ）具体的な使用例 例: 環境変数でサーバーのポート番号を指定する 次の例では、何らかのサーバーで使用するポート番号を、環境変数 PORT で指定できるようにしています。 環境変版を指定しなかった場合は、デフォルトで 3000 番ポートを使用します。 package main import ( &#34;fmt&#34; &#34;os&#34; &#34;strconv&#34; ) const defaultPort = 3000 // 使用するポート番号を取得します func getPort() (int) { // 環境変数 PORT の値を参照 port := os.Getenv(&#34;PORT&#34;) if port == &#34;&#34; { return defaultPort } // 環境変数の値は文字列型なので数値に変換して返す portNum, err := strconv.Atoi(port) if err != nil { fmt.Fprintf(os.Stderr, &#34;PORT &#39;%s&#39; is not valid\\n&#34;, port) return defaultPort } return portNum } func main() { port := getPort() fmt.Printf(&#34;Server is running at port %d\\n&#34;, port) }`},{url:"/p/8r3cmu5/",title:"Docker Compose で環境変数を使用する (env_file, environment)",date:"2022-07-03T00:00:00+09:00",body:"Docker Compose で環境変数を使用する (env_file, environment) 環境変数を参照する Docker Compose の Compose ファイル (docker-compose.yml) 内では、次のように OS（シェル）の環境変数の値を参照することができます。 例: 環境変数 TAG の値を参照する services: web: image: &#34;webapp:${TAG}&#34; この仕組みを利用すると環境に依存する値をハードコードしなくて済むようになるため、汎用的な docker-compose.yml を記述できるようになります。 上記の例では、${TAG} のように記述していますが、多くのケースでは $TAG のようにカッコを省略することができます。 ドル記号 ($) そのものを扱いたい場合は、$$ のように記述する必要があります。 .env ファイル .env ファイルは自動で読み込まれる docker compose up コマンドは、プロジェクトディレクトリに置いてある環境ファイル .env を読み込んでくれます。 .env ファイルには、次のように複数の環境変数を定義しておくことができます。 .env の記述例 # この行はコメント MYAPP_PORT=3000 DB_PASSWORD=mypassword 別の .env ファイルを参照する docker compose コマンドの --env-file オプションを指定すると、参照する .env ファイルを切り替えることができます。 例: .env ではなく .env.prod を参照する $ docker compose --env-file .env.prod up 優先順位 シェル環境で同じ名前の環境変数がセットされている場合（例: export MYAPP_PORT=4000）は、そちらが優先して使われます。 つまり、.env ファイルで定義されている値は、シェル環境変数がセットされていない場合のデフォルト値のように扱われます。 環境変数の優先順位: OS の環境変数（シェル環境）でセットした値。例えば、bash シェルであれば export FOO=BAR のように設定した値 プロジェクトディレクトリの .env ファイルで定義した値 環境変数が定義されていない場合の振る舞い 環境変数 VARIABLE が定義されていないときに、Compose ファイルの中で ${VARIABLE} のように参照すると、空文字列 (&quot;&quot;) として評価されます。 この振る舞いは次のような参照方法によって変更することができます（この構文は、bash の変数展開の構文 に基づいています）。 環境変数が設定されていないときにデフォルト値を使用する ${VARIABLE:-default} … 変数 VARIABLE がセットされていないか空文字のときに、default で指定された値を使用します。 ${VARIABLE-default} … 変数 VARIABLE がセットされていないときに、default で指定された値を使用します（VARIABLE に空文字がセットされているときは、そのまま空文字を使います）。 次の例では、web サービスのデフォルトのホスト側ポート番号を 8000 番に設定しています（コンテナ側のポート番号は 80 で固定です）。 docker-compose.yml services: web: image: nginx ports: - &#34;${APP_PORT:-8000}:80&#34; 実行例 $ docker compose up # localhost:8000 でアクセスできるようになる 次のように APP_PORT の値を明示すると、ホスト側のポート番号は 8000 ではなく、3000 が使われるようになります。 $ APP_PORT=3000 docker compose up # localhost:3000 でアクセスできるようになる 環境変数が設定されていないときにエラーにする ${VARIABLE:?err} … 変数 VARIABLE がセットされていないか空文字のときに、err メッセージを表示して終了します（実際には err を省略して ${VARIABLE:?} と書くだけでもそれっぽいエラーメッセージが表示されます） ${VARIABLE?err} … 変数 VARIABLE がセットされていないときに、err メッセージを表示して終了します（VARIABLE に空文字がセットされているときは空文字を使います） 次の例では、PostgreSQL のパスワードを環境変数 POSTGRES_PASSWORD でセットしておくことを強制しています。 docker-compose.yml services: db: image: postgres restart: always environment: - POSTGRES_USER=${POSTGRES_USER:-root} - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:?} - POSTGRES_DB=${POSTGRES_DB:-mydb} 環境変数 POSTGRES_PASSWORD を設定せずにサービスを起動しようとすると、次のようにエラーになります。 $ docker compose up invalid interpolation format for services.db.environment.[]: &#34;required variable POSTGRES_PASSWORD is missing a value: &#34;. You may need to escape any $ with another $ 各コンテナの環境変数を設定する Compose ファイル (docker-compose.yml) の中では OS（シェル）の環境変数を参照できますが、それらがそのまま各コンテナに渡されるわけではありません。 environment プロパティによる指定 各コンテナの環境変数を設定するには、各サービスの定義で environment プロパティを指定する必要があります。 次の例では、web サービス（コンテナ）の環境変数 DEBUG の値を 1 にセットしています。 これは、docker run -e DEBUG=1 ... のようにコンテナを起動するのと同じ効果があります。 docker-compose.yml services: web: image: nginx ports: - &#34;80:80&#34; environment: - DEBUG=1 ホスト側の環境変数（.env で定義したものを含む）の値をそのままコンテナに渡したいときは、次のように環境変数名だけを記述します。 これは、docker run -e DEBUG ... のようにコンテナを起動するのと同じ効果があります。 environment: - DEBUG env_file プロパティによる指定 コンテナに渡す環境変数の一覧を .env ファイルに記述しておき、そのファイル名を env_file プロパティで指定する、という方法もあります。 web-vars.env DB_NAME=mydb DB_USER=root DB_PASSWORD=mypassword docker-compose.yml services: web: image: nginx ports: - &#34;80:80&#34; env_file: - web-vars.env 優先度 次のように、env_file と environment が両方指定されていて、同じ環境変数がセットされている場合は、Compose ファイルに直接記述された environment の方が優先されます。 services: web: image: nginx ports: - &#34;80:80&#34; env_file: - web-vars.env environment: - DB_NAME=xxxxx - DB_USER=yyyyy docker compose config コマンドを実行すると、実際にどのような環境変数がコンテナに設定されるかを確認できます。 $ docker compose config name: myproject services: web: environment: DB_NAME: xxxxx DB_PASSWORD: mypassword DB_USER: yyyyy ...（省略）..."},{url:"/p/qm5k2hx/",title:"Docker Compose の基本",date:"2022-07-03T00:00:00+09:00",body:"Docker Compose の基本 Docker Compose とは？ Docker Compose (docker compose) を使うと、複数の Docker コンテナをまとめてコントロールすることができます。 各コンテナの起動時に必要となるパラメーターや連携方法を docker-compose.yml という YAML ファイルにまとめて記述できるため、すべてのコンテナの起動を docker compose up というシンプルなコマンドで行うことができます。 Docker Compose は複数のコンテナをコントロールすることを想定していますが、単一のコンテナを起動するときにも便利 です。 例えば、Dockerfile を使ったイメージビルド、ポート番号のマッピング、ネットワークの定義などを docker-compose.yml で定義しておいて、docker compose up コマンド一発で実行できます。 docker-compose.yml の中では環境変数の値を参照できる（例: ${APP_PORT}）ため、環境ごとに異なる値をハードコードしなくて済みます。 また、docker compose up コマンドは、環境変数を定義した .env ファイルを自動的に読み込んでくれます。 単一のコンテナを起動してみる Docker Compose で簡単な nginx サーバーを立ち上げてみます。 Docker Compose は、デフォルトで カレントディレクトリ名をプロジェクト名として使用します（-p オプションで任意のプロジェクト名を付けることもできます）。 ここでは、myproject というディレクトリを作って、その中に Compose ファイル (docker-compose.yml) を配置することにします。 $ mkdir myproject $ cd myproject 次のようなシンプルな Compose ファイルを作成します。 docker-compose.yml services: web: image: nginx ports: - &#34;80:80&#34; 各サービス（コンテナ）の定義は、services プロパティの下に記述していきます。 この例では、web という名前のサービスを 1 つだけ定義しており、その下の image プロパティで nginx のイメージを使うよう指示しています。 さらに、ports プロパティで、ホストの 80 番ポートへのアクセスをコンテナの 80 番ポートへ転送しています。 この定義で生成されるコンテナの名前は web ではなく、プロジェクト名や連番が付加された myproject-web-1 という名前になります。 Compose ファイル (docker-compose.yml) のあるディレクトリで docker compose up コマンドを実行すると、コンテナを作成＆起動できます。 $ docker compose up 停止したいときは、Ctrl-C を入力するとすべてのコンテナが停止します（今回は 1 コンテナだけですが）。 初回起動時には、nginx のイメージなどがダウンロードされるため少し時間がかかりますが、しばらくすると myproject-web-1 コンテナが起動し、http://localhost/（あるいは http://127.0.0.1/）で Web ページにアクセスできるようになります。 別のターミナル（端末）を開いて次のように実行すると、myproject-web-1 というコンテナが起動していることを確認できます。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cf2aa5a2b831 nginx &#34;/docker-entrypoint.…&#34; 10 minutes ago Up 5 minutes 0.0.0.0:80-&gt;80/tcp myproject-web-1 参考: Docker Compose をデタッチモードで起動する (docker compose up -d) 応用 Dockerfile からイメージをビルドする 独自の Dockerfile を使ってイメージを構築してコンテナを起動したいときは、サービスの定義の中で image プロパティの代わりに build プロパティを使用します。 設定する値は、Dockerfile があるディレクトリのパスです。 次の docker-compose.yml は、カレントディレクトリ (.) にある Dockerfile を使ってイメージをビルドし、コンテナを起動します。 services: web: build: . ports: - &#34;3000:3000&#34; 複数のコンテナを起動する services プロパティ以下には、複数のサービスを定義することができます。 次の docker-compose.yml では、web と redis の 2 つのサービスを定義しています。 services: web: build: . ports: - &#34;3000:3000&#34; redis: image: &#34;redis:alpine&#34; web サービスは独自の Dockerfile からイメージをビルドし、redis サービスは Docker Hub レジストリ上の redis:alpine イメージを使うよう指定しています。 redis サービスは同一の Docker ネットワーク内にある web サービスから参照できればよいので、ports プロパティによるポート転送設定は必要ありません。 docker compose up を実行すると、次のような名前の 2 つのコンテナが起動します。 &lt;PROJECT-NAME&gt;-web-1 &lt;PROJECT-NAME&gt;-redis-1 ひとつの Compose ファイルで定義したサービスは同一の Docker ネットワーク（例: myproject_default）に配置されるため、それぞれのコンテナは互いにコンテナ名で参照することができます。 上記の例でいうと、web サービスの中では、redis というホスト名で Redis サービスを参照できます。 Web アプリの実装の中から、Redis コンテナに割り当てられた IP アドレスを意識しなくて済みます（逆に言うと、変化しやすい IP アドレスをもとに通信すべきではありません）。 参考: Docker のネットワークについて理解する"},{url:"/p/94m3izf/",title:"Docker Compose をデタッチモードで起動する (docker compose up -d)",date:"2022-07-03T00:00:00+09:00",body:"Docker Compose をデタッチモードで起動する (docker compose up -d) docker compose up コマンドを実行すると、現在のターミナル（端末）に入出力がアタッチされて Docker Compose のログが出力されるようになるため、その端末では別の入力作業ができなくなってしまいます（Ctrl-D で停止できます）。 $ docker compose up [+] Running 2/0 ⠿ Network myproject_default Created ⠿ Container myproject-web-1 Created Attaching to myproject-web-1 ...（省略）... myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker processes myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 31 myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 32 ...（省略）... docker compose up コマンドを実行するときに、-d (--detach) オプションを指定すると、Docker Compose がデタッチモードで起動（バックグラウンド実行）されるため、その端末を引き続き使用できるようになります。 $ docker compose up -d [+] Running 1/1 ⠿ Container myproject-web-1 Started $ （次のコマンドを入力可能） 表示されなくなったログは、docker compose logs コマンドで確認できます。 $ docker compose logs ...（省略）... myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker processes myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 31 myproject-web-1 | 2022/07/01 06:50:46 [notice] 1#1: start worker process 32 ...（省略）... Docker Compose で動作しているコンテナの一覧は docker compose ps で確認できます。 $ docker compose ps NAME COMMAND SERVICE STATUS PORTS myproject-web-1 &#34;/docker-entrypoint.…&#34; web running 0.0.0.0:80-&gt;80/tcp デタッチモードで起動したコンテナをすべて停止するには docker compose stop コマンド、停止されたコンテナを起動するには docker compose start コマンドを使用します。 $ docker compose stop # コンテナを停止 $ docker compose start # 停止中のコンテナを起動 コンテナやネットワークをすべて削除するには、docker compose down コマンドを実行します。 こちらは停止ではなくて削除なので気をつけてください。 $ docker compose down # コンテナとネットワークの削除 $ docker compose down --volumes # ボリュームまで削除する場合 なお、上記のようなコマンドは、対象の docker-compose.yml があるディレクトリ内（プロジェクト内）で実行する必要があります。 別のディレクトリから実行したいときは、-p オプションでプロジェクト名（デフォルトではディレクトリ名）を指定します。 $ docker compose -p myproject ps"},{url:"/p/4ohyhxe/",title:"Docker Hub のイメージを検索する (docker search)",date:"2022-07-03T00:00:00+09:00",body:"Docker Hub のイメージを検索する (docker search) docker search コマンドを使って、Docker Hub（レジストリ）で公開されているイメージを検索することができます。 次の例では、ubuntu というキーワードでイメージを検索しています。 Docker Hub 上で付けられたスターの数や、公式イメージかどうかもチェックできます。 $ docker search ubuntu NAME DESCRIPTION STARS OFFICIAL AUTOMATED ubuntu Ubuntu is a Debian-based Linux operating sys… 14524 [OK] websphere-liberty WebSphere Liberty multi-architecture images … 286 [OK] ubuntu-upstart DEPRECATED, as is Upstart (find other proces… 112 [OK] neurodebian NeuroDebian provides neuroscience research s… 91 [OK] open-liberty Open Liberty multi-architecture images based… 53 [OK] ubuntu/nginx Nginx, a high-performance reverse proxy &amp; we… 52 ubuntu-debootstrap DEPRECATED; use &#34;ubuntu&#34; instead 46 [OK] ubuntu/apache2 Apache, a secure &amp; extensible open-source HT… 36 ubuntu/mysql MySQL open source fast, stable, multi-thread… 34 kasmweb/ubuntu-bionic-desktop Ubuntu productivity desktop for Kasm Workspa… 29 ubuntu/prometheus Prometheus is a systems and service monitori… 27 ubuntu/squid Squid is a caching proxy for the Web. Long-t… 25 ubuntu/bind9 BIND 9 is a very flexible, full-featured DNS… 22 ubuntu/postgres PostgreSQL is an open source object-relation… 17 ubuntu/redis Redis, an open source key-value store. Long-… 10 ubuntu/grafana Grafana, a feature rich metrics dashboard &amp; … 6 ubuntu/prometheus-alertmanager Alertmanager handles client alerts from Prom… 6 ubuntu/kafka Apache Kafka, a distributed event streaming … 6 ubuntu/memcached Memcached, in-memory keyvalue store for smal… 5 ubuntu/telegraf Telegraf collects, processes, aggregates &amp; w… 4 ubuntu/zookeeper ZooKeeper maintains configuration informatio… 4 ubuntu/cortex Cortex provides storage for Prometheus. Long… 3 ubuntu/cassandra Cassandra, an open source NoSQL distributed … 2 bitnami/ubuntu-base-buildpack Ubuntu base compilation image 2 [OK] ubuntu/loki Grafana Loki, a log aggregation system like … 0"},{url:"/p/najs2ah/",title:"Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal)",date:"2022-07-02T00:00:00+09:00",body:"Docker コンテナからホスト側のサーバーにアクセスする (host.docker.internal) コンテナからホスト側のサーバーにアクセスする Docker コンテナの中から、ホスト側で動作しているサービス（Web サーバーなど）にアクセスするには、IP アドレスの代わりに特殊な DNS 名 host.docker.internal を使用します（localhost だとコンテナ自身を参照してしまうのでうまくいきません）。 コンテナからホスト上のサービスにアクセスする $ curl http://host.docker.internal:8000/ 接続テスト テストとして、ホスト上で Web サーバーを起動してコンテナからアクセスしてみます。 まず、何でもいいのでホスト側で Web サーバーを起動します。 Docker で nginx サーバーを起動する方法 $ docker container run --rm -p 8000:80 --name webserver nginx:alpine Python のワンライナーで Web サーバーを起動する方法 $ python -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... 参考: Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) 次に、コンテナ側からこの Web サーバーに curl でアクセスできるか確認します。 ここでは、軽量のコンテナとして Alpine Linux を使っています。 コンテナからホスト側の Web サーバーにアクセス $ docker container run --rm -it alpine ash / # apk add curl / # curl http://host.docker.internal:8000/ &lt;!DOCTYPE html&gt; &lt;html&gt; ...（省略）..."},{url:"/p/7fjnqtw/",title:"Docker のネットワークについて理解する (none, host, bridge)",date:"2022-06-15T00:00:00+09:00",body:"Docker のネットワークについて理解する (none, host, bridge) Docker の 3 つのネットワーク Docker をインストールすると、デフォルトで none、host、bridge という 3 つのネットワークが生成されます。 docker network ls コマンドの出力の NAME カラムを見ると、これら 3 つの名前があることを確認できます。 $ docker network ls NETWORK ID NAME DRIVER SCOPE 1d32c46c83f6 bridge bridge local a97adbf7b226 host host local 7543afe52cd6 none null local none Docker コンテナにネットワークインタフェースを持たせたくない場合に指定します。 つまり、外部との通信が一切できないコンテナになります。 host ホスト側のネットワークインタフェースを共有するときに指定します。 つまり、ホストと同じ IP アドレスがコンテナに割り当てられます。 bridge 一番よく使用されるネットワークで、bridge という名前の仮想ブリッジに接続されたネットワーク環境であることを示します。 docker container create (run) でコンテナを作成するときにネットワーク (--net) を指定しないと、デフォルトでこの bridge が使われます。 Linux のブリッジ機能を利用しており、このネットワークに参加したコンテナからは、インターネットにアクセスすることができます。 同じ bridge に接続するコンテナは、同じ仮想ブリッジで接続された状態（同じネットワークに所属する状態）になるため、相互に通信ができます（ping など）。 Docker コンテナを作成する際には、どのネットワークを使うかを --net オプションで指定します。 指定しない場合はデフォルトで bridge が使われます。 例: ネットワーク接続できないコンテナを作成する $ docker container create --name my-ubuntu --net none ubuntu:22.04 bridge ネットワークのアドレスを確認してみる デフォルトで作成される bridge には、172.17.0.0/16 などのネットワークアドレスが割り当てられています。 $ docker network inspect bridge --format &#34;{{.IPAM.Config}}&#34; [{172.17.0.0/16 map[]}] このネットワークに参加させるコンテナには、172.17.0.2 や 172.17.0.3 などの IP アドレスが割り当てられていきます。 172.17.0.1 など、末尾が 1 のアドレスは通常はデフォルトゲートウェイに割り当てられています。 コンテナに割り当てられた IP アドレスを確認するには、次のようにコンテナ情報を表示します。 $ docker container inspect --format &#34;{{.NetworkSettings.IPAddress}}&#34; my-cont 172.17.0.2 あるいは、次のようにネットワーク情報を表示して、Containers プロパティ以下の情報を参照すれば、そのネットワークに参加しているすべてのコンテナの IP アドレスを確認できます。 $ docker network inspect bridge 新しいブリッジネットワークを作成すると、別のネットワークアドレス（172.18.0.0/16 など）が割り当てられます。 $ docker network create my-net $ docker network inspect my-net --format &#34;{{.IPAM.Config}}&#34; [{172.18.0.0/16 172.18.0.1 map[]}] Docker Compose を使えば、複数のコンテナを同一ネットワークに参加させるということをシンプルに表現できます。 ☝️ format オプションについて 上記の例では、--format オプションで出力を絞り込んでいますが、ここで使われている書式は、Go 言語の template パッケージ に従っています。 コンテナ名による通信 Docker ネットワークを作成し、コンテナをそのネットワークに参加させると、各コンテナ同士が コンテナ名 で通信できるようになります。 つまり、各コンテナに割り当てられた IP アドレスを知る必要がありません。 図: Docker コンテナ間のコンテナ名での通信 次のように実行すれば、コンテナ名で通信を行えることを確認できます。 （新しいネットワーク my-net を作成） $ docker network create my-net （1 つ目のコンテナ alpine1 を起動） $ docker run --rm -it --net my-net --name alpine1 alpine /bin/sh （別のターミナルから 2 つ目のコンテナ alpine2 を起動） $ docker run --rm -it --net my-net --name alpine2 alpine /bin/sh （コンテナ名で互いに ping できるか確認）　# ping alpine1 # ping alpine2 （コラム）仮想ブリッジ bridge0 Docker 用のブリッジは、ホスト側に bridge0 という名前の仮想ブリッジとして作成されます。 $ ifconfig bridge0 bridge0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=63&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt; ether 36:f6:6f:f3:5a:c0 Configuration: id 0:0:0:0:0:0 priority 0 hellotime 0 fwddelay 0 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 root id 0:0:0:0:0:0 priority 0 ifcost 0 port 0 ipfilter disabled flags 0x0 member: en1 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 10 priority 0 path cost 0 member: en2 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 11 priority 0 path cost 0 member: en3 flags=3&lt;LEARNING,DISCOVER&gt; ifmaxaddr 0 port 12 priority 0 path cost 0 Address cache: nd6 options=201&lt;PERFORMNUD,DAD&gt; media: &lt;unknown type&gt; status: inactive ちなみにこの bridge0 は、Docker Desktop for Windows/macOS を使っている場合は直接は参照できないことに注意してください。 Docker Desktop の場合は、その仮想マシン内に bridge0 が作成されます。"},{url:"/p/8fjnqtw/",title:"Docker のコンテナイメージを削除する (docker image rm/prune)",date:"2022-06-12T00:00:00+09:00",body:"Docker のコンテナイメージを削除する (docker image rm/prune) docker image rm （指定したコンテナイメージを削除する） 使い方 docker image pull や docker container run 経由でダウンロードした Docker イメージを削除するには、docker image rm コマンド（旧: docker rmi）を使用します。 $ docker image rm ＜イメージ＞ 削除するイメージは、イメージ名:タグ名 や イメージID の形で指定します。 $ docker image rm ubuntu:20.04 $ docker image rm 54c9d81cbb44 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB ヘルプ $ docker help image rm Usage: docker image rm [OPTIONS] IMAGE [IMAGE...] Remove one or more images Aliases: rm, rmi, remove Options: -f, --force Force removal of the image --no-prune Do not delete untagged parents docker image prune （使用していないコンテナイメージを削除する） 使い方 docker image prune コマンドを使用すると、使用していない Docker イメージをまとめて削除することができます。 $ docker image prune デフォルトでは、dangling images（エラーなどで予期せず残ってしまったイメージ）のみを削除します。 コンテナと関連づけられていないイメージをすべて削除するには、-a (--all) オプションを指定して実行します。 $ docker image prune -a ヘルプ $ docker help image prune Usage: docker image prune [OPTIONS] Remove unused images Options: -a, --all Remove all unused images, not just dangling ones --filter filter Provide filter values (e.g. &#39;until=&lt;timestamp&gt;&#39;) -f, --force Do not prompt for confirmation 参考 リポジトリ名のついていない Docker イメージをすべて削除する (docker image rm)"},{url:"/p/9hkprvx/",title:"Hugo で Markdown (.md) ファイルを VS Code で開くリンクを表示する",date:"2022-06-04T00:00:00+09:00",body:"Hugo で Markdown (.md) ファイルを VS Code で開くリンクを表示する VS Code で開くリンク 下記の Hugo テンプレートコードは、現在のページの生成元になった Markdown (.md) ファイルを VS Code で開くリンクを表示します（ローカルサーバーでの実行中のみ）。 {{- if hugo.IsServer }} {{- with .File }} &lt;a href=&#34;vscode://file/{{ .Filename }}&#34;&gt;✎ VS Code で開く&lt;/a&gt; {{- end }} {{- end }} 仕組み VS Code (Visual Studio Code) をインストールすると、ブラウザのアドレス欄に vscode://path&lt;ファイルのフルパス&gt; という特殊なアドレスを入力することで、ローカル PC 内のファイルを VS Code で開くことができるようになります。 例えば、/Users/maku/hugo-site/content/page.md というファイルを開きたいときは次のようなアドレスを入力します。 Linux や macOS の場合 vscode://file/Users/maku/hugo-site/content/page.md Windows の場合 vscode://file/C:\\Users\\maku\\hugo-site\\content\\page.md Markdown ファイルのパス情報は File 変数で参照できる ので、それを利用して a 要素を出力してやれば、リンクのクリックだけで VS Code を開くことができるようになります。"},{url:"/p/3adgjnq/",title:"Hugo の記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する",date:"2022-06-02T00:00:00+09:00",body:"Hugo の記事ページで TypeScript ファイルや NPM パッケージをインクルードして使用する js.Build の基本 Hugo Pipes のひとつである js.Build を使用すると、TypeScript ファイル (.ts) のビルドを行うことができます。 下記のショートコードは、記事ページにバンドルした .ts ファイルを .js ファイルにトランスパイルし、script 要素として出力する例です。 layouts/shortcodes/script.html {{- $src := .Get &#34;src&#34; -}} {{- $res := .Page.Resources.GetMatch $src -}} {{- $built := $res | js.Build -}} &lt;script src=&#34;{{ $built.RelPermalink }}&#34; defer&gt;&lt;/script&gt; このショートコードを使う記事ページ (.md) と TypeScript ファイル (.ts) は、次のような感じで content ディレクトリ以下の任意のディレクトリに配置します。 content/ sample-page/ index.md hello.ts ページバンドルの形にするため、記事ページは index.md というファイル名で作成し、同じディレクトリに .ts ファイルを配置することに注意してください。 content/sample-page/index.md --- title: &#34;サンプルページ&#34; --- {{&lt; script src=&#34;hello.ts&#34; &gt;}} content/sample-page/hello.ts alert(&#39;Hello!&#39;) assets ディレクトリに配置した ts ファイルを参照する 前述の例では、ページバンドルした .ts ファイルを参照しましたが、プロジェクト全体で使う .ts ファイルは、共有リソースとして assets ディレクトリ以下に入れておくと便利です（assets ディレクトリには、ビルド時に何らかの変換を行うファイルを配置します）。 assets/js/hello2.ts alert(&#39;Hello2&#39;) assets ディレクトリ以下のリソースを参照するために、ショートコードを少しだけ変更する必要があります（.Page.Resources.GetMatch を resources.Get に置き換えます）。 ここでは、別のショートコード (script-shared.html) として作成することにします。 layouts/shortcodes/script-shared.html {{- $src := .Get &#34;src&#34; -}} {{- $res := resources.Get $src -}} {{- $built := $res | js.Build -}} &lt;script src=&#34;{{ $built.RelPermalink }}&#34; defer&gt;&lt;/script&gt; ショートコードの使い方は、前述の例と同様です。 .ts ファイルのパスは、assets ディレクトリからの相対パスで指定します。 content/test.md --- title: &#34;テストページ&#34; --- {{&lt; script-shared src=&#34;js/hello2.ts&#34; &gt;}} ちなみに、assets ディレクトリに配置した .ts ファイルは、js.Build への入力ファイルとして使われるだけで、最終的なビルド結果（public ディレクトリ）にコピーされることはありません。 上記の例の場合は、トランスパイル後の public/js/hello2.js だけが出力されます。 NPM パッケージを使用する js.Build は、Hugo のプロジェクトルートに配置した node_modules ディレクトリを参照してくれます（ver 0.78.1 以降）。 つまり、npm install でインストールした NPM パッケージを使用できるということです。 ここでは、day.js という日付を扱うパッケージを使ってみます。 まず、Hugo プロジェクトのルートで次のように NPM パッケージをインストールします。 $ npm init -y # package.json の作成 $ npm install dayjs # dayjs パッケージのインストール あとは、TypeScript コードから普通に import して使えます。 assets/js/test.ts import dayjs from &#39;dayjs&#39; const s = dayjs(&#39;2019-01-25&#39;).format(&#39;DD/MM/YYYY&#39;) alert(s) もちろん、React などのパッケージも使えるので、Hugo のページ内に React コンポーネントを埋め込むといったことも可能です。 Hugo は自由度が高いですね。"},{url:"/p/9gjnqtw/",title:"Hugo のセクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight)",date:"2022-05-20T00:00:00+09:00",body:"Hugo のセクションページでいろいろな方法でページソートする (.ByDate, .ByTitle, .ByWeight) .Pages のデフォルトソート順序 Hugo のセクションページのテンプレート内で .Pages 変数を参照すると、子セクションや子ページの一覧を取得できますが、その一覧はデフォルトで次のような情報をもとにソートされています（参考: Lists of Content in Hugo - Order Content）。 Weight ページのフロントマターで weight: 1 のように書いておくと、ページに重み付けできます。 より小さな値の weight を持っているページの方が先に表示されます。 weight を持たないページ（あるいは weight: 0 のページ）は、いかなる weight を持つページよりも後ろに表示されます。 Date ページのフロントマターで、date: &quot;2022-05-20&quot; のように記述しておくと、そのページの作成日として認識されます。 より新しいページが先に表示されます。 LinkTitle / Title ページのタイトルで昇順ソートされます。 フロントマターに linkTitle が指定されていればその値でソートされ、なければ title の値でソートされます。 FilePath .md ファイルのフルパスで昇順ソートされます。 具体的のどのような実装になっているかは、下記 Hugo ソースコードの DefaultPageSort 関数あたりを見ると分かります。 参考: hugo/pages_sort.go ソート方法をカスタマイズする .Pages 変数でページの一覧を取得するときに .Pages.ByTitle のように指定すると、ページタイトルでソートされた結果を取得できます。 他にもいろいろな参照方法があります。 参照方法 意味 .Pages.ByWeight フロントマターの weight の小さい順。ただし、weight: 0 は指定なしとみなされる .Pages.ByTitle タイトル (title) 順 .Pages.ByLinkTitle タイトル (linkTitle) 順。linkTitle がない場合は title を参照する .Pages.ByDate 日付 (date) が新しい順 .Pages.ByPublishDate 日付 (publishdate) が新しい順 .Pages.ByExpiryDate 日付 (expirydate) が新しい順 .Pages.ByLastmod 日付 (lastmod) が新しい順 .Pages.ByLength 本文が短い順 .Pages.ByParam &quot;rating&quot; フロントマターの独自フィールドの値でソート（この場合は rating） .Pages.ByParam &quot;author.last_name&quot; 上の応用（入れ子になった独自フィールド） 逆順にしたいときは、後ろに .Reverse を付けます。 例えば次のようにすると、タイトルで降順ソート されます。 .Pages.ByTitle.Reverse セクションテンプレートの中に、次のようなスニペットを記述すれば、各種ソート条件でどのように表示されるかを確認できます。 この例では、ページタイトルで逆順ソートした結果を表示しています。 layouts/_default/section.html（抜粋） &lt;ul&gt; {{ range .Pages.ByTitle.Reverse }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Weight }} / {{ .Date.Format &#34;2006-01-02&#34; }} / {{ .LinkTitle }}&lt;/a&gt;&lt;/li&gt; {{ end }} &lt;/ul&gt; 応用: 複数の条件でソートする 前述の通り、.Pages はデフォルトで Weight → Date → LinkTitle → FilePath の優先度でソートされるのですが、これをカスタマイズして Weight → LinkTitle の順でソートしたい場合はちょっとややこしいです。 .Pages.ByWeight.ByTitle としてしまうと、Weight 順にソートされた結果がタイトル順で再度ソートされるだけでうまくいきません（.ByWeight の意味がなくなってしまいます）。 段階的にソートするには、まずグループ機能で同じ Weight を持つページを取り出し、そのグループ内でタイトル順ソートする必要があります。 次のパーシャルテンプレートは、渡された .Pages を Weight → LinkTitle の順でソートする関数です。 layouts/partials/functions/sort-pages.html {{- $pages := . }} {{- $pagesWithWeight := where $pages &#34;Weight&#34; &#34;&lt;&gt;&#34; 0 }} {{- $pagesWithoutWeight := where $pages &#34;Weight&#34; &#34;==&#34; 0 }} {{- $ret := slice }} {{- range $pagesWithWeight.GroupBy &#34;Weight&#34; }} {{- $ret = $ret | append .Pages.ByLinkTitle }} {{- end }} {{- $ret = $ret | append $pagesWithoutWeight.ByLinkTitle }} {{- return $ret }} あとは、セクションテンプレートなどから次のように使用します。 layouts/_default/section.html（抜粋） &lt;ul&gt; {{ range partial &#34;functions/sort-pages&#34; .Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt;&lt;/li&gt; {{ end }} &lt;/ul&gt;"},{url:"/p/uh84kfj/",title:"ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)",date:"2022-04-21T00:00:00+09:00",body:"ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages) （確認バージョン: Android 12 (S)） pm list packages コマンド adb shell pm list packages コマンドを使用すると、Android デバイスにインストールされているパッケージ (APK) の一覧を取得できます。 パッケージ名は順不同で表示されるので、出力をパイプで sort につなぐと見やすくなります。 $ adb shell pm list packages | sort ... package:com.google.android.apps.maps package:com.google.android.apps.messaging package:com.google.android.apps.nexuslauncher package:com.google.android.apps.photos package:com.google.android.apps.restore package:com.google.android.apps.wallpaper ... -f オプションを付けて実行すると、各 APK の インストール先のパス を調べることができます。 $ adb shell pm list packages -f | sort ... package:/system/priv-app/UserDictionaryProvider/UserDictionaryProvider.apk=com.android.providers.userdictionary package:/system/priv-app/VpnDialogs/VpnDialogs.apk=com.android.vpndialogs package:/system_ext/priv-app/CarrierConfig/CarrierConfig.apk=com.android.carrierconfig package:/system_ext/priv-app/EmergencyInfo/EmergencyInfo.apk=com.android.emergency ... -3 オプションを付けて実行すると、サードパーティ製のパッケージ の一覧を表示できます。 つまり、Google Play ストアからインストールしたアプリや、自分で作ってインストールしたアプリの一覧を確認できます。 $ adb shell pm list packages -3 package:com.example.myapp package:com.example.myapp2 （おまけ）pm help のヘルプ表示抜粋 adb shell pm help のヘルプ表示のうち、pm list packages コマンドに相当する部分の抜粋です。 list packages [-f] [-d] [-e] [-s] [-3] [-i] [-l] [-u] [-U] [--show-versioncode] [--apex-only] [--uid UID] [--user USER_ID] [FILTER] Prints all packages; optionally only those whose name contains the text in FILTER. Options are: -f: see their associated file -a: all known packages (but excluding APEXes) -d: filter to only show disabled packages -e: filter to only show enabled packages -s: filter to only show system packages -3: filter to only show third party packages -i: see the installer for the packages -l: ignored (used for compatibility with older releases) -U: also show the package UID -u: also include uninstalled packages --show-versioncode: also show the version code --apex-only: only show APEX packages --uid UID: filter to only show packages with the given UID --user USER_ID: only list packages belonging to the given user"},{url:"/p/bg2g4bu/",title:"ADB で Android 端末のバージョンや API レベルを調べる (getprop)",date:"2022-04-21T00:00:00+09:00",body:"ADB で Android 端末のバージョンや API レベルを調べる (getprop) ADB 経由で adb shell getprop コマンドを実行すると、Android 端末に設定されたシステムプロパティの一覧を取得することができます。 この中には、Android バージョンの情報も含まれています。 $ adb shell getprop | grep &#34;ro.product.build.version&#34; [ro.product.build.version.incremental]: [8015633] [ro.product.build.version.release]: [12] [ro.product.build.version.release_or_codename]: [12] [ro.product.build.version.sdk]: [32] この出力から次のようなことがわかります。 8015633 &hellip; ビルドナンバー 12 &hellip; Android のバージョン（この場合は Android S(12) を示す） 32 &hellip; SDK バージョン"},{url:"/p/whs2bjt/",title:"Go でコマンドラインツールを作って GitHub で公開する",date:"2022-04-10T00:00:00+09:00",body:"Go でコマンドラインツールを作って GitHub で公開する 何をするか？ ここでは、Go 言語の HelloWorld として、go-hello というコマンドを作って、GitHub で公開できるようにしてみます。 この手順が完了すると、世界中のユーザーが次のように go-hello コマンドをインストールできるようになります。 $ go install github.com/&lt;User&gt;/go-hello@latest go-hello プロジェクトの作成 まず、適当なディレクトリにプロジェクト用のディレクトリを作成します。 $ mkdir -p ~/go-hello $ cd ~/go-hello go mod コマンドで、プロジェクトのルートディレクトリに go.mod ファイルを作成します。 引数として、モジュール名（モジュールパス）を指定します。 GitHub で公開するのであれば次のような感じで指定します（maku77 の部分は自分の GitHub ユーザー ID に変更してください）。 $ go mod init github.com/maku77/go-hello 作成された go.mod の内容 module github.com/maku77/go-hello go 1.18 Go は、go.mod ファイルのあるディレクトリをモジュールルートとみなします。 go-hello コマンドの実装 実装 Go 言語では実行可能なコマンドは main パッケージの main 関数として実装します。 ファイル名は何でもよいのですが、ここでは main.go として作成します。 go-hello/main.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello, world!&#34;) } 動作確認 この Hello World プログラムは、go run コマンドでファイル名かディレクトリパスを指定して直接実行できます。 $ go run . Hello, world! go build コマンドを実行すれば、実行ファイル (go-hello) を生成することができます。 実行ファイル名は go mod init で指定したモジュール名にしたがって自動的につけられますが、-o オプションで明示することもできます。 $ go build $ ./go-hello Hello, world! go install コマンドを使うと、go-hello 実行ファイルが $GOPATH/bin（あるいは $GOBIN で指定したディレクトリ）にインストールされます（あらかじめ go build しておく必要はありません）。 Go 用の PATH 環境変数を設定 してあれば、どのディレクトリからでもインストールした go-hello コマンドを実行できるようになります。 $ go install $ go-hello Hello, world! インストールしたコマンドが不要になった場合は、次のように単純に実行ファイルを削除すれば OK です。 $ rm `go env GOPATH`/bin/go-hello # GOBIN 環境変数を設定済みであれば下記でも OK $ rm `go env GOBIN`/go-hello GitHub で go-hello モジュールを公開する 作成した Go モジュールを GitHub で公開します。 リポジトリの作成 まず、モジュール名に合わせて、GitHub にリポジトリを作成 します。 ここでは、&lt;User&gt;/go-hello という名前で作成します。 README.md と Go 言語用の .gitignore を自動生成しておくと便利です。 コミット＆プッシュ リポジトリを作成したら、適当な作業用ディレクトリに git clone します。 $ cd ~/gitwork $ git clone https://github.com/&lt;User&gt;/go-hello $ cd ~/gitwork/go-hello 前のステップで作成した go.mod や main.go ファイルをこのディレクトリにコピーしてコミット、プッシュします。 これで、GitHub への公開は完了です。 $ git add . $ git commit -m &#34;Add main function&#34; $ git push GitHub からコマンドをインストールしてみる GitHub への Go モジュールのデプロイが完了したら、GitHub から直接 go install してみます。 この際、取得するコードのバージョンをサフィックスとして指定する必要があります。 これは想定外のコードを使わないようにするための安全策です。 最新コードを信用してよいのであれば、次のように @latest を指定してインストールします。 $ go install github.com/maku77/go-hello@latest もう少しお行儀よくやるには、GitHub のコードにバージョンタグを付けておき、次のようにバージョンを指定してインストールします。 $ go install github.com/maku77/go-hello@v1.0.0 下記のように実行ファイルができていれば、うまくインストールできています。 $ ls `go env GOPATH`/bin go-hello $ go-hello Hello, world! 複数のコマンドを提供する 前述の例では、モジュール名を github.com/maku77/go-hello として、go-hello という名前のコマンド作成しました。 1 つのモジュールで複数のコマンドを提供したい場合は、コマンドごとにディレクトリを作成して、その中にそれぞれの main パッケージを構成します。 典型的なディレクトリ構成 としては、cmd ディレクトリを作って、その中にコマンド名と同名のディレクトリを作成します。 例えば、go-hello モジュール内に hello1 コマンドと hello2 コマンドを作成するには次のようなディレクトリ構成にします。 go-hello/ +- go.mod +- cmd/ +- hello1/main.go （hello1 コマンド用の main パッケージ） +- hello2/main.go （hello2 コマンド用の main パッケージ） go-hello/cmd/hello1/main.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello 1&#34;) } go-hello/cmd/hello2/main.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello 2&#34;) } 各コマンド用のディレクトリを go run で指定すれば実行できます。 ディレクトリ名は ./ で始まる相対パスで指定することに注意してください。 $ go run ./cmd/hello1 Hello1 $ go run ./cmd/hello2 Hello2 go run の代わりに go install を使えば、システムにコマンドをインストールできます。 $ go install ./cmd/hello1 $ go install ./cmd/hello2 # 次のようにまとめてインストールすることも可能です $ go install ./... これらのコードを GitHub にプッシュして公開すれば、世界中の人が次のように簡単にコマンドをインストールできるようになります。 $ go install github.com/maku77/go-hello/cmd/hello1@v1.0.0 $ go install github.com/maku77/go-hello/cmd/hello2@v1.0.0 # あるいは次のようにまとめてインストール $ go install github.com/maku77/go-hello/cmd/...@v1.0.0"},{url:"/p/s258beh/",title:"Go のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin)",date:"2022-04-10T00:00:00+09:00",body:"Go のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin) go install コマンドで Go の実行可能コマンドをインストールすると、次のようなディレクトリにコマンドがインストールされます。 GOBIN 環境変数が設定されていれば、$GOBIN が指すディレクトリ GOPATH 環境変数が設定されていれば、$GOPATH/bin が指すディレクトリ $HOME/go/bin ディレクトリ これらのディレクトリに OS のパスを通しておくと、どのディレクトリからでもインストールしたコマンドを実行できるようになります。 Linux や macOS であれば、~/.zlogin や ~/.bash_profile で次のような感じで設定できます。 ここでは、GOBIN 環境変数を設定して、コマンドのインストール先を ~/bin に設定しています。 ~/.zlogin export GOBIN=~/bin export PATH=$PATH:$GOBIN でも、なんだかんだ言って次のような標準的な構成にしておくとトラブルが少なくてよい気がします。 ~/.zlogin export GOPATH=$HOME/go export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN Windows の場合は、コントロールパネルの「環境変数を編集」から次のような感じで設定します（%USERPROFILE% 以外の変数を参照すると、うまく展開できなくて問題が出たりするので注意）。 GOPATH → %USERPROFILE%\\go GOBIN → %USERPROFILE%\\go\\bin PATH → %USERPROFILE%\\go\\bin （を PATH に追加） 上記のようにパスを通しておけば、go install でインストールしたコマンドを、どこからでも実行できるようになります。 $ go install github.com/maku77/go-hello@latest $ go-hello Hello, world!"},{url:"/p/3x95seb/",title:"nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager)",date:"2022-03-13T00:00:00+09:00",body:"nvm で複数の Node.js バージョンを切り替えて使用する (Node Version Manager) nvm (Node Version Manager) とは？ nvm というコマンドラインツールを使うと、システム内に複数バージョンの Node.js 実行環境をインストールして、切り替えて使うことができるようになります。 nvm 実行のために、あらかじめ Node.js をインストールしておく必要はありません。 $ nvm use 16 # node コマンドを version 16.x.x に切り替え（必要に応じてインストール） $ nvm use 14 # node コマンドを version 14.x.x に切り替え（必要に応じてインストール） 上記のように node コマンドのバージョンを簡単に切り替えることができるため、新しいバージョンの Node.js を試してみたいときや、複数バージョンでテストを行いたい場合に便利です。 nvm はスタンドアローン版の Node.js とも共存できるので、安心してインストールすることができます。 nvm を使わずにインストールされた Node.js は、system という名前で参照できるようになっています。 $ nvm use system # node コマンドをスタンドアローン版に切り替え nvm のインストール nvm コマンドは次のように簡単にインストールできます。 macOS や Linux の場合 $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 最新バージョンのインストール方法は nvm-sh/nvm - GitHub の公式サイトで確認してください。 インストール後は、ターミナル（bash など）を再起動するか、source ~/.bashrc を実行すると nvm コマンドを実行できるようになります。 Windows の場合 nvm はもともと Linux 系のコマンドラインツールとして作成されていますが、Windows でも nvm-windows のインストーラー を使えば簡単にインストールできます。 nvm の使い方 nvm が現在アクティブにしている Node.js のバージョンを調べるには、nvm current コマンドを使用します。 アクティブになっている Node.js バージョンを確認 $ nvm current system 上記のように system と表示される場合は、システムにすでにインストールされている（nvm を使わずにインストールした）Node.js がアクティブになっています。 まだ Node.js がインストールされていない環境の場合は none や No current version. のように表示されます。 使用する Node.js を nvm で切り替える場合、スタンドアローン版としてインストールされた Node.js 実行環境は必要なくなるので、不要なグローバルパッケージをアンインストールしておくとよいかもしれません（npm root -g で表示されたディレクトリをクリアする方法もあります）。 （必要があれば）スタンドアローン版の Node.js のグローバルパッケージを削除 $ npm list -g # グローバルパッケージの一覧を表示 $ sudo npm uninstall -g XXXX # 不要なパッケージをアンインストール nvm でインストール可能な Node.js バージョンの一覧は nvm list available コマンドで確認できます。 インストール可能なバージョンの一覧 $ nvm list available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 22.5.1 | 20.16.0 | 0.12.18 | 0.11.16 | | 22.5.0 | 20.15.1 | 0.12.17 | 0.11.15 | | 22.4.1 | 20.15.0 | 0.12.16 | 0.11.14 | | 22.4.0 | 20.14.0 | 0.12.15 | 0.11.13 | | 22.3.0 | 20.13.1 | 0.12.14 | 0.11.12 | | 22.2.0 | 20.13.0 | 0.12.13 | 0.11.11 | | 22.1.0 | 20.12.2 | 0.12.12 | 0.11.10 | | 22.0.0 | 20.12.1 | 0.12.11 | 0.11.9 | | 21.7.3 | 20.12.0 | 0.12.10 | 0.11.8 | | 21.7.2 | 20.11.1 | 0.12.9 | 0.11.7 | | 21.7.1 | 20.11.0 | 0.12.8 | 0.11.6 | | 21.7.0 | 20.10.0 | 0.12.7 | 0.11.5 | | 21.6.2 | 20.9.0 | 0.12.6 | 0.11.4 | | 21.6.1 | 18.20.4 | 0.12.5 | 0.11.3 | | 21.6.0 | 18.20.3 | 0.12.4 | 0.11.2 | | 21.5.0 | 18.20.2 | 0.12.3 | 0.11.1 | | 21.4.0 | 18.20.1 | 0.12.2 | 0.11.0 | | 21.3.0 | 18.20.0 | 0.12.1 | 0.9.12 | | 21.2.0 | 18.19.1 | 0.12.0 | 0.9.11 | | 21.1.0 | 18.19.0 | 0.10.48 | 0.9.10 | This is a partial list. For a complete list, visit https://nodejs.org/en/download/releases 上記の例では、最新バージョンは 22.5.1 で、LTS（長期サポート）バージョンが 20.16.0 であることが分かります。 特定のバージョンの Node.js をインストールしたいときは、nvm install &lt;ver&gt; コマンドを使用します。 次の例では、メジャーバージョン 22 の最新の Node.js をインストールしています。 最新バージョンをインストールするときは、バージョン番号の代わりに nvm install latest と指定することも可能です。 最新の LTS （長期サポート）バージョンをインストールしたいときは、nvm install lts と指定します。 nvm で Node.js をインストールする $ nvm install 20 # メジャーバージョンを指定してインストールする場合 Downloading node.js version 22.5.1 (64-bit)... $ nvm install latest # 最新バージョンをインストールする場合 Downloading node.js version 22.5.1 (64-bit)... $ nvm install lts # 最新の LTS 版をインストールする場合 Downloading node.js version 20.16.0 (64-bit)... 現在インストールされている Node.js バージョンの一覧は nvm list コマンドで確認できます。 インストール済みの Node.js バージョンの確認 $ nvm list 22.5.1 20.16.0 使用する Node.js のバージョンを切り替えるには、nvm use コマンドを使用します。 $ nvm use 22 # nvm でインストールしたバージョン 22 の Node.js を使う $ nvm use system # スタンドアローン版としてインストールされた Node.js を使う nvm ls コマンドの結果には、次のように各種エイリアス名が表示されることがあります。 $ nvm ls v14.19.0 -&gt; v16.14.0 system default -&gt; 16 (-&gt; v16.14.0) ... stable -&gt; 16.14 (-&gt; v16.14.0) (default) ... lts/gallium -&gt; v16.14.0 現在アクティブになっているバージョンには、行頭に -&gt; が表示されています（あるいは *）。 上記の例では、v16.14.0 がアクティブになっていることが分かります。 default -&gt; 16 のように矢印の左側に表示されている名前は、具体的なバージョンのエイリアス名を示しており、default などのエイリアス名が自動的に生成されます。 このエイリアスの仕組みによって、次のコマンドはいずれも v16.14.0 の切り替えを意味します。 $ nvm use 16 $ nvm use 16.14 $ nvm use v16.14.0 $ nvm use default $ nvm use stable $ nvm use lts/gallium $ nvm use --lts （参考までに LTS はオプションでも指定可能） default となっているのは、その名の通り、ターミナル起動時（bash シェル起動時）にデフォルトで有効になるバージョンとして扱われます。 nvm alias コマンドで、デフォルトのバージョンを変更することができます（この default エイリアスの実体は、~/.nvm/alias/default というファイルです）。 $ nvm alias default 14 ちなみに、各バージョンの Node.js 実行環境は、~/.nvm ディレクトリ以下にインストールされていきます（nvm root でディレクトリパスを確認可能）。 npm install -g でグローバルインストールした NPM パッケージも、各バージョンごとに管理されます（node_modules ディレクトリの場所は npm root -g で確認できます）。 多くのバージョンの Node.js をインストールすると、ホームディレクトリのサイズが肥大化していくので注意してください（1 バージョンごとに 100 MB くらい消費していきます）。 必要のなくなった Node.js バージョンは、適宜 nvm uninstall で削除しましょう。 $ nvm uninstall 14 （応用） .nvmrc ファイルで Node.js バージョンを揃える Node.js プロジェクトのルートディレクトリに .nvmrc ファイルを置くと、そのプロジェクトが想定する Node.js のバージョンを示すことができます。 例えば、プロジェクトで Node.js バージョン 14.19.x を使用するように統一したい場合は、次のように .nvmrc ファイルを作成して、Git などにコミットしておきます。 $ echo 14.19 &gt; .nvmrc このディレクトリより下のディレクトリで nvm install を引数なしで実行すると、.nvmrc に記述されたバージョンの Node.js がインストールされます。 $ nvm install Found &#39;/Users/maku/myapp/.nvmrc&#39; with version &lt;14.19.0&gt; Downloading and installing node v14.19.0... アクティブな Node.js バージョンを切り替える場合も、nvm use を引数なしで実行するだけで済みます。 $ nvm use Found &#39;/Users/maku/myapp/.nvmrc&#39; with version &lt;14.19.0&gt; Now using node v14.19.0 (npm v6.14.16) このように、nvm さえ入れておけば、プロジェクト全体で使用する Node.js のバージョンを簡単に揃えることができます。 （応用）最新環境に同じ NPM パッケージをインストールする 前述の通り、nvm install node コマンドを使用すると、最新の Node.js バージョンをインストールすることができますが、新しい環境の NPM グローバルパッケージはひとつずつ入れ直す必要があります。 現在アクティブになっている Node.js 環境にインストールされている NPM グローバルパッケージを、最新の Node.js 環境にすべてインストールするには次のように --reinstall-packages-from オプションを使用します。 $ nvm install node --reinstall-packages-from=current このオプションには、任意のエイリアス名を指定できます。 # 現在の最新環境 (node) にインストールされているパッケージを引き継ぐ $ nvm install node --reinstall-packages-from=node # 特定のバージョンにインストールされているパッケージを引き継ぐ $ nvm install node --reinstall-packages-from=16 デフォルトでは NPM パッケージのバージョンはすべて引き継がれますが、--latest-npm オプションを指定することで、最新の NPM パッケージをインストールすることができます。 新しい Node.js 環境では、新しいバージョンの NPM パッケージが必要になることも多いため、このオプションは指定しておいた方がいいかもしれません。 $ nvm install node --reinstall-packages-from=node --latest-npm"},{url:"/p/z3n4hye/",title:"Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する",date:"2022-03-01T00:00:00+09:00",body:"Docker のマルチステージビルドで軽量のアプリ実行用イメージを作成する マルチステージビルドとは？ ある GitHub のリポジトリに、Dockerfile と src/hello.go（Go 言語のコード）が入っているとします。 myapp/ +-- Dockerfile （アプリのビルド＆実行コンテナイメージの生成用） +-- src/hello.go （Hello World アプリのソースコード） この Dockerfile で作成したいのは、Go ソースコードをビルドしてできた hello アプリを実行するための Docker イメージです。 つまり、この Dockerfile ファイルには、次のようなイメージ生成手順を記述することになります。 src/hello.go をビルドして、実行ファイル hello を生成する。 hello を実行するための Docker コンテナイメージを生成する。 ここで 1 つ疑問が出てきます。 最終的な Docker イメージでは hello アプリの実行環境さえ整っていればよいはずですが、上記の手順通りに Docker イメージを構築すると、Go 言語のビルド環境まで含まれてしまいそうです。 hello アプリを実行するための軽量なイメージを作るにはどうしたらよいでしょうか？ このようなケースで便利なのが、Docker の マルチステージビルド です。 なお、アプリのソースコード (src/hello.go) には何を使ってもよいのですが、ここでは次のような簡単な Hello World コードを使うことにします。 src/hello.go package main import &#34;fmt&#34; func main() { fmt.Printf(&#34;Hello World\\n&#34;) } シングルステージビルドの場合 マルチステージビルドの効果を実感するために、まずはシングルステージによるビルド（従来のビルド方法）で Docker コンテナをビルドしてみます。 Dockerfile（シングルステージビルド） FROM golang:1.17 WORKDIR /work COPY src . RUN go build hello.go CMD [&#34;./hello&#34;] Go ソースコードのビルドを行うために、golang:1.17 をベースイメージとして使用しています。 ビルド手順はシンプルで、ホスト側の src ディレクトリ以下の Go ソースコードをコンテナ側の /work にコピーして、go build でビルドしているだけです。 次のように実行すれば、Docker イメージ (img-hello) が生成されます。 $ docker image build -t img-hello . 完成したイメージからコンテナを起動してみます。 Dockerfile に CMD 命令を記述しているので、次のようにするとデフォルトで ./hello アプリが実行されます。 --rm オプションを指定しておくと、実行後にコンテナを自動で削除してくれるので、一時的にコンテナを起動したいときに便利です。 $ docker container run --rm img-hello Hello World やったー！ うまく動いたー！ さっそくこの実行イメージを配布しよう！ ・・・・・・ ちょっと待って！！！ 作った Docker イメージ (img-hello) のサイズを見てみましょう。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE img-hello latest bcfd5668d079 About a minute ago 943MB 単純な Hello World アプリを実行したいだけなのに、Docker イメージのサイズが 1GB 弱もあります。 これは、ベースイメージの golang に Go 言語用のビルド環境がたくさん詰まっているからです。 Hello World アプリを実行するだけであれば、Go 言語のビルド環境は必要ないはずです。 そこで、マルチステージビルドの出番です。 マルチステージビルドの場合 マルチステージビルドを行うには、Dockerfile に 複数の FROM 命令 を含めます。 つまり、複数のベースイメージを切り替えながらビルドを進めていきます。 最終的なイメージは、最後の FROM 命令で指定したベースイメージをもとに生成されます。 構造的には次のような感じになります。 FROM xxx ... FROM yyy ... FROM zzz ... この場合、最終的に生成される Docker イメージは、ベースイメージ zzz を使って構築されます。 つまり、zzz には、アプリを実行するのに必要かつ最小限のベースイメージを指定すればよいことになります。 今回の hello アプリの場合は、次のような Dockerfile になります。 Go 言語のビルドでは、対象 OS やアーキテクチャを指定できるので、ここでは Linux の AMD64 環境をターゲットとして指定しています (GOOS=linux GOARCH=amd64)。 もちろん、実行環境のベースイメージはこのアーキテクチャに合わせる必要があります。 Dockerfile（マルチステージビルド） # 1st ステージ -- Go ソースコードをビルドするためのステージ FROM golang:1.17 AS builder WORKDIR /work COPY src . RUN GOOS=linux GOARCH=amd64 go build hello.go # 2nd ステージ -- 最終的な実行イメージを生成するためのステージ FROM amd64/alpine:3.15 WORKDIR /bin COPY --from=builder /work/hello . CMD [&#34;./hello&#34;] 1st ステージは、golang:1.17 イメージを使って Go ソースコードをビルドする役割を担います。 FROM 命令で、次のように AS builder としてエイリアス名 (builder) を割り当てていますが、これは後段のステージで、1st ステージ内で生成したファイルを参照しやすくするためのものです。 FROM golang:1.17 AS builder 2nd ステージは最終的な Docker イメージを生成する役割を担うので、FROM 命令で軽量な Alpine Linux を指定しています。 FROM alpine:3.15 そして、1st ステージで生成したアプリの実行ファイル /work/hello を /bin/hello にコピーしています。 WORKDIR /bin COPY --from=builder /work/hello . ここの --from=builder オプションで、1st ステージのファイルを参照することを示しています。 1st ステージの FROM 命令でエイリアス名を付けていない場合は、--from=0 のように番号で参照することもできますが、できるだけエイリアス名を付けておいた方がよいでしょう。 ビルド方法は、シングルステージビルドの場合と同様です。 $ docker image build -t img-hello . 実行方法も同じです。 $ docker container run --rm img-hello Hello World 最後に、マルチステージビルドによって生成された Docker イメージのサイズを確認してみます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE img-hello latest 638578ac0bdc About a minute ago 7.37MB なんと、イメージサイズが 100 分の 1 以下になりました！ このサイズであれば気楽に配布できそうです (^-^)"},{url:"/p/cqar8o5/",title:"Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp)",date:"2022-02-21T00:00:00+09:00",body:"Docker コンテナとホスト PC の間でファイルをコピーする (docker container cp) docker container cp コマンドを使用すると、Docker コンテナ内の任意のファイルやディレクトリを、ホスト PC にコピーすることができます。 例えば、以下のようにすると、mycon コンテナ内の /work/hello というファイルを、ホスト側のカレントディレクトリにコピーすることができます。 $ docker container cp mycon:/work/hello ./ ディレクトリごと丸ごとコピーすることもできます。 $ docker container cp mycon:/work/imgs ./imgs 逆に、ホスト側のファイルを Docker コンテナにコピーすることもできます。 $ docker container cp hoge.txt mycon:/work/tempdir"},{url:"/p/hxhzgxf/",title:"Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfs マウント）",date:"2022-01-25T00:00:00+09:00",body:"Docker のマウント機能でファイルを永続化する（ボリュームマウント、バインドマウント、tmpfs マウント） Docker の 3 種類のマウント Docker コンテナ内で作成・編集した作業ファイルは、コンテナを停止 (docker container stop) しても消えてしまうことはありませんが、コンテナを削除 (docker container rm) した場合には消えてしまいます。 これは、コンテナ内のファイル群が、コンテナ内に閉じて存在しているからです（だからこそコンテナなのですが）。 Docker のマウント機能を用いると、コンテナ内の特定のディレクトリパス（の中のファイル群）をホスト PC 上のファイルシステムに関連付けることができるため、コンテナのライフサイクルとは切り離して作業ファイルを管理できるようになります。 マウントには下記で説明する 3 種類がありますが、作業ファイルをホスト PC 側に永続化したい場合は、「ボリュームマウント」か「バインドマウント」というマウントタイプを使用します。 もうひとつの「tmpfs マウント」は、その名のとおりテンポラリファイルにのみ使用できます。 図: Docker の 3 種類のマウント（公式サイトより） ボリュームマウント ホスト PC 上にコンテナ用のデータファイルを作成 し、コンテナ内の特定のディレクトリパスにマッピングします。 このデータファイルはポータビリティが高く、クラウド上に保存するということもできます（ボリュームドライバーが必要）。 複数のコンテナから 1 つのボリュームを共有することも可能です。 コンテナ内で作成したファイルの永続化には、このボリュームの使用が推奨されています。 バインドマウント ホスト PC の特定のディレクトリ（絶対パス指定） を、コンテナ内の特定のディレクトリパスにマッピングします。 ボリュームと比べてポータビリティが低いため、名前付きボリュームの使用が推奨されてます。例えば、バインドマウントでは、ホスト側の多数のファイルとマッピングされてしまうため別環境に移しにくいとか、マウント時のパス表現が OS に依存してしまうといった欠点があります。 ホスト側からコンテナで操作したファイルをささっと覗いて見たいときはバインドマウントは便利ですが、これはコンテナ内で作成した危険なファイルが、そのままホスト上にも作られてしまうということを示しています。 tmpfs マウント ホスト PC のメモリ領域 を、コンテナ内の特定のディレクトリパスにマッピングします。コンテナ上でファイル生成を行うと、実際には一時的なメモリ領域に保存されることになるので、ここに保存されたファイルはコンテナを停止すると消えてしまいます。一時的なファイルを格納するディレクトリを tmpfs マウントすることで、コンテナサイズの増加を防ぐことができ（書き込みレイヤーに出力されない）、パフォーマンスの向上を見込めます。 上記で、「ホスト PC」といっているのは Docker コンテナの実行環境のことであり、Windows や macOS で Docker Desktop を使用している場合は、正確には Linux VM のことを示します。 ボリュームマウント (volume mount) の使い方 コンテナ内での作業内容（生成したファイル）をホスト PC 側に永続化したいときに最初に検討すべきは「ボリューム」の使用です。 ボリュームの実体はホスト PC 上のファイルシステム（Docker 管轄下）に永続化されたファイルであり、コンテナ側から見ると「ディレクトリ」として見えます。 ボリュームを作成する (docker volume create) ボリュームを明示的に作成するには次のように実行します（コンテナ実行時に自動生成することも可能です）。 ボリューム名を明示するので、名前付きボリューム (named volume) と呼ばれています。 $ docker volume create my-vol ボリュームの一覧を表示する (docker volume ls) Docker ホスト上に存在しているボリュームの一覧を表示するには、次のように実行します。 $ docker volume ls DRIVER VOLUME NAME local e61a091c345b2b969dd288f984be... local my-vol ← 今回作成したボリューム local out （ボリューム名がランダムな記号列になっているものは、匿名マウント時に自動生成されたボリュームです） ボリュームの詳細情報を表示する (docker volume inspect) 指定したボリュームの詳細情報を確認するには次のようにします。 $ docker volume inspect my-vol [ { &#34;CreatedAt&#34;: &#34;2022-01-25T07:18:24Z&#34;, &#34;Driver&#34;: &#34;local&#34;, &#34;Labels&#34;: null, &#34;Mountpoint&#34;: &#34;/var/lib/docker/volumes/my-vol/_data&#34;, &#34;Name&#34;: &#34;my-vol&#34;, &#34;Options&#34;: null, &#34;Scope&#34;: &#34;local&#34; } ] ボリュームを削除する (docker volume rm/prune) # ボリューム名を指定して削除 $ docker volume rm my-vol # 未使用のボリューム（どのコンテナからも参照されていないもの）をすべて削除 $ docker volume prune ボリュームマウントしてコンテナを起動する コンテナ側の /volume というパスに、上記で作成した my-vol ボリュームをマウントして使ってみます。 ここでは、軽量の Alpine Linux イメージ (alpine:latest) を使ってコンテナを作成します。 # コンテナ (my-alpine) の作成 $ docker container create -it --mount src=my-vol,dst=/volume --name my-alpine alpine:latest # コンテナが作成できているか確認 $ docker container ls -a --mount オプションの src や dst で、ボリューム名やマウント先のパスを指定します。 src=&lt;ボリューム名&gt; … src ではなく source でも OK。存在しないボリューム名を指定すると、その名前のボリュームが自動的に生成されます。src パラメーターを省略すると、ランダムな16進文字列の名前のボリュームが生成されます。 dst=&lt;コンテナ側のパス&gt; … dst ではなく destination や target でも OK。 type=&lt;マウントタイプ&gt; … ボリュームマウントの場合は省略できます。マウントタイプとして volume、bind、tmpfs を指定します。 （過去の記事には、-v オプションを使っているものもありますが、現在は公式に --mount オプションの使用が推奨されています（挙動がわかりにくく問題が発生しやすいなどの理由があります）。特別な事情がない限り、--mount オプションの方を使うようにしてください） コンテナを作成したら、次のようにして起動してシェル接続できます。 $ docker start -ai my-alpine コンテナ側の /volume というディレクトリが見えているかを確認してください。 この中にファイルを作成すると、ホスト OS 側のボリューム領域に内容が保存されるので、次回コンテナを起動 (docker start) したときにファイル編集作業の続きを行えます。 my-volume ボリュームを他のコンテナにマウントして共有するということもできます。 # ls /volume # 初期状態は空っぽ # echo Hello &gt; /volume/hello.txt # exit ボリュームファイルの格納場所 ボリュームのデータファイルは具体的にはホスト PC の /var/lib/docker/volumes に生成されますが、ボリュームは docker volume コマンドを介して操作するので、通常は保存先のパスを意識する必要はありません。 Windows や macOS で Docker Desktop を使用している場合は、Volumes タブでボリュームの一覧を確認することができます（Docker Desktop のバックエンドとして使われる Linux VM 上に格納されているため、Windows や macOS 上で上記のパスを探しても見つからないことに注意してください）。 図: Docker Desktop によるボリュームの確認 バインドマウント (bind mount) の使い方 バインドマウントは、ホスト OS 上のディレクトリをコンテナ側のディレクトリにマッピングします。 つまり、お互いのファイルシステム上で同じディレクトリ／ファイルを参照できるようになります。 次の例では、ホスト OS 上のカレントディレクトリにある data ディレクトリを、コンテナ側の /data にマウントしています。 ホスト OS 側のディレクトリは、存在するディレクトリを絶対パスで指定する必要があります（次の例では、&quot;$(pwd)/data&quot; で絶対パスを生成しています）。 $ mkdir data $ docker container create -it --mount type=bind,src=&#34;$(pwd)/data&#34;,dst=/data --name my-alpine alpine:latest バインドマウントするときは、上記のように --mount オプションで type=bind と指定する必要があります。 コンテナを起動してシェル接続し、適当なファイルを /data ディレクトリ以下に作成してみます。 $ docker container start -ai my-alpine # echo Hello &gt; /data/hello.txt # exit ホスト OS 側で data ディレクトリを見ると、コンテナで作成したファイルが存在していることを確認できます。 $ ls data hello.txt tmpfs マウントの使い方 tmpfs マウントを使用すると、ホスト OS 上のメモリ領域を一時ファイルシステムとして、コンテナ側のディレクトリにマッピングすることができます。 結果として、そのディレクトリ内に保存したファイルは、コンテナを停止したときに削除されます。 一時的にしか使用しないファイルは、tmpfs マウントしたディレクトリ内に作成することで、Docker イメージの肥大化を防ぐことができます。 また、そのファイルはメモリ上に生成されるため、パフォーマンス的にも有利です。 $ docker container create -it --mount type=tmpfs,dst=/sandbox --name my-alpine alpine:latest tmpfs マウントするときは、上記のように --mount オプションで type=tmpfs と指定する必要があります。 この例では、コンテナ側の /sandbox ディレクトリを tmpfs マウントのターゲットとしています。 コンテナを起動して /sandbox 内にファイルを作成し、コンテナを停止してみます。 $ docker start -ai my-alpine # echo Hello &gt; /sandbox/hello.txt # exit 再度コンテナを起動して /sandbox の中を見ると、上記で作成した hello.txt は消えていることがわかります。 $ docker start -ai my-alpine # ls /sandbox #"},{url:"/p/wyxzbdw/",title:"Python でファイルやディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move)",date:"2021-08-10T00:00:00+09:00",body:"Python でファイルやディレクトリをコピー、移動する (shutil.copyfile, shutil.copy, shutil.copytree, shutil.move) ファイルやディレクトリのコピーや移動を行うには、Python 標準ライブラリの shutil モジュール が提供する高水準のファイル操作 API を利用するのが簡単です。 ファイルをコピーする (shutil.copyfile, shutil.copy) shutil.copyfile 関数 shutil.copyfile 関数 で単一のファイルをコピーできます。 import shutil import sys try: shutil.copyfile(&#39;src.txt&#39;, &#39;dst.txt&#39;) except Exception as e: print(&#39;Error: {0}&#39;.format(e), file=sys.stderr) 同名のファイルがすでに存在する場合（上記の場合は dst.txt）は上書きされます。 shutil.copyfile 関数は次のようなエラーを発生させる可能性があります。 IsADirectoryError &hellip; コピー先として指定したファイル名と同名のディレクトリが存在する場合。 OSError &hellip; 指定したファイル名で書き込めない場合（バージョン 3.3 以降）。 SameFileError &hellip; コピー元とコピー先のファイル名が同じ場合（バージョン 3.4 以降）。 FileNotFoundError &hellip; 存在しないディレクトリ階層（aaa/bbb/dst.txt など）にコピーしようとした場合。 shutil.copy 関数 既存のディレクトリ以下に同じファイル名でコピーしたいときは、shutil.copyfile の代わりに shutil.copy 関数 を使用します。 # dst という名前でコピー、あるいは dst ディレクトリ以下にコピー shutil.copy(&#39;src.txt&#39;, &#39;dst&#39;) 上記のように実行すると、dst ディレクトリがない場合は dst というファイル名でコピーされ、dst ディレクトリが存在する場合は dst/src.txt としてコピーされます。 shutil.copyfile と shutil.copy の使い分け copyfile 関数と copy 関数の振る舞いの違いをまとめておきます。 違いは、ターゲットと同じ名前のディレクトリが存在しているときの振る舞いです。 shutil.copyfile('src.txt', 'dst') dst が存在しないとき: dst としてコピー dst ファイルが存在するとき: dst ファイルを上書き dst ディレクトリが存在するとき: エラー (IsADirectoryError) shutil.copy('src.txt', 'dst') dst が存在しないとき: dst としてコピー dst ファイルが存在するとき: dst ファイルを上書き dst ディレクトリが存在しないとき: dst/src.txt としてコピー なお、shutil.copyfile も shutil.copy もディレクトリをコピーすることはできません（IsADirectoryError が発生します）。 ディレクトリをコピーする (shutil.copytree) shutil.copytree 関数 を使用すると、指定したディレクトリを丸ごとコピーできます。 次の例では、src ディレクトリを dst ディレクトリとしてコピーします。 import shutil shutil.copytree(&#39;src&#39;, &#39;dst&#39;) すでにカレントディレクトリに dst という名前のファイルやディレクトリが存在する場合は FileExistsError が発生します。 ただし、次のように dirs_exist_ok フラグを True に設定すると、dst ディレクトリが存在していてもそのままコピーしようとします（dst 内のファイル群が上書きされるという動作になります）。 import shutil shutil.copytree(&#39;src&#39;, &#39;dst&#39;, dirs_exist_ok=True) shutil.copytree 関数には面白い機能が付いていて、次のように ignore パラメーターを利用すると、グロブパターンに一致したファイルやディレクトリをコピー対象から外すことができます（バージョン 3.8 以降）。 from shutil import copytree, ignore_patterns copytree(src, dst, ignore=ignore_patterns(&#39;*.pyc&#39;, &#39;tmp*&#39;)) ファイルやディレクトリを移動する (shutil.move) ファイルやディレクトリの移動は単純で、shutil.move 関数 一種類だけで実現できます。 import shutil shutil.move(&#39;src&#39;, &#39;dst&#39;) 上記のようにすると、src ファイル（あるいはディレクトリ）を、dst という名前に変更します。 すでに dst という名前のディレクトリが存在している場合は、dst ディレクトリ内に移動させようとします（dst/src ができる）。 つまり、Linux の mv コマンドのように振る舞います。 確実にリネームだけを実行したい場合は、os.rename 関数を使ってください。 参考: Python でファイルやディレクトリの名前を変更する (os.rename, os.renames) ファイルの存在を確認しておくのが安全 (os.path.exists) 基本的には、ファイルやディレクトリの移動やコピーを行う場合は、os.path.exists 関数 を使って、あらかじめ同名のファイルやディレクトリが存在していないかをチェックしておくのが安全です。 import os import shutil def check_and_copy(src, dst): &#34;&#34;&#34; ファイルをコピーします。 すでに同名のファイルが存在する場合は、確認プロンプトを表示します。 &#34;&#34;&#34; if os.path.exists(dst): if input(&#39;Overwrite?(y/n): &#39;) != &#39;y&#39;: return shutil.copyfile(src, dst) check_and_copy(&#39;src&#39;, &#39;dst&#39;)"},{url:"/p/vexfweu/",title:"Python の dictionary の内部的な要素順序を変更する (dict, OrderedDictionary)",date:"2021-07-24T00:00:00+09:00",body:"Python の dictionary の内部的な要素順序を変更する (dict, OrderedDictionary) dict が保持する要素の順序 Python の辞書オブジェクト (dict) は要素の追加順序を保持しており、要素のイテレート時や print での出力時はこの順序で出力されるようになっています（Python 3.7 以降）。 sample.py book = { &#39;id&#39;: &#39;123&#39;, &#39;authors&#39;: [&#39;Author 1&#39;], &#39;title&#39;: &#39;Title 1&#39; } print(book) 出力結果 {&#39;id&#39;: &#39;123&#39;, &#39;authors&#39;: [&#39;Author 1&#39;], &#39;title&#39;: &#39;Title 1&#39;} 単純にキー名のアルファベット順にループ処理したい場合は、例えば次のようにします。 キーのリストをソート for key in sorted(book.keys()): print(&#39;%s: %s&#39; % (key, book[key])) でもこれは、出力時に一時的なキーリストをソートしているだけで、辞書オブジェクト内部の要素順序を制御しているわけではありません。 次のようにすれば、あるキーの要素を辞書オブジェクト内で末尾に持ってくることができます。 book[&#39;id&#39;] = book.pop(&#39;id&#39;) 単純に id キーの要素を取り出して、再度辞書オブジェクトに追加しているだけです (^^; この後、print(book) とすると、id 要素が最後に出力されます。 もっといい方法があるかもしれませんが、この仕組みだけである程度柔軟な並び替えが可能です。 例えば、次の sort_dict 関数は、辞書オブジェクト内部の要素をキー名順に並び替える関数ですが、priority_keys 引数でキー名のリストを渡すと、それらのキーは優先的にその順番で先頭に並べられます。 sort_dict 関数の実装例 def sort_dict(d, priority_keys=()): &#34;&#34;&#34; 辞書オブジェクト d の要素を内部的にキー名でソートします。 ただし、priority_keys にキー名のリストが指定されたときは、 そのキーを優先的に先頭に並べます。 &#34;&#34;&#34; keys1 = list(filter(lambda k: k in d, priority_keys)) keys2 = sorted(d.keys() - keys1) for k in (keys1 + keys2): d[k] = d.pop(k) 下記はこの sort_dict 関数の使用例です。 book オブジェクト内のキーをアルファベット順にソートしつつ、id と title キーは優先的に先頭に並べるようにしています。 sort_dict 関数の使用例 import json book = { &#39;authors&#39;: [&#39;Maku&#39;, &#39;Ponyo&#39;, &#39;Chi&#39;], &#39;title&#39;: &#39;Title 1&#39;, &#39;id&#39;: &#39;123&#39;, &#39;note&#39;: &#39;Very interesting&#39; } sort_dict(book, (&#39;id&#39;, &#39;title&#39;)) print(json.dumps(book, indent=2)) 実行結果 { &#34;id&#34;: &#34;123&#34;, &#34;title&#34;: &#34;Title 1&#34;, &#34;authors&#34;: [ &#34;Maku&#34;, &#34;Ponyo&#34;, &#34;Chi&#34; ], &#34;note&#34;: &#34;Very interesting&#34; } OrderedDict について ちなみに、Python は dict のサブクラスとして collections.OrderedDict クラスを用意しています。 通常の dict が要素の追加順序を保持するようになった今、OrderedDict の出番はあまり多くないかもしれませんが、OrderedDict は独自のメソッドを備えていたりします。 例えば、指定した要素を末尾か先頭に移動させる move_to_end(key, last=True) メソッドがあります。 sample.py from collections import OrderedDict book = OrderedDict({ &#39;title&#39;: &#39;Title 1&#39;, &#39;authors&#39;: [&#39;Author 1&#39;], &#39;id&#39;: &#39;123&#39; }) book.move_to_end(&#39;title&#39;) # title を末尾へ book.move_to_end(&#39;id&#39;, last=False) # id を先頭へ print(dict(book)) 実行結果 {&#39;id&#39;: &#39;123&#39;, &#39;authors&#39;: [&#39;Author 1&#39;], &#39;title&#39;: &#39;Title 1&#39;}"},{url:"/p/4kdso44/",title:"Androidメモ: Jetpack Compose の宣言型 (declarative) の UI 定義とは？",date:"2021-07-07T00:00:00+09:00",body:"Androidメモ: Jetpack Compose の宣言型 (declarative) の UI 定義とは？ Jetpack Compose の宣言型プログラミングとは？ 2021 年の Google I/O で、Jetpack Compose が正式リリース (v1.0.0) されることが発表されました。 Compose は Android の新しい UI フレームワークで、declarative（宣言的） に UI を定義することができるのが特徴的です。 正確には、Compose のトップページでは declarative ではなく、intuitive（直感的） という表現がされているのですが、ソフトウェア開発の世界では declarative（宣言的）といった方が伝わりやすいと思います。 宣言型（宣言的）な UI 定義を一言で説明すると、「最終的に実現したいことを記述する」というアプローチです。 Jetpack のトップページには、次のようなサンプルコードが掲載されています。 @Composable fun JetpackCompose() { Card { var expanded = by remember { mutableStateOf(false) } Column(Modifier.clickable { expanded = !expanded }) { Image(painterResource(R.drawable.jetpack_compose)) AnimatedVisibility(expanded) { Text( text = &#34;Jetpack Compose&#34;, style = MaterialTheme.typography.h2, ) } } } } これは、ひとつのカード (Card) を表示するためのコードですが、多くの人がこのコードをパッと見たときの感想は、「ナニコレ？オイシイノ？」だと思います。 ポイントは、「こういった状態であれば、こう表示するよ」とだけ記述しているところです。 これでもまだ伝わらないかもしれないので、もう少し具体的な例で説明します。 例えば、あるアプリの「状態 A」では「ボタンを 3 つ表示する」とします。 declarative（宣言的）なコードと、従来の imperative（命令的）なコードでは、実装が次のように変ってきます。 declarative（宣言的）なコード 状態 A なので、ボタンを 3 つ表示する。 imperative（命令的）なコード 状態 A なので、ボタンを 3 つ表示する必要がある。ただし、すでに中央のボタンを表示しているので、その左右にひとつずつボタンを追加する。 従来の、XML のレイアウトファイルを使って Kotlin コードでゴリゴリ制御するというやり方は、後者の imperative（命令的）な実装です。 実装者が、現在のアプリ状態と、UI の表示状態をうまく整合性が取れるように制御してやる必要がありました。 Compose を使うと、最終的な表示結果を意識すればよいので、実装者の負担が減り、コードの見通しもよくなります。 Compose のトップページで次のように記述されているのは、こういうことです。 直感的 UI を記述するだけで、残りの部分は Compose で処理されます。アプリの状態が変更されると、UI が自動的に更新されます。 React や IaC と同じ考え方では？ はい。 React の関数コンポーネントをそのまま Android に持ってきた感じですね。 React (JavaScript) のコードがこちら。 function Button(label, onPress) { const [count, setCount] = useState(0) // ... } Compose (Kotlin) のコードがこちら。 @Composable fun Button(label: String, onPress: () -&gt; Unit) { val count = remember { mutableStateOf(0) } // ... } ほぼ同じです。 React のフックの仕組み (useState など）に対応するもの (mutableStateOf) もあります。 宣言型 (declarative) なパラダイムは、次のような IaC (Infrastructure as Code) の世界でも取り入れられています。 Ansible Azure ResourceManager AWS CloudFormation これらは、クラウドリソースや PC 内の環境構築を自動化するためのツールですが、シェルスクリプトなどで構築手順を記述するのではなく、静的な YAML/JSON ファイルなどを使って「最終的に目指すべき構成」を定義するところが、まさに declarative（宣言的）です。 もっというと、AI による自動コード生成も究極の宣言型ですね。 GitHub Copilot などは、コメントや関数名で最終的にやりたいことを記述するだけでコードができるという。。。 こう考えると、ソフトウェア開発のやり方が declarative（宣言的）な方向に向かっていくのは自然な流れなのかもしれません。 Android は ちょっと古い 枯れた技術しか使わないというイメージが強いですが、やっと declarative なプログラミングパラダイムにも対応してきました。 宣言的 UI フレームワークは色々ありますが、Android で使える有名どころのフレームワークは、Compose、Flutter、React Native などがあります。 簡単にまとめるとこんな感じでしょうか。 フレームワーク（ライブラリ） 言語 特徴 Android 特有機能 Jetpack Compose Kotlin Android 専用 ◎ Flutter Dart Android/iOS 共通 〇 React Native JavaScript Android/iOS 共通 △ なんだかんだ言っても、Anrdoid の標準開発言語である Kotlin が使える Jetpack Compose が主流になっていきそうな気はします。 Jetpack Compose を使ってみる ここで、Compose を使った実装方法を詳細に述べることはしませんが、Jetpack Compose は簡単に使い始めることができます。 Android Studio でプロジェクトを作成するときに、Empty Compose Activity を選択すれば、Jetpack Compose を使ったテンプレートプロジェクトが自動作成されます。 次のような依存パッケージの定義も自動的に build.gradle に追加されます。 implementation &#34;androidx.compose.ui:ui:$compose_version&#34; implementation &#34;androidx.compose.material:material:$compose_version&#34; implementation &#34;androidx.compose.ui:ui-tooling:$compose_version&#34; 現時点では、次のような Hello Android! と表示されるだけのプロジェクトが生成されました。 package com.example.myapplication import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.compose.material.MaterialTheme import androidx.compose.material.Surface import androidx.compose.material.Text import androidx.compose.runtime.Composable import androidx.compose.ui.tooling.preview.Preview import com.example.myapplication.ui.theme.MyApplicationTheme class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { MyApplicationTheme { // A surface container using the &#39;background&#39; color from the theme Surface(color = MaterialTheme.colors.background) { Greeting(&#34;Android&#34;) } } } } } @Composable fun Greeting(name: String) { Text(text = &#34;Hello $name!&#34;) } @Preview(showBackground = true) @Composable fun DefaultPreview() { MyApplicationTheme { Greeting(&#34;Android&#34;) } }"},{url:"/p/26hr2bk/",title:"dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認）",date:"2021-03-09T00:00:00+09:00",body:"dumpsys gfxinfo でジャンクフレームの発生率を調べる（60FPSの確認） Janky frames 情報を取得する Android デバイス上で実行可能なコマンド dumpsys gfxinfo を使用すると、指定したアプリにおける Janky frames（ジャンクフレーム）の発生率を調べることができます。 Janky frame の説明は「dropped frame」と書かれていたりしますが、60FPS 出ていないフレーム（16.6ミリ秒以上かかったフレーム）だと考えればよいと思います。 アプリの UI が、どの程度ぬるぬるさくさくなアニメーション (60FPS) を達成できているかを定量的に調べたいときに使えるかもしれません。 $ adb shell dumpsys gfxinfo com.example.myapp | grep frames Total frames rendered: 544 Janky frames: 242 (44.56%) 本来 dumpsys gfxinfo の出力はもっと長いのですが、上記では frames という単語で grep してフィルタしちゃってます（Windows なら findstr を使えば OK）。 Janky frames の発生率を確認したいのであれば、これが手っ取り早いです。 dumpsys gfxinfo の詳細は下記ドキュメントが参考になります。 参考: UI パフォーマンスをテストする｜Android デベロッパー フレームの計測単位 Total frames rendered は、アプリを起動してからの総フレーム数を表しています。 ただし、この数はフレームメトリクスとして計測されたフレームのみが対象で、アニメーションが発生していないときは増加しません。 これは、開発者オプションの Profile HWUI rendering を有効にしたときに、画面上にバーが増えていく速度と同じです。 図: Profile HWUI rendering Janky frames としてカウントされているのは、このバーが緑色のライン（16.6ミリ秒）を超えているもののようです（太くて濃いバーになっているもの）。 上の図の場合は、最初の30％くらいが緑色の水平ラインを超えているので、Janky frames は約30％ということです。 フレームの統計情報をリセットする 何らかのアニメーションのパフォーマンスを計測したい場合は、アプリ起動時からのフレーム統計ではなく、そのタイミングだけでの統計情報が欲しいと思います。 そのような場合は、まずは次のように Android が収集しているフレーム統計情報をリセットします。 $ adb shell dumpsys gfxinfo &lt;PACKAGE_NAME&gt; reset リセットしたいだけでも統計情報がだらだらと表示されてしまうので、Linux なら &gt; /dev/null、Windows なら &gt; nul にリダイレクトして出力を消した方がいいかもしれません。 その後、何らかのユーザー操作を発生して、再度 dumpsys gfxinfo で統計情報を確認すれば OK です。 ちなみに、開発者オプションの Profile HWUI rendering で画面上に GPU バーを表示している場合、上記のリセットコマンドを実行すると、このバー表示もクリアされます（内部で同じ gfxinfo 情報を参照していることが分かります）。 （応用）ユーザー操作 → パフォーマンス計測を自動化 次のバッチファイルは、次のような操作を自動化しています。 com.example.myapp アプリのフレーム統計情報をリセット 1 秒待つ 下キーを 30 回押す（リスト UI などをスクロールさせることを想定） 1 秒待つ フレーム統計情報 (Janky frames) を出力 janktest.cmd @echo off adb shell dumpsys gfxinfo com.example.myapp reset &gt; nul timeout /t 1 /nobreak &gt; nul FOR /L %%A IN (1, 1, 30) DO ( adb shell input keyevent DPAD_DOWN ) timeout /t 1 /nobreak &gt; nul adb shell dumpsys gfxinfo com.example.myapp | findstr frames 実行例 C:\\&gt; janktest.cmd （自動操作が終わるまでしばらく待つ） Total frames rendered: 400 Janky frames: 200 (50.00%) うーむ、60FPS 安定までの道のりは長いです。。。 参考: ADB からキー入力やテキスト入力を行う (input text, input keyevent)"},{url:"/p/ehu5eox/",title:"Perfetto でシステム全体のパフォーマンスを計測する",date:"2021-03-09T00:00:00+09:00",body:"Perfetto でシステム全体のパフォーマンスを計測する Perfetto とは Android 端末のシステム全体のプロファイリングを行うには、Perfetto というツールを使用します。 システム全体の動作を調査する場合、従来は Systrace を使っていましたが、Android 10 (Q) 以降は、より洗練された Perfetto で分析を行うことができます。 Perfetto - System profiling, app tracing and trace analysis - Perfetto Tracing Docs Android には Perfetto 用のトレースデーモンと、トレースデータを取得するための perfetto コマンドが標準搭載されています。 取得したトレースデータは、Perfetto の Web アプリ (Perfetto UI) から読み込んで、グラフィカルな UI で分析を行うことができます。 開発 PC と Android 端末が Bluetooth や USB 接続されていれば、Perfetto UI から直接トレースデータを取得することができます。 Perfetto デーモンの有効化 （この設定は、Android 10 (Q) の端末でのみ必要です。Android 11 (R) 以降は必要ありません） perfetto コマンドでトレースを開始するには、Android 端末上で Perfetto デーモンを起動しておく必要があります。 次のようにシステムプロパティを設定すれば、Perfetto デーモンが起動します。 $ adb shell setprop persist.traced.enable 1 これは persist プレフィックスの付いたプロパティなので、設定が不揮発メモリに保存されます。 Android 端末を再起動したときに設定しなおす必要はありません。 正しく Perfetto デーモンが起動していれば、次のような Logcat ログが出力されます。 $ adb logcat -s perfetto --------- beginning of main 03-09 21:38:37.139 21766 21766 I perfetto: probes.cc:56 Starting /system/bin/traced_probes service 03-09 21:38:37.140 21765 21765 W perfetto: service.cc:65 Started traced, listening on /dev/socket/traced_producer /dev/socket/traced_consumer 03-09 21:38:37.141 21766 21766 I perfetto: probes_producer.cc:88 Connected to the service Perfetto トレースデータの取得 次のように Android 端末上の perfetto コマンドを実行すると、トレース結果が /data/misc/perfetto-traces/trace ファイルとして出力されます。 出力先は -o (--out) オプションで変更できますが、SELinux のセキュリティ制限のため、/data/misc/perfetto-traces ディレクトリしか指定できないようになっています（errno: 13, Permission denied が発生します）。 $ adb shell perfetto --config :test --out /data/misc/perfetto-traces/trace --config :test というオプションは、perfetto コマンドにハードコードされたテスト設定を使用することを示しています（参考: Perfetto trace config）。 トレースファイルは下記のようにローカル PC へダウンロードできます。 $ adb pull /data/misc/perfetto-traces/trace あるいは、 $ adb shell cat /data/misc/perfetto-traces/trace &gt; ~/trace 以下のようにして、ディレクトリごとダウンロードすることもできます。 $ adb pull /data/misc/perfetto-traces 取得したトレースファイルを Perfetto UI のサイト で開けば、グラフィカルに分析を行うことができます。 Perfetto のトレース設定 perfetto コマンドを実行するときにパラメーターを指定することで、計測時間や取得するデータのカスタマイズを行えます。 設定方法は大きく分けて、下記の 2 通りの方法があります。 lightweight mode -t/--time などの個々のパラメーターを 1 つずつ設定する方法。従来の systrace と同様の指定 (atrace、ftrace) を行うだけでよければこの方法が使えます。 normal mode -c/--config オプションでコンフィグファイルを指定する方法。lightweight mode より詳細なトレース設定を行うことができます。 参考: perfetto コマンドのコマンドラインオプション。 lightweight mode（個別パラメーターで指定する方法） perfetto コマンドを実行するときに、次のようなオプションを使って、トレース方法を設定する方法です。 adb shell perfetto [--time TIMESPEC] [--buffer SIZE] [--size SIZE] [ATRACE_CAT | FTRACE_GROUP/FTRACE_NAME]... -t/--time TIMESPEC &hellip; トレース時間。使える単位は s、m、h（デフォルト: 10s）。 -b/--buffer SIZE &hellip; リングバッファサイズ。使える単位は mb、gb（デフォルト: 32mb)。 -s/--size SIZE &hellip; 最大ファイルサイズ。使える単位は mb、gb（デフォルトはリングバッファサイズ？）。 ATRACE_CAT &hellip; トレースする atrace カテゴリ（例: am wm gfx view など）を指定。参考: Tracing categories（実装） FTRACE_GROUP/FTRACE_NAME &hellip; トレースする ftrace グループ（カーネル系のトレース）（例: sched/sched_switch、sched/*） 例）3秒間、gfx、input、view、sched をトレースする $ adb shell perfetto -o /data/misc/perfetto-traces/trace -t 3s gfx input view sched normal mode（コンフィグファイルで指定する方法） perfetto 用の設定をコンフィグファイルの形で保存しておけば、--config オプションでそのファイル名を指定するだけで毎回同じ設定でトレースできます。 perfetto コマンドはデバイス上で実行する都合上、コンフィグファイルはデバイス上に作成しなければいけないことに注意してください。 ただ、ファイル名として - を指定すると標準入力から設定テキストを流し込むことができるので、これを使えばローカル PC 上のコンフィグファイルの内容をそのまま渡せます。 $ cat config.pbtx | adb shell perfetto -o /data/misc/perfetto-traces/trace --txt -c - Windows の場合は cat を type に置き換えてください。 下記はコンフィグファイルの記述例です。 このようなテキスト形式のコンフィグファイルを指定する場合は、-c/--config オプションに加えて、--txt オプションも同時に指定する必要があります。 コンフィグファイルの例 (perfetto-config.pbtx) duration_ms: 5000 buffers: { size_kb: 8960 fill_policy: DISCARD } data_sources { config { name: &#34;linux.ftrace&#34; ftrace_config { # Enables events for a specific app. atrace_apps: &#34;com.example.myapp&#34; # Enables all events for all apps. # atrace_apps: &#34;*&#34; # Enables specific system events tags. atrace_categories: &#34;gfx&#34; atrace_categories: &#34;input&#34; atrace_categories: &#34;view&#34; atrace_categories: &#34;sched&#34; # ftrace_events: &#34;sched/sched_switch&#34; # ftrace_events: &#34;power/suspend_resume&#34; # ftrace_events: &#34;sched/sched_process_exit&#34; # ftrace_events: &#34;sched/sched_process_free&#34; # ftrace_events: &#34;task/task_newtask&#34; # ftrace_events: &#34;task/task_rename&#34; # ftrace_events: &#34;ftrace/print&#34; } } } （応用）簡単にトレース取得できるようスクリプト化 下記のバッチファイルを実行すると、perfetto-20210309-213055.pb のようなタイムスタンプ入りのトレースファイルを作成し、ローカル PC にダウンロードします。 トレースの設定は、先頭部分の DURATION 変数や ATRACE 変数である程度柔軟にカスタマイズできます。 perfetto デーモンが起動していない場合は、設定のヒントを表示して終了するようにしています。 get-perfetto.cmd（Windows用） @echo off setlocal REM Perfetto configuration set DURATION=3s set ATRACE=gfx view input sched set FTRACE= REM Check if the perfetto daemon is enabled for /f &#34;usebackq delims=&#34; %%A in ( `adb shell getprop persist.traced.enable` ) do set PERFET_ENABLED=%%A if not &#34;%PERFET_ENABLED%&#34;==&#34;1&#34; ( echo Trace daemon is not started. Try the following command. echo adb shell setprop persist.traced.enable 1 exit /b ) REM Generate a filename by the current date and time set mydate=%DATE% set mytime=%TIME% set year=%mydate:~0,4% set month=%mydate:~5,2% set day=%mydate:~8,2% set hour=%mytime:~0,2% set minute=%mytime:~3,2% set second=%mytime:~6,2% set filename=perfetto-%year%%month%%day%-%hour%%minute%%second%.pb REM Start tracing adb shell perfetto --out /data/misc/perfetto-traces/%filename% -t %DURATION% %ATRACE% %FTRACE% REM Download the trace file adb pull /data/misc/perfetto-traces/%filename%"},{url:"/p/sfqyajt/",title:"Android アプリのパフォーマンス改善のためのチェックリスト",date:"2021-03-08T00:00:00+09:00",body:"Android アプリのパフォーマンス改善のためのチェックリスト はじめに パフォーマンスの最適化を行うには、フレームワーク特有の知識と、プロファイラによる計測 の両面から攻めていく必要があります。 アプリケーションを 60FPS の描画性能で動作させるには、1フレームあたりわずか 16.6 ミリ秒で処理を終えなければいけません。 複雑な計算処理や描画を行うアプリケーションにおいて、常に 60FPS を達成するのは非常に大変で、考えるべきことがたくさんあります。 ここでは、Android アプリのパフォーマンス改善のヒントをまとめておきます。 パフォーマンス可視化自動化のススメ 定期的にパフォーマンスに関するプロファイリングを行うのはよいことですが、もっといい方法は、パフォーマンスに関する計測を自動化＆見える化 することです。 例えば次のような仕組みを作り、普段の開発では常に有効化しておきます。 各フェーズの実行にかかった時間を、画面上に自動で表示する 画面上に FPS を表示する 各端末のパフォーマンス（メトリクス情報）を自動でサーバーに送り、統計をグラフ化する このような仕組みを作り込んでおけば、チームメンバー全員が普段からパフォーマンスを意識 して開発できるようになります。 アーキテクトだけにプロファイリング作業を任せたり、プロジェクト終盤になってからパフォーマンス計測をはじめたりするのはやめましょう。 コードを作り込んでからデータ構造やスレッド戦略を変更するのはとても大変で、手遅れになることが多いです。 上記の仕組みによって表示された結果は、製品リリースのためのパフォーマンスクライテリアを満たしているかの指標にもなります。 まずは計測 FPS の確認（1 フレームあたり何ミリ秒かかっているか） 開発者オプションから GPU バー表示を ON にして確認 GPU レンダリング速度のプロファイリング Profile HWUI rendering の設定は ADB で OFF/ON する と素早く切り替えられる 何らかの操作をしているときに、赤色のライン (16.6ms) を上回ることがないか を調べる Window.OnFrameMetricsAvailableListener でフレームごとのメトリクス情報を取得できる Firebase などを使えるのであれば、メトリクス情報をサーバー集計することが可能 Choreographer を使ってプログラム内で FPS を確認する 方法もあり adb shell dumpsys gfxinfo PKG名 | grep frames で ジャンクフレーム発生率を調べる オーバードローの確認（Debug GPU overdraw で何度も重ねて描画している部分がないか確認） レイアウトの確認（Layout Inspector で無駄なネストを確認） 全般的なボトルネックの確認 CPU Profiler でアプリ内のボトルネックを調査（Traceview はサポート終了） 各スレッドのビジー状態や、どのメソッドに時間がかかっているか を調べる → メソッド単位の最適化 GC (Garbage Collection) が頻繁に発生していないか を調べる (Perfeto/SystraceAllocation Tracker)。 Perfetto でシステム全体のボトルネックを調査 他のプロセスとの Binder 通信などがボトルネックになっていなかを調べる adb shell perfetto で計測開始するか、Perfetto の Web アプリから直接データ取得可能（要 Bluetooth/USB 接続） 昔は Systrace だったけど、Android 10 以降は Perfetto で。 改善ポイント 背景色描画の削減 背景色は、テーマ、Activity、Fragment、View のいずれかのレイヤで一回のみ指定する テーマの背景色が余計なときは、テーマの定義で android:windowbackground=&quot;null&quot; するか、Activity で window.setBackgroundDrawable(null) する カスタムビュー内のオーバードローをチェック onDraw 内の描画で重なって見えない部分は clipRect でマスクする。カスタムビューの描画内容は Android フレームワークが最適化することができない レイアウトをフラット化 ListView → ConstraintLayout / RelativeLayout レイアウトリソースの Inflate 時間短縮 Layout XML の Inflate 処理時間が短縮したいなら、レイアウト情報をハードコード する手もあり カスタムビューにして onDraw を実装 スレッド戦略 各種処理をどのようなスレッド上で実行するか設計する。各メソッドに スレッドアノテーション を付けてみる（Main/UI、Worker スレッド間の呼び出しで警告してくれる） Kotlin のコルーチンで実行スレッドを分ける。 Dispatcher.Main &hellip; メインスレッド（ここの処理は最小限に） Dispatcher.Default &hellip; ワーカースレッド（ほとんどの処理はここで実行する） Dispatcher.IO &hellip; I/O アクセス、ネットワーク処理など メインスレッドの処理を極小化 例えば、Android のユーザー入力イベントはメインスレッドでハンドルされるので、ViewModel のメソッドをトリガにコルーチン起動 (viewModelScope.launch) し、その中から戻り値なしの別コンテキスト（スレッド）処理を呼び出し (withContext(Dispatcher.Default)) て、メインスレッドはそのまま抜けるようにする。画面反映は LiveData からの更新通知のタイミングで行えばよい。ViewModel クラスには戻り値を持つ public メソッド (getter) を作らないということ（それは同期処理を意味する）。 並列化できる処理を見極める 順序依存のない処理は同時に開始する ように書き換える（とくに画面遷移後の初期化処理など） 最後に Join の必要な並列処理は coroutineScope { ... async { ... }} など スレッドのキャンセル、間引き処理 キー連打や同種のイベントが連続発生する可能性がある場合は、要求をコマンド化してキューイングして間引く（Command パターン） あえてシングルスレッドでキュー処理して (SingleThreadExecutor)、新しい要求が来たらキューを空にするとか（最新要求だけ処理） 排他制御のデザインパターン 排他制御によるロック時間を最小化するパターンを学ぶ。例えば、Read-Write Lock パターンでは、Read スレッド同士は排他制御する必要がないことを示している（Java の標準クラスにも ReadWriteLock がある）。 頻繁な GC の抑制 onDraw 内でオブジェクト生成しないようにする（アニメーション中の GC 発生を抑制） ループ内で一時オブジェクトを生成しないようにする Flyweight パターンでオブジェクトを共有する オブジェクトプールでオブジェクトを使いまわす（Android の Message クラス が参考になる (Message.obtain() でプールから取得 → recycle() でプールに戻す)） その他 キャッシュ関連処理は全般的に難しいが重要 時間のかかる関数呼び出し結果はメモ化 キャッシュコントロール（いつ消すかなど）は、基本的には HTTP の Cache-Control レスポンスヘッダの stale-while-revalidate 拡張 (RFC 5861) を参考にするとよい。簡単にいうと、キャッシュで高速に描画しつつ、背後でキャッシュの更新処理を走らせるという考え方。 シーケンシャルサーチ (indexOf) 処理はマップ処理に置き換える（O(n) → O(1)） ログ出力用のオブジェクト生成（主にテキスト構築）を削除（if (DEBUG) で引数生成部分ごと囲む） 画像ファイルに PNG ではなく WebP フォーマットを使用する 起動時 (onCreate) での初期化コードは最低限にする（各種処理の遅延化） onResume へ遅らせる スレッド起動するだけにする レイアウトの Inflate 処理を遅らせる (ViewStub で次のフレームへ遅らせる） DI による依存注入処理を Dagger/Hilt で遅延させる コールバックオブジェクトの共通化 補足メモ Android Profiler で関数レベルのボトルネックを探る Android Studio の Android Profiler から CPU ペーンを開き、Record ボタンを押してレコード開始 → 何らかの操作をしてレコード停止 レコード中は動作が重くなるので、トレース結果は実時間で速度を見るのでなく、全体時間に対してどの程度の割合で時間がかかっているかで見る 正確に呼び出し情報をトレースするために、プロファイルモードで Trace Java Methods を選択しておく。Sample Java Methods は一定間隔でサンプリングするだけなので、動作は軽いけど正確な呼び出し情報が取れない Android Profiler でデバイスを認識しない時は、デバイス側の開発者オプションで USB デバッグが有効になっているかを確かめる 本質的に遅いメソッドを見つけるには、Bottom Up タブを選択 → Self 時間でソートする 先に main スレッドのチャート上でメソッドを選択しておくと、右側の分析ペーンの結果をフィルタできる 図: Android Studio の Profiler 機能 Layout Inspector で無駄なレイアウト構成を見つける アプリ動作中に Layout Inspector を起動すると、リアルタイムに現在のレイアウト構造を確認することができます（Hierarchy Viewer はサポート終了）。 パフォーマンスへの影響を見るときは、主にレイアウトが 深いネスト構造になっていないか を調べます。 Layout Inspector は 3D 表示にして角度をずらして、Layer spacing スライダーを調整すると、どれだけ重なっているかがよく分かかります。 オーバードローされている部分を見つける 開発者オプションから Debug GPU overdraw（GPU オーバードローをデバッグ） を ON にすると、何度も重ねて描画してしまっている部分を確認できます。 不透明な部分を重ねて描画していると完全に無駄です。 参考: GPU オーバードローの視覚化 この設定は開発者オプションの深いところにあるので、ADB で OFF/ON するのが早い 何らかの操作をしているときに、赤や緑の矩形が表示されることがないか を調べる（できれば青の領域もない方がいい） オーバードローされている部分は Layout Inspector でレイアウトを確認 コールバックオブジェクトの共通化 例えば、RecyclerView.Adapter#onBindViewHolder の中で次のようにリスナー登録していると、そのビューが表示されるごとにリスナーオブジェクトが生成されることになります。 setOnClickListener { // ... } リスナー内の処理が共通であれば、共通のリスナーオブジェクトを使うようにします。 setOnClickListener(handleClick)"},{url:"/p/w5gs4ep/",title:"Hugo でクリックで開閉する accordion ショートコードを作成する",date:"2021-02-22T00:00:00+09:00",body:"Hugo でクリックで開閉する accordion ショートコードを作成する 図: accordion ショートコードによる開閉表示 ブログ記事内の補足的な説明テキストなどは、デフォルトでは非表示にしておいて、必要なときにクリックで開閉できるようにしておくとスッキリします。 このような UI コンポーネントは、アコーディオン (accordion) と呼ばれることが多いので、ここでは accordion という名前のショートコードとして作成してみます。 accordion ショートコードは次のように使うことを想定しています。 Markdown 内での使用例 {{% accordion title=&#34;もっと詳しく&#34; %}} この本文はデフォルトでは隠されていて、クリックで見えるようになります。 - サンプルコード - 補足説明 などに使うと便利です。 {{% /accordion %}} ☝️ ワンポイント 本文のテキストを Markdown コードとして処理するためには、ショートコード名を &lt; と &gt; ではなく、上記のように % で囲む必要があります。 下記は、accordion ショートコードの実装例です。 クリックによる HTML 要素の表示／非表示の切り替えは、input 要素の状態による CSS の切り替えテクニック を利用しています。 label 要素と input 要素を結びつける ID には、Hugo の関数でランダムに生成した文字列 を使用しています。 layouts/shortcodes/accordion.html {{- $title := .Get &#34;title&#34; | default &#34;例&#34; }} {{- $rand := delimit (seq 9 | shuffle) &#34;&#34; }} &lt;div class=&#34;xAccordion&#34;&gt; &lt;label class=&#34;xAccordion_title&#34; for=&#34;id-{{ $rand }}&#34;&gt;{{ $title }}&lt;/label&gt; &lt;input id=&#34;id-{{ $rand }}&#34; type=&#34;checkbox&#34;&gt; &lt;div class=&#34;xAccordion_body&#34;&gt; {{ .Inner }} &lt;/div&gt; &lt;/div&gt; 上記の出力に合わせて、次のようなスタイルシートを読み込んでおく必要があります。 ここでは、SCSS によるスタイル記述が有効化 されていることを想定していますが、通常の CSS で記述しても大丈夫です。 表示スタイルはここで自由に変更できます。 common.scss .xAccordion { /* タイトル */ &amp;_title { display: block; padding: 0.5rem 0.7rem; background: #ddd; cursor: pointer; &amp;::after { font-size: smaller; color: #999; content: &#34;（クリックで開閉）&#34;; } &amp;:hover { background: #ccc; } } &amp;_body { display: none; /* デフォルトでは本文は非表示 */ /* 本文の共通設定 */ border: solid lightgray 1px; padding: 0.5rem; } input { display: none; /* チェックボックスは非表示 */ /* ラベルをクリックしたら本文を開く（表示） */ &amp;:checked + .xAccordion_body { display: block; } } }"},{url:"/p/9qexh2q/",title:"Hugo のテンプレートやショートコードでランダムな文字列を生成する",date:"2021-02-22T00:00:00+09:00",body:"Hugo のテンプレートやショートコードでランダムな文字列を生成する 次の random ショートコードは、1 〜 9 の数値をランダムに並び替えた 9 桁の数値文字列を生成します。 layouts/shortcodes/random.html {{ $random1 := delimit (seq 9 | shuffle) &#34;&#34; }} {{ $random2 := delimit (shuffle (split &#34;123456789&#34; &#34;&#34; )) &#34;&#34; }} &lt;p&gt;random1 = {{ $random1 }}&lt;/p&gt; &lt;p&gt;random2 = {{ $random2 }}&lt;/p&gt; content/page1.md（使用例） --- title: &#34;ページタイトル&#34; --- {{&lt; random &gt;}} レンダリング結果 &lt;p&gt;random1 = 816257394&lt;/p&gt; &lt;p&gt;random2 = 234976851&lt;/p&gt; 上記の例では、2 種類の生成方法を示していますが、どちらも次のような手順でランダムな文字列を生成しています。 1 〜 9 の連番からなる配列を生成（seq 9 あるいは split &quot;123456789&quot; &quot;&quot; の部分） shuffle 関数 で配列要素をシャッフル delimit 関数 で配列要素を 1 つの文字列に結合 配列要素を結合する関数に delimit という名前が付けられていますが、多くの言語では join とか concatenate という名前が一般的ですね。 この関数名にはちょっと戸惑うかも（＾＾；"},{url:"/p/bn8q8o6/",title:"ADB で描画パフォーマンス計測のデバッグ機能を有効にする",date:"2021-01-29T00:00:00+09:00",body:"ADB で描画パフォーマンス計測のデバッグ機能を有効にする Android の開発者向けオプション (Developer options) には、描画パフォーマンスなどを測定するための便利なツールが揃っています。 特に、GPU オーバードロー領域の表示や、レンダリングプロファイル（画面上にバー表示）は、描画パフォーマンス 60 FPS を達成するために必須のツールです。 でも、これらの設定項目は設定メニューの深いところにあって、ホーム画面に戻って毎回切り替えるのは手間がかかります。 実はこれらのオプション設定は、adb shell から setprop コマンドを実行することで簡単に切り替えることができます。 コマンドからこれらの設定を変更した場合は、すぐに設定が有効にならないことがあるので注意してください。 その場合は、アプリの再起動や、アプリ内での画面遷移などを発生させると有効になるようです。 各種デバッグ項目の ADB からの設定方法 Show view updates（GPU表示の更新を表示） ON にすると、GPU での描画時にウィンドウ内の表示を点滅させます。 (Flash views inside windows when drawn) 設定方法 意味 adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を OFF adb shell setprop debug.hwui.show_dirty_regions false GPU描画点滅を ON Show hardware layers updates（ハードウェア層情報を表示） ON にすると、ハードウェア層が更新されると緑を表示します。 (Flash hardware layers green when they update) GPU を活用した描画が行えているのであれば、GPU 層での更新は頻繁に発生するものではありません。 新しいビューが生成されたときのみ緑色のフラッシュが発生していれば OK です。 設定方法 意味 adb shell setprop debug.hwui.show_layers_updates false HW層更新表示を OFF adb shell setprop debug.hwui.show_layers_updates true HW層更新表示を ON Debug GPU overdraw（GPU オーバードローをデバッグ） ON にすると、何度も重ねて描画されてしまっている部分を色付きで表示します。 緑色や赤色の矩形がたくさん出てきたら、レイアウトの階層構造や、描画まわりの実装を見直す必要があります。 設定方法 意味 adb shell setprop debug.hwui.overdraw false OFF adb shell setprop debug.hwui.overdraw show オーバードロー領域の表示 adb shell setprop debug.hwui.overdraw show_deuteranomaly 第二色弱の方向けの領域の表示 参考: GPU レンダリングの速度とオーバードローを検査する Profile HWUI rendering（GPU レンダリングのプロファイル作成） 設定を visual_bars にすると、描画時にフレームあたり何ミリ秒かかったかを画面上の棒グラフで表示してくれます。 緑色の水平線以下にあれば、16.66ミリ秒、つまり 60FPS での描画を達成できています。 設定方法 意味 adb shell setprop debug.hwui.profile false レンダリングプロファイルを OFF adb shell setprop debug.hwui.profile visual_bars バーとして画面に表示 adb shell setprop debug.hwui.profile true dumpsys gfxinfo での確認用 参考: GPU レンダリングの速度とオーバードローを検査する （おまけ）設定項目のプロパティ名はどうやって調べたの？ 次のようにすると、Android 端末の現在のプロパティ設定の一覧を取得できます。 $ adb shell getprop あらかじめ上記の結果をファイルに保存しておいて、開発者向けオプションの設定を変更したときに値が変化する項目を調べれば、その設定項目のプロパティ名（および設定値）が分かります。 adb shell getprop &gt; props1.txt 開発者向けオプションで設定を変更 adb shell getprop &gt; props2.txt 比較 Windows: fc props1.txt props2.txt | findstr debug Linux: diff props1.txt props2.txt | grep debug プロパティ名は Android のバージョンによって変わる可能性がありますが、この方法でプロパティ名を調べれば対応できます。"},{url:"/kotlin/",title:"Kotlin",date:"2020-12-04T00:00:00+09:00",body:"Kotlin はじめに／環境 Kotlin とは？ Kotlin をインストールする VS Code で Kotlin の開発環境を構築する 変数／関数 変数を定義する (val, var) 基本的な型の一覧 関数を定義する (fun) 可変長引数をとる関数を定義する (vararg) lateinit による変数の初期化 lateinit 変数が初期化されているかどうかを調べる (isInitialized) 分解宣言 (destructuring declarations) による Pair 要素や Triple 要素の分解 infix 記法で関数呼び出し時の記述を簡略化する (to) インライン関数の特徴を理解する (inline fun) 制御構文 if による分岐処理と if 式 when 式による条件分岐 for ループと while ループ（そして forEach） 例外処理を記述する (try, catch, finally) クラス クラスの基本 クラスを定義する／コンストラクタを定義する (class) 継承可能なクラスを作成する (open, abstract, override) シールクラスで継承可能なクラスを制限する (sealed class) クラスにプロパティのアクセサメソッドを定義する (set, get) データクラスを定義する (data class) by を使ったメソッド呼び出しの委譲 (class delegation) 既存のクラスに関数やプロパティを追加する（拡張関数） 演算子 (Operator) の定義 算術演算子を定義してオブジェクトに + や += を適用できるようにする 比較演算子を定義してオブジェクト同士の比較やソートを行えるようにする (equals, compareTo) インデックス演算子を定義して配列のようにアクセス可能なクラスを作る (index operator) in 演算子を定義して要素の包含チェックを行えるようにする (contains) iterator を定義して for-in ループで要素を処理できるようにする (iterator) 範囲演算子を定義して .. で指定した範囲の要素を取得できるようにする (rangeTo) object キーワード オブジェクト宣言でシングルトンを作成する (object declaration) オブジェクト式で無名オブジェクトを生成する (object expression) コンパニオンオブジェクトでクラスに静的メソッドを追加する (companion object) ジェネリクス (Generics)【応用】 ジェネリクスの基本 reified でジェネリクスの型情報を維持する ジェネリクスの共変 (covariant) と不変 (invariant) について理解する その他 コンパニオンオブジェクトとクラス内オブジェクト宣言の違い クラス名を文字列で取得する (class.java.simpleName) クラス内の MutableList を不変 (immutable) な List にして公開する インラインクラスでプリミティブ型の型安全性を確保する (inline class) 型（タイプ） インタフェースを定義する (interface) 列挙型を定義する (enum) 列挙型 (enum) の値をインデックスで取得する 列挙型 (enum) の値をループ処理する (values) スマートキャストでキャストを自動化する safe call (?.) や elvis operator (?:)、let で null をうまく扱う あるインスタンスがどのクラスのオブジェクトなのか調べる (javaClass) ラムダ式 (lambda expression) ラムダ式の基本 (lambda expression) メンバ参照、結合メンバ参照を理解する (member reference) レシーバー付きラムダ (with) パッケージ Kotlin のパッケージの扱い方を理解する パッケージのトップレベルに関数、プロパティ、定数を定義する 配列／コレクション 共通 コレクションの基本的な使い方 (List, Set, Map) immutable なコレクションと mutable なコレクション (List, Set, Map) immutable なコレクションを mutable に変換する (toMutableList, toMutableSet, toMutableMap) 配列とリストの生成方法まとめ（連番からなる配列やリストを作成する） プリミティブ型の配列には IntArray や LongArray などの専用クラスを使うことを検討する プリミティブ型配列 (IntArray) の内容を見やすく出力する (contentToString) 配列やコレクションの要素をループ処理する (for-in, forEach, withIndex) コレクションの要素をもとに別のリストを作成する (map) コレクションから条件に一致する要素のみを取り出す (filter, filterNot, filterKeys, filterValues) 配列やリストから null 以外の要素のみを抽出する (filterNotNull, mapNotNull) ある値がコレクションに含まれているか調べる (in) コレクションの最初・最後の要素を取得する (first, last) コレクション内の最小・最大の値を見つける (min, max, minBy, maxBy) 配列やリストの先頭・末尾の n 要素を取り出す・削除する (take, drop) マップ (Map) マップからキーのリスト、値のリストを作成する (keys, values) マップのキー／値をまとめて変更する (mapKeys, mapValues) マップをソートしてループ処理する (toSortedMap) マップの値を初めて取得しようとしたときに初期化する（Map の遅延初期化）(getOrPut) セット (Set) セットの集合演算を行う 文字列／数値 文字列リテラルの中で変数や式を展開する（文字列テンプレート） 文字列と数値を変換する (toIntOrNull, toInt) 文字列をデリミタ文字で分割する (split) 日時（日付／時刻） Kotlin で日時（日付／時刻）を扱う方法いろいろ その他 Kotlin のコードにドキュメンテーションコメントを記述する (KDoc) Kotlin で読みやすいコードを書く方法（可読性の高い Kotlin コードとは） ある処理にかかった時間を計測する (measureTimeMillis/Micros) 演算子の前後で改行したいときは必ず後ろで改行する"},{url:"/p/9c9d2t7/",title:"Kotlinメモ: Kotlin で日時（日付／時刻）を扱う方法いろいろ",date:"2020-12-04T00:00:00+09:00",body:"Kotlinメモ: Kotlin で日時（日付／時刻）を扱う方法いろいろ 日時を表すクラス Kotlin で日付や時刻を扱うには、Java 標準ライブラリの java.time パッケージを使用します。 クラス名 表現する情報 ISO-8601 表現 LocalDate 日付（年-月-日） 2020-12-04 LocalTime 時刻（時-分-秒） 20:26:47.549110600 LocalDateTime 日付＆時刻（年-月-日-時-分-秒） 2020-12-04T20:26:47.549110600 ZonedDateTime 日付＆時刻（年-月-日-時-分-秒）＋ タイムゾーン 2020-12-04T20:26:47.549110600+09:00[Asia/Tokyo] 時刻はナノ秒の精度まで保持可能ですが、実際にどの精度までの値が格納されているかはオブジェクトの生成方法に依存します。 特徴: Local 系と Zoned 系がある 日時を表すクラスは、大きく LocalXxx 系と ZonedXxx に分かれています。 LocalDateTime は単純な日時情報（年-月-日-時-分-秒）を保持するためのクラスで、内部にタイムゾーン情報を保持していません。 つまり、一度 2020-02-15T21:30:50 という情報を持つオブジェクトを生成したら、そのオブジェクトはどの国で使っても 2020-02-15T21:30:50 という情報として扱うということです（時差の概念は持たない）。 一方で、ZonedDateTime は、JST などのタイムゾーン情報 (ZoneId) を内部に保持しているため、地域ごとの時差を表現できます。 日本であれば UTC 時刻＋9時間なので、2020-02-15T21:30:50+09:00 といった情報を保持することになります。 つまり、ZonedDateTime = LocalDateTime + ZoneId なので、LocalDateTime オブジェクトに ZoneId オブジェクトを付加してやれば、ZonedDateTime オブジェクトを生成することができます。 具体的には、ZonedDateTime.of() か LocalDateTime#atZone()を使用します。 val localDateTime = LocalDateTime.now() val zonedDateTime1 = ZonedDateTime.of(localDateTime, ZoneId.systemDefault()) val zonedDateTime2 = ZonedDateTime.of(localDateTime, ZoneId.of(&#34;Asia/Tokyo&#34;)) val zonedDateTime3 = ZonedDateTime.of(localDateTime, ZoneId.of(&#34;America/Los_Angeles&#34;)) println(localDateTime) //=&gt; 2020-12-04T20:32:26.214124900 println(zonedDateTime1) //=&gt; 2020-12-04T20:32:26.214124900+09:00[Asia/Tokyo] println(zonedDateTime2) //=&gt; 2020-12-04T20:32:26.214124900+09:00[Asia/Tokyo] println(zonedDateTime3) //=&gt; 2020-12-04T20:32:26.214124900-08:00[America/Los_Angeles] 生成された ZonedDateTime オブジェクトにはタイムゾーン情報が付加されていますが、時-分-秒の情報は変化していないことに注意してください。 特徴: 不変オブジェクト (immutable) である 日時を表すクラスはすべて不変 (immutable) であり、スレッドセーフに利用することができます。 既存の日時オブジェクトの一部を変更して新しい日時を表現したいときは、変換メソッドの戻り値で新しいオブジェクトとして受け取ります。 例えば、現在の時刻 (LocalTime) から 12 時間後の時刻を取得したい場合は、plusHours メソッドの戻り値で新しい LocalTime オブジェクトを受け取ります。 val time1: LocalTime = LocalTime.now() val time2: LocalTime = time1.plusHours(12) println(time1) //=&gt; 19:44:25.216369900 println(time2) //=&gt; 07:44:25.216369900 変換元の LocalTime オブジェクトの値は変化していないところがポイントです。 日時オブジェクトの生成方法いろいろ 現在のシステム時刻から生成 val date = LocalDate.now() //=&gt; 2020-12-04 val time = LocalTime.now() //=&gt; 20:39:30.973274100 val ldt = LocalDateTime.now() //=&gt; 2020-12-04T20:39:30.973274100 val zdt = ZonedDateTime.now() //=&gt; 2020-12-04T20:39:30.973274100+09:00[Asia/Tokyo] ZonedDateTime.now() は、デフォルトで ZoneId.systemDefault() のタイムゾーン情報を使用します。 年-月-日-時-分-秒を指定して生成 // 2020年2月15日 val date1 = LocalDate.parse(&#34;2020-02-15&#34;) val date2 = LocalDate.of(2020, 2, 15) val date3 = LocalDate.ofYearDay(2020, 46) // 2020年の46日目 // 21時30分50秒 val time1 = LocalTime.parse(&#34;21:30:50&#34;) val time2 = LocalTime.of(21, 30, 50) val time3 = LocalTime.ofSecondOfDay(77450) // 00:00:00から77450秒後 // 2020年2月15日21時30分50秒（タイムゾーン情報なし） val dateTime1 = LocalDateTime.parse(&#34;2020-02-15T21:30:50&#34;) val dateTime2 = LocalDateTime.of(2020, 2, 15, 21, 30, 50) val dateTime3 = LocalDateTime.of(date1, time2) // LocalDate + LocalTime // 2020年2月15日21時30分50秒（タイムゾーン情報あり） val zoned1 = ZonedDateTime.parse(&#34;2020-02-15T21:30:50+09:00[Asia/Tokyo]&#34;) val zoned2 = ZonedDateTime.of(dateTime1, ZoneId.of(&#34;Asia/Tokyo&#34;)) // LocalDateTime + ZoneId 日時オブジェクトから各フィールドの情報を取り出す val dt = LocalDateTime.parse(&#34;2020-02-15T21:30:50&#34;) 上記のように生成した LocalDateTime オブジェクトからは、次のようなプロパティで各フィールドの値を取得できます。 メソッド 結果 意味 dt.year 2020 年 dt.monthValue 2 月 dt.dayOfMonth 15 日 dt.hour 21 時 dt.minute 30 分 dt.second 50 秒 dt.month Month.FEBRUARY 月 (enum) dt.dayOfWeek DayOfWeek.SATURDAY 曜日 (enum) dt.dayOfYear 46 年始からの日数 日時オブジェクトの演算 日時オブジェクトには、年月日時分秒の各フィールドの演算を行うためのメソッドが用意されています。 演算結果は新しい日時オブジェクトとして戻り値で返されます。 次の例では、10年後の日時を求めています。 val dt1 = LocalDateTime.parse(&#34;2020-02-15T21:30:50&#34;) val dt2 = dt1.plusYears(10) //=&gt; 2030-02-15T21:30:50 他にもいろいろな演算方法があります。 メソッド 結果 意味 dt.plusYears(1) 2021-02-15T21:30:50 1年後 dt.plusMonths(1) 2020-03-15T21:30:50 1ヵ月後 dt.plusDays(1) 2020-02-16T21:30:50 1日後 dt.plusHours(1) 2020-02-15T22:30:50 1時間後 dt.plusMinutes(1) 2020-02-15T21:31:50 1分後 dt.plusSeconds(1) 2020-02-15T21:30:51 1秒後 dt.withYear(2000) 2000-02-15T21:30:50 2000年に書き換え dt.withMonth(7) 2020-07-15T21:30:50 7月に書き換え dt.withDayOfMonth(10) 2020-02-10T21:30:50 10日に書き換え dt.withHour(18) 2020-02-15T18:30:50 18時に書き換え dt.withMinute(45) 2020-02-15T21:45:50 45分に書き換え dt.withSecond(0) 2020-02-15T21:30:00 0秒に書き換え あるフィールド以下の値をすべて 0 にしたいときは、次のように LocalDateTime#truncatedTo() や ZonedDateTime#truncatedTo() を使用します。 import java.time.LocalDateTime import java.time.temporal.ChronoUnit fun main() { val dt = LocalDateTime.parse(&#34;2020-02-15T21:30:50&#34;) // 「日」以下のフィールドを切り捨て（その日の 0 時 0 分にする） val truncated1: LocalDateTime = dt.truncatedTo(ChronoUnit.DAYS) println(truncated1) //=&gt; 2020-02-15T00:00 // 「時」以下のフィールドを切り捨て val truncated2: LocalDateTime = dt.truncatedTo(ChronoUnit.HOURS) println(truncated2) //=&gt; 2020-02-15T21:00 // 「分」以下のフィールドを切り捨て val truncated3: LocalDateTime = dt.truncatedTo(ChronoUnit.MINUTES) println(truncated3) //=&gt; 2020-02-15T21:30 } 日時オブジェクトを文字列にフォーマットする 日付オブジェクトの format メソッドに、java.time.format.DateTimeFormatter オブジェクトを渡すと、任意の形式の日時文字列に変換することができます。 独自のフォーマットを作成することもできますし、あらかじめ用意されている定数を使用することもできます。 val dt = ZonedDateTime.now() println(dt) //=&gt; 2020-12-04T21:52:23.473136500+09:00[Asia/Tokyo] // 日付のみ println(dt.format(DateTimeFormatter.ISO_DATE)) //=&gt; 2020-12-04+09:00 println(dt.format(DateTimeFormatter.ISO_OFFSET_DATE)) //=&gt; 2020-12-04+09:00 println(dt.format(DateTimeFormatter.ISO_LOCAL_DATE)) //=&gt; 2020-12-04 // 時刻のみ println(dt.format(DateTimeFormatter.ISO_INSTANT)) //=&gt; 2020-12-04T12:52:23.473136500Z println(dt.format(DateTimeFormatter.ISO_TIME)) //=&gt; 21:52:23.4731365+09:00 println(dt.format(DateTimeFormatter.ISO_OFFSET_TIME)) //=&gt; 21:52:23.4731365+09:00 println(dt.format(DateTimeFormatter.ISO_LOCAL_TIME)) //=&gt; 21:52:23.4731365 // 日付＆時刻 println(dt.format(DateTimeFormatter.ISO_DATE_TIME)) //=&gt; 2020-12-04T21:52:23.4731365+09:00[Asia/Tokyo] println(dt.format(DateTimeFormatter.ISO_ZONED_DATE_TIME)) //=&gt; 2020-12-04T21:52:23.4731365+09:00[Asia/Tokyo] println(dt.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)) //=&gt; 2020-12-04T21:52:23.4731365+09:00 println(dt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)) //=&gt; 2020-12-04T21:52:23.4731365 println(dt.format(DateTimeFormatter.RFC_1123_DATE_TIME)) //=&gt; Fri, 4 Dec 2020 21:52:23 +0900 // その他 println(dt.format(DateTimeFormatter.BASIC_ISO_DATE)) //=&gt; 20201204+0900 println(dt.format(DateTimeFormatter.ISO_ORDINAL_DATE)) //=&gt; 2020-339+09:00 println(dt.format(DateTimeFormatter.ISO_WEEK_DATE)) //=&gt; 2020-W49-5+09:00 独自形式の DateTimeFormatter を作成するには次のようにします。 val formatter = DateTimeFormatter.ofPattern(&#34;YYYY-MM-dd (E) HH:mm:ss&#34;) println(dt.format(formatter)) //=&gt; 2020-12-04 (金) 21:52:23 その他 エポックタイム（ミリ秒）←→ ZonedDateTime System.currentTimeMillis() で取得したミリ秒から ZonedDateTime オブジェクトを生成するには次のようにします。 Instant クラスは、エポックタイム（1970年からの経過秒数）をナノ秒の単位で扱うためクラスです。 val epochMillis = System.currentTimeMillis() val zonedDt = ZonedDateTime.ofInstant( Instant.ofEpochMilli(epochMillis), ZoneId.systemDefault() ) println(epochMillis) //=&gt; 1607088295866 println(zonedDt) //=&gt; 2020-12-04T22:24:55.866+09:00[Asia/Tokyo] 逆に、ZonedDateTime からエポックタイムに変換するには toEpochSecond() が使えますが、toEpochMillis() はありません。 toInstant() で Instant オブジェクトを取得してから、toEpochMilli() を使えばミリ秒単位で取得できます。 val millis: Long = zonedDt.toInstant().toEpochMilli() println(millis) //=&gt; 1607090443203 // 下記でも同じような値は取得できるけど、下3桁が 000 に丸められてしまう val millis2: Long = zonedDt.toEpochSecond() * 1000 println(millis2) //=&gt; 1607090443000 時刻文字列 → エポックタイム（ミリ秒） fun strTimeToMillis(timeStr: String): Long { return Instant.parse(timeStr).toEpochMilli() // return ZonedDateTime.parse(timeStr).toInstant().toEpochMilli() } val millis: Long = strTimeToMillis(&#34;2020-12-04T22:49:30Z&#34;) エポックタイム（ミリ秒）を 0 時 0 分の値に切り詰める 次のユーティリティクラス TimeUtil の startTimeOfDay() は、渡されたタイムスタンプを、その日の 0 時 0 分になるように切り詰めます。 import java.time.ZonedDateTime import java.time.ZoneId import java.time.Instant import java.time.temporal.ChronoUnit import java.time.format.DateTimeFormatter object TimeUtil { /** * エポックタイム（ミリ秒）を切り詰めて「00時00分00秒」の値にします。 */ fun startTimeOfDay(epochMillis: Long): Long { val zoned = Instant.ofEpochMilli(epochMillis).atZone(ZoneId.systemDefault()) return zoned.truncatedTo(ChronoUnit.DAYS).toInstant().toEpochMilli() } /** * エポックタイム（ミリ秒）を切り詰めて「24時00分00秒」の値にします。 */ fun endTimeOfDay(epochMillis: Long): Long { val zoned = Instant.ofEpochMilli(epochMillis).atZone(ZoneId.systemDefault()) return zoned.plusDays(1).truncatedTo(ChronoUnit.DAYS).toInstant().toEpochMilli() } /** * タイムスタンプを分かりやすい形式で表示します（デバッグ用）。 */ fun prettyPrintTimeStamp(epochMillis: Long) { val zoned = Instant.ofEpochMilli(epochMillis).atZone(ZoneId.systemDefault()) println(zoned.format(DateTimeFormatter.ISO_DATE_TIME)) } } // 使用例 fun main() { val currentTime = System.currentTimeMillis() val startTimeOfDay = TimeUtil.startTimeOfDay(currentTime) val endTimeOfDay = TimeUtil.endTimeOfDay(currentTime) // 結果の確認 println(currentTime) //=&gt; 1608624565893 println(startTimeOfDay) //=&gt; 1608595200000 println(endTimeOfDay) //=&gt; 1608681600000 TimeUtil.prettyPrintTimeStamp(currentTime) //=&gt; 2020-12-22T08:09:25.893Z[UTC] TimeUtil.prettyPrintTimeStamp(startTimeOfDay) //=&gt; 2020-12-22T00:00:00Z[UTC] TimeUtil.prettyPrintTimeStamp(endTimeOfDay) //=&gt; 2020-12-23T00:00:00Z[UTC] }"},{url:"/p/ias8kt3/",title:"GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink)",date:"2020-12-03T00:00:00+09:00",body:"GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink) オートリンク機能とは GitHub の Issue（イシュー）や PR（プルリクエスト）のページの概要欄、コメント欄では、次のように Issue 番号を書いておくだけで該当ページに自動リンクすることができます。 #1234 参考: Autolinked references and URLs - GitHub Docs この機能はあくまで GitHub サイト内のリンクを簡単に記述するためのものですが、カスタムの Autolink references を設定しておくことで、任意の外部サイトに ID ベースで自動リンクできるようになります。 参考: Configuring autolinks to reference external resources - GitHub Docs 例えば、仕様書サイトのあるページ（ID=123 とします）にリンクしたい場合に、次のように簡単にリンクできるようになります。 SPEC-123 URL そのものを記述する必要がなくなるので、仕様書サイトのサーバー移転などでドメイン名が変わったとしても、Issue のコメントに記述したリンクが無効になってしまうことがありません。 ちなみにブログサイトなどの各ページの URL には、ID ベースのパーマリンクアドレスを割り当てる運用にしておくと、こういった機能と連携しやすくなります。 参考: サイト構造を変えてもページの URL が変わらないようにする - まくまくHugoノート カスタム・オートリンクの設定 （2022年7月時点で、このカスタム・オートリンクは、GitHub Pro、GitHub Team などの 有料プランのみで設定可能 です） 外部サイトへのオートリンク機能を有効にするには、次のように設定します。 ここでは、外部サイトの URL は https://spec.example.com/p/123/ といったパーマリンクで提供されるものとします（123 といった ID はサーバー移転などしても変わらないことが保証されていると過程）。 対象のリポジトリの Settings（設定）を選択 サイドバーから Autolink references を選択 次のような感じで Autolink 方法を設定 Reference prefix: SPEC- Target URL: https://spec.example.com/p/&lt;num&gt;/ すると、Issue や PR のコメントとして SPEC-123 のように記述するだけで、自動的に https://spec.example.com/p/123/ という URL へリンクされるようになります。 注意点 SPEC-XXX という形でリンクを張るとき、XXX の部分には 数値しか指定できない ということに注意してください。 SPEC-xyz1234 といった数値以外の文字が含まれる ID では自動リンクしてくれません。 GitHub チームに問い合わせましたが、2020年12月時点では、やはり数値のみのページ ID にしか対応していないとのこと。 パーマリンクのアドレスとしては、xyz1234 といった数値以外の文字を含む ID は一般的に使われているので、このあたりは改善されることを期待しています。 （2022年7月追記） これまで、オートリンクの ID 部分には数値しか指定できませんでしたが、GitHub 側の対応により、英数字及びハイフンの組み合わせ ([a-zA-Z0-9-]+)が使えるようになりました。 例えば、SPEC-xyz1234 のように、ID 部分に英数字を含んでいてもオートリンクが機能します。 参考: Autolinks with alphanumeric IDs - GitHub Changelog"},{url:"/p/khn4o5z/",title:"Kotlinメモ: インラインクラスでプリミティブ型の型安全性を確保する (inline class)",date:"2020-11-04T00:00:00+09:00",body:"Kotlinメモ: インラインクラスでプリミティブ型の型安全性を確保する (inline class) インラインクラスの基本 Kotlin のインラインクラスを使用すると、パフォーマンスに悪影響のないプリミティブ型ラッパークラスを作成することができます。 プライマリコンストラクタで 1 つの値（プロパティ）のみを受け取るクラスは、次のように inline キーワードを付けてインラインクラスにすることができます。 inline class Name(private val name: String) このインラインクラスは、通常のクラスと同様に次のように使用します。 val name: Name = Name(&#34;Maku&#34;) 違いはコンパイル後のバイトコードに現れます。 上記のコードはコンパイル時にインライン展開され、次のようなコードを記述したのと同様に扱われます。 コンパイル後のコード val name: String = &#34;Maku&#34; つまり、コンパイル時は具体的な型（Name 型）で型チェックを行いつつも、実行時にはプリミティブ型になっているのでパフォーマンスが悪化しない、という両方の利点を享受できます。 現状、インラインクラスは、init ブロックを持てない、バッキングフィールドを持てない、といった制約がありますが、単純な getter プロパティや関数を持つことはできます。 inline class Name(private val name: String) { val length: Int get() = name.length fun greet() { println(&#34;Hello, $name&#34;) } } val name: Name = Name(&#34;Maku&#34;) //=&gt; val name: String = &#34;Maku&#34; に置き換えられる name.greet() //=&gt; String オブジェクトの greet() を呼び出す？ 上記の name 変数はコンパイル時に String オブジェクトに置き換えられるので、name.greet() の部分でエラーになりそうですが、コンパイラがうまいこと静的関数を生成して問題なく動作するようにしてくれます。 上記のコードは次のようなコードにコンパイルされます。 val name: String = &#34;Maku&#34; Name.`greet-impl`(name) インラインクラスの用途 同一のプリミティブ型を区別したいとき 同じ型のパラメータを複数取る関数を作ると、引数の指定方法を間違える不具合が入りやすくなります。 例えば、次の searchBooks 関数は 2 つの Int 値を受け取ります。 fun searchBooks(authorId: Int, genreId: Int): Array&lt;Book&gt; { // ... } 2 つのパラメーターは両方とも Int 型なので、次のように順序を間違えて呼び出してしまってもコンパイルエラーになってくれません。 実行時にもすぐには分からず、潜在的な不具合を埋め込んでしまう可能性があります。 val authorId: Int = getAuthorId() val genreId: Int = getGenreId() val books = searchBooks(genreId, authorId) // 間違い！ 次のように名前付き引数の構文を使えば、コード上は分かりやすくなりますが、相変わらず型情報は同じ Int なので、型安全性が高いとは言えません。 val books = searchBooks(authorId=authorId, genreId=genreId) そこで、次のようにインラインクラスとして AuthorId 型と GenreId 型を定義します。 inline class AuthorId(private val authorId: Int) inline class GenreId(private val genreId: Int) fun searchBooks(authorId: AuthorId, genreId: GenreId): Array&lt;Book&gt; { // ... } こうすれば、それぞれの ID が異なる型として定義されるので、引数の指定ミスはコンパイル時に確実に発見できるようになります。 val authorId: AuthorId = ... val genreId: GenreId = ... val books1 = searchBooks(authorId, genreId) // OK val books2 = searchBooks(genreId, authorId) // Error! しかも、上記のインラインクラスは実際には Int 型として扱われるため、単純なラッパークラスとは違って Unboxing（AuthorId から Int への変換）のオーバーヘッドがかかりません。 つまり、速度を犠牲にせずに、型安全性を確保できます。 単位の違いを表現したいとき 長さ（m/cm/mm）、時間（時/分/秒）、ファイルサイズ（mb/kb/byte）などの単位をともなう情報は、多くの場合は Int や Long などのプリミティブ型で表現されます。 このような場合、単位を表現するラッパークラスを作成すると、単位の間違いによる不具合を防ぐことができます。 まずは、すべてプリミティブの Long 型だけで済ませた例から見てみます。 次のコードは、時間を表す time が、「秒」と「ミリ秒」の 2 つの意味で使われてしまっています（不具合です）。 import java.util.concurrent.TimeUnit // ラピュタ崩壊までの残り時間を取得 fun getRemainingTime(): Long { return 100 // 100秒のつもり } // ラピュタ崩壊までのカウントダウンを開始する fun startTimer(time: Long) { TimeUnit.MILLISECONDS.sleep(time) // time を「ミリ秒」として扱う println(&#34;バルス！&#34;) } fun main() { val time: Long = getRemainingTime() startTimer(time) } getRemainingTime() が返す値は「100秒」を表現しているつもりですが、この値をそのまま startTimer() に渡すと「100ミリ秒」として扱われてしまいます。 ラピュタ崩壊までいくらかの猶予（100秒）があると思っていたら、一瞬（100ミリ秒）でバルスされてしまうことになります。 このようなミスは、関数名やパラメーター名の工夫である程度防ぐことができます。 fun getRemainingTimeSeconds(): Long { // ... } fun startTimer(timeMillis: Long) { // ... } しかし、すべての関数やパラメーターにこのような単位名を付けようとすると、コードが全体的に冗長になり、可読性が下がってしまいます。 それに、ID の例でも示したように、名前で単位を示すのは型安全性という面では不安が残ります（万が一、誤用してもコンパイルエラーになりません）。 そこで、インラインクラスを使ったラッパークラスの出番です。 次の例では、秒を表現する型 Seconds と、ミリ秒を表現する型 Millis を定義しています。 // 秒を表現する型 inline class Seconds(val seconds: Long) { fun toMillis() = Millis(seconds * 1000) } // ミリ秒を表現する型 inline class Millis(val millis: Long) { // ... } fun getRemainingTime(): Seconds { return Seconds(100) } fun startTimer(time: Millis) { TimeUnit.MILLISECONDS.sleep(time.millis) println(&#34;バルス！&#34;) } fun main() { val time: Seconds = getRemainingTime() startTimer(time.toMillis()) // startTimer(time) // これは型のミスマッチによるコンパイルエラー } これで、時間情報を受け渡す各ポイントで型情報のチェックが入り、異なる単位の時刻情報が受け渡しされてしまうのを防ぐことができます。 もし、Seconds(100) のような記述が煩わしいと思うのであれば、次のように Long の拡張プロパティを定義してしまう方法もあります。 こうすれば、独自の数値型がもともと言語に備わっているかのようにコーディングすることができます。 // Long に拡張プロパティを追加 val Long.sec get() = Seconds(this) val Long.ms get() = Millis(this) // 使用例 val timeMillis: Millis = 50.ms 50 と記述する代わりに、50.ms と記述するだけで Millis 型のインスタンスを扱えます。 インラインクラスと typealias の違い Kotlin の typealias を使うと、既存の型のエイリアスを作成することができます。 typealias Seconds = Long typealias Millis = Long この仕組みを使うと、インラインクラスを使った場合と同じようなコードを記述できますが、意味はまったく異なります。 インラインクラスが新しい型を定義しているのに対し、typealias はあくまで別名を付けているだけです。 つまり、上記のように定義した別名 Seconds と Millis は、Long と等価（同じ型）の扱いになります。 typealias Seconds = Long typealias Millis = Long fun getRemainingTime(): Seconds = 100 fun startTimer(time: Millis) {} fun main() { // Seconds を Long に入れてもエラーにならない！ val seconds: Long = getRemainingTime() // Long を Millis として扱ってもエラーにならない！ startTimer(seconds) } このような場面で型安全性を確保するには、typealias で別名を付けるのではなく、インラインクラス（によるラッパークラス）で新しい型を定義する必要があります。 toString はオーバーライドした方がいいかもしれない 既存の Int 変数などをインラインクラスに置き換える場合は、toString() の戻り値が変化することに注意してください。 例えば、下記のように Int 変数の toString() を呼び出している部分があるとします。 val n = 100 val s: String = n.toString() //=&gt; &#34;100&#34; これを、インラインクラスに置き換えると、toString() の値が次のように変わります。 inline class GenreId(val value: Int) val n = GenreId(100) val s: String = n.toString() //=&gt; &#34;GenreId(value=100)&#34; このような振舞いの変化を防ぎたい場合は、次のように toString() をオーバーライドしておくと安心です。 inline class GenreId(val value: Int) { override fun toString(): String = value.toString() } val n = GenreId(100) val s: String = n.toString() //=&gt; &#34;100&#34; コンパイル時の警告について Experimental feature 警告 インラインクラスは現状 Experimental feature として提供されているので、使用しようとすると、 The feature &#34;inline classes&#34; is experimental といった警告がでることがあります。 インラインクラスが正式リリースされれば、この警告は消えるのでそのままにしておいてもよいのですが、気になる場合は次のように警告を抑制することができます。 方法1: ファイルの先頭にアノテーションを記述する方法 @file:Suppress(&#34;EXPERIMENTAL_FEATURE_WARNING&#34;) 方法2: 対象コードの直前にアノテーションを記述する方法 @Suppress(&#34;EXPERIMENTAL_FEATURE_WARNING&#34;) inline class CategoryId(val id: Int) 方法3: build.gradle (.kts) にコンパイラオプションを指定する方法 build.gradle compileKotlin { kotlinOptions.freeCompilerArgs += [&#34;-Xinline-classes&#34;] } build.gradle.kts tasks.withType&lt;org.jetbrains.kotlin.gradle.tasks.KotlinCompile&gt; { kotlinOptions.freeCompilerArgs += &#34;-Xinline-classes&#34; } いずれも、Android Studio を使用している場合は、inline にカーソルを合わせて Alt + Enter で自動入力できます。 1 ファイルでたくさん inline class 定義するとき 次のように 1 ファイル内でたくさんインラインクラスを定義している場合、detekt などの静的解析で警告が発生することがあります。 types.kt package com.example.myapp inline class GenreId(val id: Int) inline class EventId(val id: Int) class GenreId should be declared in a file named GenreId.kt 例えば、detekt であれば、@Suppress アノテーションを使ってこの警告を抑制 することができます。 @file:Suppress( &#34;MatchingDeclarationName&#34;, // 「ファイル名＝公開クラス名」のチェックを抑制 &#34;EXPERIMENTAL_FEATURE_WARNING&#34; // inline class の experimental 警告を抑制 ) package com.example.myapp // ..."},{url:"/p/8ieeha7/",title:"Kotlinメモ: インライン関数の特徴を理解する (inline fun)",date:"2020-10-26T00:00:00+09:00",body:"Kotlinメモ: インライン関数の特徴を理解する (inline fun) インライン関数 Kotlin の関数定義には fun キーワードを使用しますが、このとき、inline fun と記述すると インライン関数 として定義することができます。 inline 修飾子が付けられた関数を呼び出すと、呼び出した位置に関数の内容がインライン展開される形でコンパイルされるため、結果的に次のような効果が得られます。 型パラメータを reified 指定できる 非局所リターン (non-local return) を行えるようになる 実行時の高速化を期待できる 型パラメータを reified 指定できる Java (JVM) では、型パラメータを持つ関数（ジェネリクス関数）を定義しても、その型情報を実行時には参照することができません。 なぜなら、型パラメータはコンパイル時の型チェックにのみ使われるものであり、後方互換性のために実行コードからは削除されてしまうからです（イレイジャと呼びます）。 Kotlin では、関数を inline 定義し、さらに型パラメータを reified 指定 (具体化型パラメータ）することにより、実行時に型情報を参照することができます。 例えば次のようなコードをコンパイル、実行することができます。 // 型パラメータで渡された型の名前を出力する inline fun &lt;reified T&gt; printType() { println(T::class.simpleName) } printType&lt;String&gt;() // =&gt; &#34;String&#34; これは、関数の内容が次のように呼び出し位置にインライン展開され、型情報がそこに埋め込まれることにより実現されています。 println(String::class.simpleName) つまり、型パラメータの reified 指定は、inline 関数があってこその機能といえます（実際、inline 関数以外で型パラメータを reified 指定するとコンパイルエラーになります）。 Kotlin の標準ライブラリ (kotlin.collections) が提供する Collection の拡張関数 filterIsInstance&lt;T&gt; も同じように inline 定義されており、型パラメータで指定した型の要素を抽出することができます。 val list = listOf(1, null, &#34;AAA&#34;, 2, &#34;BBB&#34;) println(list.filterIsInstance&lt;String&gt;()) // =&gt; &#34;AAA&#34;, &#34;BBB&#34; reified については、下記の記事でもう少し詳しく説明しています。 参考: ジェネリクス: reified でジェネリクスの型情報を維持する 非局所リターン (non-local return) を行えるようになる 非局所リターン というのは、あるブロックの内側から、外側のブロックを抜ける return を行うことです。 次のような、inline 指定されていないリピート関数 (noinlineRepeat) を考えてみます。 /** [times] 回だけ [action] を繰り返します */ fun noinlineRepeat(times: Int, action: (Int) -&gt; Unit) { for (index in 0 until times) { action(index) } } fun isFinalNumber(num: Int) = num == 3 fun main() { noinlineRepeat(10) { println(it) if (isFinalNumber(it)) return // ERROR } } noinlineRepeat のブロックの中で return しようとしていますが、Kotlin では、このようなラムダ式の中での単純な return は禁止されているためコンパイルエラーになります（ラムダ式は最後に評価した値が結果となる）。 このリピート関数を inline 関数として定義すると、非局所リターンが可能になり、ラムダ式の外側（この場合は main 関数）を抜けることができるようになります。 下記の例では、Kotlin 標準の repeat 関数ほぼそのままのコードを使っています。 inline fun repeat(times: Int, action: (Int) -&gt; Unit) { for (index in 0 until times) { action(index) } } fun isFinalNumber(num: Int) = num == 3 fun main() { repeat(10) { println(it) if (isFinalNumber(it)) return // main 関数を抜ける } } なぜこのようなことが可能かというと、関数の中身と、ラムダ式の中身がインライン展開され、次のようなコードとして扱われるからです。 fun main() { for (index in 0 until 10) { println(index) if (isFinalNumber(index)) return } } 組み込みの for ループはもともと非局所リターンが可能な制御構文なので、上記のように展開されたコードからも非局所リターンが可能ということです。 つまり、インライン関数として定義された repeat 関数は、if や for のような制御構文と同様の性質を持つことになります。 ちなみに、関数パラメータのインライン展開を抑制する noinline 修飾子、非局所リターンを禁止する crossinline 修飾子なども用意されています。 例えば次のようなインライン関数があるとします。 inline fun processUser( handleName: (String) -&gt; Unit, handleAge: (Int) -&gt; Unit, ) { handleName(&#34;Maku&#34;) handleAge(13) } 次のように handleName の処理の中で return してしまうと、非局所リターンになってしまうので、後続の handleAge が呼び出されなくなってしまいます。 fun main() { processUser( handleName = { name -&gt; println(name) return // main から抜けてしまう }, handleAge = { age -&gt; println(age) } ) } 必ず後続の処理まで実行したいのであれば、次のように noinline 指定してインライン展開を抑制するか、crossinline 指定して非局所リターンを禁止します。 inline fun processUser( noinline handleName: (String) -&gt; Unit, noinline handleAge: (Int) -&gt; Unit, ) { handleName(&#34;Maku&#34;) handleAge(13) } 実行時の高速化を期待できる 関数を inline 定義すると、その関数の内容および、関数型パラメータで渡した関数リテラルがそのまま展開されるため、呼び出し時のコストが減って実行速度が向上します。 特に、次のようなリピート関数では、関数型パラメータの内容が展開されることでパフォーマンスが向上します。 inline fun repeat(times: Int, action: (Int) -&gt; Unit) { for (index in 0 until times) { action(index) } } 逆に inline 定義されていないバージョンのリピート関数を呼び出すと、ラムダ式用の一時オブジェクトが生成されるためパフォーマンスが低下します。 関数の inline 化によるパフォーマンス向上は、主にその関数が関数型パラメータを持つときにこそ見込めるものであり、単純なスカラ型のパラメータしか持たない関数をインライン化してもパフォーマンス向上はほとんど見込めません。 そのため、次のように関数型パラメータを持たない関数をインライン化しようとすると、 inline fun printNumber(num: Int) { println(num) } Android Studio などの IDE は、次のような警告を出します。 Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of functional types. 関数型パラメータを持たない関数をインライン化しても、パフォーマンスはほとんど向上しないから意味ないよ、という警告ですね。 でも、別に弊害がないのであれば、全部インライン化しておけばいいんじゃない？と思うかもしれません。 もちろんインライン化による弊害はあります。 インライン化による弊害や制約 コードの肥大化に注意 インライン化された関数の中からインライン化された関数を呼び出し、さらにその中からインライン化関数を呼び出し、、、とやっていると、すべてのコードが展開されることになるので、コンパイル後のファイルサイズがすぐに肥大化してしまいます。 簡単に言うと、関数という仕組みを一切使わずにスパゲッティコードを記述しているような状態になります。 関数のインライン化は、その特徴を理解して、効果的かつ、必要最小限に行う必要があります。 再帰呼び出しできない インライン関数は再帰呼び出しできないという制約があります。 無限展開になってしまうので、これはもっともな制約です。 inline の付いた関数から自分自身を呼び出そうとすると、cannot be recursive といったコンパイルエラーになります。 可視性を上げる参照はできない public なインライン関数の中では private なプロパティや関数を参照できないという制約があります。 クラスのカプセル化の利点が活かせないため、インライン関数は、クラス内の関数定義ではあまり使われないかもしれません。 一方、拡張関数の場合は、もともと public なプロパティにしかアクセスできないという性質があるため、インライン化の対象にしやすいと言えます。 具体的な使い道は？ 例えば、コレクションの要素を繰り返し処理するような拡張関数を作るときなどが inline の使いどころです。 kotlin.collections パッケージが提供する拡張関数は、inline 関数のよいサンプルになっています。 次の first 関数は、ラムダ式で示した条件を満たす最初の要素を検索します。 public inline fun &lt;T&gt; Iterable&lt;T&gt;.first(predicate: (T) -&gt; Boolean): T { for (element in this) if (predicate(element)) return element throw NoSuchElementException(&#34;Collection contains no element matching the predicate.&#34;) } スコープ関数（let、apply、also など）もインライン関数として定義されており、ラムダ式の呼び出しコストがかからないようになっています。 つまり、これらのスコープ関数は、Kotlin の組み込み構文（if のブロックなど）と同じ感覚で使えるということです。 public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { return block(this) } public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { block() return this } public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { block(this) return this }"},{url:"/p/oifj5jn/",title:"GitHub で Pull Request のコードレビューワーを自動でアサインする",date:"2020-10-20T00:00:00+09:00",body:"GitHub で Pull Request のコードレビューワーを自動でアサインする 2019年の末に、GitHub にコードレビューワーの自動アサイン機能が追加されました。 Managing code review assignment for your team - GitHub Docs この機能を有効にすると、Pull Request のレビューワーとしてチームをアサインしたときに、そのチーム内の数名を自動アサインしてくれるようになります。 この機能は、チーム単位の設定になるので、あらかじめリポジトリに何らかのチームを参加させておく必要があります。 チーム構成に迷ったら、プロジェクトと同じ粒度で作ってしまうのが手っ取り早いです（例えば、MyApp プロジェクトのチームとして、team-MyApp を作成します）。 自動アサインの設定画面は、チームのページから、Settings → Code review assignment と辿ると開くことができます。 図: GitHub Auto Assign 上記の例では次のような設定を行っています。 自動アサインする人数: 2人 選択アルゴリズム: ロードバランス アサイン対象外とする人: （省略） 自動アサインのアルゴリズムとしては「ラウンドロビン」と「ロードバランス」を選択できます。 「ラウンドロビン」を選択すると、単純に順番に割り当てていきます。 「ロードバランス」を選択すると、最近レビュー活動を行っていない人から優先的に割り当てていきます。 自動アサインといっても、PR 作成時に完全自動でアサインされるわけではありません（チームを手動でアサインする必要がある）。 状況に応じて、この自動アサイン機能と、ユーザー単位の手動アサインを使い分けると便利です。 ちなみに、この自動アサインの設定は、Organization の Owner メンバーだけでなく、各チームで team maintainer として登録されているユーザーが自由に行うことができます。 各チームのレビュー事情はチーム内の人が一番よく分かっているので、team maintainer をうまく設定してあげるとよいです。"},{url:"/p/kyn8rcv/",title:"Hugo で SVG ファイルをインラインで埋め込む svg ショートコードを作成する",date:"2020-10-20T00:00:00+09:00",body:"Hugo で SVG ファイルをインラインで埋め込む svg ショートコードを作成する Hugo で SVG ファイルを表示するには、Markdown の画像ファイル用構文や、Hugo 組み込みの figure ショートコード などを使用します。 ![サンプル画像](sample.svg) {{&lt; figure src=&#34;sample.svg&#34; caption=&#34;サンプル画像&#34; &gt;}} この方法で SVG ファイルを表示すると、次のような img タグで外部ファイルを参照するような HTML が出力されます。 &lt;img src=&#34;sample.svg&#34;&gt; これは、PNG ファイルや JPG ファイルと同様に外部ファイルを画像として表示する方法なので、SVG ファイル内にテキストが含まれていたとしても、そのテキストを検索することはできません。 SVG ファイルの内容をインラインで svg 要素として埋め込むようにすれば、SVG ファイルの内容をブラウザの検索機能などで検索できるようになります。 次の svg ショートコードは、指定された SVG ファイルをインラインで HTML に埋め込みます。 ポイントは、Hugo の readFile 関数でファイルの中身を読み込んで、その場に出力するところです。 layouts/shortcodes/svg.html {{- $src := .Get &#34;src&#34; }} {{- $title := .Get &#34;title&#34; }} {{- /* md ファイルからの相対パスで svg ファイル名を指定できるように */}} {{- $svgFile := path.Join (path.Dir .Position.Filename) $src }} &lt;figure class=&#34;xImage&#34;&gt; &lt;a href=&#34;{{ $src }}&#34; target=&#34;_blank&#34;&gt; {{ readFile $svgFile | safeHTML }} &lt;/a&gt; {{- with $title }} &lt;figcaption&gt;図: {{ . }}&lt;/figcaption&gt; {{- end }} &lt;/figure&gt; 使用例（Markdown ファイル内） {{&lt; svg src=&#34;sample.svg&#34; title=&#34;サンプル画像&#34; &gt;}}"},{url:"/p/3j6qatd/",title:"GitHub で管理している社内リポジトリをトピックで分類する (topics)",date:"2020-10-14T00:00:00+09:00",body:"GitHub で管理している社内リポジトリをトピックで分類する (topics) GitHub リポジトリのトピック機能 社内で GitHub を使っている場合、組織内 (GitHub organization) にたくさんのリポジトリがごちゃ混ぜになっているかもしれません。 例えば、製品アプリ用のリポジトリ、社内ツール用のリポジトリ、ドキュメント管理用のリポジトリなどなど。 このような場合は、リポジトリのトピック機能 を使用すると、リポジトリをグループ化して管理することができます。 例えば、一般ユーザーにリリースする予定の製品アプリには product というトピックを付けるというルールで運用すると、製品アプリの一覧を簡単に作成することができます。 GitHub API を使ってリポジトリの一覧情報を取得すれば、高度な自動化処理を実現することができます。 GitHub リポジトリにトピックを割り当てる リポジトリへのトピック割り当てはとても簡単です。 リポジトリのトップページを開き、右上の 歯車アイコンをクリック します。 すると、リポジトリの情報を入力するダイアログが開くので、Topics の項目に任意のトピック名を入力します。 ここでは、製品アプリであることを示す product というトピックを付けています。 あとは、左上の検索窓などに topic:product と入力すれば、組織内の製品アプリ用のリポジトリの一覧を表示することができます。 このときブラウザに表示されている URL を共有すれば、マネージャー陣にアプリリストを提出するということも簡単にできます。 製品別のトピックを付けて管理するのもいいですね！ トピックの AND 検索と OR 検索 複数のトピックで GitHub リポジトリを検索するときに、次のように指定すれば AND 検索や OR 検索を行えるようです（2023-03 確認）。 AND 検索の例: AAA トピックと BBB トピックが付いているリポジトリを検索 topic:AAA topic:BBB OR 検索の例: AAA トピックまたは BBB トピックが付いているリポジトリを検索 topic:&#34;AAA BBB&#34;"},{url:"/p/3j6qate/",title:"Hugo でショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode)",date:"2020-10-13T00:00:00+09:00",body:"Hugo でショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode) .HasShortcode 関数 外部の JavaScript ファイルを利用して動作するショートコードを作成すると、Web サイトの表現力を大きく向上させることができます。 例えば、次のようなショートコードが考えられます。 独自の構文でコードを記述すると UML 図を出力してくれる mermaid ショートコード（mermaid.js などを利用） TeX 構文でコードを記述すると数式を出力してくれる math ショートコード（MathJax.js などを利用） このとき悩ましいのが、どのようにして次のような script 要素を出力するかです。 &lt;script src=&#34;for-shortcode.min.js&#34;&gt;&lt;/script&gt; すべてのページにこのようなコードを出力してしまうと、この JavaScript が必要ないページでもファイルの読み込みが発生してしまいます。 こういった拡張が増えてくると、大量の JavaScript ファイルが読み込まれることになり、重い Web サイトになってしまいます。 このような場合の救世主が Page.HasShortcode 関数です。 参考: Hugo - Create Your Own Shortcodes - Checking for Existence ページテンプレート内で、 {{ if .HasShortcode &#34;my-shortcode&#34; }} ... {{ end }} といった記述をしておくと、Markdown ファイル内で my-shortcode ショートコードを使用している場合のみ出力を行うことができます。 実装例 例えば、ベーステンプレートの body 要素の末尾に次のように記述しておけば、Markdown ファイル内で mermaid ショートコードを使用している場合のみ、mermaid.js の読み込みと初期化処理を実行することができます。 layouts/_default/baseof.html（抜粋） ... {{- if .HasShortcode &#34;mermaid&#34; }} &lt;script src=&#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#34;&gt;&lt;/script&gt; &lt;script&gt;mermaid.initialize({startOnLoad: true});&lt;/script&gt; {{- end }} &lt;/body&gt; &lt;/html&gt; ちなみに、mermaid ショートコードの実装は次のような感じになっています。 layouts/shortcodes/mermaid.html &lt;div class=&#34;mermaid&#34;&gt; {{ .Inner }} &lt;/div&gt; Markdown ファイルからは次のように呼び出します。 {{&lt; mermaid &gt;}} sequenceDiagram Client-&gt;&gt;Cache: search cache Cache--&gt;&gt;Client: cache Client-&gt;&gt;Repo: fetch data Repo--&gt;&gt;Client: data {{&lt; /mermaid &gt;}} 図: 出力結果 （応用）他のページを間接的に出力するとき baseof.html での .HasShortcode がうまく動作しない例 Page.HasShortcode 関数は、あくまで現在処理しようとしているページの Markdown 内でショートコードが使われているかどうかを調べます。 例えば、ホームページテンプレートで、次のように最新記事の内容を間接的に取得して表示しているような場合は、baseof.html テンプレートに記述した .HasShortcode 関数は意図通り動作しない可能性があります。 &lt;!-- 最近の記事をいくつかまとめて表示 --&gt; {{- range first 3 .Site.RegularPages.ByLastmod.Reverse -}} &lt;article class=&#34;xArticle&#34; itemscope itemtype=&#34;https://schema.org/BlogPosting&#34;&gt; {{ .Render &#34;inc-article&#34; }} &lt;/article&gt; {{- end -}} なぜなら、ホームページ (content/_index.md) の Markdown ファイルではショートコードを使っていないのにもかかわらず（.HasShortcode が false になる）、上記ループで表示される別ページ内で JavaScript のロードを必要としていることがあるからです。 このようなケースに対応するには、上記のような Page オブジェクトをループしている部分で、.HasShortcode によるチェックを行わなければいけません。 ただし、ループ内で JavaScript ファイルをロードする script 要素を出力してしまうと、読み込みタイミングとしてはよろしくない（できれば body の末尾がいい）し、読み込み用のコードが重複してしまいます。 解決案 解決方法はいろいろありそうですが、ひとつの解決方法としては、ショートコード内で、自分自身が必要とする JavaScript ファイル（下記の例では mermaid.min.js）をロードする JavaScript コードを出力してしまうという方法です。 layouts/shortcodes/mermaid.html &lt;div class=&#34;mermaid&#34;&gt; {{ .Inner }} &lt;/div&gt; &lt;script&gt; (function() { const JS_FILE = &#39;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#39;; // JSファイルの多重ロードを防止 const jsSet = window.loadedJsSet = window.loadedJsSet || new Set(); if (jsSet.has(JS_FILE)) return; jsSet.add(JS_FILE); // JSファイルの動的読み込み const script = document.createElement(&#39;script&#39;); script.src = JS_FILE; script.onload = function() { // 必要に応じてJSファイルロード後に初期化処理 mermaid.initialize({startOnLoad: true}); } document.body.appendChild(script); })(); &lt;/script&gt; すでにロードした JavaScript の情報は、グローバルな window.loadedJsSet 変数に格納しておくことで重複ロードを防いでいます。 この方法であれば、baseof.html などのベーステンプレートで script 要素を出力する必要もなく、ショートコード用のファイルだけで完結できます。 ある意味 .HasShortcode を使う方法よりもすっきりするかもしれません。 この方法の欠点としては、このショートコードを使うたびに同じ JavaScript コードが出力されてしまうという点でしょうか。 とはいえ、ページ内でのショートコードの呼び出し回数が、たかだか数回程度と想定できるのであれば、それほど気にしなくてもいいと思います。 参考: mermaid.js で Markdown 中に UML 図を埋め込む"},{url:"/p/xg3n7qa/",title:"mermaid.js で Hugo の Markdown 記事に UML 図を埋め込む",date:"2020-10-13T00:00:00+09:00",body:"mermaid.js で Hugo の Markdown 記事に UML 図を埋め込む mermaid.js とは mermaid.js を使うと、独自構文のテキストから UML 図などを生成することができます。 JavaScript で動的に SVG を生成することができるので、Markdown ファイルに図を埋め込みたい場合によく使われています。 Azure DevOps Wiki や GitHub、Gitlab などでも標準サポートされており、Markdown で図を扱うときのデファクトスタンダードになるかもしれません。 UML 図の表現力という点では PlantUML の方が上ですが、そのあたりは改善されていくと思います。 Hugo は現時点 (v0.76.4) では、mermaid.js を標準サポートしていないので、ここでは Hugo に mermaid.js を組み込む方法を説明します。 mermaid.js の仕組み mermaid.js は、次のような mermaid クラスが付けられた HTML 要素の内容を読み取り、そこに変換後の図 (SVG) を挿入します。 この例の場合は、div 要素の内容が SVG に置き換わります。 &lt;div class=&#34;mermaid&#34;&gt; graph LR A --- B B--&gt;C[あいうえお] B--&gt;D(かきくけこ) &lt;/div&gt; HTML の body 要素の末尾あたりで、次のように mermaid.js の読み込みと初期化を行います。 ... &lt;script src=&#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#34;&gt;&lt;/script&gt; &lt;script&gt;mermaid.initialize({startOnLoad: true});&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; これだけで、Web ブラウザでページを開いたときに、SVG に変換された図が表示されます。 図: 表示例 mermaid.initialize() 関数には、表示方法をカスタマイズするためのオプション情報を渡すことができます。 startOnLoad: true と指定すると、HTML コンテンツが読み込み終わった時点で mermaid.js による変換が自動で開始されます。 逆に、startOnLoad: false としておくと、変換処理は自動で始まらなくなるので、任意のタイミングで mermaid.init() を呼び出すことで変換を開始します。 参考: API-Usage · mermaid これらをふまえて、Hugo にどのように mermaid.js を組み込んでいくかを考えてみます。 Hugo に mermaid.js を組み込む 方法1: コードブロックをそのまま使用する方法 Markdown ファイル内に、次のようなコードブロックを記述しておくと、クラス名 .language-mermaid の付いた &lt;code&gt; 要素が出力されます。 これは、Hugo 標準の機能です。 Markdown ```mermaid graph TD; A--&gt;B; A--&gt;C; ``` mermaid.js はデフォルトで mermaid クラスの付いた要素を変換対象としますが、任意の CSS セレクタを指定することができます。 なので、Hugo のベーステンプレートなどに次のようなコードを入れておけば、上記のコードブロックで SVG 図を出力することができます。 layouts/_default/baseof.html（抜粋） ... &lt;script src=&#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#34;&gt;&lt;/script&gt; &lt;script&gt; mermaid.initialize({startOnLoad: false}); mermaid.init(undefined, &#39;.language-mermaid&#39;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; これはとてもお手軽な方法ですが、図が含まれていないページでも mermaid.min.js の読み込みが発生してしまうという欠点があります。 それを許容できるのであれば、おそらく最も簡単な方法です。 方法2: 独自のショートコード + テンプレートを使う方法 下記は、mermaid ショートコードの実装例です。 layouts/shortcodes/mermaid.html &lt;div class=&#34;mermaid&#34;&gt; {{ .Inner }} &lt;/div&gt; このショートコードは、Markdown ファイル内で次のように呼び出します。 {{&lt; mermaid &gt;}} sequenceDiagram Client-&gt;&gt;Cache: search cache Cache--&gt;&gt;Client: cache Client-&gt;&gt;Repo: fetch data Repo--&gt;&gt;Client: data {{&lt; /mermaid &gt;}} あとは、ベーステンプレートなどで mermaid.js を読み込めばいいのですが、ここで Hugo の Page.HasShortcode という関数を利用すると、「mermaid ショートコードを使っているページでのみ mermaid.js をロードする」という振る舞いを実現できます。 layouts/_default/baseof.html（抜粋） ... {{- if .HasShortcode &#34;mermaid&#34; }} &lt;script src=&#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#34;&gt;&lt;/script&gt; &lt;script&gt;mermaid.initialize({startOnLoad: true});&lt;/script&gt; {{- end }} &lt;/body&gt; &lt;/html&gt; 参考: あるショートコードが使われている場合のみ JavaScript を読み込む (.HasShortcode) 方法3: ショートコードのみを使う方法 下記の mermaid ショートコードを使用すると、その場に mermaid.js を動的に読み込むコードが出力されます。 つまり、mermaid.js の導入を、ショートコードのみで完結させてしまう方法です。 layouts/shortcodes/mermaid.html &lt;div class=&#34;mermaid&#34;&gt; {{ .Inner }} &lt;/div&gt; &lt;script&gt; (function() { // JSファイルの多重ロードを防止 if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; // JSファイルの動的読み込み const script = document.createElement(&#39;script&#39;); script.src = &#39;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#39;; script.onload = () =&gt; { mermaid.initialize({startOnLoad: true}); }; document.body.appendChild(script); })(); &lt;/script&gt; ベーステンプレートなどを一切変更せずに mermaid.js を使えるようになるので、とてもお手軽な方法です。 ショートコード化しているので、独自パラメータを導入するのも簡単です。 若干気になるのは、mermaid ショートコードを呼び出すたびに重複する JS コードが出力されてしまうところですが、このくらいの長さであれば、ほとんど問題になることはないと思います。 （おまけ）mermaid ショートコードのカスタマイズ mermaid ショートコードを使うときに、次のように図の「タイトル」を入れられると便利です。 {{&lt; mermaid title=&#34;ほげほげ&#34; &gt;}} graph LR A --- B B--&gt;C[あいうえお] B--&gt;D(かきくけこ) {{&lt; /mermaid &gt;}} 図: ほげほげ 次の mermaid ショートコードは、title パラメータで図のタイトルを表示できるようにしています（今まで通り title を省略することも可能です）。 ついでに、全体を中央寄せで表示するようにしています。 ここでは、style 属性を直接指定していますが、CSS ファイル内で .mermaid クラスに対してスタイル指定することもできます（mermaid による変換後も &lt;div class=&quot;mermaid&quot;&gt; というタグは残るため）。 layouts/shortcodes/mermaid.html &lt;figure style=&#34;text-align: center;&#34;&gt; &lt;div class=&#34;mermaid&#34;&gt;{{ .Inner }}&lt;/div&gt; {{- with .Get &#34;title&#34; }}&lt;figcaption&gt;図: {{ . }}&lt;/figcaption&gt;{{ end }} &lt;/figure&gt; （おまけ）Visual Studio Code で mermaid をプレビュー VS Code は Markdown エディタとしてとても優秀ですが、さらに mermaid.js 用のプラグインを入れると、プレビューウィンドウで mermaid.js による図の変換をリアルタイムに確認できるようになります。 mermaid.js 用のプラグインは多数提供されていますが、下記は Markdown Preview Mermaid Support プラグインを入れたときの表示例です。 図: Markdown Preview Mermaid Support プラグイン このプラグインは、```mermaid という行で始まるコードブロックがプレビューの対象になるようですが、Hugo のショートコードにも対応したプラグインが出てくるとよいですね。"},{url:"/p/qyh8496/",title:"Androidメモ: 数値をある範囲内［min, max］に丸める (MathUtils.clamp)",date:"2020-08-31T00:00:00+09:00",body:"Androidメモ: 数値をある範囲内［min, max］に丸める (MathUtils.clamp) Android アプリの実装で、ある数字を指定した範囲 ［min, max］に収まるように調整したいときは、MathUtils.clamp() というユーティリティ関数を使用できます。 例: x の値を [-100, 100] の範囲に収める // import androidx.core.math.MathUtils var x = -150 x = MathUtils.clamp(x, -100, 100) //=&gt; -100 clamp() のような関数は Java のコアライブラリとして提供されていてもよさそうなのですが、現状は存在しないので Android がライブラリとして提供してくれています。 とはいっても、中身は下記のような簡単な実装です。 // MathUtils class public static int clamp(int value, int min, int max) { if (value &lt; min) { return min; } else if (value &gt; max) { return max; } return value; } ちなみに上記の代わりに、次のように書けば同じことができると思うかもしれませんが、 x = max(min(x, 100), -100) このようにすると、else-if ではなく全て if 分岐になってしまい効率が悪いです。"},{url:"/p/nmv4cjr/",title:"Python でテキストファイルを書き込む (write, writelines)",date:"2020-06-02T00:00:00+09:00",body:`Python でテキストファイルを書き込む (write, writelines) テキストファイルを一行ずつ書き込む (write) Python でファイル書き込み用のファイルオブジェクトを作成するには、open 関数 の mode パラメータで下記のいずれかの値を設定してファイルをオープンします。 文字 意味 ファイルが存在しない場合の動き ファイルが存在する場合の動き w 上書き 新規作成 内容をクリアして上書き a 追記 新規作成 末尾にテキストを追加 x 排他生成 新規作成 オープンに失敗する (FileExistsError) 最もよく使うのは、w による上書き用のオープンです。 次の例では、output.txt という名前のファイルを作成（あるいは上書き）して、2 つの行を書き込んでいます。 テキストファイルの作成 f = open(&#39;output.txt&#39;, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) f.write(&#39;Hello\\n&#39;) f.write(&#39;World\\n&#39;) f.close() エンコーディング形式 (encoding) は、省略するとプラットフォーム依存になるので、明示的に utf-8 を指定しておいた方がよいでしょう。 改行の扱い方 (newline) は、省略すると write() 関数での \\n の書き込みが、プラットフォーム依存の改行コードの書き込みという扱いになります。 必ず Unix の改行コード (LF) で書き込みたいということであれば、上記のように \\n あるいは '' を指定しておきましょう。 この指定により、write() 関数での \\n が LF、\\r\\n が CR+LF として書き込まれるようになります。 ファイルオブジェクトは最後に close() してリソースを解放する必要がありますが、 with を使って close() を自動化することができます。 基本的にはこの書き方をしておけばよいです。 close 処理の自動化 with open(&#39;output.txt&#39;, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) as f: f.write(&#39;Hello\\n&#39;) f.write(&#39;World\\n&#39;) 文字列のリストをまとめて書き込む (writelines) 文字列のリストを一度に書き込みたい場合は、write() の代わりに writelines() を使用すると便利です。 複数行の出力 lines = [ &#39;Hello\\n&#39;, &#39;World\\n&#39; ] with open(&#39;output.txt&#39;, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) as f: f.writelines(lines) writelines() も write() と同様に、行末に改行を入れたりはしません。 改行したい場合は、明示的に改行文字 \\n を入れる必要があります。 open の排他生成モード (mode=x) の用途 open() の一見変わったモードとして、排他生成モード (mode=&quot;x&quot;)があります。 このモードでオープンすると、すでにファイルが存在している場合に FileExistsError 例外 が発生するようになっています。 例えば次のように、ファイルが存在しない場合だけ、デフォルト値の書き込まれたデータファイルを作成するといったケースで使えます。 すでに config.yml が存在する場合は何もしない try: with open(&#39;config.yml&#39;, mode=&#39;x&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) as f: f.write(&#39;user: anonymous\\n&#39;) except FileExistsError: # Already exists pass このコードは、次のようにファイルの存在チェックをするのと同じように見えるかもしれません。 このコードには不具合がある import os.path if os.path.exists(&#39;config.yml&#39;): # Already exists else: with open(&#39;config.yml&#39;, mode=&#39;x&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) as f: f.write(&#39;user: anonymous\\n&#39;) しかし、後者の方法では、ファイルの存在チェックから open() の実行までのわずかな時間に、ファイル存在状態が変化するというレースコンディションが発生する危険があります。 また、後者の方法だと、os.path をインポートしないといけないとか、ファイル名を 2 か所で指定しないといけない、といった欠点があります。 これらの理由から、ファイルが存在しない場合にのみファイルを新規作成したい場合には、open 関数の x モードを使用するのが適しています。`},{url:"/p/wewevcs/",title:"Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する",date:"2020-06-01T00:00:00+09:00",body:"Python の urllib による HTTP 通信 (6) レスポンスヘッダを取得する urllib.request.urlopen() が返した HTTPResponse オブジェクトの info() メソッドを呼び出すと、HTTP レスポンスのヘッダ情報を取得することができます。 ヘッダ情報は HTTPMessage オブジェクト として返されますが、これは通常の辞書オブジェクトと同様に使用することができます。 詳しくは、HTTPMessage の親クラスである email.message.Message の定義を参照してください。 次の例では、Web サイトにアクセスしたときの HTTP レスポンスヘッダーを取得して表示しています。 sample.py import urllib.request url = &#39;https://yahoo.co.jp/&#39; try: with urllib.request.urlopen(url) as res: # HTTP レスポンスのヘッダ情報を取得 headers = res.info() print(type(headers)) #=&gt; http.client.HTTPMessage print() print(headers) # 下記は Body 部分の取得 # text = res.read().decode(&#39;utf-8&#39;) # print(text) except urllib.error.URLError as err: print(&#39;Could not access: %s&#39; % url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) 実行結果 &lt;class &#39;http.client.HTTPMessage&#39;&gt; Cache-Control: private, no-cache, no-store, must-revalidate Content-Type: text/html; charset=UTF-8 Date: Mon, 01 Jun 2020 06:07:42 GMT Expires: -1 Pragma: no-cache Set-Cookie: B=1sg6o4tfd96pe&amp;b=3&amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.yahoo.co.jp Vary: Accept-Encoding X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-Vcap-Request-Id: f25c0bf4-0481-4804-5fe1-ef1fab7a3080 X-Xss-Protection: 1; mode=block Age: 0 Transfer-Encoding: chunked Connection: close Via: http/1.1 edge2424.img.djm.yahoo.co.jp (ApacheTrafficServer [c sSf ]) Server: ATS Set-Cookie: XB=1sg6o4tfd96pe&amp;b=3&amp;s=ab; expires=Thu, 02-Jun-2022 06:07:42 GMT; path=/; domain=.yahoo.co.jp; secure; samesite=none 特定のヘッダ情報だけ取得したい場合は、次のように参照すれば OK です。 Content-Type ヘッダーを参照する with urllib.request.urlopen(url) as res: headers = res.info() if &#39;Content-Type&#39; in headers: print(headers[&#39;Content-Type&#39;])"},{url:"/p/8axzppz/",title:"GitHub の REST API を Python から使用する",date:"2020-05-30T00:00:00+09:00",body:"GitHub の REST API を Python から使用する 何を作るか？ Python で GitHub API を利用するアプリケーションを作るときは、GitHub API を実行して情報取得する部分を、1 つのモジュールとして切り出しておくと全体のコードがすっきりします。 ここでは、実装例として GitHubApi というクラスを作り、次のようなことを行えるようにします。 get_members() や get_issues() といった直感的な API で GitHub の情報を取得できるようにする オプションでプロキシや Personal Access Token を指定できるようにする ページネーションによる連続アクセスで、多くの情報を一度に取得できるようにする GitHub の REST API に関しては、下記の記事を参照してください。 GitHub の REST API を使用する GitHub の REST API で Issue 情報を取得する方法いろいろ GitHubApi クラスを実装する ここで紹介する GitHubApi クラスを使うと、次のようなシンプルなコードで GitHub API を呼び出して、その結果を Python のオブジェクトとして取得することができます。 # ユーザー情報を取得する user = api.get_user(&#39;maku77&#39;) print(user[&#39;login&#39;]) 下記は、GitHubApi クラスの実装例です。 github.py import json import re import sys from urllib.parse import quote, urlencode import urllib.request class GitHubApi: BASE_URL = &#39;https://api.github.com&#39; UNVERIFY_SSL = True def __init__(self, option={}): self.option = option if self.UNVERIFY_SSL: self.__unverify_ssl() def __unverify_ssl(self): import ssl ssl._create_default_https_context = ssl._create_unverified_context def __get_json(self, url, paginate=False): req = self.__create_request(url) try: with urllib.request.urlopen(req) as res: json_text = res.read().decode(&#39;utf-8&#39;) json_obj = json.loads(json_text) # ページネーションによる繰り返し取得 if paginate: next_link = self.__get_next_link(res.info()) if next_link: json_obj.extend(self.__get_json(next_link)) return json_obj except urllib.error.URLError as err: print(&#39;Could not access: %s&#39; % req.full_url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) # ページネーションによる連続取得が必要な場合は、 # 次のアドレスを返す。必要ない場合は None を返す。 def __get_next_link(self, response_headers): link = response_headers[&#39;Link&#39;] if not link: return None match = re.search(r&#39;&lt;(\\S+)&gt;; rel=&#34;next&#34;&#39;, link) if match: return match.group(1) return None def __create_request(self, url): req = urllib.request.Request(url) if &#39;token&#39; in self.option: req.add_header(&#39;Authorization&#39;, &#39;token %s&#39; % self.option[&#39;token&#39;]) if &#39;proxy&#39; in self.option: req.set_proxy(self.option[&#39;proxy&#39;], &#39;http&#39;) req.set_proxy(self.option[&#39;proxy&#39;], &#39;https&#39;) return req # 指定したユーザーの情報を取得します def get_user(self, username): url = self.BASE_URL + &#39;/users/%s&#39; % quote(username) return self.__get_json(url) # 指定した組織のメンバーリストを取得します def get_members(self, org): url = self.BASE_URL + &#39;/orgs/%s/members?per_page=100&#39; % quote(org) return self.__get_json(url, paginate=True) # 指定した組織のリポジトリ一覧を取得します def get_org_repos(self, org): url = self.BASE_URL + &#39;/orgs/%s/repos?per_page=100&#39; % quote(org) return self.__get_json(url, paginate=True) # 指定したユーザーのリポジトリ一覧を取得します def get_user_repos(self, user): url = self.BASE_URL + &#39;/users/%s/repos?per_page=100&#39; % quote(user) return self.__get_json(url, paginate=True) # 指定したリポジトリの Issue 一覧を取得します def get_issues(self, owner, repo, params={}): url = self.BASE_URL + &#39;/repos/%s/%s/issues?per_page=100&#39; % (quote(owner), quote(repo)) if params: url = &#39;%s&amp;%s&#39; % (url, urlencode(params)) return self.__get_json(url, paginate=True) 最後の方にある get_xxx 系のメソッドが、GitHub API を呼び出すための public メソッドです。 同じようにメソッドを追加していけば、いろいろな GitHub API に対応することができます。 どのような API があるかは、GitHub REST API v3 のサイト を参照してください。 ページネーション処理 GitHub API v3 でリポジトリの一覧などを取得すると、デフォルトでは 30 件ずつしか結果を返してくれません。 URL 末尾のクエリパラメーターで per_page=100 と指定すれば、100 件までは一度に取得できるのですが、100 件を超えるすべての情報を取得したいときは、ページネーションの仕組み を使って何度かに分けて取得する必要があります。 次ページの情報を取得するときは、page=2 のようにクエリ指定する必要があるのですが、次ページが存在する場合は HTTP レスポンスの Link ヘッダーに次ページのアドレスが含まれているので、このアドレスを使って繰り返しアクセスするのがよいでしょう。 上記のサンプルコードでは、__get_json メソッドの中で次のようにページネーション処理しています。 次のページがある場合は、再帰的に __get_json を呼び出し、その結果を json_obj 配列に結合しています。 # ページネーションによる繰り返し取得 if paginate: next_link = self.__get_next_link(res.info()) if next_link: json_obj.extend(self.__get_json(next_link)) GitHubApi クラスの使用例いろいろ 下記は、GitHubApi クラスを使って、いろいろな情報を取得するサンプルコードです。 from github import GitHubApi api = GitHubApi() # ユーザー情報を取得 user = api.get_user(&#39;maku77&#39;) print(user[&#39;login&#39;]) print(user[&#39;blog&#39;]) print(user[&#39;company&#39;]) # 指定した組織のリポジトリ一覧を取得します repos = api.get_org_repos(&#39;sony&#39;) for repo in repos: print(repo[&#39;name&#39;]) print(repo[&#39;full_name&#39;]) print(repo[&#39;description&#39;]) print(repo[&#39;html_url&#39;]) print() # 指定した組織のメンバーリストを取得 members = api.get_members(&#39;sony&#39;) for member in members: print(member[&#39;login&#39;]) # 指定したリポジトリの Issue 一覧を取得します（open 状態のもの） issues = api.get_issues(&#39;sony&#39;, &#39;nnabla&#39;) for issue in issues: print(issue[&#39;title&#39;]) # 指定したリポジトリの Issue 一覧を取得します（close 状態のものも取得） issues = api.get_issues(&#39;sony&#39;, &#39;nnabla&#39;, params={&#39;state&#39;: &#39;all&#39;}) for issue in issues: print(issue[&#39;title&#39;]) プロキシや Personal Access Token を指定してアクセスする必要がある場合は、GitHubApi コンストラクタのオプションで次のように指定します。 options = { &#39;proxy&#39;: &#39;proxy.example.com:80&#39;, &#39;token&#39;: &#39;a0709c8d0ac21812d9c4b8511298b33ec0fd2813&#39; } api = GitHubApi(options) ここでは、取得した情報のうち、ごく一部のプロパティだけを参照していますが、GitHub API が返す値にはもっといろいろな情報が含まれています。 これらの情報をうまく使えば、日々の業務を自動化できるかもしれません。"},{url:"/p/w7p7n4j/",title:"Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode)",date:"2020-05-30T00:00:00+09:00",body:"Python で文字列を URL エンコード／デコードする (urllib.parse.quote, unquote, urlencode) Python の標準モジュールとして提供されている urllib.parse を使用すると、任意の文字列を URL 内で扱えるようにエンコード／デコードすることができます。 ユーザーが入力したテキストや、日本語を含むテキストをエスケープ処理して URL として扱いたいときに使用できます。 文字列を URL エンコードする (quote) 任意の文字列を URL として扱いたいときは、urllib.parse.quote 関数 を使うと、エスケープすべき文字を %xx という形に変換してくれます。 from urllib.parse import quote print(quote(&#39;あ&#39;)) #=&gt; &#39;%E3%81%82&#39; print(quote(&#39;ABC&#39;)) #=&gt; &#39;ABC&#39; print(quote(&#39;A B C&#39;)) #=&gt; &#39;A%20B%20C&#39; print(quote(&#39;A/B/C&#39;)) #=&gt; &#39;A/B/C&#39; 上記の結果からわかるように、quote 関数はデフォルトではスラッシュ (/) をエスケープしません。 これは、変換しない文字を示すオプションパラメータ safe のデフォルト値が '/' になっているからです。 次のようにすると、スラッシュが %2F にエスケープされるようになります。 print(quote(&#39;A/B/C&#39;, safe=&#39;&#39;)) #=&gt; &#39;A%2FB%2FC&#39; URL の特定階層のパス名をユーザーに入力させるようなケースで使用できます。 URL をデコードする (unquote) 逆に、URL エンコードされた文字列をデコードして元に戻すには、urllib.parse.unquote 関数 を使用します。 from urllib.parse import unquote print(unquote(&#39;%E3%81%82&#39;)) #=&gt; &#39;あ&#39; print(unquote(&#39;ABC&#39;)) #=&gt; &#39;ABC&#39; print(unquote(&#39;A%20B%20C&#39;)) #=&gt; &#39;A B C&#39; print(unquote(&#39;A%2FB%2FC&#39;)) #=&gt; &#39;A/B/C&#39; クエリ文字列を作成する (urlencode) HTTP の GET リクエストを送るときに、URL の末尾に次のようにクエリ文字列を付加したいことがあります。 https://example.com/?key1=value1&amp;key2=value2 urllib.parse.urlencode 関数 を使用すると、任意のディクショナリオブジェクトからクエリ文字列を作成することができます。 ディクショナリの各要素が key1=value1 という形で、&amp; 記号により結合された文字列が返されます。 キーと値は適切に URL エンコードされるので、そのまま URL の末尾にくっつけることができます。 from urllib.parse import urlencode query = urlencode({&#39;a&#39;:100, &#39;b&#39;:200}) print(query) #=&gt; a=100&amp;b=200 query = urlencode({&#39;a&#39;:&#39;あ&#39;, &#39;b&#39;:&#39;い&#39;}) print(query) #=&gt; a=%E3%81%82&amp;b=%E3%81%84 query = urlencode({&#39;msg&#39;:&#39;hello world&#39;}) print(query) #=&gt; msg=hello+world 次のようにすれば、クエリ文字列の付いた URL を簡単に生成できます。 from urllib.parse import urlencode base = &#39;https://example.com/&#39; query = { &#39;key1&#39;: 100, &#39;key2&#39;: 200 } url = &#39;%s?%s&#39; % (base, urlencode(query)) print(url) #=&gt; https://example.com/?key1=100&amp;key2=200"},{url:"/p/dpccbv7/",title:"Vim/Neovim でウィンドウ（タブ）移動時にカレントディレクトリも自動で移動する (autochdir)",date:"2020-05-29T00:00:00+09:00",body:"Vim/Neovim でウィンドウ（タブ）移動時にカレントディレクトリも自動で移動する (autochdir) カレントディレクトリとは Vim のカレントディレクトリは、Vim で最初に開いたファイルがあるディレクトリに設定されます。 カレントディレクトリは、例えば下記のようなコマンドを実行したときに、起点となるディレクトリとして参照されます。 :vim pattern **/*.txt などで複数ファイルを grep するとき :e sample.txt でファイルを開くとき :cd dirname でカレントディレクトリを移動するとき :terminal でターミナルを開くとき このカレントディレクトリは、:e や :tabnew コマンドで別のディレクトリにあるファイルを開いた場合も変化しません。 :vim (:vimgrep) コマンドでファイルを検索してもなぜかヒットしないというときは、カレントディレクトリが正しくセットされてない可能性があります。 カレントディレクトリは :pwd で確認することができます。 カレントディレクトリを変更する 手動で移動する 明示的にカレントディレクトリを設定するには :cd コマンドを使用します。 編集中のファイルがあるディレクトリへ移動する :cd %:h と実行すると、現在編集中のファイルがあるディレクトリ (%:h) へ移動することができます。 カレントウィンドウ（カーソルのあるウィンドウ）のみを対象にカレントディレクトリを移動したいときは、:cd の代わりに :lcd コマンドを使用します。 自動で移動する autochdir オプションをセットしておくと、新しくウィンドウを開いた時や、タブを切り替えたときなどに、そのファイルがあるディレクトリへ自動で移動してくれるようになります。 ~/.vimrc &#34; Change the current working directory automatically set autochdir Neovim の場合 (~/.config/nvim/init.lua) -- Change the current working directory automatically vim.opt.autochdir = true 現在の設定は :set autochdir? コマンドで確認できます。 autocmd を設定してディレクトリ移動を自動化する方法 もありますが、autochdir が使える Vim 環境であればそちらを使った方が簡単です。"},{url:"/p/gzo8d7y/",title:".env ファイルで環境変数を設定する (python-dotenv)",date:"2020-05-27T00:00:00+09:00",body:".env ファイルで環境変数を設定する (python-dotenv) python-dotenv モジュールの概要 python-dotenv モジュールを使用すると、Python プログラム実行時に次のような .env ファイルを読み込んで、環境変数を設定することができます。 .env MYAPP_USER=maku MYAPP_PASS=makupass MYAPP_CONFIG=${HOME}/${MYAPP_USER}/config 上記の例のように、${HOME} という形で環境変数の値を展開することもできます。 特定のプログラムを実行するために、いちいち OS の環境変数を設定するのを嫌がるユーザーはたくさんいます。 あなたのプログラムが何らかの環境変数を必要としているのであれば、.env ファイルによる設定手段も提供しておくと親切です。 .env の仕組みは Python に限ったものではなく、いろいろな言語で採用されています。 参考: Node.js プログラムで .env ファイルを使用する python-dotenv モジュールのインストール python-dotenv モジュールは pip コマンドでインストールできます。 $ python3 -m pip install python-dotenv ☝️ venv 仮想環境を使う システム全体の Python 実行環境を汚したくない場合は、次のように venv 仮想環境を作成 して、そこにインストールしましょう。 $ python3 -m venv venv $ source venv/bin/activate (venv) $ pip install python-dotenv 仮想環境は次のように抜けられます。 (venv) $ deactivate python-dotenv の使い方 .env ファイルの内容を環境変数に反映する .env ファイルを読み込むのはとても簡単で、load_dotenv() を呼び出すだけです。 次の Python スクリプトでは、同じディレクトリ（あるいは、より上位のディレクトリ）に置かれた .env ファイルの内容を読み込み、環境変数に反映しています。 .env を環境変数に反映 from dotenv import load_dotenv load_dotenv() # Load environment variables from .env file 基本的な使い方としては、これだけで OK です。 仮に、.env ファイルが存在しなくても、load_dotenv() はエラーにならないので、上記のようなコードは安心して実行することができます。 OS の環境変数を上書きする (override) OS の環境変数設定で、すでに同じ名前の変数が定義されている場合は、そちらが優先して使われるようになっています。 .env ファイルで設定した値を優先して使いたい場合は、次のように override オプションを指定します。 from dotenv import load_dotenv load_dotenv(override=True) （おまけ）config モジュール化する 次の config.py は、アプリケーション全体のコンフィグ情報を管理するモジュールの実装例です。 config.py from dotenv import load_dotenv import os load_dotenv() # Load environment variables from .env file MYAPP_USER = os.getenv(&#34;MYAPP_USER&#34;) MYAPP_PASS = os.getenv(&#34;MYAPP_PASS&#34;) この config モジュールを使えば、アプリケーションのどこからでも次のようにコンフィグ情報を参照できるようになります。 main.py import config print(config.MYAPP_USER) print(config.MYAPP_PASS) .env ファイルの扱い方 .env ファイルはどこに置くべきか？ ある Python スクリプトから dotenv.load_dotenv() 関数を呼び出すと、そのスクリプトファイルがあるディレクトリを起点に、.env ファイルが見つかるまで親ディレクトリを遡りながら検索します。 なので、あるプロジェクトで使用する .env ファイルは、そのプロジェクトのルートディレクトリに配置 しておけば、まずロードに失敗することはありません。 .env ファイルは Git にコミットする？ .env ファイルは、ユーザー固有の設定を記述するものです。 例えば、Web サービスのアクセストークンなどを記述するので、 .env ファイルは Git にコミットしてはいけません。 間違えてコミットしないように、.gitignore ファイルに .env のエントリを登録しておきましょう。 Git にコミットしない .env ファイルであることを明確にするために、.env.local というファイル名を使うこともあります。"},{url:"/p/wozpogm/",title:"Python の実行環境を venv で切り替える",date:"2020-05-27T00:00:00+09:00",body:"Python の実行環境を venv で切り替える venv モジュールは、Python の仮想実行環境を作成するための標準モジュールです。 Python 3.2 までは virtualenv という外部パッケージを使用していましたが、Python 3.3 以降は標準で同等機能を提供する venv パッケージ を使用できます。 なぜ仮想環境が必要か？ Python で作成されたプログラムは、pip install で外部モジュールをインストールすることを前提に作成されたものがたくさんあります。 Python プログラムを実行するために、何も考えずに pip install を繰り返していると、いろいろなバージョンのモジュールがインストールされてしまい、実行環境がぐちゃぐちゃになってしまいます。 あるプログラムを動作させるために pip install すると、別のプログラムが動作しなくなるといったことが起こります。 venv を使って仮想環境を作ると、その環境内に閉じて pip install することができるようになります。 例えば、app1 と app2 という 2 つの Python プログラム用に別々の仮想環境を作って、それぞれのプログラムに必要なパッケージをインストールするということができます。 プロジェクト用の仮想環境を作成する／削除する 仮想環境を作成する 仮想環境を作成するには、次のようなコマンドを実行します。 仮想環境はディレクトリの形で作成され、その中に必要なファイルが自動生成されます。 ここでは、python3 を使っていますが、環境によっては python に置き換えてください（Windows の場合は py だったりします）。 仮想環境の作成 $ python3 -m venv &lt;仮想環境ディレクトリ&gt; 仮想環境ディレクトリの名前としては、一般的に venv や .venv が使われます。 このディレクトリは Git にコミットするものではないので、好きな方を選べばよいです。 プロジェクトごとに仮想環境を作成するのであれば、プロジェクトのルートに仮想環境ディレクトリを作成するのがよいでしょう。 例えば、myapp プロジェクト用の仮想環境を作るには次のようにします。 仮想環境ディレクトリ venv を作成 $ mkdir ~/myapp $ cd ~/myapp $ python3 -m venv venv この仮想環境ディレクトリには、次のようなファイル群が格納されていて、仮想環境内でインストールしたパッケージなどはこの中で管理されます。 $ ls venv bin/ include/ lib/ pyvenv.cfg 仮想環境を削除する 仮想環境が必要なくなった場合は、仮想環境ディレクトリを丸ごと削除してしまえば OK です。 仮想環境の削除 $ rm -Rf venv .gitignore を修正する 仮想環境ディレクトリは他のユーザーと共有する仕組みにはなっていないので、.gitignore ファイルに次のように記述して、Git にコミットしないようにします。 .gitignore .venv/ venv/ ここでは、仮想環境ディレクトリ名が .venv あるいは venv であると想定しています。 このあたりはプロジェクト内でルール化して、README.md などに仮想環境の構築方法を記述しておきましょう。 仮想環境に入る / 抜ける 仮想環境に入る (activate) 作成した仮想環境を使用するには、仮想環境のディレクトリ内に作成された activate スクリプトを実行します。 Linux と Windows で呼び出すスクリプトのパスが異なるので注意してください。 仮想環境に入る（Linux や macOS の場合） $ source venv/bin/activate 仮想環境に入る（Windows の場合） venv\\Scripts\\activate.bat 仮想環境に入ると、次のように、プロンプトの先頭に仮想環境名が表示されます。 (.venv) $ この状態で pip install コマンドを実行すると、仮想環境内に閉じてパッケージがインストールされます。 そのパッケージが有効なのは、この仮想環境内で python コマンドを実行した場合のみです。 仮想環境にパッケージをインストール (.venv) $ pip install requests (.venv) $ pip install python-dotenv (.venv) $ pip install ... 仮想環境から抜ける (deactivate) 仮想環境から抜けるには、単純に deactivate コマンドを実行します。 このコマンドは、仮想環境に入っている状態であれば、どのディレクトリからでも実行できるようになっています。 仮想環境から抜ける (.venv) $ deactivate 特定のバージョンの Python を使う仮想環境を作成する venv 環境内で実行される python のバージョンは、venv 環境を作成するときに実行した python のバージョンと同じになります。 仮想環境内で任意のバージョンの python コマンドを使いたい場合は、venv 環境を作るときにそのバージョンの python コマンドを使用する必要があります。 python コマンドのバージョンを切り替えるには、pyenv コマンド (Linux/macOS) や py コマンド (Windows) を使うと便利です。 参考: python コマンドのバージョンを切り替える (pyenv, py) 下記は任意の Python バージョン（ここでは 3.10）の venv 仮想環境を作成する方法の例です。 pyenv を使う方法 (Linux/macOS) # Python 3.10.X をインストール $ pyenv install 3.10 # カレントシェルで Python 3.10 を使うように切り替え $ pyenv shell 3.10 # venv 環境を作成 $ python -m venv venv py を使う方法 (Windows) C:\\&gt; py -3.10 -m venv venv プロジェクトの依存パッケージを requirements.txt で管理する requirements.txt とは これは venv の仕組みではなくて、パッケージ管理ツールの pip の仕組み ですが、requirements.txt というファイルに依存パッケージを記述しておくと、一撃で依存パッケージをインストールできるようになります。 Python アプリのソースコードと一緒に、この requirements.txt を Git にコミットしておくことで、チーム内の開発環境を簡単に揃えることができます。 venv による仮想環境を使って開発を進める場合、初期状態では何もパッケージがインストールされていない状態からパッケージをインストールしていくことになるため、requirements.txt によるパッケージ管理は非常に相性がよいといえます。 requirements.txt を生成する pip freeze コマンドを使うと、現在の仮想環境にインストールされているパッケージのリストをもとに requirements.txt を自動生成することができます。 このコマンドは、仮想環境に入っている状態で（source venv/bin/activate コマンドを実行した後に）実行してください。 (.venv) pip freeze &gt; requirements.txt 例えば、requires と python-dotenv パッケージをインストールした後の requirements.txt の内容は次のような感じになります（間接的に依存するパッケージも列挙されます）。 requirements.txt certifi==2021.10.8 charset-normalizer==2.0.7 idna==3.3 python-dotenv==0.19.1 requests==2.26.0 urllib3==1.26.7 requirements.txt はプロジェクトのルートディレクトリに配置して、Git にコミットしておきましょう。 requirements.txt を使ってパッケージをインストールする 別の PC 環境で開発を始めるときは、次のようにセットアップすることができます。 $ python3 -m venv venv # 仮想環境を作成する $ source venv/bin/activate # 仮想環境に入る (.venv) $ pip install -r requirements.txt # 依存パッケージをインストールする これで、依存パッケージがすべてインストールされた状態で python コマンドを実行することができます。"},{url:"/p/uvoibwi/",title:"GitHub の REST API で Issue 情報を取得する方法いろいろ",date:"2020-05-25T00:00:00+09:00",body:"GitHub の REST API で Issue 情報を取得する方法いろいろ あるリポジトリの Issues の一覧を取得する GitHub の /repos/&lt;ユーザー名&gt;/&lt;リポジトリ名&gt;/issues という REST API エンドポイントにアクセスすると、指定したリポジトリ内の Issue の一覧を取得することができます。 特定の Organization が提供しているリポジトリを指定するときは、ユーザー名 の部分を Organization名 に置き換えてください。 Public リポジトリの場合 Public リポジトリの情報は、誰でも簡単に取得することができます。 下記は、curl コマンドを使って REST API を呼び出すサンプルです。 ユーザー名とリポジトリ名の部分は適切な値に変更してください。 Public なリポジトリの場合 $ USER_NAME=myname $ REPO_NAME=myrepo $ curl https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues HTTP レスポンスのヘッダ情報も確認したい場合は、 -i オプションを追加してください。 上記のような GET リクエストにより、Issue のリスト（PullRequest も含む）が JSON 形式で返されます。 単純な GET リクエストなので、ブラウザで直接 URL を入力することでも情報を取得することができます。 下記は、1 つの Issue だけ含むリポジトリから情報を取得したときのサンプルです。 この Issue には、ラベル1 と ラベル2 という 2 つのラベルが設定されています。 リポジトリの Issue リストの例 (JSON) [ { &#34;url&#34;: &#34;https://api.github.com/repos/maku77/sample/issues/1&#34;, &#34;repository_url&#34;: &#34;https://api.github.com/repos/maku77/sample&#34;, &#34;labels_url&#34;: &#34;https://api.github.com/repos/maku77/sample/issues/1/labels{/name}&#34;, &#34;comments_url&#34;: &#34;https://api.github.com/repos/maku77/sample/issues/1/comments&#34;, &#34;events_url&#34;: &#34;https://api.github.com/repos/maku77/sample/issues/1/events&#34;, &#34;html_url&#34;: &#34;https://github.com/maku77/sample/issues/1&#34;, &#34;id&#34;: 624149172, &#34;node_id&#34;: &#34;MDU6SXNzdWU2MjQxNDkxNzI=&#34;, &#34;number&#34;: 1, &#34;title&#34;: &#34;Issueのタイトル1&#34;, &#34;user&#34;: { &#34;login&#34;: &#34;maku77&#34;, &#34;id&#34;: 5519503, &#34;node_id&#34;: &#34;MDQ6VXNlcjU1MTk1MDM=&#34;, &#34;avatar_url&#34;: &#34;https://avatars2.githubusercontent.com/u/5519503?v=4&#34;, &#34;gravatar_id&#34;: &#34;&#34;, &#34;url&#34;: &#34;https://api.github.com/users/maku77&#34;, &#34;html_url&#34;: &#34;https://github.com/maku77&#34;, &#34;followers_url&#34;: &#34;https://api.github.com/users/maku77/followers&#34;, &#34;following_url&#34;: &#34;https://api.github.com/users/maku77/following{/other_user}&#34;, &#34;gists_url&#34;: &#34;https://api.github.com/users/maku77/gists{/gist_id}&#34;, &#34;starred_url&#34;: &#34;https://api.github.com/users/maku77/starred{/owner}{/repo}&#34;, &#34;subscriptions_url&#34;: &#34;https://api.github.com/users/maku77/subscriptions&#34;, &#34;organizations_url&#34;: &#34;https://api.github.com/users/maku77/orgs&#34;, &#34;repos_url&#34;: &#34;https://api.github.com/users/maku77/repos&#34;, &#34;events_url&#34;: &#34;https://api.github.com/users/maku77/events{/privacy}&#34;, &#34;received_events_url&#34;: &#34;https://api.github.com/users/maku77/received_events&#34;, &#34;type&#34;: &#34;User&#34;, &#34;site_admin&#34;: false }, &#34;labels&#34;: [ { &#34;id&#34;: 2086106907, &#34;node_id&#34;: &#34;MDU6TGFiZWwyMDg2MTA2OTA3&#34;, &#34;url&#34;: &#34;https://api.github.com/repos/maku77/sample/labels/%E3%83%A9%E3%83%99%E3%83%AB1&#34;, &#34;name&#34;: &#34;ラベル1&#34;, &#34;color&#34;: &#34;23c6bc&#34;, &#34;default&#34;: false, &#34;description&#34;: &#34;&#34; }, { &#34;id&#34;: 2086107046, &#34;node_id&#34;: &#34;MDU6TGFiZWwyMDg2MTA3MDQ2&#34;, &#34;url&#34;: &#34;https://api.github.com/repos/maku77/sample/labels/%E3%83%A9%E3%83%99%E3%83%AB2&#34;, &#34;name&#34;: &#34;ラベル2&#34;, &#34;color&#34;: &#34;f9bbdb&#34;, &#34;default&#34;: false, &#34;description&#34;: &#34;&#34; } ], &#34;state&#34;: &#34;open&#34;, &#34;locked&#34;: false, &#34;assignee&#34;: null, &#34;assignees&#34;: [ ], &#34;milestone&#34;: null, &#34;comments&#34;: 0, &#34;created_at&#34;: &#34;2020-05-25T08:51:56Z&#34;, &#34;updated_at&#34;: &#34;2020-05-25T08:51:56Z&#34;, &#34;closed_at&#34;: null, &#34;author_association&#34;: &#34;OWNER&#34;, &#34;body&#34;: &#34;Issueのコメント1&#34; } ] Issue が 1 つも存在しない場合は、空の配列を示す JSON 文字列 ([]) が返されます。 リポジトリ名などの指定が間違っている場合は、次のような JSON 文字列が返されます（レスポンスのステータスコードは HTTP/1.1 404 Not Found です）。 存在しないリポジトリを指定した場合 { &#34;message&#34;: &#34;Not Found&#34;, &#34;documentation_url&#34;: &#34;https://developer.github.com/v3/issues/#list-issues-for-a-repository&#34; } Private リポジトリの場合 Private なリポジトリの情報を単純に GET リクエストで取得しようとすると、間違ったリポジトリ名を指定した場合と同様の Not Found メッセージが返されます。 403 Forbidden ではなく、404 Not Found を返すのは、Private リポジトリの存在に気づかれないようにするためのセキュリティ上の対策とされています。 Private リポジトリから Issue の一覧を取得するには、GitHub の Personal access token 設定 で発行したトークンや、OAuth トークンを使ってアクセスする必要があります。 二要素認証を有効にしている場合でも、これらのトークンによるアクセスは有効です。 トークンは次のように HTTP リクエストの Authorization ヘッダで指定します。 アクセストークンを指定した API 呼び出し $ TOKEN=dd7bbe7538fd705d5350bc152c5e44d828d32b22 $ USER_NAME=myname $ REPO_NAME=myrepo $ curl -H &#34;Authorization: token $TOKEN&#34; https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues アクセストークンのスコープとしては、次のように repo (Full control of private repositories) を割り当てておく必要があるようです。 図: Issue のリストを取得するためのアクセストークン設定 あるユーザーにアサインされた Issue の一覧を取得する /user/issues という REST API エンドポイントにアクセスすると、認証済みユーザー（つまり自分）にアサインされた Issue の一覧を取得することができます。 例えば、次のように、Personal Access Token を使った情報取得が可能です。 ユーザーにアサインされた Issue の一覧を取得する $ TOKEN=dd7bbe7538fd705d5350bc152c5e44d828d32b22 $ curl -H &#34;Authorization: token $TOKEN&#34; https://api.github.com/user/issues 取得する Issue の種類を指定する URL 末尾にクエリパラメーターを追加することで、取得する Issue を絞り込むことができます。 closed 状態の Issue を取得する (state=closed) 例: Close 済みの Issue を取得する $ USER_NAME=myname $ REPO_NAME=myrepo $ curl https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues?state=closed state パラメーターを指定すると、open/closed 状態を指定して Issue リストを取得することができます。 state=open &hellip; Open 状態の Issue のみ取得（デフォルト） state=closed &hellip; Close 状態の Issue のみ取得 state=all &hellip; すべての Issue を取得 ちなみに curl コマンドでは、URL 末尾のクエリパラメーター (?...) の代わりに、次のように --data オプションで指定することもできます。 スクリプトを作成するときに便利かもしれません。 --data オプションを指定すると、curl は POST メソッドでアクセスしようとするので、-G も同時に指定して GET メソッドを使うように指示する必要があります。 クエリパラメーターの代わりに --data オプションを使う方法 $ curl -G --data &#34;state=closed&#34; https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues あるラベルが付いている Issue を取得する (labels) 例: &#39;ラベル1&#39; というラベルを持つ Issue を取得する $ curl -G --data-urlencode &#34;labels=ラベル1&#34; https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues labels パラメーターでは、複数のラベル名をカンマ区切りで指定することができます。 URL 末尾のクエリパラメーターとして指定することもできるのですが、日本語などを含むラベルは URL エンコードした形で指定しなければいけないので、ここでは curl の --data-urlencode オプションを使って labels パラメーターを渡しています。 この場合も前述の例と同様に、-G オプションを指定して GET メソッドを使う必要があります。 その他のパラメーター Issue の一覧を取得するときには、他にもいろいろクエリパラメーターで絞り込みを行えます。 詳しくは下記の GitHub Developers Guide のサイトで確認してみてください。 参考: Issues ｜ GitHub Developer Guide"},{url:"/p/4ziyhxe/",title:"Hugo でページリスト（記事一覧）に列挙されないページを作る (_build.list)",date:"2020-05-17T00:00:00+09:00",body:"Hugo でページリスト（記事一覧）に列挙されないページを作る (_build.list) Hugo 0.65.0 で、ビルド時の振る舞いを制御するためのフロントマター用プロパティ (_build) が導入されました。 記事ページのフロントマターで、_build.list プロパティを never に設定しておくと、.Pages、.RegularPages、.Sections などで返されるページリストに、そのページが含まれなくなります。 _build: # Whether to add it to any of the page collections. # # Note that the page can still be found with .Site.GetPage. # We extended this property from a boolean to an enum in Hugo 0.68.0. # Valid values are: # # - never: The page will not be included in any page collection. # - always (default): The page will be included in all page collections, # e.g. site.RegularPages, $page.Pages. # - local: The page will be included in any local page collection, # e.g. $page.RegularPages, $page.Pages. One use case for this # would be to create fully navigable, but headless content sections. list: always # Whether to render it. # # If always, the page will be treated as a published page, # holding its dedicated output files (index.html, etc…) and permalink. # We extended this property from a boolean to an enum in Hugo 0.76.0. # Valid values are: # # - never: The page will not be included in any page collection. # - always (default): The page will be rendered to disk and get a RelPermalink etc. # - link: The page will be not be rendered to disk, but will get a RelPermalink. render: always # Whether to publish its resources. # # These will still be published on demand, but enabling this can be useful # if the originals (e.g. images) are never used. # # - true: The Bundle&#39;s Resources will be published. # - false: Still publish Resources on demand (when a resource&#39;s .Permalink or # .RelPermalink is invoked from the templates) but will skip the others. publishResources: false 例えば、サイト内検索のページは特別な経路でのみリンクしたいので、「メニューツリー」や「子ページ一覧」などには表示しないようにしたいとします。 そのような場合は、該当記事の Markdown ファイルで次のようにフロントマターを設定すれば OK です。 content/search.md --- title: &#34;サイト内検索&#34; _build: list: never --- ネストされたプロパティは、次のように 1 行で記述することもできます。 --- title: &#34;サイト内検索&#34; _build: { list: never } --- この仕組みができるまでは、独自の nomenu プロパティなどを定義して対応していたのですが、リスト系のページから除外するのがとても簡単になりました。 一方で、サイトマップ・テンプレート などで .Data.Pages によるリスト出力しているところからも除外されてしまうので、そういった副作用には注意してください。"},{url:"/p/5fzgwdt/",title:"Hugo で JSON-LD 形式のパンくずリストを出力する（SEO 対策）",date:"2020-05-16T00:00:00+09:00",body:"Hugo で JSON-LD 形式のパンくずリストを出力する（SEO 対策） JSON-LD 形式の構造化データを HTML 内に含めておくと、Google の検索結果にページの階層構造が表示されるようになります。 この構造化データは、あくまで Google などの検索エンジンに記事の階層を伝えるためのもの であり、記事内に表示するためのパンくずリストではないことに注意してください。 画面表示用のパンくずリストを出力したいときは、下記の記事を参考にしてください。 参考: Hugo でパンくずリストを表示する パンくずリストのフォーマット JSON-LD 形式でパンくずリストを作成するときに、どのような内容で出力すればよいかは、 Google のパンくずリストの説明ページ に分かりやすく書かれています。 例えば、ある「記事ページ」が次のような階層で配置されているとします。 ホーム ＞ カテゴリA ＞ カテゴリB ＞ 記事ページ これを JSON-LD で表現するには、下記のようなコードを head 要素や body 要素の中に記述します。 特に理由がなければ、少しでもパフォーマンスを考慮して body 要素の最後に記述するのがよいでしょう。 &lt;script type=&#34;application/ld+json&#34;&gt; { &#34;@context&#34;: &#34;https://schema.org&#34;, &#34;@type&#34;: &#34;BreadcrumbList&#34;, &#34;itemListElement&#34;: [{ &#34;@type&#34;: &#34;ListItem&#34;, &#34;position&#34;: 1, &#34;name&#34;: &#34;サイト名&#34;, &#34;item&#34;: &#34;https://example.com/&#34; },{ &#34;@type&#34;: &#34;ListItem&#34;, &#34;position&#34;: 2, &#34;name&#34;: &#34;カテゴリA&#34;, &#34;item&#34;: &#34;https://example.com/category-a&#34; },{ &#34;@type&#34;: &#34;ListItem&#34;, &#34;position&#34;: 3, &#34;name&#34;: &#34;カテゴリB&#34;, &#34;item&#34;: &#34;https://example.com/category-b&#34; },{ &#34;@type&#34;: &#34;ListItem&#34;, &#34;position&#34;: 4, &#34;name&#34;: &#34;記事ページのタイトル&#34;, &#34;item&#34;: &#34;https://example.com/article-page&#34; }] } &lt;/script&gt; 重要なのは itemListElement プロパティで、この配列要素として各階層の内容を記述します。 とても単純なので説明するまでもないと思いますが、 name プロパティで各階層の名称、 item プロパティでその階層を示す URL を指定します。 position プロパティは 1、2、3 と順番に振っていけば OK です。 パンくずリストは記事の位置を論理的に階層化しますが、item プロパティで指定する URL は階層化されていなくてもよいところが柔軟性があってよいですね。 1 番目の要素にホームページのエントリ、最後の要素に記事ページ自体のエントリを配置するのが無駄なように感じるかもしれませんが、Google 検索の結果ではこのあたりを考慮して表示を最適化してくれるので、心配せずに全て含めておけば大丈夫です。 テンプレートで JSON-LD を出力する ここでは、Hugo のパーシャルテンプレートで、JSON-LD 形式のパンくずリストを出力できるようにします。 まず、ユーティリティ関数として、現在のページの階層構造を .Page の配列で取得するパーシャルテンプレートを用意します。 参考: ページの階層構造を取得する関数を作成する (get-hierarchy) layouts/partials/function/get-hierarchy.html {{ $hierarchy := slice . }} {{ if .Parent }} {{ $parentHierarchy := partial &#34;function/get-hierarchy&#34; .Parent }} {{ if $parentHierarchy }} {{ $hierarchy = $parentHierarchy | append $hierarchy }} {{ end }} {{ end }} {{ return $hierarchy }} 次のパーシャルテンプレートでは、上記の get-hierarchy ユーティリティが返す階層情報を使って、JSON-LD 形式のパンくずリストを出力します。 layouts/partials/breadcrumb-json.html {{ $hierarchy := partial &#34;function/get-hierarchy&#34; . }} &lt;script type=&#34;application/ld+json&#34;&gt; { &#34;@context&#34;: &#34;https://schema.org&#34;, &#34;@type&#34;: &#34;BreadcrumbList&#34;, &#34;itemListElement&#34;: [ {{- range $index, $page := $hierarchy }} {{- if gt $index 0 }},{{ end }} { &#34;@type&#34;: &#34;ListItem&#34;, &#34;position&#34;: {{ add $index 1 }}, &#34;name&#34;: {{ $page.LinkTitle }}, &#34;item&#34;: {{ $page.Permalink }} } {{- end }} ] } &lt;/script&gt; あとは、任意のレイアウト用テンプレートから、次のように呼び出せば、そこにパンくずリストが出力されます。 layouts/_default/baseof.html（抜粋） &lt;body&gt; ... 省略 ... {{ partial &#34;breadcrumb-json&#34; . }} &lt;/body&gt; JSON-LD の内容を検証する 出力された JSON-LD 形式のパンくずリストは、下記のサイトで検証することができます。 Google 構造化データ テストツール BreadcrumbList の項目でエラーが出ていないことを確認しましょう。"},{url:"/p/v9t62ux/",title:"Hugo でページの階層構造を取得する関数を作成する (get-hierarchy)",date:"2020-05-16T00:00:00+09:00",body:"Hugo でページの階層構造を取得する関数を作成する (get-hierarchy) 何を作るか？ Hugo の記事ページは、次のような感じで、セクション機能を使って階層化することができます。 ホーム ＞ セクション1 ＞ セクション2 ＞ ページタイトル ここでは、上記のような階層構造をスライス（配列）で取得する 関数を作成 してみます。 ページの階層構造を取得できると、パンくずリストなどを簡単に出力できるようになります。 階層構造を取得する関数 関数はパーシャルテンプレートの形で作るので、layouts/partials の下に .html ファイルを作成します。 ここでは、関数であることを明確にするために、さらに function という名前のディレクトリを作ってその下に格納することにします。 関数名（テンプレート名）は get-hierarchy とします。 layouts/partials/function/get-hierarchy.html {{ $hierarchy := slice . }} {{ if .Parent }} {{ $parentHierarchy := partial &#34;function/get-hierarchy&#34; .Parent }} {{ if $parentHierarchy }} {{ $hierarchy = $parentHierarchy | append $hierarchy }} {{ end }} {{ end }} {{ return $hierarchy }} この関数は、任意のテンプレートファイルから次のように呼び出します。 {{ $hierarchy := partial &#34;function/get-hierarchy&#34; . }} $hierarchy 変数には、ホームページからカレントページまでの Page 変数の配列データ が格納されます。 例えば、次のようにすれば、ページ階層を番号付きでリンク表示できます。 {{ $hierarchy := partial &#34;function/get-hierarchy&#34; . }} {{- range $index, $page := $hierarchy }} {{ $index }}: &lt;a href=&#34;{{ $page.RelPermalink}}&#34;&gt;{{ $page.Title }}&lt;/a&gt;&lt;br&gt; {{- end }} 表示結果のイメージ 0: ホーム 1: セクション1 2: セクション2 3: ページタイトル この get-hierarchy 関数を使用すれば、パンくずリストのようなものも簡単に表示できるはずです。 参考: パンくずリストを表示する ← こちらの記事では関数を使わずに出力してますが"},{url:"/p/2hbwijq/",title:"Kotlinメモ: VS Code で Kotlin の開発環境を構築する",date:"2020-05-12T00:00:00+09:00",body:"Kotlinメモ: VS Code で Kotlin の開発環境を構築する Kotlin 環境の構築 kotlinc のインストール VS Code 自体は Kotlin コードのコンパイル機能を持っていないので、kotlinc コマンドはあらかじめインストールしておく必要があります。 Kotlin をインストールする コマンドラインから次のように kotlinc コマンドを実行できるようになっていれば OK です。 $ kotlinc -version info: kotlinc-jvm 1.3.71 (JRE 1.8.0_212-release-1586-b04) Kotlin Language プラグインのインストール VS Code の Extensions タブから kotlin で検索して、 Kotlin Language プラグインをインストールします。 このプラグインにより、Kotlin コードのシンタックスハイライトなどが効くようになります。 Code Runner プラグインのインストール VS Code の Extensions タブから code で検索して、 Code Runner プラグインをインストールします。 このプラグインにより、ショートカットキー一発で Kotlin コードを実行できるようになります。 Kotlin プログラムを実行してみる VS Code への各種プラグインのインストールが済んだら、簡単な Kotlin プログラムを記述して実行してみます。 コードの作成 まず、VS Code を適当な空のディレクトリを起点にして起動します。 $ mkdir sample-kotlin $ code sample-kotlin Ctrl + N キーでファイルを新規作成し、次のように入力して Ctrl + S で保存します。 ファイルの拡張子は .kt にしてください。 main.kt fun main() { println(&#34;Hello World!&#34;) } 実行 後は、下記のいずれかの方法でプログラムを実行できます。 Ctrl + Alt + N ショートカットキーを押す エディタ上で右クリックして Run Code を選択 F1 キーでコマンドパレットを開いて Run Code を実行 OUTPUT ウィンドウに下記のように出力されれば成功です。 [Running] cd &#34;d:\\sample-kotlin\\&#34; &amp;&amp; kotlinc main.kt -include-runtime -d main.jar &amp;&amp; java -jar main.jar Hello World! [Done] exited with code=0 in 6.605 seconds ビルドしてから実行しているので結構時間がかかりますね。。。 ちなみに、出力を見ると分かるのですが、内部的には下記のようなコマンドが実行されています。 cd &lt;作業ディレクトリ&gt; &amp;&amp; kotlinc main.kt -include-runtime -d main.jar &amp;&amp; java -jar main.jar kotlinc コマンドが見つからないというエラーが出るとき VS Code を起動した状態で kotlinc コマンドをインストールした場合は、環境変数 PATH の設定が反映されていない可能性があります。 その場合は、VS Code を再起動すれば直ります。"},{url:"/p/9tg2m7q/",title:"Hugo のショートコードをエスケープ処理してそのまま表示する",date:"2020-05-07T00:00:00+09:00",body:"Hugo のショートコードをエスケープ処理してそのまま表示する Hugo で作成した記事（.md ファイル）内でショートコードの使い方を説明するときなど、ショートコードのタグそのものを文章中に表示させたいことがあります。 そのまま記述するとショートコードとして処理されてしまうので、次のようにエスケープ処理して記述する必要があります。 Markdown ファイル内での書き方 出力結果 {{&lt;/* my-shortcode */&gt;}} {{&lt; my-shortcode &gt;}} {{%/* my-shortcode */%}} {{% my-shortcode %}} ショートコード名の部分 (my-shortcode) を C/C++ や Java のコメント風に囲めば OK です。 コードブロックの中でも同様にエスケープ処理できます。"},{url:"/p/m2n8rbu/",title:"Hugo の記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout)",date:"2020-05-04T00:00:00+09:00",body:"Hugo の記事ファイルのフロントマターで使用するレイアウトを制御する (type, layout) フロントマターでのレイアウト指定 Hugo では、記事ファイル (.md) のレンダリングにどのレイアウトファイルを使用するかは、content ディレクトリ以下にどのようなパスで .md ファイルを配置したかによって決まります。 ほとんどのページではこれで十分なのですが、あるページだけ特殊なレイアウトを使用したい ことがあります。 例えば、検索ページや、新着記事リストのページなどです。 このような場合は、Markdown ファイルのフロントマターで、type プロパティや layout プロパティを指定することで、使用するレイアウトファイルを制御することができます。 type プロパティ コンテントタイプを指定します。デフォルトでは、content ディレクトリ以下のディレクトリ名が使われます（参考: Content Types | Hugo）。 layout プロパティ レイアウト名を指定します。デフォルトでは、ページの種類によって section.html（セクションテンプレート）や single.html（シングルページテンプレート）が使用されます。 これらの値の組み合わせによって、そのページをレンダリングするときに使用するレイアウトファイル（テンプレート）が次のように決まります。 layouts/&lt;タイプ名&gt;/&lt;レイアウト名&gt;.html 実際には、すべてのコンテントタイプで共通のレイアウトファイルを使えばよいことが多く、そのようなケースでは layouts/_default/single.html といったレイアウトファイルを配置します（タイプ名として _default 指定されたかのように振る舞います）。 複数のレイアウトファイルが存在する場合に、どのレイアウトファイルが選択されるかのルールは下記を参照してください。 参考: レイアウト用のテンプレートの種類を理解する 通常、コンテントタイプとレイアウトファイル名は、ディレクトリ構造と Markdown ファイル名によって決まるようになっています。 例えば、次のような感じです。 Markdown フィイル名 コンテントタイプ レイアウトファイル content/foo/_index.md foo section.html や list.html content/foo/page1.md foo single.html content/bar/page2.md bar single.html content/foo/bar/page3.md foo single.html フロントマターで type と layout を指定することにより、これらのルールを無視して、強制的に使用するレイアウトファイルを変更することができます。 例を見た方が分かりやすいので、ここでは、「新着一覧」のページをサンプルとして作ってみます。 ☝️ ワンポイント 記事の一覧を表示するくらいであれば、通常はショートコードで出力してしまった方が簡単です。 ここでは、特定のページだけレイアウトを大きく変更する必要があると想定しています 使用するレイアウトファイルを指定する例 下記のテンプレートでは、更新日時が新しい順に、5 件分の記事をリスト表示しています。 このレイアウトは、「新着一覧」のページでしか使わない 特殊なレイアウト なので、レイアウトファイル自体も layouts/special/latest.html という特殊なパスに作成することにします。 このレイアウトファイルは、コンテントタイプとして special、レイアウト名として latest が設定された記事ファイルに適用されます。 layouts/special/latest.html（抜粋） &lt;ul&gt; {{- range first 5 .Site.RegularPages.ByLastmod.Reverse }} &lt;li&gt; &lt;b&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/b&gt; &lt;time&gt;{{ .Date.Format &#34;2006-01-02&#34; }}&lt;/time&gt; &lt;/li&gt; {{- end }} &lt;/ul&gt; 次に、記事一覧のページを出力するための Markdown ファイルを作成します。 コンテントタイプとレイアウト名はフロントマターで指定するので、Markdown ファイルはどのようなパスに配置しても構いません。 ここでは、content ディレクトリ直下に配置することにします。 content/latest.html --- title: &#34;新着一覧&#34; type: &#34;special&#34; layout: &#34;latest&#34; --- （本文は空っぽで OK） 本文はレイアウトファイルの方で出力される内容だけでいいので、Markdown ファイルにはフロントマターだけを記述します。 コンテントタイプとして special、レイアウト名として latest を指定しているので、layouts/special/latest.html というパスに配置したレイアウトファイルが使用されることになります。 もちろん、記事ファイルを配置するパスによって、使用するレイアウトファイルをうまく制御するのでも OK です。 例えば、content/latest/_index.md というパスに Markdown ファイルを配置すれば、フロントマターで type や layout を指定しなくても、レイアウトファイルとして layouts/latest/section.html（あるいは list.html）が使用されます。"},{url:"/p/q3y3jhr/",title:"Kotlinメモ: 列挙型 (enum) の値をループ処理する (values)",date:"2020-04-27T00:00:00+09:00",body:"Kotlinメモ: 列挙型 (enum) の値をループ処理する (values) 列挙型 (enum) クラスに自動的に定義される values() メソッドを使用すると、全ての値を含む配列 (Array&lt;列挙型&gt;) を取得することができます。 この配列を for-in ループで処理すれば、列挙型の値を 1 つずつ取り出せます。 enum class Fruits { APPLE, BANANA, GRAPE } fun main() { for (x: Fruits in Fruits.values()) { println(x) } } 次のように forEach でループ処理することもできますね。 Fruits.values().forEach { println(it) } Fruits.values().forEach(::println)"},{url:"/p/qr4eox7/",title:"Hugo でサーチエンジン用に sitemap.xml や robots.txt ファイルを配置する",date:"2020-04-26T00:00:00+09:00",body:"Hugo でサーチエンジン用に sitemap.xml や robots.txt ファイルを配置する サーチエンジンに対して、インデックス登録させたいページを伝えるには、Web サイトに sitemap.xml や robots.txt というファイルを配置します。 Google の検索結果に影響するため、正しく理解して配置しましょう。 sitemap.xml と robots.txt の概要 Web サイトのルートに sitemap.xml や robots.txt を置くと、下記のようなヒント情報を Google などの検索エンジンに伝えることができます。 sitemap.xml &hellip; サイト内のページ一覧情報を記述します。検索エンジンは、サイト全体をクロールしなくても、この情報でページのインデックス情報を作成できるようになります。ページごとに更新日時 (YYYY-MM-DD) や優先度 (0.0〜1.0) を指定できます。 robots.txt &hellip; クロールしなくてもよいディレクトリやファイルを指定します。上記の sitemap.xml の URL を指定することもできます。 もちろん、これらのファイルを用意したところで、どこまで反映されるかは検索エンジン側の実装によりますが、SEO 対策として少しでもヒントとなる情報を与えておくのが望ましいでしょう。 sitemap.xml を作成する sitemap.xml ファイルには、Google などの検索エンジンにインデックス登録してもらいたいページの一覧を記述します。 sitemap.xml のデフォルト出力 Hugo はデフォルトで Web サイトのルートに、Sitemap protocol に基づいた sitemap.xml ファイルを出力するようになっています。 下記はデフォルト設定で出力される sitemap.xml の例です。 sitemap.xml &lt;urlset xmlns=&#34;http://www.sitemaps.org/schemas/sitemap/0.9&#34; xmlns:xhtml=&#34;http://www.w3.org/1999/xhtml&#34;&gt; &lt;url&gt; &lt;loc&gt;https://example.com/page1/&lt;/loc&gt; &lt;lastmod&gt;2020-04-26T00:00:00+00:00&lt;/lastmod&gt; &lt;/url&gt; &lt;url&gt; &lt;loc&gt;https://example.com/page2/&lt;/loc&gt; &lt;lastmod&gt;2020-04-25T00:00:00+00:00&lt;/lastmod&gt; &lt;/url&gt; &lt;/urlset&gt; この出力は、Hugo にデフォルトで組み込まれている sitemap.xml テンプレートによって生成されています。 デフォルトのテンプレート定義は下記を見ると分かります。 Hugo’s sitemap.xml gohugoio/hugo/tpl/tplimpl/embedded/templates/_default/sitemap.xml (GitHub) このままで問題なければ、特に何も設定する必要はありませんが、出力内容をカスタマイズしたいときは、次のように sitemap.xml 用のテンプレートファイルを生成する必要があります。 Hugo はデフォルトですべてのページを sitemap.xml にリスト化しようとするので、Google などの検索結果に載せたくないページがある場合は、sitemap.xml のカスタマイズが必要です。 sitemap.xml のカスタマイズ 下記のいずれかのテンプレートファイルを作成することで、Web サイトのルートディレクトリに出力される sitemap.xml の内容をカスタマイズできます。 layouts/sitemap.xml layouts/_default/sitemap.xml ここでは、下記のようにカスタマイズしてみます。 タクソノミーリスト（あるタグのページ一覧）のページを出力しない（/tags/* や /categories/* などをリストに載せない） 特定の URL 以下のページを出力しない (URL が /search/ で始まるページをリストに載せない） Markdown ファイルのフロントマターで noindex: true と記述されていたら出力しない セクションページの優先度を上げる（デフォルトで priority=0.5 のところを priority=1.0 とする。ただしフロントマターでの指定があればそちらを優先） layouts/sitemap.xml &lt;urlset xmlns=&#34;http://www.sitemaps.org/schemas/sitemap/0.9&#34; xmlns:xhtml=&#34;http://www.w3.org/1999/xhtml&#34;&gt; {{- range .Data.Pages }} {{- if ne .Kind &#34;term&#34; }} {{- if not (hasPrefix .RelPermalink &#34;/search/&#34;) }} {{- if ne .Params.noindex true }} &lt;url&gt; &lt;loc&gt;{{ .Permalink }}&lt;/loc&gt; {{- if not .Lastmod.IsZero }} &lt;lastmod&gt;{{ .Lastmod.Format &#34;2006-01-02&#34; }}&lt;/lastmod&gt; {{- end }} {{- with .Sitemap.ChangeFreq }} &lt;changefreq&gt;{{ . }}&lt;/changefreq&gt; {{- end }} {{- if ge .Sitemap.Priority 0.0 }} &lt;priority&gt;{{ .Sitemap.Priority }}&lt;/priority&gt; {{- else if eq .Kind &#34;section&#34; }} &lt;priority&gt;1.0&lt;/priority&gt; {{- end }} &lt;/url&gt; {{- end }} {{- end }} {{- end }} {{- end }} &lt;/urlset&gt; ここでは、ページ変数の .Kind の値を見ることで、セクションやタクソノミーリスト (/tags/*) のページであるかどうかを判断しています。 このあたりのページ変数がどのような値を取るかに関しては、下記の記事を参考にしてください。 参考: 各種ページにおいて .Kind や .IsPage、.IsNode の値がどうなるかの一覧 ｜ まくまく Hugo/Go ノート 各ページのフロントマターでサイトマップ出力を制御する ページごとにサイトマップ出力を制御したい場合は、フロントマターのプロパティを設定します。 サイトマップに列挙されないようにする サイトマップには列挙したくない特殊なページがあるかもしれません。 簡単な方法として、Hugo 組み込みの _build プロパティで、list: never を指定してしまう方法があります（参考: Hugo でページリスト（記事一覧）に列挙されないページを作る）。 このフラグを設定すると、Hugo の .Pages や .RegularPages などのコレクションに含まれなくなるので、結果的に sitemap.xml にも列挙されなくなります（サイトマップテンプレート内で .Data.Pages をループ処理していたことに着目してください）。 content/page.md（Hugo の _build プロパティで出力抑制） --- title: &#34;ページタイトル&#34; date: &#34;2023-05-31&#34; _build: { list: never } --- 別の方法として、独自の noindex プロパティを定義してしまう方法もあります。 .Pages コレクションなどには含めたいけれど、サイトマップには列挙したくないといった事情があれば、このような独自プロパティを使って制御します。 前述のカスタマイズされた sitemap.xml 用テンプレートでは、この noindex プロパティがセットされていたら、そのページの URL を列挙しないようにしています。 content/page.md（独自の noindex プロパティで出力抑制） --- title: &#34;ページタイトル&#34; date: &#34;2023-05-31&#34; noindex: true --- ちなみに、独自の noindex プロパティを導入するのであれば、それと連動させて HTML の meta 要素を出力するようにしておくのがよいでしょう（noindex 用の meta 要素については後述）。 layouts/_default/baseof.html（ベーステンプレートの抜粋） &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; {{- if .Params.noindex }} &lt;meta name=&#34;robots&#34; content=&#34;noindex&#34; /&gt; {{- end }} サイトマップに出力される情報を調整する (changefreq, priority) Hugo 組み込みの sitemap プロパティを設定することで、sitemap.xml に出力する &lt;changefreq&gt; や &lt;priority&gt; 要素の値を制御することができます。 これらの値は、前述のテンプレート内で .Sitemap.ChangeFreq、.Sitemap.Priority といった変数で参照しています。 content/page.md（ページのプライオリティなどを調整） --- title: &#34;ページタイトル&#34; date: &#34;2020-04-26&#34; sitemap: changefreq: monthly priority: 0.8 --- sitemap.xml の出力先パスを変更する sitemap.xml はデフォルトで Web サイトのルートに出力されますが、Hugo の設定ファイルで出力パスを変更することができます。 hugo.toml [sitemap] filename = &#34;assets/my-sitemap.xml&#34; robots.txt によるクロールの抑制 Web サイトのルートに robots.txt を配置しておくと、検索エンジンに対して、そのサイト内でクロールされたくないディレクトリやファイルを知らせることができます（参考: robotstxt.org）。 また、上記で作成した sitemap.xml の URL を知らせることもできます。 robots.txt を出力するための設定 静的なファイルとして robots.txt を作成するのであれば、単純に Hugo プロジェクト内に /static/robots.txt というファイルを配置しておけば OK です（robots.txt が出力ディレクトリのルートにコピーされます）。 テンプレート機能を使って、動的に robots.txt を生成したいのであれば、設定ファイルで下記のように指定しておく必要があります。 hugo.toml enableRobotsTXT = true この設定により、下記のテンプレートファイルを使って robots.txt を生成してくれるようになります。 /layouts/robots.txt /themes/&lt;THEME&gt;/layouts/robots.txt 下記のようなテンプレートを作成すると、すべての種類のクローラーに対して sitemap.xml の URL を知らせるための robots.txt を生成できます。 /layouts/robots.txt User-agent: * Sitemap: {{ .Site.BaseURL }}sitemap.xml sitemap.xml のパスは、FQDN（完全修飾 URL）で指定しなければいけないので、上記のようにテンプレート内で .Site.BaseURL 変数を使って完全な URL を構築しています。 robots.txt の Disallow ディレクティブはあまり使わない よくある robots.txt の例として、Disallow ディレクティブを使ったクロールの防止方法が示されていたりしますが、実際に Disallow ディレクティブが必要になるケースはそれほど多くありません（それよりは後述の meta 要素を使う方が目的と合っていることが多いです）。 特に、JavaScript や CSS、画像ファイルなどは、検索エンジンがページ内容を正しく処理するために必要なので、Disallow 指定してクロール対象から外してはいけません。 Google の検索結果から除外する（meta 要素の noindex 設定） robots.txt の Disallow ではなく meta 要素の noindex を使う 特定のページを Google の検索結果に表示されないようにするには、HTML の head 要素内に下記のような meta 要素を記述するのが正解みたいです。 &lt;meta name=&#34;robots&#34; content=&#34;noindex&#34; /&gt; robots.txt に下記のように指定すれば、/search/ 以下をクロールしないように知らせることにはなるのですが、すでにインデックスされてしまったページは検索結果に表示され続けることになってしまいます。 robots.txt User-agent: * Disallow: /search/ また、クロールを防いだとしても、他のページからリンクされている場合はインデックスされてしまう可能性があります。 よって、検索エンジンに特定のページがインデックスされることを防ぐには、 meta 要素で noindex を指定する robots.txt の Disallow は指定しない とするのがよいようです。 参考: noindex を使用して検索インデックス登録をブロックする - Search Console ヘルプ 重要: noindex ディレクティブが有効に機能するようにするために、robots.txt ファイルでページをブロックしないでください。ページが robots.txt ファイルでブロックされると、クローラは noindex ディレクティブを認識しません。そのため、たとえば他のページからリンクされていると、ページは検索結果に引き続き表示される可能性があります。 （コラム）Google Search Console の sitemap.xml に関するエラー sitemap.xml にリストアップされているにも関わらず、HTML ファイルの &lt;meta name=&quot;robots&quot; content=&quot;noindex&quot;&gt; でインデックス登録を抑制しているようなページがあると、Google Search Console にエラーが表示されることがあります。 図: 送信された URL に noindex タグが追加されています これは、「sitemap.xml でインデックス登録しろと指定されているけど、実際にページの内容を見ると meta 要素で noindex 指定されてるのでインデックス登録しないよ。それでいいの？」という意味の警告です。 インデックス登録されたくないページは、sitemap.xml にもリストアップされないように整合性を取りましょう。"},{url:"/p/88e7tiz/",title:"Hugo のテンプレートの中で絵文字を使用する (emojify)",date:"2020-04-13T00:00:00+09:00",body:"Hugo のテンプレートの中で絵文字を使用する (emojify) emojify 関数の概要 Hugo のテンプレートファイルの中で emojify 関数 を使用すると、GitHub や Slack などで使える有名どころの絵文字 (emoticons) を出力することができます。 使えるアイコンのリストは下記サイトで確認できます。 🎁 Emoji cheat sheet for GitHub, Basecamp, Slack &amp; more 例えば、:smile: アイコンを表示したければ、任意のテンプレートファイルの中で次のように記述します。 {{ emojify &#34;:smile:&#34; }} emojify 関数の使用例 下記の例では、Hugo をサーバーモードで起動しているときに、ローカルファイルのパスをアイコン付きで表示します。 layouts/_default/single.html（抜粋） {{ if hugo.IsServer }} {{ emojify &#34;:memo:&#34; }}{{ .File.Filename }} {{ end }} 図: 表示結果"},{url:"/p/4anjern/",title:"Hugo のパーシャルテンプレートから値を返す（関数化）(return)",date:"2020-04-06T00:00:00+09:00",body:"Hugo のパーシャルテンプレートから値を返す（関数化）(return) パーシャルテンプレートを関数として使用する Hugo v.0.55 以降のパーシャルテンプレートでは、テキストを出力する代わりに、値を return できるようになっています（参考: Returning a value from a Partial ｜ Hugo）。 この機能をうまく使うと、テンプレート内の共通処理をくくり出して、コードをスッキリさせることができます（通常のプログラミング言語の関数と同じイメージ）。 例えば、次の my-add-100 パーシャルテンプレートは、引数で受け取った値に 100 を足した値を返します。 パーシャルテンプレートの呼び出し時に渡された引数は、コンテキスト (.) として参照できます。 layouts/partials/functions/my-add-100.html {{ $ret := add 100 . }} {{ return $ret }} ここでは、関数風に呼び出せるパーシャルテンプレートであることを示すために、functions というディレクトリ以下に HTML ファイルを保存していますが、このあたりは自由です。 呼び出し側のテンプレートからは、次のように関数のように呼び出して、戻り値を受け取ることができます。 layouts/_default/single.html（抜粋） {{ $ret := partial &#34;functions/my-add-100&#34; 50 }} 戻り値: &lt;b&gt;{{ $ret }}&lt;/b&gt; レンダリング結果は次のようになります。 戻り値: &lt;b&gt;150&lt;/b&gt; パーシャルテンプレートに複数の値（引数）を渡す パーシャルテンプレートに複数の値を渡すには、辞書オブジェクト（キー＆バリュー）の形で値を渡します。 次のパーシャンテンプレート (my-add) は、2 つの数値を受け取り、それらを足し合わせた結果を返します。 ここでは、辞書のキー名として val1 と val2 を使用することを想定していますが、キー名は何でも構いません。 下記のように、パーシャルテンプレートの先頭で辞書キーを参照して変数に代入するようにしておくと、このパーシャルテンプレートがどのような辞書キーを期待しているのかが分かりやすくなります。 layouts/partials/functions/my-add.html {{ $v1 := .val1 }} {{ $v2 := .val2 }} {{ return (add $v1 $v2) }} このパーシャルテンプレートを呼び出すには、次のように dict 関数を使って辞書オブジェクトを作成して引数として渡します。 ここでは、val1 に 100、val2 に 200 という値を入れて渡しているので、結果として 300 という値が返ってきます。 テンプレートからの呼び出し例 {{- $ret := partial &#34;functions/my-add&#34; (dict &#34;val1&#34; 100 &#34;val2&#34; 200) }} 戻り値: &lt;b&gt;{{ $ret }}&lt;/b&gt; レンダリング結果 戻り値: &lt;b&gt;300&lt;/b&gt; ☝️ 引数は 1 つしか渡せない partial 関数の呼び出し時に指定した第 2 引数は、パーシャルテンプレート側のコンテキスト (.) として参照できるようになるのですが、次のように複数の値を単純に並べて渡すことはできません。 間違った呼び出し方 {{ $ret := partial &#34;functions/my-add&#34; 100 200 }} なぜなら、第 3 引数の値 (200) は、パーシャルテンプレート呼び出しのキャッシュ用のキーとして使われるという仕様になっているからです。 詳しくは、公式サイトの partialCached 関数 の説明を参照してください。 パーシャルテンプレートからリストを返す パーシャルテンプレートの return では、様々な型のオブジェクトを返すことができます。 例えば次の get-colors パーシャルテンプレートでは、slice で作成したリストを返しています。 layouts/partials/functions/get-colors.html {{ $ret := slice &#34;Blue&#34; &#34;Red&#34; &#34;Yellow&#34; }} {{ $ret = $ret | append &#34;Black&#34; &#34;White&#34; }} {{ return $ret }} 呼び出し元のテンプレートファイルでは、get-colors が返したリストを range などでループ処理します。 layouts/_default/single.html &lt;ul&gt; {{- range partial &#34;functions/get-colors&#34; . }} &lt;li&gt;{{ . }} {{- end }} &lt;/ul&gt; 実行結果 &lt;ul&gt; &lt;li&gt;Blue &lt;li&gt;Red &lt;li&gt;Yellow &lt;li&gt;Black &lt;li&gt;White &lt;/ul&gt; インラインパーシャルテンプレート パーシャルテンプレートは、通常 layouts/partils ディレクトリ以下に HTML ファイルとして作成しますが、テンプレート（ショートコードやレイアウトファイル）の中で、define 関数を使って、インラインに定義してしまうこともできます（参考: Inline Partials）。 特定のショートコード内でしか使わないような関数を定義したいときに利用できるかもしれません。 layouts/shortcodes/my-shortcode.html {{/* インラインパーシャルを定義する （partials プレフィックスを付ける） */}} {{ define &#34;partials/functions/inline-add&#34; }} {{ $v1 := .val1 }} {{ $v2 := .val2 }} {{ return (add $v1 $v2) }} {{ end }} {{/* 上記は同じテンプレート内から呼び出せる （partials プレフィックスは省略できる） */}} {{- $ret := partial &#34;functions/inline-add&#34; (dict &#34;val1&#34; 100 &#34;val2&#34; 200) }} 戻り値 = {{ $ret }} define 関数で、インラインパーシャルテンプレートを定義する時は、プレフィックスとして partials/ を付けることに注意してください。 これにより、partial 関数による呼び出しが可能になります。 partials/ プレフィックスを付けずに定義した場合は、通常の部分テンプレートとして template 関数で呼び出すことができるようになるのですが、その方法だと戻り値を返すことができません（戻り値を返すことができるのは、パーシャルテンプレートを partial 関数で呼び出したときのみです）。 パーシャルテンプレートの名前空間はグローバルに共有されるため、名前のコンフリクトには注意してください。 同じ名前のテンプレートが定義されている場合は、Hugo ビルド時に次のようなエラーになります。 multiple definition of template &#34;partials/functions/inline-add&#34;"},{url:"/p/kmv4bjr/",title:"Hugo でページ内リンク（アンカー）を張る",date:"2020-04-05T00:00:00+09:00",body:"Hugo でページ内リンク（アンカー）を張る ページ内リンクを張ることで、ワンクリックでページ内の任意の位置へジャンプできるようになります。 ヘッダ要素 (h2, h3, h4) へのジャンプ 自動的に割り振られる id 属性を使用する Hugo はデフォルトで、ヘッダ要素（h2 などの見出し）に id 属性を付けてくれます。 例えば、次のようなヘッダがあったとすると、 Link to me ---- 生成される h2 要素には、次のように自動的に id 属性が設定されます（スペースは - に置き換えられます）。 &lt;h2 id=&#34;link-to-me&#34;&gt;Link to me&lt;/h2&gt; よって、このヘッダ要素には、次のような内部リンクを張ることができます。 [Link to me へジャンプ](#link-to-me) もちろん、他のページのヘッダ要素へのリンクを張ることもできます。 [Link to me へジャンプ](/posts/pagename/#link-to-me) ヘッダ要素に独自の id 属性を設定する ヘッダ要素に自動的に割り振られる id 属性を使用することの欠点は、アルファベットや数字以外の文字が削除されてしまうことです。 また、見出しを変更すると id 属性の値も変わってしまうので、リンク切れのリスクも高まります。 例えば、次のような見出しがあったとすると、 OGP とは ---- 出力される HTML は次のようになります。 &lt;h2 id=&#34;ogp-&#34;&gt;OGP とは&lt;/h2&gt; 日本語の「とは」の部分が無視され、分かりにくい ID になってしまっています。 このような不完全な ID が割り当てられるのが嫌な場合は、次のようにして独自の ID を設定することができます。 OGP とは {#what-is-ogp} ---- 出力される HTML は次のようになります。 &lt;h2 id=&#34;what-is-ogp&#34;&gt;OGP とは&lt;/h2&gt; これで、次のように自信を持って内部リンクを張ることができます。 詳細は [OGP の説明](#what-is-ogp) を参照してください。 任意の位置にアンカーを設定するショートコード 通常は、前述のようなヘッダ要素への内部リンクを使うだけで十分ですが、任意の位置に内部リンクを張りたいことがあるかもしれません。 次の anchor ショートコードは、id 属性を持つ、空っぽのアンカータグを出力します（ちなみに、id 属性の代わりに name 属性を設定しても同様の振る舞いをしますが、HTML5 では id 属性の方を使用すべきとされています）。 layouts/shortcodes/anchor.html &lt;a id=&#34;{{ .Get 0 }}&#34;&gt;&lt;/a&gt; Markdown ファイルの中で、アンカーを設定したい位置（ジャンプ先）で次のようにショートコードを呼び出します。 content/posts/sample.md {{&lt; anchor &#34;what-is-ogp&#34; &gt;}} ここに OGP の説明を記述。 ここにジャンプしてきたい。 ここにジャンプするためのリンクを張るには次のように記述します。 詳細は [OGP の説明](#what-is-ogp) を参照してください。"},{url:"/p/c9kmay4/",title:"Vim で <Leader> キーを使ったキーコンビネーションを定義する (mapleader)",date:"2020-04-04T00:00:00+09:00",body:"Vim で <Leader> キーを使ったキーコンビネーションを定義する (mapleader) Vim の Leader キー は、キーマッピングを定義するときに使用可能なプレフィックスキーです。 Leader キーとは 例えば、.vimrc で次のようなキーマップ設定があったとします。 .vimrc（Leader キーの使用例） nmap &lt;Leader&gt;a :echo &#34;Hello&#34;&lt;CR&gt; nmap &lt;Leader&gt;b :echo &#34;World&#34;&lt;CR&gt; これは、Leader キーに続けて a キーや b キーを入力することで、Hello や World と表示するキーコンビネーションを定義しています。 つまり、Leader キーはキーコンビネーションのためのプレフィックスキー です（実際には任意の位置で使えます）。 Leader キーには、デフォルトでバックスラッシュ (\\) が割り当てられているため、上記の設定を行った場合は、\\a と入力することで Hello と表示されることになります。 次のように直接バックスラッシュキー (&lt;Bslash&gt;) を使って定義するのとは何が違うのでしょうか？ .vimrc nmap &lt;Bslash&gt;a :echo &#34;Hello&#34;&lt;CR&gt; nmap &lt;Bslash&gt;b :echo &#34;World&#34;&lt;CR&gt; Leader キーを使ったキーマッピングには、次のような利点があります。 Leader キーは単なるプレフィックキーだということを強調できる（特に自分の .vimrc を公開するとき） Leader キーだけを変更したくなったときに、まとめて置き換えられる（Leader キーは任意のキーに設定できます） 他のユーザーの .vimrc 設定を使いまわしやすい（自分の好きな Leader キーで使える） Plugin の中でキーマッピングを定義するときに Leader キーを使うことで、ユーザーによるキー設定の余地を残す Leader キーを設定する (mapleader) Vim の場合 Leader キーを任意のキーに設定するには、次のように g:mapleader グローバル変数を設定します。 デフォルトではバックスラッシュキーが使用されますが、決して押しやすいキーではないので、スペースキーやカンマを Leader キーとして使用する人が多いようです。 ~/.vimrc &#34; Leader キーをスペースキーに変更 let g:mapleader = &#34;\\&lt;Space&gt;&#34; &#34; Leader キーをカンマに変更 let g:mapleader = &#34;,&#34; スペースキーを表現するときは、&quot;\\&lt;Space&gt;&quot; と記述することに注意してください。 同様に、CTRL-W という入力は &quot;\\&lt;C-W&gt;&quot; と記述します（参考: :help expr-quote, :help key-notation）。 g:mapleader 変数は、nmap や nnoremap コマンドなどで &lt;Leader&gt; を参照する前に定義しておく必要があります。 mapleader 変数を設定する前に &lt;Leader&gt; を参照すると、デフォルトのバックスラッシュキーに置き換えられてしまいます。 ☝️ スペースキーのデフォルトの振る舞い ノーマルモードのスペースキーには、デフォルトでは L キーと同じ振る舞い（カーソルを右へ移動させる）が割り当てられています。 Leader キーをスペースキーに割り当てた場合でも、スペースキーを押してから 1 秒間放置することで、このデフォルトの振る舞いを実行することができます。 このあたりの振る舞いは、timeout、ttimeout、timeoutlen などのオプションで調整できます。 Neovim の場合 ~/.config/nvim/init.lua -- Leader キーをスペースキーに変更 vim.g.mapleader = &#34; &#34; Leader キーを使ったキーマップの例 ~/.vimrc (Vim) &#34; Leader キーをスペースキーに変更 （注: &lt;Leader&gt; を参照する前に設定すること） let g:mapleader = &#34;\\&lt;Space&gt;&#34; &#34; タブの切り替え nnoremap &lt;Leader&gt;h :tabprev&lt;CR&gt; nnoremap &lt;Leader&gt;l :tabnext&lt;CR&gt; &#34; NERDTree 用のキーマップ nnoremap &lt;Leader&gt;nt :NERDTreeToggle&lt;CR&gt; nnoremap &lt;Leader&gt;nf :NERDTreeFind&lt;CR&gt; ~/.config/nvim/init.lua (Neovim) -- Leader キーをスペースキーに変更 （注: &lt;Leader&gt; を参照する前に設定すること） vim.g.mapleader = &#34; &#34; -- タブの切り替え vim.keymap.set(&#34;n&#34;, &#34;&lt;Leader&gt;h&#34;, &#34;:tabprev&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;Leader&gt;l&#34;, &#34;:tabnext&lt;CR&gt;&#34;) &lt;Leader&gt; は小文字で &lt;leader&gt; と記述することもできます。 Leader キーにどのキーが設定されているか調べる Leader キーの現在の割り当てを調べるには次のように実行します。 Leader キーの割り当てを表示 :echo g:mapleader Leader キーにスペースキーが割り当てられている場合は、空白文字が出力されるので、実際には何も表示されていないように見えるので注意してください。 何も設定されていない場合（デフォルトでバックスラッシュ \\ が割り当てられている状態）は、次のようなエラー表示になります。 E121: 未定義の変数です: g:mapleader E121: Undefined variable: g:mapleader おまけ LocalLeader キー &lt;Leader&gt; とは別に、バッファローカルな Leader キーとして参照可能な &lt;LocalLeader&gt; が用意されています。 &lt;LocalLeader&gt; 用のキーは、b:maplocalleader 変数で設定します。 &#34; LocalLeader キーをカンマに変更 let b:maplocalleader = &#34;,&#34; &#34; バッファローカルなキーマップ nnoremap &lt;buffer&gt; &lt;LocalLeader&gt;h :tabprev&lt;CR&gt; nnoremap &lt;buffer&gt; &lt;LocalLeader&gt;l :tabnext&lt;CR&gt; VS Code での Leader キー設定 VS Code (Visual Studio Code) の Vim プラグインでも、Leader キーの設定ができます。 settings.json（VS Code の設定ファイル抜粋） { /* * Vim 拡張用の設定。 */ &#34;vim.leader&#34;: &#34;&lt;Space&gt;&#34;, // Leader キーとしてスペースキーを使う &#34;vim.useSystemClipboard&#34;: true, // システムクリップボードを使う // ... }"},{url:"/p/vit4ckt/",title:"Hugo で「このページを編集 (Edit this page)」のリンクを表示する",date:"2020-04-01T00:00:00+09:00",body:"Hugo で「このページを編集 (Edit this page)」のリンクを表示する GitHub の編集ページ GitHub には簡易的なエディタ機能があり、ウェブサイト上で Markdown ファイルを直接編集できるようになっています。 Hugo サイトのコンテンツを GitHub で管理しているのであれば、GitHub の編集ページにリンクを張っておくと便利かもしれません。 この編集ページを使用すれば、Git コマンドに不慣れな人でも手軽に Markdown ファイルを修正することができます。 例えば、https://github.com/yourname/website/ といった GitHub リポジトリで Hugo のサイトコンテンツを管理している場合、トップページの Markdown ファイルを編集するための URL は次のようになります。 https://github.com/yourname/website/edit/master/content/_index.md ここでは、Hugo で生成する各ページに、上記のような編集ページへのリンクを出力することを考えてみます。 編集ページへのリンクを出力する まず、GitHub リポジトリのベース URL は、Hugo の設定ファイルに、独自パラメータ editBaseURL として定義することにしましょう。 hugo.toml baseURL = &#34;https://example.com&#34; languageCode = &#34;ja-jp&#34; title = &#34;私のウェブサイト&#34; [params] editBaseURL = &#34;https://github.com/yourname/website/edit/master/content&#34; 次に、編集ページへのリンクを出力するためのパーシャルテンプレートを作成します。 layouts/partials/edit-this-page.html {{ if $.Site.Params.editBaseURL }} {{- $filepath := replace .File.Path &#34;\\\\&#34; &#34;/&#34; -}} {{- $url := printf &#34;%s/%s&#34; $.Site.Params.editBaseURL $filepath -}} &lt;a href=&#34;{{ $url }}&#34;&gt;Edit this page&lt;/a&gt; {{- end }} このテンプレートでは次のようなことを行っています。 設定ファイルに editBaseURL が定義されている場合のみ処理を継続 .File.Path で、Markdown ファイルの content ディレクトリからの相対パスを取得（さらに、Windows を考慮してバックスラッシュをスラッシュに変換しておく） editBaseURL の値と Markdown ファイルのパスを組み合わせて、編集ページの URL を構築（URL の結合に path.Join が使えるかと思ったけど、https:// のスラッシュが一個削除されてしまってうまくいかないので、ここでは printf で結合してます） HTML のアンカータグ (a) を出力 あとは、このパーシャルテンプレートを、任意のレイアウトファイルから呼び出せば OK です。 ここでは、シングルページテンプレートから呼び出してみます。 layouts/_default/single.html（抜粋） {{ partial &#34;edit-this-page&#34; . }}"},{url:"/p/2ycmvbn/",title:"hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする",date:"2020-03-25T00:00:00+09:00",body:"hugo deploy コマンドで Azure などのクラウドサービス上にデプロイする Hugo は、各種クラウド (Azure Storage, Google Cloud Storage, AWS S3) 上のストレージにデプロイするためのコマンドを標準で搭載しています。 hugo deploy コマンドとは 静的なウェブサイトをホスティングするために、次のような有名どころのストレージサービスを使用している人は多いと思います。 Microsoft の Azure Storage (BLOB Storage) Google の GSC (Google Cloud Storage) Amazon の AWS S3 Hugo が搭載している hugo deploy コマンドを使用すると、プロジェクトの設定ファイル (hugo.toml) に記述されたデプロイ設定に基づき、これらのサービスへのデプロイを行えるようになります。 もちろん、各種ストレージサービス用の CLI（コマンドラインツール）を使ってもデプロイすることはできるのですが、hugo deploy を使うことでデプロイ方法が単純化（統一化）され、余計なコマンドラインツールをインストールしなくてもデプロイを実行できるという利点があります。 ここでは、Azure のストレージコンテナ（BLOB ストレージ）に Hugo で生成した Web コンテンツをデプロイする方法を説明します。 Azure のストレージコンテナにデプロイする hugo deploy の設定 Azure Storage は、簡単に静的な Web サイトをホスティングする機能を提供しています。 ここでは詳細な手順は記載しませんが、下記サイトのように、(1) ストレージアカウントの作成、(2) 静的な Web サイトを有効化、という 1 分くらいの手順で Web サイトを立ち上げることができます。 利用料金も、小規模なサイトであれば月額 100 円もかからないくらいリーズナブルです。 参考: Azure Storage で静的 Web サイトをホスティングする｜まくろぐ Azure Storage で静的な Web サイトを有効化すると、$web という名前のストレージコンテナが生成されるので、ここにデプロイするための設定を設定ファイル (hugo.toml) に追記します。 hugo.toml（追記） [[deployment.targets]] URL = &#34;azblob://$web&#34; あとはデプロイ先を示す Azure Storage のストレージアカウント名と、アクセス用のキーを、次のような環境変数で設定します。 環境変数 AZURE_STORAGE_ACCOUNT: ストレージアカウント名 環境変数 AZURE_STORAGE_KEY: ストレージキー（代わりに SAS トークンを使いたい場合は AZURE_STORAGE_SAS_TOKEN を設定します） 設定は最低限これだけしておけばよいので、とてもシンプルです。 さらに細かい設定については 公式サイト を参照してください。 hugo deploy の実行 あとは、次のように hugo コマンドで Web サイトをビルドし、hugo deploy コマンドでデプロイを実行できます。 # サイトをビルド（public ディレクトリを生成） $ hugo Building sites … # デプロイを実行（public ディレクトリの中身をアップロード） $ hugo deploy Deploying to target &#34;&#34; (azblob://$web) Identified 38 file(s) to upload, totaling 6.0 MB, and 0 file(s) to delete. Success! 今回はデプロイ先が 1 つなので、ターゲット名の設定を省略しており、ログにもターゲット名が出力されていません。 差分アップロードもちゃんとできているようです（azcopy sync に相当）。 コンテンツに更新がない場合は、次のようにアップロード処理をスキップしてくれます。 $ hugo deploy Deploying to target &#34;&#34; (azblob://$web) No changes required. ちなみに、プロキシ環境から hugo deploy を実行したいときは、http_proxy 環境変数を設定しておけば OK です。 （おまけ）アップロード用のバッチファイル 下記は、hugo コマンドによるサイトのビルドと、hugo deploy によるデプロイをまとめて実行する Windows バッチファイルの例です。 AZURE_STORAGE_ACCOUNT、AZURE_STORAGE_KEY などの汎用的な環境変数をシステム全体に設定してしまうのが嫌な場合は、下記のように独自の環境変数に設定した値を伝搬させて設定するとよいでしょう。 deploy.bat @echo off setlocal set AZURE_STORAGE_ACCOUNT=%MAKU_AZURE_STORAGE_ACCOUNT% set AZURE_STORAGE_KEY=%MAKU_AZURE_STORAGE_KEY% if defined MAKU_AZURE_STORAGE_PROXY ( set http_proxy=%MAKU_AZURE_STORAGE_PROXY% ) hugo hugo deploy"},{url:"/p/w7r8p6m/",title:"Hugo サイトで SNS（Twitter や Facebook）用の表示設定を行う (OGP: Open Graph Protocol)",date:"2020-03-15T00:00:00+09:00",body:"Hugo サイトで SNS（Twitter や Facebook）用の表示設定を行う (OGP: Open Graph Protocol) Web ページに OGP (Open Graph Protocol) に基づいたメタ情報を記述しておくと、SNS アプリで URL をシェアしたときに表示される内容をカスタマイズできます。 図: OGP 設定によるリンク表示の例 Open Graph のメタ情報として、どのような HTML タグを記述すればよいかは、下記のサイトを参考にしてください。 参考: Facebook や Twitter でシェアするときに画像や説明文が表示されるようにする (OGP: Open Graph Protocol) Open Graph タグを出力するためのパーシャルテンプレート ここでは、Hugo のパーシャルテンプレートで Open Graph タグを出力するようにしてみます。 layouts/partials/head/ogp.html &lt;meta property=&#34;og:site_name&#34; content=&#34;{{ .Site.Title }}&#34; /&gt; &lt;meta property=&#34;og:title&#34; content=&#34;{{ .Title }}&#34; /&gt; &lt;meta property=&#34;og:type&#34; content=&#34;website&#34; /&gt; &lt;meta property=&#34;og:url&#34; content=&#34;{{ .Permalink }}&#34; /&gt; &lt;meta property=&#34;og:locale&#34; content=&#34;ja_JP&#34; /&gt; {{- if .Params.image }} {{- $imageRes := .Resources.GetMatch .Params.image -}} &lt;meta property=&#34;og:image&#34; content=&#34;{{ $imageRes.Permalink }}&#34; /&gt; &lt;meta property=&#34;og:image:width&#34; content=&#34;{{ $imageRes.Width }}&#34; /&gt; &lt;meta property=&#34;og:image:height&#34; content=&#34;{{ $imageRes.Height }}&#34; /&gt; {{- else if .Site.Params.image }} {{- $imageRes := resources.Get .Site.Params.image -}} &lt;meta property=&#34;og:image&#34; content=&#34;{{ $imageRes.Permalink }}&#34; /&gt; &lt;meta property=&#34;og:image:width&#34; content=&#34;{{ $imageRes.Width }}&#34; /&gt; &lt;meta property=&#34;og:image:height&#34; content=&#34;{{ $imageRes.Height }}&#34; /&gt; {{- end }} {{- if .Description }} &lt;meta property=&#34;og:description&#34; content=&#34;{{ .Description }}&#34; /&gt; {{- else if .Summary }} &lt;meta property=&#34;og:description&#34; content=&#34;{{ .Summary }}&#34; /&gt; {{- else if .Site.Params.description }} &lt;meta property=&#34;og:description&#34; content=&#34;{{ .Site.Params.description }}&#34; /&gt; {{- end }} {{- with .Site.Params.facebookAppId }} &lt;meta property=&#34;fb:app_id&#34; content=&#34;{{ . }}&#34; /&gt; {{- end }} 画像 (og:image) や説明文 (og:description) などの内容は、いくつかフォールバックの仕組みを入れて、次のように出力するようにしています。 og:image ページバンドルとして画像ファイルを含んでいる場合、フロントマターの image プロパティでそのファイル名を指定することで、Open Graph の画像として表示できるようにしています。 例えば、content/aaa/bbb/index.md というページにバンドルする画像ファイルは、content/aaa/bbb/sample.png のように同じディレクトリ内に配置します。 フロントマターでのページ画像の指定 --- title: &#34;ページタイトル&#34; date: &#34;2020-03-15&#34; image: &#34;sample.png&#34; --- フロントマターで image プロパティが指定されていない場合は、サイトの設定ファイル (config.toml) の独自プロパティ params.image で指定した画像ファイルをサイトロゴ画像として使用します。 サイトロゴ画像は、Hugo プロジェクトのディレクトリ内に、assets/img/site-log-large.png のようなパスで配置しておきます（Hugo の Image processing 機能を使って画像サイズを取得するため、static ディレクトリではなく assets ディレクトリに配置しなければいけないことに注意してください）。 hugo.toml でのサイトロゴの指定（抜粋） [params] image = &#34;img/site-logo.png&#34; og:description ページの説明文を表す og:description には、下記のような優先度で見つかったものを設定します。 フロントマターの description プロパティに記述されたテキスト ページ本文があれば、.Page.Summary で求められる要約テキスト（本文の先頭部分） サイトの設定ファイル config.toml の独自プロパティ params.description に記述されたテキスト これは 1 番だけにしておいた方がいいかもしれません。。。 fb:app_id Facebook の公式ドキュメントによると、Facebook のアプリ ID も指定しておく必要があるとされています。 Facebook のアプリ ID は、サイトの設定ファイル config.toml の独自プロパティ params.facebookAppId で指定できるようにしています。 [params] facebookAppId = &#34;1234567890123456&#34; head 要素に Open Graph メタ情報を埋め込む 上記のように作成したパーシャルテンプレートは、各ページの head 要素内に展開されるようにします。 ここでは、全てのページに適用するために、ベーステンプレート 内から読み込むようにしてみます。 layouts/_default/baseof.html（抜粋） &lt;!DOCTYPE html&gt; &lt;html lang=&#34;{{ .Site.LanguageCode }}&#34;&gt; &lt;head prefix=&#34;og: https://ogp.me/ns# fb: https://ogp.me/ns/fb#&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; {{ partial &#34;head/ogp&#34; . }} ... html 要素か head 要素で、メタ情報用のプレフィックス定義が必要なことに注意してください。 これで、Facebook や Twitter といった SNS アプリでサイトの URL が共有されたときに、アイキャッチ画像や説明文が表示されるようになります。 （応用）親セクションの image プロパティを採用する 細かいページをたくさん作っている場合は、各ページごとにアイキャッチ画像を用意するのは大変です。 そこで、各ページが所属するセクションや、親セクションのフロントマターに設定された image プロパティを見て og:image 情報を設定するようにしてみます。 もちろん、自分自身のページのフロントマターに image プロパティが指定されていれば、そちらを優先的に使用します。 layouts/partials/head/ogp.html（og:image 出力部分の抜粋） {{- define &#34;og_image&#34; }} {{- if .Params.image }} {{- $imageRes := .Resources.GetMatch .Params.image -}} &lt;meta property=&#34;og:image&#34; content=&#34;{{ $imageRes.Permalink }}&#34; /&gt; &lt;meta property=&#34;og:image:width&#34; content=&#34;{{ $imageRes.Width }}&#34; /&gt; &lt;meta property=&#34;og:image:height&#34; content=&#34;{{ $imageRes.Height }}&#34; /&gt; {{- else if .Parent }} {{- template &#34;og_image&#34; .Parent }} {{- else if .Site.Params.image }} {{- $imageRes := resources.Get .Site.Params.image -}} &lt;meta property=&#34;og:image&#34; content=&#34;{{ $imageRes.Permalink }}&#34; /&gt; &lt;meta property=&#34;og:image:width&#34; content=&#34;{{ $imageRes.Width }}&#34; /&gt; &lt;meta property=&#34;og:image:height&#34; content=&#34;{{ $imageRes.Height }}&#34; /&gt; {{- end }} {{- end }} {{- template &#34;og_image&#34; . }} この仕組みを採用した場合、最終的にホームページ (content/_index.md) のフロントマターまで遡って image プロパティを探してくれるようになるので、サイト全体のロゴをホームページのフロントマターでも設定できるようになります（サイトの設定ファイル (config.toml) で image プロパティを設定しておく必要がなくなります）。 content/_index.md によるサイトロゴの指定 --- title: &#34;まくろぐ&#34; url: &#34;/&#34; image: &#34;site-logo.png&#34; --- この場合は、site-log.png ファイルはホームページにバンドルされたものを参照することになるので、次のようなパスで配置することに注意してください（assets ディレクトリには配置しません）。 content/site-logo.png"},{url:"/p/7rhpaxa/",title:"Androidメモ: カスタムビューの子ビューがフォーカスを得たことを検出する",date:"2020-03-11T00:00:00+09:00",body:"Androidメモ: カスタムビューの子ビューがフォーカスを得たことを検出する Android の View に対して setOnFocusChangeListener() でリスナを登録しておくと、その View がフォーカスを得たり、失ったりしたタイミングを検出することができます。 myView.setOnFocusChangeListener { v, hasFocus -&gt; // ... } しかし、この通知はフォーカス対象となる末端の View に対してしか送られないため、複数の View を束ねるカスタムビュー単位でフォーカスが移動したことを判別したい場合は少し工夫が必要です。 ここでは、次のように 2 つのボタンを持つカスタムビューを縦方向に 3 つ配置し、カスタムビュー間でフォーカスを移動させた場合に、カスタムビュー全体の背景色を変更することを考えてみます（うっすらとフォーカスされたカスタムビューの背景色を緑色にしています）。 次のコードはカスタムビューの実装例です。 MyCustomView.kt package com.example.myapp import android.content.Context import android.graphics.Color import android.util.AttributeSet import android.view.LayoutInflater import android.view.ViewTreeObserver.OnGlobalFocusChangeListener import androidx.constraintlayout.widget.ConstraintLayout class MyCustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : ConstraintLayout(context, attrs, defStyleAttr) { private val focusListener = OnGlobalFocusChangeListener { _, _ -&gt; if (findFocus() == null) { // このカスタムビュー内からフォーカスが失われた setBackgroundColor(Color.DKGRAY) } else { // このカスタムビュー内のいずれかのビューがフォーカスを得た setBackgroundColor(Color.rgb(68, 92, 68)) // DKGRAYより少し緑 } } init { LayoutInflater.from(context).inflate(R.layout.my_custom_view, this) viewTreeObserver.addOnGlobalFocusChangeListener(focusListener) } } 実際にフォーカスが当たるのは、カスタムビュー内の子ビュー (Button) なので、このカスタムビュー自体の onFocusChanged() ではフォーカスの移動を検出できません。 そこで、ここでは ViewTreeObserver.OnGlobalFocusChangeListener を登録して、ビューツリー全体のフォーカス移動タイミングをハンドルするようにしています。 onGlobalFocusChanged() が発火したタイミングで ViewGroup.findFocus() を呼び出し、カスタムビュー内の子ビューがフォーカスを得たのか（あるいは失ったのか）を判定しています。 ViewGroup.findFocus() は、そのビューツリー以下のビューがフォーカスを持っているときにその参照を返し、持たないときは null を返すため、何らかの View 参照が返された場合は、カスタムビュー内の子ビューがフォーカスを持っているのだと判断できます。 上記のカスタムビューが使用している、レイアウト XML ファイルも載せておきます。 res/layout/my_custom_view.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:padding=&#34;10dp&#34;&gt; &lt;Button android:id=&#34;@+id/button1&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34; android:layout_marginEnd=&#34;10dp&#34; android:text=&#34;Button1&#34; app:layout_constraintBottom_toBottomOf=&#34;parent&#34; app:layout_constraintEnd_toStartOf=&#34;@+id/button2&#34; app:layout_constraintStart_toStartOf=&#34;parent&#34; app:layout_constraintTop_toTopOf=&#34;parent&#34; /&gt; &lt;Button android:id=&#34;@+id/button2&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34; android:text=&#34;Button2&#34; app:layout_constraintBottom_toBottomOf=&#34;parent&#34; app:layout_constraintEnd_toEndOf=&#34;parent&#34; app:layout_constraintStart_toEndOf=&#34;@+id/button1&#34; app:layout_constraintTop_toTopOf=&#34;parent&#34; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;"},{url:"/p/nsvub5w/",title:"Kotlinメモ: 列挙型 (enum) の値をインデックスで取得する",date:"2020-03-11T00:00:00+09:00",body:"Kotlinメモ: 列挙型 (enum) の値をインデックスで取得する 次の例では、列挙型クラス Fruits に static な関数 fromOrdinal() を定義し、インデックス番号 (0, 1, 2) から Fruits インスタンスを取得できるようにしています。 範囲外のインデックスを指定した場合は、NoSuchElementException 例外が発生します。 Fruit.kt enum class Fruits { APPLE, BANANA, GRAPE; companion object { fun fromOrdinal(ordinal: Int) : Fruits { return values().first { it.ordinal == ordinal } } } } 使用例 val f1 = Fruits.fromOrdinal(0) //=&gt; Fruits.APPLE val f2 = Fruits.fromOrdinal(1) //=&gt; Fruits.BANANA val f3 = Fruits.fromOrdinal(2) //=&gt; Fruits.GRAPE val f4 = Fruits.fromOrdinal(3) //=&gt; NoSuchElementException"},{url:"/p/uyzcgd8/",title:"Git コマンドで使用するプロキシを設定する (http.proxy)",date:"2020-03-04T00:00:00+09:00",body:"Git コマンドで使用するプロキシを設定する (http.proxy) Git のプロキシを設定する 会社のオフィスなどのプロキシ環境内から git コマンドを使用する場合は、次のようにプロキシサーバーのアドレス（とポート番号）を設定できます。 git コマンド用のプロキシ設定 $ git config --global http.proxy http://proxy.example.com:8080 ちゃんと設定されているかは、git config --list コマンド、あるいは設定ファイルを直接見て確認できます。 プロキシ設定の確認 (1) $ git config --global --list ... http.proxy=http://proxy.examle.com:8080 プロキシ設定の確認 (2) $ cat ~/.gitconfig ... [http] proxy = http://proxy.examle.com:8080 Git のプロキシ設定を削除する プロキシ設定を削除するには、git config --unset コマンドを使用します。 $ git config --global --unset http.proxy 参考: git config で設定を削除する (config --unset) Git のプロキシ設定を一時的に無効にする リモートワークなどで、一時的にプロキシ設定を無視して git コマンドを使用したい場合は、-c オプションで http.proxy 設定を次のように空っぽに指定してやります。 $ git -c http.proxy= pull http.proxy= の後ろには空であることを示すスペースがあることに注意してください（もっと明示的に http.proxy=&quot;&quot; としてもOK）。 また、-c オプションは、git コマンドのグローバルなオプションなので、git の直後くらいに入力しないといけないことに注意してください。"},{url:"/p/msds6iv/",title:"Git の設定値がどのファイルで設定されているか調べる (config --show-origin)",date:"2020-03-04T00:00:00+09:00",body:"Git の設定値がどのファイルで設定されているか調べる (config --show-origin) Git 設定のスコープには、local/global/system などがあり、ある設定値がどのスコープ（設定ファイル）で行われているか混乱することがあります。 参考: Git 設定のスコープ (local/global/system) を理解する そのような場合は、git config --list --show-origin コマンドを使うと、それぞれの設定値がどのファイルで設定されいるものなのか調べることができます。 $ git config --list --show-origin ... file:/Users/maku/.gitconfig user.name=maku77 file:/Users/maku/.gitconfig user.email=xxx@gmail.com file:/Users/maku/.gitconfig core.editor=vim file:/Users/maku/.gitconfig push.default=simple file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config core.ignorecase=true file:.git/config core.precomposeunicode=true file:.git/config remote.origin.url=https://github.com/maku77/maku77.github.io.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master この例の場合、/Users/maku/.gitconfig で始まるものが global スコープ、.git/config で始まるものが local スコープで設定されていることが分かります。 ここでは、--list オプションですべての設定値を列挙していますが、次のように個別の設定値に関して調べることもできます。 $ git config --show-origin user.name file:/Users/maku/.gitconfig user.name=maku77"},{url:"/p/tqmr4od/",title:"Vim のキーマップ例: ショートカットキーでカレントディレクトリを Windows エクスプローラーや Mac の Finder で開く",date:"2020-02-29T00:00:00+09:00",body:"Vim のキーマップ例: ショートカットキーでカレントディレクトリを Windows エクスプローラーや Mac の Finder で開く Vim/Neovim で次の設定を行っておくと、現在編集中のファイルが格納されたディレクトリをショートカットキー（ここでは F12 キー）一発で開くことができます。 Windows の場合は start コマンドを使って「エクスプローラー」を開き、Mac の場合は open コマンドを使って「Finder」を開くようにしています。 Neovim（Lua スクリプト）の場合 ~/.config/nvim/init.lua -- 編集中ファイルが格納されたディレクトリを開く関数 function open_current_dir() local command if vim.fn.has(&#34;mac&#34;) == 1 then command = &#34;open&#34; elseif vim.fn.has(&#34;win32&#34;) == 1 or vim.fn.has(&#34;win64&#34;) == 1 then command = &#34;start&#34; else print(&#34;Could not open the directory (unsupported OS)&#34;) return end local dir_path = vim.fn.expand(&#34;%:p:h&#34;) vim.fn.system(command .. &#34; &#34; .. dir_path) end -- F12 キーにマップする vim.keymap.set(&#34;n&#34;, &#34;&lt;F12&gt;&#34;, open_current_dir, { silent = true, desc = &#34;Open current directory in file manager&#34; }) Vim（Vim スクリプト）の場合 ~/.vimrc &#34; 編集中ファイルのディレクトリを Explorer や Finder で開く if has(&#34;win32&#34;) || has(&#34;win64&#34;) || has(&#34;win32unix&#34;) nmap &lt;F12&gt; :silent ! start %:h&lt;CR&gt; elseif has(&#34;macunix&#34;) nmap &lt;F12&gt; :silent ! open %:h&lt;CR&gt; endif"},{url:"/p/4j2zidk/",title:"Kotlinメモ: プリミティブ型配列 (IntArray) の内容を見やすく出力する (contentToString)",date:"2020-02-26T00:00:00+09:00",body:"Kotlinメモ: プリミティブ型配列 (IntArray) の内容を見やすく出力する (contentToString) 配列クラスの contentToString メソッド 配列を扱うためのクラスである Array&lt;T&gt; や IntArray などのインスタンスを、println() などで出力しようとすると、JVM 表現で分かりにくい文字列が出力されてしまいます（例: [I@2c7b84de）。 このような場合は、Kotlin が拡張関数として用意している contentToString() メソッドを使用すると、読みやすい形式で配列の内容を出力できます。 実装例 // ジェネリック型配列の場合 val arr1: Array&lt;Int&gt; = arrayOf(1, 2, 3) println(arr1) println(arr1.contentToString()) // プリミティブ型配列の場合も同様 val arr2: IntArray = intArrayOf(1, 2, 3) println(arr2) println(arr2.contentToString()) 実行結果 [Ljava.lang.Integer;@31befd9f [1, 2, 3] [I@2c7b84de [1, 2, 3] ちなみに、contentToString() 拡張関数の実装は、java.util.Arrays.toString(this) を呼び出しているだけです。 List/Set/Map はデフォルトで綺麗に出力される List や Set、Map などのジェネリッククラスは、このようなことをしなくても、デフォルトの toString() が見やすい出力をしてくれます（継承元の AbstractCollection.toString() などで実装されています）。 val list: List&lt;Int&gt; = listOf(1, 2, 3) println(list) //=&gt; [1, 2, 3] val set: Set&lt;Int&gt; = setOf(1, 2, 3) println(set) //=&gt; [1, 2, 3] val map: Map&lt;String, Int&gt; = mapOf(&#34;one&#34; to 1, &#34;two&#34; to 2) println(map) //=&gt; {one=1, two=2}"},{url:"/p/fo685z4/",title:"Kotlinメモ: 配列とリストの生成方法まとめ（連番からなる配列やリストを作成する）",date:"2020-02-26T00:00:00+09:00",body:"Kotlinメモ: 配列とリストの生成方法まとめ（連番からなる配列やリストを作成する） 空の配列やリスト リストや配列のファクトリ関数である listOf や arrayOf の引数に何も指定しないと、空の配列やリストを作成することができます。 空の List/Set/Map を生成 val x = listOf&lt;Int&gt;() //=&gt; List&lt;Int&gt; val x = mutableListOf&lt;Int&gt;() //=&gt; MutableList&lt;Int&gt; val x = setOf&lt;Int&gt;() //=&gt; Set&lt;Int&gt; val x = mutableSetOf&lt;Int&gt;() //=&gt; MutableSet&lt;Int&gt; val x = mapOf&lt;String, Int&gt;() //=&gt; Map&lt;String, Int&gt; val x = mutableMapOf&lt;String, Int&gt;() //=&gt; MutableMap&lt;String, Int&gt; Java の可変配列である ArrayList を生成する arrayListOf() という関数も存在しますが、通常は MutableList の方を使えばいいので、上記の例には含めていません。 空の配列を生成 // ジェネリック型配列 val x = arrayOf&lt;Int&gt;() //=&gt; Array&lt;Int&gt; val x = arrayOf&lt;Double&gt;() //=&gt; Array&lt;Double&gt; // プリミティブ型配列 val x = intArrayOf() //=&gt; IntArray val x = doubleArrayOf() //=&gt; DoubleArray emptyXxx メソッドを使う immutable（不変）かつ empty（要素数 0）な配列やリストを、arrayOf や listOf で個別に作成するのはあまり意味がありません（要素を追加できないのでどのインスタンスも同様のものになってしまう）。 このような場合は、次のような emptyXxx 系メソッドを使うと効率がよいです。 val x = emptyArray&lt;Int&gt;() //=&gt; Array&lt;Int&gt; val x = emptyList&lt;Int&gt;() //=&gt; List&lt;Int&gt; val x = emptySet&lt;Int&gt;() //=&gt; Set&lt;Int&gt; val x = emptyMap&lt;String, Int&gt;() //=&gt; Map&lt;String, Int&gt; これらのメソッドは、Kotlin が定義しているシングルトンインスタンス（EmptyList など）を返すので、空のコレクションインスタンスがいくつも作られるのを防ぐことができます。 ちなみに、空のプリミティブ型配列を作る emptyIntArray() のような関数はないみたいです（なので intArrayOf() で代用）。 各要素の初期値を明示する リストや配列のファクトリ関数の引数には、任意の要素数の初期値を指定することができます。 初期値を指定して List/Set/Map を生成 val x: List&lt;Int&gt; = listOf(1, 2, 3) val x: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3) val x: Set&lt;Int&gt; = setOf(1, 2, 3) val x: MutableSet&lt;Int&gt; = mutableSetOf(1, 2, 3) val x: Map&lt;String, Int&gt; = mapOf(&#34;one&#34; to 1, &#34;two&#34; to 2) val x: MutableMap&lt;String, Int&gt; = mutableMapOf(&#34;one&#34; to 1, &#34;two&#34; to 2) 初期値を指定して配列を生成 val x: Array&lt;Int&gt; = arrayOf(1, 2, 3) val x: IntArray = intArrayOf(1, 2, 3) サイズだけ指定する（デフォルト値で初期化） プリミティブ型配列のコンストラクタの引数に整数を 1 つだけ指定すると、そのサイズの配列が生成されます。 各要素の値はデフォルト値の 0 で初期化されます（CharArray の場合は null 文字を表す \\u0000 になります）。 val x = ByteArray(3) //=&gt; [0, 0, 0] val x = ShortArray(3) //=&gt; [0, 0, 0] val x = IntArray(3) //=&gt; [0, 0, 0] val x = LongArray(3) //=&gt; [0, 0, 0] val x = FloatArray(3) //=&gt; [0.0, 0.0, 0.0] val x = DoubleArray(3) //=&gt; [0.0, 0.0, 0.0] val x = CharArray(3) //=&gt; [&#39;\\u0000&#39;, &#39;\\u0000&#39;, &#39;\\u0000&#39;] デフォルト値の 0 を使ってすべての要素を初期化する仕組みがあるのは、このようなプリミティブ型配列のみです。 List&lt;Int&gt; や Array&lt;Int&gt; で、すべての要素を 0 に初期化する場合は、次のようにラムダ式で各要素に 0 を設定してやる必要があります。 val x: List&lt;Int&gt; = List(3) { 0 } //=&gt; [0, 0, 0] val x: Array&lt;Int&gt; = Array(3) { 0 } //=&gt; [0, 0, 0] ちょっと特殊な例として、すべての要素を null で初期化した配列を作るユーティリティ関数として arrayOfNulls() というのも用意されています。 val x: Array&lt;Int?&gt; = arrayOfNulls(3) //=&gt; [null, null, null] val x = Array&lt;Int?&gt;(3) { null } //=&gt; 同上 ちなみに、ArrayList クラスのコンストラクタにも整数値を 1 つ指定することができますが、これは初期キャパシティ (initialCapacity) を示すもので、要素数を指定するものではありません（要素数は 0 になります）。 ラムダによる初期化（連番からなる配列やリストを生成する） コレクション系クラスのコンストラクタには、各要素の初期値を設定するためのラムダ式を渡すことができます。 ラムダ式のパラメータ (it) で各要素のインデックス番号 (0, 1, 2 &hellip;) を参照できるので、この値を使って連番からなる配列やリストを生成することができます。 // ジェネリック型コレクション val x: List&lt;Int&gt; = List(3) { it } //=&gt; [0, 1, 2] val x: MutableList&lt;Int&gt; = MutableList(3) { it + 1 } //=&gt; [1, 2, 3] val x: Array&lt;String&gt; = Array(3) { &#34;ID-${it + 1}&#34; } // =&gt; [&#34;ID-1&#34;, &#34;ID-2&#34;, &#34;ID-3&#34;] // プリミティブ型配列も同様 val x = IntArray(3) { it * 2 } //=&gt; [0, 2, 4] val x = DoubleArray(3) { Math.sqrt(it.toDouble()) } //=&gt; [0.0, 1.0, 1.414213] val x = CharArray(3) { &#39;A&#39; + it } // =&gt; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] ちなみに、Set や Map の初期化はこのようなラムダ式では行えないようです（ラムダを受け取るコンストラクタが存在しない）。 参考: プリミティブ型の配列には IntArray や LongArray などの専用クラスを使うことを検討する"},{url:"/p/az53za7/",title:"Kotlinメモ: プリミティブ型の配列には IntArray や LongArray などの専用クラスを使うことを検討する",date:"2020-02-25T00:00:00+09:00",body:"Kotlinメモ: プリミティブ型の配列には IntArray や LongArray などの専用クラスを使うことを検討する いつ Int はプリミティブ型として扱われるか？ 整数値を扱うとき、Java では Integer 型と int 型を使い分けていました。 一方 Kotlin では、一律で Int を使い、必要に応じて内部的にプリミティブ型（Java の int）として扱ってくれるようになっています。 この仕組みによって、プログラマは Int だけを使っていれば、自動的に効率的なプリミティブ型を使ってくれるようになるので非常にありがたいのですが、問題は、Kotlin がいつ Int をプリミティブ型として扱ってくれるのかということです。 下記の表は、Kotlin と Java の整数型の対応を示しています。 Kotlin の型 Java の型 Int int Int? Integer List&lt;Int&gt; List&lt;Integer&gt; Array&lt;Int&gt; Integer[] IntArray int[] 簡単にまとめると、Int? のように nullable な型として扱う場合と、ジェネリクスクラスの型引数として使った場合は、プリミティブ型ではなく Java の Integer として扱われます。 プリミティブ型配列のためのクラス IntArray プリミティブ型の配列を作りたい場合は、Java では int[] のように記述できていましたが、Kotlin の場合は IntArray のような専用の型を使用します。 val intArr1: IntArray = intArrayOf() // これがプリミティブ型配列 println(intArr1.javaClass.simpleName) // Java では int[] に相当 val intArr2: Array&lt;Int&gt; = arrayOf&lt;Int&gt;() // これは Integer な配列 println(intArr2.javaClass.simpleName) // Java では Integer[] に相当 多くのケースではジェネリクスクラスの List&lt;T&gt; を使っていれば問題ありませんが、大きなプリミティブ型要素を扱うケースや、パフォーマンスが重要になるケースでは IntArray のようなプリミティブ型配列を使うのがよいでしょう。 プリミティブ型配列には、IntArray 以外にも次のようなものが用意されています。 Kotlin の型 Java の型 CharArray char[] ByteArray byte[] ShortArray short[] IntArray int[] LongArray long[] FloatArray float[] DoubleArray double[] いずれも、xxxArrayOf() という名前のファクトリ関数を使って配列要素を初期化できます。 val charArr = charArrayOf(&#39;a&#39;, &#39;b&#39;) // char[] val byteArr = byteArrayOf(1, 2, 3) // byte[] val shortArr = shortArrayOf(1, 2, 3) // short[] val intArr = intArrayOf(1, 2, 3) // int[] val longArr = longArrayOf(1, 2, 3) // long[] val floatArr = floatArrayOf(1.0f, 2.0f, 3.0f) // float[] val doubleArr = doubleArrayOf(1.0, 2.0, 3.0) // double[] 参考: 配列とリストの生成方法いろいろ（連番からなる配列やリストを作成する）"},{url:"/p/2imy2j9/",title:"Androidメモ: Emulator での開発時にキーボードによるキー入力が長押しかどうかを判別する",date:"2020-02-13T00:00:00+09:00",body:"Androidメモ: Emulator での開発時にキーボードによるキー入力が長押しかどうかを判別する Android アプリの開発をエミュレーターで行っているとき、キーボードの Enter キー (KEYCODE_ENTER) の長押しを **KeyEvent.isLongPress で判定しようとしてもうまくいきません（true になりません）。 なぜなら、キーボードのハードウェア的なキーリピート（正確には OS によるキーリピート）が働いてしまい、長押しではなくキー連打だと判定されてしまうからです。 ☝️ Android TV における D-Pad 操作の場合 Android TV 用のアプリを開発している場合は、リモコンの決定キー (KEYCODE_DPAD_ENTER) を長押しすると、KeyEvent.isLongPress が正しく true になります。 エミュレーターでの開発時に、KEYCODE_DPAD_ENTER の代わりにキーボードの Enter キー (KEYCODE_ENTER) で代替しようとすると、長押しが判定できないという罠にはまります。 下記の LongKeyPressChecker クラスは、キーボードからのキー入力であっても、そのキーが長押しされているかどうかを判別できるようにするためのユーティリティクラスです。 LongKeyPressChecker.kt import android.view.KeyEvent /** * キーボードによるキー入力が長押しかどうかを判別します。 */ class LongKeyPressChecker { companion object { // この時間以内に連続してキー入力があったら、そのキーは押しっぱなしだと判断する const val REPEAT_INTERVAL_MILLIS = 200 // 間髪いれずにこの回数だけキー入力があったら長押しされたと判断する const val LONG_PRESSED_COUNT = 3 } // 各キーが最後に押された時間と連打回数 private val timeAndCount = mutableMapOf&lt;Int, Pair&lt;Long, Int&gt;&gt;() /** * キーが長押しされたかどうかを判別します。 * 下記のいずれか関数の中で毎回呼び出す必要があります。 * - onKeyDown * - dispatchKeyEvent * - onUnhandledKeyEvent */ fun isLongPressed(event: KeyEvent): Boolean { if (event.action != KeyEvent.ACTION_DOWN) { return false } // KeyEvent.repeatCount 対応のキーでは KeyEvent.isLongPress を信用する if (event.repeatCount &gt; 0) { return event.isLongPress } val key: Int = event.keyCode val time: Long = event.downTime val timeAndCount = timeAndCount.getOrDefault(key, Pair(time, 0)) if ((time - timeAndCount.first) &lt; REPEAT_INTERVAL_MILLIS) { // 間髪入れずにキー入力があればカウントアップ this.timeAndCount[key] = Pair(time, timeAndCount.second + 1) if (timeAndCount.second == LONG_PRESSED_COUNT) { // 短時間でのキー入力が一定回数に達したら長押しされたと判断 return true } } else { // 前回のキープレスから一定時間が経過していたらそこからカウント開始 this.timeAndCount[key] = Pair(time, 1) } return false } } 使い方は簡単で、View.onKeyDown などの先頭で isLongPressed メソッドを呼び出すだけです。 次のようにすれば、キーボードの Enter キー (KEYCODE_ENTER) が長押しされたかどうかを判別できます。 MainActivity.kt class MainActivity : FragmentActivity(R.layout.main_activity) { private val longKeyPressChecker = LongKeyPressChecker() override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean { val isLongPressed = longKeyPressChecker.isLongPressed(event) when (event.keyCode) { KeyEvent.KEYCODE_ENTER, KeyEvent.KEYCODE_DPAD_CENTER -&gt; { if (isLongPressed) { Log.d(&#34;MainActivity&#34;, &#34;決定キーが長押しされたよ！&#34;) return true } } } return super.onKeyDown(keyCode, event) } // ... } 仕組みとしては、前回のキー入力から時間をあけずに（上記の例では REPEAT_INTERVAL_MILLIS ミリ秒以内）に、同じキーが何回も（上記の例では LONG_PRESSED_COUNT 回）押されたかを判別しているだけです。 なので、短時間にキー連打すると、長押しと判定されてしまう可能性があります。 また、Windows などの OS のキーリピート設定により、キー押しっぱなし時のカウント速度が変わってくることに注意してください。"},{url:"/p/y8hs5w6/",title:"Python で環境変数を参照する (os.getenv, os.environ)",date:"2020-01-29T00:00:00+09:00",body:"Python で環境変数を参照する (os.getenv, os.environ) 指定した環境変数を取得する Python で OS の環境変数を取得するには、os.getenv 関数を呼び出すか、os.environ 辞書オブジェクトを参照します。 例: 環境変数 PATH の値を表示 import os print(os.getenv(&#34;PATH&#34;)) print(os.environ[&#34;PATH&#34;]) 両者の違いは、存在しないキーを指定した場合に os.getenv がデフォルトで None を返すのに対し、os.environ は KeyError 例外を投げるという点です（辞書オブジェクト参照時の共通の振る舞いです）。 通常は os.getenv 関数を使った方が、例外をハンドルせずに済むのでシンプルなコードになります。 環境変数が設定されているかどうかで分岐 import os key = os.getenv(&#34;ACCESS_KEY&#34;) if key: print(&#34;環境変数が見つかった場合の処理&#34;) if not key: print(&#34;環境変数が見つからない場合の処理&#34;) ただし、複数の環境変数を参照する場合は、os.environ を使って一度に例外処理した方が分かりやすくなることがあります。 いずれかの環境変数が設定されていない場合に終了する try: openai.api_base = os.environ[&#34;OPENAI_API_BASE&#34;] openai.api_key = os.environ[&#34;OPENAI_API_KEY&#34;] except KeyError as e: sys.exit(f&#34;Environment variable not set: {e}&#34;) os.getenv 関数の第 2 パラメータ (default) では、キーが存在しな場合のデフォルト値を指定することが可能です。 環境変数が設定されていないときにデフォルト値を使う import os env = os.getenv(&#34;MYAPP_ENV&#34;, default=&#34;development&#34;) print(env) ちなみに、os.environ.get() という関数もありますが、これは os.getenv() 関数のエイリアスです。 すべての環境変数を列挙する 単一の環境変数を参照するときは os.getenv 関数が便利ですが、すべての環境変数をループ処理したい場合は os.environ オブジェクトをループ処理するとよいです。 環境変数を列挙する（キーを取り出す方法） import os for key in os.environ: val = os.environ[key] print(f&#34;{key}: {val}&#34;) 環境変数を列挙する（キーと値を取り出す方法） import os for key, val in os.environ.items(): print(f&#34;{key}: {val}&#34;) より実践的なサンプル ある環境変数が設定されていない場合にプログラムを終了する 次の config.py モジュールは、環境変数 MYAPP_USER と MYAPP_PASS の値を参照し、同じ名前の変数にセットします。 環境変数が見つからない場合は、対応方法を出力してプログラムを終了します。 config.py import os import sys def load_env_or_exit(env_name: str) -&gt; str: &#34;&#34;&#34; 環境変数の値を取得します。 設定されていない場合はエラーメッセージを表示してプログラムを終了します。 &#34;&#34;&#34; env_val = os.getenv(env_name) if not env_val: sys.exit(f&#34;Error: {env_name} not set. Please consider adding a .env file with {env_name}.&#34;) return env_val # 環境変数を参照 MYAPP_USER = load_env_or_exit(&#34;MYAPP_USER&#34;) MYAPP_PASS = load_env_or_exit(&#34;MYAPP_PASS&#34;) ☝️ ワンポイント 環境変数の値として明示的に空文字 (&quot;&quot;) がセットされているときにエラーにしたくない場合は、上記の if not env_val: の部分を if env_val is None: に変更します。 env_val が文字列型の場合、if not env_val: という条件指定は、if env_val is None or env_val == &quot;&quot;: と同じ意味になります。 さらに、.env ファイルを使って環境変数を設定できるようにしておくと、よりユーザーにとって扱いやすいプログラムになります。 上記の config.py モジュールは、別のモジュールから次のような感じ使用できます。 main.py import config print(config.MYAPP_USER) print(config.MYAPP_PASS) config.MYAPP_USER や config.MYAPP_PASS の値は、config.py をインポートしたときに自動的に初期化されるので、定数のように参照できます。 複数のモジュールから config.py をインポートする場合は、最初にインポートしたときのキャッシュが使われるので、何度も load_env_or_exit 関数が呼ばれてしまう心配はありません。 あるプログラム専用のプロキシ環境変数を用意する プロキシの設定を行う場合、一般的に http_proxy 環境変数が使用されますが、この環境変数を参照するのが適切ではないケースがあります。 例えば、http_proxy 環境変数を設定することにより、依存する別のプログラムが動作しなくなってしまうようなケースです。 このような場合は、次のようにアプリ特有の環境変数でプロキシを設定できるようにすることで対処できます。 config.py import os # 独自の MYAPP_PROXY 環境変数が設定されていたら http_proxy よりも優先的に使う PROXY = os.getenv(&#34;MYAPP_PROXY&#34;) or os.getenv(&#34;http_proxy&#34;)"},{url:"/p/78gvwox/",title:"Vim で 2 つのファイルの差分を取る・マージする (vimdiff, vim -d)",date:"2020-01-24T00:00:00+09:00",body:"Vim で 2 つのファイルの差分を取る・マージする (vimdiff, vim -d) 2 つのテキストファイルの差分を取る Vim（あるいは gVim）には、テキストファイルの差分を取る diff モード が付いています。 参考: diff - Vim日本語ドキュメント 参考: diff - Vim Documentation ハイライト表示された差分を確認しながらファイルを修正していくことができます。 Vim/gVim を diff モードで起動する (vimdiff/gvimdiff) コマンドラインから、Vim や gVim を diff モードを起動するには次のように vimdiff （あるいは gvimdiff） コマンドを実行します。 引数を増やせば、3 つ、あるいは 4 つのファイルを比較することも可能です。 vim の場合 vim -d ファイル1 ファイル2 vimdiff ファイル1 ファイル2 （vim -d のエイリアス） gvim の場合 gvim -d ファイル1 ファイル2 gvimdiff ファイル1 ファイル2 （gvim -d のエイリアス） 例えば、gVim 上で a.txt と b.txt を比較したいときは次のように gVim を起動します。 $ gvimdiff a.txt b.txt 左右にスプリットされた画面になり、内容が異なる部分（2 行目の BBBBB と XXXXX）がハイライト表示されます。 ウィンドウ間を移動するには Ctrl-W Ctrl-W と入力します。 ファイル編集中に他のファイルと比較する (diffsplit) 現在 vim (gvim) で編集中のファイルと、別のファイルの内容を比較したい場合は、次のように diffsplit コマンドを実行すると diff モードに移行できます。 :diffsplit b.txt （上下に分割） :vert diffsplit b.txt （左右に分割） デフォルトでは上下に分割表示しようとするので、左右に分割表示したい場合は、上記のように vert[ical] コマンドと組み合わせて使用する必要があります。 diffsplit を実行したときのデフォルトの分割方向を左右にするには、.vimrc (_vimrc) ファイルで次のように diffopt オプション を設定しておきます。 set diffopt+=vertical 次の差分／前の差分へジャンプする diff モードで比較表示を行っているときに、差分のある行にジャンプしたいときは、次のように入力します。 [c &hellip; 前の差分にジャンプ ]c &hellip; 次の差分にジャンプ マージする vimdiff (gvimdiff) コマンドなどで diff モード起動した状態で、次のコマンドを実行すると、差分を簡単にマージしていくことができます。 差分箇所で dp &hellip; 自分の内容をもう一方のファイルに反映 差分箇所で do &hellip; もう一方のファイルに内容を自分に反映 dp は diff put、do は diff obtain の略だと覚えましょう（公式ドキュメントより）。 左側にカーソルがあるときに、do、dp を入力すると次のような動きになります。 （トラブルシューティング）Windows で vimdiff コマンドが見つからない Windows では vimdiff (gvimdiff) コマンドは、vimdiff.bat (gvimdiff.bat) というバッチファイルでインストールされます（中で vim.exe -d や gvim.exe -d を呼び出しています）。 vimdiff コマンドが見つからない場合は、 Vim のインストーラ で、bat ファイルを作成 にチェックを入れてインストールしてください。 デフォルトでは、C:\\Windows ディレクトリの下に .bat ファイルを作成してくれますね。 何てことするんだ！"},{url:"/p/oc2j8u9/",title:"Kotlinメモ: セットの集合演算を行う",date:"2020-01-17T00:00:00+09:00",body:"Kotlinメモ: セットの集合演算を行う Set オブジェクト同士を + や - などで演算を行うと、和集合や差集合を求めることができます。 和集合 (union) + 演算子、あるいは union() メソッドを用いることで、セット同士の和集合（いずれかのセットに含まれている要素からなる集合）を求めることができます。 union() は infix 関数として定義されているので、演算子のように用いることができます。 val s1 = setOf(1, 2, 3, 4) val s2 = setOf(3, 4, 5, 6) println(s1 + s2) // [1, 2, 3, 4, 5, 6] println(s1 union s2) // 同上 println(s1.union(s2)) // 同上 共通集合／積集合 (intersection) intersect メソッドを用いることで、セット同士の共通集合（両方のセットに含まれている要素からなる集合）を求めることができます。 intersect() は infix 関数として定義されているので、演算子のように用いることができます。 val s1 = setOf(1, 2, 3, 4) val s2 = setOf(3, 4, 5, 6) println(s1 intersect s2) // [3, 4] println(s1.intersect(s2)) // 同上 差集合 (difference) - 演算子、あるいは minus() メソッド、subtract() メソッドを用いることで、2 つのセットの差集合（左辺に指定したセットにしか存在しない要素からなる集合）を求めることができます。 subtract() は infix 関数として定義されているので、演算子のように用いることができます。 val s1 = setOf(1, 2, 3, 4) val s2 = setOf(3, 4, 5, 6) println(s1 - s2) // [1, 2] println(s1.minus(s2)) // 同上 println(s1 subtract s2) // 同上 println(s1.subtract(s2)) // 同上 差集合は、左辺と右辺の値を入れ替えると結果が変わってくることに注意してください。 println(s1 - s2) // [1, 2] println(s2 - s1) // [5, 6]"},{url:"/p/ojwakt8/",title:"Kotlinメモ: 比較演算子を定義してオブジェクト同士の比較やソートを行えるようにする (equals, compareTo)",date:"2020-01-17T00:00:00+09:00",body:"Kotlinメモ: 比較演算子を定義してオブジェクト同士の比較やソートを行えるようにする (equals, compareTo) オブジェクトを ==、!=、&gt;、&lt;、&gt;=、&lt;= などの比較演算子で大小比較したいときや、ソート系の関数を適用できるようにするには、equals メソッドや、compareTo メソッドを定義します。 同値比較のための演算子（==、!=）に対応する (equals) Kotlin ではオブジェクトに対して == や != を適用すると、内部的に equals() メソッドの呼び出しに変換されます。 equals() メソッドのシグネチャは Any クラスで次のように定義されています。 Any クラスの equals() 定義 public open operator fun equals(other: Any?): Boolean このため、あらゆるクラスのインスタンスは == や != による比較を行えるようになっていますが、デフォルトの振る舞いは単なる参照の比較であり、オブジェクトが持つ各フィールドの内容は考慮されません。 標準ライブラリで提供されているクラス（BigDecimal など）が、== 演算子でうまく比較できるのは、equals() メソッドが適切に実装されているからです。 独自クラスを作成するときは、equals() メソッドをオーバーライドすることで、== 演算子と != 演算子の振る舞いをカスタマイズすることができます。 下記は独自の複素数クラス (Complex) で equals() メソッドをオーバーライドし、各フィールドの値（実数部と虚数部）を比較するようにしています。 class Complex(val re: Int, val im: Int) { override fun equals(other: Any?): Boolean { if (other === this) return true if (other !is Complex) return false return other.re == re &amp;&amp; other.im == im } } fun main() { val c1 = Complex(1, 2) val c2 = Complex(1, 2) println(c1 == c2) // =&gt; true println(c1 != c2) // =&gt; false } ここでは、参考のために equals メソッドの実装例を示しましたが、Kotlin ではクラス定義時に data プレフィックスを付けてデータクラスとして定義すると、自動的に equals メソッドが実装されるため、下記のように equals メソッドの定義を省略できます。 data class Complex(val re: Int, val im: Int) データクラスのデフォルトの equals() 実装では、各フィールドの値が順番に比較されていきます（この例では re と im が等しいか確認される）。 上記の Complex クラスのように、値を保持するだけの単純なクラスであれば、データクラスが提供してくれる equals() メソッドの振る舞いをそのまま利用することができます。 == 演算子と === 演算子の違い Java では == は参照の比較になりますが、Kotlin で参照の比較を行いたい場合は、=== 演算子（3 つのイコール）の方を使用する必要があります（== や != の方は equals() 呼び出しになるため）。 val c1 = Complex(1, 2) val c2 = Complex(1, 2) println(c1 == c2) // =&gt; true（内容は等しい） println(c1 === c2) // =&gt; false（参照は異なる） Kotlin では、== と === による等価性の違いの概念を、次のような用語で呼び分けています。 Structural equality &hellip; 内容が等しいことを示す（equals() メソッドによる比較で true を返すかどうか） Referential equality &hellip; 参照が等しいことを示す（2 つの変数が単一のオブジェクトを指し示すかどうか） Int などのプリミティブ型の場合、== と === の意味は同じになります。 val a: Int = 100 val b: Int = 100 println(a == b) //=&gt; true println(a === b) //=&gt; true 参照比較用の === 演算子をオーバーロードすることはできません。 大小比較のための演算子（＞、＜、≧、≦）に対応する (compareTo) Comparable インタフェース（の compareTo() メソッド）を実装したクラスは、そのクラスのインスタンス同士を &gt; や &lt; などの比較演算子で比較できるようになります。 比較演算子の呼び出しは、Kotlin コンパイラによって compareTo() メソッドの呼び出しに置き換えられるため、Comparable インタフェースを実装していないクラスのインスタンスを比較しようとするとコンパイルエラーになります。 Comparable インタフェースの実装は、コレクションクラスのソート系メソッドでも利用されます。 compareTo() の実装例 次のコードでは、複素数クラス Complex に Comparable インタフェースを実装し、オブジェクト同士の大小比較を行えるようにしています。 複素数同士の大小比較はナンセンスですが、ここでは、実数部→虚数部の順で比較することにします。 data class Complex(val re: Int, val im: Int) : Comparable&lt;Complex&gt; { override fun compareTo(other: Complex): Int { return if (re == other.re) { im - other.im } else { re - other.re } } } fun main() { val c1 = Complex(1, 2) val c2 = Complex(2, 1) val c3 = Complex(1, 3) println(c1 &lt; c2) // =&gt; true println(c1 &gt; c2) // =&gt; false println(c1 &lt;= c3) // =&gt; true } Kotlin の Char クラスや String クラスも Comparable インタフェースを実装しているので、下記のような大小比較が可能になっています。 println(&#39;A&#39; &lt; &#39;B&#39;) // =&gt; true println(&#34;AAA&#34; &lt; &#34;BBB&#34;) // =&gt; true compareValuesBy() による実装の簡素化 ちなみに、上記の比較関数 (compareTo()) では re → im プロパティの順に値を比較していますが、このような定型処理は下記のように、Kotlin の compareValuesBy() 関数を使って簡単に記述することができます。 override fun compareTo(other: Complex): Int { // this と other を、re フィールド → im フィールドの順に比較する return compareValuesBy(this, other, Complex::re, Complex::im) } コレクション系クラスのソート sort と sorted コレクション（List、Set、Array など）に格納された要素が Comparable インタフェースを実装していれば、sort() メソッドや sorted() メソッドを使ってソートすることができます。 data class Complex(val re: Int, val im: Int) : Comparable&lt;Complex&gt; { override fun compareTo(other: Complex): Int { return compareValuesBy(this, other, Complex::re, Complex::im) } } fun main() { val list = listOf( Complex(4, 2), Complex(1, 3), Complex(2, 5) ) val sorted1 = list.sorted() // 昇順ソート val sorted2 = list.sortedDescending() // 降順ソート println(sorted1) println(sorted2) } 実行結果 [Complex(re=1, im=3), Complex(re=2, im=5), Complex(re=4, im=2)] [Complex(re=4, im=2), Complex(re=2, im=5), Complex(re=1, im=3)] sorted 系メソッドが上記のように、ソート結果を戻り値で返すのに対し、sort 系メソッドは自分自身のリストを書き換えます（リスト生成に listOf ではなく mutableListOf を使う必要があります）。 fun main() { val list = mutableListOf( Complex(4, 2), Complex(1, 3), Complex(2, 5) ) list.sort() // 昇順ソート（自分自身を書き換え） println(list) list.sortDescending() // 降順ソート（自分自身を書き換え） println(list) } いろんな条件でソートする (sortBy, sortWith) 状況によって異なるルールでソートしたいときは、sortBy (sortedBy)、sortWith (sortedWith) などのメソッドを使い、パラメータでソートルールを指定します。 特定のフィールドの値でソートしたいときは、sortBy (sortedBy) を使うのが簡単です。 フィールドは、メンバー参照 の形で指定できます。 data class Book(val title: String, val price: Int) fun main() { val books = listOf( Book(&#34;Title3&#34;, 1500), Book(&#34;Title1&#34;, 2000), Book(&#34;Title2&#34;, 1000) ) val booksInTitleOrder = books.sortedBy(Book::title) // title 順にソート val booksInPriceOrder = books.sortedBy { it.price } // price 順にソート println(booksInTitleOrder) println(booksInPriceOrder) } 複数のフィールドの値を使った、もう少し複雑なソートを行いたい場合は、sortWith (sortedWith) メソッドに Comparator オブジェクトを渡します。 data class Book(val title: String, val price: Int) { companion object { /** 価格、タイトルの順でソートするための比較関数 */ val PRICE_ORDER = Comparator&lt;Book&gt; { b1, b2 -&gt; if (b1.price != b2.price) { b1.price - b2.price } else { b1.title.compareTo(b2.title) } } } } fun main() { val books = listOf( Book(&#34;Title3&#34;, 1500), Book(&#34;Title1&#34;, 2000), Book(&#34;Title2&#34;, 1000) ) val booksInPriceOrder = books.sortedWith(Book.PRICE_ORDER) println(booksInPriceOrder) } Kotlin は、Comparator オブジェクトを生成するためのユーティリティメソッド compareBy を提供しているので、上記の PRICE_ORDER オブジェクトは次のように簡単に生成できます。 data class Book(val title: String, val price: Int) { companion object { /** 価格、タイトルの順でソートするための比較関数 */ val PRICE_ORDER: Comparator&lt;Book&gt; = compareBy(Book::price, Book::title) } } もちろん、sortWith (sortedWith) メソッドを呼び出すときに、動的に Comparator オブジェクトを生成することもできます。 val booksInPriceOrder = books.sortedWith(compareBy(Book::price, Book::title))"},{url:"/p/6qamkcy/",title:"Kotlinメモ: infix 記法で関数呼び出し時の記述を簡略化する (to)",date:"2020-01-16T00:00:00+09:00",body:"Kotlinメモ: infix 記法で関数呼び出し時の記述を簡略化する (to) infix 呼び出し記法 Kotlin には、「infix 記法 (infix notation)」 と呼ばれる、特別なメソッドコールの構文が用意されています。 「infix 呼び出し (infix call)」や「中置記法」などと呼ばれることもあります。 例えば、次のように Map オブジェクトを生成するときに使用する to 関数などが infix 呼び出しできるように定義されています。 val map = mapOf(&#34;one&#34; to 1, &#34;two&#34; to 2, &#34;three&#34; to 3) println(map[&#34;one&#34;]) //=&gt; 1 infix とは「接中辞」のことで、上記の例では、to がちょうど間に挟まる形になるのでこう呼ばれています。 この to 関数は、ジェネリックな関数として次のように定義されています。 infix fun &lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that) つまり、to 関数は Pair オブジェクトを生成するためのユーティリティ関数です。 val pair = &#34;one&#34; to 1 //=&gt; Pair(&#34;one&#34;, 1) この to 関数は本来は下記のように、ドットや括弧を付けたメソッド呼び出しの形で呼び出さなければならないはずですが、関数の先頭に infix を付けて定義してあると、ドットや括弧を省略した「infix 記法」で呼び出せるようになります。 val pair1 = &#34;one&#34;.to(1) // 通常のメソッド呼び出し記法 val pair2 = &#34;one&#34; to 1 // infix 呼び出し記法 ちなみに、Map オブジェクトを生成する mapOf() 関数は次のように定義されており、任意の数の Pair オブジェクトをパラメータとして受け取るようになっています。 public fun &lt;K, V&gt; mapOf(vararg pairs: Pair&lt;K, V&gt;): Map&lt;K, V&gt; 最初のコード例では、これに渡す Pair 引数を生成するために、infix 関数である to 関数を利用しているということです。 infix 関数を定義するときの制約 infix キーワードは、クラスのメソッドや、拡張関数を定義するときに付加することができますが、infix キーワードを付けられる関数には下記のような制約があります。 1 つのパラメータしか受け取れない デフォルト引数 (=) は扱えない 可変長引数 (vararg) は扱えない これは、1 レシーバー 1 引数の形になる記述方法を想定しているためです。 infix 関数の例 CharSequence クラスには matches() という infix 関数が定義されており、文字列が指定した正規表現に一致するかどうかを調べることができます。 infix fun CharSequence.matches(regex: Regex): Boolean val text = &#34;2020-01-16&#34; val pattern = &#34;&#34;&#34;\\d{4}-\\d{2}-\\d{2}&#34;&#34;&#34;.toRegex() println(text matches pattern) //=&gt; true 少しだけ英語風に読めるようになりますが、これくらいだったら次のような通常の呼び出し方でも充分読みやすいので、まぁどちらでもいいかなという感じですね。 text.matches(pattern) Kotlin でもっとも infix 呼び出しが活用されているのは、前述の to 関数による Map 要素の初期化や、次のような for ループでの数値処理かと思います。 for (i in 1 until 5) //=&gt; for (i in 1.until(5)) for (i in 5 downTo 1) //=&gt; for (i in 5.downTo(1)) for (i in 1 until 5 step 2) //=&gt; for (i in 1.until(5).step(2)) for (i in 5 downTo 1 step 2) //=&gt; for (i in 5.downTo(1).step(2)) これは、前者の infix 呼び出しの形式の方が明らかに読みやすいです。 参考（分解宣言） 上記で説明した to 関数は、2 つの値から Pair オブジェクトを作成するのに便利でした。 Kotlin には、これとは逆に、Pair オブジェクトから 2 つの値を別々の変数に取り出す構文（分解宣言）が用意されています。 分解宣言 (destructuring declarations) による Pair 要素や Triple 要素の分解"},{url:"/p/rtajezj/",title:"Kotlinメモ: インデックス演算子を定義して配列のようにアクセス可能なクラスを作る (index operator)",date:"2020-01-16T00:00:00+09:00",body:"Kotlinメモ: インデックス演算子を定義して配列のようにアクセス可能なクラスを作る (index operator) インデックス演算子の実体は set と get コレクション系のクラスでは、[] を使ったインデックス指定（キー指定）による要素へのアクセスが可能になっていると便利です。 例えば、Kotlin の配列やリストは次のように要素を参照することができます。 val value = arr[index] // get する場合 arr[index] = value // set する場合 このようなインデックスアクセスを可能にするには、そのクラスに インデックス演算子 (index operator) を定義します。 コード上で [] によるインデックスアクセスを行うと、内部的には次のように get() メソッドや set() メソッドが呼び出されます。 コード上の記述 こう呼び出される value = arr[i] value = arr.get(i) arr[i] = value arr.set(i, value) つまり、実際にインデックス演算子として定義すべきメソッドの名前は get() や set() です。 get 用のインデックス演算子を定義する 次の Pos クラスでは、インデックス指定によるプロパティ参照を可能にするための get() 関数を定義しています。 演算子のオーバーロードなので、関数定義の先頭に operator キーワードを付けるのを忘れないでください。 data class Pos(val x: Double, val y: Double) { operator fun get(index: Int): Double = when(index) { 0 -&gt; x 1 -&gt; y else -&gt; throw IndexOutOfBoundsException(&#34;Invalid index $index&#34;) } } fun main() { val pos = Pos(1.5, 2.5) println(pos[0]) //=&gt; 1.5 println(pos[1]) //=&gt; 2.5 println(pos[2]) //=&gt; Exception println(pos[&#34;x&#34;]) //=&gt; Compile Error } 上記の例では、get() のパラメータを Int 型にしましたが、任意の型で定義することができます。 次の例では、Int 型の代わりに String 型を使用して定義しています。 data class Pos(val x: Double, val y: Double) { operator fun get(key: String): Double = when(key) { &#34;x&#34; -&gt; x &#34;y&#34; -&gt; y else -&gt; throw IndexOutOfBoundsException(&#34;Invalid index $key&#34;) } } fun main() { val pos = Pos(1.5, 2.5) println(pos[&#34;x&#34;]) //=&gt; 1.5 println(pos[&#34;y&#34;]) //=&gt; 2.5 println(pos[&#34;z&#34;]) //=&gt; Exception println(pos[100]) //=&gt; Compile Error } 演算子は拡張関数として追加することもできるので、3rd パーティ製のライブラリが提供しているクラスなどに、後付けする形でインデックス演算子を追加できます。 // このクラスは外部ライブラリとして提供されていて修正できないとする data class Pos(val x: Double, val y: Double) // 拡張関数を追加して [] によるインデックスアクセスを可能にする operator fun Pos.get(index: Int): Double { /* ... */ } set 用のインデックス演算子を定義する 値をセット（代入）するためのインデックス演算子 (set) も同様に定義することができます。 当然ですが、値を保持するための内部的なフィールドは mutable な型で定義しておく必要があります。 次の MutablePos クラスは前述の Pos クラスと似ていますが、フィールドの x、y の値を後から変更できるように、val 定義から var 定義に変えています。 data class MutablePos(var x: Double, var y: Double) { operator fun set(index: Int, value: Double) { when (index) { 0 -&gt; x = value 1 -&gt; y = value else -&gt; throw IndexOutOfBoundsException(&#34;Invalid index $index&#34;) } } } fun main() { val pos = MutablePos(1.5, 2.5) pos[0] = 1.2345 println(pos) //=&gt; MutablePos(x=1.2345, y=2.5) } Kotlin の Map と MutableMap の例 Java の Map オブジェクトから要素を取得するには、map.get(key) のように、get と明示的に記述する必要がありました。 これに比べ、Kotlin の Map では、map[key] のような簡潔な記述ができるようになっています。 これは、Kotlin の Map インタフェースで、次のようなインデックス演算子が定義されているからです。 public interface Map&lt;K, out V&gt; { // ... public abstract operator fun get(key: K): V? } public inline operator fun &lt;K, V&gt; MutableMap&lt;K, V&gt;.set(key: K, value: V): Unit { put(key, value) } 複数のパラメータを取るインデックス演算子を定義する 多次元配列的なコレクションクラスを作る場合、インデックス演算子のパラメータ数も複数にすることができます。 例えば、2 次元行列を表現する Matrix クラスであれば、各要素を参照するときに、obj[1, 2] のように行インデックスと列インデックスを指定してアクセスできます。 class Matrix() { operator fun get(row: Int, col: Int): Int { // 実際は保持しているフィールドの値を返すように実装する return 1000 + row + col } } fun main() { val mat = Matrix() println(mat[2, 4]) //=&gt; 1006 } set の定義もほぼ同様ですが、最後のパラメータで代入する値を受け取ります。 class MutableMatrix() { operator fun set(row: Int, col: Int, value: Int) { // 実際は保持しているフィールドの値を変更する println(&#34;$row 行 $col 列の値を $value に変更します&#34;) } } fun main() { val mat = MutableMatrix() mat[2, 4] = 100 }"},{url:"/p/fr4jjf6/",title:"Kotlinメモ: 分解宣言 (destructuring declarations) による Pair 要素や Triple 要素の分解",date:"2020-01-16T00:00:00+09:00",body:"Kotlinメモ: 分解宣言 (destructuring declarations) による Pair 要素や Triple 要素の分解 Pair クラスと Triple クラス Kotlin は 2 つの値、あるいは 3 つの値を保持するための簡易クラスとして、Pair クラスと Triple クラスを用意しています。 Pair オブジェクトの 1 番目と 2 番目の要素には、それぞれ first、second というプロパティでアクセスできます。 val pair = &#34;one&#34; to 1 // Pair(&#34;one&#34;, 1) と同じ println(pair.first) //=&gt; &#34;one&#34; println(pair.second) //=&gt; 1 この例のように、Pair オブジェクトを生成するときは to という中置関数（infix function）を使うと簡潔に記述できます（参考: infix 記法 (infix notation)）。 Triple オブジェクトの要素も同様に、first、second、third というプロパティでアクセスできます。 val triple = Triple(&#34;one&#34;, &#34;two&#34;, &#34;three&#34;) println(triple.first) //=&gt; &#34;one&#34; println(triple.second) //=&gt; &#34;two&#34; println(triple.third) //=&gt; &#34;three&#34; 分解宣言でオブジェクトの各プロパティを別々の変数に代入する Kotlin の 分解宣言 (destructuring declarations) と呼ばれている形で変数を定義すると、オブジェクトの各プロパティが保持している値を、別々の変数に一度に代入することができます。 分解宣言の方法は簡単で、代入文の左辺に複数の変数を括弧で囲んで記述するだけです。 次の例では、Pair オブジェクトの first プロパティと second プロパティの値を、それぞれ x、y という変数に取り出しています。 val pair = 100 to 200 // Pair(100, 200) と同じ val (x, y) = pair // 分解宣言で代入 println(x) //=&gt; 100 println(y) //=&gt; 200 Triple オブジェクトに関しても同様です。 val triple = Triple(100, 200, 300) val (x, y, z) = triple Pair オブジェクトを使って多値関数を実現する 関数が Pair や Triple を戻り値として返す場合も同様に、複数の変数に直接代入してしまうことができます。 これは、あたかも 複数の戻り値を返す関数（多値関数） のように振る舞います。 // 簡易的な多値関数 fun getPosition(): Pair&lt;Int, Int&gt; = 100 to 200 // 返された Pair の各プロパティを別々の変数で受け取る val (x, y) = getPosition() println(x) //=&gt; 100 println(y) //=&gt; 200 ただし、このように関数の戻り値を分解宣言で受け取るときは、変数の順序を間違えないように注意する必要があります。 例えば、次のように変数の名前を逆にしてしまうと、見つけにくい不具合になります。 val (y, x) = getPosition() なので、Pair オブジェクトを多値関数の実装のために使用するのは、どちらかというとアンチパターンになります。 Kotlin ではデータクラスを簡単に定義することができるので、通常は次のように戻り値を表す型を定義してしまった方が安全です。 data class Position(val x: Int, val y: Int) fun getPosition(): Position = Position(100, 200) val pos: Position = getPosition() val (x, y) = getPosition() 最終行では、前述の例と同様に分解宣言による代入を行っていますが、変数の名前を逆転させてしまった場合には、IDE（開発環境）が警告メッセージを表示してくれるので、不具合が入る可能性がグッと下がります。 分解宣言の仕組み データクラスによる componentN の自動実装 val triple = Triple(100, 200, 300) val (x, y, z) = triple 上記のような分解宣言は、内部的には実は下記のような conponentN 関数呼び出しとして処理されます（実際にこのように記述しても動作します）。 val triple = Triple(100, 200, 300) val x = triple.component1() val y = triple.component2() val z = triple.component3() このように振舞うためには、Triple クラスが componentN というメソッドを提供していなければいけないはずですが、Triple クラスの定義を見てもそれらしき実装は見当たりません。 public data class Triple&lt;out A, out B, out C&gt;( public val first: A, public val second: B, public val third: C ) 実は、Kotlin では、クラスをデータクラスとして定義すると、そのプロパティにアクセスするための componentN オペレータ関数を自動的に定義してくれるようになっています。 つまり、 データクラスのプロパティはデフォルトで分解宣言による代入が可能 です。 分解宣言の代表的な使用例として、コレクション系クラスの withIndex() 関数があります。 val arr = arrayOf(&#34;one&#34;, &#34;two&#34;, &#34;three&#34;) for ((index, value) in arr.withIndex()) { println(&#34;$index -&gt; $value&#34;) } 実行結果 0 -&gt; one 1 -&gt; two 2 -&gt; three withIndex() 関数は、IndexedValue というクラスのオブジェクトを順番に返すのですが、このクラスもデータクラスとして定義されているので、そのプロパティ (index と value) を分解宣言で取り出せるというわけです。 data class IndexedValue&lt;out T&gt;(public val index: Int, public val value: T) データクラス以外の componentN の実装 データクラス以外のオブジェクトを分解宣言の右辺に置けるようにするには、componentN 系のメソッドを自力で実装する必要があります。 次のコードは Map の要素をループ処理する例ですが、ここで key と value のペアを取り出すときも分解宣言の仕組みが利用されています。 val map = mapOf(1 to &#34;one&#34;, 2 to &#34;two&#34;) for ((key, value) in map) { println(&#34;$key -&gt; $value&#34;) } Map および Map.Entry は、データクラスではなくインタフェースなので、componentN 系のメソッドが実装されておらず、そのままでは分解宣言の右辺には置くことができません。 そこで、Kotlin の標準ライブラリでは、Map インタフェースと Map.Entry インタフェースを次のように拡張し、分解宣言を利用したループ処理を可能にしています。 inline operator fun &lt;K, V&gt; Map&lt;out K, V&gt;.iterator(): Iterator&lt;Map.Entry&lt;K, V&gt;&gt; = entries.iterator() inline operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component1(): K = key inline operator fun &lt;K, V&gt; Map.Entry&lt;K, V&gt;.component2(): V = value つまり、上述のループ処理は、次のようなコードと等価になります。 for (entry in map.entries) { val key = entry.component1() val value = entry.component2() println(&#34;$key -&gt; $value&#34;) }"},{url:"/p/c2f65zt/",title:"Kotlinメモ: 可変長引数をとる関数を定義する (vararg)",date:"2020-01-16T00:00:00+09:00",body:"Kotlinメモ: 可変長引数をとる関数を定義する (vararg) Kotlin の可変長引数は vararg キーワード Kotlin で可変長引数 (variable-length arguments) を表現するには、vararg キーワードを使用します。 例えば、List を生成するファクトリ関数である listOf は次のように定義されています。 fun &lt;T&gt; listOf(vararg elements: T): List&lt;T&gt; { elements.forEach { /* ... */ } } listOf 関数のパラメータには vararg が付けられているため、次のように任意の数の引数を渡すことができます。 val list = listOf(1, 2, 3, 4 ,5) ちなみに、Java で可変長引数を定義するときは、3 つのドット (...) を使っていました。 Java でも Kotlin でも、関数の実装側では配列と同様に扱うことができます。 Java の例 public void show(Integer... args) { for (Integer x: args) { /* ... */ } } vararg を使った関数を実装する 下記は、任意の数の String 引数を受け取ることのできる関数の定義例です。 可変長引数として定義したパラメータは、配列型のオブジェクトとして参照することができるので、forEach 関数などを使ってループ処理することができます（ここでは strings パラメータは Array&lt;String&gt; として扱えます）。 fun show(vararg strings: String) { strings.forEach { // 配列のループで処理できる println(it) } if (!strings.isEmpty()) { print(strings[0]) // もちろんインデックスアクセスも可能 } } 呼び出すときは、0 個以上の任意の数の引数を渡すことができます。 show() show(&#34;A&#34;) show(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) 配列をアンパックして vararg パラメータに渡す（スプレッド演算子） Java の可変長パラメータには配列をそのまま渡すことができましたが、Kotlin の場合は配列をアンパック（展開）してから渡す必要があります。 配列をアンパックするには、スプレッド演算子 (spread operator) の * を使用します。 val arr: Array&lt;String&gt; = arrayOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) val list = listOf(*arr) println(list) //=&gt; [A, B, C] 配列をアンパックせずに、次のようにそのまま listOf() 関数に渡してもコンパイルエラーにはなりませんが、この場合は 1 つの配列を要素に持つ List オブジェクトが生成されてしまいます。 val list = listOf(arr) println(list) //=&gt; [[Ljava.lang.String;@1be6f5c3] 可変長引数とスプレッド演算子の組み合わせは強力で、次のように、任意の位置で配列をアンパックすることができます。 val arr: Array&lt;String&gt; = arrayOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) val list = listOf(&#34;XXX&#34;, *arr, &#34;YYY&#34;) println(list) //=&gt; [XXX, A, B, C, YYY]"},{url:"/p/mxhzgwd/",title:"Hugo で大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing)",date:"2020-01-15T00:00:00+09:00",body:"Hugo で大きな画像ファイルから自動的に小さなサムネイル画像を生成する (Image Processing) Image Processing 機能とは Hugo の Image Processing 機能 を使用すると、ページにバンドル した 1 枚の画像ファイルを加工し、サムネイル画像などを自動的に生成することができます。 例えば、デジカメで撮影した写真をウェブサイト上に掲載する場合、直接画像を貼り付けるとサイズが大きいため、小さなサムネイル画像からのリンクを用意することが多いと思います。 このような場合に、Image Processing 機能を使用すれば、サムネイル画像を手動で作成する手間をなくすことができます。 Image Processing の使用例 ここでは、下記のように、books セクションページ内に sample.png というリソースが含まれているとします。 content/ books/ _index.md sample.png Image Processing の機能を使って画像の変換を行うには、Page Resources のオブジェクト を取得する必要があります（Page 変数ではないので注意）。 このオブジェクトは、Page 変数 の次のようなプロパティ、およびメソッドを使って取得することができます。 .Resources（バンドルされたすべてのリソースを参照する） .Resources.ByType（指定した種類のリソースだけ取り出す） 例: $resources := .Resources.ByType &quot;image&quot; .Resources.Match（ファイル名のパターンに一致するリソースだけ取り出す） 例: $resources := .Resources.Match &quot;sample.png&quot; 例: $resources := .Resources.Match &quot;**.png&quot; 例: $resources := .Resources.Match &quot;images/**.png&quot; これらのメソッドは Markdown ファイル内から直接呼び出すことはできないので、実際にはショートコードやテンプレートファイルから利用することになります。 例えば、次のようなショートコードを作成しておけば、元の画像ファイルがどのようなサイズであっても、強制的に 150x150 のサイズのサムネイル画像を生成して表示してくれます。 layouts/shortcodes/thumbnail.html {{- $src := .Get &#34;src&#34; }} {{- $imageRes := .Page.Resources.GetMatch $src }} {{- $imageRes := $imageRes.Fill &#34;150x150&#34; }} {{- $imageUrl := $imageRes.RelPermalink }} &lt;img src=&#34;{{ $imageUrl }}&#34; alt=&#34;{{ $src }}&#34; /&gt; ショートコードから .Resources オブジェクトを参照するときは、上記のように .Page.Resources としなければいけないことに注意してください。 この thumbnail ショートコードは、Markdown ファイル内からは次のように利用します。 content/books/_index.md --- title: &#34;タイトル&#34; date: &#34;2020-01-15&#34; --- {{&lt; thumbnail src=&#34;sample.png&#34; &gt;}} ここでは、Fill メソッドで生成する画像ファイルのサイズを 150x150 で固定していますが、ショートコードのパラメータで指定できるようにしてもよいでしょう。 ちなみに自動生成されるサムネイル画像の URL は次のような感じのランダムな文字列になるようです。 /books/sample_d74hu175c61ccf69bf5f1995b2e27ba4cd_111429_150x150_fill_q75_box_smart1.png Image Processing 用の関数は、Fill メソッド以外にも色々あるので、ざっと目を通しておくとよいでしょう。 下記に、Resize、Fit、Fill メソッドの使用例を示しておきます。 幅x高さを 200x150 にする（アスペクト比は考慮されないので、歪んだ画像になるかもしれない） $img = $resource.Resize &quot;200x150&quot; アスペクト比を保って幅が 200px になるよう拡大縮小する $img = $resource.Resize &quot;200x&quot; アスペクト比を保って高さが 150px になるよう拡大縮小する $img = $resource.Resize &quot;x150&quot; アスペクト比を保って幅x高さが大きくても 200x150 に収まるようにする（最終的な画像サイズはどちらか一辺が指定したサイズより小さくなるかもしれない） $img = $resource.Fit &quot;200x150&quot; アスペクト比を保って幅x高さがちょうど 200x150 になるようにする（アスペクト比が変わる場合、画像の中央当たりだけが見えるような画像になる） $img = $resource.Fill &quot;200x150&quot; 他にも、背景色を指定したり、回転させたり、JPEG のクオリティを調整したりと、色々なオプションが用意されています。 Facebook などで Web ページをシェアする場合は、画像ファイルの中央部分しか表示されなかったりしますね（OGP という仕組みが使われる）。 この振舞いは、上記の Fill メソッドの動きに似ているので、サムネイル用のショートコードを作成するときは、Fill メソッドを使用するのがよいかもしれません。 サムネイル画像をクリックしたときに元の画像ファイルを表示する おまけのショートコードサンプルです。 この image ショートコードを使用して画像を表示すると、指定したサイズに縮小した画像を表示しつつ、画像をクリックすることで元の大きいサイズの画像を表示することができます。 layouts/shortcodes/image.html {{- $src := .Get &#34;src&#34; }} {{- $title := .Get &#34;title&#34; }} {{- $width := .Get &#34;w&#34; }} {{- $size := printf &#34;%sx&#34; $width }} {{- $res := .Page.Resources.GetMatch $src }} {{- $image := $res.Resize $size }} {{- $imageUrl := $image.RelPermalink }} &lt;figure&gt; &lt;a href=&#34;{{ $src }}&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;{{ $imageUrl }}&#34; alt=&#34;{{ $src }}&#34; /&gt; &lt;/a&gt; {{- with $title }} &lt;figcaption&gt;図: {{ . }}&lt;/figcaption&gt; {{- end }} &lt;/figure&gt; Markdown ファイルの中からは次のように呼び出します。 content/books/_index.md {{&lt; image w=&#34;200&#34; src=&#34;sample.jpg&#34; title=&#34;タイトル&#34; &gt;}} 上記のショートコードでは、figure タグと figcaption を使って、画像のタイトルも表示できるようにしています。 ショートコードのパラメータで title=&quot;タイトル&quot; のように指定すると、画像の下にタイトルが表示されます。 また、アスペクト比を保ったまま画像を縮小表示することを想定しているため、サイズ指定は横幅だけを指定できるようにしています（ショートコードのパラメータで w=&quot;200&quot; のように単位なしで指定します）。 応用1: w パラメータをオプショナルにしたバージョン 下記はもう少し改良したバージョンの image ショートコードで、w パラメータが省略された場合に、src で指定した画像ファイルをそのまま使用するようにしています。 layouts/shortcodes/image.html {{- $src := .Get &#34;src&#34; }} {{- $title := .Get &#34;title&#34; }} {{- $width := .Get &#34;w&#34; }} {{- $imageUrl := $src }} {{- $res := .Page.Resources.GetMatch $src }} {{- /* ページまたぎでリンク切れを防ぐおまじない */}} {{- if $res }} {{- $src = $res.RelPermalink }} {{- $imageUrl = $res.RelPermalink }} {{- end }} {{- if $width }} {{- $size := printf &#34;%sx&#34; $width }} {{- $image := $res.Resize $size }} {{- $imageUrl = $image.RelPermalink }} {{- end }} &lt;figure&gt; &lt;a href=&#34;{{ $src }}&#34; target=&#34;_blank&#34;&gt; &lt;img src=&#34;{{ $imageUrl }}&#34; alt=&#34;{{ $src }}&#34; /&gt; &lt;/a&gt; {{- with $title }} &lt;figcaption&gt;図: {{ . }}&lt;/figcaption&gt; {{- end }} &lt;/figure&gt; 応用2: SVG ファイルに対応する SVG ファイルは Image Processing 機能に対応していないので、同じコードで width 調整しようとすると、次のようなエラーになってしまいます。 error calling Resize: *resources.genericResource is not an image 下記の image ショートコードは、src パラメータで指定されたファイルの拡張子が svg だった場合に、Image Processing 機能を使わず、style 属性を使って横幅を指定するようにしています。 {{- $src := .Get &#34;src&#34; }} {{- $title := .Get &#34;title&#34; }} {{- $width := .Get &#34;w&#34; }} {{- $imageUrl := $src }} {{- $res := .Page.Resources.GetMatch $src }} {{- /* ページまたぎでリンク切れを防ぐおまじない */}} {{- if $res }} {{- $src = $res.RelPermalink }} {{- $imageUrl = $res.RelPermalink }} {{- end }} {{- $isSvg := strings.HasSuffix $src &#34;svg&#34; }} {{- if and $width (not $isSvg) }} {{- $size := printf &#34;%sx&#34; $width }} {{- $image := $res.Resize $size }} {{- $imageUrl = $image.RelPermalink }} {{- end }} &lt;figure&gt; &lt;a href=&#34;{{ $src }}&#34; target=&#34;_blank&#34;&gt; &lt;img {{ if $isSvg }}style=&#34;width:{{ $width }}px;&#34;{{ end }} src=&#34;{{ $imageUrl }}&#34; alt=&#34;{{ $src }}&#34; /&gt; &lt;/a&gt; {{- with $title }} &lt;figcaption&gt;図: {{ . }}&lt;/figcaption&gt; {{- end }} &lt;/figure&gt;"},{url:"/p/u32ykpo/",title:"Kotlinメモ: reified でジェネリクスの型情報を維持する",date:"2019-12-27T00:00:00+09:00",body:"Kotlinメモ: reified でジェネリクスの型情報を維持する 具体化型パラメータ (reified type parameters) Java の頃から変わっていませんが、ジェネリクスの型引数で指定した型情報は、コンパイル時にイレイジャ (erasure) によって削除されます。 つまり、実行時にその型情報を参照することはできません。 これは、JVM の仕組みによるもので、erased at runtime と呼ばれたりします。 Kotlin では、reified type parameter という機能を使うことで、型引数で指定した型情報を残すことができます。 例えば、次のように、いろいろな型の要素を含んだリストから、指定した型の要素だけを取り出すためのジェネリック関数 filterByType() を作りたいとします。 val list = listOf(1, &#34;A&#34;, 2, &#34;B&#34;) val intList = filterByType&lt;Int&gt;(list) println(intList) //=&gt; [1, 2] val strList = filterByType&lt;String&gt;(list) println(strList) //=&gt; [&#34;A&#34;, &#34;B&#34;] この filterByType() 関数は、次のような感じで実装できそうな気がします。 間違ったコード fun &lt;T&gt; filterByType(list: List&lt;*&gt;): List&lt;T&gt; { val result = mutableListOf&lt;T&gt;() list.forEach { // ERROR: cannot check for instance of erased type: T if (it is T) result.add(it) } return result } しかし、ジェネリクスの型情報はイレイジャによってコンパイル時に失われるため、if (it is T) という実行時の型判定を行うことができません。 T という型情報は、コンパイル時の整合性の確認には活用されますが、実行時には役に立たないということです。 そこで、reified の出番です。 Kotlin では、上記の関数を inline で定義し、さらに型パラメータに reified キーワードを付ける ことにより、実行時まで型情報が残され、うまく動作するようになります。 正しいコード inline fun &lt;reified T&gt; filterByType(list: List&lt;*&gt;): List&lt;T&gt; { val result = mutableListOf&lt;T&gt;() list.forEach { if (it is T) result.add(it) } return result } 仕組みとしては、型情報を伴ったコードがその場にインライン展開されるため、型の判定も正しく行えるということのようです。 reified の使用例 Kotlin の filterIsInstance Kotlin の標準ライブラリでは、下記のような拡張関数が定義されていたりします。 fun &lt;reified R&gt; Array&lt;*&gt;.filterIsInstance(): List&lt;R&gt; fun &lt;reified R&gt; Iterable&lt;*&gt;.filterIsInstance(): List&lt;R&gt; 次のようにすると、リストに含まれる Int 要素を抽出することができます。 val list = listOf(1, &#34;A&#34;, 2, &#34;B&#34;) val intList = list.filterIsInstance&lt;Int&gt;() println(intList) //=&gt; [1, 2] 参考: filterIsInstance - Kotlin Programming Language Android の startActivity reified type parameter として渡した型情報から、直接コンストラクタを呼び出すことはできませんが、その型の java.lang.Class オブジェクトは T::class.java という形で取得することができます。 下記の Context クラスの拡張関数は、Class オブジェクトを指定する代わりに、型引数で指定したクラス名を使って Intent オブジェクトを生成しています。 inline fun &lt;reified T : Activity&gt; Context.startActivity() { startActivity(Intent(this, T::class.java)) } これを利用すると、次のように簡潔な形で Activity を起動することができます。 startActivity&lt;MyActivity&gt;()"},{url:"/p/mju5eox/",title:"Hugo で Markdown ファイルに記述した HTML コードが削除されてしまう場合",date:"2019-12-26T00:00:00+09:00",body:"Hugo で Markdown ファイルに記述した HTML コードが削除されてしまう場合 Goldmark 化による弊害 Hugo v0.60.0 から Markdown パーサーとして Goldmark が採用され、Markdown の解釈が微妙に変わっています。 Now CommonMark Compliant! - Hugo 例えば、今までは .md ファイル内に記述した HTML コードはそのまま出力されていたのに、デフォルトで取り除かれるようになっています。 これまでに作成した記事で HTML タグを使用している場合はちょっと困ってしまいます。 Markdown ファイル内に HTML コードを記述できるようにする .md ファイルに記述した HTML コードを、これまで通り出力できるようにするには、Hugo の設定ファイルで次のように指定します。 hugo.toml（TOML フォーマットの場合） [markup.goldmark.renderer] unsafe = true hugo.yaml（YAML フォーマットの場合） markup: goldmark: renderer: unsafe: true もちろん、使用する Markdown パーサー自体を旧来の BlackFriday に設定するという方法もあります。 [markup] defaultMarkdownHandler = &#34;blackfriday&#34; ただ、Goldmark の方が高速に動作するようなので、前向きに Goldmark に乗り換えることを考えた方がよいでしょう。"},{url:"/p/ynv4ago/",title:"Hugo でドラフト指定したセクションが公開されてしまう場合",date:"2019-12-26T00:00:00+09:00",body:"Hugo でドラフト指定したセクションが公開されてしまう場合 Hugo のトラブルシューティングです（v0.62.0 で確認）。 ドラフトセクションが公開されてしまう問題 Hugo では、記事ページのフロントマターに、 draft: true という感じでドラフト指定を行なっておくと、hugo コマンドでページ生成するときに -D オプションを付けない限り、そのページは出力されなくなります。 しかし、セクションページに関しては、上記のように指定していても、必ず出力されてしまいます（v0.57 くらいからこんな振る舞いになってしまったような・・・）。 例えば、下記のようにトップレベルのセクションを一覧表示しようとすると、ドラフトのセクションまで出力されてしまいます。 &lt;ul&gt; {{ range .Site.Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; このあたりの振る舞いは下記で議論されていて、 Improve _index.md vs draft · Issue #6312 · gohugoio/hugo · GitHub 作者の bep 氏 (Bjørn Erik Pedersen) によると、下記の回答がすべてを表しているようです。 The original purpose of draft did not include section pages &ndash; as that was not a thing back then. （当初はドラフト機能はセクションページを対象にすることを考えていなかった） セクションをドラフトとしてマークできるようにした場合、その下にぶらさがるページはどう振舞うべきなんだ（一時的にそのセクション自体が存在しないものとしてセクション外に出すの？）とか、仕様が複雑になってしまうのであまり振る舞いを変えたくないという事情があるみたいです。 とは言っても、セクション全体をドラフトとして扱うという機能は需要があるはずです。 bep 氏もドラフトセクションの機能は検討すると言っているようなので、将来のバージョンに期待したいと思います。 ドラフトセクションを表示しない対策 ドラフト設定したセクションの出力を抑制する機能は今のところありませんが（2019年時点 v0.62.0）、少なくともセクションを列挙する際に自力でドラフトセクションを無視するようにすることは可能です。 次のサンプルでは、where 関数を使って、.Site.Sections に含まれるセクションの一覧から、.Draft プロパティが false であるものだけを抽出しています。 結果として、ドラフトではないセクションだけを列挙できます。 {{ range where .Site.Sections &#34;.Draft&#34; false }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} 次のように、各ページ（セクション）の .Draft 変数の値によって分岐させる方法もありますが、上記のように where 関数を使って最初にフィルタリングしてしまった方がネストが深くならなくてシンプルです。 {{ range .Site.Sections }} {{ if not .Draft }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} {{ end }} もちろん、上記のようにリンクを出力しないように制御しても、ドラフトセクションのページ自体（HTML ファイル）は生成されてしまうことに注意してください。 生成されているドラフトセクションを見落とさないようにするためには、Hugo をサーバーモードで起動したときに、ドラフトセクションのリンクも含めて出力するようにしておくとよいでしょう。 Hugo がサーバーモードで動作しているかどうかは、hugo.IsServer で確認できます。 {{/* サーバーモードではドラフトセクションも含めて表示 */}} {{ $sections := .Site.Sections }} {{ $filtered := cond hugo.IsServer $sections (where $sections &#34;.Draft&#34; false) }} {{ range $filtered }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} ここで使用している cond 関数は、C 言語の三項演算子のようなもので、最初のパラメータで指定した hugo.IsServer の値が true であれば 2 番目のパラメータの値を、false の場合は 3 番目のパラメータの値を返します。 よって、サーバーモード時は $filtered にドラフトを含むセクション一覧が格納され、リリース時はドラフトを除いたセクション一覧が格納されます。"},{url:"/p/irsz3gs/",title:"Kotlinメモ: ジェネリクスの共変 (covariant) と不変 (invariant) について理解する",date:"2019-12-20T00:00:00+09:00",body:"Kotlinメモ: ジェネリクスの共変 (covariant) と不変 (invariant) について理解する 共変である (covariant) とはどういうことか？ Kotlin の Int は Any として使用することができます（Any は Java で言うところの Object です）。 それでは、 List&lt;Int&gt; は List&lt;Any&gt; として扱うことができるでしょうか？ MutableList&lt;Int&gt; は MutableList&lt;Any&gt; として扱うことができるでしょうか？ その答えは、使用している Generic クラスが、その型パラメータに関して 共変である (covariant) か 不変であるか (invariant) によって決まります。 List&lt;Int&gt; は List&lt;Any&gt; として使える（List は共変である (= covariant)） MutableList&lt;Int&gt; は MutableList&lt;Any&gt; としては使えない（MutableList は共変ではない (= invariant)） 「Generic クラスが共変である」とは、型引数に指定した型の親子関係が、Generic クラスによって生成された型の親子関係と等しくなるということを意味します。 例えば、List&lt;E&gt; はその型パラメータ E に関して共変であり、List&lt;Int&gt; を List&lt;Any&gt; として扱うことが可能です（List&lt;Int&gt; は List&lt;Any&gt; のサブタイプとみなされます）。 List&lt;Int&gt; は List&lt;Any&gt; として扱える fun showElems(list: List&lt;Any&gt;) { for (e in list) { println(e) } } fun main() { val a = listOf(0, 1, 2) // List&lt;Int&gt; showElems(a) // OK! } 一方で、MutableList&lt;E&gt; は型パラメータ E に関して共変ではなく、MutableList&lt;Int&gt; は MutableList&lt;Any&gt; として扱うことができません。 まったく互換性のない型として扱われます。 なぜこのような差が出てくるのでしょうか？ 次のようなコードを考えると分かりやすいと思います。 MutableList&lt;Int&gt; は MutableList&lt;Any&gt; としては扱えない fun addElems(list: MutableList&lt;Any&gt;) { list.add(&#34;Hello&#34;) list.add(&#34;World&#34;) } fun main() { val a = mutableListOf(0, 1, 2) // MutableList&lt;Int&gt; addElems(a) // Compile Error! } 仮に上記のようなコードが合法とされてしまうと、MutableList&lt;Int&gt; 型のオブジェクトに、Int 以外の任意の要素を追加できることになってしまいます。 だから、MutableList&lt;E&gt; は型パラメータ E に関して共変ではない、と定義されているのです。 そのため、上記のようなコードはコンパイルエラーになります。 List&lt;Int&gt; の要素がより汎用的な Any として使われるだけであれば問題はなく、MutableList&lt;Int&gt; がより汎用的な型である Any を受け入れてしまうのは問題があるということです。 ややこしいですが、共変 (covariant) と不変 (invariant) は Kotlin のジェネリクスを扱う上で非常に大切な概念なので、もう一度まとめておきます。 A が B のサブタイプであるとき、List&lt;A&gt; は List&lt;B&gt; のサブタイプとなる。このような Generic クラスを 共変である (covariant) という。 A が B のサブタイプであったとしても、MutableList&lt;A&gt; は MutableList&lt;B&gt; のサブタイプにはならない。このような Generic クラスを 不変である (invariant) という（＝共変ではない）。 共変な Generic クラス (covariant class) を定義する ある型パラメータに関して共変な Generic クラスを定義するには、型パラメータに out キーワードを付けて定義します。 逆に何も修飾子を付けないで型パラメータを定義した場合は、その Generic クラスはデフォルトで不変 (invariant) になります。 class Holder&lt;out T&gt;(val elem: T) { fun get(): T = elem } 型パラメータに out を付けるということは、その Generic クラスの実装において、型パラメータを出力用としてしか使用しないという宣言でもあります。 出力用というのは、戻り値の位置のみでその型パラメータを使用するということです。 そのため、このようなクラスを producer と呼ぶことがあり、クラス名に Producer が使われたりします。 個人的にはそういった命名はサンプルコードとしては分かりにくいと思うので、ここでは Holder というクラス名にしています。 専門用語では、getter などの出力位置で使うことを out position で使用する、setter などの入力位置で使うことを in position で使用すると言います。 型パラメータに out を付けることができるのは、その型パラメータを out position でしか使用していない場合のみに限られます（正確には in position で使用しない場合）。 例えば、上記のサンプルコードでは、型パラメータ T を getter の戻り値 (out position) の型としてのみ使用しています（コンストラクタのパラメータでも使っていますが、コンストラクタの val パラメータは本質的には getter を定義するものであり、out position とみなされます）。 型パラメータ T は in position では一切使用していないので、out 修飾子を付加することができ、共変 (covariant) な Generic クラスとすることができます。 もし、次のように out を付けた型パラメータを in position で使ってしまうと、 class Holder&lt;out T&gt;(val elem: T) { fun dump(t: T) { ... } // ERROR } Type parameter T is declared as &#39;out&#39; but occurs in &#39;in&#39; position in type T といった感じのコンパイルエラーになります。 なぜなら、このような使い方を許してしまうと、先に示した MutableList の例のように、型の安全性が保てなくなってしまうケースが発生するからです。 さて、ここで、次のような継承関係のある Animal クラスと Bird クラスがあるとします。 Bird は Animal のサブタイプです。 open class Animal { fun eat() { println(&#34;EAT&#34;) } } class Bird : Animal() { fun fly() { println(&#34;FLY&#34;) } } そして、Holder&lt;Animal&gt; をパラメータに取る doEat 関数を次のように定義したとします。 fun doEat(holder: Holder&lt;Animal&gt;) { val animal = holder.get() animal.eat() } Holder クラスは共変なジェネリッククラスとして定義（型パラメータ T に out を付けて定義）されているので、Holder&lt;Bird&gt; オブジェクトは Holder&lt;Animal&gt; オブジェクトの代わりに使用することができます。 よって、次のように doEat 関数に、Holder&lt;Bird&gt; オブジェクトを渡すことができます。 val holder: Holder&lt;Bird&gt; = Holder(Bird()) doEat(holder) これが、class Holder&lt;out T&gt; のように、型パラメータに out を付けて定義した効果です。 もし、out を付けないで class Holder&lt;T&gt; と不変 (invariant) なクラスとして定義していると、doEat(holder) の呼び出しは、次のようなエラーになってしまいます。 Type mismatch: inferred type is Holder&lt;Bird&gt; but Holder&lt;Animal&gt; was expected Holder が共変になっていないので、Holder&lt;Bird&gt; と Holder&lt;Animal&gt; の間には何の互換性もないからです。 ただ、これには少しだけ抜け道があって、ジェネリッククラスを使用する側（ここでは doEat 関数を定義する場所）で、次のように out を付けて、「共変 (covariant) な型パラメータとして使用しますよ」と宣言してしまう方法があります。 fun doEat(holder: Holder&lt;out Animal&gt;) { val animal = holder.get() animal.eat() } これは、Holder クラス自体は共変として定義してないけれど、少なくともこの関数の実装では共変なクラスとして使いますよ（Holder&lt;Animal&gt; の代わりに Holder&lt;Bird&gt; を渡してもいいですよ）ということを示しています。 このように、ジェネリッククラスを利用する場所で型引数に out 修飾子を付けてしまう方法を、use-site variance（利用箇所分散） と呼びます。 詳しくは後述します。 Kotlin の List と MutableList の定義 では、Kotlin の List インタフェースと MutableList インタフェースの定義を見てみましょう。 interface List&lt;out E&gt; : Collection&lt;E&gt; { ... } interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; { ... } List インタフェースの型パラメータ E には out が付いており、MutableList インタフェースの方には付いていません。 よって、List は型パラメータ E に関して共変 (covariant) なジェネリッククラスであり、MutableList は不変 (invariant) なジェネリッククラスです。 型パラメータの out 修飾子は、多くの場合、ファクトリ系のクラスや、immutable なデータホルダー系クラスで使われることになります。 しかし、clear() のように、まったくパラメータを取らずにオブジェクトの内容を変更するメソッドもあり得るため、immutable なクラスのみが共変 (covariant) なクラスになれるというわけではなりません。 反変な Generic クラス (contravariant class) を定義する 共変 (covariant) に近い概念に、その反対の性質を持つ 反変 (contravariant) があります。 共変 (covariant) なジェネリッククラスから生成された型は、その型引数で指定した型の親子関係と同じ親子関係を持ちますが、反変 (contravariant) なジェネリッククラスから生成された型は、この親子関係が逆転します。 文章で書いても分かりにくいので、コードで見てみましょう。 まず、共変 (covarinat) のおさらいから。 共変な型パラメータは、out で修飾します。 interface List&lt;out E&gt; List&lt;Int&gt; は List&lt;Any&gt; のサブタイプになります。 次に、反変 (contravariant) の例です。 反変なインタフェースの代表例としてあげられるのが Comparator インタフェースです。 反変な型パラメータは、in で修飾します。 interface Comparator&lt;in T&gt; { fun compare(a: T, b: T): Int } Comparator&lt;Int&gt; は Comparator&lt;Any&gt; のスーパータイプになります。 言い換えると、Comparator&lt;Any&gt; が Comparator&lt;Int&gt; のサブタイプになります。 このあたりの親子関係が、共変 (covariant) のときと逆転しているため、反変 (contravariant) と呼びます。 なぜこのように親子関係が逆転するのでしょうか？ Comparator&lt;Any&gt; と Comparator&lt;Int&gt; の関係を考えてみましょう。 Comparator&lt;Int&gt; をパラメータとして受け取る関数には、Comparator&lt;Any&gt; オブジェクトを渡すことができます。 val anyComp = Comparator&lt;Any&gt; { a, b -&gt; a.hashCode() - b.hashCode() } val intList = mutableListOf(3, 1, 5) intList.sortWith(anyComp) なぜなら、Comparator&lt;Any&gt; の実装の中では Any インタフェースしか参照しないため、その実装を Int オブジェクト同士の比較に使用しても何ら問題はないからです。 in 修飾子を付けられる型パラメータは、in position でしか使われないものに限定されます（正確には、public メソッドの戻り値のような、out position では一切使われないもの）。 そのジェネリッククラスの中では、型パラメータを受け入れる（あるいは消費する）用途にしか使用しないため、そのジェネリッククラスのことを consumer と呼んだりします。 なので、サンプルコードでは反変 (contravariant) なジェネリッククラスの名前が Consumer になっていたりします。 Kotlin の Continuation インタフェースも、反変なジェネリックインタフェースのひとつです。 interface Continuation&lt;in T&gt; { val context: CoroutineContext fun resume(value: T) fun resumeWithException(exception: Throwable) } declaration-site variance（宣言箇所分散）と use-site variance（利用箇所分散） 前述の Holder クラスの説明の場所でも少し出てきましたが、ジェネリッククラスの型パラメータに、out や in などの分散修飾子 (variance modifier) を付ける場合、Kotlin ではその付加タイミングが 2 パターンあります。 declaration-site variance（宣言箇所分散） &hellip; クラスやインタフェースの宣言時に型パラメータを out や in で修飾する use-site variance（使用箇所分散） &hellip; すでに定義されているジェネリッククラスを使うときに型引数に out や in を付ける declaration-site variance（宣言箇所分散） 次の List インタフェースのように、インタフェースを宣言する時点で型パラメータに out や in 修飾子を付けてしまう方法です。 interface List&lt;out E&gt; : Collection&lt;E&gt; { ... } この List インタフェースを使う場所では、デフォルトで共変 (covariant) として扱われます。 例えば、List&lt;Number&gt; を受け取る関数には、List&lt;Int&gt; や List&lt;Double&gt; を渡すことができます。 fun showNumbers(nums: List&lt;Number&gt;) { println(nums) } fun main() { showNumbers(listOf(1, 2, 3)) // List&lt;Int&gt; を渡せる showNumbers(listOf(0.1, 0.2, 0.3)) // List&lt;Double&gt; も渡せる } もっと簡単に書くと、List インタフェースでは、次のような代入が可能ということです。 val nums: List&lt;Number&gt; = listOf&lt;Int&gt;(1, 2, 3) // OK 逆に、MutableList インタフェースは共変 (convariant) として定義されていない（＝不変 (invariant)) ので、次のような代入ができません。 val nums: MutableList&lt;Number&gt; = mutableListOf&lt;Int&gt;(1, 2, 3) // ERROR use-site variance（使用箇所分散） ジェネリッククラスを使用する際に、その型引数に in や out キーワードを付ける方法です。 例えば、Kotlin の MutableList は不変 (invariant) なジェネリッククラスなので、次のように、MutableList&lt;Int&gt; を MutableList&lt;Number&gt; として扱うことはできません。 val list: MutableList&lt;Number&gt; = mutableListOf&lt;Int&gt;(1, 2, 3) // ERROR このような不変 (invariant) クラスであっても、使用する場所で out キーワードを付ければ、その部分だけでは共変であるとみなして使用することができます。 その副作用として、in position で要素を扱うことができなくなるので、add() メソッドなどを呼び出せなくなります。 val list: MutableList&lt;out Number&gt; = mutableListOf&lt;Int&gt;(1, 2, 3) list.add(1.5) // ERROR このように型引数を使用することを、専門用語で 型投影（タイププロジェクション） と呼んだりします。 このケースでは、out キーワードを付けているので、out-projected されているといいます。 より実践的な例として、次のような、配列 (Array) の中身をコピーする関数を考えてみます。 fun &lt;T&gt; copyArray(src: Array&lt;T&gt;, dst: Array&lt;T&gt;) { assert(src.size == dst.size) for (i in src.indices) { dst[i] = src[i] } } Kotlin の Array クラスは、次のように型パラメータに variance modifier（out や in）が付いていないので、MutableList と同様に、不変 (invariant) なジェネリッククラスです。 class Array&lt;T&gt; よって、Array&lt;Int&gt; と Array&lt;Number&gt; には互換性がなく、次のようなコードはエラーになります。 val arr1 = arrayOf&lt;Int&gt;(1, 2, 3) val arr2 = arrayOfNulls&lt;Number&gt;(3) copyArray(arr1, arr2) // ERROR そこで、使用箇所分散 (use-site variance) の仕組みを使って、dst パラメータの型パラメータに in キーワードを付けて、反変 (contravariant) にします。 in キーワードが付けられることにより、この dst オブジェクトは、T 型の要素を取り込むだけ（consume するだけ）ですよと宣言していることになります。 fun &lt;T&gt; copyArray2(src: Array&lt;T&gt;, dst: Array&lt;in T&gt;) { assert(src.size == dst.size) for (i in src.indices) { dst[i] = src[i] } } すると、この関数の src パラメータに Array&lt;Int&gt; を渡した場合は、dst パラメータに Array&lt;Number&gt; などをサブタイプとみなして渡せるようになります。 val arr1 = arrayOf&lt;Int&gt;(1, 2, 3) val arr2 = arrayOfNulls&lt;Number&gt;(3) copyArray2(arr1, arr2) // OK Array クラスは本来は不変 (invariant) なクラスとして定義されているものですが、この関数だけは反変 (contravariant) として使えるようになるということです。 ちなみに、Java には、この use-site variance しか存在せず、&lt;? extends Hoge&gt; や &lt;? super Hoge&gt; といった上限境界、下限境界を指定する方法が使われていました。 in position と out position 型パラメータを共変 (covariant) にするには out 修飾子を付ける必要があり、反変 (contravariant) にするには in 修飾子を付ける必要があります。 これらの修飾子を付けるときの制約は次のようになっています。 out &hellip; in position で使用する型パラメータには付けられない in &hellip; out position で使用する型パラメータには付けられない ここでは、どの位置で型パラメータを参照することが、in position と out position のどちらで使用しているとみなされるのかをまとめておきます。 in position public なメソッドのパラメータ public なプロパティの setter（コンストラクタパラメータで、var が付いているもの。内部的に setter が定義されるため in position とみなされる） out position public なメソッドの戻り値 public なプロパティの getter（コンストラクタパラメータで、val あるいは var が付いているもの。内部的に getter が定義されるため out position とみなされる） in position でも out position でもない（共変にも反変にもできる） private なメソッドやプロパティのパラメータおよび戻り値（private なメソッドでは、型の誤用の心配がないため） コンストラクタパラメータで、val も var も付いていないもの（初期化時にしか呼ばれないものであり、型パラメータの誤用の危険性が低いため、in position でも out position でもないとみなされる） Kotlin の配列は不変、Java の配列は共変 Kotlin の Array クラスは不変 (invariant) なジェネリッククラスとして定義されています。 なので、基本的に、Array クラスから生成される異なる型の間に、親子関係は生まれません（前述の型投影 (use-site variance) の仕組みを使う場合は例外です）。 val arr: Array&lt;Any&gt; = arrayOf&lt;Int&gt;(1, 2, 3) // ERROR 一方、Java の配列は共変 (covariant) なものと定義されていました。 なので、次のような代入が可能でした。 Integer[] nums = {1, 2, 3}; Object[] objs = nums; objs[0] = &#34;ABC&#34;; // Runtime ERROR この仕様の問題点として、上記のように、Integer[] 配列に String オブジェクトを格納するコードがコンパイルできてしまう点が挙げられていました。 このような問題に対するアプローチとして、Kotlin では Array&lt;E&gt; クラスを（よりプリミティブな要素を保持する IntArray や CharArray も同様に）不変 (invariant) とすることに決めました。 Array&lt;Int&gt; と Array&lt;Any&gt; の間には互換性がないため、上記の Java の例のように、想定外の型の要素が格納されてしまう心配がありません。 List&lt;Any?&gt; と List&lt;*&gt; (star projection) の違い ジェネリクス型のオブジェクトを受け取る関数を定義するときに、要素の型情報を特に意識しないケースでは、型パラメータの代わりに、より簡潔な スタープロジェクション (star projection) の構文を使用することができます。 fun dump(list: List&lt;*&gt;) { for ((index, elem) in list.withIndex()) { println(&#34;$index: $elem&#34;) } } fun main() { val list = listOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) dump(list) } 上記の dump 関数を次のように型パラメータを使って定義しても同様に動作しますが、関数の定義の中で型情報を使用しないため、スタープロジェクションの構文を使用した方がシンプルに記述できます。 fun &lt;T&gt; dump(list: List&lt;T&gt;) 型パラメータの位置に &lt;*&gt; を指定するのと、&lt;Any?&gt; を指定するのは同じような感じがしますが、次のように明確な違いがあります。 MutableList&lt;*&gt; &hellip; 特定の型の要素が入ったリスト MutableList&lt;Any?&gt; &hellip; 何でも入れられるリスト MutableList&lt;*&gt; で参照しているリストの実態は MutableList&lt;Int&gt; だったりする一方、MutableList&lt;Any?&gt; で参照するリストは必ず MutableList&lt;Any?&gt; です。 MutableList&lt;*&gt; を受け取る関数は、具体的な型は気にしないけれど、呼び出し元で具体的な型引数を指定して作成したリストが渡されることを想定しています。 つまり、次のようなコードは型の安全性がないため、コンパイルエラーになります。 fun addSomething(list: MutableList&lt;*&gt;) { list.add(&#34;Hello&#34;) // ERROR: 勝手にString型のリストだと想定しちゃだめ } fun main() { var intList = mutableListOf(1, 2, 3) addSomething(intList) } 一方で、MutableList&lt;Any?&gt; は何でも格納できるリストであることを示します。 fun addSomething(list: MutableList&lt;Any?&gt;) { list.add(&#34;Hello&#34;) // OK: このリストには何でも入れられる } fun main() { var list = mutableListOf&lt;Any?&gt;(1, &#34;A&#34;, null) addSomething(list) } MutableList は不変 (invariant) なクラスであるため、MutableList&lt;Any?&gt; を受け取る関数には、MutableList&lt;Any?&gt; オブジェクトしか渡せないことに注意してください。 スタープロジェクションは、その要素をリードオンリーにする性質を持っています。 val list1 = mutableListOf(1, 2, 3) list1.add(100) // OK val list2: MutableList&lt;*&gt; = list1 list2.add(100) // ERROR ちなみに、Java ではワイルドカード文字として、* ではなく ? を使用していますが、Kotlin と同様にコレクションクラスをリードオンリーにする作用があります。 List&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add(&#34;Hello&#34;); // OK List&lt;?&gt; roList = strList; roList.add(&#34;World&#34;); // ERROR （コラム）分散という呼び方について covariant（共変）や invariant（不変）、contravariant（反変）などの性質は、まとめて variance/variant と呼ばれます。 これの日本語訳はよく「分散」と記述されていますが、分散ってデータの散らばり具合を意味する用語なので、この訳はとても気持ちが悪いです。 型の互換性を示すものなのだから、もっとわかりやすく、互換性とか変換性のように呼ぶべきだと思いますが、ちょっと抽象的すぎなのであまりいい用語がなかったのかもしれません。 でも少なくとも、分散とか変な呼び方をして、理解しにくくしてしまうのは悪い傾向かと思います。 誰かもっといい名前を付けて欲しいです！ あと、型パラメータに制約を付けるときの upper bound（上限境界）とか、lower bound（下限境界）とかいう用語も、ネーミングがよくないですね。 わざと分かりにくくしているのではないかという噂も。。。"},{url:"/p/yepnwyf/",title:"Kotlinメモ: ジェネリクスの基本",date:"2019-12-20T00:00:00+09:00",body:"Kotlinメモ: ジェネリクスの基本 ジェネリクスとは？ ジェネリクス (generics) は、ある型に 型パラメータ (type parameter) を付加する機能です。 型パラメータを持つクラスや関数を、Generic クラス、Generic 関数のように呼びます。 下記は型パラメータを 1 つ持つ Generic クラスの定義例です。 class Holder&lt;T&gt;(val value: T) 型パラメータはこのように &lt; と &gt; で囲む形で定義され、クラス本体部分の任意の箇所で使用することができます。 型パラメータは、Generic クラスを使用するときに指定した具体的な型に置き換えられます。 このとき指定する型のことを 型引数 (type argument) と呼びます。 次の例では、型引数として Int を指定しています。 val h = Holder&lt;Int&gt;(100) // Holder(100) と省略可 println(h.value) この場合、Holder という Generic クラスから、Holder&lt;Int&gt; という型が生成されていることになります。 つまり、理論上は 1 つの Generic クラスは、無限の型を生み出すことができます。 Kotlin では、「クラス:型 = 1:1」ではなく「クラス:型 = 1:多」の関係にあるということです。 クラスと型は異なる概念です。 Kotlin には型推論 (type inference) の仕組みが備わっているので、多くの場合、型引数の指定を省略することができます。 下記のようなコードは、 val users: List&lt;String&gt; = listOf&lt;String&gt;(&#34;User1&#34;, &#34;User2&#34;) 次のように省略できます。 val users = listOf(&#34;User1&#34;, &#34;User2&#34;) Generic クラスや Generic 関数を定義する際、型パラメータは基本的に大文字 1 文字で表現され、慣例として下記のような文字が使用されます。 E &hellip; コレクションの要素 (element) の型を表す型パラメータ K, V &hellip; マップ系コレクションのキー (key) と値 (value) の型を表す型パラメータ T, S &hellip; その他の汎用的な型パラメータ Java では、言語の進化の都合上、Generic クラスのもとになっている原型 (raw type) をそのまま使用することが許されていましたが（例: List&lt;E&gt; ではなく List を使うことができた）、Kotlin では、Generic クラスを使用する場合は、必ず型引数を指定して使用する必要があります。 特に、空のリストを生成するようなケースでは、初期値から要素の型を推論することができないので、次のいずれかの形で具体的な型引数を指定する必要があります。 val list = mutableListOf&lt;String&gt;() val list: MutableList&lt;String&gt; = mutableListOf() Generic 関数を定義する 型パラメータを持つ関数を定義するときは、関数名の「前」に「型パラメータ」 を記述します。 fun &lt;T&gt; createPair(a: T, b: T): Pair&lt;T, T&gt; { return a to b } Generic 関数を呼び出すときは、関数名の「後ろ」に「型引数」 を記述します。 多くの場合は Kotlin コンパイラが型を推論できるので、型引数は省略できます。 val p1 = createPair&lt;Int&gt;(100, 200) val p1 = createPair(100, 200) // 省略した場合 val p2 = createPair&lt;String&gt;(&#34;Hello&#34;, &#34;World&#34;) val p2 = createPair(&#34;Hello&#34;, &#34;World&#34;) // 省略した場合 拡張関数や拡張プロパティを定義するときも同様です。 次の例では、Generic な List クラスを拡張して lastIndex プロパティを追加しています（Kotlin の標準ライブラリで提供されています）。 public val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = this.size - 1 この拡張プロパティは、次のように List に元々備わっているプロパティのように使用することができます。 val list = listOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) println(list.lastIndex) //=&gt; 2 Kotlin のコレクション系クラスは Generics を用いた定義が前提になっているため、List の拡張関数を定義する場合は、上記のように必ず型パラメータ（上記の場合は &lt;T&gt;）を指定した定義を行うことになります。 Generic クラスを定義する 型パラメータを持つクラス（あるいはインタフェース）を定義するときは、クラス名の後ろに型パラメータを記述します。 interface MyList&lt;T&gt; { operator fun get(index: Int): T } あとは、そのクラス本体の実装のどこからでもその型を使用できるようになります。 上記の例では、戻り値の型として型パラメータを使用しています。 Generic クラスを継承する場合 Generic クラスを親クラスとして継承する場合は、次のいずれかの方法を使って、親クラスの型引数を指定します。 親クラスに対して具体的な型引数を指定してしまう方法 子クラスに新しく定義した型パラメータを親クラスへ伝搬させる方法 1 つ目の方法は、親クラスの型引数に具体的な型を指定してしまう方法で、このように定義した子クラスはもはや Generic クラスではありません。 class MyIntList : MyList&lt;Int&gt; { override fun get(index: Int): Int = ... } 2 つ目の方法は、子クラスの方にも型パラメータを持たせ、その型を親クラスの型引数として使ってしまう方法です。 この場合、子クラスも Generic クラスになります。 class MyStack&lt;T&gt; : MyList&lt;T&gt; { override fun get(index: Int): T = ... } 型パラメータ制約 (type parameter constraints) 例えば、任意のリストを受け取って、その要素の値を合計する関数を作りたいとします。 関数内で要素同士の足し算を行うため、List&lt;Int&gt; や List&lt;Double&gt; は受け取れるけど、List&lt;String&gt; は受け取ることができません。 このような場合は、型パラメータに制約 (constraint) を付けて、Number のサブクラスを型引数として与えられたリストしか受け付けないようにすることができます。 型パラメータに制約を付けるには、コロン (:) を使って、T : Number のように記述します（Java では T extends Number のように記述していました）。 fun &lt;T : Number&gt; sum(list: List&lt;T&gt;): T { var result: Double = 0.0 for (x in list) { result += x.toDouble() // Number#toDouble() を呼び出せる } return result as T } 結果として、この Generic 関数は、Number のサブクラス型（Int や Double）の要素を持つ List しか受け取ることができないため、関数の中で Number クラスのメソッドを自由に呼び出して実装を行うことができます。 このような制約 (constraint) を、上限 (upper bound) と呼びます。 何も制約を付加しない場合（&lt;T&gt; とだけ記述した場合）のデフォルトの上限は Any? となり、どんな型の要素を含んだ List でも受け取れることになります（Any? なので null を含んでいてもよい）。 どんな型の要素でもいいけど、null だけは受け付けないよ、というのであれば、明示的に &lt;T : Any&gt; と宣言します。 型パラメータを、上限 (upper bound) として指定するクラスの型引数として渡すこともできます。 次の例では、型パラメータ T の上限として Comparable&lt;T&gt; を指定しています。 これは、この関数に渡すオブジェクト a、b は、少なくとも Comparable&lt;T&gt; を実装していなければいけないということです。 結果として、この関数の中で a と b は、大なり (&gt;) や小なり (&lt;) を使って比較できるようになります。 fun &lt;T : Comparable&lt;T&gt;&gt; max(a: T, b: T) : T { return if (a &gt;= b) a else b } println(max(10, 20)) //=&gt; 20 println(max(&#34;A&#34;, &#34;B&#34;)) //=&gt; &#34;B&#34; println(max(10, &#34;A&#34;)) // Error! println(max(listOf(), listOf())) // Error! 上記では、関数の型パラメータに制約を与える方法を示しましたが、クラスの型パラメータに関しても同様です。 class TreeNode&lt;T : Vehicle&gt; この TreeNode クラスを使用するときは、型引数として、Vehicle のサブクラスや、Vehicle インタフェースを実装したクラスを指定する必要があります。 TreeNode クラスの実装の中では、Vehicle インタフェースが持つメソッドを自由に呼び出すことができます。 上限として複数の制約を持たせたい場合は、where という特殊なキーワードを使用する必要があります。 class TreeNode&lt;T&gt; where T : Vehicle, T : HasWheels このように定義された TreeNode を使用する場合、型引数に指定する型として、Vehicle インタフェースと HasWheels インタフェースの両方を実装した型を指定する必要があります。"},{url:"/p/bmwa9t8/",title:"Kotlinメモ: 演算子の前後で改行したいときは必ず後ろで改行する",date:"2019-12-04T00:00:00+09:00",body:"Kotlinメモ: 演算子の前後で改行したいときは必ず後ろで改行する Kotlin のコードにおいて、演算子の前後で改行をするときは、改行位置に気を付けないといけません。 不可解な不具合に悩まされたので戒めのためにメモ。 問題：次のコードを実行すると何と表示されるでしょう？ fun getVal() = 1 fun main() { val x = 100 - getVal() val y = 100 - getVal() println(x) println(y) } 答えは、 99 100 です。 y の計算式の方は、末尾が演算子で終わっていないので、次の行まで計算式が続いているとみなされません。 その次の行は、getVal() が返した値に単項演算子の - を適用するだけの意味のないコードになります。 だから、Kotlin のコードにおいて、長い計算式を記述する場合は、必ず演算子の後で改行するように注意しなければいけません。 Java の場合は、セミコロンが出てくるまで式が続いているとみなされるので、このようなミスは発生しませんでした。 ちなみに Ruby も同じで、演算子の後ろで改行しなければいけません。 Ruby x = 100 - 1 y = 100 - 1 puts x #=&gt; 99 puts y #=&gt; 100 Python の場合は、そもそも演算子の前後で改行しようとするとエラーになりますね。 バックスラッシュを入れれば連結できますが。 Python x = 100 - \\ 1 y = 100 \\ - 1 print(x) #=&gt; 99 print(y) #=&gt; 99"},{url:"/p/58ctg7k/",title:"Python で 2 つのリストに重複する要素を抽出する (set と &)",date:"2019-11-25T00:00:00+09:00",body:"Python で 2 つのリストに重複する要素を抽出する (set と &) Python では 2 つの set インスタンス同士で &amp; 演算を行うと、両方のセットに含まれる要素を抽出することができます（積集合）。 s1 = {1, 2, 3, 4} s2 = {3, 4, 5, 6} print(s1 &amp; s2) #=&gt; {3, 4} 参考: set オブジェクトで集合演算を行う リストやタプルにはこのような演算子は実装されていないため、リストやタプル同士でこういった演算を行うには、一度 set オブジェクトに変換する必要があります。 l1 = [1, 2, 3, 4] l2 = [3, 4, 5, 6] s1 = set(l1) s2 = set(l2) print(s1 &amp; s2) #=&gt; {3, 4} 重複要素があるかのチェックだけを行いたい場合は、&amp; 演算の結果求められたセットを条件式として評価すれば OK です（Python では空のセットを偽、それ以外のセットを真として扱います）。 if s1 &amp; s2: print(&#34;重複要素があります&#34;)"},{url:"/p/cdtcqag/",title:"Androidメモ: RecyclerView の基本",date:"2019-11-12T00:00:00+09:00",body:"Androidメモ: RecyclerView の基本 RecyclerView とは Android アプリで多数のコンテンツのリストを表示したいケースでは、RecyclerView という UI コンポーネントを使用すると、個々のアイテムの描画用インスタンスを使いまわしながら効率的な描画を行えます。 RecyclerView によって表示された描画領域をスクロールし、表示されているコンテンツが画面外に消えていくと、その描画用インスタンスが、新たに画面内に入ってきたコンテンツのために使いまわされます。 このとき使いまわされる描画用インスタンスを、view holder オブジェクトといい、RecyclerView.ViewHolder を継承して、任意の View を保持するように実装します。 ListView などでも複数のコンテンツを並べることはできますが、ListView は一度にすべてのコンテンツを表示しきってしまえるような場合に使用します。 何十、何百というコンテンツを並べたいときは、RecyclerView を使用します。 RecyclerView の構成 RecyclerView は次のような構成要素から成り立っています。 RecyclerView Android アプリ上に表示する View コンポーネントです。 RecyclerView.LayoutManager RecyclerView 上の各要素をどのように配置するかのアルゴリズムを実装します。標準のレイアウトマネージャーとして、LinearLayoutManager や GridLayoutManager が用意されていますが、LayoutManager を拡張して独自のレイアウトマネージャーを作成することもできます。 RecyclerView.ViewHolder RecyclerView 上の各要素を描画するための View を保持します。この ViewHolder インスタンスは、画面外にスクロールアウトしたときに、別の項目を表示するために再利用されます。 RecyclerView.Adapter RecyclerView と実際のデータを結びつけ、適切なタイミングで ViewHolder オブジェクトの生成 (onCreateViewHolder()) や、表示内容の入れ替え (onBindViewHolder()) を行います（LayoutManager から自動的に呼び出されます）。つまり、アプリの開発者は、onCreateViewHolder() で ViewHolder インスタンスを生成し、onBindViewHolder() でその表示内容を更新するように実装するだけでよいことになります。 RecyclerView を使った実装 図: RecyclerViewの表示例 まず、RecyclerView を配置したレイアウトファイルを用意します。 LinearLayout などの ViewGroup を挟んでもよいのですが、ここではルートに RecyclerView を配置して、直接 MainActivity.setContentView() でセットしてしまうことにします。 res/layout/activity_main.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;androidx.recyclerview.widget.RecyclerView xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:id=&#34;@+id/recycler_view&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:scrollbars=&#34;vertical&#34; /&gt; 次の item.xml は、RecyclerView で描画される各要素の View を構成するためのレイアウトファイルです。 ここでは、テキストとボタンを左右に配置しています。 RecyclerView.Adapter 内で ViewHolder インスタンスを生成するときに inflate します。 res/layout/item.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34;&gt; &lt;Button android:id=&#34;@+id/button&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34; android:text=&#34;Button&#34; app:layout_constraintEnd_toEndOf=&#34;parent&#34; app:layout_constraintTop_toTopOf=&#34;parent&#34; /&gt; &lt;TextView android:id=&#34;@+id/label&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;wrap_content&#34; android:layout_marginStart=&#34;8dp&#34; android:text=&#34;Element&#34; app:layout_constraintBottom_toBottomOf=&#34;@+id/button&#34; app:layout_constraintStart_toStartOf=&#34;parent&#34; app:layout_constraintTop_toTopOf=&#34;@+id/button&#34; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; アプリのエントリポイントとなる MainActivity では、RecyclerView に配置アルゴリズムとなる LayoutManager と、データと View を結び付けるための Adapter をセットします。 ここでは、LayoutManager として、Android に標準で搭載されている LinearLayoutManager を使用します（デフォルトで縦方向に並びますが、コンストラクタの orientation パラメータで水平方向を指定することもできます）。 Adapter にセットするデータとしては、1～100 の整数配列 (IntArray) を使うことにします。 MainActivity.kt import androidx.appcompat.app.AppCompatActivity import android.os.Bundle import androidx.recyclerview.widget.LinearLayoutManager import androidx.recyclerview.widget.RecyclerView class MainActivity : AppCompatActivity() { // RecyclerView 本体、および、LayoutManager と Adapter private lateinit var recyclerView: RecyclerView private lateinit var layoutManager: RecyclerView.LayoutManager private lateinit var adapter: RecyclerView.Adapter&lt;*&gt; // Adapter にセットするデータ (1～100) private val data = IntArray(100) { it + 1 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.recycler_view) layoutManager = LinearLayoutManager(this) adapter = MyAdapter(data) recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recycler_view).also { it.layoutManager = layoutManager it.adapter = adapter } } } 次の MyViewHolder クラスは、各要素を描画するための View を保持するための RecyclerView.ViewHolder の実装です。 保持する View 自体は、後述の MyAdapter で item.xml から inflate して作成します。 その View を MyViewHolder のコンストラクタで受け取るようにしています。 View 内の表示内容は、外の MyAdapter から更新する必要があるため、ここではプロパティを介して TextView や Button に直接アクセスできるようにしています。 MyViewHolder.kt import android.view.View import android.widget.Button import android.widget.TextView import androidx.recyclerview.widget.RecyclerView /** * ViewHolder の実装（各要素を表示するための View を保持する） */ class MyViewHolder(private val view: View) : RecyclerView.ViewHolder(view) { val label: TextView by lazy { view.findViewById&lt;TextView&gt;(R.id.label) } val button: Button by lazy { view.findViewById&lt;Button&gt;(R.id.button) } } 最後に、RecyclerView.Adapter を拡張して、MyAdapter クラスを作成します。 このクラスでは少なくとも次の 3 つのメソッドを実装する必要があります。 Adapter.getItemCount() &hellip; セットされているデータの要素数を返す。 Adapter.onCreateViewHolder() &hellip; 新しい ViewHolder インスタンスを生成する。XML ファイルを inflate して作成した View オブジェクトを、独自の ViewHolder インスタンスにセットして返せばよい。 Adapter.onBindViewHolder() &hellip; ViewHolder の表示内容を更新する。パラメータで渡される ViewHolder が最初に表示されるときにも呼び出されるし、使いまわされるときにも呼び出される。 ここでは、Adapter.onCreateViewHolder() のタイミングで item.xml を inflate して MyViewHolder インスタンスを生成し、Adapter.onBindViewHolder() でその中のテキストやボタンのラベルを更新しています。 MyAdapter.kt import android.view.LayoutInflater import android.view.View import android.view.ViewGroup import androidx.recyclerview.widget.RecyclerView /** * Adapter の実装（データを結びつけ、ViewHolder の生成とデータ反映を行う） */ class MyAdapter(private val data: IntArray) : RecyclerView.Adapter&lt;MyViewHolder&gt;() { /** 表示用データの要素数（ここでは IntArray のサイズ） */ override fun getItemCount(): Int = data.size /** 新しく ViewHolder オブジェクトを生成するための実装 */ override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MyViewHolder { val inflater = LayoutInflater.from(parent.context) return MyViewHolder(inflater.inflate(R.layout.item, parent, false)) } /** position の位置のデータを使って、表示内容を適切に設定（更新）する */ override fun onBindViewHolder(holder: MyViewHolder, position: Int) { val num = data[position] holder.label.text = &#34;Element-$num&#34; holder.button.text = &#34;Button-$num&#34; } }"},{url:"/p/n4o7o6m/",title:"Hugo でGoogle カスタム検索を設置して記事を検索できるようにする",date:"2019-11-10T00:00:00+09:00",body:"Hugo でGoogle カスタム検索を設置して記事を検索できるようにする Google カスタム検索エンジンによる検索フォームを Hugo のサイトに設置することで、簡単にサイト内の記事を検索することができるようになります。 Google カスタム検索エンジンに自分のサイトを登録する まず、Google カスタム検索エンジンを適用する Web サイトは、インターネット上に公開されている必要があります。 プライベートな Hugo サーバーを使用する場合に検索機能を付けたい場合は、自己完結する全文検索の仕組み を導入する必要があります。 ここでは、すでにインターネット上に公開されている Web サーバーがあるという前提で話を進めます。 カスタム検索エンジンの登録は下記のサイトから行えます。 Google カスタム検索エンジン 追加 ボタンを押して、自分の Web サイトのアドレスを入力するだけで登録は完了します。 検索ページを表示する Web サイトをカスタム検索エンジンに登録すると、Google のサーバ上に、カスタム検索用のページが作成されます。 カスタム検索のコントロールパネル から、登録した検索エンジンを選択し、公開 URL の欄を確認してみてください。 下記のようなアドレスが生成されているはずです（下記アドレスの cx パラメータ部分は適当です）。 https://cse.google.com/cse?cx=207539779230035260336:1pkduco3un7 あとは、Markdown ファイルの中から、次のようにリンクを張ってやれば、即席のカスタム検索サイトの完成です。 [サイト内検索](https://cse.google.com/cse?cx=207539779230035260336:1pkduco3un7) 図: 表示例 Hugo のページ内に検索フォームと検索結果を表示する 上記のやり方では、Google のサーバ上に生成された検索ページへただジャンプするだけでした。 ここでは、Hugo の記事ページ内に検索フォームと、検索結果を表示できるようにしてみます。 まず、カスタム検索のサイトから、ページ埋め込み用の HTML コードを取得します。 図: カスタム検索用の HTML コードを生成 カスタム検索のコントロールパネル から、登録した検索エンジンを選択する デザイン のタブから、全幅 のデザインを選択する 保存してコードを取得する ボタンを押す 上記のようにポチポチ入力していくと、下記のようなコードが取得できるはずです（バージョンにより変更される可能性があります）。 &lt;script async src=&#34;https://cse.google.com/cse.js?cx=207539779230035260336:1pkduco3un7&#34;&gt;&lt;/script&gt; &lt;div class=&#34;gcse-search&#34;&gt;&lt;/div&gt; 後は、このコードを、任意の記事ページの Markdown ファイル内にコピペするだけです。 content/custom-search/_index.md --- title: &#34;サイト内検索&#34; --- &lt;script async src=&#34;https://cse.google.com/cse.js?cx=207539779230035260336:1pkduco3un7&#34;&gt;&lt;/script&gt; &lt;div class=&#34;gcse-search&#34;&gt;&lt;/div&gt; 下記は、実際に Hugo を使ったサイト内のページにカスタム検索を埋め込んだときの表示例です。 図: Hugo サイトへのカスタム検索の埋め込み 検索フォームに余計な枠線が表示されていたり、微妙にレイアウトが崩れてしまっているのが分かります。 これは、その Web サイトのスタイル設定が Google の検索フォームにも影響してしまっているからです。 このようなレイアウトの崩れを防ぐ一番手っ取り早い方法は、先に示した、Google のサーバ上に生成された検索ページに飛ばしてしまう方法です。 検索フォームだけ独自コードで設置する 最初の例で示したように、Google のサーバー上に生成される検索ページのアドレスは次のようになっています。 https://cse.google.com/cse?cx=＜検索エンジンID＞ 実は、このアドレスの後ろに、次のように検索ワードを追加して開くと、検索結果を表示した状態で検索ページを開くことができます。 https://cse.google.com/cse?cx=＜検索エンジンID＞&amp;q=＜検索ワード＞ つまり、このようなアドレスを開くための FORM 要素を設定してやることで、直接カスタム検索の結果にジャンプできる検索フォームを作成できます。 下記は、form 要素の記述例です（cx パラメータの値は、あなたの Web サイト用の検索エンジン ID に変更してください）。 &lt;form action=&#34;https://cse.google.com/cse&#34;&gt; &lt;div class=&#34;searchBox&#34;&gt; &lt;input type=&#34;hidden&#34; name=&#34;cx&#34; value=&#34;207539779230035260336:1pkduco3un7&#34; /&gt; &lt;input type=&#34;hidden&#34; name=&#34;ie&#34; value=&#34;UTF-8&#34; /&gt; &lt;input type=&#34;search&#34; name=&#34;q&#34; placeholder=&#34;サイト内検索&#34; size=&#34;30&#34; autocomplete=&#34;off&#34; /&gt; &lt;input type=&#34;submit&#34; value=&#34;検索&#34; /&gt; &lt;/div&gt; &lt;/form&gt; ここでは、div 要素に searchBox というクラスを割り当てているので、このクラスに対する CSS スタイルを設定してやれば、見た目のカスタマイズは自由に行えます。 .searchBox &gt; input { font-size: 16px; vertical-align: middle; border-radius: 3px; } .searchBox &gt; input[type=&#34;search&#34;] { border: solid 1px #ccc; padding: 0.5em; } .searchBox &gt; input[type=&#34;submit&#34;] { background: #ff3c5f; color: white; font-weight: bold; border: none; margin-left: 0.3em; padding: 0.5em 1em; } 図: 表示結果 パーシャルテンプレート化する こういった検索フォームは、すべてのページに設置することが多いでしょうから、Hugo では下記のような感じで、レイアウトファイルからパーシャルテンプレートとして呼び出せるようにしておくと便利です。 layouts/_default/single.html（抜粋） {{ partial &#34;custom-search&#34; . }} 下記は custom-search パーシャルテンプレートの記述例です。 ここでは、Hugo の設定ファイルで CustomSearchId という独自パラメータが設定されている場合のみ、カスタム検索のフォームを表示するようにしています（最初の with による分岐）。 layouts/partials/custom-search.html {{- with .Site.Params.CustomSearchId }} &lt;form action=&#34;https://cse.google.com/cse&#34;&gt; &lt;div class=&#34;searchBox&#34;&gt; &lt;input type=&#34;hidden&#34; name=&#34;cx&#34; value=&#34;{{ . }}&#34; /&gt; &lt;input type=&#34;hidden&#34; name=&#34;ie&#34; value=&#34;UTF-8&#34; /&gt; &lt;input type=&#34;search&#34; name=&#34;q&#34; placeholder=&#34;サイト内検索&#34; size=&#34;30&#34; autocomplete=&#34;off&#34; /&gt; &lt;input type=&#34;submit&#34; value=&#34;検索&#34; /&gt; &lt;/div&gt; &lt;/form&gt; {{- end }} 設定ファイルには下記のように検索エンジン ID を設定しておきます。 hugo.toml [params] CustomSearchId = &#34;207539779230035260336:1pkduco3un7&#34; 参考 Hugo に全文検索（インクリメンタルサーチ）の機能を付ける"},{url:"/p/otwhjds/",title:"Kotlinメモ: Kotlin で読みやすいコードを書く方法（可読性の高い Kotlin コードとは）",date:"2019-10-31T00:00:00+09:00",body:"Kotlinメモ: Kotlin で読みやすいコードを書く方法（可読性の高い Kotlin コードとは） Effective Kotlin という電子書籍に、Kotlin コードの可読性に関していろいろためになることが書いてあるのでメモメモ。 読みやすさのためのデザイン (Design for readability) 昔ながらの実装 vs Kotlin 的な実装 下記の実装 A と B はどちらが読みやすいでしょうか？ // 実装 A if (person != null &amp;&amp; person.isAdult) { view.showPerson(person) } else { view.showError() } // 実装 B person?.takeIf { it.isAdult } ?.let(view::showPerson) ?: view.showError() どちらが読みやすいかは読む人のスキルによりますが、A の方が変更しやすく、デバッグしやすいです。 条件分岐を増やそうとすると、B の方は全体を考え直さないといけないので、頭が疲れます。 A と B は一見同じ振る舞いをするように見えますが、実際には異なる動作をします。 let はラムダ式の評価結果を返すので、view::showPerson が null を返すと、showError() が実行されてしまいます！ let などはしっかり仕様を理解して使わないと危険だということです。 一般ルールとしては、認知負荷を下げる ようにコードを記述することを考えるとよいです。 つまり、どう動作するかがそのままコードに表現されている ように書くということです。 「短いコード＝読みやすいコード」ではないということですね。 一般的に、コンパクトなコードを書ける人は、技術的にはどんなコードでも書ける人だと思います。 あとはその人がどれだけ思いやりを持って書けるかにかかっています。 やりすぎはダメよ (Do not get extreme) これはよくある safe call let イディオムなんですが、、、 person?.let { print(it.name) } これはどうですか？ students .filter { it.pointsInSemester &gt; 15 &amp;&amp; it.result &gt;= 50 } .sortedWith(compareBy({ it.surname }, { it.name })) .joinToString(separator = &#34;\\n&#34;) { &#34;${it.name} ${it.surname}, ${it.result}&#34; } .let(::print) var obj = FileInputStream(&#34;/file.gz&#34;) .let(::BufferedInputStream) .let(::ZipInputStream) .let(::ObjectInputStream) .readObject() as SomeObject 後者のようなコードの問題点は、デバッグが難しくなることと、Kotlin に慣れていない人にとって理解しにくいことです。 こういった Kotlin 的なイディオムの組み合わせは、単独で順番に呼び出した時よりも何倍も複雑になってしまうということを意識しておかなければいけません。 演算子の振る舞いと関数名との一貫性 (Operator meaning should be consistent with its function name) 演算子のオーバーロードはとってもパワフル！でもとってもデンジャラス！ 下記はある数の階乗を求めるプログラムです。 fun Iterable&lt;Int&gt;.product(): Int = fold(1) { acc, i -&gt; acc * i } fun Int.factorial(): Int = (1..this).product() fun main() { print(6.factorial()) // 720 } 階乗は数学の世界では 10・6! と書けるので、こんな風に定義したくなるかもしれません。 operator fun Int.not() = factorial() print(!6) // 720 !6 という表現が、6! に似ててエレガント！と思うかもしれません。 でもこれは not() という関数を定義しているのであり、下記のシンタックスシュガーでしかありません。 print(6.not()) // 720 これは意味的におかしいですよね？ だから、演算子をオーバーロードするときは、その演算子の本質的な意味を変えるような実装をしてはいけません。 関数を整数倍 (times) するとは？ 下記はどんな処理を表現しているのでしょうか？ 3 * { print(&#34;Hello&#34;) } ある人は、関数をその場で 3 回呼び出すことを意味していると思うかもしれません。 operator fun Int.times(operation: ()-&gt;Unit) { repeat(this) { operation() } } 3 * { print(&#34;Hello&#34;) } // HelloHelloHello またある人は、関数を 3 回呼び出す関数を定義していると思うかもしれません。 operator fun Int.times(operation: () -&gt; Unit): ()-&gt;Unit = { repeat(this) { operation() } } val tripledHello = 3 * { print(&#34;Hello&#34;) } tripledHello() // HelloHelloHello このように、演算子のオーバーロードによって曖昧さを発生させる恐れがある場合は、わかりやすい名前の 拡張関数 を定義すべきです。 どうしても演算子のように呼び出せるようにしたいのであれば、infix を使いましょう。 infix fun Int.timesRepeated(operation: ()-&gt;Unit) = { repeat(this) { operation() } } val tripledHello = 3 timesRepeated { print(&#34;Hello&#34;) } tripledHello() // HelloHelloHello でも、このように処理を繰り返したいときは、素直にトップレベル関数をそのまま使っちゃえば OK です。 repeat(3) { print(&#34;Hello&#34;) } 例外として、DSL (Domain Specific Language) を定義する場合は、意図的に特殊なオーバーライドをすることがあります。 body { div { +&#34;Some text&#34; // String.unaryPlus の呼び出し } } Unit? 型の戻り値は便利？ (Avoid returning or operating on Unit?) fun keyIsCorrect(key: String): Boolean = /* ... */ if (!keyIsCorrect(key)) return こーゆーのは、戻り値を Unit? にしておけば、Elvis operator で簡潔に記述できるのでは？という主張があります。 こんな感じに if を省略できる。。。 fun verifyKey(key: String): Unit? = /* ... */ verifyKey(key) ?: return 確かにこれは書いている人にとっては快適かもしれないけど、読む人にとっては混乱のもとです。 素直に Boolean を使いましょう！ 特に問題になるのは、ちょっと前にも出てきた次のような呼び出し方をした場合です。 getData()?.let { view.showData(it) } ?: view.showError() 万が一、ラムダ式で呼び出している showData() が null を返すような実装をしていたら、showError() まで呼ばれてしまいます。これは恐ろしい。。。 Unit? の方が有用なケースってあまりないはずなので、結論としては、Unit? なんて使うな ということです。 型が明確でないときは省略しない (Specify the variable type when it is not clear) Kotlin の型推論機能 (type inference) はよいよねー。 val num = 10 val name = &#34;Marcin&#34; val ids = listOf(12, 112, 554, 997) こーゆーのはシンプルでとてもよい。 でも下記のように、関数の戻り値を受ける場合はどうでしょう？ val data = getSomeData() 確かに Kotlin の型推論によって、変数 data の型指定は省略できます。 でも、このコードを見ただけでは、data はどんな型なのかがわかりません。 読み手はいちいち関数の定義を見なければ理解することができません。 IDE の機能を使ったり、関数を辿っていけば分かるじゃん、とは言いますが、GitHub 上でレビューすることはよくあるでしょう？ 言語的に型を省略できる場合でも、この例のような場合はちゃんと型を明示した方が読みやすくなります（最近の Android Studio は、このようなケースで型名を省略すると suggestion を出してくれるようになりました）。 val data: UserData = getSomeData() 特にプラットフォーム型（言語的には xxx! と示される内部表現） を返すメソッドを呼び出す場合は、必ずその場で受け取る型を宣言しましょう。 NotNull な値として扱うのか、Nullable な値として扱うのかを早めに指定することで、null まわりの不具合を見つけやすくなります。 val text = javaObj.getUserName() // これはダメ！深いところでヌルポになるバグのもと val text: String = javaObj.getUserName() // OK: NotNull な値として扱う val text: String? = javaObj.getUserName() // OK: Nullable な値として扱う 仮に本当は Nullable にすべき戻り値を NotNull な型で受けるように実装してしまっても、早い段階で NullPointerException が発生するので、潜在的なバグの混入は防ぐことができます。 レシーバーオブジェクトの明示 (Consider referencing receivers explicitly) 拡張関数における this の明示 下記はクイックソートを拡張関数として実装する例です。 fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; { if (size &lt; 2) return this val pivot = first() val (smaller, bigger) = drop(1).partition { it &lt; pivot } return smaller.quickSort() + pivot + bigger.quickSort() } どれがレシーバーのプロパティかわかりにくいかもしれません。 このような場合は、レシーバー (this) を明示的に記述した方が理解しやすくなることがあります。 fun &lt;T : Comparable&lt;T&gt;&gt; List&lt;T&gt;.quickSort(): List&lt;T&gt; { if (this.size &lt; 2) return this val pivot = this.first() val (smaller, bigger) = this.drop(1).partition { it &lt; pivot } return smaller.quickSort() + pivot + bigger.quickSort() } たくさんレシーバーがいるとき apply や with や run などを使うとき、レシーバーが複数混在することがあります。 そのようなケースでは、ちゃんとレシーバーを明示しないと危険です。 class Node(val name: String) { fun makeChild(childName: String) = create(&#34;$name.$childName&#34;) .apply { print(&#34;Created ${name}&#34;) } fun create(name: String): Node? = Node(name) } fun main() { val node = Node(&#34;parent&#34;) node.makeChild(&#34;child&#34;) } 上記を実行すると何が表示されるでしょう？ （答え → Created parent） 次に、レシーバーとして this を明示してみるとどうなるでしょう？ lass Node(val name: String) { fun makeChild(childName: String) = create(&#34;$name.$childName&#34;) .apply { print(&#34;Created ${this?.name}&#34;) } fun create(name: String): Node? = Node(name) } fun main() { val node = Node(&#34;parent&#34;) node.makeChild(&#34;child&#34;) } （答え → Created parent.child） これは apply の間違った使い方の一つです。 こーゆー場合は、レシーバーをパラメータとして受け取る also や let を使えば、パラメータに名前を付けることができるし、this の意味がラムダ式 {} の内側と外側で変わってしまうのを防ぐことができます。 class Node(val name: String) { fun makeChild(childName: String) = create(&#34;$name.$childName&#34;) .also { print(&#34;Created ${it?.name} in $name&#34;) } fun create(name: String): Node? = Node(name) } fun main() { val node = Node(&#34;parent&#34;) node.makeChild(&#34;child&#34;) // Created parent.child in parent } ちなみに、also と let の違いは、also が自分自身を戻り値とするのに対し、let は戻り値が任意であるという点です。 よい例ではないですが、仮に apply を使ったときに外側の name パラメータを参照したい場合は、次のように this をラベリングして参照する必要があります。 fun makeChild(childName: String) = create(&#34;$name.$childName&#34;) .apply { print(&#34;Created ${this?.name} in ${this@Node.name}&#34;) } プロパティは振る舞いではなく状態を表す (Properties should represent state, not behavior) Kotlin のプロパティと Java のフィールドが大きく異なるのは、Kotlin ではカスタムゲッターとしてプロパティの実装ができるところです（Kotlin のプロパティはフィールドではなくアクセッサーです）。 プロパティは実際のところ関数なので、どんな実装でもできてしまいますが、アルゴリズム的な振る舞いを実装すべきではありません。 // DON’T DO THIS! val Tree&lt;Int&gt;.sum: Int get() = when (this) { is Leaf -&gt; value is Node -&gt; left.sum + right.sum } 上記のようなプロパティ実装は、要素を再帰的に走査するため、コレクションのサイズによって計算量が莫大になり得ます。 getter メソッドは、暗黙的に高速に値を返すと想定されるので、このような大きなアルゴリズムはプロパティとして実装してはいけません。 代わりに、次のように関数として実装すべきです。 fun Tree&lt;Int&gt;.sum(): Int = when (this) { is Leaf -&gt; value is Node -&gt; left.sum() + right.sum() } 標準ライブラリでも sum は関数として提供していますね。 val s = (1..100).sum() プロパティと関数のどちらで定義すべきか？ メソッドにしたときに、setXxx()/getXxx() と命名できるもののみプロパティとして定義する資格がある プロパティは O(1) のオーダーで完了するべき ビジネスロジックを含むものはプロパティにしてはいけない（例外: ロギング、リスナへの通知、結合された要素値の変更） 呼び出しの順序によって振る舞いが変わるもの、複数回呼び出すと振る舞いが変わるものはプロパティにしてはいけない 自身の値を全体的に変換するものは、慣例としてメソッドとして提供する（例: Int.toDouble()） 一言でいうなら、プロパティは「状態」であり、関数は「振舞い」であるということ。 名前付き引数を活用する (Consider naming arguments) 名前付き引数を使って、パラメータの意味を分かりやすくしましょう。 下記は名前付き引数 (named arguments) のよい例です。 val text = (1..10).joinToString(separator = &#34;|&#34;) 下記は似ているけど、変数名で意味を示そうとしています（named values というらしい）。 val separator = &#34;|&#34; val text = (1..10).joinToString(separator) 後者は、開発者のミスが入りうるので前者の名前付き引数を使った方がベターです。 後者の実装では、関数の利用者が変数名を付け間違えることがあるし、関数側のパラメータの順序が変更された場合に気付くことができません。 引数名と同じような名前の変数を下記のように渡すのは、一見冗長に見えますが、上記のような理由から有用です。 val separator = &#34;|&#34; val text = (1..10).joinToString(separator = separator) 時間の単位（ミリ秒 or 秒）を明確にする 時間の単位があいまいな値を記述するのは避けましょう。 sleep(100) // 100秒？ これでは、100 という値が 100 秒なのか 100 ミリ秒なのかが伝わりません。 次のような書き方をすれば、「ミリ秒」単位の指定であることが一目瞭然になります。 sleep(timeMillis = 100) // 名前付き引数で示す sleep(Millis(100)) // 関数名で示す sleep(100.ms) // 拡張関数で示す 同じ型の変数が複数ある場合は名前付き引数で指定する 同じ型のパラメータを複数取る関数は、呼び出し時にパラメータの順序を間違えるミスが発生します。 次の関数は、String 型のパラメータを 2 つ受け取ります。 fun sendEmail(to: String, message: String) { /* ... */ } このような関数を呼び出す場合は、次のように 名前付き引数 の形で呼び出せば、パラメータの指定順序のミスはなくすことができます。 sendEmail( to = &#34;contact@example.com&#34;, message = &#34;Hello, ...&#34; ) 絶対に名前付き引数で呼び出した方がいいケース 次のように、関数型パラメータを複数もつ関数を呼び出すケースでは、必ず名前付き引数で呼び出すようにした方がよいです。 同じような呼び出し方をしているのに、振る舞いが変わってしまうことがあるからです。 fun call(before: () -&gt; Unit = {}, after: () -&gt; Unit = {}) { before() print(&#34; ---- &#34;) after() } call({ print(&#34;CALL&#34;) }) //=&gt; CALL ---- call { print(&#34;CALL&#34;) } //=&gt; ---- CALL 名前付き引数で、次のように呼び出せば間違えることがありません。 call(before = { print(&#34;CALL&#34;) }) //=&gt; CALL ---- call(after = { print(&#34;CALL&#34;) }) //=&gt; ---- CALL 3rd パーティライブラリを使う場合も、このような名前付き引数は活用できるケースはよくあります。 例えば、Java 言語で RxJava の Observable を使う場合、次のように処理内容をチェーンさせて記述します。 observable.getUsers() .subscribe((List&lt;User&gt; users) -&gt; { // onNext // ... }, (Throwable throwable) -&gt; { // onError // ... }, () -&gt; { // onCompleted // ... }); いちいちコメントで何の処理かを記述しているところがかっこ悪いです。 Kotlin の名前付き引数で記述すれば、次のようにスッキリ読みやすく書けるし、パラメータの順序を間違えることもありません。 observable.getUsers() .subscribeBy( onNext = { users: List&lt;User&gt; -&gt; // ... }, onError = { throwable: Throwable -&gt; // ... }, onCompleted = { // ... }) ちなみに名前付き引数バージョンで呼び出せるようにするため、RxJava オリジナルの subscribe() ではなく、Kotlin ラッパー（拡張関数）として定義されている subscribeBy() を呼び出さなければいけないことに注意してください。 コーディング規約に従おう (Respect coding conventions) 公式のコーディング規約 Kotlin 標準のコーディング規約は公式サイトでちゃんと定義されているので、できるだけこれに従いましょう。 これは読んでおかなければいけないドキュメントです。 Coding Conventions - Kotlin Programming Language もちろん、社内プロジェクトのすべてがこのコーディング規約に従う必要はないけれど、オープンなコミュニティで使用するプロジェクトでは従うべきです。 誰にとっても読みやすくなるし、コードをプロジェクト間で移動させるのも容易になります。 今 Kotlin を使っている人は、Java から移行してきた人が多いので、間違って Java のコーディング規約で書いている人が多いです。 特に、クラス定義や関数定義のパラメータ部分に改行を入れる場合に、次のような間違った記述方法をよく見かけます。 間違った例（Java の世界では OK だが、Kotlin の世界では NG） class Person(val id: Int = 0, val name: String = &#34;&#34;, val surname: String = &#34;&#34;) : Human(id, name) { // body } Kotlin では次のように改行するのが標準のルールで、最初の開き括弧 ( の後ろですぐに改行し、1 パラメータずつ改行していきます。 関数 body の直前の行（開き中括弧 { の行）はインデントしない class Person( // 一行目にはパラメータを記述しない val id: Int = 0, val name: String = &#34;&#34;, val surname: String = &#34;&#34; ) : Human(id, name) { // ここで一度インデントをリセットする // body } とはいえ、Effective Kotlin の著者は、関連度の強いパラメータ（x、y など）は、同じ行に書いてしまいたいとも言っています。 コーディング規約に従うためのツール Kotlin 標準のコーディング規約に従う場合は、下記のようなツールを活用しましょう。 IntelliJ/Android Studio のフォーマット設定 Setting → Editor → Code Style → Kotlin Set from... のリンクをクリック Predefined Style → Kotlin style guide を選択 ktlint - Kotlin 用の Lint ツール https://github.com/pinterest/ktlint コーディング規約はとても重要なものなのに、軽視している開発者もいます。 プロジェクトをよりよいものにするために、コーディング規約を守りましょう！"},{url:"/p/u4j3e9t/",title:"Kotlinメモ: マップの値を初めて取得しようとしたときに初期化する（Map の遅延初期化）(getOrPut)",date:"2019-10-24T00:00:00+09:00",body:"Kotlinメモ: マップの値を初めて取得しようとしたときに初期化する（Map の遅延初期化）(getOrPut) MutableMap の getOrPut メソッド を使用すると、指定されたキーに対応する値が見つからないときに、その値をラムダ式によって初期化した上で返すことができます。 val map = mutableMapOf&lt;String, Int&gt;() println(map.get(&#34;foo&#34;)) //=&gt; null （値が存在しない） println(map.getOrPut(&#34;foo&#34;, { 0 })) //=&gt; 0（get と同時に初期値がセットされる） println(map.get(&#34;foo&#34;)) //=&gt; 0 （値がセットされている） getOrPut() を利用すると、マップ値の遅延初期化を行えます。 キー＆値の形式の固定値を取得したいのだけど、各値の取得には多少コストがかかるという場合のキャッシュ用途で利用できます（値が変わらない前提）。 class UserDb { // ユーザーの年齢のキャッシュ private var _userAge = mutableMapOf&lt;String, Int&gt;() // ユーザーの年齢を取得する（キャッシュを利用） fun getAge(name: String) : Int = _userAge.getOrPut(name, { getAgeWithoutCache(name) }) private fun getAgeWithoutCache(name: String) : Int { // 初期値の計算に時間がかかるという想定 return 10 } } fun main() { val userDb = UserDb() val age : Int = userDb.getAge(&#34;maku&#34;) println(age) }"},{url:"/p/bes7iu7/",title:"Python で Markdown ファイルのフロントマターの記述が正しいかチェックする",date:"2019-10-22T00:00:00+09:00",body:`Python で Markdown ファイルのフロントマターの記述が正しいかチェックする 下記の Python スクリプト (check-front-matter.py) は、Markdown ファイルに記載された YAML フロントマターの内容が正しいかどうかを調べるサンプルスクリプトです。 確認内容は、validate() 関数の中に記載されていますので、用途に応じてこの内容を書き換えてください。 下記のサンプルコードでは、フロントマターに title と date が記載されているかをチェックしています。 使い方 PyYAML というライブラリを使用しているので、下記のようにインストールしておく必要があります。 PyYAML のインストール $ pip install pyyaml 次のように実行すると、カレントディレクトリ以下の全ての Markdown ファイル (.md) の内容を検証できます。 $ python check-front-matter.py content/title3.md: Missing title or date content/title4.md: Missing title or date content/title5.md: Missing title or date この例では、3 つの Markdown ファイルのフロントマターが正しく記述されていないことが検出されています。 サンプルスクリプト check-front-matter.py #!/usr/bin/env python3 import yaml class YamlFrontMatter: &#34;&#34;&#34;YAML ファイルからフロントマターを取得するクラスです。&#34;&#34;&#34; def __init__(self, filename): self.filename = filename def load_frontmatter(self): &#34;&#34;&#34; Markdown ファイルのフロントマターを読みこんで、 Python のオブジェクトとして返します。 &#34;&#34;&#34; with open(self.filename, encoding=&#39;utf-8&#39;) as file: text = self.__load_front_matter_text(file) return yaml.safe_load(text) def __load_front_matter_text(self, file): &#34;&#34;&#34; ファイルオブジェクトからフロントマター部分のテキストを抽出します。 セパレータの &#34;---&#34; は含みません。 &#34;&#34;&#34; line = file.readline().rstrip(&#39;\\r\\n&#39;) if line != &#39;---&#39;: raise Exception(file.name + &#39;: Front matter must begin with &#34;---&#34;&#39;) result = [] for line in file: line = line.rstrip(&#39;\\r\\n&#39;) if line == &#39;---&#39;: return &#39;\\n&#39;.join(result) result.append(line) raise Exception(file.name + &#39;: Front matter must end with &#34;---&#34;&#39;) # カレントディレクトリ以下のすべての Markdown ファイルの # フロントマターの記述が正しいかチェックします。 if __name__ == &#39;__main__&#39;: import glob import sys def validate(filename, fm): &#34;&#34;&#34; フロントマターの内容 (fm) が正しいかチェックします。 ここの実装は自由に変更してください。 &#34;&#34;&#34; if (&#39;title&#39; in fm) and (&#39;date&#39; in fm): # print(filename + &#39;: OK&#39;) pass else: print(filename + &#39;: Missing title or date&#39;) for filename in glob.iglob(&#39;**/*.md&#39;, recursive=True): try: fm = YamlFrontMatter(filename).load_frontmatter() validate(filename, fm) except Exception as e: print(e, file=sys.stderr) sys.exit(1)`},{url:"/p/euevcsa/",title:"Python で ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive)",date:"2019-10-22T00:00:00+09:00",body:"Python で ZIP ファイルを作成・展開する (shutil.make_archive, shutil.unpack_archive) Python の標準ライブラリである shutil を使用すると、複数のファイルを含むディレクトリから ZIP アーカイブを簡単に作成することができます（1 ファイル単位でアーカイブに追加するファイルを細かく制御したいときは、zipfile モジュールを使用します）。 ディレクトリを ZIP 圧縮する ZIP ファイルの作成 shutil.make_archive 関数 を使用すると、指定したディレクトリ内のファイルを丸ごと ZIP 圧縮できます。 次の例では、src ディレクトリ内のファイルを backup.zip ファイルに圧縮しています。 zip.py（src ディレクトリから backup.zip を作成） import shutil import sys try: shutil.make_archive(&#39;backup&#39;, format=&#39;zip&#39;, root_dir=&#39;src&#39;) except Exception as e: print(e, file=sys.stderr) ZIP ファイルの上書き確認をする shutil.make_archive 関数は、すでに ZIP ファイルがある場合には、問答無用で上書き保存してしまうようです。 下記の create_zip 関数は、同名の ZIP ファイルが存在している場合に確認プロンプトを表示するようにしています。 上書き確認付きの ZIP アーカイブ化関数 import shutil import sys import os def create_zip(zip_filename, src_dir): &#34;&#34;&#34; src_dir ディレクトリ内のファイル群を、 zip_filename で指定した名前の ZIP ファイルにアーカイブします。 すでに同名の ZIP ファイルが存在する場合は、確認プロンプトを表示します。 &#34;&#34;&#34; # 上書き確認 if os.path.exists(zip_filename): answer = input(zip_filename + &#39; already exists. Overwrite? (y/n): &#39;) if (answer != &#39;y&#39; and answer != &#39;Y&#39;): return # ZIP アーカイブの作成 try: name = os.path.splitext(zip_filename)[0] shutil.make_archive(name, format=&#39;zip&#39;, root_dir=src_dir) except Exception as e: print(e, file=sys.stderr) if __name__ == &#39;__main__&#39;: create_zip(&#39;backup.zip&#39;, &#39;src&#39;) ZIP ファイルを展開する shutil.unpack_archive 関数 を使用すると、指定した ZIP ファイルの中身を、指定したディレクトリに展開することができます。 下記の例では、backup.zip アーカイブ内のファイル群を dst ディレクトリ以下に展開しています。 dst ディレクトリが存在しない場合は、自動的に生成されます。 unzip.py import shutil import sys try: shutil.unpack_archive(&#39;backup.zip&#39;, extract_dir=&#39;dst&#39;) except Exception as e: print(e, file=sys.stderr)"},{url:"/p/u9r9p7n/",title:"Hugo でサイト構造を変えてもページの URL が変わらないようにする (Permalink)",date:"2019-10-20T00:00:00+09:00",body:`Hugo でサイト構造を変えてもページの URL が変わらないようにする (Permalink) 各ページの URL は変わってはいけない Hugo によって出力される HTML ファイルのパスは、デフォルトでは content ディレクトリ以下のセクション構成（ディレクトリ構成）やファイル名によって決定されます。 サイトの規模が小さいうちはこれでもよいのですが、Markdown ファイル数が増えてくると、ディレクトリ構造を変えたり、ファイル名を整理したくなってきます。 それによってページの URL がころころ変わってしまうと、せっかくリンクを張ってくれたサイトがあっても、すべてリンク切れになってしまいます。 このようなリンク切れを起こさないようにするのが パーマリンク (permalink) という考え方で、各ページに不変の ID を割り当てて URL が変わらないようにします。 例えば、Amazon の各商品のページは 10 桁の ISBN-10 という ID でアクセスできるようになっています。 https://www.amazon.co.jp/dp/4592146980/ Hugo でも、各ページにこのような ID ベースの URL を割り当てることができます。 不変の URL を割り当てた例 https://&lt;your-hugo-site&gt;/p/abc1234/ Hugo で出力するページに固定の URL を割り当てる Markdown ファイルのフロントマターに url プロパティを設定すると、そのページの URL を固定することができます。 --- title: &#34;ページタイトル&#34; url: &#34;p/abc1234/&#34; date: &#34;2019-10-20&#34; --- 例えば、上記のようなフロントマターを記述しておくと、そのページには必ず https://ドメイン名/p/abc1234/ というアドレスでアクセスできるようになります。 一階層目のパスは別の用途で使用する可能性があるため、ここでは p という階層を掘って、permalink 化した記事を格納するようにしています（Amazon の dp と同様です）。 このようにすることで、Markdown ファイルのファイル名や記事タイトル、ディレクトリ構成を変えても、最終的な URL を変化させずに済みます。 Hugo 搭載の permalink 機能は使わない Hugo には他にも、設定ファイルで permalink に関する設定を行う仕組みが用意されていますが、こちらは日付や記事タイトルに基づいて URL が決まるものであり、URL を固定する用途にはあまり向いていません。 また、フロントマターで aliases プロパティを指定することもできますが、こちらはリダイレクト用の HTML ファイルを追加出力するものであり、最終ターゲットとなるページの URL を制御することはできません。 このような理由により、ページのリンク切れの心配をなくすには、url プロパティで変化しない ID を割り当てる ことをお勧めします。 多言語対応ページでは url の先頭にスラッシュを付けない Hugo は 1 つのページを 多言語化してホスティング する機能を持っており、例えば、フランス語に翻訳したページの URL は、/fr/p/xxxxxxx/ のように、先頭に /fr という言語プレフィックスが付いたものになります。 各言語用の .md ファイルは次のようなファイル名で作成するのですが、 hello.md（デフォルト言語のページ） hello.en.md（英語のページ） hello.fr.md（フランス語のページ） このとき、フロントマターの url プロパティには en や fr やなどの言語プレフィックスを付ける必要はありません。 url: &#34;p/abc1234/&#34; ← 全ページ共通でこの指定で OK 多言語対応ページをビルドしたときに、自動的に言語プレフィックスを考慮したパスに HTML ファイルを出力してくれます（Hugo 0.55 以降）。 /p/abc1234/index.html /en/p/abc1234/index.html /fr/p/abc1234/index.html ただし、フロントマターの url プロパティの値をスラッシュ (/) で始めると、こういった言語プレフィックスの考慮はなくなり、指定したままのパスで HTML 出力されることになるので注意してください。 url: &#34;/p/abc1234/&#34; ← スラッシュで始めるように変えた 上記のように記述すると、必ず次のようなパスで HTML 出力されることになります。 /p/abc1234/index.html 通常は、url の値はスラッシュで始めないようにする のがよさそうです。 ランダム ID の生成方法 本記事の例では、ページの URL に 7 桁の ID を割り当てていますが、この ID は下記のサイトでランダム文字列として生成することができます。 ランダムID生成 - まくろぐ 毎回手動で ID を生成するのが面倒であれば、エディタのマクロなどで自動的に Markdown ファイルのフロントマターを挿入できるようにしておくと便利です。 下記にフロントマターの自動挿入方法をいくつか紹介します。 （応用）Archetypes でフロントマターを自動挿入 Hugo プロジェクトのルートに、archetypes/default.md というファイルを作成しておくと、hugo new コマンドで記事ページを生成したときに、その内容が雛形として使用されます（Hugo の Archetypes という機能です）。 次のサンプルでは、自動でフロントマターにランダムな url プロパティを挿入するようにしています。 archetypes/default.md --- title: &#34;&#34; url: &#34;p/{{ template &#34;permanentId&#34; }}/&#34; date: &#34;{{ now.Format &#34;2006-01-02&#34; }}&#34; tags: [&#34;&#34;] --- {{ define &#34;permanentId&#34; -}} {{- $scratch := newScratch -}} {{- range (seq 7) -}} {{- $nextCh := slice &#34;2&#34; &#34;3&#34; &#34;4&#34; &#34;5&#34; &#34;6&#34; &#34;7&#34; &#34;8&#34; &#34;9&#34; &#34;a&#34; &#34;b&#34; &#34;c&#34; &#34;d&#34; &#34;e&#34; &#34;f&#34; &#34;g&#34; &#34;h&#34; &#34;i&#34; &#34;j&#34; &#34;k&#34; &#34;m&#34; &#34;n&#34; &#34;o&#34; &#34;p&#34; &#34;q&#34; &#34;r&#34; &#34;s&#34; &#34;t&#34; &#34;u&#34; &#34;v&#34; &#34;w&#34; &#34;x&#34; &#34;y&#34; &#34;z&#34; | shuffle | first 1 -}} {{- $scratch.Add &#34;id&#34; $nextCh -}} {{- end -}} {{- delimit ($scratch.Get &#34;id&#34;) &#34;&#34; -}} {{- end -}} ここでは、permanentId という内部テンプレートを定義して、xpya1z3 という感じのランダム文字列を生成しています（もうちょっと綺麗に生成する方法があればいいんですが）。 Hugo プロジェクトのルートで次のようにコマンドを実行すれば、新しい記事ファイルが生成され、その先頭にフロントマターが挿入されます。 $ hugo new sample.md 例えば、次のような感じのファイルが生成されます（デフォルトで content ディレクトリ以下に生成されます）。 content/sample.md --- title: &#34;&#34; url: &#34;p/es3qakw/&#34; date: &#34;2020-03-16&#34; tags: [&#34;&#34;] --- （応用）Vim エディタでフロントマターを自動挿入 Vim などのエディタを使っている人は、エディタのマクロ機能でフロントマターを挿入できるようにしておくと便利です。 下記の Vim スクリプトは、現在編集中のファイルの先頭に、date プロパティや url プロパティを挿入する Hugo コマンドを定義します。 ~/vimrc_hugo.vim &#34; 0〜n-1 の範囲のランダム整数を生成する function! s:RandNum(n) return reltime()[1] % (a:n) endfunction &#34; 指定した長さのランダム文字列を生成する function! s:RandStr(length) let chars = &#39;23456789abcdefghijkmnopqrstuvwxzy&#39; let n = len(chars) let result = &#39;&#39; for i in range(a:length) let result .= chars[s:RandNum(n)] endfor return result endfunction &#34; 先頭行に Hugo 用のフロントマターを挿入する function! s:InsertHugoFrontMatter() let title = &#34;title: \\&#34;\\&#34;\\n&#34; let url = &#34;url: \\&#34;p/&#34; . s:RandStr(7) . &#34;/\\&#34;\\n&#34; let date = &#34;date: \\&#34;&#34; . strftime(&#34;%Y-%m-%d&#34;) . &#34;\\&#34;\\n&#34; let tags = &#34;tags: [\\&#34;\\&#34;]\\n&#34; execute &#34;:normal gg&#34; execute &#34;:normal I&#34; . &#34;---\\n&#34; . title . url . date . tags . &#34;---\\n\\n&#34; execute &#34;:normal gg&#34; endfunction &#34; Hugo コマンドを定義する command! Hugo call s:InsertHugoFrontMatter() このスクリプトファイルを ~/.vimrc などから下記のように読みこんでおくか、直接コードを ~/.vimrc にコピペしておけば、Vim エディタ上で Hugo コマンドを実行できるようになります。 ~/.vimrc（Windows の場合は %HOME%/_vimrc） source &lt;sfile&gt;:p:h/vimrc_hugo.vim ファイル名の前のあやしい記号群は、同じディレクトリにある別のファイルを読み込むためのおまじないです。 フルパスで指定しておいても OK です。 Vim エディタから下記のようにコマンドを実行すると、 :Hugo 現在編集中のファイルに、次のようなフロントマターが挿入されます。 --- title: &#34;&#34; url: &#34;p/4nzaju5/&#34; date: &#34;2019-10-20&#34; tags: [&#34;&#34;] --- （応用）GitHub の Issue や PullRequest からショートカット記法でリンクを張る GitHub のオートリンク機能を使うと、GitHub リポジトリの Issue や PR の Markdown ドキュメントの中から、簡単な ID 指定で Hugo のページにリンクを張れるようにようになります。 参考: GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink) - まくまくGitノート 例えば、https://blog.example.com/p/1234abc/ というアドレスの代わりに、BLOG-1234abc と記述するだけで済むようになります。 本記事で紹介したように Hugo のページを ID ベースで管理する場合は、GitHub のオートリンク機能も合わせて利用すると幸せになれるかもしれません。 参考 出力される HTML ファイルのパスが変更されると、それに付随する画像ファイルとの位置関係が変わって、画像の表示ができなくなってしまうかもしれません。 下記の記事で紹介しているショートコードを使って画像を表示するようにしておくと、このような心配がなくなります。 参考: 画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle)`},{url:"/p/9n8p6n4/",title:"Hugo で画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle)",date:"2019-10-19T00:00:00+09:00",body:"Hugo で画像ファイルを Markdown ファイルと同じディレクトリに置く (Page Bundle) ページバンドルとは 初期の頃の Hugo では、画像ファイルは static ディレクトリに置いて、記事ファイル (Markdown) と別々のディレクトリで管理するという方法がとられていました。 content/ _index.md page1.md page2.md page3.md static/ image1.png image2.png image3.png しかし、これでは Markdown ファイルと画像ファイルをバラバラに管理しないといけないというユーザーの不満が出て、現状は content ディレクトリ以下に一緒に配置できるようになっています。 この仕組みを ページバンドル (Page Bundle) と言います。 参考: Page Bundles - Hugo ページバンドルは、その名のとおり、各ページにバンドルする形で画像ファイル（リソース）を保持するという考え方です。 ページバンドルを作成するには、content ディレクトリ以下に _index.md あるいは index.md を含むディレクトリを作成し、そのディレクトリ内に一緒に画像ファイルなどのリソースファイルを格納します（画像ファイル以外のファイルでも OK）。 つまり、バンドルされた画像ファイルを表示したいページは、_index.md あるいは index.md というファイル名のコンテンツでなければいけません。 Page Bundle には、Branch Bundle と Leaf Bundle の 2 種類があり、_index.md を含むディレクトリは Branch Bundle となり、index.md を含むディレクトリは Leaf Bundle となります。 content/ branch/ ← Branch Bundle _index.md image1.png data/ image2.png （不正なリソース） leaf/ ← Leaf Bundle index.md image3.png （Leaf Bundle のリソース） data/ image4.png （Leaf Bundle のリソース） Branch Bundle は、いわゆるセクションを構成するものなので、その下にさらに別のバンドル (Branch Bundle あるいは Leaf Bundle) を入れ子で持つことができます。 一方 Leaf Bundle は、末端のページであり、その下に別のバンドルを持つことはできません（というかその下に子ページを作れない）。 本家のサイトの記述を理解するのには中々時間がかかりますが、かみ砕いてまとめると次のような感じです。 Branch Bundle _index.md を持つディレクトリ。いわゆるセクションページに、画像などのリソースをくっつけたもの。 入れ子で別のバンドルを含むことができる（子ページを持てることと同義）。 リソースファイル用のサブディレクトリを持つことはできない（サブディレクトリは、あくまで別のページ用に作るものである）。だから、_index.md から参照する画像ファイルなどは、_index.md と同じディレクトリ内に並べて置く必要がある。 このディレクトリ以下に配置した Markdown ファイル (.md) は、別の独立したシングルページとして存在することになる（当たり前のように思えるけど、下の Leaf Bundle の場合はちょっと違う扱いになる）。 Leaf Bundle index.md を持つディレクトリ。いわゆるシングルページに、専用のディレクトリを割り当てたもの。 入れ子で別のバンドルは含められない。だから、ブランチ（枝）に対して、リーフ（葉）という名前が付けられている。 リソースファイル用のサブディレクトリを持つことができる。このディレクトリ以下に置いた index.md 以外のファイルは、どんなに深いディレクトリに置こうが、この Leaf Bundle のリソースである。だから、index.md から参照する画像ファイルは、それ以下の階層であればどこにでも置ける。 Markdown ファイル (.md) でさえ、このディレクトリ内に配置したら、Leaf Bundle のリソースという扱いになる（単独で表示する記事ページとはみなされない）。 Branch Bundle 内でのリソース参照 Branch Bundle から見ていきます。 下記の content ディレクトリは Branch Bundle を構成している部分の抜粋です。 content/ branch/ ← Branch Bundle _index.md image1.png data/ image2.png （不正なリソース） _index.md（セクションページ）の中から、同じ階層に置いた image1.png を下記のように参照することができます。 1 行目は HTML のべた書き、2 行目は Markdown の文法、3 行目は Hugo 組み込みの figure ショートコード を使用した記述方法です。 まぁ迷ったらショートコードを使用しておきましょう（まとめて振る舞いを変えやすいので）。 &lt;img src=&#34;image1.png&#34; alt=&#34;画像1&#34;&gt; ![画像1](image1.png) {{&lt; figure src=&#34;image1.png&#34; alt=&#34;画像1&#34; &gt;}} content/branch ディレクトリの下には、悪いリソースの配置例として data/image2.png ファイルを用意してあります。 実は Branch Bundle では、このように _index.md と違う階層に配置したリソースを参照することができません。 デフォルトの状態では、下記のようにすれば参照できてしまうかもしれませんが、 &lt;img src=&#34;data/image2.png&#34;&gt; ![data/image2](data/image2.png) {{&lt; figure src=&#34;data/image2.png&#34; &gt;}} _index.md のフロントマターで url プロパティなどを指定して、出力先のディレクトリを変更したとたんに 404 Not Found エラーになってしまいます。 なぜなら、data ディレクトリに配置した画像ファイルの出力先（コピー先）は、_index.md の出力先と連動して変化してくれないからです。 つまり、data ディレクトリ内のファイルは、_index.md にバンドルされたリソースとして扱われていないということです。 以上のような理由により、Branch Bundle では、基本的に画像ファイルを _index.md と同じディレクトリ内に配置することになります。 もちろん、フルパス指定で &lt;img src=&quot;/branch/data/image2.png&quot;&gt; と記述すれば、まったく別のディレクトリに出力された画像ファイルを参照できてしまいますが、そのような指定をするくらいであれば、従来の static ディレクトリを使ってリソースファイルを管理した方が余計なトラブルの心配が少ないと思います。 Leaf Bundle 内でのリソース参照 次に、もうひとつのページバンドルの種類である Leaf Bundle です。 下記の content ディレクトリは Leaf Bundle を構成している部分の抜粋です。 Leaf Bundle は Branch Bundle の下に入れ子にする形で配置できます。 というか、Leaf Bundle 同士で入れ子にしなければどこにでも置けます。 content/ branch/ ← Branch Bundle leaf/ ← Leaf Bundle index.md image3.png （Leaf Bundle のリソース） data/ image4.png （Leaf Bundle のリソース） index.md ファイル（アンダースコアなし）を配置したディレクトリが Leaf Bundle となります。 Branch Bundle と同様に、index.md ファイルと同じ階層に置かれた画像ファイルは、次のように参照することができます。 &lt;img src=&#34;image3.png&#34; alt=&#34;画像3&#34;&gt; ![画像3](image3.png) {{&lt; figure src=&#34;image3.png&#34; alt=&#34;画像3&#34; &gt;}} Branch Bundle とは異なり、Leaf Bundle ではそのディレクトリ以下のファイルがすべて自分自身にバンドルされているものだとみなされるため、深い階層に置いた画像ファイルにも直感的に（相対パスで）アクセスできます。 &lt;img src=&#34;data/image4.png&#34; alt=&#34;画像4&#34;&gt; ![画像4](data/image4.png) {{&lt; figure src=&#34;data/image4.png&#34; alt=&#34;画像4&#34; &gt;}} 逆に、index.md ファイルを置いたディレクトリ以下には、別のページを構成するための Markdown ファイルを配置することはできません。 配置したとしても、それはあくまで Leaf Bundle 内のリソースファイルとして扱われます。 ショートコードなどで、.Page.Resources 配列の内容を出力してみると、画像ファイルと一緒に Markdown ファイルも index.md ページに付随するリソースとして含まれていることが分かります。 index.md を配置したディレクトリは、そのページ専用のディレクトリになると考えましょう。 （応用）ページバンドルに含まれるリソースファイルの一覧を表示する 下記のショートコードは、現在のページにバンドルされているリソースファイルを列挙します。 layouts/shortcodes/list-page-resources.html &lt;ul&gt; {{- range .Page.Resources }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Name }}&lt;/a&gt; {{- end }} &lt;/ul&gt; 任意のページの Markdown ファイル内で下記のように使用します。 {{&lt; list-page-resources &gt;}} 参考: Page Resources - Hugo （応用）別のページのページバンドルリソースを参照する .Site.GetPage 関数などを使用して、別のページの Page インスタンスを取得すれば、そのページバンドルとして格納されているリソースファイルを参照することができます（もちろん、そのページがページバンドルになっている必要があります）。 ただ、こういった仕組みを使いすぎると、全体的に複雑な構成になってメンテナンス性が下がってしまいます。 共有したいリソースファイルがあるときは、できるだけ static ディレクトリを使って単純なファイルコピーで済ませられないか検討することをオススメします。 下記のショートコードを使用すると、dir パラメータで指定したページから、src で指定した名前の画像リソースを参照して表示できます。 layouts/shortcodes/shared-image.html {{ $dir := .Get &#34;dir&#34; }} {{ $src := .Get &#34;src&#34; }} {{ $page := .Page.GetPage $dir }} {{ $imagePath := ($page.Resources.GetMatch $src).RelPermalink }} &lt;img src=&#34;{{ $imagePath }}&#34;&gt; 例えば、下記のような構成で data/index.md による Leaf Bundle が作成されていて、その中の sample.png を外側のページから参照したいとします。 content/ section/ data/ ← Leaf Bundle index.md （Leaf Bundle を生成するには index.md が必要） sample.png _index.md （セクションページ） page.md （シングルページ） section/_index.md や section/page.md の中から、下記のようにショートコードを呼び出すと、data/sample.png を表示することができます。 つまり、2 つのページから 1 つのページバンドル内の画像を共有できます。 {{&lt; shared-image dir=&#34;data&#34; src=&#34;sample.png&#34; &gt;}} .Page.GetPage 関数に相対パス（上記の例では data）を渡すと、content ディレクトリ内の相対的な位置関係をもとに Page オブジェクトを取得できるようです。 なので、仮に section/_index.md や section/page.md のフロントマターで url プロパティを指定をして、HTML ファイルの出力先が変わったとしてもリソースは正しく参照できます。 （応用）image ショートコードを作成する Hugo は画像を表示するための組み込みショートコードとして figure を提供しています。 figure ショートコードの実装は、下記の GitHub リポジトリで参照できます。 shortcodes/figure.html - Hugo 画像の表示はいろいろとカスタマイズしたかったりするので（デフォルトで CSS クラスを付加するとか）、何か不満を感じたら、早めに自分専用のショートコードを作成してしまった方がよいでしょう。 figure ショートコードをベースにして少しずつ修正していけば簡単です。 私は自分用にカスタマイズした image という名前のショートコードを作成して使っています。 基本的に画面中央に画像を大きく表示するためのショートコードになっており、画像をインライン表示したい場合は、それ専用に作成した image-inline という別のショートコードを使っています。 layouts/shortcodes/image.html （大したことしてなかったので省略）"},{url:"/p/gv2dqi3/",title:"Androidメモ: StrictMode の違反メッセージを Toast で表示する (StrictModeToaster)",date:"2019-10-16T00:00:00+09:00",body:"Androidメモ: StrictMode の違反メッセージを Toast で表示する (StrictModeToaster) Android アプリの実装内で StrictMode の設定をしておくと、メインスレッドから I/O アクセスなどを行った場合に違反 (violation) 通知を受けることができます。 例えば StrictMode の設定時に、ThreadPolicy.Builder.penaltyLog() を呼び出しておくと、violation 発生時に Logcat に警告メッセージを出力してくれるようになります。 ここではさらに Toast で発生した violation の名称を表示するようにしてみます。 violation 発生時に Toast 表示を行うことで、violation の見逃しを防ぎやすくなります。 StrictModeToaster クラスで violation をトースト表示する 下記の StrictModeToaster クラスを使用すると、StrictMode の violation が発生したときに、violation 名を Toast で表示することができます。 同時に、violation の詳細内容（コールスタック）が Logcat に出力されます。 使い方は、Application クラスなどの先頭で StrictModeToaster.setup() を呼び出すだけです。 App.kt class App : Application() { override fun onCreate() { super.onCreate() StrictModeToaster.setup(applicationContext) } } StrictModeToaster.kt package com.example.myapp import android.content.Context import android.content.pm.ApplicationInfo import android.os.Handler import android.os.Looper import android.os.StrictMode import android.os.strictmode.Violation import android.widget.Toast import java.util.concurrent.ExecutorService import java.util.concurrent.Executors /** * StrictMode utility to show a violation message as a toast. * To enable the StrictMode, just call [setup] at the beginning of the application. */ object StrictModeToaster { // To show a toast private val mainThreadHandler by lazy { Handler(Looper.getMainLooper()) } private lateinit var appContext: Context // To handle violation messages private val workerThreadExecutor: ExecutorService by lazy { Executors.newSingleThreadExecutor() } private val vmViolationListener by lazy { StrictMode.OnVmViolationListener(::showViolationName) } private val threadViolationListener by lazy { StrictMode.OnThreadViolationListener(::showViolationName) } /** * Starts handling strict mode violation messages. * This method must be called as soon as possible after launching the app. */ fun setup(context: Context) { // Enable the strict mode only when the debuggable flag is true if (context.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE == 0) { return } appContext = context.applicationContext StrictMode.setThreadPolicy( StrictMode.ThreadPolicy.Builder() .detectAll() .penaltyLog() .penaltyListener(workerThreadExecutor, threadViolationListener) .build() ) StrictMode.setVmPolicy( StrictMode.VmPolicy.Builder() .detectAll() .penaltyLog() .penaltyListener(workerThreadExecutor, vmViolationListener) .build() ) } /** * Shows the [violation] name with a Toast. */ private fun showViolationName(violation: Violation) { val message: String = violation.javaClass.simpleName mainThreadHandler.post { Toast.makeText(appContext, message, Toast.LENGTH_LONG).show() } } } StrictModeToaster クラスの説明 デバッグビルドの判断 StrictModeToaster.setup() を実行すると、DEBUG ビルドのときのみ StrictMode に関する設定が行われるようになっています。 デバッグビルドかのチェックには、よく BuildConfig.DEBUG に設定されている Boolean フラグを見たりするのですが、このクラスはビルド時にアプリパッケージ以下に自動生成されるクラスなので、汎用的なライブラリの実装からは参照できません。 ここでは、ApplicationInfo.flags を見て、デバッグビルドかどうかの判別を行うようにしています。 build.gradle や AndroidManifest.xml で余計な設定をしていない限り、デバッグビルド時に FLAG_DEBUGGABLE のビットが 1 になります。 violation 発生時のハンドル ThreadPolicy.Build.penaltyListener() を使用すると、StrictMode の violation 発生時に呼び出されるコールバック関数を登録することができます。 上記の例では、threadViolationListener をコールバック関数として登録しています。 このコールバック関数自体はワーカースレッド (workerThraderExecutor) 上で呼び出されるようにしているので、Toast の表示時にはメインスレッド用のハンドラ (mainThreadHandler) へ処理を委譲する必要があります。"},{url:"/p/wzufzn6/",title:"Node.jsメモ: npm run のスクリプトの中でディレクトリを削除する (rimraf)",date:"2019-10-07T00:00:00+09:00",body:"Node.jsメモ: npm run のスクリプトの中でディレクトリを削除する (rimraf) なぜ rimraf が必要か？ TypeScript などのトランスパイラを使って Node.js アプリを開発していると、ビルド結果を格納するディレクトリを削除する clean コマンド（NPM スクリプト）を定義したくなります。 package.json { &#34;scripts&#34;: { &#34;clean&#34;: &#34;rm -rf build&#34; } } これはこれで間違いではないのですが、Linux の rm コマンドを使用しているので、OS 依存の package.json になってしまいます。 そこで、OS に依存しない rm -rf コマンドを実現するのが rimraf という NPM パッケージです。 rimraf は NPM の作者である Isaac 氏が作成しており、安心して使用できます。 rimraf という名前は Linux コマンドの rm -rf の発音が由来だと言われています。 rimraf の使い方 rimraf のインストール rimraf コマンドは NPM パッケージとして提供されているので、下記のように簡単にインストールすることができます。 $ npm install --save-dev rimraf --save-dev オプションを付けて、package.json の devDependencies エントリに追加するようにしましょう。 rimraf でディレクトリを削除する 下記の package.json では、build ディレクトリをごっそり削除する clean スクリプトを定義しています。 { &#34;scripts&#34;: { &#34;clean&#34;: &#34;rimraf build&#34; } } あとは、下記のように clean スクリプトを起動するだけで、build ディレクトリを削除することができます。 build ディレクトリが存在しない場合は何も起こりません。 $ npm run clean"},{url:"/p/fzudboe/",title:"Node.jsメモ: npm run のスクリプトを連続実行・並列実行する (npm-run-all)",date:"2019-10-07T00:00:00+09:00",body:"Node.jsメモ: npm run のスクリプトを連続実行・並列実行する (npm-run-all) なぜ npm-run-all が必要か？ package.json の scripts プロパティでスクリプトを定義しておくと、任意のコマンドを npm run コマンド経由で実行できるようになります（以降 NPM スクリプトと呼びます）。 しかし、デフォルトでは、複数の NPM スクリプトを連続して実行する方法（Linux の cmd1 &amp;&amp; cmd2）や、並列に実行する方法（Linux の cmd1 &amp; cmd2）は提供されていません。 強引に各 OS のシェルの &amp;&amp; や &amp; を組み合わせることでできないことはありませんが、Windows と Linux で記述方法が異なるので、OS に依存した package.json になってしまいます。 このような場合に、npm-run-all という NPM パッケージを使用すると、複数の NPM スクリプトを逐次／並列実行するスクリプトを、OS に依存しない形で記述できるようになります。 npm-run-all パッケージ npm-run-all の使い方 npm-run-all のインストール npm-run-all は下記のようにインストールします。 $ npm install --save-dev npm-run-all npm-run-all コマンドは、package.json の scripts 定義の中から呼び出して使用するので、上記のように --save-dev オプションを指定して、devDependencies の依存情報に追加するようにしましょう。 npm-run-all でシーケンシャル実行 (run-s) run-s （npm-run-all のショートカット）というコマンドを使用すると、指定した NPM スクリプトをシーケンシャルに（ひとつずつ順番に）実行していくことができます。 package.json { // ... &#34;scripts&#34;: { &#34;hello&#34;: &#34;run-s hello:foo hello:bar&#34;, &#34;hello:foo&#34;: &#34;echo FOO&#34;, &#34;hello:bar&#34;: &#34;echo BAR&#34; }, // ... } 上記の hello スクリプトを実行すると、hello:foo と hello:bar のスクリプトが順番に実行されます。 $ npm run -s hello FOO BAR ちなみに、上記のように : を使ってスクリプト名を細分化しておくと、グロブでスクリプトをまとめて指定することができます。 &#34;scripts&#34;: { &#34;hello&#34;: &#34;run-p hello:*&#34;, npm-run-all でパラレル実行 (run-p) run-p （npm-run-all --parallel のショートカット）というコマンドを使用すると、指定した NPM スクリプトを並列に実行することができます。 package.json { // ... &#34;scripts&#34;: { &#34;hello&#34;: &#34;run-p hello:*&#34;, &#34;hello:foo&#34;: &#34;timeout /t 3 &gt; nul &amp; echo FOO&#34;, &#34;hello:bar&#34;: &#34;timeout /t 3 &gt; nul &amp; echo BAR&#34; }, // ... } このサンプルは、Windows の timeout コマンド（指定した秒数だけスリープ）を使用しているのであまりよくない例ですが、run-p の効果を確かめるにはこのようなスリープ＆エコーが手っ取り早いです。 下記のように実行すると、hello:foo と hello:bar スクリプトのスリープが同時に開始されるので、FOO と BAR の出力がほぼ同時に行われます。 $ npm run -s hello FOO BAR hello スクリプトの中の run-p という部分を run-s に変更すると、FOO が出力された後 3 秒待ってから BAR と表示されるはずです。"},{url:"/p/j9dkm52/",title:"Node.jsメモ: npm run のスクリプトの中でファイルのコピーを行う (cpx)",date:"2019-10-05T00:00:00+09:00",body:"Node.jsメモ: npm run のスクリプトの中でファイルのコピーを行う (cpx) OS 依存のコピーコマンドでファイルコピーする方法 package.json の scripts プロパティでスクリプトを定義しておくと、任意のコマンドを npm run コマンド経由で実行できるようになります。 参考: npm run で任意のコマンドを実行する (npm run, npm start) このスクリプト定義は便利なので、例えば、下記のようにファイルのコピーや削除を行うスクリプトを定義したくなるかもしれません。 package.json（Windows でしか動作しない copy スクリプトの定義） { &#34;scripts&#34;: { &#34;copy&#34;: &#34;xcopy /S /H /Y static\\\\** build\\\\&#34; } } この copy スクリプトを下記のように実行すると、static ディレクトリ内のファイルが build ディレクトリにすべてコピーされます。 D:\\&gt; npm run copy しかし、xcopy コマンドは Windows のコマンドなので、Linux などで同様のことを行うためには、下記のように別のスクリプトを用意しなければいけません。 { &#34;scripts&#34;: { &#34;copy-win&#34;: &#34;xcopy /S /H /Y static\\\\** build\\\\&#34;, &#34;copy-linux&#34;: &#34;mkdir -p ./build &amp;&amp; cp -pR ./static/* ./build&#34; } } Toru Nagashima さんの作成した cpx という NPM パッケージを使用すると、ファイルのコピー処理を汎用的に記述することができます。 同様のことを行える copyfiles という NPM パッケージもあるのですが、ここでは使い方がよりシンプルな cpx を採用することにします。 cpx パッケージを使ってファイルコピーする方法 NPM のパッケージとして公開されている cpx コマンドを使用すると、OS に依存しないファイルのコピー を行うことができます。 cpx を使用すると、グロブ形式でコピーするファイルを指定できたり、コピー先のディレクトリを自動生成してくれたりします。 cpx パッケージ (npm) cpx は下記のように開発用のコマンドとしてインストールしましょう。 cpx パッケージのインストール $ npm install --save-dev cpx これにより、ローカルの node_modules/.bin ディレクトリに cpx コマンドがインストールされ、package.json の devDependencies プロパティに依存関係情報も追加されます。 cpx コマンドは、package.json で定義するスクリプト内から下記のように呼び出すことができます。 package.json（OS に依存しない copy スクリプトの定義） { &#34;scripts&#34;: { &#34;copy&#34;: &#34;cpx -C static/** build&#34; } } cpx コマンドの実体は、node_modules/.bin ディレクトリ以下にインストールされているのですが、npm 実行時にこのディレクトリに自動的にパスが通るようになっているので、上記のようにコマンド名だけを直接指定できるようになっています。 これで、次のように実行するだけで、static ディレクトリ内のファイルを build ディレクトリに丸ごとコピーできます。 $ npm run copy ここでは cpx の -C オプションを指定していますが、このオプションを指定すると、コピー元に存在しないファイルが、コピー先のディレクトリから削除されます（ゴミファイルが残るのを防げます）。 明示的にディレクトリを削除したい場合は、rimraf を使用してディレクトリを削除 するようにしましょう。"},{url:"/p/ymzvh9q/",title:"Kotlinメモ: lateinit による変数の初期化",date:"2019-09-25T00:00:00+09:00",body:"Kotlinメモ: lateinit による変数の初期化 lateinit 変数とは クラスのプロパティは、できるだけ val（再代入不可）変数として定義すると保守性の高いコードを作成することができます。 val 変数は生成時に参照先のオブジェクトを確定しておく必要があるため、変数の宣言時に代入するか、init ブロックでの代入が必要です。 class Potter { private val magics = mutableListOf&lt;String&gt;() //... } しかし、Android などのフレームワーク上で実装を行っている場合、どうしてもフレームワークによる初期化関数の呼び出しの段階まで変数の初期化ができないことがあります。 このようなケースで val 変数の代わりに使用できるのが lateinit 変数です。 下記は Android の Activity 実装の抜粋です。 ここでは、surfaceView 変数を lateinit で宣言することにより、初期化タイミングを onCreate() 呼び出しまで遅延させています。 lateinit 変数は var で宣言しないといけないことに注意してください。 class MainActivity : Activity() { private lateinit var surfaceView: SurfaceView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) surfaceView = SurfaceView(this) } //... } 変数を lateinit 宣言することにより、non-null な初期化済みの変数として参照することができるようになります。 ただし、参照する前に必ず初期化（代入）されていることが条件となります。 初期化前に lateinit 変数を参照すると、次のような UninitializedPropertyAccessException が発生します。 Exception in thread &#34;main&#34; kotlin.UninitializedPropertyAccessException: lateinit property book has not been initialized lateinit 変数の使用例 DI による依存注入 lateinit による変数初期化は、Dagger などの DI 系ツールで依存関係を注入するときにもよく使用されます。 class MyClass { @Inject lateinit var logger: Logger //... } 上記の logger 変数は、Dagger により MyClass オブジェクトが生成されるときに自動的に初期化されます。 テストクラスの SetUp 下記は Kotlin のサイトに紹介されている例ですが、テストクラスのセットアップメソッドが呼ばれた段階で subject 変数の初期化を行っています。 public class MyTest { lateinit var subject: TestSubject @SetUp fun setup() { subject = TestSubject() } @Test fun test() { subject.method() // dereference directly } } セットアップメソッドが最初に実行されることが保障されているので、このように lateinit 宣言することができます。 参考情報 lateinit 変数が初期化されているかどうかを調べる (isInitialized)"},{url:"/p/qpc53iy/",title:"Kotlinメモ: lateinit 変数が初期化されているかどうかを調べる (isInitialized)",date:"2019-09-25T00:00:00+09:00",body:"Kotlinメモ: lateinit 変数が初期化されているかどうかを調べる (isInitialized) isInitialized の概要 Kotlin 1.2 以降では、lateinit 変数が初期化済みかどうかを isInitialized を使って調べることができます。 あるクラスのプロパティが初期化済みかどうかを調べるには次のようにします。 if (::プロパティ.isInitialized) { // プロパティは初期化済み (代入済み） } 直接プロパティにアクセスすると UninitializedPropertyAccessException が発生する可能性があるため、上記のようにプロパティ参照の仕組みを利用して参照するところがポイントです。 isInitialized の使用例 下記の initSubject() メソッドでは、lateinit 変数である subject が初期化されているかどうかを isInitialized で調べ、初期化されていない場合にのみ初期化を行うようにしています。 foo() や bar() メソッドの中で最初に initSubject() を呼び出すことで、subject が確実に初期化されてから参照されるようにしています。 class MyClass { private lateinit var subject: Subject private fun initSubject(context: Context) { if (::subject.isInitialized) { return } // ここで context を使って subject を初期化する } fun foo(context: Context) { initSubject(context) // ... subject を使う処理 ... } fun bar(context: Context) { initSubject(context) // ... subject を使う処理 ... } //... } subject の初期化には foo() や bar() の呼び出し時に渡される Context オブジェクトを必要としているため、このタイミングで初期化するしか方法がないと想定しています。"},{url:"/p/qrrnw9b/",title:"Kotlinメモ: safe call (?.) や elvis operator (?:)、let で null をうまく扱う",date:"2019-09-24T00:00:00+09:00",body:"Kotlinメモ: safe call (?.) や elvis operator (?:)、let で null をうまく扱う null を扱うさまざまな演算子・関数 Kotlin には、null をうまく扱うための便利な演算子や関数が用意されています。 代表的なものに下記があります。 オブジェクト?.メソッド (safe call) オブジェクトが null でないならメソッドを呼び出す。null なら null を返す。 式1 ?: 式2 (Elvis operator) 式1が null でないならその値、null なら式2を評価する オブジェクト!! (not-null assertion / unsafe dereference) nullable なオブジェクトを not-null なオブジェクトとして参照する。 万が一 null だった場合は NullPoiterException が発生する。 使用例 オブジェクトが null じゃない場合のみメソッドを呼び出す／プロパティを参照する logger?.log(&#34;Hello&#34;) logger 変数が null でない場合のみ log() メソッドを実行します。 null の場合は何も行いません。 val label = book?.title book 変数が null でない場合に title プロパティの値を取得します。 book 変数が null の場合は null が返されます。 オブジェクトが null だった場合にデフォルト値を設定／処理を打ち切る val title = book?.title ?: &#34;Unknown title&#34; book 変数が null でない場合は book.title の値を、null である場合は &ldquo;Unknown title&rdquo; を title に代入します。 book book.title 結果 null ─ &ldquo;Unknown title&rdquo; not null null &ldquo;Unknown title&rdquo; not null not null book.title 下記も似たような使い方ですが、値が取得できないときにデフォルト値を設定する代わりに、return したり、例外を投げて処理を打ち切っています。 val title = book?.title ?: return val title = book?.title ?: throw Error(&#34;Book must have a title&#34;) オブジェクトが null のときに一連の処理を行う val title = book.title ?: run { log(&#34;Could not display the book because of lack of title&#34;) return } あるオブジェクトやそのプロパティが null だった場合にのみ一連の処理を行いたい場合は、elvis operator (?:) と run を組み合わせて使用します。 上記では、book は null でないことを想定していますが、book 自体が null であるケースも想定するのであれば、book?.title ?: run {} と、safe call を組み合わせれば OK です。 オブジェクトが null でないときに一連の処理を行う // var book: Book? = null book?.let { // let の中では it で non-null な book を参照できる println(it.title) println(it.author) } safe call (?.) と let 関数を組み合わせた safe call let と呼ばれているイディオムです。 上記の例では、変数 book が null でない場合に book のプロパティを参照する処理を実行します。 book が null でない場合にメソッドを 1 つだけ呼び出したい場合は、単純に safe call で book?.foo() とすればよいのですが、上記のように連続してオブジェクトを参照したい場合や、そのオブジェクト自体をパラメータとして別の関数に渡したい場合などに利用します。 別の関数のパラメータとして渡したい場合は次のように簡潔に記述することができます。 book?.let(display::showBookCover) これは、下記のように記述するのと同じです。 book?.let { display.showBookCover(it) } （コラム）let はラムダ式の評価結果を返すことに注意 let の戻り値の振る舞いをきちんと理解していないと、思わぬ不具合の元になります。 次の safe call let イディオムを見てください。 book?.let(logger::printTitle) ?: logger.showError(); あるいは、下記でも同様。 book?.let { logger.printTitle(it) } ?: logger.showError(); このコードは、book が null でない場合に printTitle(book) を実行し、null である場合に showError() を実行するコードのように見えます。 しかし、let() は実行したラムダ式の評価結果を返すため、printTitle(book) が null を返した場合にも showError() が実行されてしまいます。 この振る舞いはきっと意図したものとは異なります。 素直に下記のように書くべきかもしれません。 if (book != null) { logger.printTitle(book) } else { logger.showError() }"},{url:"/p/imx8hr2/",title:"Choreographer で FPS を計測する（Fps クラスの実装）",date:"2019-09-18T00:00:00+09:00",body:"Choreographer で FPS を計測する（Fps クラスの実装） Choreographer クラスによる FPS 計測 Android の Choreographer クラスを使用すると、フレームの描画開始のタイミングで呼び出されるコールバック (Choreographer.FrameCallback) を登録することができます。 Choreographer#postFrameCallback(callback: Choreographer.FrameCallback!) 上記のメソッドでコールバックを登録すると、次のフレーム描画のタイミングで doFrame(long frameTimeNanos) メソッドが呼び出されます。 Choreographer.FrameCallback#doFrame(frameTimeNanos: Long) パラメータとして描画開始時刻（ナノ秒単位）が渡されるため、前回のコールバック時の描画開始時刻からの差分を取れば、1 フレームの描画にかかった時間を求めることができます。 この値を使えば、FPS (Frame per second) は下記のように計算できます。 FPS = 1秒あたりのナノ秒 / 描画にかかった時間（ナノ秒） サンプルコード Fps クラスの実装 下記の Fps クラスは、FPS を簡単に計測するためのクラスです。 内部で Android の Choreographer を使っています。 Fps.kt import android.view.Choreographer import java.util.concurrent.TimeUnit class Fps : Choreographer.FrameCallback { interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Float) } private val choreographer = Choreographer.getInstance() private var fpsCallback: FpsCallback? = null private var prevFrameTimeNanos: Long = 0 /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: FpsCallback) { this.fpsCallback = fpsCallback prevFrameTimeNanos = 0 choreographer.postFrameCallback(this) } /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: (Float) -&gt; Unit) { startObserving(object : FpsCallback { override fun onFpsUpdated(fps: Float) = fpsCallback(fps) }) } /** * Stops observing the FPS. */ fun stopObserving() { choreographer.removeFrameCallback(this) } /** * Implementation for [Choreographer.FrameCallback]. */ override fun doFrame(frameTimeNanos: Long) { // Register the same callback again to be called continuously choreographer.postFrameCallback(this) // At first, just store the frame time for later calculation if (prevFrameTimeNanos == 0L) { prevFrameTimeNanos = frameTimeNanos return } // Calculate FPS and pass it to the callback function val elapsed = frameTimeNanos - prevFrameTimeNanos val fps = TimeUnit.SECONDS.toNanos(1) / elapsed.toFloat() checkNotNull(fpsCallback).onFpsUpdated(fps) prevFrameTimeNanos = frameTimeNanos } } Choreographer#postFrameCallback() で登録したコールバックは、一度しか呼び出されないことに注意してください。 連続してフレーム描画のタイミングを取得するには、毎回同じコールバックを登録し直す必要があります（上記では、doFrame() メソッドの先頭で登録しています）。 Fps クラスの使用例 Fps クラスを使って FPS の観測を行うには、例えば次のようにします。 Fps().startObserving { fps -&gt; Log.i(&#34;DEBUG&#34;, &#34;FPS = %.3f&#34;.format(fps)) } （応用） 1 秒おきに平均 FPS を求める 上記のサンプルコードでは、毎フレーム FPS を求めてコールバック関数を呼び出していましたが、これでは高頻度すぎるという場合は、下記のようにすれば約 1 秒ごとに呼び出すように軽量化できます。 FrameCallback.doFrame() が呼び出されたときに、前回のコールバックから 1 秒以上経過している場合だけ、コールバックするようにしています。 ここでは、約 1 秒間のフレーム数を数えて平均 FPS を求めています。 Fps.kt (2) import android.view.Choreographer import java.util.concurrent.TimeUnit /** * Utility class for obtaining FPS (frames per second). */ class Fps : Choreographer.FrameCallback { companion object { /** Callbacks are invoked at intervals of this time. */ private val CALLBACK_INTERVAL_NANOS = TimeUnit.SECONDS.toNanos(1) } interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Double) } private val choreographer = Choreographer.getInstance() private var fpsCallback: FpsCallback? = null private var prevCallbackTimeNanos: Long = 0 /** How many times doFrame is called since the last onFpsUpdated. */ private var frames = 0 /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: FpsCallback) { this.fpsCallback = fpsCallback prevCallbackTimeNanos = 0 frames = 0 // Add a frame callback but prevents duplicate registration choreographer.removeFrameCallback(this) choreographer.postFrameCallback(this) } /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: (Double) -&gt; Unit) { startObserving(object : FpsCallback { override fun onFpsUpdated(fps: Double) = fpsCallback(fps) }) } /** * Stops observing the FPS. */ fun stopObserving() { choreographer.removeFrameCallback(this) } /** * Implementation for [Choreographer.FrameCallback]. */ override fun doFrame(frameTimeNanos: Long) { // Register the same callback again to be called continuously choreographer.postFrameCallback(this) // At first, just store the frame time for later calculation if (prevCallbackTimeNanos == 0L) { prevCallbackTimeNanos = frameTimeNanos return } frames++ // Callback at the intervals of CALLBACK_INTERVAL_NANOS val elapsed = frameTimeNanos - prevCallbackTimeNanos if (elapsed &gt;= CALLBACK_INTERVAL_NANOS) { // Calculate FPS and pass it to the callback function val fps = frames.toDouble() * TimeUnit.SECONDS.toNanos(1) / elapsed checkNotNull(fpsCallback).onFpsUpdated(fps) // Reset counters prevCallbackTimeNanos = frameTimeNanos frames = 0 } } } （応用） 1 秒おきに最低 FPS を求める 上記の例では、1 秒間の描画フレーム数を数えることで秒間平均 FPS を求めていましたが、その方法だと、あるフレームが非常に遅くても、残りのフレームが高速であれば、FPS としては比較的高い値が出てしまいます。 ここでは、もっとストイックに、過去 1 秒間で最も時間のかかったフレームの描画時間をもとに、FPS 計算するようにしてみます。 つまり、 秒間最低 FPS（秒間最悪 FPS） です。 秒間最低FPS = 1秒あたりのns / 最も時間のかかったフレームの描画時間(ns) Fps.kt (3) import android.view.Choreographer import java.lang.Long.max import java.util.concurrent.TimeUnit /** * Utility class for obtaining FPS (frames per second). */ class Fps : Choreographer.FrameCallback { companion object { /** Callbacks are invoked at intervals of this time. */ private val CALLBACK_INTERVAL_NANOS = TimeUnit.SECONDS.toNanos(1) } interface FpsCallback { /** Called when the latest FPS is calculated. */ fun onFpsUpdated(fps: Double) } private val choreographer = Choreographer.getInstance() private var fpsCallback: FpsCallback? = null private var prevCallbackTimeNanos: Long = 0 private var prevFrameTimeNanos: Long = 0 /** Maximum frame time over the last one minute. */ private var worstFrameTimeNanos: Long = 1 /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: FpsCallback) { this.fpsCallback = fpsCallback prevCallbackTimeNanos = 0 // Add a frame callback but prevents duplicate registration choreographer.removeFrameCallback(this) choreographer.postFrameCallback(this) } /** * Starts observing the FPS. * [fpsCallback] is invoked continuously after calling this method. */ fun startObserving(fpsCallback: (Double) -&gt; Unit) { startObserving(object : FpsCallback { override fun onFpsUpdated(fps: Double) = fpsCallback(fps) }) } /** * Stops observing the FPS. */ fun stopObserving() { choreographer.removeFrameCallback(this) } /** * Implementation for [Choreographer.FrameCallback]. */ override fun doFrame(frameTimeNanos: Long) { // Register the same callback again to be called continuously choreographer.postFrameCallback(this) // At first, just store the frame time for later calculation if (prevCallbackTimeNanos == 0L) { prevCallbackTimeNanos = frameTimeNanos prevFrameTimeNanos = frameTimeNanos return } worstFrameTimeNanos = max(worstFrameTimeNanos, frameTimeNanos - prevFrameTimeNanos) // Callback at the intervals of CALLBACK_INTERVAL_NANOS val elapsed = frameTimeNanos - prevCallbackTimeNanos if (elapsed &gt;= CALLBACK_INTERVAL_NANOS) { // Calculate the minimum FPS and pass it to the callback function val fps = TimeUnit.SECONDS.toNanos(1).toDouble() / worstFrameTimeNanos checkNotNull(fpsCallback).onFpsUpdated(fps) // Reset counters prevCallbackTimeNanos = frameTimeNanos worstFrameTimeNanos = 1 } prevFrameTimeNanos = frameTimeNanos } }"},{url:"/p/r5f583b/",title:"Kotlinメモ: immutable なコレクションを mutable に変換する (toMutableList, toMutableSet, toMutableMap)",date:"2019-09-17T00:00:00+09:00",body:"Kotlinメモ: immutable なコレクションを mutable に変換する (toMutableList, toMutableSet, toMutableMap) Kotlin の List インタフェースや Map インタフェースは immutable（不変）なインタフェースとして定義されており、add や set といった要素を変更するメソッドが定義されていません。 toMutableList listOf() などで生成した immutable（不変）なリストから mutable なリストを生成するには、toMutableList() メソッドを使用します。 val list1 = listOf(1, 2, 3) val list2 = list1.toMutableList() list2.add(4) // list2 += 4 でも OK println(list1) //=&gt; [1, 2, 3] println(list2) //=&gt; [1, 2, 3, 4] toMutableList() はリストのコピーを作成するため、元の list1 変数が参照しているリストの内容は変更されていないことに注意してください。 toMutableSet / toMutableMap toMutableList() と同様に、セット用には toMutableSet()、マップ用には toMutableMap() が用意されています。 下記は、setOf() で作成した immutable（不変）なセットを mutable なセットに変換する例です。 val set1 = setOf(1, 2, 3) val set2 = set1.toMutableSet() set2.add(4) // set2 += 4 でも OK println(set1) //=&gt; [1, 2, 3] println(set2) //=&gt; [1, 2, 3, 4] 使用するメソッドが toMutableList() から toMutableSet() に変わっただけです。 マップの場合も同様です。 val map1 = mapOf(&#34;one&#34; to 1, &#34;two&#34; to 2, &#34;three&#34; to 3) val map2 = map1.toMutableMap() map2.put(&#34;four&#34;, 4) // map2 += &#34;four&#34; to 4 でも OK println(map1) //=&gt; {one=1, two=2, three=3} println(map2) //=&gt; {one=1, two=2, three=3, four=4} 要素の追加に使用するメソッドが add() から put() に変わるくらいです。 関連記事 Kotlinメモ: クラス内の MutableList を immutable な List にして公開する"},{url:"/p/9fwrpnu/",title:"Kotlinメモ: クラス内の MutableList を immutable な List にして公開する",date:"2019-09-17T00:00:00+09:00",body:"Kotlinメモ: クラス内の MutableList を immutable な List にして公開する 参考: Kotlinメモ: immutable なコレクションを mutable に変換する (toMutableList, toMutableSet, toMutableMap) 上記の記事では、immutable（不変）な List から MutableList を生成する例を示していますが、逆に、mutable（可変）なオブジェクトを immutable にして見せたいことがあります。 定型的なのは、クラス内のフィールドとして MutableList を持っているときに、不変なリストとして外部に公開したいケースです。 このような場合は、単純に戻り値の型を List にアップキャストしたメソッド（あるいはプロパティ）を用意するだけで対応できます。 class TitleList { private val mutableTitles = mutableListOf&lt;String&gt;() val titles: List&lt;String&gt; = mutableTitles // メンバーメソッドからは内部のリストを変更できる fun changeInternally1() { mutableTitles.add(&#34;Title1&#34;) } fun changeInternally2() { mutableTitles.add(&#34;Title2&#34;) } } fun main() { val list = TitleList() list.changeInternally1() list.changeInternally2() println(list.titles) //=&gt; [Title1, Title2] // 下記はエラー list.titles.add(&#34;Title3&#34;) // Unresolved reference: add } ただし、このような実装はスレッドセーフではないことに注意してください。 titles プロパティが参照するリストオブジェクトの実体は、mutableTitles が参照するものと同じだからです。 下記のように実行すると、titles 変数の内容が、外部要因によってどんどん変化していくことが分かります。 fun main() { val list = TitleList() val titles = list.titles println(titles) //=&gt; [] list.changeInternally1() println(titles) //=&gt; [Title1] list.changeInternally2() println(titles) //=&gt; [Title1, Title2] } titles プロパティによって取得したリストの内容が別スレッドから変更されないことを保証するには、下記のようにコピーして作成したリストを返すように実装します。 class TitleList { private val mutableTitles = mutableListOf&lt;String&gt;() val titles: List&lt;String&gt; get() = mutableTitles.toList() //... } このように、外部からの変更の恐れをなくすために丸ごとコピーしちゃう手法を 防御的コピー (defencive copying) と呼びます。 Effective Java の「項目39: 必要な場合には、防御的にコピーする」に詳しく記述されています。 おまけ Android の LiveData の例 Android アプリを作成していると、LiveData まわりで同様の処理が必要になったります。 class PlayerViewModel : ViewModel() { private val life_ = MutableLiveData&lt;Int&gt; val life: LiveData&lt;Int&gt; = life_ //... } MutableLiveData フィールドを private に定義しておくことで、内部からは LiveData の値を変更できるようにしつつ、外部からはリードオンリーな LiveData 型で参照するようにしています。"},{url:"/p/vu7hr2b/",title:"Hugo サイトの favicon.ico をサイトのルートに配置する (static)",date:"2019-09-10T00:00:00+09:00",body:"Hugo サイトの favicon.ico をサイトのルートに配置する (static) Hugo によって生成した Web サイトのルート階層に favicon.ico を配置するには、static ディレクトリに favicon.ico ファイルをそのまま置いておけば OK です。 website/ +-- content/ +-- layouts/ +-- static/ +-- favicon.ico static ディレクトリ以下に置いたファイル群は、その階層構造を保ったまま出力ディレクトリへコピーされます。 favicon の詳細については下記を参考にしてください。 Web サイトに favicon を設定する"},{url:"/p/zmr4tpu/",title:"Kotlinメモ: ある処理にかかった時間を計測する (measureTimeMillis/Micros)",date:"2019-09-02T00:00:00+09:00",body:"Kotlinメモ: ある処理にかかった時間を計測する (measureTimeMillis/Micros) 下記の Kotlin の組み込み関数を使用すると、ブロックで渡した一連の処理にかかった時間を計測することができます。 measureTimeMillis() - ブロックで渡した処理にかかる時間を「ミリ秒」単位で計測 measureTimeMicros() - ブロックで渡した処理にかかる時間を「マイクロ秒」単位で計測 import kotlin.system.measureTimeMillis val time = measureTimeMillis { val one = doSomething1() val two = doSomething2() println(&#34;The answer is ${one + two}&#34;) } println(&#34;Completed in $time ms&#34;) 計測範囲が分かりやすくてよいですね！"},{url:"/p/b9ij3zq/",title:"Androidメモ: Preference フレームワークを使って設定画面を簡単に作成する",date:"2019-08-19T00:00:00+09:00",body:"Androidメモ: Preference フレームワークを使って設定画面を簡単に作成する 図: Preference フレームワークを使った設定画面 Preferences フレームワーク Android が提供する Preferences フレームワークを使用すると、SharedPreferences による設定リソースをベースにした設定画面を簡単に作成することができます。 設定画面の表示は Android が用意している PreferenceFragmentCompat クラスにより行われるため、ユーザーが使い慣れた UI で設定画面を表示することができます。 設定画面に表示する項目は、PreferenceScreen 要素をルートにした XML ファイルを作成することで定義できます（コード内で動的に PreferenceScreen オブジェクトを構築することもできます）。 PreferenceFragmentCompat クラス 設定画面を表示するためのベースとなる Fragment クラスです。 （コラム）API level 28 以前は、設定画面用のクラスとして PreferenceActivity が使われていましたが、今は PreferenceFragmentCompat クラスを使用します。 PreferenceScreen レイアウトファイル PreferenceActivity で表示する設定項目の階層構造を定義した XML ファイルです。ユーザーが選択できる項目のリストを管理したり、SharedPreferences のキーを関連付けたりすることができます。 ライブラリの依存関係の追加 PreferenceFragmentCompat クラスを使用するには、androidx.preference:preference ライブラリへの依存を追加しておく必要があります。 ライブラリのバージョン番号は こちらのリリースページ で確認できます（2020年4月15日のリリースは 1.1.1）。 app/build.gradle dependencies { implementation &#39;androidx.preference:preference:1.1.1&#39; } （コラム）Preferences 系のクラスは、以前は support ライブラリとして提供されており、名前空間は android.preference でした。現在は androidx.preference という名前空間で提供されている Jetpack ライブラリ (AndroidX) の方を使用する必要があります。 設定項目を定義する Android アプリのレイアウトファイルは通常 res/layout ディレクトリに配置しますが、Preferences フレームワークを使って設定画面を表示する場合は、res/xml ディレクトリに XML ファイルを配置します。 ファイル名は任意ですが、ここでは preferences.xml とします（プログラム内からは R.xml.preferences と参照することになります）。 この XML ファイルのルート要素は androidx.preference.PreferenceScreen にする必要があります。 下記は、2 つのスイッチ項目と、2 つのチェックボックス項目を持つ PreferenceScreen レイアウトの例です。 それぞれを PreferenceCategory でグルーピングして表示しています。 res/xml/preferences.xml &lt;androidx.preference.PreferenceScreen xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&gt; &lt;PreferenceCategory android:title=&#34;スイッチによる設定&#34;&gt; &lt;SwitchPreferenceCompat android:key=&#34;switch1&#34; android:title=&#34;スイッチ1&#34; android:summary=&#34;1つ目のスイッチだよ&#34; android:defaultValue=&#34;true&#34; /&gt; &lt;SwitchPreferenceCompat android:key=&#34;switch2&#34; android:title=&#34;スイッチ2&#34; android:summary=&#34;2つ目のスイッチだよ&#34; android:defaultValue=&#34;false&#34; /&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&#34;チェックボックスによる設定&#34;&gt; &lt;CheckBoxPreference android:key=&#34;checkbox1&#34; android:title=&#34;チェックボックス1&#34; android:summary=&#34;1つ目のチェックボックスだよ&#34; android:defaultValue=&#34;true&#34; /&gt; &lt;CheckBoxPreference android:key=&#34;checkbox2&#34; android:title=&#34;チェックボックス2&#34; android:summary=&#34;2つ目のチェックボックスだよ&#34; android:defaultValue=&#34;false&#34; /&gt; &lt;/PreferenceCategory&gt; &lt;/androidx.preference.PreferenceScreen&gt; PreferenceScreen 要素以下には、様々な種類の Preference 要素を配置することができます。 下記は代表的な Preference 要素の例で、すべて Preference クラスのサブクラスとして定義されています。 Preference 要素 表示内容 SwitchPreferenceCompat ON/OFF の設定（スイッチ） CheckBoxPreference ON/OFF の設定（チェックボックス） ListPreference リストで選択項目を表示 DropDownPreference ドロップダウンで選択項目を表示（ListPreference の拡張） EditTextPreference テキスト入力のダイアログを表示 PreferenceCategory 設定項目をグルーピングして title を表示 設定項目の key 属性 各 Preference 要素には key 属性を設定することができ、自動的に アプリケーションのデフォルトの SharedPreferences ファイル にそのキー名で設定値が保存されるようになります。 設定ファイルのパスは下記のようになります。 設定ファイルのパス /data/data/&lt;package名&gt;/shared_prefs/&lt;pacakge名&gt;_preferences.xml 上記のサンプルコードを用いた場合、出力は下記のようになります。 com.example.myapp_preferences.xml &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt; &lt;map&gt; &lt;boolean name=&#34;switch1&#34; value=&#34;true&#34; /&gt; &lt;boolean name=&#34;switch2&#34; value=&#34;false&#34; /&gt; &lt;boolean name=&#34;checkbox1&#34; value=&#34;true&#34; /&gt; &lt;boolean name=&#34;checkbox2&#34; value=&#34;false&#34; /&gt; &lt;/map&gt; 各 Preference 要素の key 属性の値は、このように、デフォルトの SharedPreferences 設定ファイルの name 属性にマッピングされるため、その中で一意になるように管理しておく必要があります。 名前にはドットなどの記号を含めることができるので、必要に応じて display.color.main のように階層化した名前で管理するとよいでしょう。 ファイルに保存された設定値は、次に設定画面を開くときに自動的に読み込まれます。 アプリケーション内で設定情報を参照したい場合は、下記のような感じでデフォルトの SharedPreferences インスタンスを取得します（詳しくは こちらの記事 を参照）。 設定値の参照方法 // SharedPreference インスタンスを取得 val prefs = PreferenceManager.getDefaultSharedPreferences(context) // あとは各設定値を参照するだけ val userName = prefs.getString(&#34;userName&#34;, &#34;名無しさん&#34;) val userAge = prefs.getInt(&#34;userAge&#34;, -1) 設定画面の階層化 XML ファイルのルート要素として配置する &lt;PreferenceScreen&gt; は、一画面分の設定項目をまとめる単位です。 以前はこの要素を入れ子構造にすることで、2 階層以上の設定画面を構成する方法がサポートされていましたが、今はこのやり方はサポートされていません。 代わりに、&lt;Preference&gt; 要素にフラグメント名を対応付け、その要素がタップされたときに新しくそのフラグメントを起動するように実装する必要があります。詳しくは下記のドキュメントを参照してください。 Organize your settings ｜ Android Developers 設定画面を表示する PreferenceFragmentCompat クラスは、設定項目を表示するためのベース Fragment クラスとして使用できます。 このクラスを継承する形で独自の Fragment クラスを実装し、上記で作成した XML ファイルを setPreferencesFromResource() メソッドで読み込みます。 つまり、このメソッドで 読み込む XML ファイルを切り替えるだけで、複数の設定画面を切り替えて表示することができます。 MyPreferenceFragment.kt package com.example.myapp import android.os.Bundle import androidx.preference.PreferenceFragmentCompat import com.example.myapp.R class MyPreferenceFragment : PreferenceFragmentCompat() { override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) { // res/xml/preferences.xml ファイルに従って設定画面を構成 setPreferencesFromResource(R.xml.preferences, rootKey) } } この Fragment を表示するための Activity も作った方がよさそうですが、ここでは MainActivity の上に表示してしまうことにしましょう。 layout/activity_main.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:tools=&#34;http://schemas.android.com/tools&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; tools:context=&#34;.MainActivity&#34;&gt; &lt;FrameLayout android:id=&#34;@+id/settings_container&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; MainActivity.kt package com.example.myapp import androidx.appcompat.app.AppCompatActivity import android.os.Bundle class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 設定用の Fragment を表示 supportFragmentManager .beginTransaction() .replace(R.id.settings_container, MyPreferenceFragment()) .commit() } } SharedPreferences のデフォルト値 Preference XML ファイルの defaultValue 属性で設定したデフォルト値は、設定画面を開いたときに初めて使用されます。 でもこれでは、先に SharedPreferences オブジェクトの getter 系メソッドを呼び出したときにデフォルト値として取得できません。 setDefaultValues を使う方法 PreferenceManager.setDefaultValues 関数を呼び出すと、Preference XML の defaultValue 属性の値を読み込んで、SharedPreferences オブジェクトの初期値として先回りして設定しておくことができます。 このメソッドは、アプリの MainActivity となるクラスで呼び出すべきとされているので、下記のように Application クラスや MainActivity の onCreate で呼んでおけばよいでしょう（I/O アクセスが若干気になりますが）。 デフォルト値の設定例 class App : Application() { lateinit var prefs: SharedPreferences override fun onCreate() { super.onCreate() // Start loading preferences as early as possible to avoid ANR when // referring the configuration for the first time. PreferenceManager.setDefaultValues(this, R.xml.preferences, false) prefs = PreferenceManager.getDefaultSharedPreferences(this) } } このやり方のイケてないところは、setDefaultValues 自体の処理が重く、それにもかかわらずメインスレッドから実行することを前提とした実装になっているところです。 コルーチンの中から呼び出していると、android.view.InflateException 例外で落ちたりします（少なくとも Android 10 時点では NG）。 なので、デフォルト値を扱うときは下記の方法をオススメします。 リソースにデフォルト値をまとめる方法（オススメ） SharedPreferences のデフォルト値を扱うときのオススメの方法は、リソースファイルでデフォルト値を定義し、その値を Preference XML ファイルと、SharedPreferences#getString() の両方のデフォルト値として参照する方法です。 例えば、下記のような感じで、リソースファイルに設定画面用の表示ラベルと一緒にデフォルト値を定義しておきます。 res/values/settings.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;resources&gt; &lt;string name=&#34;settings_fps_key&#34;&gt;settings.fps&lt;/string&gt; &lt;string name=&#34;settings_fps_title&#34;&gt;FPS&lt;/string&gt; &lt;string name=&#34;settings_fps_summary_on&#34;&gt;Show&lt;/string&gt; &lt;string name=&#34;settings_fps_summary_off&#34;&gt;Hide&lt;/string&gt; &lt;bool name=&#34;settings_fps_default&#34;&gt;false&lt;/bool&gt; &lt;/resource&gt; 設定画面を構成するための Preference XML ファイルからは、下記のように参照します。 res/xml/preferences.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;androidx.preference.PreferenceScreen xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34; app:title=&#34;MyApp Settings&#34;&gt; &lt;SwitchPreference app:key=&#34;@string/settings_fps_key&#34; app:title=&#34;@string/settings_fps_title&#34; app:summaryOn=&#34;@string/settings_fps_summary_on&#34; app:summaryOff=&#34;@string/settings_fps_summary_off&#34; app:defaultValue=&#34;@bool/settings_fps_default&#34; /&gt; &lt;/androidx.preference.PreferenceScreen&gt; プログラムの中からは、下記のようにデフォルト値を参照します。 リソースからデフォルト値を参照 val prefs = PreferenceManager.getDefaultSharedPreferences(context) val isFpsOn = prefs.getBoolean( context.resources.getString(R.string.settings_fps_key), context.resources.getBoolean(R.bool.settings_fps_default)) これで、重い SharedPreferences.setDefaultValues() を使わずに、初回起動時のデフォルト設定値をうまく扱うことができます。 ちなみに、res/values ディレクトリ以下に配置するリソースファイルの名前は何でもよいって知ってました？ ここでは strings.xml ではなく、settings.xml という名前で作成してみました。 このルールを知っていれば、特定の機能で使うリソースを複数ファイルにバラバラに定義しなくて済みます。 いろいろな Preference 要素 リストから選択 (ListPreference) Preference 要素として ListPreference を使用すると、いくつかの項目の中からユーザに選択させることができます。 res/xml/preferences.xml &lt;androidx.preference.PreferenceScreen xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&gt; &lt;ListPreference android:key=&#34;fruit&#34; android:title=&#34;Favorite fruit&#34; android:entries=&#34;@array/fruit_labels&#34; android:entryValues=&#34;@array/fruit_values&#34; android:dialogTitle=&#34;Favorite fruit&#34; android:defaultValue=&#34;apple&#34; /&gt; &lt;/androidx.preference.PreferenceScreen&gt; 選択項目ごとのラベルや値は下記のように配列リソースとして定義しておきます。 res/values/arrays.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;resources&gt; &lt;string-array name=&#34;fruit_labels&#34;&gt; &lt;item&gt;りんご&lt;/item&gt; &lt;item&gt;バナナ&lt;/item&gt; &lt;item&gt;オレンジ&lt;/item&gt; &lt;/string-array&gt; &lt;string-array name=&#34;fruit_values&#34;&gt; &lt;item&gt;apple&lt;/item&gt; &lt;item&gt;banana&lt;/item&gt; &lt;item&gt;orange&lt;/item&gt; &lt;/string-array&gt; &lt;/resources&gt; ちなみに、数値の配列だとしても、タグは string-array を使用する必要があるみたいです（integer-array などにすると ListPreference が NullPointerException で落ちます）。 他の Activity を起動する Preference 要素内に intent 要素を入れておくと、その設定項目を選択したときにインテントを発行して任意の Activity を起動することができます。 下記は、Android のディスプレイ設定画面を起動する例です。 res/xml/preferences.xml &lt;androidx.preference.PreferenceScreen xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&gt; &lt;Preference android:title=&#34;ディスプレイ設定を起動&#34;&gt; &lt;intent android:action=&#34;android.settings.DISPLAY_SETTINGS&#34; /&gt; &lt;/Preference&gt; &lt;/androidx.preference.PreferenceScreen&gt; ON 状態と OFF 状態で summary テキストの表示を切り替える SwitchPreferenceCompat 要素の summary 属性の代わりに、summaryOn 属性と summaryOff 属性を使用すると、設定の ON/OFF に応じて表示テキストを切り替えることができます。 summaryOn/summaryOff 属性の使用例 &lt;androidx.preference.PreferenceScreen xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34;&gt; &lt;SwitchPreferenceCompat android:key=&#34;check_updates&#34; android:title=&#34;Check updates&#34; android:summaryOn=&#34;起動時に最新データに更新します&#34; android:summaryOff=&#34;データの更新を行いません&#34; /&gt; &lt;/androidx.preference.PreferenceScreen&gt; EditTextPreference や ListPreference の summary 領域に入力したテキストを自動で表示する EditTextPreference や ListPreference の useSimpleSummaryProvider 属性を true に設定しておくと、ユーザーの入力したテキスト（あるいは選択した値）が自動的に summary 領域に表示されるようになります。 res/xml/preferences.xml &lt;androidx.preference.PreferenceScreen xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:app=&#34;http://schemas.android.com/apk/res-auto&#34;&gt; &lt;EditTextPreference android:key=&#34;username&#34; android:title=&#34;User name&#34; android:dialogTitle=&#34;User name&#34; android:defaultValue=&#34;名無しさん&#34; app:useSimpleSummaryProvider=&#34;true&#34; /&gt; &lt;/androidx.preference.PreferenceScreen&gt; ネームスペースは、xmlns:android=&quot;http://schemas.android.com/apk/res/android ではなく、xmlns:app=&quot;http://schemas.android.com/apk/res-auto の方を使わないと、「そんな属性はない」と怒られてしまうので注意してください。 この機能は、anrdoidx.preferences の version 1.1.0-alpha01 以降からサポートされているため、build.gradle でそれ以上のバージョンを指定しておく必要があります。 app/build.gradle dependencies { implementation &#39;androidx.preference:preference:1.1.0-rc01&#39; } 参考: Dynamically update summaries ｜ Android Developers 読んでおくべきドキュメント Android Settings Design Guidelines コーディング方法というより、一般的な設定 UI はこうあるべき、という下記のようなガイドラインが示されています。 こういった知識は Android 以外のアプリ開発にも活用できるので読んでおいて損はないです。 よく使う項目から並べる 1ページに表示する項目は多くても10～15項目 多くの設定項目をリスト表示するときはグルーピング機能、区切り線を使う 設定画面はコンテキストに応じて複数用意することを考慮する（設定項目は複数の設定画面から共有して表示してよい） タイトル名の付け方（&ldquo;General Settings&rdquo; などは避ける） 設定項目に親子関係がある場合、マスター設定項目を用意して、子項目をまとめて Enable/Disable できるようにする ラジオボタンは個別の設定画面で表示する（他の設定項目と一緒にリストに並べない） ユーザ入力を受け付けるボタンやリンクなどは、アプリのテーマに沿った色で表示する ボタンを表示するときは、Positive なアクションはテーマカラーで、Negative なアクション（アンインストールとか）はグレーで表示する Advanced な設定はデフォルトでは閉じた状態で表示する チェックボックスよりもスイッチを使う。でも項目が多い場合や、Negative な項目（通知ブロック）などはチェックボックスの方がわかりやすいことがある。"},{url:"/p/omkgowq/",title:"Kotlinメモ: クラス名を文字列で取得する (class.java.simpleName)",date:"2019-08-08T00:00:00+09:00",body:"Kotlinメモ: クラス名を文字列で取得する (class.java.simpleName) Kotlin クラス名を文字列として取得したい場合、例えば、MyClass クラスの名前を MyClass という文字列として取得したい場合は次のように記述します。 val name = MyClass::class.java.simpleName Java の場合は (MyClass.simpleName) と記述できたので、それと比べると Kotlin は若干冗長な記述 (MyClass::class.java.simpleName) になります。 ただ、クラス名をそのまま文字列リテラルでハードコードすると、クラス名のリファクタリング時に修正し忘れたりするので、このようにクラス名を取得した方がよいケースはよくあります。 例えば、Android アプリのログ (Logcat) には、タグ情報としてクラス名を入れたりしますが（個人的にはアプリ名を入れるべきだと思いますが）、このタグは下記のように初期化することができます。 class Sample { companion object { private val TAG = Sample::class.java.simpleName } fun sayHello() { Log.i(TAG, &#34;Hello&#34;) } }"},{url:"/p/mmiwzqj/",title:"Kotlinメモ: 配列やリストの先頭・末尾の n 要素を取り出す・削除する (take, drop)",date:"2019-08-05T00:00:00+09:00",body:"Kotlinメモ: 配列やリストの先頭・末尾の n 要素を取り出す・削除する (take, drop) 先頭・末尾からいくつかの要素を取り出す (take) take 系のメソッドを使用すると、配列やリストの先頭・末尾から指定した数の要素を取り出すことができます。 どのメソッドも新しいリストを返すため、元のリストは変化しません。 take(n): 先頭から n 個の要素を取り出す takeLast(n): 末尾から n 個の要素を取り出す val list = listOf(1, 2, 3, 4, 5) // intArrayOf でも OK println(list.take(3)) //=&gt; [1, 2, 3] println(list.takeLast(3)) //=&gt; [3, 4, 5] takeWhile 系のメソッドは、条件式を指定することができ、各要素の値が条件を満たす限り取り出します。 takeWhile(predicate: (T) -&gt; Boolean): 先頭から条件に一致する限り要素を取り出す takeLastWhile(predicate: (T) -&gt; Boolean): 末尾から条件に一致する限り要素を取り出す val chars = (&#39;a&#39;..&#39;z&#39;).toList() println(chars.takeWhile { it &lt; &#39;f&#39; }) //=&gt; [a, b, c, d, e] println(chars.takeLastWhile { it &gt; &#39;w&#39; }) //=&gt; [x, y, z] 先頭・末尾のいくつかの要素を削除する (drop) drop 系のメソッドを使用すると、配列やリストの先頭・末尾から指定した数の要素を削除します。 どのメソッドも新しいリストを返すため、元のリストは変化しません。 drop(n): 先頭から n 個の要素を削除する dropLast(n): 末尾から n 個の要素を削除する val list = listOf(1, 2, 3, 4, 5) // intArrayOf でも OK println(list.drop(3)) //=&gt; [4, 5] println(list.dropLast(3)) //=&gt; [1, 2] dropWhile 系のメソッドは、条件式を指定することができ、各要素の値が条件を満たす限り削除します。 dropWhile(predicate: (T) -&gt; Boolean): 先頭から条件に一致する限り要素を削除する dropLastWhile(predicate: (T) -&gt; Boolean): 末尾から条件に一致する限り要素を削除する val chars = (&#39;a&#39;..&#39;z&#39;).toList() println(chars.dropWhile { it &lt; &#39;x&#39; }) //=&gt; [x, y, z] println(chars.dropLastWhile { it &gt; &#39;c&#39; }) //=&gt; [a, b, c]"},{url:"/p/j4eyu47/",title:"Androidメモ: Kotlin で OpenGL ES を使って 3D 表示するアプリを作る",date:"2019-08-02T00:00:00+09:00",body:"Androidメモ: Kotlin で OpenGL ES を使って 3D 表示するアプリを作る Android では、組み込み向けの OpenGL インタフェースである OpenGL ES を使用して 3D の描画を行うことができます。 Kotlin でも Java でも利用方法は変わらないのですが、今はもう Kotlin が主流になってきてますので、ここでは Kotlin で書いてみます。 Android で OpenGL ES を使った描画を行うには、下記のような手順を踏みます。 描画用のビューとして GLSurfaceView を作成する 描画処理を実装した GLSurfaceView.Renderer インスタンスを GLSurfaceView にセットする 描画用のビュー (GLSurfaceView) の作成 下記は、MainActivity の実装です。 ここでは、OpenGL ES によって描画するためのビューとして、GLSurfaceView を生成し、そこに GLSurfaceView.Renderer インスタンスを設定します。 MainActivity.kt package com.example.openglsample import android.opengl.GLSurfaceView import androidx.appcompat.app.AppCompatActivity import android.os.Bundle class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val view = GLSurfaceView(this).apply { setRenderer(MyRenderer()) } setContentView(view) } } これが OpenGL ES を使用する場合の、最低限のビュー構成になります。 レンダラー (GLSurfaceView.Renderer) の実装 次に、実際に OpenGL ES の API を使って描画処理を行うレンダラークラスを実装します。 レンダラークラスを作成するには、Android の GLSurfaceView.Renderer インタフェース が提供する下記のメソッドを実装します。 onSurfaceCreated: 描画用サーフェスが作成されたときに呼び出される。クリア色の初期化などを行う。 onSurfaceChanged: 描画用サーフェスのサイズが変更されたときに呼び出される。ビューポートの初期化などを行う。 onDrawFrame: 描画が必要なときに呼び出される。ここに実際の描画処理を記述する。 ここでは、各頂点が異なる色を持つ三角形を表示してみます。 MyRenderer.kt package com.example.openglsample import android.opengl.GLSurfaceView import android.opengl.GLU import javax.microedition.khronos.egl.EGLConfig import javax.microedition.khronos.opengles.GL10 class MyRenderer : GLSurfaceView.Renderer { /** Called when the surface is created or recreated. */ override fun onSurfaceCreated(gl: GL10, config: EGLConfig) { // 背景色を設定（暗い青） gl.glClearColor(0.0f, 0.0f, 0.5f, 1.0f) // RGBA } /** Called when the surface changed size. */ override fun onSurfaceChanged(gl: GL10, width: Int, height: Int) { // ビューポート（描画領域）の設定 gl.glViewport(0, 0, width, height) // 視体積の設定 (left, right, bottom, top, near, far) val ratio = width.toFloat() / height gl.glMatrixMode(GL10.GL_PROJECTION) gl.glLoadIdentity() gl.glFrustumf(-ratio, ratio, -1f, 1f, 2f, 6f) // 視点と視線方向の設定 GLU.gluLookAt(gl, 0f, 0f, 4f, // カメラの位置（視点） 0f, 0f, 0f, // カメラの向き（注視点） 0f, 1f, 0f // カメラ姿勢（上方向を表すベクトル） ) } /** Called to draw the current frame. */ override fun onDrawFrame(gl: GL10) { // 画面のクリア gl.glClear(GL10.GL_COLOR_BUFFER_BIT) // 3つの頂点の座標をセット val vertices = floatArrayOf( -1f, -0.5f, 0f, // (x, y, z) 1f, -0.5f, 0f, // (x, y, z) 0f, 1f, 0f // (x, y, z) ) gl.glVertexPointer(3, GL10.GL_FLOAT, 0, Util.makeFloatBuffer(vertices)) gl.glEnableClientState(GL10.GL_VERTEX_ARRAY) // 3つの頂点の色をセット（RGBA の繰り返し） val colors = floatArrayOf( 1.0f, 1.0f, 0.0f, 1.0f, // #FFFF00 - 黄色 0.0f, 1.0f, 1.0f, 1.0f, // #00FFFF - シアン 1.0f, 0.0f, 1.0f, 1.0f // #FF00FF - マゼンタ ) gl.glColorPointer(4, GL10.GL_FLOAT, 0, Util.makeFloatBuffer(colors)) gl.glEnableClientState(GL10.GL_COLOR_ARRAY) // 描画（三角形の組み合わせで描画） gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, vertices.size / 3) } } onSurfaceCreated サーフェスが生成されたときに呼び出される onSurfaceCreated ですが、ここでは、クリア色（つまり背景色）の設定だけを行っています。 override fun onSurfaceCreated(gl: GL10, config: EGLConfig) { // 背景色を設定（暗い青） gl.glClearColor(0.0f, 0.0f, 0.5f, 1.0f) // RGBA } onSurfaceChanged サーフェスサイズが変更された場合（および初期表示時）には、Renderer.onSurfaceChanged が呼び出されるので、ここでビューポートや視点などの設定を行います。 ビューポートは、GLSurfaceView のどの領域に描画を行うかの設定です。 ここでは、単純にビュー全体に描画するように指定しています。 override fun onSurfaceChanged(gl: GL10, width: Int, height: Int) { // ビューポート（描画領域）の設定 gl.glViewport(0, 0, width, height) ... 次に、glFrustumf 関数 を使って視体積の設定、GLU.gluLookAt 関数 を使って視点（カメラ）の設定を行います。 // 視体積の設定 (left, right, bottom, top, near, far) val ratio = width.toFloat() / height gl.glMatrixMode(GL10.GL_PROJECTION) gl.glLoadIdentity() gl.glFrustumf(-ratio, ratio, -1f, 1f, 2f, 6f) // 視点と視線方向の設定 GLU.gluLookAt(gl, 0f, 0f, 4f, // カメラの位置（視点） 0f, 0f, 0f, // カメラの向き（注視点） 0f, 1f, 0f // カメラ姿勢（上方向を表すベクトル） ) glFrustumf 関数のパラメータは次のようになっており、最初の 4 つのパラメータ (left, right, bottom, top) で、ニアクリップ面（最前面）の領域を示す座標値を指定します。 これが、視点から見たときに見える範囲の最前面になります。 glFrustumf(left, right, bottom, top, near, far) 図からもわかるように、視点とニアクリップ面までの距離が近いほど、表現上の視野角は広くなります。 glFrustumf の末尾の 2 つのパラメータ (near, far) が視点からニアプリップ面、ファークリップ面までの距離を表します。 GLU.gluLookAt 関数では、視点（カメラ）の位置、および向きを設定します。 ここでは、原点 (0, 0) あたりに描画オブジェクトを配置することを想定し、カメラ位置は (0, 0, 4) とし、原点の方向 (0, 0, 0) を向くように設定しています。 ここでは、遠くのものが小さく見える透視投影 (Perspective Projection) 用の設定を行いましたが、glOrthof 関数を使えば、正投影 (Orthographic Projection) 用の設定を行うことができます。 2D のゲームなどを作るのであれば、正投影を使ったほうが簡単です。 描画処理の実装 (onDrawFrame) 描画処理が必要なときには、Renderer#onDrawFrame が呼び出されるので、この中で 3D オブジェクトの描画処理を行います。 まずは、glClear を使って画面をクリアします。 クリア色として、glClearColor で設定済みの色が使用されます。 override fun onDrawFrame(gl: GL10) { // 画面のクリア gl.glClear(GL10.GL_COLOR_BUFFER_BIT) ... 次に、原点近く (z=0) に三角形を表示するために 3 つの頂点の座標を設定します。 // 3つの頂点の座標をセット val vertices = floatArrayOf( -1f, -0.5f, 0f, // (x, y, z) 1f, -0.5f, 0f, // (x, y, z) 0f, 1f, 0f // (x, y, z) ) gl.glVertexPointer(3, GL10.GL_FLOAT, 0, Util.makeFloatBuffer(vertices)) gl.glEnableClientState(GL10.GL_VERTEX_ARRAY) glVertexPointer の最初のパラメータで 3 と指定しているのは、各座標値が三次元 (x, y, z) のデータであることを示しています。 Util.makeFloatBuffer に関しては後述。 さらに、3 つの頂点の色を、それぞれ RGBA で設定します。 // 3つの頂点の色をセット（RGBA の繰り返し） val colors = floatArrayOf( 1.0f, 1.0f, 0.0f, 1.0f, // #FFFF00 - 黄色 0.0f, 1.0f, 1.0f, 1.0f, // #00FFFF - シアン 1.0f, 0.0f, 1.0f, 1.0f // #FF00FF - マゼンタ ) gl.glColorPointer(4, GL10.GL_FLOAT, 0, Util.makeFloatBuffer(colors)) gl.glEnableClientState(GL10.GL_COLOR_ARRAY) ここでは 3 点の色を異なる色に設定していますが、すべて同じ色でよければ、下記のように簡単に設定することができます。 // 単色でよければ下記のような2行で OK gl.glColor4f(1.0f, 1.0f, 0f, 0f) // 黄色 gl.disableClientState(GL10.GL_COLOR_ARRAY) 最後に、設定した座標値などに従ってレンダリングを行って終了です。 // 描画（三角形の組み合わせで描画） gl.glDrawArrays(GL10.GL_TRIANGLE_STRIP, 0, vertices.size / 3) FloatBuffer 作成用のユーティリティ 上記の実装において、glVertextPointer で頂点座標を指定するときや、glColorPointer で頂点の色を指定するときに、Util.makeFloatBuffer という関数を使っていました。 これは、OpenGL が扱える形式のバッファー (FloatBuffer) を生成するためのユーティリティ関数です。 Util.kt package com.example.openglsample import java.nio.ByteBuffer import java.nio.ByteOrder import java.nio.FloatBuffer object Util { /** OpenGL 用のバッファを作成します。 */ fun makeFloatBuffer(arr: FloatArray): FloatBuffer { val bb = ByteBuffer.allocateDirect(arr.size * 4) // float は 4 byte bb.order(ByteOrder.nativeOrder()) return bb.asFloatBuffer().apply { put(arr) position(0) } } } OpenGL でポリゴンを描画するには、座標値や色情報を OpenGL に転送してやる必要があるのですが、このとき渡すデータは Java VM 上に確保された float 配列ではダメで、OpenGL 用に作成したバッファー（ここでは FloatBuffer）でなければいけません。 上記の makeFloatBuffer 関数は、Java の float 配列を受け取り、OpenGL 用の FloatBuffer を生成して返します。 全ソースコード 上記のソースコードは下記からダウンロードできます。 https://github.com/maku77/AndroidOpenGlSample"},{url:"/p/wf7yjbm/",title:"Kotlinメモ: 算術演算子を定義してオブジェクトに + や += を適用できるようにする",date:"2019-07-16T00:00:00+09:00",body:"Kotlinメモ: 算術演算子を定義してオブジェクトに + や += を適用できるようにする Kotlin では、+ や += などの演算子をオーバーロードして、独自の振る舞いを定義することができます（Java では演算子のオーバーロードはできません）。 ここでは、様々な演算子のオーバーロードの例を示すために、下記のような複素数を保持する簡単なデータクラスを使用することにします。 data class Complex(val re: Int, val im: Int) 二項演算子のオーバーロード (Binary arithmetic operators) Kotlin で a + b のような演算を可能にする二項演算子を定義するには、plus や minus などの 演算子関数 を実装します。 使用する演算子 定義する演算子関数 + plus - minus * times / div % mod 下記は、+ 演算子をオーバーロードする例です。 演算子関数を定義するときは、モディファイアとして operator を付けることに注意してください（同名の通常関数の定義と区別するためです）。 data class Complex(val re: Int, val im: Int) { operator fun plus(other: Complex): Complex { return Complex(re + other.re, im + other.im) } } これにより、独自オブジェクト同士の + 演算子による演算が可能になります。 val c1 = Complex(1, 2) val c2 = Complex(3, 4) println(c1 + c2) //=&gt; Complex(re=4, im=6) 上記では、メンバ関数として演算子関数を定義しましたが、拡張関数として定義することもできます。 この方法であれば、既存の外部ライブラリが提供するクラスの演算子をオーバーロードすることが可能です。 operator fun Complex.plus(other: Complex): Complex { return Complex(re + other.re, im + other.im) } ここまでは、Complex インスタンス同士の演算を定義していましたが、別の型との演算を定義することもできます。 次の例では、各プロパティを、指定した Int 値倍に変化させる * 演算子 (times) を定義しています。 data class Complex(val re: Int, val im: Int) { operator fun times(scale: Int): Complex { return Complex(re * scale, im * scale) } } fun main() { val c1 = Complex(1, 2) val c2 = c1 * 10 println(c2) // =&gt; Complex(re=10, im=20) } このように違う型同士の演算を定義した場合、演算子の左右の値は交換可能ではない ことに注意してください。 例えば、10 * Complex(1, 2) という演算を行いたいのであれば、Int.times(c: Complex) という演算子関数を定義しておく必要があります。 二項演算子の戻り値を、元のオブジェクトの型とは別のものにすることもできます。 operator fun Char.times(n: Int) = toString().repeat(n) fun main() { println(&#39;A&#39; * 3) //=&gt; &#34;AAA&#34; } 複合代入演算子のオーバーロード (Compound assignment operators) Kotlin では、二項演算子の + (plus) を定義すると、自動的に複合代入演算子である += も使用できるようになります。 ただし、この場合は変数の値を変更できるようにするために、val ではなく var で変数定義しておく必要があります。 var c = Complex(1, 2) c += Complex(3, 4) println(c) // =&gt; Complex(re=4, im=6) 一方、コレクション系クラスやビルダ系クラスでは、要素の追加を行うための += 演算子のみを定義したいことがあります。 このようなケースでは、plusAssign や minusAssign という名前の演算子関数を定義します。 使用する演算子 定義する演算子関数 += plusAssign -= minusAssign *= timesAssign /= divAssign %= remAssign 下記は、MutableCollection による拡張関数定義の抜粋です。 public inline operator fun &lt;T&gt; MutableCollection&lt;in T&gt;.plusAssign(element: T) { this.add(element) } public inline operator fun &lt;T&gt; MutableCollection&lt;in T&gt;.minusAssign(element: T) { this.remove(element) } つまり、a += b という記述は、a = a.plus(b) あるいは a = a.plusAssign(b) という呼び出しのどちらかにマッピングされることになります。 plus と plusAssign の両方が定義されていると、a += b という呼び出しはコンパイルエラーになります。 もちろん、a = a.plus(b) のように関数名を明示して呼び出せばエラーにはなりませんが、通常は plus と plusAssign を同時に定義しないようにすべきでしょう。 単項演算子のオーバーロード (Unary operators) 下記のような単項演算子をオーバーロードすることもできます。 使用する演算子 定義する演算子関数 +x unaryPlus -x unaryMinus !x not ++x, x++ inc --x, x-- dec 次の例では、各プロパティの符号を反転する - 演算子を定義しています。 data class Complex(val re: Int, val im: Int) { operator fun unaryMinus() = Complex(-re, -im) } fun main() { val c1 = Complex(1, 2) val c2 = -c1 println(c2) // =&gt; Complex(re=-1, im=-2) } 前置インクリメント (++x)、後置インクリメント (x++) を使用するには、inc 演算子関数を 1 つ定義するだけで OK です。 デクリメントに関しても同様です。 data class Complex(val re: Int, val im: Int) { operator fun inc() = Complex(re + 1, im + 1) } fun main() { var c = Complex(1, 2) println(c++) // =&gt; Complex(re=1, im=2) println(++c) // =&gt; Complex(re=3, im=4) }"},{url:"/p/7kkqw4q/",title:"Androidメモ: 常に画面の最前面に表示されたままになる View を作る (TYPE_APPLICATION_OVERLAY)",date:"2019-07-09T00:00:00+09:00",body:"Androidメモ: 常に画面の最前面に表示されたままになる View を作る (TYPE_APPLICATION_OVERLAY) ここでは、任意のビュー（上の図では猫）をどのアプリよりも最前面に表示し、ずっとそこに表示し続けるようにする方法を説明します。 表示の ON/OFF は、メインアクティビティに配置したトグルボタンから行えるようにしています。 この猫が、下に表示されているアプリの操作を邪魔することはありません（猫の部分をタップすると、下に表示されているアプリの画面をタッチしたことになります）。 アプリのビューを最前面にオーバーレイ表示する方法 Android で画面の最前面に張り付くウィジェットのようなものを作る場合、かつて (API Level 25 以前、Android 7 Nougat まで）はビューを TYPE_SYSTEM_OVERLAY や TYPE_SYSTEM_SYSTEM_ALERT_WINDOW などのレイヤーに表示することで実現していました。 API Level 26 以降（Android 8 Oreo 以降）はこのような特殊なレイヤーの使用は制限されており、代わりに TYPE_APPLICATION_OVERLAY レイヤーを使う必要があります。 TYPE_APPLICATION_OVERLAY TYPE_SYSTEM_OVERLAY (deprecated) TYPE_SYSTEM_ALERT (deprecated) TYPE_APPLICATION_OVERLAY を使うことにより、すべての Activity よりも上位に表示しつつも、ステータスバーや IME などの重要な UI よりは下に表示されるようになります。 TYPE_APPLICATION_OVERLAY のレイヤーに表示を行うには、AndroidManifest.xml に SYSTEM_ALERT_WINDOW パーミッション の使用を宣言し、さらにアプリケーション実行中にユーザーからの許可（ランタイムパーミッション）を得る必要があります。 View を最前面にオーバーレイ表示する流れは下記のようになります。 AndroidManifest.xml に SYSTEM_ALERT_WINDOW の uses-permission を追加 アプリ起動時やボタンを押したときなどにダイアログ表示してオーバーレイ表示の許可を得る すでにパーミッションが付加されているかは Settings.canDrawOverlays() で確認できる ダイアログの表示は Settings.ACTION_MANAGE_OVERLAY_PERMISSION アクションで startActivity すればよい パーミッションが得られたら WindowManager で対象ビューのレイヤーを移動させる 実装例 AndroidManifest.xml に uses-permission を追加 View のオーバーレイ表示を行うには、SYSTEM_ALERT_WINDOW パーミッションが必要です。 まず、マニフェストの uses-permission 要素で、android.permission.SYSTEM_ALERT_WINDOW を使用することを宣言しておきます。 AndroidManifest.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;manifest xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; xmlns:dist=&#34;http://schemas.android.com/apk/distribution&#34; package=&#34;com.example.overlaysample&#34;&gt; &lt;uses-permission android:name=&#34;android.permission.SYSTEM_ALERT_WINDOW&#34;/&gt; ... &lt;/manifest&gt; これを指定しなくても Runtime Permission を要求するダイアログを表示することはできるのですが、TYPE_APPLICATION_OVERLAY の OFF/ON ボックスがグレーアウトされてしまいます。 図: SYSTEM_ALERT_WINDOW パーミッションが宣言されていないとき 図: SYSTEM_ALERT_WINDOW パーミッションが宣言されているとき オーバーレイ表示の許可を得る 実際に SYSTEM_ALERT_WINDOW パーミッションを使用するには、Runtime Permission の仕組みによって、アプリ起動後にユーザーから許可を得る必要があります（API level 23 以降）。 Settings.canDrawOverlays() を呼び出すと、すでにパーミッションが付加されているかどうかを調べることができるので、これが false を返した場合だけパーミッションを要求するダイアログを表示するようにします。 パーミッション要求のダイアログは、Settings.ACTION_MANAGE_OVERLAY_PERMISSION をアクション名とするインテントを投げることで起動することができます。 class MainActivity : AppCompatActivity() { // ... /** Requests an overlay permission to the user if needed. */ private fun requestOverlayPermission() { if (isOverlayGranted()) return val intent = Intent( Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse(&#34;package:$packageName&#34;) ) startActivityForResult(intent, OVERLAY_PERMISSION_REQUEST_CODE) } /** Checks if the overlay is permitted. */ private fun isOverlayGranted() = Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M || Settings.canDrawOverlays(this) } API level 23 (Build.VERSION_CODES.M) より前は、Runtime Permission でユーザからの許可を得る必要はないので、何もしないで return するようにしています。 このパーミッションを取得せずに、TYPE_APPLICATION_OVERLAY のレイヤにビューを表示しようとすると、WindowManager$BadTokenException という RuntimeException が発生します。 ユーザーによってオーバーレイ表示が許可されたかどうかは、startActivityForResult() の呼び出し結果をハンドルするための onActivityResult() メソッドでチェックすればよいでしょう。 /** Terminates the app if the user does not accept an overlay. */ override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == OVERLAY_PERMISSION_REQUEST_CODE) { if (!isOverlayGranted()) { finish() // Cannot continue if not granted } } } ここでは、ユーザーがオーバーレイ表示を許可してくれなかった場合は、単純にアプリケーションを終了するようにしています。 ビューをオーバーレイ表示する オーバーレイ表示のパーミッションを取得できたたら、WindowManager.LayoutParams の設定により、任意のビューを最前面に表示することができます。 /** Settings for overlay view */ private val layoutParams = WindowManager.LayoutParams( WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY, // Overlay レイヤに表示 WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE // フォーカスを奪わない or WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS, // 画面外への拡張を許可 PixelFormat.TRANSLUCENT ) fun showAsOverlay() { windowManager.addView(myView, layoutParams) } NotificationManager で通知領域にメッセージを表示する このように、最前面にビューを表示し続ける場合は、ユーザーがその表示を簡単に OFF にできるように、通知領域にメッセージを登録しておくと親切です。 メインアクティビティを閉じても猫アイコン（ビュー）は表示され続けるのですが、ユーザーはこの通知をクリックすることで、いつでもメインアクティビティに戻ることできます。 あるサービスを Foreground service として動作させ、その際に Notification を登録しておくと、そのサービスが終了するまで通知メッセージを表示しておくことができます。 AndroidManifest.xml に uses-permission 追加 &lt;uses-permission android:name=&#34;android.permission.FOREGROUND_SERVICE&#34; /&gt; Foreground service としてサービスを起動 class OverlayService : Service() { override fun onCreate() { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { // Start as a foreground service val notification = MyNotification.build(this) startForeground(1, notification) } // ... Notification を設定するためのヘルパクラス object MyNotification { private const val CHANNEL_ID = &#34;channel_id_overlay_sample&#34; private const val CHANNEL_NAME = &#34;オーバーレイ表示の切り替え&#34; private const val CHANNEL_IMPORTANCE = NotificationManager.IMPORTANCE_DEFAULT private const val FIRST_LINE = &#34;オーバーレイ表示中&#34; private const val SECOND_LINE = &#34;ここから表示・非表示を切り替えられます。&#34; private val ACTIVITY = MainActivity::class.java /** * Set the info for the views that show in the notification panel. */ fun build(context: Context): Notification { // Create a notification channel val nm = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager nm.createNotificationChannel( NotificationChannel(CHANNEL_ID, CHANNEL_NAME, CHANNEL_IMPORTANCE) ) // The PendingIntent to launch our activity if the user selects this notification val pendingIntent = PendingIntent.getActivity( context, 0, Intent(context, ACTIVITY), 0 ) return Notification.Builder(context, CHANNEL_ID) .setAutoCancel(false) // don&#39;t dismiss when touched .setContentIntent(pendingIntent) // The intent to send when the entry is clicked .setContentTitle(FIRST_LINE) // the label of the entry .setContentText(SECOND_LINE) // the contents of the entry .setSmallIcon(R.drawable.cat) // the status icon .setTicker(context.getText(R.string.app_name)) // the status text .setWhen(System.currentTimeMillis()) // the time stamp .build() } } オーバーレイ表示を OFF にしたときは、このサービスを終了させる (stopSelf()) ことで、通知メッセージを自動的に削除することができます。 全ソースコード ソースコードおよびリソース一式は下記に置いてあります。 https://github.com/maku77/AndroidOverlaySample/"},{url:"/p/rvghobv/",title:"Node.jsメモ: nodemon で Node.js サーバの再起動を自動化する",date:"2019-06-07T00:00:00+09:00",body:"Node.jsメモ: nodemon で Node.js サーバの再起動を自動化する nodemon とは？ Express や Restify で Web サーバの実装をしていると、ソースコードを修正するたびに Ctrl + C でサーバを強制終了し、node app.js で再起動するという操作が必要になります。 node コマンドの代わりに nodemon コマンドを使用すると、ソースコードの変更を監視し、自動的に node コマンドを再起動してくれます。 $ nodemon app.js node の代わりに nodemon とタイプするだけで、快適な実装生活を送ることができます。 Node.js でサーバ系のコーディングを行うときは nodemon を使うようにしましょう！ nodemon のインストール nodemon コマンドは、Node.js 付属の npm コマンドで簡単にインストールすることができます。 $ npm install -g nodemon システム全体で使用可能なコマンドとしてインストールしたいので、-g オプションを付けて実行してください。 nodemon を使ってみる ここでは、Node.js の標準モジュールである http を使って簡単な Web サーバを作り、それを nodemon で起動してみます。 下記は、Hello という返答を返すだけの簡単な Web サーバプログラムです。 app.js var server = require(&#39;http&#39;).createServer(); server.on(&#39;request&#39;, function(req, res) { res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;}); res.write(&#39;Hello\\n&#39;); res.end(); }); server.listen(51200); console.log(&#39;Server listening on port 51200&#39;); node コマンドの代わりに nodemon コマンドを使ってこのプログラムを実行します。 $ nodemon app.js [nodemon] 1.19.1 [nodemon] to restart at any time, enter `rs` [nodemon] watching: *.* [nodemon] starting `node app.js` Server listening on port 51200 出力に [nodemon] というプレフィックスが付いている行は、nodemon によって出力されているメッセージです。 自分で実装したプログラムの出力はそのまま表示されています（Server listening on port 51200 の部分）。 nodemon はデフォルトでは *.js ファイルや *.json ファイルの変更を監視しており、変更を検出すると自動的に node コマンドを再実行します。 例えば、上記の app.js の中の Hello という文字列を Hogeeeee に変更して保存すると、下記のように表示され、Web サーバが自動的に再起動します。 [nodemon] restarting due to changes... [nodemon] starting `node app.js` Server listening on port 51200 監視するファイルをオプションで絞り込んだり、package.json にその設定を書いておくこともできます。 詳しくは、nodemon --help や、下記のドキュメントサイトを参照してください。 nodemon - Monitor for any changes in your node.js application and automatically restart the server"},{url:"/p/y2biqz7/",title:"Python でドキュメンテーションコメント (docstring) を記述する",date:"2019-06-04T00:00:00+09:00",body:"Python でドキュメンテーションコメント (docstring) を記述する Docstring とは？ Python のコードに docstring フォーマットでコメントを記述しておくと、いろいろなツールから API ドキュメントとして参照できるようになります。 例えば、Python 用の統合開発環境 (IDE) におけるコード補完時に、ヒントとして関数の使用方法が表示されます。 下記は PEP 257 &ndash; Docstring Conventions に記述されている docstring の書き方の例です。 def complex(real=0.0, imag=0.0): &#34;&#34;&#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) &#34;&#34;&#34; if imag == 0.0 and real == 0.0: return complex_zero ... docstring はこのように 3 つのクォート (&quot;&quot;&quot;) で囲んで記述します。 docstring コメントは関数の内部に記述する ところがポイントです。 このあたりは、関数の外側にドキュメンテーションコメントを記述する Java や C# などとは異なっています。 Docstring の書き方 &quot;&quot;&quot; で始まり &quot;&quot;&quot; で終わる。 一行目はサマリであり、ピリオドで終わるフレーズで記述する。 一行目は &quot;&quot;&quot; と同じ行に記述してもよいし、改行してから記述してもよい。 最後の &quot;&quot;&quot; は行末に書いてもよいし、単独の行に書いてもよい。 一行だけで記述する場合は、開始クォートと終了クォートを同じ行に記述してもよい。 def complex(real=0.0, imag=0.0): &#34;&#34;&#34;Form a complex number.&#34;&#34;&#34; 一行当たり 72 文字以内 で記述する。 クラスメソッドであれば、最初から 8 文字インデントして書き始めることになるので、結局、一行あたりのサイズを 80 文字にするということですね。 r&quot;&quot;&quot; で始めると Raw docstring となり、バックスラッシュを含めることができる。 サマリは命令形で記述する。動詞で始め、三単現の s は付けない（例: Return ...）。 これは、Javadoc が三単現の s を付けるのを慣例しているのとは対照的です。下記は、PEP 257 &ndash; Docstring Conventions からの抜粋です。 The docstring is a phrase ending in a period. It prescribes the function or method&rsquo;s effect as a command (&ldquo;Do this&rdquo;, &ldquo;Return that&rdquo;), not as a description; e.g. don&rsquo;t write &ldquo;Returns the pathname &hellip;&rdquo;. 詳細なコメントを記述する場合は、一行目にサマリ、二行目は空行、三行目以降に詳細コメントを記述する。この場合も一行目のサマリは、&quot;&quot;&quot; と同じ行に記述してよい。 def complex(real=0.0, imag=0.0): &#34;&#34;&#34;Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) &#34;&#34;&#34; パッケージのドキュメントは __init__.py に書く。自分が export するモジュールやサブパッケージをリスト化し、それぞれ一行のサマリを記述する。 Docstring の記述例 os モジュールの例 def normcase(s): &#34;&#34;&#34;Normalize case of pathname. Makes all characters lowercase and all slashes into backslashes.&#34;&#34;&#34; urllib.request モジュールの例 def _open_generic_http(self, connection_factory, url, data): &#34;&#34;&#34;Make an HTTP connection using connection_class. This is an internal method that should be called from open_http() or open_https(). Arguments: - connection_factory should take a host name and return an HTTPConnection instance. - url is the url to retrieval or a host, relative-path pair. - data is payload for a POST request or None. &#34;&#34;&#34; json モジュールの例 def load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw): &#34;&#34;&#34;Deserialize ``fp`` (a ``.read()``-supporting file-like object containing a JSON document) to a Python object. ``object_hook`` is an optional function that will be called with the result of any object literal decode (a ``dict``). The return value of ``object_hook`` will be used instead of the ``dict``. This feature can be used to implement custom decoders (e.g. JSON-RPC class hinting). ``object_pairs_hook`` is an optional function that will be called with the result of any object literal decoded with an ordered list of pairs. The return value of ``object_pairs_hook`` will be used instead of the ``dict``. This feature can be used to implement custom decoders. If ``object_hook`` is also defined, the ``object_pairs_hook`` takes priority. To use a custom ``JSONDecoder`` subclass, specify it with the ``cls`` kwarg; otherwise ``JSONDecoder`` is used. &#34;&#34;&#34; （コラム）Docstring はなぜ 72 文字までなのか？ PEP 8 &ndash; Style Guide for Python Code では、docstring コメントは一行あたり 72 文字まで にすることを推奨しています。 For flowing long blocks of text with fewer structural restrictions (docstrings or comments), the line length should be limited to 72 characters. &hellip; The Python standard library is conservative and requires limiting lines to 79 characters (and docstrings/comments to 72). 72 文字という数字は、パンチカードの印刷幅から来ているという説や、ツールでの出力を考慮しているという説などがあります。 現実的にはツールの出力を考慮しているのだと考えるのが自然でしょう。 例えば、Python 付属の pydoc コマンドで、main.py 内のドキュメンテーションコメントを表示すると下記のように表示されます。 $ pydoc main Help on module main: NAME main FUNCTIONS complex(real=0.0, imag=0.0) Form a complex number. Keyword arguments: real -- the real part (default 0.0) imag -- the imaginary part (default 0.0) FILE /User/maku/main.py 関数のドキュメンテーション部分には 8 文字分のインデントが入っています。 よって、ドキュメンテーションコメント自体は 72 文字に収めておかないと、合計で 80 文字を超えることになってしまいます。"},{url:"/p/y2z9krm/",title:"Kotlinメモ: コレクションから条件に一致する要素のみを取り出す (filter, filterNot, filterKeys, filterValues)",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: コレクションから条件に一致する要素のみを取り出す (filter, filterNot, filterKeys, filterValues) リストや配列のフィルタ (filter, filterNot) コレクションの要素から、指定した条件を満たす要素のみを抽出するには、filter 関数を使用します。 次の例では、数値リストから偶数のみを抽出しています。 val nums = listOf(1, 2, 3, 4, 5) val evens = nums.filter { it % 2 == 0 } println(evens) //=&gt; [2, 4] 次の例では、文字列リストから &ldquo;M&rdquo; で始まる文字列のみを抽出しています。 val names = listOf(&#34;Maku&#34;, &#34;Hemu&#34;, &#34;Momo&#34;) val ms = names.filter { it.startsWith(&#34;M&#34;) } println(ms) //=&gt; [Maku, Momo] filter の代わりに filterNot を使うと、指定した条件を満たさない要素のみを抽出することができます。 // M で始まらない文字列のみを抽出する val ms = names.filterNot { it.startsWith(&#34;M&#34;) } コレクション内から要素が null でないものを取り出したいときは、filterNotNull や mapNotNull を使用すると簡潔に記述できます。 配列やリストから null 以外の要素のみを抽出する (filterNotNull, mapNotNull) マップのフィルタ (filterKeys, filterValues) マップの中から条件を満たす要素だけを抽出したい場合は、キーと値のどちらでフィルタするかによって filterKeys と filterValues を呼び分けます。 キーでフィルタする場合 (filterKeys) 次の例では、マップ要素のキーに Kotlin という文字列を含んでいる要素を抽出しています。 filterKeys の戻り値はマップ型です。 val map = mapOf( &#34;Kotlin ABC&#34; to 2000, &#34;Effective Java&#34; to 2500, &#34;Effective Kotlin&#34; to 1500) val map2 = map.filterKeys { key -&gt; &#34;Kotlin&#34; in key } println(map2) //=&gt; {Kotlin ABC=2000, Effective Kotlin=1500} 値でフィルタする場合 (filterValues) 次の例では、マップ要素の値が 2000 以上であるものを抽出しています。 filterValues の戻り値はマップ型です。 val map = mapOf( &#34;Kotlin ABC&#34; to 2000, &#34;Effective Java&#34; to 2500, &#34;Effective Kotlin&#34; to 1500) val map2 = map.filterValues { value -&gt; value &gt;= 2000 } println(map2) //=&gt; {Kotlin ABC=2000, Effective Java=2500} もちろん、value という変数名は、デフォルトのイテレータ変数 it に置き換えることができます。"},{url:"/p/by55kee/",title:"Kotlinメモ: コレクションの基本的な使い方 (List, Set, Map)",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: コレクションの基本的な使い方 (List, Set, Map) リスト (List) Kotlin の List は、Java の List をベースにしたコレクションです。 一連の要素を格納された順に保持しており、前から順番に要素を取り出すことができます。 不変 (immutable) なリストは、Kotlin 組み込みの listOf 関数で作成することができます。 val list: List&lt;Int&gt; = listOf(1, 2, 3) for (x in list) { println(x) } リスト生成後に要素を追加・削除したい場合は、mutableListOf 関数でリストを作成しておく必要があります。 val list: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3) list.add(4) list.add(5) list.removeAt(0) list.removeAt(0) println(list) //=&gt; [3, 4, 5] セット (Set) Kotlin の Set は、Java の Set をベースにしたコレクションです。 リストと似ていますが、セットは重複しない要素のみを保持し、順序の概念を持ちません。 不変 (immutable) なセットは、Kotlin 組み込みの setOf 関数で作成することができます。 val set: Set&lt;Int&gt; = setOf(1, 2, 3, 1, 2) println(set) //=&gt; [1, 2, 3] 重複する要素は保持しないので、1 と 2 がひとつしか格納されていないところに着目してください。 セット生成後に要素を追加・削除したい場合は、mutableSetOf 関数でセットを作成しておく必要があります。 val set: MutableSet&lt;Int&gt; = mutableSetOf(1, 2, 3) set.add(1) set.add(4) println(set) //=&gt; [1, 2, 3, 4] マップ (Map) Kotlin の Map は、Java の Map をベースにしたコレクションです。 キーと値のペアを保持し、順序の概念はありません。 不変 (immutable) なマップは、Kotlin 組み込みの mapOf 関数で作成することができます。 val map: Map&lt;String, Int&gt; = mapOf(&#34;AAA&#34; to 1, &#34;BBB&#34; to 2, &#34;CCC&#34; to 3) println(map[&#34;AAA&#34;]) //=&gt; 1 // ループ処理（forEach メソッドでも可） for ((k, v) in map) { println(&#34;$k -&gt; $v&#34;) } マップ生成後に要素を追加・削除したい場合は、mutableMapOf 関数でマップを作成しておく必要があります。 val map: MutableMap&lt;String, Int&gt; = mutableMapOf(&#34;AAA&#34; to 1, &#34;BBB&#34; to 2, &#34;CCC&#34; to 3) map[&#34;AAA&#34;] = 5 map[&#34;DDD&#34;] = 10 for ((k, v) in map) { println(&#34;$k -&gt; $v&#34;) } この例から分かるように、要素の変更と追加は、どちらも map[キー] = 値 という記述で実行できます（Kotlin の 内部で set メソッドの呼び出しに変換されています）。 immutable と mutable について Kotlin では、コレクション系のクラスを扱うとき、immutable（不変）なインタフェースと mutable（可変）なインタフェースを明示的に使い分けます。 詳しくは下記の記事を参照してください。 immutable なコレクションと mutable なコレクション (List, Set, Map)"},{url:"/p/v5wjmyk/",title:"Kotlinメモ: コレクションの要素をもとに別のリストを作成する (map)",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: コレクションの要素をもとに別のリストを作成する (map) 配列やリストに対する map map 関数を使用すると、配列やリストなどのコレクション要素の値を使って、別のコレクションを生成することができます。 次の例では、数値リストから、各要素を 2 倍にした新しい数値リストを作成しています。 val nums = listOf(1, 2, 3) val nums2 = nums.map { it * 2 } println(nums2) //=&gt; [2, 4, 6] map 関数の典型的な使用例として、あるクラスのインスタンスのリストから、特定のプロパティを抜き出したリストを作成する、というものがあります。 次の例では、Book インスタンスのリストから、title プロパティだけを抜き出したリストを作成しています。 data class Book(val title: String, val price: Int) fun main() { val books = listOf( Book(&#34;Title1&#34;, 100), Book(&#34;Title2&#34;, 200), Book(&#34;Title3&#34;, 300)) val titles = books.map { it.title } println(titles) //=&gt; [&#34;Title1&#34;, &#34;Title2&#34;, &#34;Title3&#34;] } 上記の books.map { it.title } という部分は、メンバ参照の記法 を使用して books.map(Book::title) と記述することもできます。 マップに対する map マップ系の要素に対して map を実行した場合、ラムダ式に渡されるパラメータは Map.Entry 型のオブジェクトになり、key プロパティと value プロパティを使ってマップ要素のキー＆バリューを取り出せます。 戻り値はリストです。 次の例では、マップ要素のキーを、値の回数だけ繰り返して作成した文字列のリストを生成しています。 String#repeat() は、自分自身の文字列を指定回数だけ繰り返した文字列を作成します。 val map = mapOf(&#34;A&#34; to 1, &#34;B&#34; to 2, &#34;C&#34; to 3) val list = map.map { e -&gt; e.key.repeat(e.value) } println(list) 実行結果 [A, BB, CCC]"},{url:"/p/6r9c6vu/",title:"Kotlinメモ: マップからキーのリスト、値のリストを作成する (keys, values)",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: マップからキーのリスト、値のリストを作成する (keys, values) マップはキーと値のペアを保持するコレクションですが、keys プロパティでキーだけのリスト、values プロパティで値だけのリストを取得することができます。 val map = mapOf(&#34;AAA&#34; to 1, &#34;BBB&#34; to 2, &#34;CCC&#34; to 3) println(map.keys) //=&gt; [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;] println(map.values) //=&gt; [1, 2, 3]"},{url:"/p/633znjc/",title:"Kotlinメモ: マップのキー／値をまとめて変更する (mapKeys, mapValues)",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: マップのキー／値をまとめて変更する (mapKeys, mapValues) マップ要素のキーをまとめて変更する (mapKeys) 既存のマップのキーとして使われている値をまとめて変更するには、mapKeys を使用します。 mapKeys にラムダ式を渡すと、各要素のキー＆バリューを保持した Map.Entry オブジェクトがそのラムダ式に順番に渡されます。 各ループ処理でラムダ式が返した戻り値が新しいキーとして扱われます。 Map.Entry オブジェクトからは、key で要素のキー、value で要素の値を参照することができます。 例: マップ内のキーをすべて大文字に変換する val map = mapOf(&#34;aaa&#34; to 1, &#34;bbb&#34; to 2, &#34;ccc&#34; to 3) val map2 = map.mapKeys { it.key.toUpperCase() } println(map2) //=&gt; {AAA=1, BBB=2, CCC=3} mapKeys の戻り値はマップ型です。 マップ要素の値をまとめて変更する (mapValues) mapValues も mapKeys に似ていますが、こちらはマップ要素の値をまとめて変更します。 ラムダ式は、変更後の要素の値が戻り値になるように実装します。 例: マップ内の値をすべて 2 倍にする val map = mapOf(&#34;aaa&#34; to 1, &#34;bbb&#34; to 2, &#34;ccc&#34; to 3) val map2 = map.mapValues { it.value * 2 } println(map2) //=&gt; {aaa=2, bbb=4, ccc=6} mapValues の戻り値はマップ型です。"},{url:"/p/8msfk3j/",title:"Kotlinメモ: マップをソートしてループ処理する (toSortedMap)",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: マップをソートしてループ処理する (toSortedMap) マップをキーでソートする マップの要素を出力するときに、キー順にソートして出力したいことはよくあると思います。 このような場合、toSortedMap を使用すると、キーでソートされたマップ (SortedMap) に変換することができます。 val map = mapOf(&#34;CCC&#34; to 3, &#34;AAA&#34; to 1, &#34;BBB&#34; to 2) for ((k, v) in map.toSortedMap()) { println(&#34;$k -&gt; $v&#34;) } 実行結果 AAA -&gt; 1 BBB -&gt; 2 CCC -&gt; 3 forEach メソッドを使ってループを記述すると、処理の流れが左から右へ一方向になるので、若干可読性が上がるかもしれません。 map.toSortedMap().forEach { k, v -&gt; println(&#34;$k -&gt; $v&#34;) } sortedMapOf というファクトリ関数を使って、最初からマップインスタンスを SortedMap 型で生成してしまう方法もあります。 val map = sortedMapOf(&#34;CCC&#34; to 3, &#34;AAA&#34; to 1, &#34;BBB&#34; to 2) map.forEach { k, v -&gt; println(&#34;$k -&gt; $v&#34;) } マップを値でソートする マップ要素の値でソートしたいことがごくたまにあります。 ちょっと工夫が必要なので、いくつか方法を紹介します。 キー＆バリューのリストに変換してバリューでソートする方法 val map = mapOf(&#34;AAA&#34; to 3, &#34;BBB&#34; to 1, &#34;CCC&#34; to 2) val pairs = map.toList().sortedBy { it.second } pairs.forEach { (k, v) -&gt; println(&#34;$k, $v&#34;) } 実行結果 BBB, 1 CCC, 2 AAA, 3 toSortedMap() にカスタム Comparator を渡す方法 val map = mapOf(&#34;AAA&#34; to 3, &#34;BBB&#34; to 1, &#34;CCC&#34; to 2) val map2 = map.toSortedMap( Comparator { k1, k2 -&gt; map[k1]!! - map[k2]!! } ) map2.forEach { k, v -&gt; println(&#34;$k, $v&#34;) }"},{url:"/p/r2gqqnt/",title:"Kotlinメモ: メンバ参照、結合メンバ参照を理解する",date:"2019-06-03T00:00:00+09:00",body:"Kotlinメモ: メンバ参照、結合メンバ参照を理解する メンバ参照 (Member references) Kotlin では、クラス名::プロパティ名 あるいは クラス名::関数名 という記述をメンバ参照 (Member reference) と呼び、あるレシーバオブジェクトに対して、どのメンバを参照するかを示すことができます。 Book クラスの price プロパティを参照するメンバ参照は、 Book::price と記述することができ、これは下記のようなラムダ式と同じ意味を持ちます。 { b: Book -&gt; b.price } つまり、Book オブジェクトをパラメータとして受け取り、その price プロパティの値を返す関数です。 メンバ参照を変数に格納しておくと、後から通常の関数のように呼び出すことができます。 data class Book(val title: String, val price: Int) // price プロパティの値を参照するメンバ参照 val getPrice = Book::price fun main() { val book = Book(&#34;Title&#34;, 1000) println(getPrice(book)) //=&gt; 1000 } メンバ参照は、コレクション系のメソッドに適用できるケースがよくあります。 下記の例では、リストをソートする関数 sortedBy に、メンバ参照オブジェクトを渡しています。 // price プロパティの値を参照するメンバ参照 val getPrice = Book::price val books = listOf( Book(&#34;Title1&#34;, 300), Book(&#34;Title2&#34;, 500), Book(&#34;Title3&#34;, 100)) val sortedBooks = books.sortedBy(getPrice) このように単純なケースでは、次のように直接ラムダ式を渡してもシンプルに記述できます。 books.sortedBy { it.price } ただ、メンバ参照オブジェクトを変数やパラメータ経由で渡すようなケースでは、メンバ参照の記法を使った方が短く記述できます。 型の推論が働かないため、デフォルトのイテレータ変数 (it) を使えないからです。 val getPrice = Book::price // Good val getPrice = { b: Book -&gt; b.price } // OK（冗長） val getPrice = { it.price } // NG（コンパイルエラー） パラメータを持つインスタンスメソッドをメンバ参照を使って呼び出す場合は、第二引数以降にメソッドのパラメータとして渡す値を指定します。 第一引数では、レシーバオブジェクトを指定しなければいけないからです。 data class Person(val name: String) { fun greet(name: String) { println(&#34;Hello, $name. I am ${this.name}.&#34;) } } val g = Person::greet fun main() { val p = Person(&#34;Maku&#34;) g(p, &#34;Hemu&#34;) } トップレベル関数の参照 (Reference to the Top-level function) トップレベルに定義した関数の参照は、クラス名を省略した形で ::関数名 と記述することで取得することができます。 下記の例では、greet 関数の参照を、g 変数に取得しています。 fun greet(name: String) = println(&#34;Hello, $name&#34;) fun main() { val g = ::greet g(&#34;Maku&#34;) //=&gt; &#34;Hello, Maku&#34; } 関数の参照は、ラムダ式を受け取るように設計された関数に対して、定義済みの関数をパラメータとして渡す場合に便利です。 次の例では、run で実行する内容として、定義済みの shout 関数を渡しています。 fun shout() = println(&#34;WRYYY!!!&#34;) fun main() { run(::shout) } ::関数名 という記法は、関数参照を表している（そこでは関数を呼び出さない）ということを覚えておきましょう。 コンストラクタ参照 (Constructor references) ::クラス名 という記述は、クラスのコンストラクタへの参照を意味します。 トップレベル関数と同様の記法ですが、このコンストラクタ参照を呼び出すと、クラスのインスタンスを返します。 data class Book(val title: String, val price: Int) fun main() { val createBook = ::Book val b = createBook(&#34;Title&#34;, 1000) println(b) } メンバ参照とは異なり、第一パラメータにレシーバオブジェクトを指定する必要がないことに注意してください（コンストラクタなので当然ですが）。 結合メンバ参照 (Bound member references) クラスのメンバ参照は、クラス名::メソッド名 のような形で取得しましたが、このクラス名の部分をインスタンス名に置き換えると、結合メンバ参照 (Bound member reference) となり、呼び出し時にインスタンスを指定せずに呼び出せるようになります。 class Counter(var count: Int = 0) { fun increment() = ++count } fun main() { val c = Counter() val inc = c::increment inc() inc() inc() println(c.count) //=&gt; 3 } ちなみに、このようにインスタンスに結び付けられた参照を Bound reference と呼ぶのに対して、クラス名::メソッド名 のような参照を Unbound reference と呼ぶことがあります。"},{url:"/p/i4zkqye/",title:"Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする",date:"2019-05-30T00:00:00+09:00",body:"Python の urllib による HTTP 通信 (5) ヘッダを付けてリクエストする リクエストごとにヘッダを設定する (Request) urllib.request.Request オブジェクトの add_header メソッドや、headers プロパティを使用すると、HTTP リクエスト時のヘッダ情報を設定することができます。 あとは、urllib.request.urlopen で HTTP リクエストを送信するとき、URL の代わりに Request オブジェクトを渡せば、ヘッダ付きのリクエストを送ることができます。 import urllib.request def create_request(): req = urllib.request.Request(&#39;https://example.com/myapi&#39;) req.add_header(&#39;Referer&#39;, &#39;http://www.python.org/&#39;) req.add_header(&#39;User-Agent&#39;, &#39;Mozilla/5.0&#39;) return req if __name__ == &#39;__main__&#39;: req = create_request() with urllib.request.urlopen(req) as res: html = res.read().decode(&#39;utf-8&#39;) print(html) 上記の例では、Request#add_header() メソッドを使って、ヘッダ情報を 1 つずつ付加しています。 Request#headers プロパティを使用すれば、複数のヘッダ情報をディクショナリ形式でまとめて設定することができます。 req.headers = { &#39;Referer&#39;: &#39;http://www.python.org/&#39;, &#39;User-Agent&#39;: &#39;Mozilla/5.0&#39;, } すべてのリクエストに共通のヘッダを設定する (OpenerDirector) Request オブジェクトは URL まで含んでいるため、アクセス先の URL が変わるたびに生成しなおす必要があります。 一方、OpenerDirector を使用すると、リクエスト時のヘッダ情報などはそのままで、URL だけを変更してアクセスすることができます。 import urllib.request def create_opener(): opener = urllib.request.build_opener() opener.addheaders = [ (&#39;Referer&#39;, &#39;http://www.python.org/&#39;), (&#39;User-Agent&#39;, &#39;Mozilla/5.0&#39;), ] return opener if __name__ == &#39;__main__&#39;: opener = create_opener() with opener.open(&#39;https://example.com/myapi&#39;) as res: html = res.read().decode(&#39;utf-8&#39;) print(html) ヘッダ情報は OpenerDirector#addheaders プロパティにセットするのですが、add という名前なのにプロパティになっていたり、ディクショナリではなくリストで値を設定しなければいけなかったりと、謎仕様なところには注意してください。 作成した OpenerDirector オブジェクトを、urllib.request.install_opener 関数で設定してやることで、それ以降の urlopen はその OpenerDirector の設定に基づいて動作するようになります。 アプリケーション全体でアクセス方法を統一したいのであれば、こちらの方法を使うとシンプルかもしれません。 import urllib.request def setup_requests(): opener = urllib.request.build_opener() opener.addheaders = [ (&#39;Referer&#39;, &#39;http://www.python.org/&#39;), (&#39;User-Agent&#39;, &#39;Mozilla/5.0&#39;), ] urllib.request.install_opener(opener) if __name__ == &#39;__main__&#39;: setup_requests() with urllib.request.urlopen(&#39;https://example.com/myapi&#39;) as res: html = res.read().decode(&#39;utf-8&#39;) print(html)"},{url:"/p/a8cta8q/",title:"Python の型の一覧、ある値の型を調べる (type)",date:"2019-05-29T00:00:00+09:00",body:"Python の型の一覧、ある値の型を調べる (type) Python の組み込み型 Python の主な組み込み型は、数値、シーケンス、マッピング、クラス、インスタンス、および例外です。 数値型 int 整数（精度なし）。Python2 には long 型というものがありましたが、Python3 で int に統合されました。Python3 の int には精度の制限はなく、巨大な整数を保持することができます。 float 浮動小数点数（現在のシステムにおける精度は sys.float_info.mant_dig で確認できる、多くの場合 53 ビットの精度） complex 複素数 標準ライブラリ fractions &hellip; 分数 decimal &hellip; ユーザ定義の精度の浮動小数点数 論理型 bool True or False（and、or、not 演算が可能）。int のサブタイプ。Python の bool 型は int 型を継承しているのが特徴的です。bool オブジェクトから int クラスのメソッドを呼び出すことができます。 シーケンス list 可変 (mutable) なシーケンス tuple 不変 (immutable) なシーケンス range 範囲を示すシーケンス（数の不変なシーケンス） 文字列型 str テキストを示す不変 (immutable) なシーケンス ある値・変数の型を調べる (type) type 関数を使用すると、パラメータで渡した値の型を調べることができます。 基本型の型名を調べる print(type(100)) #=&gt; &lt;class &#39;int&#39;&gt; print(type(1.5)) #=&gt; &lt;class &#39;float&#39;&gt; print(type(1+2j)) #=&gt; &lt;class &#39;complex&#39;&gt; print(type(True)) #=&gt; &lt;class &#39;bool&#39;&gt; print(type(&#39;ABC&#39;)) #=&gt; &lt;class &#39;str&#39;&gt; print(type([0, 1, 2])) #=&gt; &lt;class &#39;list&#39;&gt; print(type((0, 1, 2))) #=&gt; &lt;class &#39;tuple&#39;&gt; print(type(range(10))) #=&gt; &lt;class &#39;range&#39;&gt; ちなみに、type 関数が返すオブジェクトの型は type で、このオブジェクトを 型オブジェクト (Type object) と呼びます。 print(type(type(1))) #=&gt; &lt;class &#39;type&#39;&gt; type 関数でビルトイン関数の型を調べると下記のような結果になります。 print(type(print)) #=&gt; &lt;class &#39;builtin_function_or_method&#39;&gt; Python の変数定義では型を省略して記述できますが、クラスライブラリを使用する場合は、関数の戻り値がどのクラスのインスタンスなのかを把握するようにすると、理解が進みやすくなります。 例: urlopen() の戻り値の型を調べる import urllib.request request = urllib.request.urlopen(&#39;https://example.com/&#39;) print(type(request)) #=&gt; &lt;class &#39;http.client.HTTPResponse&#39;&gt;"},{url:"/p/qpcvfzi/",title:"Hugo でドラフトページの一覧を簡単に確認できるようにする",date:"2019-05-22T00:00:00+09:00",body:"Hugo でドラフトページの一覧を簡単に確認できるようにする やりたいこと Hugo では、作成途中の記事ページをドラフトとしてマークしておくと、デフォルトで非公開扱いになるので、気軽に記事を書き始めることができます。 ただ、ドラフトページがたくさん溜まってくると、自分が中途半端に書き始めた記事が散らばって分かりにくくなってしまいます。 そこで、ここでは下記のような仕組みを実装して、Hugo のドラフト機能をより便利に使用できるようにします。 図: ドラフト一覧のページへ移動するボタン ドラフトの一覧ページに飛ぶための ドラフト記事一覧ボタン をサイドバー上に表示する（上図） ドラフトの一覧ページでは、最終更新日 や タグ情報 も一緒に表示する 上記は ローカルでの作業中のみ表示する こととする（具体的には hugo server で実行中のみ） ドラフト記事一覧のページにジャンプするボタンを配置する ドラフトページへジャンプするためのボタンは、レイアウトファイルから簡単に配置できるように、パーシャルファイルとして作成します。 個人的に、ローカルでしか有効にしないコードは、下記のように debug ディレクトリの下に入れるようにしています。 そして、全体のコードを if hugo.IsServer の条件で囲むことで、ローカルサーバーで起動しているときのみ出力されるようにしています。 layouts/partials/debug/draft-button.html {{- if hugo.IsServer -}} &lt;style&gt; .xDraftButton { display: block; text-align: center; width: 100%; font-weight: bolder; color: white !important; background: blue; padding: 0.3em 0.5em; border-radius: 0.5em; } &lt;/style&gt; &lt;a href=&#34;/drafts/&#34; class=&#34;xDraftButton&#34;&gt;ドラフト記事一覧&lt;/a&gt; {{- end }} 簡単に言えば、このパーシャルは、https://example.com/drafts/ といった URL へのリンクを出力しているだけです。 上記では style 要素も含めてしまっていますが、みなさんはちゃんと CSS ファイルでスタイル定義するようにしてください。 このパーシャルファイルを、サイドバーを出力するテンプレートから呼び出します。 layouts/partials/sidebar/all.html（抜粋） {{ partial &#34;debug/draft-button&#34; . }} ドラフト記事一覧を表示するページを作成する ドラフト記事をリストアップするためのショートコードを作成します。 下記のようにすれば、フロントマター部分に draft: true と記述された記事のみをループ処理できます。 layouts/shortcodes/list-drafts.html &lt;ul&gt; {{- range (where .Site.Pages &#34;.Draft&#34; true) }} &lt;li&gt; &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; &lt;small&gt; ({{ .Lastmod.Format &#34;2006-01-02&#34; }}) {{ range .Params.tags }}#{{ . }} {{ end }} &lt;/small&gt; &lt;/li&gt; {{- end }} &lt;/ul&gt; このショートコードを、ドラフト記事一覧のページを生成するための Markdown ファイルから呼び出します。 ドラフトボタンのリンク先 URL を /drafts/ にしたので、その URL に合うように、drafts/_index.md というパスに作成します。 content/drafts/_index.md --- title: &#34;ドラフト記事一覧&#34; draft: true --- （ここに本文を書くこともできるよ！） {{&lt; list-drafts &gt;}} これで、hugo server -D とサーバーモードで起動したときに、ドラフト記事一覧へのリンクボタンが表示されるようになり、簡単に書きかけの記事を確認できるようになります。 ドラフト記事をビルド対象にするために、-D オプションが必要になることに注意してください。"},{url:"/p/x9tbr8o/",title:"Hugo で各ページに目次を表示する (.TableOfContents)",date:"2019-05-21T00:00:00+09:00",body:"Hugo で各ページに目次を表示する (.TableOfContents) Hugo 組み込みのページ変数 .TableOfContents を使用すると、各ページに簡単に目次を表示することができます。 Hugo の目次機能 各ページの Markdown ファイル (.md) には、## や ---- を使ったセクション（h2 要素として出力される）を記述していると思います。 Hugo は、これらの セクション名から自動的に目次 (Table of Contents) を出力する機能 を搭載しています。 下記は、自動的に出力した目次の例です。 図: Hugo で自動生成された目次 テンプレートの記述方法（v0.59以前） 目次を自動的に出力するには、テンプレートファイル内で .TableOfContents というページ変数を参照します。 layouts/_default/single.html（抜粋） {{- with .TableOfContents }} &lt;aside class=&#34;xToc&#34;&gt; &lt;div class=&#34;xToc_title&#34;&gt;目次&lt;/div&gt; {{ . }} &lt;/aside&gt; {{- end }} ここでは、目次情報がないときに何も表示しないように、with で分岐処理を行っています（2019-12-26 追記: v0.60.0 以降は出力内容が変わったため、このように分岐処理を行えなくなりました。次のセクションを参照してください）。 Hugo が自動的に生成する .TableOfContents の値は、ul 要素と li 要素によって構成されています。 出力された HTML の内容を見て、スタイルシート (CSS) の調整をするとよいでしょう。 下記は CSS の記述例です。 .xToc { font-size: smaller; border-radius: 0.5em; border: solid 1px lightgray; padding: 0.5em 1em; line-height: 2; } .xToc_title { font-weight: bolder; } .xToc ul { list-style-type: none; padding-left: 0; } .xToc li { padding-top: 0 !important; } .xToc li &gt; ul { padding-left: 1em; width: 100%; } .xToc a { font-weight: normal; display: block; border-bottom: dashed 1px lightgray; } テンプレートの記述方法（v0.60以降） Hugo v0.60 から Markdown パーサーが Goldmark に変更され、Table of Contents の出力内容も変わってしまいました。 これまでは、ページ内に見出し（h2 要素など）が存在しない場合は、.TableOfContents 変数の値は空っぽになっていたので、その場合は「目次」というタイトルも含めて何も出力しない、という制御ができていました。 しかし、v0.60 以降は、ページ内に一切見出しが存在しなくても .TableOfContents の値には次のような文字列が入ってしまいます。 &lt;nav id=&#34;TableOfContents&#34;&gt;&lt;/nav&gt; しょうがないので、Hugo テンプレートファイルの中では分岐処理などを行わずに、素直に .TableOfContents の値を出力しておきます。 layouts/_default/single.html（抜粋） {{ .TableOfContents }} 「目次」というタイトルを表示するかどうかの制御は、CSS で行うことにしましょう。 ここでは、#TableOfContents という ID の HTML 要素の直下に ul 要素があるときのみ、その直前に「目次」というテキストを挿入しています。 #TableOfContents &gt; ul { font-size: smaller; border-radius: 0.5em; border: solid 1px lightgray; padding: 0.5em 1em; line-height: 2; } #TableOfContents &gt; ul:before { content: &#34;目次&#34;; font-weight: bolder; } #TableOfContents ul { list-style-type: none; } #TableOfContents li { padding-top: 0; } #TableOfContents li &gt; ul { padding-left: 1em; width: 100%; } #TableOfContents a { font-weight: normal; display: block; border-bottom: dashed 1px lightgray; } これで、ある程度は目次の見た目を制御できます。 本当は、ツールが生成する要素の ID (#TableOfContents) に依存する CSS などは記述したくないのですが、仕方ありません。 Hugo がうまい制御方法を用意してくれるまでこれで凌ぎます。 参考 Table of Contents ｜ Hugo"},{url:"/p/dunigdz/",title:"Hugo でページタイトルに自動でセクションプレフィックスを付ける",date:"2019-05-17T00:00:00+09:00",body:"Hugo でページタイトルに自動でセクションプレフィックスを付ける Hugo で多くのコンテンツを作成する場合、記事の種類ごとにセクション（ディレクトリ）に分けて管理することになります。 このような場合、各ページのタイトルに対して、セクションのタイトルを自動で付加できれば、ページタイトルの管理が楽になります。 何をするか？ 例えば、次のようなセクション構造で記事を管理しているとします。 contents/ +-- _index.md (home page) +-- section1/ | +-- _index.md (section page) | +-- page1.md (single page) | +-- page2.md (single page) | +-- page3.md (single page) +-- section2/ +-- _index.md (section page) +-- ... 各ディレクトリにある _index.md は、セクションページのコンテンツファイルとして使用されます。 このファイルのフロントマターには、下記のようにセクションのタイトルを記述することができます。 contents/section1/_index.md --- title: &#34;セクション1&#34; date: &#34;2019-05-17&#34; --- セクションページの本文… このセクションタイトルは、セクションページ（このケースでは https://example.com/section1/）にアクセスしたときに使用されるものですが、同じセクションに所属する記事ページのタイトルのプレフィックスにも自動で付加できると便利です。 例えば、section1 に所属する記事ページとして下記のようなコンテンツがあるとします。 contents/section1/page.md --- title: &#34;タイトル1&#34; date: &#34;2019-05-17&#34; --- ページの本文… このように記述されているときに、表示するタイトルを タイトル1 ではなく、セクション1: タイトル1 のようにしたいということです。 このように、セクションタイトルを付加することで、あるページを単独で表示したときに、どのような階層に配置された記事なのかが分かりやすくなります。 セクションプレフィックスの実装 ここでは、シングルページテンプレートで、セクションプレフィックスの仕組みを実現する方法を示します。 下記の例では、構築したページタイトルを $pageTitle という変数に格納しています。 layouts/_defaults/single.html（抜粋） {{ $pageTitle := cond (eq .CurrentSection.Section &#34;&#34;) (.Title) (printf &#34;%s: %s&#34; .CurrentSection.Title .Title) }} &lt;h1&gt;{{ $pageTitle }}&lt;/h1&gt; コンテンツのルートディレクトリ (contents) に配置したページにアクセスしたときは、.CurrentSection.Section の値が空 (&quot;&quot;) になることを利用して、ページのタイトルをそのまま表示するようにしています。 ☝️ ワンポイント 上記では、h1 要素で表示上のページタイトルを設定していますが、head 要素下の title 要素にも同様に設定するようにしてください。 Google などの検索エンジンは、title 要素に指定したページタイトルを表示します。 （応用）セクションプレフィックス用のプロパティを用意する方法 上記の例では、セクションプレフィックスとして、自分が所属するセクションのセクションページに設定された title プロパティの値を使用していました。 ここでは、セクションプレフィックス用に、独自のプロパティ sectionPrefix を参照するようにしてみます。 このようなケースでは、Hugo の Front Matter Cascade という機能を使用すると便利です。 例えば、セクションページのフロントマターで次のように記述しておくと、 contents/section1/_index.md --- title: &#34;セクションタイトル1&#34; cascade: sectionPrefix: &#34;セクション1&#34; --- このセクション内の記事では、.Params.sectionPrefix 変数で セクション1 という値を参照できるようになります。 親セクションのフロントマターで cascade: 以下に設定したプロパティを、すべての子ページから参照できるということです。 下記はテンプレートの実装例です。 テンプレートの例（抜粋） {{ $pageTitle := .Title }} {{ if ne .Kind &#34;section&#34; }} {{ with .Params.sectionPrefix }} {{ $pageTitle = printf &#34;%s: %s&#34; . $pageTitle }} {{ end }} {{ end }} &lt;h1&gt;{{ $pageTitle }}&lt;/h1&gt; 現在のページがセクションページでなければ、sectionPrefix プロパティの値をタイトルの前に連結する、という処理になっています。"},{url:"/p/rdoseay/",title:"Kotlinメモ: ラムダ式の基本 (lambda expression)",date:"2019-05-16T00:00:00+09:00",body:"Kotlinメモ: ラムダ式の基本 (lambda expression) ラムダ式とは ラムダ式は、パラメータを受け取ることのできる名前のない小さなコードブロックです。 Kotlin では、ラムダ式は次のように中括弧 {} で囲んで定義します。 { a: Int, b: Int -&gt; a + b } このラムダ式は、2 つの Int 型パラメータを受け取り、足し合わせた値を返します。 ラムダ式を変数に格納すると、通常の関数のように呼び出すことができるようになります。 val sum = { x: Int, y: Int -&gt; x + y } println(sum(1, 2)) //=&gt; 3 ラムダ式の典型的な使い方は、処理の一部をパラメータとして渡す使い方です。 次の例では、ボタンが押されたときのイベントハンドラとして、パラメータなしのラムダ式をセットしています。 button.setOnClickListener { println(&#34;ボタンが押されたよ&#34;) } このようなコールバック処理は、インタフェースを実装したオブジェクトを渡すことでも実現できますが、ラムダ式を使うと関数の本体部分だけを渡すことができるので、とてもシンプルな記述ができます。 ラムダ式を受け取る関数を定義する 下記の myRepeat 関数は、第1引数 times で指定された回数だけ、第2引数 action で指定されたラムダ式を繰り返し実行します。 fun myRepeat(times: Int, action: (Int) -&gt; Unit) { for (index in 0 until times) { action(index) } } パラメータ action の型は (Int) -&gt; Unit となっていますが、これは、Int 型のパラメータを取り、戻り値がない (Unit) ラムダ式を受け取ることを表しています。 myRepeat 関数は次のように使用します。 fun main() { myRepeat(3, { i -&gt; println(&#34;Hello $i&#34;)} ) } 実行結果 Hello 0 Hello 1 Hello 2 上記のように、関数の最後のパラメータがラムダ式である場合、その関数を呼び出すときに、ラムダ式を括弧の外に出して次のように記述することができます。 myRepeat(3) { i -&gt; println(&#34;Hello $i&#34;) } このような記述方法が許されているので、ラムダ式の中が複数行にわたるコードになった場合にも、次のようにシンプルに記述することができます。 myRepeat(3) { i -&gt; println(&#34;${i + 1} 回目のループ処理です&#34;) println(&#34;Hello!&#34;) } ラムダ式のパラメータが 1 つだけのとき、i -&gt; の部分を省略し、代わりに it というパラメータ名で参照することができます。 myRepeat(3) { println(&#34;Hello $it&#34;) } デフォルトのパラメータ名である it を使用すると簡潔な記述が可能ですが、明示的に名前を付けたほうが可読性が上がるケースもあります。 例えば、ラムダ式がネストされている場合などはパラメータ名を指定すべきでしょう。 ちなみに、Kotlin の組み込み関数 repeat を使うと、上記の myRepeat と同様のことを行えます。 ラムダ式のいろいろな使い方 forEach（繰り返し処理） リストや配列の要素を繰り返し処理する forEach 関数 は、ラムダ関数の代表的な使用例です。 val list = listOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) list.forEach { println(it) } このようにパラメータがラムダ式だけであれば、関数名の直後の括弧 () を省略することができます（forEach() と書かなくてよい）。 ちなみに、ループ処理中にインデックス番号が欲しいときは、forEach の代わりに forEachIndexed を使用します。 list.forEachIndexed { index, value -&gt; println(&#34;$index -&gt; $value&#34;) } 次のように for ~ in を使用した書き方もできますが、ラムダ式を使ったほうがスマートですね。 for ((index, value) in list.withIndex()) { println(&#34;$index -&gt; $value&#34;) } map, mapIndexed（変換処理をラムダ式で指定する） リストや配列に適用できる map 関数 を使うと、各要素の値を、ラムダ式によって加工することができます。 下記の例では、数値リストの各要素を 2 倍にしています。 val list = listOf(1, 2, 3) val list2 = list.map { it * 2 } println(list2) //=&gt; [2, 4, 6] map 関数は下記のように定義されていて、受け取るラムダ式の型は (T) -&gt; R と定義されています。 public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; { return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform) } T は元のリスト要素の型で、R が変換後のリスト要素の型です。 実際には、ほとんどのケースで型の指定を省略することができるため、呼び出しコードはとてもシンプルになります。 maxBy, sortBy（比較アルゴリズムをラムダ式で指定する） リストや配列に適用できる maxBy 関数 を使うと、その中の最大の要素を検索するときに、どのフィールドの値を参照するかをラムダ式で指定することができます。 下記の例では、Book のリストのから、price フィールドが最大であるものを検索しています。 data class Book(val title: String, val price: Int) val list = listOf( Book(&#34;Title1&#34;, 500), Book(&#34;Title2&#34;, 1000), Book(&#34;Title3&#34;, 300)) val mostExpensiveBook = list.maxBy { it.price } println(mostExpensiveBook) //=&gt; Book(title=Title2, price=1000) 上記の例では、検索に使用するフィールドを list.maxBy { it.price } というようにラムダ式で指定していますが、このように単純に、あるフィールドを参照すればよい場合、Book::price というメンバ参照で指定することもできます。 この方法であれば、ラムダ式の記述は必要なくなります。 val mostExpensiveBook = list.maxBy(Book::price) Book::price は、{ b: Book -&gt; b.price } というラムダ式の省略記法です。 メンバ参照に関しての説明はこちら を参照してください。 maxBy 関数の実装は次のようになっています。 /** * Returns the first element yielding the largest value of * the given function or `null` if there are no elements. */ public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Iterable&lt;T&gt;.maxBy(selector: (T) -&gt; R): T? { val iterator = iterator() if (!iterator.hasNext()) return null var maxElem = iterator.next() var maxValue = selector(maxElem) while (iterator.hasNext()) { val e = iterator.next() val v = selector(e) if (maxValue &lt; v) { maxElem = e maxValue = v } } return maxElem } withLock（テンプレートメソッドのような処理をラムダ式で実現する） テンプレート的な処理の一部をラムダ式で指定すると、コードを簡潔にすることができます。 例えば、ReentrantLock による排他処理は、lock() で開始、unlock() で終了、という流れになりますが、このように順序の決まった定型処理をカプセル化することができます。 val lock = ReentrantLock() lock.withLock { // スレッドセーフにしたいコード } withLock 関数は次のように実装されています。 public inline fun &lt;T&gt; Lock.withLock(action: () -&gt; T): T { lock() try { return action() } finally { unlock() } } ラムダ式のパラメータの型を省略できないケース ラムダ式のパラメータの型は通常コンパイラによって推測されるので省略できますが、ラムダ式をいったん変数に格納してから使用する場合は、パラメータの型を明示する必要があります。 val getBookPrice = { b: Book -&gt; b.price } val mostExpensiveBook = list.maxBy(getBookPrice) ラムダ式からのローカル変数アクセス Kotlin のラムダ式からは、同じスコープで定義されたローカル変数や関数のパラメータにアクセスすることができます。 Java のラムダ式やインナーメソッドからも、同様にローカル変数にアクセスすることはできますが、final 定義された変数にしかアクセスできないという制約がありました。 Kotlin のラムダ式にはそのような制約はないため、ラムダ式の中から、外側の変数の値を変更することができます。 fun totalSales(shops: List&lt;Shop&gt;) : Int { var total = 0 shops.forEach { total += it.sales } return total } ☝️ ワンポイント 専門用語では、Java のラムダは「final 変数しか捕捉 (capture) できない」と表現します。 逆に、Kotlin のラムダは「mutable な変数も捕捉できる」と表現します。 ラムダ式で外部変数を変更する場合は、上記のように、同期で実行される必要があります。 非同期に実行されるラムダ式の中で値を変えようとしても、その次の処理が先に実行されてしまうので意味のないコードになってしまいます。 fun getClickCount(button: Button) { var count = 0 button.setOnClickListener { ++count } return count // ここが先に実行されるので常に 0 になってしまう } ちなみに、前述の totalSales のような処理は、sumBy や fold を使えば、次のように簡単に記述することができます。 val total = list.sumBy(Shop::sales) val total = list.fold(0) { total, elem -&gt; total + elem.sales } sumBy は単純にフィールドの値を足し合わせ、fold は一要素ずつ計算結果を畳み込んでいきます（一つ前の計算結果を用いて次の計算を行う）。"},{url:"/p/wc8f9y8/",title:"Kotlinメモ: オブジェクト宣言でシングルトンを作成する (object declaration)",date:"2019-05-14T00:00:00+09:00",body:"Kotlinメモ: オブジェクト宣言でシングルトンを作成する (object declaration) オブジェクト宣言によるシングルトン実装 Java のシングルトンに相当するものは、Kotlin ではオブジェクト宣言 (object declrations) を使用して簡単に実装することができます。 object Log { fun info(text: String) = println(text) fun error(text: String) = System.err.println(text) } 上記の例では、object Log という部分で Log という名前のオブジェクトを作成しています。 その後ろに続く { ... } のブロックがクラス定義の内容です。 無名のクラス定義があり、そのインスタンスとして Log という名前のオブジェクトを生成していると考えるとよいでしょう。 Log オブジェクトのメソッドを呼び出すコードは下記のようになります。 fun main() { Log.info(&#34;Hello&#34;) Log.error(&#34;Something bad happened&#34;) } オブジェクト名が大文字で始まっていて、クラス名のように見えるので、まるで Java の static メソッド呼び出しのように見えますが、実際には Log という名前のオブジェクトのメソッド呼び出しているにすぎません。 Kotlin には static フィールドというものは存在しません（@JvmStatic という魔法のキーワードはありますが）。 オブジェクト宣言では、通常のクラス定義と同様に、メソッドやプロパティ、初期化ブロック (init) などの定義を行うことができますが、プライマリ・コンストラクタやセカンダリ・コンストラクタの定義を行うことはできません（クラス定義とインスタンス化が同時に行われるため、他の場所でコンストラクタを呼び出すタイミングがないからです）。 コンストラクタは定義できないので、下記のようにインスタンスを作成することはできません。 val log = Log() // NG（インスタンス化はできない） よって、オブジェクト宣言によって作成されたオブジェクトは、シングルトンオブジェクトとして使用することができます。 オブジェクト宣言で継承を行う オブジェクト宣言 (object declaration) では、普通のクラス実装と同様、別のクラスの継承や、インタフェースの実装を行うことができます。 あくまでクラス定義とインスタンス生成を実装を同時に行っているだけで、このあたりの制約はありません（コンストラクタは定義できないので、コンストラクタでパラメータを渡せない点には注意）。 object DefaultListener : MouseAdapter() { override fun mouseClicked(e: MouseEvent) { // ... } override fun mouseEntered(e: MouseEvent) { // ... } } ステートを持たないアルゴリズムなどは、オブジェクト宣言によって実装してしまうのがよいでしょう。 下記の例では、Book クラスのオブジェクトを値段で比較するための Comparator を実装しています。 data class Book(val title: String, val price: Int) object BookPriceComparator : Comparator&lt;Book&gt; { override fun compare(a: Book, b: Book): Int { return a.price - b.price } } fun main() { val books = listOf(Book(&#34;A&#34;, 300), Book(&#34;B&#34;, 100), Book(&#34;C&#34;, 200)) val sorted = books.sortedWith(BookPriceComparator) println(sorted) } 実行結果 [Book(title=B, price=100), Book(title=C, price=200), Book(title=A, price=300)] このように、あるクラスに特化した Comparator を作成する場合は、次のようにオブジェクト宣言をネストさせてしまった方が分かりやすいかもしれません。 data class Book(val title: String, val price: Int) { object PriceComparator : Comparator&lt;Book&gt; { // ... } } Java からの参照 (INSTANCE) オブジェクト宣言 (object declaration) によって作成されたオブジェクトを Java のコードから参照したい場合は、INSTANCE キーワードを使用します。 例えば、下記のようにオブジェクト宣言で定義した Log オブジェクトがあるとします。 Log.kt package com.example.util object Log { fun info(text: String) = println(text) fun error(text: String) = System.err.println(text) } このシングルトンオブジェクトは、Java からは Log.INSTANCE という名前で参照できます。 JavaMain.java import com.example.util.Log; public class JavaMain { public static void main(String... args) { Log.INSTANCE.info(&#34;Hello&#34;); Log.INSTANCE.error(&#34;World&#34;); } } どうしても、Java から Log.info(...) のように static メソッドとして参照したい場合は、Kotlin 側でメソッドを定義するときに @JvmStatic を付けます。 object Log { @JvmStatic fun info(text: String) = println(text) @JvmStatic fun error(text: String) = System.err.println(text) }"},{url:"/p/8yzdom9/",title:"Kotlinメモ: オブジェクト式で無名オブジェクトを生成する (object expression)",date:"2019-05-14T00:00:00+09:00",body:"Kotlinメモ: オブジェクト式で無名オブジェクトを生成する (object expression) オブジェクト式の基本 オブジェクト宣言 (object declaration) は、クラスの定義とインスタンス生成を同時に行う構文ですが、これと似たものに オブジェクト式 (object expression) があります。 オブジェクト宣言では、object MyObj { ... } のように、クラス定義と同時に名前付きのオブジェクトを作成していましたが、オブジェクト式はその場で名前なしの無名オブジェクト (anonymous objects) を生成します。 オブジェクト式を使って生成したオブジェクトは、変数に格納するか、関数に渡すパラメータとして使用します（そうしないと参照できないため）。 下記の例では、オブジェクト式を使って、greet() 関数を持つ無名オブジェクトを生成しています。 生成されたオブジェクトを使用するために、いったん myObj という変数に格納しています。 val myObj = object { fun greet() = println(&#34;Hello&#34;) } myObj.greet() （これだけ見ると、JavaScript のオブジェクトにとても似ていますね） オブジェクト式は、何らかのインタフェースを実装する無名オブジェクトを生成するときによく使われます。 interface ButtonListener { fun onClicked() } val listener = object : ButtonListener { override fun onClicked() = println(&#34;押されたよ&#34;) } オブジェクト式により生成した無名オブジェクトを、関数のパラメータに直接渡してしまうこともできます。 button.addListener(object : ButtonListener { override fun onClicked() = println(&#34;押されたよ&#34;) }) ただし、このように記述すると、このコードが実行されるたびにオブジェクトが生成されることに注意してください。 ちなみに、オブジェクト宣言 (object declaration) を使った場合は、下記のような記述になりますが、この場合は、イコール演算子の右側に書いたり、そのまま関数のパラメータで渡したりすることはできません（オブジェクト宣言は「式」ではないので、値を持ちません）。 // オブジェクト宣言 (object declaration) の場合 object MyButtonListener : ButtonListener { override fun onClicked() = println(&#34;押されたよ&#34;) } オブジェクト式から外部変数を参照する オブジェクト式のクラス実装部分からは、その外側のスコープにある変数や関数を参照することができます。 これは Java の無名インナクラスと同様ですが、Kotlin では final 修飾されていない変数を参照することができ、さらに、その値を変更することもできます。 fun startCounting(button: Button) { var count = 0 button.addListener(object : ButtonListener { override fun onClicked() { println(&#34;${++count} 回クリックされたよ&#34;) } }) } Java の無名インナークラスに比べた利点 Kotlin のオブジェクト式は、Java では無名インナークラスに相当します。 Java の無名オブジェクト生成 button.addListener(new ButtonListener() { @Override public void onClick() { System.out.println(&#34;Hello&#34;); } }); Java の無名インナークラスの場合、その構文の都合上、1 つまでしかインタフェースを実装できませんでしたが、Kotlin のオブジェクト式では、任意の数のインタフェースを実装することができます（前述しましたが、インタフェースを全く実装しないプレーンなオブジェクトも作成できます）。 val listener = object : IFoo, IBar, IHoge { // ... }"},{url:"/p/n2jphu2/",title:"Kotlinメモ: コンパニオンオブジェクトでクラスに静的メソッドを追加する (companion object)",date:"2019-05-14T00:00:00+09:00",body:"Kotlinメモ: コンパニオンオブジェクトでクラスに静的メソッドを追加する (companion object) コンパニオンオブジェクトの基本 Kotlin は言語仕様上、クラスに static なフィールドを持たせることはできませんが、コンパニオンオブジェクト (companion object) の仕組みを利用すると、Java の static メソッドと同様な振る舞いを実現できます。 コンパニオンオブジェクトは、クラス本体部分で下記のように companion object を使って定義します（無名のコンパニオンオブジェクト）。 data class Book(val title: String, val price: Int) { companion object { const val FREE_PRICE = 0 fun newFreeBook(title: String) = Book(title, FREE_PRICE) } } fun main() { val book = Book.newFreeBook(&#34;Free Kotlin&#34;) println(book) //=&gt; Book(title=Free Kotlin, price=0) } companion object の後ろの {} の中は、通常のクラスの本体と同じように実装します（private なフィールドを定義することもできます）。 上記のようにコンパニオンオブジェクトを定義すると、Book クラスの中に暗黙的なシングルトンインスタンスが生成され、Book.フィールド名 という形でアクセスできるようになります。 つまり、Java の static フィールドと同じ形でアクセスできます。 正確には Java の static フィールドとは異なり、内部でコンパニオンオブジェクトと呼ばれるオブジェクトが生成されているのですが、通常はあまり気にする必要はないでしょう。 ☝️ コンパニオンオブジェクトは外側のクラスのインスタンスではない コンパニオンオブジェクトはそれ自身がクラス定義を持っており、外側で定義されたクラスのインスタンスではないことに注意してください。 Book.xxx() というアクセス方法を見ると、あたかも Book クラスのシングルトンインスタンスが作られているかのように見えますが、Book インスタンスが作られているわけではありません。 Book.xxx() という記述は、実は Book.Companion.xxx() の省略記法です。 このことからも、コンパニオンオブジェクトは、Book クラスのインスタンスとは別物であることが分かります。 コンパニオンオブジェクトに名前を付ける オブジェクト宣言でオブジェクトを生成する場合と同様、コンパニオンオブジェクトにも名前を付けることができます。 下記の例では、Book クラスのコンパニオンオブジェクトに、Factory という名前を付けています。 data class Book(val title: String, val price: Int) { companion object Factory { const val FREE_PRICE = 0 fun freeBook(title: String) = Book(title, FREE_PRICE) } } このコンパニオンオブジェクトには、Book.Factory.フィールド名 という形でアクセスすることができます。 fun main() { val book = Book.Factory.freeBook(&#34;Free Kotlin&#34;) println(book) //=&gt; Book(title=Free Kotlin, price=0) } だがしかしっ、この場合でも、Book.フィールド名 のように省略してアクセスすることが可能です。 val book = Book.freeBook(&#34;Free Kotlin&#34;) コンパニオンオブジェクトはクラス内でひとつしか定義できません。 このような仕様だと、コンパニオンオブジェクトに名前を付ける意味はあまりないように感じますね。 Java からコンパニオンオブジェクトを参照する Java のコードからコンパニオンオブジェクトにアクセスする場合は、Companion という名前の static フィールドとして参照します。 Java Book b = Book.Companion.newFreeBook(&#34;Free Kotlin&#34;); もし、コンパニオンオブジェクトに名前を付けているのであれば、Companion の代わりにその名前を使用します。 例えば、Factory という名前を付けているのであれば次のようにします。 Java Book b = Book.Factory.newFreeBook(&#34;Free Kotlin&#34;); Java のコードから、純粋な static メソッドとして Book.newFreeBook() という形で呼び出したい場合は、Kotlin 側でメソッドを定義するときに、@JvmStatic を付けて定義しておく必要があります。 Kotlin data class Book(val title: String, val price: Int) { companion object Factory { const val FREE_PRICE = 0 @JvmStatic fun newFreeBook(title: String) = Book(title, FREE_PRICE) } } Java Book b = Book.newFreeBook(&#34;Free Kotlin&#34;); コンパニオンオブジェクトでインタフェースを実装する コンパニオンオブジェクトは、多くの場合は何のインタフェースも実装しないオブジェクト定義ですが、下記のようにして何らかのインタフェースを実装したり、別のクラスを継承したりすることもできます。 interface YamlFactory&lt;T&gt; { fun create(yaml: String): T } data class Book(val title: String) { companion object : YamlFactory&lt;Book&gt; { override fun create(yaml: String): Book { // 本当は Yaml テキストをパースしてオブジェクトを生成する return Book(&#34;タイトル&#34;) } } } 上記の Book クラスのコンパニオンオブジェクトは YamlFactory&lt;Book&gt; を実装しているため、Book（あるいは Book.Companion）を YamlFactory&lt;T&gt; のインスタンスとして使用することができます。 fun &lt;T&gt; createFromYaml(factory: YamlFactory&lt;T&gt;): T { val yamlText = &#34;...&#34; return factory.create(yamlText) } fun main() { // Yaml テキストから Book インスタンスを作成する val b = createFromYaml(Book) } コンパニオンオブジェクトに拡張関数を追加する (companion-object extension) 拡張関数 (extension function) の仕組み を使用すると、クラス定義の外から、そのクラスのインスタンスメソッドを追加することができます。 コンパニオンオブジェクトに対しても、この仕組みを使ってメソッドを追加することができます。 結果的に、クラスに後付けで static メソッドを追加するようなことができます。 次の例では、Foo のコンパニオンオブジェクト Foo.Companion に、後付けで greet() 関数を追加しています。 コンパニオンオブジェクトに拡張関数を追加する場合、コンパニオンオブジェクト名の Companion を省略できないことに注意してください（省略すると、クラスへのインスタンスメソッドの追加になってしまうため）。 class Foo { companion object } fun Foo.Companion.greet() = println(&#34;Hello&#34;) fun main() { Foo.greet() //=&gt; Hello } コンパニオンオブジェクトに拡張関数を追加する場合、あらかじめ、そのクラスにコンパニオンオブジェクトが定義されている必要があります（上記のように空でも OK）。"},{url:"/p/rej4be5/",title:"Kotlinメモ: コンパニオンオブジェクトとクラス内オブジェクト宣言の違い",date:"2019-05-14T00:00:00+09:00",body:"Kotlinメモ: コンパニオンオブジェクトとクラス内オブジェクト宣言の違い コンパニオンオブジェクトは、クラスに付随するシングルトンオブジェクトとして参照できます。 また、クラス内でオブジェクト宣言を行うと、これまたシングルトンオブジェクトとして参照できます。 これらはいったい何が違うのでしょうか？ class MyClass { // 名前付きコンパニオンオブジェクト companion object Foo { fun hello() = println(&#34;Foo.hello&#34;) } // オブジェクト宣言 object Bar { fun hello() = println(&#34;Bar.hello&#34;) } } fun main() { MyClass.Foo.hello() //=&gt; Foo.hello MyClass.Bar.hello() //=&gt; Bar.hello } 一見するとまったく違いがありませんが、シングルトンオブジェクトが生成されるタイミングに微妙な違いがあります。 コンパニオンオブジェクト &hellip; 外側のクラスが参照されたときに生成される（Java の static initializer と同様） クラス内オブジェクト宣言 &hellip; そのオブジェクト自身が参照されたときに生成される 次のように、それぞれのシングルトン定義に初期化ブロック (init) を作ってやると、初期化の順序を確認することができます。 class MyClass { companion object Foo { init { println(&#34;Foo.init&#34;) } fun hello() = println(&#34;Foo.hello()&#34;) } object Bar { init { println(&#34;Bar.init&#34;) } fun hello() = println(&#34;Bar.hello()&#34;) } } fun main() { println(&#34;1&#34;) val obj = MyClass() println(&#34;2&#34;) MyClass.Foo.hello() println(&#34;3&#34;) MyClass.Bar.hello() } 実行結果 1 Foo.init 2 Foo.hello() 3 Bar.init Bar.hello() コンパニオンオブジェクトである Foo インスタンスは、外側のクラスの MyClass がインスタンス化されるときに同時に生成されています（だからコンパニオンって言うんですね）。 一方で、オブジェクト宣言された Bar オブジェクトは、Bar.hello() 関数が呼び出された時点で初めて生成されます。 このような性質があるため、クラス内で JNI の API を呼び出す場合などは、コンパニオンオブジェクトの初期化ブロック (init) が、ライブラリのロードタイミングとして適切です。 class MyClass { companion object { init { System.loadLibrary(&#34;mylib&#34;) } } // JNI の API を呼び出すコード } これは、下記のような Java の static initializer の使い方と同様です。 class MyJavaClass { static { System.loadLibrary(&#34;mylib&#34;); } // JNI の API を呼び出すコード } あと、コンパニオンオブジェクトはクラス内で 1 つまでしか定義できないという制約があります。 クラス内に複数のシングルトンオブジェクトを定義したいときは、オブジェクト宣言を使用する必要があります。"},{url:"/p/kh358jg/",title:"Kotlinメモ: by を使ったメソッド呼び出しの委譲 (class delegation)",date:"2019-05-13T00:00:00+09:00",body:"Kotlinメモ: by を使ったメソッド呼び出しの委譲 (class delegation) by による委譲とは Decorator パターンを実装したり、コレクションクラスを委譲によって拡張したいケースでは、ベースとなるインタフェースで定義されているすべてのメソッドを実装しなければいけません。 あるクラスの機能を継承なしで拡張できる一方で、拡張しなくてもよいメソッドも含めて委譲処理を実装しなければいけないのは骨の折れる作業です。 単純なボイラープレート実装があふれたコードは美しくありません。 このようなケースで利用できるのが、by によるメソッド呼び出しの委譲 (class delegation) です。 IBar インタフェースの呼び出しを bar オブジェクトへ委譲 class Foo(val bar: IBar) : IBar by bar 実装するインタフェース名に続けて by someObj と記述すると、そのインタフェースの実装を指定したオブジェクト someObj に一括で委譲することができます。 そして、必要なメソッドだけをオーバーライドすることができます。 具体的に見ていきましょう。 by による委譲処理の例 例えば、下記のような単純なログ出力クラス SimpleLogger があるとします（Decorator パターンを使って出力をカスタマイズするため、あらかじめ Logger インタフェースを定義しています）。 interface Logger { fun info(text: String) fun warn(text: String) fun error(text: String) } class SimpleLogger : Logger { override fun info(text: String) = println(text) override fun warn(text: String) = println(text) override fun error(text: String) = println(text) } この SimpleLogger クラスを Decorator パターンで拡張し、error メソッドの呼び出し時にだけ ERROR: というプレフィックスを付けて出力する ようにします。 単純に実装すると下記のようになると思います。 class EmphasizedLogger(val logger: Logger) : Logger { override fun info(text: String) = logger.info(text) override fun warn(text: String) = logger.warn(text) override fun error(text: String) = logger.error(&#34;ERROR: $text&#34;) } fun main() { val logger = EmphasizedLogger(SimpleLogger()) logger.error(&#34;Hello&#34;) //=&gt; ERROR: Hello } もちろん、これはこれで間違いではありませんが、info メソッドと warn メソッドは単純に処理を委譲しているだけで、見るからに冗長な感じがします。 このようなとき by を使用すると、あるインタフェースに関する処理を、指定したオブジェクトにまとめて委譲してしまうことができます。 下記の例では、Logger インタフェースに関する処理を、コンストラクタで渡された logger オブジェクトへ委譲しています。 ただし、error メソッドだけは、自分のクラスでオーバーライドして拡張しています。 class EmphasizedLogger(val logger: Logger) : Logger by logger { override fun error(text: String) = logger.error(&#34;ERROR: $text&#34;) } このように、by による委譲を行うことで、自分が拡張したい部分だけをコーディングすることができるようになります。 コレクションクラスを Decorator パターンで拡張する by によるメソッド呼び出しの委譲は、コレクションなどのメソッドの多いクラスを Decorator パターンで拡張するときに威力を発揮します。 下記の例では、LinkedList を拡張し、同一の値を保持しないキューである UniqueQueue クラスを実装しています。 import java.util.* class UniqueQueue&lt;T&gt;(private val innerQueue: Queue&lt;T&gt; = LinkedList&lt;T&gt;()) : Queue&lt;T&gt; by innerQueue { override fun add(element: T) = if (element in innerQueue) false else innerQueue.add(element) } fun main() { val queue = UniqueQueue&lt;Int&gt;() queue.add(1) queue.add(2) queue.add(3) queue.add(1) queue.add(2) println(queue.toList()) //=&gt; [1, 2, 3] }"},{url:"/p/d8kkspv/",title:"Kotlinメモ: シールクラスで継承可能なクラスを制限する (sealed class)",date:"2019-05-13T00:00:00+09:00",body:"Kotlinメモ: シールクラスで継承可能なクラスを制限する (sealed class) シールクラスとは クラスを定義するときに、sealed キーワードを使ってマークするとそのクラスはシールクラス (sealed class) となり、そのクラスのサブクラスとなれるクラスを制限することができます。 例えば、Screen クラスのサブクラスが、Screen.Main、Screen.ProductList しか存在しないことを明示することができます。 Kotlin はシールクラスを列挙型クラス (enum class) の強化版のようなものだと位置付けています。 enum 型は各インスタンスがシングルトンとしてのみ存在可能ですが、シールクラスのサブクラスは、シングルトンにすることもできますし、個別のインスタンスとして生成することもできます。 シールクラスは抽象クラスと同様の性質を持ちます。 デフォルトで継承可能 (open) なクラスとして定義され、abstract なメソッド、プロパティを含むことができます。 インスタンスを生成するときは、必ずサブクラスのインスタンスとして生成しなければいけません。 シールクラスの利用例 シールクラスは利用例を見たほうが理解しやすいと思います。 例えば、列挙型クラスのようなものを作りたいのだけれど、場合によってはパラメータを渡して亜種となるオブジェクトを作らなければいけない、といったケースで利用できます。 ここでは、アプリケーションの「画面状態」を示す Screen クラスを考えてみます。 画面状態には下記の種類があります。 Screen.Main &ndash; メイン画面 Screen.ProductList &ndash; 全商品のリスト画面 Screen.ProductDetail &ndash; ある商品の詳細画面（商品 ID プロパティを含む） これらが 3 つの画面状態だけを示せればよいのであれば、従来の列挙クラスで 3 つの要素を定義してやれば解決です。 問題は、3 つ目の Screen.ProductDetail が、表示対象となる商品の ID をプロパティとして保持するという点です。 つまり、Screen.ProductDetail という 1 つの画面状態だけを示せばよいのではなく、Screen.ProductDetail(1) とか、Screen.ProductDetail(2) といった異なる画面状態を表現したいということです。 このように、列挙型の個々のオブジェクトに異なるプロパティを持たせたいという場面に出くわしたら、シールクラスの出番です。 sealed class Screen { object Main : Screen() object ProductList: Screen() data class ProductDetail(val productId: Int) : Screen() } ここでは、シールクラスのサブクラスをネストして定義していますが、ネストさせる必要は必ずしもありません。 ただ、enum クラスの拡張としてシールクラスを利用するのであれば、このようにネストして定義しておいた方がわかりやすいでしょう。 上記のようにシールクラスを定義すると、Screen.Main や Screen.ProductList などのシングルトンは従来の列挙型要素のように扱うことができ、さらに、データクラスとして定義した Screen.ProductDetail には自身のプロパティとして productId を持たせることができます。 下記は、この Screen シールクラスの使用例です。 transition 関数に Screen オブジェクトを渡すと、その画面へ遷移するというユースケースを想定しています。 // 画面遷移の実装（だと過程） fun gotoMain() = println(&#34;gotoMain&#34;) fun gotoProductList() = println(&#34;gotoProductList&#34;) fun gotoProductDetail(id: Int) = println(&#34;gotoProductDetail($id)&#34;) // 渡されたスクリーンタイプによって画面遷移する fun transition(screen: Screen) { when (screen) { is Screen.Main -&gt; gotoMain() is Screen.ProductList -&gt; gotoProductList() is Screen.ProductDetail -&gt; gotoProductDetail(screen.productId) } } fun main() { val list = listOf( Screen.Main, Screen.ProductList, Screen.ProductDetail(1), Screen.ProductDetail(2) ) list.forEach { transition(it) } } 実行結果 gotoMain gotoProductList gotoProductDetail(1) gotoProductDetail(2) 上記の when 式の記述を見ると分かるように、else 節の記述が省略されています。 シールクラスを使用すると、コンパイラがすべてのサブクラス分岐をカバーできていることを把握できるようになるので、else 節によるフォールバック記述が必要なくなります。 この仕組みにより、enum 型クラスと同様、when 式での記述漏れを防ぐことができます。 （コラム）シールクラスオブジェクトのリストの先頭が null になる問題 シールクラスを使い始めた人が時々ハマる問題です。 下記のように、シールクラスで定義したオブジェクトを companion object でリスト化しようとすると、先頭の要素がなぜか null になります。 sealed class Color(rgb: String) { object R: Color(&#34;ff0000&#34;) object G: Color(&#34;00ff00&#34;) object B: Color(&#34;0000ff&#34;) companion object { val AvailableColors = listOf(R, G, B) } } fun main() { println(Color.R) println(Color.AvailableColors) } Color$R@2a84aee7 [null, Color$G@452b3a41, Color$B@4a574795] これは、オブジェクト初期化時の循環参照が原因になっており、現状は次のように遅延初期化することで解決できます。 companion object { val AvailableColors by lazy { listOf(R, G, B) } } Color$R@2a84aee7 [Color$R@2a84aee7, Color$G@452b3a41, Color$B@4a574795] この話は、stack overflow でもたまに取り上げられます 。 参考 継承可能なクラスを作成する (open, abstract, override)"},{url:"/p/fc4unhr/",title:"Kotlinメモ: データクラスを定義する (data class)",date:"2019-05-13T00:00:00+09:00",body:"Kotlinメモ: データクラスを定義する (data class) データクラスとは Kotlin で単純なプロパティを保持するだけのクラスは、下記のように簡単に定義することができます。 class Book(val title: String, val price: Int) これだけでも十分便利ですが、さらに data キーワードを付けることにより、そのクラスはデータクラスとして定義されます。 data class Book(val title: String, val price: Int) データクラスとして定義すると、プライマリ・コンストラクタで定義したフィールドを扱う、下記のようなメソッドが内部で自動生成されます。 fun toString() : String &hellip; オブジェクトの文字列表現を返す fun equals(other: Any?) : Boolean &hellip; オブジェクトの同一性を判断する fun hashCode() : Int &hellip; コレクションクラスなどが利用するハッシュ値を返す fun copy(...) : T &hellip; オブジェクトのコピーを生成する Java では、これらのメソッドを IDE などの力を借りるなどしてコードの形で実装する必要がありましたが、Kotlin では、クラス定義の先頭に data キーワードを付加するだけです。 ボイラープレート的なコードを記述する必要がないので、コードをシンプルに保つことができます。 データクラスのオブジェクトは、そのまま println でわかりやすい表現で出力できるようになり、ハッシュ系のコレクションに追加できるようになります。 下記のサンプルでは、データクラスの println が正しく動作していること、HashSet への格納が正しくできていることを確認しています。 data class Book(val title: String, val price: Int) fun main() { val b = Book(&#34;Kotlin入門&#34;, 1000) println(b) //=&gt; Book(title=Kotlin入門, price=1000) val set = hashSetOf( Book(&#34;T1&#34;, 100), Book(&#34;T1&#34;, 100), // 同じ内容の本を追加 Book(&#34;T2&#34;, 200)) println(set.size) //=&gt; 2（内容が同一だという判断がちゃんとできている） } 注意しなければいけないのは、自動生成される実装は、プライマリ・コンストラクタで定義されたフィールドのみを扱うということです。 例えば、 data class Book(val title: String) { var price: Int = 0 } このように定義されたクラスは、equals() の比較には title フィールドの値のみが参照されます。 クラス本体部分で定義されている price プロパティの値は無視されます（price が異なっても同一とみなされる）。 equals() メソッドに price フィールドの値まで認識させるには、下記のようにパラメータ部分で val キーワードを使ってフィールド定義する必要があります。 data class Book(val title: String, val price: Int = 0) ハッシュ系のコレクションに格納する想定のデータクラスは、すべてのフィールドを val キーワードを付けて定義しておく必要があります。 キーとして扱うオブジェクトは immutable（不変）でなければならないからです。 インスタンス生成後に一部のフィールドだけを変更したい場合は、データクラスが提供する copy() メソッドを使用できます（後述）。 データクラスによる toString メソッドの実装 データクラスによって自動生成される toString は、すべてのフィールドの値を定義順に出力します。 下記のサンプルは、通常のクラスとして定義した Book1 クラスと、data キーワードを付けて定義したクラス Book2 クラスのインスタンスをそれぞれ println に渡した場合の出力結果の違いを示しています。 class Book1(val title: String, val price: Int) data class Book2(val title: String, val price: Int) fun main() { val b1 = Book1(&#34;Title1&#34;, 1000) val b2 = Book2(&#34;Title2&#34;, 2000) println(b1) //=&gt; Book1@60e53b93 println(b2) //=&gt; Book2(title=Title2, price=2000) } 通常クラス Book1 の方の toString のデフォルト実装は、クラス名@ハッシュ値 というあまり役に立たない文字列を返していることが分かります。 一方、データクラスとして定義した Book2 の方の出力は、各フィールドの値までわかりやすく表示されています。 内部的に次のように実装されているのと同様の振る舞いをします。 class Book2(val title: String, val price: Int) { override fun toString(): String { return &#34;Book2(title=$title, price=$price)&#34; } } この仕組みは、フィールドとしてリストや配列を持っていたり、他のクラスのオブジェクトを含んでいる場合もうまく働きます（深い階層まで処理してくれる）。 次の Book クラスは、フィールドとして String のリスト、独自クラスのオブジェクトを持っています。 import java.net.URI data class WebSite(val uri: URI, val title: String) data class Book(val title: String, val authors: List&lt;String&gt;, val site: WebSite) fun main() { val book = Book(&#34;タイトル&#34;, listOf(&#34;まく&#34;, &#34;へむ&#34;), WebSite(URI.create(&#34;https://example.com/&#34;), &#34;ウェブサイト&#34;)) println(book) } 実行結果 Book(title=タイトル, authors=[まく, へむ], site=WebSite(uri=https://example.com/, title=ウェブサイト)) データクラスによる equals メソッドの実装 データクラスによって実装される equals メソッドは、プライマリ・コンストラクタで定義されたすべてのフィールドの一致をチェックするように実装されます。 まず、データクラスではない、通常クラスの equals の振る舞いを見てみます。 class Book1(val title: String, val price: Int) fun main() { val a = Book1(&#34;Title&#34;, 1000) val b = Book1(&#34;Title&#34;, 1000) println(a == b) //=&gt; false } インスタンス a と b の内容は同一なのに、equlas (==) は false を返しています。 これは、通常クラスのデフォルト実装が参照の比較を行うからです。 Java では == は参照の比較を表しますが、Kotlin では equals メソッドの呼び出しを表します。 Kotlin で参照の比較を行いたい場合は、== の代わりに === 演算子を使用してください。 下記は、data プレフィックスを付けてデータクラスとして定義した場合の振る舞いです。 data class Book2(val title: String, val price: Int) fun main() { val a = Book2(&#34;Title&#34;, 1000) val b = Book2(&#34;Title&#34;, 1000) println(a == b) //=&gt; true } データクラスの equals 実装は、フィールド値を見て同一性を判断するため、インスタンス a と b の == 演算子による比較結果は true になります。 内部的に次のように実装されているのと同様の振る舞いをします。 data class Book2(val title: String, val price: Int) { override fun equals(other: Any?): Boolean { if (other !is Book2) return false return (title == other.title) &amp;&amp; (price == other.price) } } ちなみに、equals() をオーバーライドしたら、hashCode() もオーバーライドしなければいけないのは Java と同様です。 Kotlin のデータクラスは hashCode() も自動で実装してくれます。 データクラスによる hashCode メソッドの実装 データクラスにより実装される hashCode は、プライマリ・コンストラクタで定義したフィールドの値がひとつでも異なる場合に、異なるハッシュ値を返すように実装されます。 下記は、データクラスではない、通常クラスのインスタンスを HashSet に格納しています。 class Book1(val title: String, val price: Int) fun main() { val a = Book1(&#34;Title&#34;, 1000) val b = Book1(&#34;Title&#34;, 1000) val set = hashSetOf(a) println(set.contains(b)) //=&gt; false } インスタンス a と b が保持するフィールドの値は同一なのに、set.contains() による同一性チェックがうまく動作していません。 これは、デフォルトの hashCode() メソッドが異なるハッシュ値を返してしまっているからです。 ハッシュ系のコレクションクラス（HashSet や HashMap）における要素比較は、効率化のため、まずはハッシュ値を比較して (hashCode())、等しい場合は具体的な内容を比較する (equals()) という実装になっています。 このため、基本的なルールとして、2 つのオブジェクトが等しいと見なすケースでは、equals() が true を返し、かつ hashCode() が同じ値を返すように実装しなければいけません。 クラス定義時に data キーワードを付けてデータクラスとして定義すると、プライマリ・コンストラクタで定義したすべてのフィールドの同一性を考慮した equals() と hashCode() が自動生成されます。 下記の Book2 クラスはデータクラスとして定義されているので、HashSet に格納したときにも正しく動作しています。 data class Book2(val title: String, val price: Int) fun main() { val a = Book2(&#34;Title&#34;, 1000) val b = Book2(&#34;Title&#34;, 1000) val set = hashSetOf(a) println(set.contains(b)) //=&gt; true } 仮に、equals() と hashCode() を自力で実装するとなると、下記のような感じになるでしょう。 class Book2(val title: String, val price: Int) { override fun equals(other: Any?): Boolean { if (other !is Book2) return false return (title == other.title) &amp;&amp; (price == other.price) } override fun hashCode(): Int { return title.hashCode() * 31 + price } } Kotlin のデータクラスを使用すれば、このような決まりきったコードを書かなくて済みます。 データクラスによる copy メソッドの実装 データクラスが提供する copy メソッドは、既存のオブジェクトをもとに、指定したフィールドの値のみを変更したオブジェクトを生成します。 この機能は、クラスを immutable（不変）な設計にするのに役立ちます。 すべてのフィールドがリードオンリーである（val 定義された）データクラスは、スレッドセーフであったり、ハッシュ系コレクションのキーとして使えたりする利点があります。 一方、インスタンスを生成した後に、特定のフィールドだけを変更したいことがあるとちょっと困ります。 このようなときに便利なのが、データクラスが自動生成する copy メソッドです。 copy メソッドは下記のような感じの実装を提供し、既存のオブジェクトから指定したプロパティのみを変更した新しいオブジェクトを生成します。 class Book(val title: String, val price: Int) { fun copy(title: String = this.title, price: Int = this.price) = Book(title, price) } このメソッドを利用すれば、すべてのフィールドをリードオンリーにしつつ、必要なときには特定のフィールドの値だけ変更する（変更したオブジェクトを作成する）ということを簡単に行えるようになります。 コピー生成のコストはかかりますが、通常はクラスを immutable にすることのメリットの方が大きいでしょう。 下記の例では、データクラスによって自動生成された copy メソッドを使って、price フィールドの値だけを変更した Book オブジェクトを生成しています。 data class Book(val title: String, val price: Int) fun main() { val a = Book(&#34;Title&#34;, 1000) val b = a.copy(price = 2000) // price フィールドのみ変更する println(a) //=&gt; Book(title=Title, price=1000) println(b) //=&gt; Book(title=Title, price=2000) } あくまで、すべてのオブジェクトは immutable（不変）であるところがポイントです。"},{url:"/p/g2bj9zs/",title:"Kotlinメモ: クラスにプロパティのアクセサメソッドを定義する (set, get)",date:"2019-05-10T00:00:00+09:00",body:"Kotlinメモ: クラスにプロパティのアクセサメソッドを定義する (set, get) カスタムアクセサとは Kotlin では、下記のようにクラスのプロパティを定義するだけで、自動的に setter/getter が生成されます。 data class Book(var title: String) val b = Book(&#34;タイトル1&#34;) b.title = &#34;タイトル2&#34; 多くの場合はこれだけで十分ですが、プロパティの値を読み書きする際に何らかの処理を行いたい場合は、プロパティのカスタムアクセサ (getter/setter) を定義する必要があります。 カスタムアクセサを定義する (set() / get()) プロパティにアクセスしたときの振る舞いは、get、set を実装することでカスタマイズできます。 下記の例では、title プロパティに対してカスタム getter、setter を定義しています。 class Book(title: String) { var title: String = title get() { println(&#34;get: $field&#34;) return field } set(value: String) { println(&#34;set: $field -&gt; $value&#34;) field = value } } print(book.title) のようにプロパティの値を参照すると get() が呼び出され、book.title = &quot;あああ&quot; のようにプロパティの値を書き換えようとすると set(value) が呼び出されます。 プロパティとして現在保持されている値は field キーワードで参照できます。 setter の実装の中では、field に値を代入することで、プロパティが保持する値を変更します。 setter が呼び出されたときに、先に field の値を参照すれば、プロパティの値を変更する前の元の値を取得できます。 例えば、下記のようにすれば、プロパティの値が実際に変更されるときのみ処理を行う ということが実現できます。 class Book(title: String) { var title: String = title set(value: String) { if (field != value) { println(&#34;値を $field から $value に変更したよ&#34;) field = value } } } val b = Book(&#34;あああ&#34;) b.title = &#34;あああ&#34; // 何も起こらない b.title = &#34;いいい&#34; //=&gt; 値を あああ から いいい に変更したよ setter のみを非公開 (private) にする getter や setter の可視性は、デフォルトではプロパティそのものの可視性と等しくなります。 public なプロパティの getter と setter のうち一方を private にしたい場合、set、get の前に private キーワードを付けます。 次の Connector クラスは、retryCount プロパティの setter を非公開にしています。 Connector クラス内からのみプロパティの値を変更することができます。 class Connector { var retryCount: Int = 0 private set fun retry() { ++retryCount } } val conn = Connector() conn.retry() conn.retry() conn.retry() println(conn.retryCount) //=&gt; 3 次の例では読み出し専用の isExpensive プロパティを定義しています。 class Book(val title: String, var price: Int) { val isExpensive: Boolean get() { return price &gt; 1000 } } // 使用例 val b = Book(&#34;Kotlin ABC&#34;, 1500) println(b.isExpensive) 上記の isExpensive の実装は、1 つの式の評価結果を return しているだけなので、expression-body の構文を使って、下記のように簡潔に記述することもできます。 val isExpensive: Boolean get() = price &gt; 1000 派生プロパティ（実体の存在しない getter/setter） プロパティの getter メソッドは、実際に値を保持する変数が存在していなくても定義することができます。 下記の読み取り専用の fullName プロパティは、実際に fullName 変数で値を保持しているわけではなく、別のプロパティ（firstName と lastName）を組み合わせた値を返すように実装しています。 getter のみを提供するプロパティは val で定義します。 class People(val firstName: String, val lastName: String) { val fullName: String get() = &#34;$firstName $lastName&#34; } fun main() { val p = People(&#34;Taro&#34;, &#34;Yamada&#34;) println(p.fullName) //=&gt; Taro Yamada } 下記の MyTime クラスは、実体としてはタイムスタンプを保持する timeStamp 変数しか持っていませんが、Date 型による getter および setter を提供しています。 import java.util.Date class MyTime(var timeStamp: Long) { var date: Date get() = Date(timeStamp) set(value) { timeStamp = value.time } } fun main() { val time = MyTime(System.currentTimeMillis()) println(time.timeStamp) //=&gt; 1569419191165 println(time.date) //=&gt; Wed Sep 25 13:46:31 UTC 2019 } このように、自分自身の値を保持しないプロパティのことを 派生プロパティ (derived property) と呼びます。 Kotlin の プロパティは Java のようなフィールドではなく、アクセッサーであり、もっと簡単に言えばただのメソッドです。 とはいえ、本質的にはプロパティの用途はオブジェクトの状態を示すものであり、複雑な処理を伴うものは通常のメソッドとして定義すべきです。 メソッドとして定義したときに setXxx()、getXxx() と命名できるようなもののみプロパティとして定義する資格があると考えましょう。"},{url:"/p/r4wcjss/",title:"Kotlinメモ: 継承可能なクラスを作成する (open, abstract, override)",date:"2019-05-10T00:00:00+09:00",body:"Kotlinメモ: 継承可能なクラスを作成する (open, abstract, override) open と override Kotlin のクラス定義を行うと、デフォルトでは継承できないようになっています。 継承可能なクラスとして定義するには、open モディファイアを付ける必要があります。 さらに、その中でオーバーライド可能なメソッドにも open モディファイアを付ける必要があります。 下記の Animal クラスは継承可能であり、cry メソッドがオーバーライドできるようになっています。 open class Animal(val name: String) { fun greet() { print(&#34;私は${name}です。&#34;) cry() } open fun cry() { println(&#34;ウー！&#34;) } } 下記の Cat、Dog クラスは Animal クラスを継承し、cry メソッドをオーバーライドしています。 オーバーライドしていることを示すために、メソッドの定義時に override キーワードを付ける必要があります。 open class Cat : Animal(&#34;猫&#34;) { override fun cry() = println(&#34;ニャー！&#34;) } open class Dog : Animal(&#34;犬&#34;) { override fun cry() = println(&#34;ワンワン！&#34;) } fun main() { Animal(&#34;動物&#34;).greet() // 私は動物です。ウー！ Cat().greet() // 私は猫です。ニャー！ Dog().greet() // 私は犬です。ワンワン！ } それ以上オーバーライドを許可しない (final) override の付いたメソッドはデフォルトで open な状態になっており、さらにその子クラスでオーバーライドすることが可能です。 これ以上のオーバーライドを禁止するには、明示的に final キーワードを付けて override する必要があります。 open class Cat : Animal(&#34;猫&#34;) { final override fun cry() = println(&#34;ニャー！&#34;) } 親クラスのコンストラクタを呼び出す (super) サブクラスのコンストラクタ呼び出しからは、間接的、あるいは直接的に親クラスのコンストラクタを呼び出す必要があります。 親クラスがパラメータなしの（自動生成された）コンストラクタしか持たない場合でも、そのパラメータなしのコンストラクタを使用するということを示すために、後ろに () を付けて呼び出しておく必要があります。 open class Parent class Child : Parent() { // ... } サブクラスがセカンダリ・コンストラクタしか持たない場合は、super キーワードを使って、親クラスのいずれかのコンストラクタを呼び出すようにすれば OK です。 open class Parent(val name: String) { constructor(dummy: Int) : this(&#34;ほげ&#34;) } class Child : Parent { constructor(name: String) : super(100) } 抽象クラスを作成する (abstract class) Kotlin でも Java と同様に、abstract キーワードを使って抽象クラスを定義することができます。 抽象クラスは 1 つ以上の抽象メソッド（実装のないメソッド）を定義することができ、このメソッドにも abstract キーワードを付けます。 abstract キーワードの付いたメソッドはオーバーライドすることを前提としているため、open を付ける必要はありません。 abstract class Parent { // オーバーライドして実装しなければいけない抽象メソッド（実装がない） abstract fun abstractMethod() // オーバーライド可能なメソッド（実装がある） open fun openMethod() = println(&#34;openMethod of Parent&#34;) // オーバーライドできない通常のメソッド fun normalMethod() = println(&#34;normalMethod of Parent&#34;) } class Child : Parent() { override fun abstractMethod() = println(&#34;abstractMethod in Child&#34;) override fun openMethod() = println(&#34;openMethod in Child&#34;) } fun main() { val obj = Child() obj.abstractMethod() //=&gt; abstractMethod in Child obj.openMethod() //=&gt; openMethod in Child } 上記のサンプルを見ると分かるように、abstract メソッドと open メソッドの使い方にほとんど差はありません。 違いは、abstract メソッドがデフォルトで実装を持っていないということです。 参考 シールクラスで継承可能なクラスを制限する (sealed class)"},{url:"/p/mngmt9c/",title:"Kotlinメモ: 文字列をデリミタ文字で分割する (split)",date:"2019-05-08T00:00:00+09:00",body:"Kotlinメモ: 文字列をデリミタ文字で分割する (split) カンマで文字列を分割する Kotlin で文字列を分割するには、Java と同様に String クラスの split メソッドを使用します。 下記は、CSV 形式の文字列（カンマ区切り文字列）をカンマで分割する例です。 val s = &#34;AAA, BBB, CCC&#34; val arr = s.split(&#34;,&#34;) println(arr) //=&gt; [&#34;AAA&#34;, &#34; BBB&#34;, &#34; CCC&#34;] カンマの前後の空白文字を削除したい場合は、分割後に trim() を全要素に対してかけてあげればよいでしょう。 val s = &#34;AAA, BBB, CCC&#34; val arr = s.split(&#34;,&#34;).map { it.trim() } println(arr) //=&gt; [&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;] 頻繁に使用する場合は、次のように String クラスに拡張関数を作ってしまうのもよいかもしれません。 /** * CSV 形式の文字列をカンマで分割します。 * 各要素の先頭・末尾の空白は削除されます。 */ fun String.parseCsv() : List&lt;String&gt; { return split(&#34;,&#34;).map { it.trim() } } // 使用例 fun main() { val arr = &#34;1, 2, 3&#34;.parseCsv() println(arr) //=&gt; [&#34;1&#34;, &#34;2&#34;, &#34;3&#34;] } 複数のデリミタ文字を指定する Kotlin は String クラスの拡張関数として、split の別バージョンを定義しています。 例えば、複数のデリミタ文字を受け取ることができるようになっているので、下記のようにしてドット (.)、あるいはカンマ (,) で分割するといった処理を簡単に記述できます。 val s = &#34;123.456,789&#34; val arr = s.split(&#34;.&#34;, &#34;,&#34;) println(arr) //=&gt; [&#34;123&#34;, &#34;456&#34;, &#34;789&#34;] ちなみに Java で同じようなことを実現しようとすると、次のように正規表現を使うことになります。 String s = &#34;123.456,789&#34;; String[] arr = s.split(&#34;\\\\.|,&#34;); for (String elem : arr) { System.out.println(elem); } Java の場合はバックスラッシュを使ってエスケープしたりとか面倒ですね。"},{url:"/p/du53m3v/",title:"Kotlinメモ: 既存のクラスに関数やプロパティを追加する（拡張関数）",date:"2019-05-08T00:00:00+09:00",body:"Kotlinメモ: 既存のクラスに関数やプロパティを追加する（拡張関数） クラスに拡張関数を追加する 拡張関数を使うと、自分で作成したクラスではなくてもメソッドを追加することができます。 例えば、Java のコアライブラリの String クラスや、Android SDK が提供するクラスなどを拡張することができます。 やりすぎると分かりにくくなってしまいますが、効果的に導入すると、簡潔で分かりやすいコードを記述できるようになります。 次の例では、String クラスに拡張関数を追加し、ある文字列が 0x あるいは 0X で始まっているかを調べる isHex メソッドを定義しています。 fun String.isHex(): Boolean = this.startsWith(&#34;0x&#34;, true) fun main() { println(&#34;0x123&#34;.isHex()) //=&gt; true println(&#34;12345&#34;.isHex()) //=&gt; false } 拡張関数の中で this を参照すると、レシーバオブジェクトを参照することができます。 つまり、s.isHex() と呼び出した場合、this はオブジェクト s を参照します。 拡張関数の実装は、普通のメソッド実装と同じ感覚で記述することができるので、拡張関数の中からメンバメソッドを呼び出すときは、通常 this を省略することができます。 よって、上記の String.isHex() 関数は下記のように記述できます。 fun String.isHex(): Boolean = startsWith(&#34;0x&#34;, true) このように、拡張関数の中から別のメンバメソッドを呼び出すことができるのですが、呼び出せるのは public なメンバメソッドだけであることに注意してください。 private メソッドや、protected メソッドを呼び出すことはできません。 これは、拡張関数を追加することによって、カプセル化されたクラス構造を破壊してしまわないようにするための Kotlin の配慮です。 Int などの基本型に拡張関数を追加する Kotlin の Int などの基本型に拡張関数を追加する場合、その値自身は this で参照することができます。 下記の例では、Int 値を 2 乗した値を返す square メソッドを Int 型に追加しています。 fun Int.square(): Int = this * this fun main() { println(20.square()) //=&gt; 400 } 拡張関数をパッケージ化する あるパッケージ内で定義された拡張関数は、パッケージのトップレベルに定義された関数と同様にインポートできます。 例えば、下記のように com.example.ext.strings パッケージで String クラスの拡張関数が定義されているとします。 StringUtil.kt package com.example.ext.strings fun String.isHex(): Boolean = startsWith(&#34;0x&#34;, true) この isHex 関数を使用するには、下記のようにトップレベルの関数をインポートするかのようにインポートします。 main.kt import com.example.ext.strings.isHex fun main() { println(&#34;0x123&#34;.isHex()) } 複数の拡張関数をインポートするときは、ワイルドカードを使ってまとめてインポートすることができます。 import com.example.ext.strings.* インポート時に as を使って、拡張関数に別名を付けることもできます。 複数のライブラリで定義された拡張関数名が衝突している場合は、この方法で解決できます。 import com.example.ext.strings.isHex as hex fun main() { println(&#34;0x123&#34;.hex()) } クラスに拡張プロパティを追加する 既存のクラスに拡張プロパティ (extension properties) を追加することもできます。 拡張関数とほぼ同様ですが、最初のキーワードが fun ではなく、val になります。 val String.lastChar: Char get() = get(length - 1) fun main() { println(&#34;ABC&#34;.lastChar) //=&gt; &#39;C&#39; } もともとフィールド（メンバ変数）としての実体のないところにプロパティを追加することになるので、必ず上記のように getter メソッドとして定義することになります（既存のフィールドの値などを参照する形で getter を実装するしかない）。 書き込み可能な拡張プロパティを定義するには、下記のように setter を実装します。 対象となるクラスは mutable（変更可能）でなければいけないので、ここでは String ではなく StringBuilder に拡張プロパティを定義していることに注意してください。 変更可能なプロパティであることを示すため、最初のキーワードは val ではなく var にします。 /** 末尾の文字を取得・設定します */ var StringBuilder.lastChar: Char get() = get(length - 1) set(value: Char) { setCharAt(length - 1, value) } fun main() { val sb = StringBuilder(&#34;ABC&#34;) sb.lastChar = &#39;X&#39; println(sb) //=&gt; &#34;ABX&#34; } コレクションクラスを拡張関数で拡張する Generics を利用して定義されたコレクションクラスにも、拡張関数を追加することができます。 下記の例では、Map インタフェースに findKey メソッドを追加して、値からキーを取得できるように拡張しています。 /** * マップ要素の値からキーを検索します。 * 見つからない場合は null を返します。 */ fun &lt;K, V&gt; Map&lt;K, V&gt;.findKey(value: V) = entries.firstOrNull { it.value == value }?.key fun main() { val map = mapOf(&#34;AAA&#34; to 100, &#34;BBB&#34; to 200, &#34;CCC&#34; to 300) println(map.findKey(100)) //=&gt; &#34;AAA&#34; println(map.findKey(777)) //=&gt; null } 特定の型の要素を持つコレクション専用の拡張関数を定義することもできます。 次の例では、String 要素を保持するコレクションに対してだけ実行できる tsv メソッドを定義しています。 /** すべての要素をタブ文字で結合した文字列を作成します。 */ fun Collection&lt;String&gt;.tsv() = joinToString(&#34;\\t&#34;) fun main() { val list = listOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) println(list.tsv()) //=&gt; &#34;A B C&#34; } Kotlin の標準ライブラリには、配列やコレクションを便利に使用するための拡張関数がいろいろ定義されています。 例えば、last() 拡張関数は、配列やコレクションの最後の要素を返します。 fun &lt;T&gt; Array&lt;out T&gt;.last(): T fun &lt;T&gt; Iterable&lt;T&gt;.last(): T fun &lt;T&gt; List&lt;T&gt;.last(): T 次のように直感的に使用できます。 val arr = intArrayOf(1, 2, 3) val list = listOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) println(arr.last()) //=&gt; 3 println(list.last()) //=&gt; &#34;C&#34; 拡張関数を Java のコードから参照する Kotlin で定義した拡張関数を Java のコードから利用する場合は、ファイル名に基づくクラス名を使用してアクセスします（トップレベルに定義した関数を Java から呼び出す場合と同様です）。 例えば、下記のように StringUtil.kt ファイル内で String クラスの拡張関数 isHex が定義されているとします。 StringUtil.kt package com.example.ext.strings fun String.isHex(): Boolean = startsWith(&#34;0x&#34;, true) この関数を Java のコードから使用する場合は、StringUtilKt.isHex という static メソッドとして参照します。 操作の対象となるレシーバオブジェクトは第一引数で渡します。 Main.java import com.example.ext.strings.StringUtilKt; public class Main { public static void main(String... args) { System.out.println(StringUtilKt.isHex(&#34;0x123&#34;)); //=&gt; true } } このように、Kotlin の拡張関数は内部的には static なメソッドとして扱われているため、拡張関数として追加したメソッドは override できないという制約があります（パラメータが異なる overload を定義することは可能）。 参考: パッケージのトップレベルに関数、プロパティ、定数を定義する 既存メソッドは拡張関数で上書きできない 既存のメソッドと同じシグネチャの拡張関数を定義した場合は、既存のメソッドの方が優先されて呼び出されます。 class Person(val name: String) { fun greet() { println(&#34;I am $name&#34;) } } // Person オブジェクトの動きを強引に変えてみる fun Person.greet() { println(&#34;Hehehe&#34;) } fun main() { val p = Person(&#34;Maku&#34;) p.greet() } 実行結果 I am Maku この動作も、既存クラスの振る舞いが破壊されないようにするための Kotlin の配慮です。"},{url:"/p/9byrmzs/",title:"Kotlinメモ: 配列やコレクションの要素をループ処理する (for-in, forEach, withIndex)",date:"2019-05-08T00:00:00+09:00",body:"Kotlinメモ: 配列やコレクションの要素をループ処理する (for-in, forEach, withIndex) 配列やリストをループ処理する (for, forEach) 配列やコレクションに格納された要素は、for や forEach を使ってループ処理することができます。 下記の例では配列の要素を for ループで処理しています。 for を使う方法 val arr = arrayOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) for (elem in arr) { println(elem) } 配列やコレクション系のクラスには forEach 拡張関数 が定義されているため、for の代わりに forEach メソッドを呼び出す形でループ処理することもできます。 ループ処理の内容はラムダ式の形 { elem -&gt; ... } で渡します。 forEach を使う方法 val list = listOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) list.forEach { elem -&gt; println(elem) } ループ処理中の要素名（イテレータ）を省略した場合は、it で参照できます。 list.forEach { println(it) } インデックス付きでループ処理する (withIndex) Kotlin には Java や C/C++ のような for (int i = 0; i &lt; n; ++i) という形式の for ループは存在しません。 配列やリストの要素をインデックス付き (0, 1, 2, &hellip;) でループ処理するには、withIndex() と組み合わせて下記のようにします。 val arr = arrayOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) for ((index, elem) in arr.withIndex()) { println(&#34;arr[$index] = $elem&#34;) } 実行結果 arr[0] = AAA arr[1] = BBB arr[2] = CCC マップ要素をループ処理する マップのキーと値も for を使ってループ処理することができます。 val map = mapOf(&#34;foo&#34; to 100, &#34;bar&#34; to 200, &#34;hoge&#34; to 300) for ((key, value) in map) { println(&#34;$key =&gt; $value&#34;) } 実行結果 foo =&gt; 100 bar =&gt; 200 hoge =&gt; 300"},{url:"/p/u8mz82t/",title:"Kotlinメモ: Kotlin のパッケージの扱い方を理解する",date:"2019-04-26T00:00:00+09:00",body:"Kotlinメモ: Kotlin のパッケージの扱い方を理解する Kotlin のパッケージの仕組みは、Java とは下記のような点で異なっています。 クラスが所属するパッケージはファイル先頭の package 宣言によってのみ決まる .kt ファイル内に複数の public クラスを定義できる .kt ファイルのファイル名はクラス名に合わせる必要はない パッケージ階層とディレクトリ階層を合わせて .kt ファイルを配置する必要はない パッケージのトップレベルに関数やプロパティを定義することができる つまり、package 宣言でパッケージ定義すること以外はほとんど自由です。 下記のように実装した main.kt ファイルは、 package com.example fun main() { println(&#34;Hello&#34;) } Java の慣例に従って、com/example/main.kt というディレクトリ階層に配置しても、プロジェクトのルートに main.kt として配置しても構いません。 Kotlin のコンパイラが意識するのは、コード内に記述した package 宣言だけです。 とはいえ、できるだけパッケージ階層とディレクトリ階層は合わせておいた方が管理しやすいと思います。 下記のように、同じ .kt ファイル内のトップレベルに、複数の public なクラスを定義することもできます。 hogegege.kt package com.example class Foo class Bar これらのクラスを参照するときは、Java と同様、次のようにインポートして使用します。 main.kt import com.example.Foo import com.example.Bar fun main() { val foo = Foo() val bar = Bar() } このようにインポートできる Foo クラス、Bar クラスが存在している場合、Java では必ず Foo.java ファイルと Bar.java ファイルが存在しますが、Kotlin の場合は必ずしも Foo.kt、Bar.kt という名前のファイルが存在しているとは限りません。 上記の例では、hogegege.kt というふざけた名前のファイルで Foo クラスと Bar クラスを定義していますが、利用する側にとってはこのファイル名を意識する必要はないので、つまり .kt のファイル名は何でもよいのです（正確には、Java コードから参照する場合はファイル名を意識する必要があります）。 また、逆に、別々の .kt ファイルで定義したクラスや関数を、同一のパッケージに所属させることもできます。 foo.kt package com.example // ... bar.kt package com.example // ... パッケージのトップレベルに関数やプロパティを定義することができるのも Kotlin の大きな特徴です。 Java で関数を定義したいときは必ず何らかのクラスのメソッドとして定義しなければいけませんが、Kotlin ではクラスの外側に関数やプロパティを定義することができます。 インポートも関数単位で行うことができます（例: import com.example.doSomething）。 トップレベルでの関数定義の詳細は、下記の記事を参照してください。 パッケージのトップレベルに関数、プロパティ、定数を定義する"},{url:"/p/tc9c9z8/",title:"Kotlinメモ: あるインスタンスがどのクラスのオブジェクトなのか調べる (javaClass)",date:"2019-04-26T00:00:00+09:00",body:"Kotlinメモ: あるインスタンスがどのクラスのオブジェクトなのか調べる (javaClass) Kotlin のあるインスタンスが、どのクラスのインスタンスかを調べるには、javaClass プロパティを使用します（Java の Object#getClass() に相当します）。 下記の例では、コレクション系のオブジェクトが、どのクラスのインスタンスなのかを調べています。 val array = arrayOf(1, 2, 3) val list = listOf(1, 2, 3) val arrayList = arrayListOf(1, 2, 3) val set = setOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) val hashSet = hashSetOf(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) val map = mapOf(&#34;A&#34; to 1, &#34;B&#34; to 2) val hashMap = hashMapOf(&#34;A&#34; to 1, &#34;B&#34; to 2) println(array.javaClass) //=&gt; class [Ljava.lang.Integer; println(list.javaClass) //=&gt; class java.util.Arrays$ArrayList println(arrayList.javaClass) //=&gt; class java.util.ArrayList println(set.javaClass) //=&gt; class java.util.LinkedHashSet println(hashSet.javaClass) //=&gt; class java.util.HashSet println(map.javaClass) //=&gt; class java.util.LinkedHashMap println(hashMap.javaClass) //=&gt; class java.util.HashMap この結果から、Kotlin のコレクション系クラスには Java の実装が用いられていることがわかります。 ちなみに、javaClass によって得られるインスタンスは、すべて java.lang.Class のインスタンスです。 println(list.javaClass.javaClass) //=&gt; class java.lang.Class インスタンスではなく、クラスの型から java.lang.Class オブジェクトを取得するには、Class名::class.java のようにします。 println(ArrayList::class.java) //=&gt; class java.lang.ArrayList"},{url:"/p/swvgt89/",title:"Kotlinメモ: コレクションの最初・最後の要素を取得する (first, last)",date:"2019-04-26T00:00:00+09:00",body:"Kotlinメモ: コレクションの最初・最後の要素を取得する (first, last) 先頭要素を取得する (first) Kotlin で配列やコレクションの先頭要素を取得するには、first() 拡張関数を使用します。 val array = arrayOf(1, 2, 3) val list = listOf(1, 2, 3) val set = setOf(1, 2, 3) println(array.first()) //=&gt; 1 println(list.first()) //=&gt; 1 println(set.first()) //=&gt; 1 配列あるいは Iterable なコレクションでなければいけないので、Map オブジェクトでは使用できません。 val map = mapOf(&#34;A&#34; to 1) println(map.first()) // NG println(map.keys.first()) // これなら OK first() のパラメータに条件式を渡すと、最初にその条件に一致する値を取り出すことができます。 例: 最初の偶数を見つける val list = listOf(5, 1, 4, 2, 3) println(list.first({ it % 2 == 0 })) //=&gt; 4"},{url:"/p/kqpvcpj/",title:"Kotlinメモ: コレクション内の最小・最大の値を見つける (min, max, minBy, maxBy)",date:"2019-04-26T00:00:00+09:00",body:"Kotlinメモ: コレクション内の最小・最大の値を見つける (min, max, minBy, maxBy) リスト内の最小値、最大値を見つける min 関数 および max 関数 を使用すると、配列やコレクション（map を除く）の中から、最小値を持つ要素、最大値を持つ要素を取り出すことができます。 val list = listOf(3, 1, 5, 2, 4) println(&#34;min = ${list.min()}, max = ${list.max()}&#34;) //=&gt; min = 1, max = 5 Comparable な要素であれば min(), max() で取り出せる 配列やコレクションから min/max 関数で要素を取り出すには、要素の比較方法が明確になっている必要があります。 もちろん数値の要素であれば問題なく min/max 関数で取り出せますが、それ以外のオブジェクトでも Comparable インタフェースさえ実装していれば、min/max 関数で取り出せるようになります。 下記の Book クラスは、Comparable インタフェースを実装しているため、コレクションに格納した後で、min/max 関数で取り出すことができます。 ここでは、price プロパティの値で大小関係を判定するように実装しています。 data class Book(val title: String, val price: Int) : Comparable&lt;Book&gt; { override fun compareTo(other: Book) = this.price - other.price } fun main() { val books = listOf( Book(&#34;Title1&#34;, 500), Book(&#34;Title2&#34;, 300), Book(&#34;Title3&#34;, 100) ) println(books.min()?.title) //=&gt; Title3 println(books.max()?.title) //=&gt; Title1 } 比較するプロパティをその都度指定する (minBy, maxBy) min/max 関数の代わりに、minBy/maxBy 関数を使用すると、関数の呼び出し時にラムダ式で比較する値を指定することができます。 例: price プロパティが最小のものを取り出す val cheapestBook = books.minBy { it.price } minBy/maxBy 関数を使用すると、Comparable でない要素を含むコレクションから（あるプロパティが）最小・最大である要素を取り出すことができます。 また、呼び出し時に比較に使用するプロパティを指定できるので、必要に応じて参照するプロパティを変えて最小値・最大値を取り出すことができます。 下記の例では、Book 要素を含むリストから、price プロパティが最小・最大の要素を取り出しています。 ここで定義している Book クラスは Comparable を実装していないので、minBy/maxBy を使い、比較に使用するプロパティをラムダ式で指定しています。 // Book クラス。Comparable インタフェースを実装してない。 data class Book(val title: String, val price: Int) fun main() { val books = listOf( Book(&#34;Title1&#34;, 500), Book(&#34;Title2&#34;, 300), Book(&#34;Title3&#34;, 100) ) val min = books.minBy { it.price } // 最安値の本を探す val max = books.maxBy { it.price } // 最高値の本を探す println(min?.title) //=&gt; Title3 println(max?.title) //=&gt; Title1 }"},{url:"/p/xgn46vo/",title:"Kotlinメモ: パッケージのトップレベルに関数、プロパティ、定数を定義する",date:"2019-04-26T00:00:00+09:00",body:"Kotlinメモ: パッケージのトップレベルに関数、プロパティ、定数を定義する トップレベル関数を定義する Java ではパッケージのトップレベルに関数を定義することはできませんでした (あるクラスの static メソッドとして定義する必要がありました) が、Kotlin ではクラスの外に関数 (プロパティ、定数) を定義することができます。 下記の例では、util.kt のトップレベルで printError 関数を定義し、それを main.kt の中から利用しています。 util.kt package com.example fun printError(message: String) { System.err.println(&#34;Error: $message&#34;) } main.kt import com.example.printError fun main() { printError(&#34;ファイルが見つかりません&#34;) } main.kt からの参照方法を見ると分かるように、Kotlin では .kt ファイルの名前は参照時に意識する必要はなく、あくまでpackage により宣言されたパッケージ名だけが参照情報として必要になります。 トップレベルに定義された関数をまとめてインポートしたいときは、下記のようなワイルドカードを使用できます。 import com.example.* トップレベル関数を private にする パッケージのトップレベルに定義した関数 (やプロパティ) は、デフォルトでは public になり、他の .kt ファイルから参照できるようになっています。 可視性を自分のファイル内に限定したい場合は、private を付けて関数を定義します。 package com.example.util // これは他のファイルからも参照できる fun greet(name: String) { println(getMessage(name)) } // これはこのファイルからしか参照できない private fun getMessage(name: String): String { return &#34;Hello, $name!&#34; } Java からどう見えるか？ kt ファイル名から Java のクラス名が生成される util.kt package com.example fun printError(message: String) { System.err.println(&#34;Error: $message&#34;) } 上記のように util.kt ファイルの中で定義した com.example パッケージの printError 関数は、Java (JVM) の世界からは com.example.UtilKt.printError のように見えます。 Java の世界ではすべてのメソッドは何らかのクラスに所属していなければいけないので、util.kt というファイル名から、自動的に UtilKt という名前のクラスが生成されるようになっています。 Main.java import com.example.UtilKt; public class Main { public static void main(String... args) { UtilKt.printError(&#34;こんにちは&#34;); } } 生成される Java のクラス名を変更する デフォルトでは .kt ファイルの名前をベースに Java クラス名が生成されますが、@JvmName アノテーションを使用すると、生成される Java クラス名を変更することができます。 util.kt @file:JvmName(&#34;LogUtil&#34;) package com.example fun printError(message: String) { System.err.println(&#34;Error: $message&#34;) } 上記の util.kt ファイルのトップレベルに定義した関数は、UtilKt ではなく、LogUtil という名前の Java クラス内に定義されます。 よって、Java のコードからは下記のように参照することになります。 Main.java import com.example.LogUtil; public class JavaMain { public static void main(String... args) { LogUtil.printError(&#34;こんにちは&#34;); } } トップレベルプロパティを定義する 関数と同様に、プロパティもパッケージのトップレベルに定義することができます。 下記の例では、util.kt ファイルのトップレベルに logPrefix というプロパティを定義しています。 util.kt package com.example var logPrefix = &#34;Error: &#34; fun printError(message: String) { System.err.println(&#34;${logPrefix}${message}&#34;) } このプロパティは、デフォルトで public なので、別の .kt ファイルから参照することができます。 下記の例では、main.kt ファイルの中から、util.kt のトップレベルプロパティの値を変更しています (var による変数定義なので値を変更できます)。 main.kt import com.example.logPrefix import com.example.printError fun main() { logPrefix = &#34;Hoge: &#34; printError(&#34;ファイルが見つかりません&#34;) } 実行結果 Hoge: ファイルが見つかりません トップレベル定数を定義する パッケージのトップレベルにプロパティを定義する際に、var ではなく const val を使用することで、トップレベルの定数として扱うことができます。 math.kt package com.example.math const val PI = 3.14 main.kt import com.example.math.PI fun main() { println(&#34;円周率は $PI だよ&#34;) } ☝️ val でなく const val で定数定義する理由 定数を定義するときに、val でなく、const val と定義することで、Java の public static final 相当のバイトコードが生成されます。 const を省略して val と記述するだけでも同様に定数として扱うことはできるのですが、その場合、Kotlin は内部で getter メソッドを生成することになります。 Kotlin のコードからアクセスするときはどちらの場合も違いはないのですが、Java のコードからアクセスするときに明らかな違いが発生します。 const val PI = 3.14 // Java からは PI という定数として見える val PI = 3.14 // Java からは getPI() というメソッドとして見える"},{url:"/p/7gfaxun/",title:"Kotlinメモ: for ループと while ループ（そして forEach）",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: for ループと while ループ（そして forEach） while ループ Kotlin の while ループ、および do-while ループは次のような形で使用します。 var i = 0 while (i &lt; 10) { print(i++) } var i = 0 do { print(i++) } while (i &lt; 10) while ループは、括弧の中の条件式が真 (true) である限りブロック内のコードを繰り返し実行します。 do-while ループも同様ですが、少なくとも一回はブロック内のコードを実行します。 Java と同様の構文なので、迷うことはないと思います。 for ループ Java にはいわゆる C/C++ 形式のループ (for (int i=0; i&lt;n; ++i)) と、for-each 形式のループ (for (int i : arr)) がありますが、Kotlin には for (xxx in yyy) の形の for ループしか存在しません。 数値範囲のループ（.. と until） Kotlin では、.. 演算子 を使用すると、数値の連番を示すことができます。 これを利用して、ある数字からある数字までのループ処理を下記のように記述することができます。 例: 1～5 のループ for (i in 1..5) { println(&#34;Count: $i&#34;) //=&gt; 1 2 3 4 5 } i in 1..n というループは、n で指定した数字まで処理されることに注意してください。 .. 演算子を使用する代わりに、until を使用して同様のループ処理を行うこともできます。 この場合、until で指定した数値の 1 つ前の数値まで処理されます。 例: 1～4 のループ for (i in 1 until 5) { println(&#34;Count: $i&#34;) //=&gt; 1 2 3 4 } つまり、こうです。 i in 1..n &hellip; 1～n の範囲でループ処理 i in 1 until n &hellip; 1～n-1 の範囲でループ処理 逆向きのループ、ステップごとの増加量（減少量）を指定 (downTo, step) until の代わりに downTo を使用すると、数値を減少させるループ処理を行うことができます。 さらに、 step を指定することで、1 ループごとの増加量（減少量）を設定することができます。 例: 10 から 0 まで -2 しながらループ処理 for (i in 10 downTo 0 step 2) { println(&#34;Count: $i&#34;) //=&gt; 10 8 6 4 2 0 } 数字と同様に、'A'..'E' とすれば、A から E までの文字範囲を示すことができます。 例: 文字 (A～E) のループ for (ch in &#39;A&#39;..&#39;E&#39;) { println(&#34;Char: $ch&#34;) //=&gt; A B C D E } 配列やコレクション要素のループ処理 for ループで要素を列挙する for は配列やコレクションの要素をループ処理するときにも使用できます。 下記の例ではリストの要素を順番にループ処理しています。 val arr = arrayOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) // listOf(...) でも同様 for (elem in arr) { println(elem) } リストの要素をインデックス付き (0, 1, 2, &hellip;) でループ処理するには、withIndex() と組み合わせて下記のようにします。 val arr = arrayOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) for ((index, elem) in arr.withIndex()) { println(&#34;arr[$index] = $elem&#34;) } 実行結果 arr[0] = AAA arr[1] = BBB arr[2] = CCC マップのキーと値も for でループ処理できます。 val map = mapOf(&#34;foo&#34; to 100, &#34;bar&#34; to 200) for ((key, value) in map) { println(&#34;$key =&gt; $value&#34;) } ちなみに、上記のように、ループ中に 2 つの変数 (key、value) に代入しながら処理できるのは、Kotlin の 分解宣言 (destructuring declarations) の仕組みのおかげです。 forEach 関数で要素を列挙する ここまでは、主に for を使ったループ処理について説明してきましたが、配列やコレクションのループ処理は forEach を使うことで簡潔に記述することができます。 val arr = arrayOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) arr.forEach { println(it) } val map = mapOf(&#34;foo&#34; to 100, &#34;bar&#34; to 200) map.forEach { key, value -&gt; println(&#34;$key =&gt; $value&#34;) } for ループか forEach か Kotlin にはループ構文として for ループが用意されていますが、Iterable なオブジェクトでは forEach という関数を使用することができます。 たとえば、数値のループは次のどちらの方法でも記述できます。 for (i in 0..5) { print(i) } //=&gt; 012345 (0..5).forEach { print(it) } //=&gt; 012345 大きな違いは、for ループが構文として後ろのブロックを繰り返し実行しているのに対し、forEach 関数は渡したラムダ式を繰り返し呼び出しているということです。 この違いは、次のように { } の内部で break したいときに顕著になります。 for (i in 0..10) { print(i) if (i == 3) break } //=&gt; 0123 (0..10).forEach { print(it) if (it == 3) return@forEach } //=&gt; 012345678910 for ループの場合は、直感的に break でループ処理を中断できますが、forEach 関数の方は、そもそもループ構文ではないので break が使えません。 苦肉の策で、上記のように return@forEach としてもループ処理は止まりません。 なので、このようにループ内でループ制御を行いたい場合は、for ループ構文の方を使うべきです。 コレクション（リストなど）のループ処理も、for と forEach どちらでも記述できます。 var list = listOf(&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;) for (elem in list) { println(elem) } list.forEach { println(it) } あまり違いがないように見えますが、次のような理由により、コレクションのループは forEach を使った方がよさそうです。 新しい変数を定義しなくてよい（上記の例では elem） タイプ数が少ない 速度的に有利っぽい（Sequence を扱う場合も同様に高速） Iterable なオブジェクトを受け取ってチェイン記述できる 最後のチェインというのは、例えば次のようにリストの要素をフィルタして取り出したい場合に、ドット (.) でつなげて簡潔に書けるということです。 var nums = 1..10 nums.filter { it % 2 == 0 }.forEach { println(it) } こういったことをやりたいときに for ループを使おうとすると、構文上、分断された形の記述になってしまいます。 var nums = 1..10 var filtered = nums.filter { it % 2 == 0 } for (x in filtered) { println(x) }"},{url:"/p/9557oxs/",title:"Kotlinメモ: immutable なコレクションと mutable なコレクション (List, Set, Map)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: immutable なコレクションと mutable なコレクション (List, Set, Map) Kotlin で immutable なリストを生成するときは listOf、mutable なリストを生成するときは mutableListOf を使って生成していると思います。 ここでは、Kotlin がどのように immutable なリスト、mutable なリストを使い分けているかを説明します。 内部的な仕組みを知らなくてもあまり困ることはありませんが、全体像を把握しておくことで自信を持ってコレクション系の API を扱えるようになると思います。 Collection と MutableCollection Kotlin のコレクション系オブジェクト（List、Set、Map オブジェクトなど）にアクセスするときは、リードオンリーでアクセスするのか、編集用にアクセスするのかによってインタフェースが使い分けられます。 要素を参照するだけであれば、Collection インタフェースを使用し、要素の追加や削除が必要な場合は MutableCollection インタフェースを使用します。 kotlin.collections.Collection インタフェース size、iterator、contains など、要素を参照するためのインタフェースのみを備える。 kotlin.collections.MutableCollection インタフェース Collection インタフェースを継承したインタフェース。 add、remove、clear など、要素を追加・削除するためのインタフェースを備える。 下記の addAll 関数は、2 つのコレクションをパラメータで受け取りますが、1 つ目のパラメータ src は参照用 (immutable) に使用され、2 つ目のパラメータ dst は内部で変更される (mutable) ことを示しています。 /** * [src] のすべての要素を [dst] の末尾に追加します。 */ fun &lt;T&gt; addAll(src: Collection&lt;T&gt;, dst: MutableCollection&lt;T&gt;) { for (e in src) { dst.add(e) } } fun main() { val src: List&lt;Int&gt; = listOf(100, 200, 300) // リードオンリー val dst: MutableList&lt;Int&gt; = mutableListOf(400, 500, 600) // 編集可能 addAll(src, dst) println(src) //=&gt; [100, 200, 300] println(dst) //=&gt; [400, 500, 600, 100, 200, 300] } リードオンリーな Collection オブジェクトを MutableCollection として渡そうとすると、Type mismatch のビルドエラーになります。 val src: List&lt;Int&gt; = listOf(100, 200, 300) val dst: List&lt;Int&gt; = listOf(400, 500, 600) // 下記はエラーになる // Type mismatch: inferred type is List&lt;Int&gt; but MutableCollection&lt;Int&gt; was expected addAll(src, dst) 3 大コレクション (List、Set、Map) の全体像 Kotlin では、List や Set、Map などの基本的なコレクションインタフェースはリードオンリーなインタフェースとして定義されており、それぞれ編集可能なインタフェースとして MutableList、MutableMap、MutableSet インタフェースを用意しています。 コレクションオブジェクト生成のための関数 これらのコレクションオブジェクトを生成するための、xxxOf() という形のユーティリティ関数が用意されており、およそ下記のような継承関係になっています。 多くの場合は、ハイライトされている、基本の 6 種類のオブジェクトを生成する関数で事足りるでしょう。 List (read-only): listOf() MutableList (mutable): mutableListOf() ArrayList (mutable): arrayListOf() Set (read-only): setOf() MutableSet (mutable): mutableSetof() HashSet (mutable): hashSetOf() LinkedHashSet (mutable): linkedSetOf() java.util.SortedSet (mutable): sortedSetOf() Map (read-only): mapOf() MutableMap (mutable): mutableMapOf() HashMap (mutable): hashMapOf() LinkedHashMap (mutable): linkedMapOf() java.util.SortedMap (mutable): sortedMapOf() 注意しなければいけないのは、listOf() や setOf() によって実際に生成されるオブジェクトは、従来の Java 実装によるコレクションインスタンスかもしれないということです。 つまり、read-only なのはあくまでインタフェースだけであり、その背後で操作しているオブジェクトは mutable（可変）かもしれないということです。 Java の java.util.Collection との互換性 Java の java.util.Collection オブジェクトをパラメータに取るメソッドには、Kotlin の Collection および MutableCollection オブジェクトのいずれも渡すことができます。 Kotlin の Collection インタフェースは read-only を示すインタフェースですが、要素を変更可能な Java の java.util.Collection オブジェクトとして渡せてしまいます。 これは、Kotlin の Collection オブジェクトが、実質的には immutable（不変）ではないということを示しています。 val list: List&lt;Int&gt; = listOf(1, 2, 3, 4, 5) // immutable な List を作成しているつもり java.util.Collections.reverse(list) // mutable な java.util.List として渡せてしまう println(list) //=&gt; [5, 4, 3, 2, 1] ちなみに、上記のように配列やコレクションの要素を逆順にしたい場合は Kotlin の reverse 関数を使いましょう。 Kotlin では下記のように書くのが正解です。 val list: MutableList&lt;Int&gt; = mutableListOf(1, 2, 3, 4, 5) list.reverse() println(list) //=&gt; [5, 4, 3, 2, 1] この場合は、もちろん mutable な MutableList に対してしか実行できないようになっています。"},{url:"/p/4ycigqq/",title:"Kotlinメモ: ある値がコレクションに含まれているか調べる (in)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: ある値がコレクションに含まれているか調べる (in) Kotlin のコレクションに、特定の要素が含まれているかを調べるには in を使用します。 下記の例では、Set&lt;String&gt; コレクションの中に特定の文字列 &quot;banana&quot; が要素として含まれているかを調べています。 Set にある値が含まれているか val set = setOf(&#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;) if (&#34;banana&#34; in set) { println(&#34;バナナ発見！&#34;) } 上記は Set の例ですが、List でも Map でも同様に調べることができます。 List にある値が含まれているか val list = listOf(&#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;) if (&#34;banana&#34; in list) { println(&#34;バナナ発見！&#34;) } Map にある値が含まれているか val map = mapOf(&#34;apple&#34; to 1, &#34;banana&#34; to 2, &#34;orange&#34; to 3) if (&#34;banana&#34; in map) { println(&#34;バナナ発見！&#34;) } ちょっと変わった例として、.. を使って定義した範囲の中に、ある値が含まれているかを調べるときにも in を使うことができます。 val num = 5 if (num in 1..10) { println(&#34;1～10 の中にあるよ&#34;) } val ch = &#39;H&#39; if (ch in &#39;A&#39;..&#39;Z&#39;) { println(&#34;A～Z の中にあるよ&#34;) } in の否定形の !in を使うと、配列やコレクションに、指定した値が含まれていない ことを調べることができます。 if (&#34;lemon&#34; !in fruits) { // レモンが含まれていない場合 }"},{url:"/p/ep23xid/",title:"Kotlinメモ: インタフェースを定義する (interface)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: インタフェースを定義する (interface) インタフェースの基本 Kotlin でのインタフェース定義は、Java と同様に interface キーワードを使用します。 下記の例では、Command インタフェースを定義し、それを GreetCommand クラスと ExplodeCommand クラスが実装しています。 interface Command { fun execute() } class GreetCommand(val name: String) : Command { override fun execute() = println(&#34;Hi, $name&#34;) } class ExplodeCommand : Command { override fun execute() = println(&#34;Boom!&#34;) } fun executeAllCommands(commands: List&lt;Command&gt;) { commands.forEach { it.execute() } } fun main() { val commands = listOf( GreetCommand(&#34;Maku&#34;), GreetCommand(&#34;Hemu&#34;), ExplodeCommand()) executeAllCommands(commands) } 実行結果 Hi, Maku Hi, Hemu Boom! インタフェースのメソッドはオーバーライドされることを前提としているため、fun の前に open を付ける必要はないことに注意してください。 オーバーライドする側のメソッドには override を付ける必要があります（Java のような @Override アノテーションは使いません）。 インタフェースの継承 インタフェースは他のインタフェースを継承することができます。 interface Command { fun execute() } interface UndoableCommand : Command { fun undo() } インタフェース（およびクラス）は、複数のインタフェースを継承（および実装）することができます。 下記の DrawCommand クラスは、Command インタフェースと Undoable インタフェースを実装しています。 interface Command { fun execute() } interface Undoable { fun undo() } class DrawCommand: Command, Undoable { override fun undo() { // ... } override fun execute() { // ... } } あるオブジェクトが特定のインタフェースを継承しているかどうかを調べるには、is を使って、if (obj is InterfaceName) のように記述します。 下記の例では、リストに含まれている要素が Number であるかをひとつずつチェックしています。 fun printAllNums(maybeNumbers: List&lt;Any&gt;) { for (e in maybeNumbers) { if (e is Number) { println(e) } } } fun main() { val list = listOf(100, &#34;AAA&#34;, 200, &#34;BBB&#34;) printAllNums(list) //=&gt; 100 200 } マーカーインタフェース Java の Serializable インタフェースなどは、メソッドを何も持っていないマーカーインタフェースです。 Kotlin では、マーカーインタフェースは下記のようにシンプルに定義できます。 interface MyMarker あるオブジェクトがマーカーインタフェースを持っているかを調べるには、is キーワードを使用します。 fun checkMarker(obj: Any) { if (obj is MyMarker) { println(&#34;MyMarker を実装しています&#34;) } } fun main() { class MyClass : MyMarker checkMarker(MyClass()) } インタフェースのデフォルト実装 Kotlin のインタフェースは、Java8 のインタフェースのデフォルトメソッドと同様に、デフォルトの実装を持つことができます。 下記の Command インタフェースの help メソッドはデフォルト実装を持っています。 interface Command { fun execute() fun help() = println(&#34;No help exists&#34;) } class MyCommand : Command { override fun execute() = println(&#34;I am MyCommand&#34;) } fun main() { val a = MyCommand() a.execute() //=&gt; I am MyCommand a.help() //=&gt; No help exists } Java でインタフェースにデフォルト実装を持たせるときは default キーワードが必要でしたが、Kotlin では通常のメソッドと同様に定義するだけで OK です。 デフォルト実装の衝突の回避 インタフェースのデフォルト実装が可能になるということは、実装の多重継承ができることと同等の意味を持ちます。 これは、実装の衝突という問題を生みます。 下記は、2 つのインタフェースが、同じ help という名前のデフォルト実装を持つ例です。 interface Menu { fun help() = println(&#34;Menu.help&#34;) } interface Command { fun help() = println(&#34;Command.help&#34;) } class FileOpenMenu : Menu, Command { // コンパイルエラー！ } FileOpenMenu クラスは help() のデフォルト実装を使おうとしますが、Menu.help() を呼び出せばいいのか、Command.help() を呼び出せばいいのか判断できないため、上記のコードはコンパイルエラーになります。 次のように、自分自身でオーバーライドしてしまえば問題ありません。 class FileOpenMenu : Menu, Command { override fun help() = println(&#34;FileOpenMenu.help&#34;) } どちらかのデフォルト実装をそのまま呼び出したい場合は、super キーワードを使って次のように記述します。 class FileOpenMenu : Menu, Command { override fun help() = super&lt;Menu&gt;.help() } デフォルト実装を呼び出す位置に制約はないので、次のようにして両方のデフォルト実装を呼び出してしまうこともできます。 class FileOpenMenu : Menu, Command { override fun help() { super&lt;Menu&gt;.help() super&lt;Command&gt;.help() } } インタフェースで抽象プロパティを定義する Kotlin のインタフェースには抽象プロパティ (abstract property) を持たせることができます（Kotlin のプロパティは実質 getter と setter メソッドの省略記法なので、当然といえば当然ですが）。 下記の Book クラスは、description という抽象プロパティを定義しています。 interface Book { val description: String } このインタフェースには、description プロパティが示す実体は存在しないことに注意してください。 このインタフェースを実装するクラスで、description プロパティを実装 (override) する必要があります。 下記のようにパラメータでプロパティの実体を定義してしまってもよいし、 class RealBook(override val description: String) : Book 下記のように getter メソッドを用意しても OK です。 class RealBook(bookId: Int) : Book { override val description: String get() = getBookDescription(bookId) } コラム: インタフェースの実装とクラスの継承の見分け方 Java では、インタフェースの実装には implements、クラスの継承には extends というように、キーワードを使い分けていました。 一方、Kotlin では、どちらも非常に似たような文法を使用します。 class Foo : MyInterface &hellip; インタフェースの実装 class Bar : Parent() &hellip; クラスの継承 見分けるポイントは、後ろに括弧 () があるかないかです。 クラスを継承する場合は、親クラスのコンストラクタを指定するための括弧が必要になります。 パラメータを取らないプライマリ・コンストラクタを呼び出す場合は、上記のように空の括弧 () を指定することになります。 下記は、インタフェースの実装と、クラスの継承を同時に行うクラスの実装例です。 interface Command { fun execute() } open class Parent { open fun hello() = println(&#34;Parent&#34;) } class Child : Command, Parent() { override fun execute() = println(&#34;Child.execute&#34;) override fun hello() = println(&#34;Child.hello&#34;) } Child クラスの定義に着目してください。 インタフェースの実装を示す部分 (Command) には括弧がついておらず、クラスの継承を示す部分 (Parent()) には括弧がついています。"},{url:"/p/4qqytis/",title:"Kotlinメモ: クラスを定義する (class)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: クラスを定義する (class) クラス定義の基本 Kotlin のクラス定義は Java と同様に class キーワードを使用しますが、デフォルトで public final 扱いという違いがあります。 これは、多くのケースで public の方が都合がよいことと、意図しない継承を防ぐことを意図した仕様です。 デフォルトでは全クラスからアクセス可能 (public) デフォルトでは継承できない (final) 次の Book クラスは、リードオンリーな title プロパティ持つ、シンプルなクラスの実装例と使用例です。 リードオンリーなプロパティを持つクラス class Book(val title: String) val b = Book(&#34;Title1&#34;) println(b.title) //=&gt; Title1 詳しくは後述しますが、Kotlin にはメソッドを簡潔に記述するための仕組みがたくさん用意されています。 メソッド実装などの記述が必要ない場合は、上記のようにクラス本体部分を示す { } ブロックすら省略して記述することができます。 Java とは異なり、コンストラクタを呼び出すときの new キーワードも省略できます（というより new は存在しません）。 上記は title プロパティをリードオンリー (val) として定義していますが、プロパティの値を書き換え可能にするには、val を var に置き換えるだけで済みます。 書き換え可能なプロパティを持つクラス class Book(var title: String) val b = Book(&#34;Title1&#34;) b.title = &#34;Title2&#34; println(b.title) //=&gt; Title2 上記のように b.title という形で title フィールドにアクセスできるのは、内部で getter/setter メソッドが定義されて呼び出されているからです。 title フィールドそのものが public になっているわけではなく、あくまで public な getter/setter メソッドが暗黙的に呼び出されています。 この Book クラスを Java のコードから使用する場合、title フィールドへのアクセスは、b.getTitle()、b.setTitle(&quot;...&quot;) のように記述することになります。 コンストラクタを定義する コンストラクタは 2 種類ある Kotlin のクラスのコンストラクタには、プライマリ・コンストラクタ (primary constructor) とセカンダリ・コンストラクタ (secondary constructor) の 2 種類があります。 プライマリ・コンストラクタ インスタンス生成時に必ず呼び出されるコンストラクタ。class 本文の外で定義する。 セカンダリ・コンストラクタ コンストラクタのバリエーション。プライマリ・コンストラクタが定義されている場合、セカンダリ・コンストラクタから直接的、あるいは間接的にプライマリ・コンストラクタを呼び出す必要がある（プライマリ・コンストラクタはいかなる場合にも呼び出される）。class 本文で定義する。 例えば、プライマリ・コンストラクタと、セカンダリ・コンストラクタを 2 つ持つクラスがあった場合、コンストラクタの呼び出しは下記のような感じで、プライマリ・コンストラクタによる初期化が起点となってオブジェクトの構築が行われます。 コード上はセカンダリ・コンストラクタからプライマリ・コンストラクタを呼び出しているかのように見えるかもしれませんが、あくまで実行順序はプライマリ・コンストラクタが先です。 プライマリ（＋初期化ブロック） プライマリ（＋初期化ブロック） → セカンダリA プライマリ（＋初期化ブロック） → セカンダリA → セカンダリB 上記のセカンダリ・コンストラクタの説明では、「バリエーション」という言葉を使いましたが、コンストラクタのパラメータとしてデフォルト引数の仕組みが使えるので、プライマリ・コンストラクタだけでもある程度の生成の「バリエーション」を持たせることは可能です。 プライマリ・コンストラクタと初期化ブロック プライマリ・コンストラクタは、インスタンスの生成時に必ず呼び出されます。 省略記法がいろいろありますが、一番冗長な書き方から順番に見ていきます。 プライマリ・コンストラクタが受け取るパラメータは、クラス名の後ろに続けて constructor(...) という形で宣言します。 プライマリ・コンストラクタが呼び出されると、(1) プロパティの定義部分 (property initializer)、(2) init で囲まれた初期化ブロック (initializer block) が順番に実行されます。 (1) と (2) の中では、プライマリ・コンストラクタに渡されたパラメータを直接参照することができます。 下記の Book クラスは、プライマリ・コンストラクタで 1 つの値を受け取り、それをリードオンリーなプロパティとして保持しています。 class Book constructor(title: String) { // (1) プロパティ定義 (property initializer) val title: String // (2) 初期化ブロック (initializer block) init { this.title = title } } // 使用例 val b = Book(&#34;タイトル&#34;) println(b.title) この例のように、初期化ブロック内で単純なプロパティ代入しか行っていない場合は、初期化ブロック (init) の記述を省略して、プロパティの定義部分で値の設定まで済ませてしまうことができます。 プロパティ定義部分では型推論が働くので、型の指定を省略することができます。 class Book constructor(title: String) { val title = title } さらに、プライマリ・コンストラクタに、アノテーションや可視性の指定がない場合は、constructor キーワードを省略することができます。 class Book(title: String) { val title = title } さらに、パラメータで受け取った値を、プロパティの定義部分で単純に代入しているだけであれば、パラメータ名の前に val、あるいは var キーワードを付けることによって、パラメータとプロパティの定義を同時に行ってしまうことができます。 val を付けた場合はリードオンリーなプロパティとなり、コンストラクタで設定された値から変更することができなくなります。 最終的に Book クラスは下記のようにシンプルに記述できることになります。 class Book(val title: String) コンストラクタの（パラメータの）定義を省略した場合は、パラメータを取らないプライマリ・コンストラクタが自動的に生成されます。 class Book { var title: String = &#34;Unknown&#34; init { println(&#34;初期化ブロックはいつでも書けるよ&#34;) } } val b = Book() b.title = &#34;ぴよぴよ&#34; println(b.title) //=&gt; ぴよぴよ デフォルト値と名前付き引数 コンストラクタのパラメータには、デフォルト値を持たせることができます（通常の関数と同様です）。 下記の例では、2 つのパラメータにデフォルト値を設定しています。 class Book(val title: String = &#34;無題&#34;, val author: String = &#34;著者不明&#34;) { override fun toString() = &#34;$title, $author&#34; } コンストラクタの呼び出し時に引数を省略すると、デフォルト値として指定した値が使用されます。 println(Book()) //=&gt; 無題, 著者不明 println(Book(&#34;ああ&#34;)) //=&gt; ああ, 著者不明 println(Book(&#34;ああ&#34;, &#34;まく&#34;)) //=&gt; ああ, まく また、コンストラクタに引数を渡す時に パラメータ名=値 という形で指定すると、任意の順序でパラメータを指定することができます （名前付き引数）。 println(Book(author = &#34;まく&#34;, title=&#34;ああ&#34;)) //=&gt; ああ, まく 型が同じパラメータが複数ある場合、名前付き引数の仕組みを使うと、引数の順番を間違えるといったミスを防ぐことができます。 セカンダリ・コンストラクタ プライマリ・コンストラクタだけではカバーしきれないような、パラメータのバリエーションを持たせたい場合は、セカンダリ・コンストラクタ (secondary constructor) を定義します。 Kotlin にはデフォルト値や名前付き引数の仕組みがあるので、多くの場合はプライマリ・コンストラクタだけで十分ですが、フレームワークで定義されているクラスを継承するようなケースで必要になったりします（親クラスのコンストラクタに合わせてパラメータ定義する必要があったりするため）。 セカンダリ・コンストラクタは、クラス本体部分で constructor キーワードを使って定義します。 下記の Indenter クラスは、テキストの前にインデントを入れて出力するためのクラスです。 コンストラクタで渡した文字数分のスペース、あるいは、渡された文字列そのものをインデントとして出力します。 パラメータに応じて異なる初期化処理を行う必要があるため、2 つのセカンダリ・コンストラクタを作成して、それぞれの初期化処理を定義しています。 class Indenter { val text: String constructor(size: Int) { text = &#34; &#34;.repeat(size) } constructor(text: String) { this.text = text } fun puts(message: String) { println(&#34;$text$message&#34;) } } fun main() { Indenter(4).puts(&#34;Hello&#34;) //=&gt; &#34; Hello&#34; Indenter(&#34;----&#34;).puts(&#34;Hello&#34;) //=&gt; &#34;----Hello&#34; } 上記のように、パラメータ付きのセカンダリ・コンストラクタのみを定義した場合、パラメータなしのプライマリ・コンストラクタが自動生成されることはありません。 Indenter() // NG（パラメータなしのコンストラクタはない） プライマリ・コンストラクタとセカンダリ・コンストラクタの両方を定義する場合、セカンダリ・コンストラクタから this を使って、間接的、あるいは、直接的にプライマリ・コンストラクタを呼び出しておく必要があります。 プライマリ・コンストラクタはいかなる場合にも呼び出されるからです。 下記の例では、Int 値を受け取るセカンダリ・コンストラクタから、String 値を受け取るプライマリ・コンストラクタを呼び出しています（実装部分は空なので後ろの {} を省略しています）。 class Indenter(val text: String) { // プライマリ・コンストラクタを呼び出す constructor(size: Int) : this(&#34; &#34;.repeat(size)) } this キーワードは、プライマリ・コンストラクタの呼び出しだけでなく、別のセカンダリ・コンストラクタの呼び出しにも使用できます。 下記の例では、1 つ目のセカンダリ・コンストラクタから、2 つ目のセカンダリ・コンストラクタを呼び出しています。 結果的にプライマリ・コンストラクタの呼び出しにつながるため、このようなコンストラクタ定義も正しいものとなります（これを「間接的」なプライマリ・コンストラクタの呼び出しと呼んでいます）。 class Indenter(val text: String) { // 別のセカンダリ・コンストラクタを呼び出すセカンダリ・コンストラクタ constructor(size: Int) : this(size, &#34; &#34;) // プライマリ・コンストラクタを呼び出すセカンダリ・コンストラクタ constructor(size: Int, text: String) : this(text.repeat(size)) } セカンダリ・コンストラクタを呼び出した場合でも、先にプライマリ・コンストラクタの処理が実行されることに注意してください。 下記のような順番で実行されていきます。 プライマリ・コンストラクタによるフィールドの初期化 初期化ブロック (init) セカンダリ・コンストラクタの本文部分 下記のようなテストコードを実行してみれば、処理の流れを理解できると思います。 class Book(title: String) { // (1) プライマリ・コンストラクタによるフィールドの初期化 val title = title var author = &#34;作者不明&#34; // (2) プライマリ・コンストラクタの初期化ブロック init { println(&#34;---- init ----&#34;) println(author) } // (3) セカンダリ・コンストラクタの中身は最後に実行される constructor(title: String, author: String) : this(title) { println(&#34;---- secondary ----&#34;) println(this.author) this.author = author } } fun main() { // セカンダリ・コンストラクタを呼び出し val b = Book(&#34;タイトル&#34;, &#34;まく&#34;) println(&#34;---- main ----&#34;) println(b.author) //=&gt; 作者 } 実行結果 ---- init ---- 作者不明 ---- secondary ---- 作者不明 ---- main ---- まく データクラスにセカンダリ・コンストラクタを定義する場合は、データクラスによって自動生成されるコードが、プライマリ・コンストラクタで定義されたフィールドのみを参照するという点に注意してください。 そもそも、セカンダリ・コンストラクタのパラメータでフィールドを定義することはできませんが、セカンダリ・コンストラクタ内の実装で、クラス本体部分で定義したフィールドを初期化するということをやってしまいがちです。 クラスが保持するべき値は、できるだけプライマリ・コンストラクタのパラメータとしてフィールド定義してしまうのが安全です。 データクラスに関する詳しい説明は下記を参照してください。 参考: データクラスを定義する (data class) コンストラクタの private 化 プライマリ・コンストラクタをクラスの外部から呼び出せないようにするには、constructor の前に private キーワードを付けます。 このように可視性を付加する場合、constructor の記述は省略できなくなります。 class Book private constructor() {} private なコンストラクタしか存在しないクラスのインスタンスを生成するには、クラスのコンパニオン・オブジェクト (companion object) からコンストラクタを呼び出す必要があります。 コンパニオン・オブジェクトに定義した関数は、インスタンスがなくても呼び出すことができるため、外部から間接的に private なコンストラクタを呼び出すための入り口として使用できます。 コンストラクタのパラメータが複雑な場合、直観的な名前のついたファクトリ・メソッドをコンストラクタの代わりに提供すると可読性を向上させることができます。 下記の Book クラスは、インスタンスの生成をファクトリ・メソッド経由で行うことを強制しています。 class Book private constructor(val title: String, val price: Int) { companion object { fun newFreeBook(title: String) = Book(title, 0) fun newDamnedBook(title: String) = Book(title, -1) } } fun main() { val b = Book.newFreeBook(&#34;はじめてのKotlin&#34;) println(b.title) println(b.price) } この例だとコンストラクタのパラメータがシンプルすぎて、ファクトリ・メソッドを導入するメリットは感じられないかもしれませんが、こういった設計パターンがあることを覚えておくといつか役に立つでしょう。 こういった抽象度の高いデザインパターンは、Kotlin に限らず、一般的なベストプラクティスとして受け入れられています。 プライマリ・コンストラクタを private にする目的が、シングルトンを作成したいということであれば、代わりに Kotlin の object 宣言を使用すると簡潔な記述が可能です。 参考: オブジェクト宣言でシングルトンを作成する (object declaration) 単なる静的なユーティリティ関数を集めただけのユーティリティ・クラスを作りたいということであれば、パッケージのトップレベルに関数を定義してしまうのが手っ取り早いです。"},{url:"/p/rk5dgjh/",title:"Kotlinメモ: スマートキャストでキャストを自動化する",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: スマートキャストでキャストを自動化する インタフェースを定義する でも説明されているように、あるオブジェクトが特定のインタフェースを持っているかを調べるには、obj is インタフェース名 というチェックを行います。 interface Command { fun execute() } fun executeIfPossible(obj: Any) { if (obj is Command) { obj.execute() } } Java では、あるオブジェクトが特定のインタフェースを持っているかを調べた後に、さらにキャストを行わなければ、そのインタフェースのメソッドを呼び出すことはできませんでした。 Kotlin では、上記のように、is による判定が true だったときは、その後ろのブロック内では明示的なキャストを省略することができます（型のチェックとキャストが同時に行われる）。 これをスマートキャスト (smart cast) と呼びます。 実際には、下記のような as を使ったキャストが内部的に自動的に行われていることになります。 冗長なキャスト if (obj is Command) { val cmd = obj as Command // これは必要ない cmd.execute() } スマートキャストは、|| や &amp;&amp; を使った際にも適用されます。 下記の 2 つの例はいずれも想定通り動作します。 if (x is String &amp;&amp; x.length &gt; 0) { // ... } if (x !is String || x.isEmpty()) { return } スマートキャストは、when 式の中でも使用することができます。 fun doTrick(animal: Animal) { when (animal) { is Bird -&gt; animal.fly() // Bird のメソッドを呼び出し is Dog -&gt; animal.bark() // Dog のメソッドを呼び出し else -&gt; throw IllegalArgumentException(&#34;Unknown animal&#34;) } } 特定の型にしか適用できない演算子を使用する場合にも、スマートキャストを適用できます。 下記の例では、リスト要素の中の Int 要素を見つけて、+ 演算子で足し合わせています。 Any 型（Java でいう Object）のままでは + 演算子は適用できませんが、Int へのスマートキャストにより足し合わせることができるようになっています。 fun addAllIntegers(maybeIntegers: List&lt;Any&gt;) : Int { var sum = 0 for (e in maybeIntegers) { if (e is Int) { sum += e } } return sum } fun main() { val list = listOf(100, &#34;AAA&#34;, 200, &#34;BBB&#34;) println(addAllIntegers(list)) //=&gt; 300 }"},{url:"/p/bvu8qmi/",title:"Kotlinメモ: 例外処理を記述する (try, catch, finally)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: 例外処理を記述する (try, catch, finally) 例外の基本 Kotlin の例外処理には、Java と同様の try、catch、finally キーワードを使用します。 下記は、NumberFormatException 例外を捕捉する例です。 try { val num = &#34;xyz&#34;.toInt() println(num) } catch (e : NumberFormatException) { System.out.println(e) } 例外のスローも Java と同様に throw を使って行います。 クラスのインスタンスを生成するときに new が必要なかったように、ここでも new は必要ありません。 fun fibonacci(n: Int) { if (n &lt; 0) throw IllegalArgumentException(&#34;負の値は指定できません&#34;) // ... } 例外の捕捉は必須ではない Java では、IOException などの検査例外 (checked exception) を投げるメソッドを呼び出すメソッドは、必ず catch で例外を捕捉するか、自分自身のメソッドで throws IOException と宣言しておく必要がありました。 Kotlin では、検査例外 (checked exception) と非検査例外 (unchecked exception) を区別しない ので、メソッドに throws IOException の宣言が必要ありません。 スローされた例外を捕捉するもしないも呼び出し側の自由です。 捕捉されなかった例外は、呼び出し元のメソッドに伝搬されていきます。 fun throwIoException() { throw IOException(&#34;読み込みエラーだよ！&#34;) } fun foo() { // IOException をスローするメソッドを呼び出しているけど、 // この foo メソッドでは throws 宣言をしなくてもよい。 throwIoException() } fun main() { try { foo() } catch (e : IOException) { System.err.println(e) } } try を式として扱う Kotlin では、try も式です。 try のブロックの中で評価された値を、そのまま変数で受け取ったり、関数の戻り値として返したりすることができます。 下記の例では、try ブロックの中で実行した String.toInt() の結果を、num 変数に代入しています。 fun printIfInt(s: String) { val num = try { s.toInt() } catch (e: NumberFormatException){ return } println(num) } Java では、try ブロック内で作成したオブジェクトを、ブロックの外で参照したいときは、ブロックの外でその変数を定義しておく必要がありました（とりあえず null 値を入れておくとかして）。 Kotlin ではそのような回りくどい書き方をせずに済みます。 上記の例では、例外が発生したときに return でそのまま関数から抜けるようにしていますが、三項演算子的に別の値を返すこともできます。 次の例では、文字列をうまくパースできなかった場合は、num 変数に null を格納するようにしています。 val num = try { s.toInt() } catch (e: NumberFormatException){ null } もっとも、この例のような処理は、String.toIntOrNull という関数を使うのが正解ですが。 val num = s.toIntOrNull(); // Int に変換できない場合 null にする ちなみに、if 式を三項演算子的に使う場合、分岐後の式が 1 つであれば下記のように {} を省略できましたが、 println(if (x == 0) &#34;ZERO&#34; else &#34;NOT ZERO&#34;) try ～ catch の場合は、{} は省略できないことに注意してください。 こんな書き方はできません val num = try s.toInt() catch (e: NumberFormatException) null"},{url:"/p/st6xako/",title:"Kotlinメモ: 列挙型を定義する (enum)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: 列挙型を定義する (enum) 列挙型の基本 (enum class) Kotlin の列挙型はクラスの一種であり（Java もそうですが）、class キーワードの前に enum を付けることで定義できます。 enum class Fruits { APPLE, BANANA, GRAPE } fun main() { val fruit = Fruits.APPLE println(fruit) //=&gt; APPLE } when 式による分岐で使用するのが典型的な使用例です。 fun getColor(fruit: Fruits) = when (fruit) { Fruits.APPLE -&gt; &#34;red&#34; Fruits.BANANA -&gt; &#34;yellow&#34; Fruits.GRAPE -&gt; &#34;purple&#34; } fun main() { val f = Fruits.APPLE println(&#34;$f is ${getColor(f)}&#34;) //=&gt; APPLE is red } when 式の分岐において、すべての列挙値を網羅していない場合は、必ず else 分岐を含める必要があります（Java の switch における default のようなもの）。 書き忘れた場合はコンパイルエラーになるのですぐに気づくことができます。 fun getColor(fruit: Fruits) = when (fruit) { Fruits.APPLE -&gt; &#34;red&#34; else -&gt; throw Exception(&#34;Unknown fruit&#34;) } 列挙型にプロパティやメソッドを追加する 列挙型もクラスの一種なので、プロパティやメソッドを持つことができます（これも Java と同様です）。 enum class Fruits(val label: String, val color: String) { APPLE(&#34;リンゴ&#34;, &#34;赤色&#34;), BANANA(&#34;バナナ&#34;, &#34;黄色&#34;), GRAPE(&#34;ぶどう&#34;, &#34;紫色&#34;); // Kotlin で唯一セミコロンが必要な場所 override fun toString(): String { return &#34;$label は $color です&#34; } } fun main() { val f = Fruits.APPLE println(f.label) //=&gt; &#34;リンゴ&#34; println(f.color) //=&gt; &#34;赤色&#34; println(f) //=&gt; &#34;リンゴ は 赤色 です&#34; } 列挙型を by name でインポートする 下記のように特定のパッケージに定義された列挙型があるとします。 color.kt package com.example enum class Color { RED, YELLOW, GREEN, BLUE; } この列挙型の値は、基本的には Color.RED のように参照するのですが、インポートするときに com.example.Color.RED のように名前まで指定してインポートすることで、RED と省略して参照できるようになります。 下記の例では、ワイルドカード * を使って、列挙型の名前をすべてインポートしています。 import com.example.Color import com.example.Color.* fun showImpression(color: Color) { when (color) { BLUE, GREEN -&gt; println(&#34;寒そうな色ですね&#34;) RED, YELLOW -&gt; println(&#34;暖かそうな色ですね&#34;) } } fun main() { val f = RED showImpression(f) //=&gt; 暖かそうな色ですね }"},{url:"/p/cdxns9p/",title:"Kotlinメモ: 文字列と数値を変換する (toIntOrNull, toInt)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: 文字列と数値を変換する (toIntOrNull, toInt) 文字列 (String) → 数値 (Int) toIntOrNull() Kotlin は String クラスに toIntOrNull() 拡張関数を定義しており、これを使うと任意の文字列を数値型 (Int) に変換することができます。 その名の通り、変換できない文字列の場合は null を返します。 val num1 = &#34;100&#34;.toIntOrNull() //=&gt; 100 val num2 = &#34;xyz&#34;.toIntOrNull() //=&gt; null String#toIntOrNull() のパラメータには基数 (radix) を指定することができるため、下記のように2進数表記や16進数表記の文字列をパースすることもできます。 val num1 = &#34;10000000&#34;.toIntOrNull(2) //=&gt; 128 val num2 = &#34;FFFF&#34;.toIntOrNull(16) //=&gt; 65535 val num3 = &#34;0xFFFF&#34;.toIntOrNull(16) //=&gt; null 上記の結果からもわかるように、16進数表記の文字列にプレフィックスとして 0x が付いていると、toIntOrNull() は null を返すということに注意してください。 toInt() 似たようなメソッドに String#toInt() がありますが、こちらはパースに失敗したときに null を返すのではなく、NumberFormatException を投げます。 必要に応じて使い分けましょう。 try { val num = &#34;xyz&#34;.toInt() println(num) } catch (ex : NumberFormatException) { System.err.println(ex) } 数値 (Int) → 文字列 (String) Int.toString(radix) を使用すると、数値 (Int) を任意の基数の文字列表現に変換することができます。 val num = 255 println(num.toString(2)) //=&gt; &#34;11111111&#34; println(num.toString(8)) //=&gt; &#34;377&#34; println(num.toString(16)) //=&gt; &#34;ff&#34; Java の Integer クラスにある toBinaryString、toOctalString、toHexString と同様に使用することができますが、負の値を指定したときには結果が変わってくることに注意してください。 val num = -255 println(num.toString(2)) //=&gt; &#34;-11111111&#34; println(num.toString(8)) //=&gt; &#34;-377&#34; println(num.toString(16)) //=&gt; &#34;-ff&#34; println(Integer.toBinaryString(num)) //=&gt; &#34;11111111111111111111111100000001&#34; println(Integer.toOctalString(num)) //=&gt; &#34;37777777401&#34; println(Integer.toHexString(num)) //=&gt; &#34;ffffff01&#34;"},{url:"/p/n3mn3og/",title:"Kotlinメモ: 文字列リテラルの中で変数や式を展開する（文字列テンプレート）",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: 文字列リテラルの中で変数や式を展開する（文字列テンプレート） 文字列リテラルの中で &quot;$変数名&quot; や &quot;${式}&quot; のように記述すると、変数の値や式の評価結果を文字列内に展開することができます。 この仕組みを 文字列テンプレート (string template) といいます。 val name = &#34;Maku&#34; println(&#34;Hello, $name!&#34;) //=&gt; Hello, Maku! &quot;${式}&quot; の記述方法を利用すると、文字列テンプレートの中で関数呼び出しなどを行うことができます。 println(&#34;You are ${p.age} years old.&#34;) // getAge() の呼び出し ただ、あまり複雑な式を書こうとすると読みにくくなってしまうので、ほどほどに。 やりすぎな例 fun main(args: Array&lt;String&gt;) { println(&#34;Hi, ${if (args.isEmpty()) &#34;anonymous&#34; else args[0]}&#34;) }"},{url:"/p/wz5cnqq/",title:"Kotlinメモ: 配列やリストから null 以外の要素のみを抽出する (filterNotNull, mapNotNull)",date:"2019-04-24T00:00:00+09:00",body:"Kotlinメモ: 配列やリストから null 以外の要素のみを抽出する (filterNotNull, mapNotNull) filterNotNull 関数による null 要素の削除 Kotlin の filterNotNull 関数 を使用すると、null 要素の混じった配列やリストから、null 以外の要素だけを抽出することができます。 val list1 = listOf(100, null, 200, null, 300) val list2 = list1.filterNotNull() println(list1) //=&gt; [100, null, 200, null, 300] println(list2) //=&gt; [100, 200, 300] 下記のように記述するのとほぼ同様ですが、filterNotNull を使うと戻り値の型が少し変わります。 val list2 = list1.filter { it != null } filterNotNull 関数の定義を見てみてください。 fun &lt;T : Any&gt; Array&lt;out T?&gt;.filterNotNull(): List&lt;T&gt; fun &lt;T : Any&gt; Iterable&lt;T?&gt;.filterNotNull(): List&lt;T&gt; 戻り値の List が保持する要素の型が T? から T に変わっており、もはや Nullable ではありません。 最初に挙げた例を、冗長に型付きで記述すると下記のようになります。 val list1: List&lt;Int?&gt; = listOf(100, null, 200, null, 300) val list2: List&lt;Int&gt; = list1.filterNotNull() null を排除した List&lt;Int&gt; に変換した後は、sum() や average() などの計算用関数を null チェックなしで思う存分呼び出せます。 fun showValidNumberStats(numbers: List&lt;Int?&gt;) { val validNumbers = numbers.filterNotNull() println(&#34;Sum: ${validNumbers.sum()}&#34;) println(&#34;Avg: ${validNumbers.average()}&#34;) } mapNotNull 関数（map と filterNotNull の一括処理） コレクションの要素を map 関数で変換し、その結果から null 要素を取り除くという処理を行う場合、単純に考えると map → filterNotNull と順番に実行することになります。 次の例では、pages コレクションから category プロパティの値を収集し、null 値を取り除いています。 val categories = pages.map { it.category }.filterNotNull() Kotlin には、この 2 つの操作を一発で行うための mapNotNull 関数が用意されています。 val categories = pages.mapNotNull { it.category } 全体のコード data class Page(val title: String, val category: String? = null) fun main() { val pages = listOf( Page(&#34;Title1&#34;, &#34;Category1&#34;), Page(&#34;Title2&#34;, &#34;Category2&#34;), Page(&#34;Title3&#34;)) val categories = pages.mapNotNull { it.category } println(categories) } 実行結果 [Category1, Category2]"},{url:"/p/6kruhwy/",title:"Node.jsメモ: 環境変数の代わりに .env ファイルを使用する (dotenv)",date:"2019-03-26T00:00:00+09:00",body:"Node.jsメモ: 環境変数の代わりに .env ファイルを使用する (dotenv) dotenv モジュールとは Node.js のプログラムから環境変数を参照するには process.env を参照します。 参考: Node.js で環境変数を参照する (process.env) ユーザー設定を環境変数で行うようにしているアプリはよくあるのですが、たかが 1 つのアプリのために環境変数を設定するのは面倒だというユーザーは少なくありません（設定がどこで行われているのかわかりにくいという理由もあります）。 dotenv モジュールを使用すると、カレントディレクトリに置かれた .env ファイルを読み込み、そこに記述されたキーと値のペアを process.env 経由で参照できるようになります。 dotenv - npm つまり、ユーザーはアプリの設定を、従来通り環境変数で行うこともできるし、.env ファイルでも行うことができるようになります。 環境変数を使ってアプリの挙動を変えるような実装をしている場合は、.env ファイルによる設定もサポートしておくと親切です。 クラウドサービスと連携するアプリケーションなどは、接続キー などの情報を .env ファイルで指定できるようにしているものがよくあります。 dotenv モジュールのインストール dotenv モジュールは npm コマンドで下記のようにインストールすることができます。 インストールされたモジュールは node_modules ディレクトリに格納されます。 $ npm install dotenv dotenv モジュールの基本的な使い方 まず、サンプルの設定ファイルとして、プロジェクトのルートディレクトリに、下記のような .env ファイルを作成します。 .env # これはコメント行 KEY1=VALUE1 KEY2=VALUE2 KEY3=VALUE3 .env ファイルの内容を読み込んで、process.env オブジェクトのプロパティとして参照できるようにするには、アプリの最初の方で下記のように実行します。 sample.js require(&#39;dotenv&#39;).config(); 基本的にはやることはこれだけです。 仮に、.env ファイルが見つからない場合は、単純に無視されるだけなので、上記のコードは安心して入れておくことができます。 後は、通常の環境変数と同様に process.env オブジェクト経由で値を参照するだけです。 require(&#39;dotenv&#39;).config(); console.log(process.env.KEY1); //=&gt; VALUE1 console.log(process.env.KEY2); //=&gt; VALUE2 console.log(process.env.KEY3); //=&gt; VALUE3 より実践的には、下記のように、設定が正しく行われているかの確認をするのがよいでしょう（これは、dotenv モジュールを使用しない場合でも同様ですが）。 require(&#39;dotenv&#39;).config(); if (typeof process.env.KEY1 == &#39;undefined&#39;) { console.error(&#39;Error: &#34;KEY1&#34; is not set.&#39;); console.error(&#39;Please consider adding a .env file with KEY1.&#39;); process.exit(1); } console.log(process.env.KEY1); //=&gt; VALUE1 .env ファイルの記述ルール 空行は無視されます # で始まる行はコメントだとみなされます 値にスペースを含んでいてもクォーテーションで囲む必要はありません（KEY1=AAA BBB CCC も OK）。シングルクォートやダブルクォートで囲んでもよいです 値の記載を省略した場合は空文字になります（例: KEY1= とすると、{ KEY1: '' } になる） キーや値の前後の空白は削除されます。削除したくない場合は、シングルクォートかダブルクォートで値を囲む必要があります（例: KEY1=' AAA '） エンコーディング形式は utf8 で保存します（dotenv.config() のオプション encoding で変更できます） dotenv によって読み込んだ値のみを参照する dotenv.config() によって返されるオブジェクトの parsed プロパティを参照すると、.env ファイルで設定されているキーと値をオブジェクトの形で参照することができます。 sample.js const dotenv = require(&#39;dotenv&#39;); const result = dotenv.config(); console.log(result.parsed); 実行結果 $ node sample.js { KEY1: &#39;VALUE1&#39;, KEY2: &#39;VALUE2&#39;, KEY3: &#39;VALUE3&#39; } ちなみに、.env ファイルが存在しない場合は result は undefined になり、.env ファイルの内容が空のときは result は {} （空オブジェクト）になります。 カレントディレクトリではなく、js ファイルと同じディレクトリにある .env ファイルを読み込む デフォルトでは、.env ファイルの読み込みパスは下記のように構築されるため、node コマンドを実行したときのカレントディレクトリに置かれた .env ファイルが読み込まれます。 path.resolve(process.cwd(), &#39;.env&#39;); 通常はあまり問題になることはありませんが、js ファイルが置かれたディレクトリ以外から node コマンドを実行する場合（例: node myapp/main.js のように実行した場合）は、.env ファイルが読み込めずに混乱するかもしれません。 カレントディレクトリではなく、プログラム（.js ファイル）自体が置かれたディレクトリ内にある .env ファイルを読み込むようにするには、dotenv.config() の path オプションで下記のようにパス指定します。 const ENV_PATH = path.join(__dirname, &#39;.env&#39;); require(&#39;dotenv&#39;).config({ path: ENV_PATH }); dotenv によって .env ファイルの内容がうまく反映されない場合 デバッグモードで確認する dotenv.config() のオプションで debug フラグを true に設定しておくと、dotenv の処理内容が表示されるようになります。 これにより、.env ファイルの記述方法のミスなどを発見できます。 require(&#39;dotenv&#39;).config({ debug: true }); $ node sample.js [dotenv][DEBUG] did not match key and value when parsing line 1: THIS_IS_AN_INVALID_LINE 環境変数に同じ名前の変数が設定されている 環境変数と、.env ファイルに同じ名前のキーが設定されている場合は、環境変数の設定の方が優先されます。 .env ファイルに設定した設定が反映されておらず、別の値が設定されているような場合は、環境変数の設定を確認してみてください。 .env ファイルは Git にコミットしない .env ファイルは、ユーザ固有の設定や、Web API 接続用のキーなどの設定を行うために使用されます。 Git などのバージョン管理システムには、.env ファイルをコミットしないように気を付けてください。 Git を使用する想定であれば、プロジェクトのルートに置いた .gitignore ファイルに下記のようなエントリを追加しておきましょう。 .env これで .env ファイルが Git の管理化から外されます（git status などでコミット候補として表示されなくなります）。"},{url:"/p/gxk6qat/",title:"Hugo でソースコードをハイライト表示する (highlight)",date:"2019-03-17T00:00:00+09:00",body:"Hugo でソースコードをハイライト表示する (highlight) Pygments によるコードハイライト Hugo の設定ファイル config.toml の中で、下記のように設定しておくと、Pygments によるコードブロックのハイライト機能を有効にすることができます。 pygmentsCodeFences = true 例えば、Java のソースコードであれば、Markdown ファイルの中で、下記のように言語名 (java) を指定してコードブロックを記述するだけで、その言語に特化したハイライト表示を行ってくれます。 ```java public class Main { public static void main(String... args) { System.out.println(&#34;Hello&#34;); } } ``` 図: ハイライト表示例 highlight ショートコードによるコードハイライト Hugo の組み込みショートコードとして highlight が用意されています。 このショートコードを使用すると、pyghmentsCodeFences を使う方法よりも高度なコードハイライトを行えます。 例えば、下記のように、行番号を表示したり、特定の行を強調表示することができます。 {{&lt; highlight java &#34;linenos=table, hl_lines=3&#34; &gt;}} public class Main { public static void main(String... args) { System.out.println(&#34;Hello&#34;); } } {{&lt; /highlight &gt;}} 図: ハイライト表示例 色々なオプションが用意されているので、詳しくは下記の Hugo ドキュメントを参照してください。 Hugo - Syntax Highlighting キャプションを付けられる独自のショートコードを作成する ソースコードの表示をキャプション付きでマークアップする場合は、HTML では下記のように figure、figcaption タグを使って記述します。 &lt;figure&gt; &lt;figcaption&gt;サンプルコード&lt;/figcaption&gt; &lt;pre&gt;&lt;code&gt; public class Main { public static void main(String... args) { System.out.println(&#34;Hello&#34;); } } &lt;/code&gt;&lt;/pre&gt; &lt;/figure&gt; このようなコードを手書きで毎回記述するのは大変なので、独自のショートコードを作る のがオススメです。 ここでは code というショートコードを作成し、コードブロックをタイトル付きでハイライト表示できるようにします。 ハイライト機能自体は自力で実装するのは大変なので、Hugo の組み込み関数として用意されている highlight 関数 を利用します（Hugo の組み込みの highlight ショートコードも、この highlight 関数を使って実装されています）。 layouts/shortcodes/code.html {{ $title := .Get &#34;title&#34; }} {{ $lang := or (.Get &#34;lang&#34;) &#34;&#34; }} &lt;figure class=&#34;xCodeBlock&#34;&gt; {{ with $title }}&lt;figcaption class=&#34;xCodeBlock_title&#34;&gt;{{ . }}&lt;/figcaption&gt;{{ end }} &lt;div class=&#34;xCodeBlock_code&#34;&gt;{{ highlight (trim .Inner &#34;\\r\\n&#34;) $lang &#34;&#34; }}&lt;/div&gt; &lt;/figure&gt; このショートコードは、Markdown ファイルの中で次のように呼び出します。 {{&lt; code lang=&#34;java&#34; title=&#34;タイトル&#34; &gt;}} public class Main { public static void main(String... args) { System.out.println(&#34;Hello&#34;); } } {{&lt; /code &gt;}} 図: ハイライト表示例 ちなみに、上記のようなタイトルラベルを表示するために、次のような CSS 定義を使用しています。 .xCodeBlock_title { display: inline-block; font-size: smaller; border-radius: 0.5em 0.5em 0 0; padding: 0 0.5em; background: gray; color: white; } .xCodeBlock_code { margin-top: -2px; } .xCodeBlock_code pre { padding: 0.5em; white-space: pre-wrap; } ハイライトのカラーテーマを変更する Hugo の highlight ショートコード、あるいは highlight 関数で使用されるカラーテーマは、CSS ファイルを用意することで変更することができます。 まず、highlight 機能によって出力される HTML コードが、CSS クラスを使用したものになるように、Hugo の設定ファイル config.toml に下記のような行を追加します。 config.toml に追記 pygmentsUseClasses = true 次に、使用したいカラーテーマの CSS ファイルを生成します。 下記のようなサイトからダウンロードしてしまうのが手っ取り早いです。 Pygments Syntax Highlighter CSS Theme Files Hugo にはシンタックスハイライト用の CSS ファイルを生成する機能がついているので、下記のようにコマンド実行して生成することもできます。 スタイル名は Pygments style gallery のサイトで探してください。 $ hugo gen chromastyles --style=manni &gt; highlight-manni.css あとは、この CSS をすべてのページで読み込むようにすれば OK です。 参考: Hugo の highlight ショートコードの実装 hugo/tpl/tplimpl/embedded/templates/shortcodes/highlight.html - gohugoio/hugo - GitHub {{ if len .Params | eq 2 }} {{ highlight (trim .Inner &#34;\\n\\r&#34;) (.Get 0) (.Get 1) }} {{ else }} {{ highlight (trim .Inner &#34;\\n\\r&#34;) (.Get 0) &#34;&#34; }} {{ end }}"},{url:"/p/wjgs3fp/",title:"Kotlinメモ: Kotlin のコードにドキュメンテーションコメントを記述する (KDoc)",date:"2019-03-05T00:00:00+09:00",body:"Kotlinメモ: Kotlin のコードにドキュメンテーションコメントを記述する (KDoc) ドキュメンテーションコメントとは Kotlin のソースコードにドキュメンテーションコメントを記述しておくと、関数のコメントなどから API ドキュメントを自動生成することができるようになります。 また、関数のドキュメンテーションコメントを記述しておけば、AndroidStudio などの開発環境上でコーディングしているときに、関数の説明をポップアップ表示してくれるようになります。 Java のドキュメンテーションコメントのフォーマットは Javadoc と呼ばれていますが、Kotlin のドキュメンテーションコメントは KDoc と呼びます。 KDoc - Documenting Kotlin Code 多人数で使用するライブラリを作成する場合は API ドキュメントを用意するのは必須です。 一人で開発する場合でも、API の仕様を明確にして実装する癖をつけることで、自然にきれいな設計を行う力が身に付きます。 ドキュメンテーションコメントに関する基本的な考え方は下記を参照してください。 ドキュメンテーションコメントの書き方 Javadoc コメントと KDoc コメントの違い KDoc ドキュメンテーションコメントは、Javadoc と同様に /** で始め */ で終わります。 @タグ名 の形で付加的な情報を記述できることも同様ですが、KDoc のみで使用できるタグや、逆に KDoc では使えないタグもあります（後述）。 Javadoc コメント内では HTML タグを使った修飾が可能でしたが、KDoc コメントでは代わりに Markdown を使用します。 下記は、Kotlin のドキュメントサイトで紹介されている KDoc コメントの記述例です。 /** * A group of *members*. * * This class has no useful logic; it&#39;s just a documentation example. * * @param T the type of a member in this group. * @property name the name of this group. * @constructor Creates an empty group. */ class Group&lt;T&gt;(val name: String) { /** * Adds a [member] to this group. * @return the new size of the group. */ fun add(member: T): Int { ... } } KDoc ドキュメンテーションコメントの書き方 パラメータに関する記述 /** * Sums two values, [a] and [b]. */ fun myAdd(a: Int, b: Int) = a + b KDoc のドキュメンテーションコメントから関数のパラメータを参照するときは、上記のようにパラメータ名をブラケット [] で囲みます。 Javadoc ではパラメータの説明は @param タグ、戻り値の説明は @return タグを使って記述することが推奨されていましたが、Kotlin の開発チームは、KDoc では説明文の形でシンプルに記述してしまうことを推奨しています。 /** * Sums two values, [a] and [b]. * * @param[a] the first value to be added * @param[b] the second value to be added * @return the sum of two values */ 上記のようなコメントは冗長なので、下記のようにシンプルに記述すればよいということですね。 /** * Sums two values, [a] and [b]. */ もちろん、パラメータや戻り値の詳細な説明が必要なケースでは、@param や @return タグを使用してコメントを記述した方がよいでしょう。 KDoc で使用できるブロックタグ KDoc コメント内では、下記のようなブロックタグが使用できます。 Javadoc には存在しなかった KDoc 独自のタグはハイライトしています。 @param name 説明 @param[name] 説明 関数のパラメータ、あるいはクラス、プロパティ、関数のタイプパラメータの説明に使用します。 @return 説明 戻り値の説明に使用します。 @throws class 説明 @exception class 説明 あるメソッドが投げる可能性のある例外に関しての説明を記述します。 @constructor 説明 クラスコメントにプライマリコンストラクタの説明を記述するときに使用します。プライマリコンストラクタのパラメータの説明は、@constructor タグよりも下に @param タグを使って記述します。 @property name 説明 クラスコメントで、各プロパティの説明を記述する際に使用します。プライマリコンストラクタで定義したプロパティの説明にも使用できます。各プロパティの説明は、このブロックタグを使用してクラスコメント内に記述できるので、各プロパティの定義位置に記述する必要はありません。 @receiver 説明 拡張関数（プロパティ）のレシーバーの説明に使用します。 @sample シンボル 指定した関数の実装をサンプルコードとして埋め込み表示します。完全修飾名 (fully qualified name) で関数を指定します。サンプルコードの置き場所は build.gradle の dokka.samples で指定します。 @suppress API ドキュメントとしては出力しないように指示します。一般的な API としては非公開にしたいのだけど、実装上どうしても呼び出さなければいけないメソッドなどで使用します。 @see シンボル 参考にすべきクラスやメソッドがある場合に、See also リンクを張るために使用します。 @version バージョン この API が導入されたバージョンを示します。 KDoc で使用できないブロックタグ 逆に、Javadoc では使えたけど KDoc では使えなくなっているタグもあります。 @deprecated タグ Kotlin では非推奨の API は @Deprecated アノテーションだけで示すのでコメント用のタグは存在しません。ただし、ドキュメンテーションコメントとして代替メソッドの説明を記述することは忘れないようにしましょう。 @inheritdoc タグ Kotlin のドキュメンテーションコメントは、サブクラスに自動的に継承されるので、ドキュメントの継承を明示するタグは存在しません。 装飾用のインラインタグ (@link、@code など） Kotlin では文章の装飾は Markdown フォーマットで行います（下記参照）。 文章の中で使用できる Markdown フォーマット Javadoc コメント内の文章に装飾を加える場合は、HTML タグや @literal などのインラインタグを使用していましたが、KDoc コメントでは代わりに Markdown フォーマットを使用します。 リンク ドキュメンテーションコメント内でクラス名や関数名にリンクを張りたいときは、下記のようにシンボル名をブラケットで囲みます（関数のパラメータと同様）。 [MyClass] [myFunc] [com.example.myapp.MyClass] [com.example.myapp.MyClass.myFunc] 表示に使用するテキストを変更したい場合は、下記のように、表示したいテキストをブラケットで囲んで前に追加します。 [test class][com.example.myapp.test.Bar] 一般的な Web サイトへのリンクは、アドレスを囲む括弧を () にします。 [Google](https://google.com/) コードブロック ```kotlin fun hello() { Log.i(TAG, &#34;hello&#34;) } ``` リスト - apple - banana - orange 1. apple 2. banana 3. orange その他 ## 見出しを入れることができます アスタリスクで囲むと *強調* されて表示されます。 バッククォートで囲んだ `インラインコード` は等幅フォントで表示されます。 Dokka による API ドキュメントの生成 Kotlin のソースコードから HTML 形式などの API ドキュメントを出力するには、Dokka というツールを使用します。 Dokka Dokka は Java コードに記述された Javadoc コメントを扱う機能を備えているため、Java コードと Kotlin コードの混在するプロジェクトでも、Dokka だけ使用すればよいようになっています。 Gradle の org.jetbrains.dokka プラグインが Maven リポジトリ (jcenter)から配信されているので、下記のように build.gradle ファイルに依存関係を記述するだけで Gradle の dakka タスクを実行できるようになります。 通常の Java アプリの場合 build.gradle buildscript { ext.dokka_version = &#39;0.9.+&#39; repositories { jcenter() } dependencies { classpath &#34;org.jetbrains.dokka:dokka-gradle-plugin:$dokka_version&#34; } } apply plugin: &#39;org.jetbrains.dokka&#39; Android アプリの場合 Android プロジェクトでは、org.jetbrains.dokka プラグインの代わりに org.jetbrains.dokka-android プラグインを使用します。 Android 用のプラグインを使用することで、自動生成される R クラスなどのドキュメントが無駄に出力されないようになります。 dependencies で指定する ID が微妙に異なるので注意してください。 ルートの build.gradle buildscript { ext.dokka_version = &#39;0.9.+&#39; repositories { jcenter() } dependencies { classpath &#34;org.jetbrains.dokka:dokka-android-gradle-plugin:$dokka_version&#34; } } Android のプロジェクトでは、app ディレクトリなどのサブプロジェクト構成になっていると思います。 各サブプロジェクトの build.gradle で com.android.application や com.android.library プラグインを適用した後で、org.jetbrains.dokka-android プラグインを適用します。 app/build.gradle apply plugin: &#39;com.android.application&#39; apply plugin: &#39;kotlin-android&#39; apply plugin: &#39;org.jetbrains.dokka-android&#39; これで、Gradle の dokka タスクを実行して API ドキュメントを生成できるようになります。 実行例 $ ./gradlew dokka デフォルトでは、各プロジェクトの build/dokka ディレクトリ内に API ドキュメントが出力されます。 Dokka の出力設定 Gradle プラグインとして提供されている Dokka を使用する場合、dokka ブロックで dokka タスクの設定を行うことができます。 出力形式を変更する dokka { outputFormat = &#39;javadoc&#39; } 下記のような出力形式を指定できます。 html - デフォルト形式 javadoc - Javadoc 形式 markdown - Markdown structured as html（一般的な Markdown 形式） gfm - GitHub flavored markdown（生成されたファイルを GitHub にそのまま push すれば Web 上で読めるようになる） jekyll - Jekyll compatible markdown（GitHub pages も Jekyll で動作しているのでこれが使える） デフォルトの出力形式は html です。 javadoc を指定することで、見慣れた Javadoc 形式の API ドキュメントを生成することができます。 Javadoc 形式の方が、サイドバーがあって使いやすいかもしれません。 出力先ディレクトリを変更する dokka { outputDirectory = &#34;$buildDir/javadoc&#34; } デフォルトの出力先は $buildDir/dokka です。 モジュール／パッケージのドキュメンテーションファイルを指定する dokka { includes = [&#39;packages.md&#39;] } KDoc では、複数パッケージのドキュメントを、独立した Markdown ファイルにまとめて記述しておくことができます。 Javadoc で使われていた package-info.java のようなものを、1 ファイルにまとめて記述できるということですね。 Kotlin は Java と違って「ディレクトリ構造＝パッケージ構造」ではないので、パッケージに関するドキュメントファイルもディレクトリ構造とは独立した形で作成できるようになっています。 パッケージドキュメントの記述方法に関しては、下記のドキュメントを参照してください。 Documenting Kotlin Code - Module and Package Documentation"},{url:"/p/32n9scv/",title:"Hugo でリンクをページからの相対パスで出力するようにする (relativeurls)",date:"2019-02-21T00:00:00+09:00",body:"Hugo でリンクをページからの相対パスで出力するようにする (relativeurls) サイト内のページへのリンクを /sec1/sec2/ のように記述しておくと、デフォルトではそのまま /sec1/sec2/ へのリンクとして出力されます（つまり、baseURL からの相対パスになります）。 Hugo の設定ファイル config.toml（あるいは config.yaml）で relativeurls = true という設定を追加しておくと、各リンクが現在のページからの相対パスで出力されるようになります。 config.toml の例 baseURL = &#34;https://example.com/&#34; relativeurls = true languageCode = &#34;ja-jp&#34; title = &#34;サンプル Web サイト&#34; 例えば、/content/posts/sample.md というコンテンツファイル内に /about/ というリンクを記載しておくと、出力されるリンクのパスは ../about/ になります。"},{url:"/p/33jn7zy/",title:"Androidメモ: リソース ID を示す変数やパラメータにアノテーションを付ける",date:"2019-02-18T00:00:00+09:00",body:"Androidメモ: リソース ID を示す変数やパラメータにアノテーションを付ける リソース ID を表す int 変数に付けるアノテーション Android の各種リソースの ID は int 型で管理されています。 この値を変数に格納したり、メソッドのパラメータとして受け取るように実装した場合、不正な int 値が渡されて実行時に落ちてしまうリスクがあります。 このようなことをできるだけ防ぐため、Android Support ライブラリには下記のようなアノテーションが用意されており、これらを付加した int 型変数には、指定した種類のリソースの ID しか格納できなくなります（AndroidStudio で警告が表示されるようになります）。 アノテーション リソース ID の種類 @AnimatorRes R.animator.xxx で参照するリソース ID @AnimRes R.anim.xxx で参照するリソース ID @AnyRes いずれかの種類のリソースの ID（他の具体的なアノテーションを使用することを推奨） @ArrayRes R.array.xxx で参照するリソース ID @AttrRes R.attr.xxx で参照するリソース ID @ColorRes R.color.xxx で参照するリソース ID @DimenRes R.dimen.xxx で参照するリソース ID @DrawableRes R.drawable.xxx で参照するリソース ID @FontRes R.font.xxx で参照するリソース ID @IdRes R.id.xxx で参照するリソース ID @IntegerRes R.interger.xxx で参照するリソース ID @InterpolatorRes R.interpolator.xxx で参照するリソース ID @LayoutRes R.layout.xxx で参照するリソース ID @NavigationRes R.navigation.xxx で参照するリソース ID @RawRes R.raw.xxx で参照するリソース ID @StringRes R.string.xxx で参照するリソース ID @StyleableRes R.styleable.xxx で参照するリソース ID @StyleRes R.style.xxx で参照するリソース ID @TransitionRes R.transition.xxx で参照するリソース ID int 変数用アノテーションの使用例 上記のようなアノテーションは Annotation Support Library で提供されているため、build.gradle に下記のような依存を追加しておく必要があります（参考: 本家ドキュメント）。 com.android.support:support-annotations:24.2.0 下記は、color 値のリソース ID のみを格納できる int 型フィールドを定義する例です。 @ColorRes private int mainColorResId = R.color.white; メソッドのパラメータにもアノテーションを付けることができます。 下記のように指定された int 型パラメータには、文字列リソースを示す ID しか渡せなくなります。 public class ResourceResolver { ... public String getString(@StringRes int resId) { return context.getString(resId); } } android.support.annotation パッケージ には他にもいろいろなアノテーションが定義されているので、ざっと見ておくとよいでしょう。 例えば、int 型用のアノテーションとしては、上記のようなリソース ID 関連のものだけではなく、AARRGGBB 形式のカラー値であることを示すアノテーションが定義されていたりします。 @ColorInt: AARRGGBB 形式の int 値"},{url:"/p/mprs3v6/",title:"GitHub の REST API を使用する",date:"2019-01-30T00:00:00+09:00",body:"GitHub の REST API を使用する GitHub の REST API でできること GitHub は Web API (REST API) を提供しており、コマンドラインや任意のアプリケーションから利用することで、GitHub の操作を自動化することができます。 Linux の curl コマンドや、スクリプト（Python や Ruby など）から簡単に利用できるので、Organization やリポジトリを管理する立場にある人はぜひ使ってみてください。 GitHub - REST API v3 GitHub の REST API を使うと、例えば、下記のような処理を自動化できます。 Users 指定したユーザの詳細情報を取得する 二要素認証が設定できていないユーザのリストを取得する Repositories 指定したオーナー（ユーザー or 組織）のリポジトリのリストを取得する Organizations/Members 指定した組織のユーザーリストを取得する Pull Requests Pull Request のリストを取得する Issues 指定したリポジトリの Issue のリストを取得する Projects 指定したリポジトリのプロジェクト（かんばん）のリストを取得する ただし、アプリケーションに GitHub との連携機能を本格的に組み込む場合は、REST API ではなく GraphQL API を使うをことをお勧めします。 参考: GitHub GraphQL API のクエリ例｜まくろぐ API トークンを発行する REST API を呼び出すには、API トークン (HTTPS Access Token) が必要です。 プライベートリポジトリに関する情報を取得するには、そのリポジトリへのアクセス権限を持つユーザが作成した API トークンを使用して REST API を呼び出す必要があります。 GitHub の API トークンは下記のページで生成することができます。 GitHub - Personal access token Generate new token のボタンを押すと、新しいトークンを発行できます。 Select scope の項目で、そのトークンを使って使用できる機能 (API) の範囲を制御できるようになっているので、必要な機能のみにチェックを入れるようにしてください。 API トークンは次のようなハッシュ値です。 REST API を呼び出す際に必要になるので保存しておいてください。 c647c084ed5f60ee7fd53a22537fd6602ace4ced REST API を呼び出す REST API は単純な HTTP リクエストをベースに動作するため、Linux の curl コマンドなどを使って簡単に実行できます。 例: オープンな Pull Request の一覧を取得する (github-api.sh) #!/bin/bash GITHUB_TOKEN=9b671cc01a1d966f3a3d1dc3366867836aa19c5d GITHUB_BASEURL=https://api.github.com GITHUB_API=/repos/YourOrganization/YourProject/pulls?state=open curl -k -s -u :$GITHUB_TOKEN $GITHUB_BASEURL$GITHUB_API GITHUB_TOKEN 変数は自分で作成した API トークンに、GITHUB_API 変数は実行した API にそれぞれ置き換えて実行してください。 GITHUB_TOKEN &hellip; API トークン GITHUB_API &hellip; 実行したい REST API 上記のサンプルコードでは、指定した Organization あるいはユーザ（ここでは YourOrganization) の、指定したリポジトリ (ここでは YourProject) のうち、オープン状態 (state=open) になっている Pull リクエストの一覧を取得しています。 結果は JSON 形式で出力されますが、長いのでここでは省略します。 GITHUB_API 変数は、他にも下記のような感じで置き換えて実行できます。 詳細は GitHub REST API のサイトを参照してください。 /users/MyName &hellip; 指定したユーザ (MyName) の詳細情報 /orgs/MyOrg/members &hellip; 指定した Organization (MyOrg) 内のメンバーリスト ちなみに、上記の curl コマンド実行時に指定しているオプションの意味は下記の通りです。 -u USER:PASSWORD &hellip; Server user, password and login options -k &hellip; Allow connections to SSL sites without certs -s &hellip; Silent mode. Don&rsquo;t output anything プロキシ環境から curl 実行する場合 プロキシ環境内から実行する場合は、https_proxy 環境変数でプロキシサーバのアドレスとポート番号を設定してから実行してください。 $ export https_proxy=https://proxy.example.com:10080 $ ./github-api.sh プロキシは、curl コマンドの --proxy (-x) オプションで指定する方法もあります。 $ curl --proxy http://proxy.example.com:10080 https://www.google.com/ すべての結果が得られない場合 REST API の結果は、デフォルトでは ページネーション によって 30 件ずつ しか返されません。 一度にたくさんの結果を取得するには、URL の末尾に per_page オプションを指定することで 最大 100 件ずつ 取得することができます。 それ以上の件数を取得するときは、page オプションを使用して取得位置を切り替える必要があります。 GITHUB_API=/user/repos?per_page=100&amp;page=1 # 1～100件目のリポジトリ情報 GITHUB_API=/user/repos?per_page=100&amp;page=2 # 101～200件目のリポジトリ情報 GITHUB_API=/user/repos?per_page=100&amp;page=3 # 201～300件目のリポジトリ情報 ページの切り替え処理 を自動化するのは若干面倒ですが、件数が多くても 500 件以下であることが分かっているのであれば、下記のように単純にループで取得してしまえば事足りるかもしれません。 GITHUB_API=/user/repos?per_page=100 # 100件の取得を5ページ分繰り返す for i in `seq 1 5`; do curl -k -s -u :$GITHUB_TOKEN $GITHUB_BASEURL$GITHUB_API\\&amp;page=$i done （おまけ）Windows のバッチファイルで GitHub REST API を呼び出す Window 10 version 1803 (2018年4月) 以降には、デフォルトで curl コマンドがインストールされるようになったみたいです。 これで、Windows のバッチファイルからも気兼ねなく curl コマンドを使えます。 次の例では、バッチファイルから curl を使って、GitHub の REST API を呼び出すサンプルコードです。 例: members.bat（YourOrganization のメンバーリストを取得する） @echo off setlocal REM --------------- REM User settings REM --------------- set GITHUB_TOKEN=b72209e0b0ed0ad32d7b8cc38b36cf71b416d0a0 set GITHUB_API=/orgs/YourOrganization/members REM set GITHUB_API=/orgs/YourOrganization/repos REM set GITHUB_API=/user/repos REM set PROXY=-x http://proxy.example.com:10080 REM ----------------- REM Call GitHub API REM ----------------- set GITHUB_BASEURL=https://api.github.com FOR /L %%A IN (1, 1, 5) DO ( curl -k -s %PROXY% -u :%GITHUB_TOKEN% &#34;%GITHUB_BASEURL%%GITHUB_API%?per_page=100&amp;page=%%A&#34; ) FOR ループでページネーションを切り替えながら 100 件ずつ取得することで、1～500 件目までの情報を表示しています。 プロキシ環境下で実行したい場合は、PROXY 変数の REM コメントアウトを外してください。 GITHUB_API 変数の部分を置き換えることで、取得する情報を切り替えることができます。 set GITHUB_API=/orgs/YourOrganization/members &hellip; 組織のメンバーリスト set GITHUB_API=/orgs/YourOrganization/repos &hellip; 組織のリポジトリリスト set GITHUB_API=/user/repos &hellip; 自分のリポジトリリスト"},{url:"/p/v2ezcum/",title:"Kotlinメモ: when 式による条件分岐",date:"2019-01-23T00:00:00+09:00",body:"Kotlinメモ: when 式による条件分岐 when 式の基本 Kotlin の when 式は、Java の switch 文に相当するものです。 Java の switch は、列挙型、文字列、数値しか扱えませんが、Kotlin の when では任意のオブジェクトで分岐を行うことができます。 ポイントは式 (expression) であるというところで、条件分岐後の評価結果をそのまま変数に代入したり、関数の戻り値として使うことができます。 val n = 1 val str = when(n) { 1 -&gt; &#34;one&#34; 2 -&gt; &#34;two&#34; else -&gt; &#34;other&#34; } println(str) //=&gt; one Java とは異なり、分岐後の処理は fall through されないので、break 文は不要です。 デフォルトで、値が一致した部分のコードのみが実行されるようになっています。 分岐後の処理を複数行にわたって記述したい場合は、次のように矢印 (-&gt;) の右側を括弧 { } で囲んでブロックを作ります。 ブロックの中で最後に評価された式の値が、when 式全体の評価結果として使われます。 val a = 1 when (a) { 1 -&gt; { println(&#34;one&#34;) exec_one() } 2 -&gt; { println(&#34;two&#34;) exec_two() } else -&gt; { println(&#34;other&#34;) exec_other() } } 列挙型の値で when 分岐 列挙型の値により when 分岐させる場合は、すべての項目を網羅するように記述するか、else でその他のケースをまとめて処理するように記述する必要があります（どちらかを満たさないとコンパイルエラーになります）。 例: Color.WHITE がカバーされていないのでコンパイルエラー enum class Color { RED, GREEN, BLUE, WHITE } fun getRgbStr(color: Color) = when(color) { Color.RED -&gt; &#34;#FF0000&#34; Color.GREEN -&gt; &#34;#00FF00&#34; Color.BLUE -&gt; &#34;#0000FF&#34; } 複数の値で同じ処理を実行したい場合は、次のようにカンマで値を列挙します。 例: 候補値を列挙 when (color) { Color.RED, Color.ORANGE, Color.YELLOW -&gt; &#34;暖色&#34; Color.BLUE, Color.AQUA -&gt; &#34;寒色&#34; Color.GREEN, Color.PURPLE -&gt; &#34;中性色&#34; } if-else 連鎖の代わりに when を使用する when 式の矢印の左側に、直接条件式を記述する形で分岐させることもできます。 この場合は、when の直後にパラメータを指定しません。 val a = 1 val b = 2 when { a == 1 -&gt; println(&#34;one&#34;) (a == 2) || (b == 2) -&gt; println(&#34;two&#34;) (a == 3) &amp;&amp; (b == 3) -&gt; println(&#34;three&#34;) else -&gt; println(&#34;other&#34;) } これは、連続する if-else を短く記述するためのショートカット記法だと考えることができます。 上記の when による分岐は、下記のような if-else の連鎖と同様です。 if (a == 1) { println(&#34;one&#34;) } else if ((a == 2) || (b == 2)) { println(&#34;two&#34;) } else if ((a == 3) &amp;&amp; (b == 3)) { println(&#34;three&#34;) } else { println(&#34;other&#34;) } in による範囲指定との組み合わせ 例: 文字コードの範囲 fun getCharType(c: Char) = when (c) { in &#39;0&#39;..&#39;9&#39; -&gt; &#34;Digit&#34; in &#39;a&#39;..&#39;z&#39;, in &#39;A&#39;..&#39;Z&#39; -&gt; &#34;Letter&#34; else -&gt; &#34;UNKNOWN&#34; } fun main() { println(getCharType(&#39;X&#39;)) //=&gt; Letter } 例: 値があるセットに含まれているか val SEGA = setOf(&#34;DreamCast&#34;, &#34;Saturn&#34;) val NINTENDO = setOf(&#34;Switch&#34;, &#34;DS&#34;, &#34;NES&#34;) val message = when (&#34;Saturn&#34;) { in SEGA -&gt; &#34;セガのハードです&#34; in NINTENDO -&gt; &#34;任天堂のハードです&#34; else -&gt; &#34;何それ？&#34; } expression-body function での when 式の利用 条件分岐が主な処理となる関数は、expression-body として when 式を使うことで簡潔に記述することができます。 enum class Color { RED, GREEN, BLUE } fun getRgbStr(color: Color) = when(color) { Color.RED -&gt; &#34;#FF0000&#34; Color.GREEN -&gt; &#34;#00FF00&#34; Color.BLUE -&gt; &#34;#0000FF&#34; }"},{url:"/p/hqup7mp/",title:"Kotlinメモ: 基本的な型の一覧",date:"2019-01-23T00:00:00+09:00",body:"Kotlinメモ: 基本的な型の一覧 Kotlin には、Java のプリミティブ型に相当する int や boolean といった型は存在せず、すべてがオブジェクトです。 例えば、32 ビット整数を扱いたい場合は、一貫して Int と記述すればよく、Java のように int と Integer を使い分ける必要はありません（内部で必要に応じて Java の int や Integer 相当のものとして扱われます）。 数値型 Byte &hellip; 8ビット整数 Short &hellip; 16ビット整数 Int &hellip; 32ビット整数 Long &hellip; 64ビット整数 Float &hellip; 32ビット浮動小数点数 Double &hellip; 64ビット浮動小数点数 文字、文字列 Char &hellip; 文字 String &hellip; 文字列 論理型 Boolean 列挙型 enum class で定義 特殊型 Any &hellip; Java の Object に相当。すべてのクラスのスーパークラスです（正確には Null 許容型のスーパークラスは Any ではなく Any?）。 Unit &hellip; Java の void に相当。意味を持たない値を表現します。Any は Unit のスーパークラスでもあります。 Nothing &hellip; インスタンスが存在しないことを表現します。ある関数の戻り値が Nothing と定義されている場合、その関数から return されることはないことを示しています（内部で無限ループしているとか、必ず例外を投げるとか）。Nothing はすべてのクラスのサブクラスであるとされています。 プラットフォーム型 &hellip; Java で定義された型で、@NonNull や @Nullable といったアノテートがされていないものです。Kotlin の言語仕様上は String! のような ! 付きの型として表現され、Null 非許容型 (String) と Null 許容型 (String?) のどちらとして扱うかは実装者に委ねられています。Kotlin コード上で明示的に String! と書くことはできません。 下記は Kotlin で定義した変数が、Java のどの型に対応しているかを示しています。 // Null 非許容型 val i: Int = 1 //=&gt; int val d: Double = 0.1 //=&gt; double val f: Float = 0.1 //=&gt; float val o: Byte = 1 //=&gt; byte val b: Boolean = true //=&gt; boolean val c: Char = &#39;X&#39; //=&gt; char val s: String = &#34;ABC&#34; //=&gt; String // Null 許容型 val i_na: Int? = null //=&gt; Integer val d_na: Double? = null //=&gt; Double val f_na: Float? = null //=&gt; Float val o_na: Byte? = null //=&gt; Byte val b_na: Boolean? = null //=&gt; Boolean val c_na: Char? = null //=&gt; Character val s_na: String? = null //=&gt; String // コレクション系 val list: List&lt;Int&gt; = listOf(1, 2, 3) //=&gt; List val arr: IntArray = intArrayOf(1, 2, 3) //=&gt; int[]"},{url:"/p/4t7x4k4/",title:"Kotlinメモ: if による分岐処理と if 式",date:"2019-01-22T00:00:00+09:00",body:"Kotlinメモ: if による分岐処理と if 式 Kotlin の if-else による分岐処理は、Java と同様の構文で記述することができます。 val n = 100 if (n % 15 == 0) { println(&#34;FizzBuzz&#34;) } else if (n % 3 == 0) { println(&#34;Fizz&#34;) } else if (n % 5 == 0) { println(&#34;Buzz&#34;) } else { println(n) } Java と異なるのは、Kotlin では if は文 (statement) ではなく式 (expression) であるという点です。 if 式を評価した結果は、そのまま変数に代入したり、関数の戻り値として使用することができます。 Java や C/C++ の三項演算子と同じ感覚で、下記のように使用することができます。 if 式の評価結果を変数に格納する val isOk = true val message = if (isOk) &#34;OK&#34; else &#34;ERROR&#34; println(message) //=&gt; &#34;OK&#34; if 式の評価結果を戻り値として使用する fun getMessage(isOk: Boolean) = if (isOk) &#34;OK&#34; else &#34;ERROR&#34;"},{url:"/p/qzkfnsq/",title:"Kotlinメモ: 変数を定義する (val, var)",date:"2019-01-22T00:00:00+09:00",body:"Kotlinメモ: 変数を定義する (val, var) 変数の定義 Kotlin で変数を定義するには、val キーワード（あるいは var キーワード）を使用します。 変数定義時に値を初期化する場合は、コンパイラが型を判断してくれるので、多くの場合は型の記述を省略することができます（この機能を型推論［type inference］と言います）。 val s = &#34;Hello&#34; //=&gt; val s: String = &#34;Hello&#34; val n = 100 //=&gt; val n: Int = 100 val f = 7.5e6 //=&gt; val f: Double = 7.5e6 (= 7.5x10^6) ただし、変数の定義と同時に初期値を指定しない場合は、必ず型の指定が必要です。 型は、変数名の後ろに : 型名 という形で指定します（Pascal や Scala、Swift などと同じ）。 val name: String name = &#34;Maku&#34; println(&#34;Hello, $name!&#34;) val と var の違い val と var の違いは、その変数に再代入が可能かどうかです。 val: 再代入できない参照を保持するための変数 (immutable reference)。Java の final 変数に相当。value の略。 var: 再代入可能な変数 (mutable reference)。variable の略。 val a = 1 var b = 1 a = 2 // NG (Val cannot be reassigned) b = 2 // OK 使い分けの方針としては、変数を定義するときはまずは再代入できない val を使用することを考え、必要なケースでのみ var を使用するのがよいでしょう。 こうすることで、コードレビュー時などに変数の変化を追う必要性が下がるため、保守性が高くなります。 Java を使って同じようなことを実現しようとすると、コードの中に final があふれてしまって逆に読みにくくなってしまうのですが、Kotlin の場合は val も var もタイプ量は一緒なので、積極的に final 相当の val を使用してコーディングすることができます。 null 許容型の変数 Kotlin の変数はオブジェクトの参照を格納するものですが、Java と異なりデフォルトでは null を代入することが禁止されています。 null を代入することが可能な変数を定義するには、型名の後ろに ? を付けて定義します。 var s: String? = null s = &#34;Hello&#34; ちなみに、このルールは関数のパラメータでも同様です。 fun greet(name: String?) { // null も渡せる println(&#34;Hello, $name&#34;) } 代入は文 (statement) である Kotlin の代入 (=) は、式 (expression) ではなく文 (statement) として扱われます。 文 (statement) は評価後の値を持ちません。 つまり、次のような、ある変数への代入結果を、そのまま別の変数へ代入することはできないということです（コンパイル時に構文エラーになります）。 var a = b = 100 // ERROR 一方、Java では代入は式 (expression) として扱われるので、このような代入の連鎖が許されています。 Kotlin ではこのような書き方を意図的に禁止することで、代入 (=) と比較 (==) の記述ミスを避けることを狙っています。"},{url:"/p/ttacror/",title:"Kotlinメモ: 関数を定義する (fun)",date:"2019-01-22T00:00:00+09:00",body:"Kotlinメモ: 関数を定義する (fun) 関数定義の基本 Kotlin で関数を定義するには fun キーワードを使用します。 Java ではすべてのメソッドは何らかのクラスに属す必要がありますが、Kotlin の場合はファイルのトップレベルに関数を定義することができます。 次の例は、2 つの整数 (Int) を受け取り、戻り値として整数 (Int) を返す関数の定義例です。 パラメータの型はパラメータ名の後ろに記述します。 関数の定義 fun max(a: Int, b: Int): Int { return if (a &gt; b) a else b } Kotlin では、if が式 (expression) 扱いになっているため、上記のように if 式の評価結果をそのまま return することができます。 関数の呼び出し方法は Java と同様です。 関数の呼び出し println(max(5, 10)) //=&gt; 10 パラメータや戻り値のない関数は下記のように記述できます。 fun greet() { println(&#34;Hello&#34;) } 戻り値がないときは関数の型は上記のように省略できますが、: Unit と明示することもできます（Java の void に相当）。 より短く関数を記述する (expression-body funtion) 下記のように { と } で囲まれた本文を持つ関数を、block body を持つ関数 (block-body function) と呼びます。 fun max(a: Int, b: Int): Int { return if (a &gt; b) a else b } 本文に 1 つの式 (expression) しか持たない場合、次のように = を使って短く記述することができます。 fun max(a: Int, b: Int) = if (a &gt; b) a else b このように記述した関数を、expression body を持つ関数 (expression-body function) と呼びます。 expression-body function の形で関数を定義する場合、Kotlin コンパイラの型推論 (type inference) 機能が働くため、多くのケースで上記のように関数の戻り値の型を省略することができます。 上記の例では関数が短いので一行で記述していますが、expression-body function であっても複数行にわたって記述することができます。 fun max(a: Int, b: Int) = if (a &gt; b) { a } else { b } fun getLongCommandName(c: Char) = when (c) { &#39;c&#39; -&gt; &#34;create&#34; &#39;d&#39; -&gt; &#34;delete&#34; &#39;e&#39; -&gt; &#34;edit&#34; else -&gt; &#34;unknown&#34; } null 許容型パラメータ Kotlin の関数のパラメータは、デフォルトでは null を渡せないようになっています。 null を渡そうとすると、Null can not be a value of a non-null type String といったコンパイルエラーが発生します。 パラメータとして null を渡すことを許容するには、パラメータの型名に ? をつけて明示する必要があります。 fun greet(name: String?) { println(&#34;Hello, $name&#34;) } fun main(args: Array&lt;String&gt;) { greet(null) //=&gt; &#34;Hello, null&#34; } 名前付き引数 下記のように 2 つのパラメーター（title と author）が同じ String 型であるとします。 fun showBook(title: String, author: String) { println(&#34;Title: $title&#34;) println(&#34;Author: $author&#34;) } この関数は次のように呼び出すことができますが、この呼び出しコードを見ただけではどちらのパラメータが title なのか author なのか判別がつきません。 showBook(&#34;Kotlin&#34;, &#34;Maku&#34;) Kotlin の 名前付き引数 の構文を使用すると、下記のようにパラメータ名とセットで値を渡すことができます。 名前付き引数を使用した場合は、パラメータの指定順序は任意になります。 showBook(title=&#34;Kotlin&#34;, author=&#34;Maku&#34;) showBook(author=&#34;Maku&#34;, title=&#34;Kotlin&#34;) ☝️ ワンポイント 残念ながら Java で記述されたメソッドに関しては、Kotlin から名前付き引数の仕組みを使って呼び出すことはできません。 Java8 のクラスファイルとしては名前付き引数の仕組みはサポートされているのですが、Kotlin は互換性のために Java6 を採用しているためこのような制約があります（2019年現在）。 デフォルト引数 関数のパラメータにデフォルト値を設定しておくと、関数呼び出し時に引数が省略された場合にその値が使用されるようになります。 下記の例では、2 番目のパラメータにデフォルト値 &quot;UNKNOWN&quot; を設定しています。 fun showBook(title: String, author: String = &#34;UNKNOWN&#34;) { println(&#34;Title: $title&#34;) println(&#34;Author: $author&#34;) } fun main() { showBook(&#34;Kotlin&#34;) } 実行結果 Title: Kotlin Author: UNKNOWN また、名前付き引数とデフォルト引数の仕組みを組み合わせて使用することで、任意のパラメータだけを指定して関数を呼び出せるようになります。 fun showBook(title: String = &#34;UNKNOWN&#34;, author: String = &#34;UNKNOWN&#34;, price: Int = 0) { println(&#34;Title: $title&#34;) println(&#34;Author: $author&#34;) println(&#34;Price: $price&#34;) } fun main() { showBook(title=&#34;Kotlin&#34;, price=3000) // author だけ省略 }"},{url:"/p/5zibnsn/",title:"Kotlinメモ: Kotlin とは？ Kotlin をインストールする",date:"2019-01-07T00:00:00+09:00",body:"Kotlinメモ: Kotlin とは？ Kotlin をインストールする Kotlin の特徴 Kotlin は Java との親和性を重視して作成されたコンパイル型の言語です。 IntelliJ IDEA の開発元である JetBrains 社によって作成された言語であり、強力な IDE のサポートがあります。 2017年の Google I/O で、Google が Android における Kotlin の公式サポートを発表したため、言語としての知名度が一気に向上しました。 Kotlin には次のような特徴があります。 Kotlin のコンパイラ (kotlinc) は、Java の仮想マシン JVM 上で動作する .class ファイルを生成します。 Kotlin で作成したコードを Java コードから簡単に呼び出せます。逆に、Kotlin から Java のコードを利用するのも容易です。 Java で作成されたフレームワークやライブラリをそのまま使用することができます。 Gradle や Ant などを使ってビルドすることができます。 上記のような特徴により、1 つのプロジェクト内に Java のコードと Kotlin のコードを共存させることができます。 Java に比べて少ない記述量で同等以上のことを実現することができます。文末のセミコロンが不要だったり、型名を省略できたり、ラッパー関数があったりします。 Java と同様に静的型付き言語 (Statically typed language) ですが、多くの場合はコンパイラによる推論 (type inference) により型名を省略できます（コンパイル時に型が確定することは変わりありません）。 Null 非許容型などを言語的にサポートするため、メンテナンス性の高いコードを記述できます。 Java と同様にオブジェクト指向言語として扱えますが、関数型プログラミング (Functional programming) を言語レベルでサポートしています。 関数をパラメータとして受け取ったり、戻り値で返したりすることができます。 Lambda 式という小さなコードブロックを受け渡しすることができます。 Data class というイミュータブルなオブジェクトを作成するための簡潔な構文が用意されています。 コレクションを関数型プログラミングのスタイルで扱う API が用意されています。 JavaScript へのトランスパイルが検討されています（Kotlin コード → JavaScript コードへの変換）。 Kotlin の開発環境のインストールと HelloWorld Kotlin Playground のサイトで試してみる 簡単な Kotlin のコードであれば、下記のサイト上で直接実行することができます。 Kotlin Playground 左側のペーンでサンプルコードを選択して Run ボタンを押せば、実行結果が下の出力エリアに表示されます。 エディタ部分には、任意のコードを入力することができるため、簡単な文法テストだけであれば、このサイト上だけで済ませてしまうことができます。 Kotlin のスタンドアロン・コンパイラ (kotlinc) を使用する Kotlin のスタンドアロン・コンパイラをインストールしておけば、kotlinc コマンドを使用して Kotlin のソースコード (.kt) をコンパイルすることができます。 下記のサイトに各環境でのインストール方法が説明されています。 Kotlin - Command Line Compiler macOS の場合 (Homebrew) $ brew update $ brew install kotlin macOS であれば、Homebrew（brew コマンド）などを使ってインストールしてしまうのが簡単です。 Windows の場合 C:\\&gt; choco install kotlinc Windows であれば、Chocolatey を使ってインストールしてしまうのが簡単です。 コマンドプロンプトを「管理者として実行」で起動して、上記のようにタイプするだけでインストールできます。 GitHub 上 Kotlin リリースページ から、実行バイナリを直接ダウンロードして使う方法もあります。 ダウンロードした zip アーカイブを展開し、bin ディレクトリに PATH を通してやれば OK です。 kotlinc コマンドが実行できるようになったら、下記のようなサンプルコードをコンパイルして実行してみましょう。 ビルド後のアプリケーションは、Java アプリケーションと同様に java コマンドを使用して実行することができます。 sample.kt fun main(args: Array&lt;String&gt;) { println(&#34;Hello, world!&#34;) } コンパイル $ kotlinc sample.kt -include-runtime -d sample.jar 実行 $ java -jar sample.jar Hello, world! kotlinc でコンパイルしたアプリケーションの実行には、Kotlin ランタイムが必要です。 kotlinc の -include-runtime オプションは、生成する JAR ファイル内にこの Kotlin ランタイムを含めてしまう指定です。 このようにして作成した JAR ファイルは、上記のように単独で実行することができます。 IDE (IntelliJ IDEA) を使用する JetBrains 社が提供している IntelliJ IDEA という統合開発環境 (IDE) は、ネイティブで Kotlin による開発をサポートしています。 Community Edition であれば無料で使用することができますので、Kotlin で本格的に開発を行いたい場合はインストールしておくとよいでしょう。 Kotlin の生みの親である JetBrains 社が作成している IDE ですので、今後も長期的にリリースが続くと思われます。 IntelliJ IDEA - JetBrains IntelliJ IDEA でプロジェクトを作成するときに、Kotlin を選択すれば開発準備 OK です。 IDE (Android Studio) を使用する Kotlin で Android アプリを作成するときは、Android Studio に Kotlin サポートを追加して使用します。 プロジェクトの作成時に下記のように Include Kotlin support にチェックを入れてやれば、スケルトンコードも Kotlin ファイルとして生成されます（MainActivity.kt などが生成されます）。"},{url:"/sass/",title:"Sass",date:"2018-12-30T00:00:00+09:00",body:"Sass 基本 Sassメモ: Sass とは／sassコマンドのインストール／sassコマンドの使い方 Sassメモ: SCSS ファイルの書き方の基本 Sassメモ: SCSS ファイルでのコメントの書き方 変数と値 Sassメモ: SCSS で変数を使用する ($var-name, !default) Sassメモ: SCSS でリスト変数を使用する Sassメモ: SCSS でマップ変数を使用する Sassメモ: 文字列変数の引用符の展開ルール 応用 Sassメモ: SCSS 内での条件分岐処理 (@if-else, if関数) Sassメモ: SCSS 内でのループ処理 (@for, @while) Sassメモ: SCSS ファイルから別の SCSS ファイルをインポートする (@import) Sassメモ: エクステンドでスタイルを継承する (@extend) Sassメモ: Mixin でスタイルを組み合わせる (@mixin, @include) Sassメモ: 関数を定義する (@function) Sassメモ: 色（カラー値）を扱う"},{url:"/p/ka8a3uc/",title:"Sassメモ: SCSS 内でのループ処理 (@for, @while)",date:"2018-12-30T00:00:00+09:00",body:"Sassメモ: SCSS 内でのループ処理 (@for, @while) Sass スクリプトで @for ディレクティブや @while ディレクティブを使用すると、数値によるループ処理を行うことができます。 主に、シンプルな数値のインクリメント（あるいはデクリメント）によるループには @for ディレクティブを使用し、より複雑なループ処理が必要な場合には @while ディレクティブを使用します。 @for ディレクティブ @for ディレクティブは下記のいずれかの構文で使用します。 @for 変数 from 開始値 through 終了値 { 処理（スタイル定義など） } @for 変数 from 開始値 to 終了値 { 処理（スタイル定義など） } いずれも 変数 の値が 開始値 から 終了値 に向かってインクリメント（あるいはデクリメント）されながらループ処理されますが、through を使った場合に 終了値 を含む値まで処理されるのに対し、to を使った場合は 終了値 に達する手前の値までしか処理されません。 下記の例を見ると、その違いが分かると思います。 入力 (SCSS) @for $i from 1 through 3 { .foo-#{$i} { width: 10px * $i; } } @for $i from 1 to 3 { .bar-#{$i} { width: 10px * $i; } } 出力 (CSS) .foo-1 { width: 10px; } .foo-2 { width: 20px; } .foo-3 { width: 30px; } .bar-1 { width: 10px; } .bar-2 { width: 20px; } 開始値 よりも 終了値 の方が小さい場合は、変数 の値は 1 つずつデクリメントされていきます。 入力 (SCSS) @for $i from 3 through 1 { .item-#{$i} { width: 10px * $i; } } 出力 (CSS) .item-3 { width: 30px; } .item-2 { width: 20px; } .item-1 { width: 10px; } @while ディレクティブ @while ディレクティブを使用すると、ある条件に一致している間処理を続けるループ処理を記述することができます。 @while ディレクティブの構文は次の通りです。 @while 条件式 { 処理（スタイル定義など） } @while ディレクティブを使用してループ処理を行う場合は、無限ループにならないように、条件式 で比較する変数の値をループ処理の中で更新してやる必要があります。 下記の例では、変数 $height の値を、ループ処理内で 10 ずつ増加させています。 入力 (SCSS) $height: 10; @while $height &lt; 50 { .space-#{$height} { margin-top: $height + px; } $height: $height + 10; } 出力 (CSS) .space-10 { margin-top: 10px; } .space-20 { margin-top: 20px; } .space-30 { margin-top: 30px; } .space-40 { margin-top: 40px; } リスト変数やマップ変数の要素のループ処理 リスト変数やマップ変数に格納された要素を 1 つずつ取り出しながらループ処理したい場合は、@each ディレクティブを使用することができます。 詳しくは、下記の記事を参照してください。 SCSS でリスト変数を使用する SCSS でマップ変数を使用する"},{url:"/p/rkk224q/",title:"Sassメモ: SCSS 内での条件分岐処理 (@if-else, if関数)",date:"2018-12-30T00:00:00+09:00",body:"Sassメモ: SCSS 内での条件分岐処理 (@if-else, if関数) @if ディレクティブ Sass スクリプトの中で @if、@else、@else if ディレクティブを使用することで、条件分岐処理を記述することができます。 下記の例では、変数 $fruit の値によってスタイルの出力を分岐させています。 入力 (SCSS) $fruit: banana; p { @if $fruit == apple { color: red; } @else if $fruit == banana { color: yellow; } @else { color: blue; } } 出力 (CSS) p { color: yellow; } 比較演算子としては、==、!=、&gt;、&gt;=、&lt;、&lt;= などを使用することができます。 論理演算子としては、and、or、not などを使用することができます（&amp;&amp; や || などはありません）。 @if ディレクティブは、Mixin や関数に渡されたパラメータを使って分岐処理したいときによく使用されます。 入力 (SCSS) @mixin highlight($inverted: false) { @if $inverted { color: white; background: red; } @else { color: red; background: white; } } strong { @include highlight(); } em { @include highlight(true); } 出力 (CSS) strong { color: red; background: white; } em { color: white; background: red; } if 関数 @if ディレクティブに似たものに、if 関数があります。 if 関数は第1パラメータの値が真 (true) の場合に第2パラメータで指定した値を返し、偽 (false) の場合に第3パラメータで指定した値を返します。 Java や C 言語の三項演算子のように使用するものです。 if(true, 1px, 2px) //=&gt; 1px if(false, 1px, 2px) //=&gt; 2px 第2パラメータ、第3パラメータの部分に式を指定した場合、それぞれの値が返されるケースでのみ、その式が評価されます。 下記の例では、この性質を利用することで 0 除算を避けています。 .foo { $denom: 0; margin: if($denom == 0, 0, 100px / $denom); }"},{url:"/p/7pq84ye/",title:"Sassメモ: 色（カラー値）を扱う",date:"2018-12-30T00:00:00+09:00",body:"Sassメモ: 色（カラー値）を扱う Color 型変数の定義方法 CSS では下記のような色の指定方法があります。 color: red; // 定数名で指定 color: #ff0000; // 16進数で指定 color: rgb(255, 0, 0); // 10進数で指定 color: rgba(255, 0, 0, 0.3); // 10進数で指定（α値あり） color: hsl(0, 100%, 50%); // HSL指定 color: hsla(0, 100%, 50%, 0.3); // HSL指定（α値あり） CSS の rgba 関数は、上記のように4つのパラメータをとりますが、Sass の rgba 関数はより柔軟なパラメータ指定が可能になっています。 color: rgba(red, 0.3); // 定数名 + α値 color: rgba(#ff0000, 0.3); // 16進数 + α値 また、Sass では名前付きパラメータを使って値を指定できるので、各パラメータの意味を明確にすることができます。 color: hsl($hue: 0, $saturation: 100%, $lightness: 50%); // 赤になる 色を表す定数の一覧 Sass スクリプトの中で色を表現する方法としては、#ff00ff のような16進数での指定方法以外にも、下記のように色を表す定数を使用する方法があります。 $my-color: magenta; // Color型の変数を定義 $my-color: #ff00ff; // 同上 色を表す定数には下記のようなものが用意されています。 aliceblue (0xF0F8FFFF) antiquewhite (0xFAEBD7FF) aqua (0x00FFFFFF) aquamarine (0x7FFFD4FF) azure (0xF0FFFFFF) beige (0xF5F5DCFF) bisque (0xFFE4C4FF) black (0x000000FF) blanchedalmond (0xFFEBCDFF) blue (0x0000FFFF) blueviolet (0x8A2BE2FF) brown (0xA52A2AFF) burlywood (0xDEB887FF) cadetblue (0x5F9EA0FF) chartreuse (0x7FFF00FF) chocolate (0xD2691EFF) coral (0xFF7F50FF) cornflowerblue (0x6495EDFF) cornsilk (0xFFF8DCFF) crimson (0xDC143CFF) cyan (0x00FFFFFF) darkblue (0x00008BFF) darkcyan (0x008B8BFF) darkgoldenrod (0xB8860BFF) darkgray (0xA9A9A9FF) darkgreen (0x006400FF) darkgrey (0xA9A9A9FF) darkkhaki (0xBDB76BFF) darkmagenta (0x8B008BFF) darkolivegreen (0x556B2FFF) darkorange (0xFF8C00FF) darkorchid (0x9932CCFF) darkred (0x8B0000FF) darksalmon (0xE9967AFF) darkseagreen (0x8FBC8FFF) darkslateblue (0x483D8BFF) darkslategray (0x2F4F4FFF) darkslategrey (0x2F4F4FFF) darkturquoise (0x00CED1FF) darkviolet (0x9400D3FF) deeppink (0xFF1493FF) deepskyblue (0x00BFFFFF) dimgray (0x696969FF) dimgrey (0x696969FF) dodgerblue (0x1E90FFFF) firebrick (0xB22222FF) floralwhite (0xFFFAF0FF) forestgreen (0x228B22FF) fuchsia (0xFF00FFFF) gainsboro (0xDCDCDCFF) ghostwhite (0xF8F8FFFF) gold (0xFFD700FF) goldenrod (0xDAA520FF) gray (0x808080FF) green (0x008000FF) greenyellow (0xADFF2FFF) grey (0x808080FF) honeydew (0xF0FFF0FF) hotpink (0xFF69B4FF) indianred (0xCD5C5CFF) indigo (0x4B0082FF) ivory (0xFFFFF0FF) khaki (0xF0E68CFF) lavender (0xE6E6FAFF) lavenderblush (0xFFF0F5FF) lawngreen (0x7CFC00FF) lemonchiffon (0xFFFACDFF) lightblue (0xADD8E6FF) lightcoral (0xF08080FF) lightcyan (0xE0FFFFFF) lightgoldenrodyellow (0xFAFAD2FF) lightgray (0xD3D3D3FF) lightgreen (0x90EE90FF) lightgrey (0xD3D3D3FF) lightpink (0xFFB6C1FF) lightsalmon (0xFFA07AFF) lightseagreen (0x20B2AAFF) lightskyblue (0x87CEFAFF) lightslategray (0x778899FF) lightslategrey (0x778899FF) lightsteelblue (0xB0C4DEFF) lightyellow (0xFFFFE0FF) lime (0x00FF00FF) limegreen (0x32CD32FF) linen (0xFAF0E6FF) magenta (0xFF00FFFF) maroon (0x800000FF) mediumaquamarine (0x66CDAAFF) mediumblue (0x0000CDFF) mediumorchid (0xBA55D3FF) mediumpurple (0x9370DBFF) mediumseagreen (0x3CB371FF) mediumslateblue (0x7B68EEFF) mediumspringgreen (0x00FA9AFF) mediumturquoise (0x48D1CCFF) mediumvioletred (0xC71585FF) midnightblue (0x191970FF) mintcream (0xF5FFFAFF) mistyrose (0xFFE4E1FF) moccasin (0xFFE4B5FF) navajowhite (0xFFDEADFF) navy (0x000080FF) oldlace (0xFDF5E6FF) olive (0x808000FF) olivedrab (0x6B8E23FF) orange (0xFFA500FF) orangered (0xFF4500FF) orchid (0xDA70D6FF) palegoldenrod (0xEEE8AAFF) palegreen (0x98FB98FF) paleturquoise (0xAFEEEEFF) palevioletred (0xDB7093FF) papayawhip (0xFFEFD5FF) peachpuff (0xFFDAB9FF) peru (0xCD853FFF) pink (0xFFC0CBFF) plum (0xDDA0DDFF) powderblue (0xB0E0E6FF) purple (0x800080FF) rebeccapurple (0x663399FF) red (0xFF0000FF) rosybrown (0xBC8F8FFF) royalblue (0x4169E1FF) saddlebrown (0x8B4513FF) salmon (0xFA8072FF) sandybrown (0xF4A460FF) seagreen (0x2E8B57FF) seashell (0xFFF5EEFF) sienna (0xA0522DFF) silver (0xC0C0C0FF) skyblue (0x87CEEBFF) slateblue (0x6A5ACDFF) slategray (0x708090FF) slategrey (0x708090FF) snow (0xFFFAFAFF) springgreen (0x00FF7FFF) steelblue (0x4682B4FF) tan (0xD2B48CFF) teal (0x008080FF) thistle (0xD8BFD8FF) tomato (0xFF6347FF) transparent (0x00000000) turquoise (0x40E0D0FF) violet (0xEE82EEFF) wheat (0xF5DEB3FF) white (0xFFFFFFFF) whitesmoke (0xF5F5F5FF) yellow (0xFFFF00FF) yellowgreen (0x9ACD32FF) アルファ値に関しては、上記のようにすべて 0xff (255) の不透過になっています。 アルファ値部分だけを変更したい場合は、下記のように rgba 関数で指定することができます。 $my-color: rgba(red, 0.3); // アルファ30% 色を調整するための関数 明度を調整する lighten() / darken() lighten 関数、darken 関数を使用すると、ある色をパーセンテージ指定で明るくしたり暗くしたりすることができます。 SCSS コード内での記述変換後 background: lighten(red, 30%); #ff9999 background: lighten(red, 20%); #ff6666 background: lighten(red, 10%); #ff3333 background: red; #ff0000 background: darken(red, 10%); #cc0000 background: darken(red, 20%); #990000 background: darken(red, 30%); #660000 彩度を調整する saturate() / desaturate() saturate 関数、desaturate 関数を使用すると、ある色の彩度をパーセンテージ指定で上げたり下げたりすることができます。 SCSS コード内での記述変換後 background: saturate(royalblue, 30%); #235aff background: saturate(royalblue, 20%); #2b5ef7 background: saturate(royalblue, 10%); #3664ec background: royalblue; #4169e1 background: desaturate(royalblue, 10%); #4c6fd6 background: desaturate(royalblue, 20%); #5774cb background: desaturate(royalblue, 30%); #627ac0 2つの色の中間色を作成する mix() mix 関数を使用すると、指定した2色の中間色を作成することができます。 第3引数（$weight パラメータ）を使って、1色目の比率を指定することもできます（デフォルトは 50%）。 SCSS コード内での記述変換後 background: mix(white, black); gray background: mix(green, yellow); #80c000 background: mix(white, black, 75%); #bfbfbf background: mix(white, black, 25%); #404040"},{url:"/p/3htu3om/",title:"Sassメモ: 関数を定義する (@function)",date:"2018-12-20T00:00:00+09:00",body:"Sassメモ: 関数を定義する (@function) Sass (SCSS) で独自関数を定義するには、下記のような構文の @function ディレクティブを使用します。 @function 関数名($引数1, $引数2) { @return 戻り値; } 関数名は、組み込みの関数とコンフリクトしないように、何らかのプレフィックスを付けることが推奨されています。 ライブラリなどを作っているのでなければ、my- とか x- とか付けておけば大丈夫だと思います。 関数には f- プレフィックス、Mixin には m- プレフィックスを付ける、といったルールを決めておくと分かりやすいかもしれません。 関数は Mixin と似ているように思われるかもしれませんが、Mixin がひとまとまりのルールセットを呼び出し側にインクルードするのに対し、関数は何らかの値を受け取って、その演算結果を値として返すために使用します（関数の方が粒度が小さい）。 下記の my-hover-color 関数は、パラメータで指定された色より若干明る目の色を返します。 ボタン要素にマウスカーソルを重ねたときの背景色を作成するために使用しています。 入力 (SCSS) $LIGHTEN_RATE: 20%; @function my-hover-color($color) { @return lighten($color, $LIGHTEN_RATE); } button { color: white; background: black; &amp;:hover { background: my-hover-color(black); } } 出力 (CSS) button { color: white; background: black; } button:hover { background: #333333; } Mixin と同様に、パラメータは名前付き引数として設定することができます。 パラメータが複数あるときは、この形式で呼び出すようにすると可読性を上げられるかもしれません。 background: my-hover-color($color: black); デフォルト引数 関数の引数にはデフォルト値を設定しておくことができます。これも Mixin と同様です。 下記の例では、my-add 関数の2番目のパラメータのデフォルト値を 100 に設定しています。 呼び出しに2番目のパラメータの指定を省略すると、100 が使用されます。 入力 (SCSS) @function my-add($a, $b: 100) { @return $a + $b; } main { margin-left: my-add(1px, 2px); margin-right: my-add(1px); } 出力 (CSS) main { margin-left: 3px; margin-right: 101px; } 可変長引数 関数の引数名の後ろに ... を付けると、可変長引数として扱うことができます。 下記の my-sum 関数は、任意の数の数値を受け取り、合計値を返します。 ここでは、その結果を @debug ディレクティブを使用して出力しています。 @function my-sum($values...) { $sum: 0; @each $x in $values { $sum: $sum + $x; } @return $sum; } @debug my-sum(1, 2, 3, 4, 5); //=&gt; 15 関数名の中のハイフンとアンダースコアは同じ Mixin や変数の名前と同様に、関数の名前の中で使用したハイフン (-) と、アンダースコア (_) は相互に置き換えが可能になっています。 my-func という名前で定義した関数は、my_func という名前で呼び出すことができます。 ただし、この振る舞いは歴史的な理由によるものなので、定義した通りの名前で呼び出すようにしましょう。"},{url:"/p/awmebxk/",title:"Sassメモ: Mixin でスタイルを組み合わせる (@mixin, @include)",date:"2018-12-19T00:00:00+09:00",body:"Sassメモ: Mixin でスタイルを組み合わせる (@mixin, @include) Sass のもっとも強力な機能とされている Mixin 機能を使用すると、部分的なスタイル定義をインクルードして使用できるようになります。 Mixin の基本 Sass の Mixin 機能は、ひとまとまりのスタイルを Mixin として定義 (@mixin) しておき、複数の場所からそのスタイルをインクルード (@include) して使用する仕組みです。 Mixin は、スタイルセットを提供する関数のようなものと考えるとわかりやすいです。 便利な Mixin を SCSS ファイルにまとめて定義しておけば、再利用可能な Sass ライブラリとして使用できます。 定義した Mixin は @include して使用しない限り CSS に出力されることはないので、Sass ライブラリの中の Mixin 定義が増えても、最終的な CSS が肥大化する心配はありません。 下記の例では、round-box という名前の Mixin を定義して、pre 要素と .ad-widget クラスのスタイル定義からインクルードしています。 入力 (SCSS) @mixin round-box { border: solid 1px gray; border-radius: 5px; padding: 10px; } pre { @include round-box; line-height: 1.3; } .ad-widget { @include round-box; background: #ccc; } 出力 (CSS) pre { border: solid 1px gray; border-radius: 5px; padding: 10px; line-height: 1.3; } .ad-widget { border: solid 1px gray; border-radius: 5px; padding: 10px; background: #ccc; } Mixin で定義したスタイルセットが、@include した位置に展開されていることが分かります。 同じコードが2か所に展開されているので、このようなシンプルな例では、@extend を使用した場合より非効率なコードになってしまいます。 このあたりは Sass のバージョンアップによって改善されるかもしれません。 とはいえ、Mixin には後述のような、引数を扱う仕組みなどがあり、@extend より使用する機会は多いでしょう。 Mixin の中で親セレクタの参照も可能 Sass のコードの中で &amp; は親セレクタを参照するために使用することができますが、Mixin の定義の中でも &amp; を使用することができます。 Mixin の定義のトップレベルで &amp; を参照すると、呼び出し元（@include したところ）のセレクタに置き換えられます。 下記は、::after 疑似要素を使用した典型的な clearfix イディオムを、Mixin で定義する例です。 入力 @mixin clearfix { &amp;::after { content: &#39;&#39;; display: block; clear: both; } } .breadcrumb { @include clearfix; float: left; margin: 10px; } 出力 (CSS) .breadcrumb { float: left; margin: 10px; } .breadcrumb::after { content: &#39;&#39;; display: block; clear: both; } ルートレベルでの Mixin の @include 下記のように、入れ子スタイルで定義した Mixin は、ルートレベルで @include して使用することができます。 入力 (SCSS) @mixin pretty-link { a { font-weight: bolder; text-decoration: none; &amp;:link { color: #36f; } // 未訪問 &amp;:visited { color: #03c; } // 訪問済 &amp;:hover { background: #def; } // マウスフォーカス &amp;:focus { background: #fdd; } // 選択中 } } // ルートレベルでインクルードできる @include pretty-link; 出力 (CSS) a { font-weight: bolder; text-decoration: none; } a:link { color: #36f; } a:visited { color: #03c; } a:hover { background: #def; } a:focus { background: #fdd; } 引数付きの Mixin を定義する Mixin には任意の数の引数を渡すことができます。 下記の color-box は、2つの引数 ($color、$border-width) を受け取るように定義しています。 入力 (SCSS) @mixin color-box($color, $border-width) { color: $color; background: lighten($color, 45%); border: solid $color $border-width; padding: 0.5em; } .warn { @include color-box(darkorange, 3px); } .error { @include color-box(red, 3px); } 出力 (CSS) .warn { color: darkorange; background: #fff4e6; border: solid darkorange 3px; padding: 0.5em; } .error { color: red; background: #ffe6e6; border: solid red 3px; padding: 0.5em; } デフォルト引数 Mixin の引数名の後ろに : デフォルト値 と記述することで、引数ごとのデフォルト値を設定しておくことができます。 入力 (SCSS) @mixin color-box($color: black, $border-width: 1px) { color: $color; background: lighten($color, 45%); border: solid $color $border-width; padding: 0.5em; } .error { @include color-box(red); // 2番目のパラメータのみ省略 } 出力 (CSS) .error { color: red; background: #ffe6e6; border: solid red 1px; padding: 0.5em; } すべてのパラメータを省略する場合は、下記のいずれの書き方でも OK です。 @include color-box(); @include color-box; 名前付き引数 (Keyword arguments) Mixin をインクルード (@include) するとき、パラメータの値を名前付きで指定することができます。 名前付き引数として値を指定するときは、引数の指定順序は任意となります。 @include color-box($border-width: 3px, $color: red); 名前付き引数を使用すると記述量は若干増えますが、それぞれのパラメータが何を表しているか明確になるというメリットがあります。 また、名前付き引数を使用することで、任意の位置のデフォルト引数のみを省略することが可能になります。 次の例では、1番目の引数 $color を省略し、2番目の引数 $border-width のみを指定して Mixin をインクルードしています。 @include color-box($border-width: 3px); 可変長引数 Mixin の引数の末尾に ... を付けると、その引数を可変長引数として扱うことができます。 例えば、CSS の box-shadow プロパティはもともと可変長のパラメータを受け付けますが、このようなプロパティを扱う Mixin は次のように定義することができます。 入力 (SCSS) @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .box { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); } 出力 (CSS) .box { -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; } 上記のように、Mixin はベンダープレフィックスの必要なプロパティをまとめて定義するためにも利用することができます。 ちなみに、... というキーワードは、リスト変数の値を展開して、複数のパラメータとして Mixin や関数に渡すためにも使用します。 入力 (SCSS) @mixin fancy-border($color, $width, $style) { border: $width $style $color; border-radius: 5px; } $value-list: green, 1px, solid; $value-map: (color: red, width: 3px, style: dashed); .success { @include fancy-border($value-list...); } .failure { @include fancy-border($value-map...); } 出力 (CSS) .success { border: 1px solid green; border-radius: 5px; } .failure { border: 3px dashed red; border-radius: 5px; } スタイルセットを Mixin のパラメータとして渡す（コンテントブロック） (@content) Mixin の定義の中で @content を参照すると、呼び出し側から渡されたスタイル定義をそこに展開することができます。 呼び出し側では、次のような構文でスタイル定義のブロックを Mixin に渡します。 @include &lt;Mixin名&gt; { Mixinに渡すスタイル定義 } この仕組みは、同じ条件のメディアクエリを複数のスタイルに対して適用するときに便利 です。 入力 (SCSS) @mixin media-large { // スクリーンの横幅が広い端末（PCなど）の場合 @media screen and (min-width: 800px) { @content; } } main { margin: 1em; // 幅が狭いときはマージンは小さく @include media-large { margin: 2em; // 幅が広いときはマージンを大きく } } #xMenu { display: none; // 幅が狭いときはメニューは表示しない @include media-large { display: block; // 幅が広いときはメニューを表示する width: 20rem; } } 出力 (CSS) main { margin: 1em; } @media screen and (min-width: 800px) { main { margin: 2em; } } #xMenu { display: none; } @media screen and (min-width: 800px) { #xMenu { display: block; width: 20rem; } } スクリーンサイズのブレイクポイントとする横幅などは、下記のように変数に定義しておくとメンテナンスしやすくなります。 $LARGE_SCREEN_WIDTH: 800px; @mixin media-large { @media screen and (min-width: $LARGE_SCREEN_WIDTH) { @content; } } ちなみに、Mixin の中で content-exists() 関数を使用すると、コンテントブロックが Mixin に渡されたかどうかを調べることができます。 Mixin 名の中のハイフンとアンダースコアは同じ 変数名や関数名も同様ですが、Mixin の名前の中で使用したハイフン (-) と、アンダースコア (_) は相互に置き換えが可能になっています。 @mixin foo-bar { color: red; } main { @include foo_bar; // ハイフンをアンダースコアに変えても参照できる } ただし、この振る舞いは歴史的な理由によるものなので、ハイフンで定義したものはハイフンを使って参照すべきでしょう。 Mixin と @extend ディレクティブの違い Sass の @extend ディレクティブも似たような機能を提供していますが、@extend はあくまで セレクタを継承 する機能であり、Mixin 機能より若干複雑な振る舞いをします。 Mixin 機能は スタイルそのものを使いまわす ものであり、@extend ディレクティブの振る舞いよりシンプルです（機能としては強力ですが）。 Mixin と @extend の違いをざっとあげると下記のような感じでしょうか。 Mixin はパラメータを扱うことができる。Mixin の定義側にコンテントブロックを渡すこともできる。 Mixin は @extend とは異なり、セレクタの組み合わせによるルールが継承されない。 Mixin をインクルードした場所にスタイル定義がコピーされて展開されるため、出力後の CSS は @extend を使ったものよりも冗長になる可能性がある。 Mixin の利用例: ベンダープレフィックス Mixin は、ベンダープレフィックスが必要なプロパティをまとめて指定するためにも活用できます。 border-radius 用の Mixin @mixin border-radius($radius: 5px) { -moz-border-radius: $radius; -webkit-border-radius: $radius; border-radius: $radius; } .box { @include border-radius(10px); } box-shadow 用の Mixin @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .box { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); }"},{url:"/p/nkv6w5b/",title:"Sassメモ: エクステンドでスタイルを継承する (@extend)",date:"2018-12-19T00:00:00+09:00",body:"Sassメモ: エクステンドでスタイルを継承する (@extend) Sass (SCSS) の @extend ディレクティブを使用すると、他のセレクタに適用されているスタイル定義を継承して使用することができます。 @extend の基本 例えば、.sample クラスのスタイル定義の中で下記のように @extend ディレクティブを使用すると、 .sample { @extend &lt;セレクタ名&gt;; } 指定したセレクタに設定されているスタイル定義を、.sample クラスに継承させることができます。 セレクタ名には、クラス名 (.foo) や HTML のタグ名 (em) などを引用符で囲まずに指定します。 下記の例では、.warn クラスに対して設定したスタイルを、.error に継承させています。 入力 (SCSS) .warn { font-weight: bolder; border: solid 3px orange; color: orange; } .error { @extend .warn; border-color: red; color: red; } 出力 (CSS) .warn, .error { font-weight: bolder; border: solid 3px orange; color: orange; } .error { border-color: red; color: red; } これで、.warn に適用したスタイルが、.error クラスにも適用されるようになります。 .error クラスは .warn クラスの性質を備えているので、.error クラスを使用するときに .warn クラスを同時に指定する必要がありません。 &lt;div class=&#34;warn&#34;&gt;警告メッセージ&lt;/div&gt; &lt;div class=&#34;error&#34;&gt;エラーメッセージ&lt;/div&gt; @extend は親クラスのセレクタ構造も継承する @extend でスタイルを継承すると、そのスタイルが単純にコピーされたかのように振る舞うだけでなく、特殊化されたスタイル構成も同時に継承されます。 これが、Extend（継承）という名前のディレクティブになっている理由です。 例えば、下記の .warn クラスは、装飾用の .large クラスと同時に使用することで、追加のスタイルを付加できるようになっています（連結セレクタ .warn.large として定義）。 このような構造があるときに、.error クラスから @extend ディレクティブを使って .warn クラスを継承すると、.error クラスの方も .large クラスと組み合わせて使用できるような構造が生成されます。 入力 (SCSS) .warn { font-weight: bolder; border: solid 3px orange; color: orange; } .warn.large { font-size: large; } .error { @extend .warn; border-color: red; color: red; } 出力 (CSS) .warn, .error { font-weight: bolder; border: solid 3px orange; color: orange; } .warn.large, .large.error { font-size: large; } .error { border-color: red; color: red; } 結果として、.large クラスは、.warn クラスだけでなく、.error クラスとも同時に使用できるようになります。 HTML &lt;div class=&#34;warn large&#34;&gt;大きな警告メッセージ&lt;/div&gt; &lt;div class=&#34;error large&#34;&gt;大きなエラーメッセージ&lt;/div&gt; @extend で継承できるセレクタと継承できないセレクタ @extend ディレクティブの構文は、@extend &lt;セレクタ名&gt; ですが、このセレクタ名の部分に指定できるセレクタは種類が限られています。 下記に、継承できるセレクタと、継承できないセレクタの種類の一覧を示します。 継承できるセレクタ 型セレクタ（タイプセレクタ） 例: strong、ul ID セレクタ 例: #main クラスセレクタ 例: .foo 連結セレクタ 例: .foo.bar、p.note、#main.bar 属性セレクタ 例: img[src$=&quot;.png&quot;]、input[type=&quot;text&quot;]、div[data-foo] 疑似クラス 例: a:hover、a:active、p:not(.sample) 疑似要素 例: p::first-line、blockquote::before 継承できないセレクタ 子孫セレクタ 例: p strong、.foo .bar 子セレクタ 例: p &gt; strong、.foo &gt; .bar 隣接セレクタ 例: h2 + h3、.foo + .bar 間接セレクタ 例: h3 ~ h3、.foo ~ .bar 親子構造を示すようなセレクタシーケンスで定義されたルールは継承できないと覚えておけばよいでしょう。 @extend 専用のプレースホルダーセレクタ (%foo) @extends ディレクティブからのみ使用するルールセットを作成するには、プレースホルダーセレクタの仕組みを使用します。 下記のように、% で始まる名称のセレクタでスタイルを定義しておくと、そのルールセットは @extend ディレクティブからの継承専用のルールセットとなります（それ自身のルールセットとしては CSS に出力されません）。 %foo { color: red; } このプレースホルダーセレクタの仕組みは、@extend 専用のスタイルを複数定義した Sass ライブラリを作成するときなどに便利です。 また、部分的に共通のスタイルを適用したいセレクタが多い場合、この仕組みをうまく使用することで SCSS コードの可読性を上げることができます。 プレースホルダーセレクタにいかに分かりやすい名前を付けるかがポイントです。 下記のサンプルでは、ボックスシャドウを設定するためのプレースホルダーセレクタ %shadow を定義し、そのスタイルを button 要素と img 要素に適用しています。 入力 (SCSS) %shadow { box-shadow: 0px 2px 2px rgba(0, 0, 0, 0.29); } button { @extend %shadow; } img { @extend %shadow; } 出力 (CSS) button, img { box-shadow: 0px 2px 2px rgba(0, 0, 0, 0.29); } @extend 対象のセレクタが存在しないときのエラーを抑制する (!optional) 例えば、下記のように @extend で %shadow セレクタを継承するように指定したときに、%shadow セレクタのルール定義が見つからない場合は、Sass プロセッサはエラーメッセージを表示します。 button { @extend %shadow; } Error: &#34;button&#34; failed to @extend &#34;%shadow&#34;. The selector &#34;%shadow&#34; was not found. Use &#34;@extend %shadow !optional&#34; if the extend should be able to fail. on line 2 of input.scss Use --trace for backtrace. @extend 対象のセレクタが見つからない場合にエラーが発生しないようにするには、!optional フラグを付けて @extend するようにします。 button { @extend %shadow !optional; } 上記の例では、プレースホルダ (%shadow) を継承していますが、普通のクラスセレクタ (.foo) を狭小する場合も同様に機能します。 @media ディレクティブ内での @extend の制約 メディアクエリを使用して環境別のスタイル定義を行っている場合、@media ブロックの中での @extend で継承できるセレクタは、同じ @media ブロック内で定義されているものに限定されます。 例えば、下記の例では、@media ブロック内から、ブロックの外で定義された .warn セレクタのスタイルを継承しようとしているのでエラーになります。 間違った例 .warn { font-weight: bolder; border: solid 3px orange; color: orange; } @media print { .error { @extend .warn; // エラー！ border-color: red; color: red; } } Error: You may not @extend an outer selector from within @media. You may only @extend selectors within the same directive. 次のように、同じ @media ブロック内で定義されたセレクタであれば @extend を使って継承することができます。 @media print { .warn { font-weight: bolder; border: solid 3px orange; color: orange; } .error { @extend .warn; // OK border-color: red; color: red; } } これは、メディアクエリの文法による制約です。 将来的な Sass のアップデートにより、@media ブロックの外のセレクタも継承できるようになる可能性はあります。 Sass でメディアクエリを使ったルール定義をスマートに行うには、Mixin の仕組みで @content ディレクティブを組み合わせて使用する方法がお勧めです。"},{url:"/p/rm99r8j/",title:"Sassメモ: SCSS でマップ変数を使用する",date:"2018-12-18T00:00:00+09:00",body:"Sassメモ: SCSS でマップ変数を使用する マップ変数を作成する Sass においてマップはリストの特殊バージョンで、リストの各要素がキー＆バリューの形 (key1:value1) になったものです。 マップを定義するには、キー＆バリューをカンマで並べ、全体を括弧 () で囲みます。 リストを定義するときは、全体の括弧を省略できるケースがありますが、マップの場合は必ず全体を括弧で囲む必要があります。 マップ変数を定義する マップ変数を定義する $map: (key1: value1, key2: value2, key3: value3); 空のマップを作成したいときは、空のリストを作成するときと同様に () を使用します。 空のマップを作成しておいて、動的に要素を追加していくという使い方ができます。 空のマップ変数を定義する（リストでもある） 空のマップ変数を定義する（リストでもある） $map: (); マップの要素をループで処理する (@each) マップの要素もリストの要素と同様に @each ディレクティブを使用してループ処理することができます。 あるルール定義の中で、マップの要素を使用してスタイル定義を出力するために使用します。 入力 (SCSS) $headers: (h1: 1.6rem, h2: 1.4rem, h3: 1.3rem, h4: 1.2rem); @each $tag, $size in $headers { #{$tag} { font-size: $size; } } 出力 (CSS) h1 { font-size: 1.6rem; } h2 { font-size: 1.4rem; } h3 { font-size: 1.3rem; } h4 { font-size: 1.2rem; } マップ用の関数一覧 リスト系の関数と同様に、マップの内容を編集する関数は、新しいマップを作成して戻り値として返します。 パラメータとして渡したマップの内容は不変であることに注意してください。 length($map) &hellip; マップの要素数を取得する マップもリストも length 関数を使って要素数を調べることができます。 length(()) //=&gt; 0 length((width: 10px, height: 20px)) //=&gt; 2 length((key1: null, null: 100)) //=&gt; 2 map-get($map, $key) &hellip; 指定したキーに対応する値を取得する map-get((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;foo&#34;) //=&gt; 1 map-get((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;bar&#34;) //=&gt; 2 map-get((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;baz&#34;) //=&gt; null 存在しないキーを指定した場合は、null を返します。 map-merge($map1, $map2) &hellip; 2つのマップをマージして新しいマップを作成する map-merge((&#34;foo&#34;: 1), (&#34;bar&#34;: 2)) // =&gt; (&#34;foo&#34;: 1, &#34;bar&#34;: 2) map-merge((&#34;foo&#34;: 1, &#34;bar&#34;: 2), (&#34;bar&#34;: 3)) //=&gt; (&#34;foo&#34;: 1, &#34;bar&#34;: 3) 体裁としては2つのマップをマージする関数ですが、マップに1つのエントリ（キー＆バリュー）を追加するときも、この map-merge 関数を使用します（要素数が1のマップをマージすればよい）。 2つのマップに同じキーのエントリがある場合は、$map2 の値が優先的に使用されます。 map-remove($map, $keys...) &hellip; マップから指定したキーを削除したマップを作成する map-remove((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;bar&#34;) //=&gt; (&#34;foo&#34;: 1) map-remove((&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 3), &#34;bar&#34;, &#34;baz&#34;) //=&gt; (&#34;foo&#34;: 1) map-remove((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;baz&#34;) //=&gt; (&#34;foo&#34;: 1, &#34;bar&#34;: 2) 最後のパラメーター $keys は可変長引数になっているので、複数のキーをまとめて削除することができます。 存在しないキーを指定した場合は何も起こりません。 map-keys($map) &hellip; マップのキーをリストにして返す map-keys((&#34;foo&#34;: 1, &#34;bar&#34;: 2)) //=&gt; &#34;foo&#34;, &#34;bar&#34; map-keys(()) //=&gt; () map-values($map) &hellip; マップの値をリストにして返す map-values((&#34;foo&#34;: 1, &#34;bar&#34;: 2)) //=&gt; 1, 2 map-values((&#34;foo&#34;: 1, &#34;bar&#34;: 2, &#34;baz&#34;: 1)) //=&gt; 1, 2, 1 複数のエントリが同じ値を持っている場合、返されるリスト内には重複した値が格納されます。 map-has-key($map, $key) &hellip; マップが指定されたキーを含んでいるかを調べる map-has-key((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;foo&#34;) //=&gt; true map-has-key((&#34;foo&#34;: 1, &#34;bar&#34;: 2), &#34;baz&#34;) //=&gt; false map-has-key((null: null), null) //=&gt; true map-has-key((), null) //=&gt; false keywords($args) &hellip; 可変長引数として渡された引数の内容を取得する @mixin foo($args...) { @debug keywords($args); //=&gt; (arg1: val, arg2: val) } @include foo($arg1: val, $arg2: val); keywords 関数を使用すると、Mixin や関数に渡された可変長引数の内容を、マップ形式にして取得することができます。 マップの要素をダンプする (inspect, @debug) Sass の inspect 関数を使用すると、マップ変数の内容を文字列形式で取得することができます。 開発時に一時的にマップ要素の内容を確認したい場合に便利です。 入力 (SCSS) $map: (key1: value1, key2: value2, key3: value3); main { dummy: inspect($map); } 出力 (CSS) main { dummy: (key1: value1, key2: value2, key3: value3); } もっとも、コンソール上でデバッグしているのであれば、@debug ディレクティブを使用して内容を出力してしまった方が早いです。 sample.scss $map: (key1: value1, key2: value2, key3: value3); @debug $map; 実行結果 $ sass sample.scss sample.scss:2 DEBUG: (key1: value1, key2: value2, key3: value3)"},{url:"/p/gm47at8/",title:"Sassメモ: SCSS でリスト変数を使用する",date:"2018-12-18T00:00:00+09:00",body:"Sassメモ: SCSS でリスト変数を使用する Sass (SCSS) には、複数の値をまとめて管理するためのデータタイプとして list 型が用意されています。 リスト型の表現方法 リスト型変数の基本 CSS でリスト型の値を定義するときは、スペース区切りかカンマ区切りで複数の値を列挙します。 例えば、次のようなプロパティを表現するために使用されます。 CSS .sample { margin: 10px 15px 0 0; font-family: Helvetica, Arial, sans-serif; } SCSS の変数には、このようなリストもそのまま格納することができます。 SCSS $my-margin: 10px 15px 0 0; $my-font: Helvetica, Arial, sans-serif; .sample { margin: $my-margin; font-family: $my-font; } リストのリスト リストの要素としてリストを含めることもできます。 下記の例では、1px 2px と 3px 4px の 2 つのリストを含むリスト変数を定義しています。 $my-list1: 1px 2px, 3px 4px; $my-list2: (1px 2px) (3px 4px); 空リストと要素が1つだけのリスト 空のリストを定義するときは、() という表現方法を使用します。 $my-list: (); Sass では、() は空のリストであり、空のマップでもあります。マップは実質的には、キー＆バリューのペア値を格納した「リスト」として扱われるためです。 要素が 1 つだけのリストを表現するには、次のように、要素の後ろにカンマ (,) を記述します。 $my-list1: (&#34;aaa&#34;,); // 要素として &#34;aaa&#34; を 1 つだけ含むリスト $my-list2: (1 2 3,); // 要素として 1 2 3 というリストを 1 つだけ含むリスト 上記のような簡単な例では括弧 (()) は省略できますが、リストであることを明確にするためにも括弧は付けておいた方がよいでしょう。 リストをループ処理する (@each) 単純なリストのループ処理 リストの要素をループ処理するには、@each ディレクティブを使用します。 あるルールの定義内で、リストやマップの内容をループ処理しながらスタイルのセットを出力するために使用することができます。 @each ディレクティブの構文は下記の通りです。 @each $var in &lt;リストorマップ&gt; { スタイル定義 } リスト内の要素を 1 つずつ $var 変数で参照しながらループ処理することができます。 イテレータとして使用する変数の名前は $var でなくても構いません。 次の例では、$fruits リスト変数に格納された要素をループ処理してスタイル定義を出力しています。 入力 (SCSS) $fruits: &#34;apple&#34;, &#34;banana&#34;, &#34;orange&#34;; @each $x in $fruits { .#{$x}-icon { background-image: url(&#39;/assets/images/#{$x}.png&#39;); } } 出力 (CSS) .apple-icon { background-image: url(&#34;/assets/images/apple.png&#34;); } .banana-icon { background-image: url(&#34;/assets/images/banana.png&#34;); } .orange-icon { background-image: url(&#34;/assets/images/orange.png&#34;); } リストのリストのループ処理 @each ディレクティブを使用して、リストのリストをループ処理することもできます。 下記の例では、リストのリストを格納した $fruits 変数の値をループ処理しています。 入力 (SCSS) $fruits: (&#34;apple&#34;, red), (&#34;banana&#34;, yellow), (&#34;orange&#34;, orange); @each $x in $fruits { $name: nth($x, 1); // 1番目の要素を取り出す（フルーツ名） $color: nth($x, 2); // 2番目の要素を取り出す（色） .#{$name}-icon { background-image: url(&#39;/assets/images/#{$name}.png&#39;); border: 2px solid $color; } } @each によるループ処理では、$fruits 内の各リスト要素が順番に取り出されるため、さらに nth 関数を使って、それらの 1 番目の要素、2 番目の要素を取り出しています。 出力 (CSS) .apple-icon { background-image: url(&#34;/assets/images/apple.png&#34;); border: 2px solid red; } .banana-icon { background-image: url(&#34;/assets/images/banana.png&#34;); border: 2px solid yellow; } .orange-icon { background-image: url(&#34;/assets/images/orange.png&#34;); border: 2px solid orange; } このように、@each ディレクティブと nth 関数を組み合わせてリストのリストをループ処理してもよいのですが、多重代入 (Multiple assignment) の仕組みを使用すると、より簡潔にリストのリストをループ処理できます。 入力 (SCSS) ─ 多重代入を使用する方法 $fruits: (&#34;apple&#34;, red), (&#34;banana&#34;, yellow), (&#34;orange&#34;, orange); @each $name, $color in $fruits { .#{$name}-icon { background-image: url(&#39;/assets/images/#{$name}.png&#39;); border: 2px solid $color; } } 上記のように、@each の後ろに複数の変数を記述すると、2階層目の要素がそれらの変数に展開されながらループ処理されます。 nth 関数で個々の要素を取り出す必要がなくなるので、簡潔かつ分かりやすいコードになります。 リスト用の関数一覧 Sass のリストを操作するための関数として、下記のような組み込み関数が定義されています。 Sass のリストは immutable （不変）であるため、パラメータとして渡したリストの内容は変更されることはなく、新しいリストが生成されて戻り値として返されることに注意してください。 ☝️ Sass 3.0.0 以降の書き方 以下の解説では built-in 関数の形で記述していますが、Sass 3.0.0 移行はモジュールシステムが導入され、リスト用の関数は list モジュールに移動しました。 次のように sass:list モジュールを読み込んで使用してください。 @use &#39;sass:list&#39;; $new-list: list.join($list1, $list2); length($list) &hellip; リストの要素数を取得する length(10px) //=&gt; 1 length(10px 20px 30px) //=&gt; 3 length((width: 10px, height: 20px)) //=&gt; 2 length((1 2 3,)) //=&gt; 1 nth($list, $n) &hellip; リストの指定した位置の要素を取得する nth(10px 20px 30px, 1) //=&gt; 10px nth(10px 20px 30px, -1) //=&gt; 30px nth((Helvetica, Arial, sans-serif), 3) //=&gt; sans-serif nth((width: 10px, length: 20px), 2) //=&gt; length, 20px Sass のインデックスは、0 始まりではなく 1 始まりであることに注意してください。 負の値はリストの末尾からの位置を表します。 set-nth($list, $n, $value) &hellip; 指定した位置の要素を置換したリストを作成する $list: 1, 2, 3, 4, 5; $new-list: set-nth($list, 3, &#34;AAA&#34;); //=&gt; 1, 2, &#34;AAA&#34;, 4, 5 元の $list 変数の値は変更されず、新しいリストを生成して返すことに注意してください。 つまり、置換後のリストを扱いたい場合は、上記のように set-nth 関数の戻り値を変数で受け取ったり、そのままプロパティ値として出力したりして使用する必要があります。 存在しないインデックスを指定すると、SyntaxError が発生します。 join($list1, $list2, [$separator, $bracketed]) &hellip; 2つのリストを結合したリストを作成する join(10px 20px, 30px 40px) //=&gt; 10px 20px 30px 40px join(10px, 20px) //=&gt; 10px 20px join(10px, 20px, comma) //=&gt; 10px, 20px join([10px], 20px) //=&gt; [10px 20px] join([10px], 20px, space, false) //=&gt; 10px 20px join([10px], 20px, comma, false) //=&gt; 10px, 20px join((blue, red), (#abc, #def)) //=&gt; blue, red, #abc, #def join((blue, red), (#abc, #def), space) //=&gt; blue red #abc #def append や set-nth 関数と同様に、join 関数は新しいリストを生成して戻り値として返すことに注意してください（$list1 と $list2 の内容は変化しません）。 生成されるリストの各要素は、$separator で指定されたセパレータ (space or comma) で区切られます。 $separator パラメータが省略された場合は、1つ目のリストに使用されているセパレータ（スペース or カンマ）がセパレータとして使用されます。 $bracketed パラメータが省略された場合は、1つ目のリストがブラケット ([]) で囲まれたリストである場合に、ブラケットリストとして返します。 append($list, $val, [$separator]) &hellip; リストの末尾に1つの要素を追加したリストを作成する append(10px 20px, 30px) //=&gt; 10px 20px 30px append((blue, red), green) //=&gt; blue, red, green append(10px 20px, 30px 40px) //=&gt; 10px 20px (30px 40px) append((), 10px) //=&gt; 10px append(10px, 20px) //=&gt; 10px 20px append(10px, 20px, comma) //=&gt; 10px, 20px append((blue, red), green, space) //=&gt; blue red green $separator が省略された場合は、元のリスト ($list) のセパレータが使用されますが、元のリストの要素数が 1 だった場合は、スペースがセパレータとして使用されます。 zip($lists...) &hellip; 複数のリストを結合し、同じインデックスの要素をリスト化した要素を持つリストを作成する zip(1px 1px 3px, solid dashed solid, red green blue) //=&gt; 1px solid red, 1px dashed green, 3px solid blue zip((1px, 1px, 3px), (solid, dashed, solid), (red, green, blue)) //=&gt; 同上 生成されたリストの各要素は、スペースで区切られます（セパレータとしてカンマを指定できません）。 index($list, $value) &hellip; 指定した値がリストのどの位置にあるか調べる index(1px solid red, solid) //=&gt; 2 index(1px solid red, dashed) //=&gt; null index((width: 10px, height: 20px), (height 20px)) //=&gt; 2 先頭要素のインデックスは 0 ではなく 1 になることに注意してください。 指定した値が見つからない場合は null を返します。 list-separator($list) &hellip; リストのセパレータ文字を取得する list-separator(1px 2px 3px) //=&gt; space list-separator((1px, 2px, 3px)) //=&gt; comma list-separator(((1 2), (3 4))) //=&gt; comma list-separator(((1, 2) (3, 4))) //=&gt; space list-separator(&#39;foo&#39;) //=&gt; space list-separator(()) //=&gt; space list-separator(null) //=&gt; space 要素数が 1 の場合と、空リストの場合は space を返します。 is-bracketed($list) &hellip; ブラケットで囲まれたリストか調べる is-bracketed(1px 2px 3px) //=&gt; false is-bracketed([1px, 2px, 3px]) //=&gt; true"},{url:"/p/vd4ym66/",title:"Sassメモ: SCSS で変数を使用する ($var-name, !default)",date:"2018-12-17T00:00:00+09:00",body:"Sassメモ: SCSS で変数を使用する ($var-name, !default) 変数定義の基本 SCSS ファイル内で変数を定義するには、下記のような構文を使用します。 $変数名: 初期値; 下記はカラー値を変数として定義する簡単な例です。 入力 (SCSS) $main-color: #333; body { color: $main-color; } 出力 (CSS) body { color: #333; } 変数の値をそのままプロパティの値として使用する場合は、上記のように $変数名 の形で参照できます。 何らかのキーワードの一部（セレクタ名の一部など）や、コメントの中で変数の値を参照する場合は、インターポレーションの形式 (#{$変数名}) で参照する必要があります。 インターポレーションで文字列変数の値を参照すると、引用符は削除されて展開されます。 入力 (SCSS) $prefix: &#34;.maku&#34;; #{$prefix}-shout { font-size: larger; } 出力 (CSS) .maku-shout { font-size: larger; } 変数のスコープ（ローカル変数） 入れ子になったルール定義の中で変数を定義すると、その変数はそのブロック内でのみ参照可能なローカル変数となります。 グローバル変数と同じ名前のローカル変数を定義した場合、ローカル変数が優先されます。 入力 (SCSS) $color: black; // グローバル変数の定義 body { color: $color; // グローバル変数の参照 } main { $color: red; // ローカル変数の定義 color: $color; // ローカル変数の参照 } 出力 (CSS) body { color: black; } main { color: red; } 変数名のハイフンとアンダースコアは同一視される 歴史的な理由により、SCSS の中で定義した変数名に含まれるハイフン (-) と、アンダースコア (_) は同一のものとして扱われます。 例えば、$main-color という名前で定義した変数は、$main_color という名前でも参照できます。 $main-color: #333; body { color: $main_color; } このルールは、Mixin の名前や関数の名前にも同様に適用されます。 変数のデフォルト値を設定する (!default) 下記のように、変数に値を設定するときに末尾に !default を付けると、その変数がまだ定義されていないとき（あるいは null が格納されているとき）にのみ代入が行われます。 入力 (SCSS) $content: &#34;First&#34;; $content: &#34;Second&#34; !default; $new-content: &#34;Third&#34; !default; main { content: $content; new-content: $new-content; } 出力 (CSS) main { content: &#34;First&#34;; new-content: &#34;Third&#34;; } この仕組みは、上書き可能な設定を持つ Sass ライブラリを作成するときに便利です。 変数に値を代入する 定義した変数に別の値を代入するには、変数の定義と同じ $変数名: 値; という構文を使用します。 次の例では、@while ループのブロックの中で、$i 変数の値を 1 ずつデクリメントしています。 入力 (SCSS) $i: 1; @while $i &lt;= 5 { h#{$i} { font-size: 1.6rem - (0.1rem * $i); } $i: $i + 1; } 出力 (CSS) h1 { font-size: 1.5rem; } h2 { font-size: 1.4rem; } h3 { font-size: 1.3rem; } h4 { font-size: 1.2rem; } h5 { font-size: 1.1rem; } 変数のデータタイプ Sass で扱える変数のデータタイプは、下記の8種類です。 number &hellip; 数値。単位なし (13, 0.3) と単位あり (5em, 10px) のものがある。 string &hellip; 文字列。引用符で囲まれたもの (&quot;foo&quot;, &quot;こんにちは&quot;) と囲まれていないもの (sans-serif, bar) がある。 color &hellip; 色を表す値 (red, #0cf2f9, rgba(255, 255, 0, 0.5)) boolean &hellip; 真偽値 (true, false) null &hellip; null list &hellip; スペースやカンマで区切られた値のリスト (1em 2em 1em 0.5em, Helvetica, Arial, sans-serif) map &hellip; キー＆バリューのリスト。全体を括弧で囲んで定義する ((key1:value1, key2:value2)) function &hellip; get-function(&quot;関数名&quot;) で返される関数への参照。call($func, $args...) で呼び出せる Sass の type-of 関数を使用すると、指定した変数のデータタイプを確認することができます。 入力 (SCSS) $color: red; #message { content: &#34;red is &#34; + type-of($color); } 出力 (CSS) #message { content: &#34;red is color&#34;; }"},{url:"/p/hqpo9s9/",title:"Sassメモ: SCSS ファイルから別の SCSS ファイルをインポートする (@import)",date:"2018-12-17T00:00:00+09:00",body:"Sassメモ: SCSS ファイルから別の SCSS ファイルをインポートする (@import) インポートの基本 SCSS の @import ディレクティブを使用すると、SCSS ファイルから別の SCSS ファイルをインポートすることができます。 入力 (SCSS) @import &#34;colors.scss&#34;; // 拡張子は省略可能 main { color: $main-color; } インポートされるファイル (colors.scss) // 色の定義 $main-color: black; 出力 (CSS) main { color: black; } 複数の SCSS ファイルをインポートしたいときは、複数行に分けて @import ディレクティブを記述してもよいですし、次のようにカンマ区切りでまとめてインポートすることもできます。 @import &#34;foo&#34;, &#34;bar&#34;, &#34;hoge&#34;; CSS 標準の @import ディレクティブとして使用する @import ディレクティブ自体は、通常の CSS に搭載されている機能であり、上記のように SCSS ファイルをその場所にインポートして展開する機能は、Sass によって追加された拡張機能です。 次のような一定のルールに従って @import ディレクティブを使用すると、従来の CSS の @import ディレクティブとして使用されたとみなされ、@import の行がそのまま出力されます（インポートしたファイルの内容がインライン展開されません）。 入力 (SCSS) // 拡張子が .css である @import &#34;colors.css&#34;; // メディアクエリが付いている @import &#34;colors&#34; screen; // URLで指定されている @import &#34;http://example.com/colors&#34;; // url() 関数で指定されている @import url(colors); 出力 (CSS) @import url(colors.css); @import &#34;colors&#34; screen; @import &#34;http://example.com/colors&#34;; @import url(colors); パーシャル SCSS ファイル (Partials) インポートして使用する SCSS ファイルの名前を、アンダースコア (_) で始まる名前にしておくと、Sass プロセッサによってそのファイル自体が CSS にコンパイルされるのを防ぐことができます。 例えば、インポート用の色定義ファイルを _colors.scss として作成しておけば、Sass プロセッサは colors.css を生成しません。 _colors.scss ファイルをインポートして使用するときは、アンダースコアを除いた名前でインポートすることができます。 @import &#34;colors&#34;; // &#34;_colors.scss&#34; のインポート インポートして使うことが分かっている SCSS ファイルに関しては、アンダースコアで始まるファイル名で作成しておくとよいでしょう。 ネストされたインポート (Nested @import) ネストされたルール定義の中で @import ディレクティブを使用して SCSS ファイルをインポートすると、その階層に SCSS ファイルの内容が展開されます。 入力 (SCSS) main { @import &#34;emphasize&#34;; } インポートされるファイル (_emphasize.scss) .emphasize { font-weight: bolder; color: red; } 出力 (CSS) main .emphasize { font-weight: bolder; color: red; } セレクタが main .emphasize と、同一階層に展開されているので最初は分かりにくいかもしれませんが、下記のように @import の位置にそのままインポートされてから、最終的に上記のような結果になると考えると理解できると思います。 main { .emphasize { font-weight: bolder; color: red; } } インデックスファイル (Index file) あるディレクトリの中に _index.scss ファイルを作成しておくと、そのファイルは @import &quot;ディレクトリ名&quot; という指定でインポートできるようになります。 この仕組みを使用すると、複数の SCSS ファイルから構成される SCSS ライブラリを、ディレクトリ単位でまとめて提供することができます（パッケージのように扱える）。 下記は、mylib という SCSS パッケージ（ディレクトリ）を作成して使用する例です。 入力 (SCSS) @import &#34;mylib&#34; インポートされるファイル (mylib/_index.scss) // 同じディレクトリにあるサブ SCSS ファイル群をインポート @import &#34;sub1&#34;; @import &#34;sub2&#34;; @import &#34;sub3&#34;; _sub1.scss、_sub2.scss、_sub3.scss は全て mylib ディレクトリに格納しておきます（内容は任意なので省略）。 このように一連の SCSS ファイルをパッケージングしておくと、上記のようにインデックスファイル経由でまとめてインポートすることもできるし、次のように個別にインポートすることもできるようになります。 @import &#34;mylib/sub1&#34;;"},{url:"/p/katvaa5/",title:"Sassメモ: SCSS ファイルでのコメントの書き方",date:"2018-12-17T00:00:00+09:00",body:"Sassメモ: SCSS ファイルでのコメントの書き方 SCSS の2種類のコメント形式 CSS のコメントは /* と */ で囲む1種類のコメント形式しかありませんが、SCSS では、一行コメント (//) と、複数行コメント (/* ～ */) の2種類のコメントを使用することができます。 SCSS でのみ使用可能な一行コメント (//) の方は、CSS に変換される際に削除されます。 複数行コメント（/* から */ まで） &hellip; CSS への変換後もそのままコメントとして残る 一行コメント（// から行末まで） &hellip; CSS への変換時に削除される 入力 (SCSS) /* * このコメントスタイルでは、 * 複数行をコメントアウトすることができます。 * CSS への変換後もコメントとして残ります。 */ body { color: black; } // これらの一行コメントは、 // CSS へ変換する際に削除されます。 strong { color: red; } 出力 (CSS) /* * このコメントスタイルでは、 * 複数行をコメントアウトすることができます。 * CSS への変換後もコメントとして残ります。 */ body { color: black; } strong { color: red; } TODO コメントなど、開発時にのみ参照したいコメントは一行コメントで記述しておくとよいでしょう。 CSS への変換時に複数行コメントを削除する SCSS ファイル内に記述した一行コメント (//) は CSS への変換時に自動的に削除されますが、複数行スタイルのコメント (/* ～ */) はデフォルトではそのまま残されます。 ただし、CSS への変換時に、--style compressed オプションを指定すると、複数行スタイルのコメントも削除されて出力されます。 $ scss --style compressed input.scss Copyright 表示のような、消えては困るコメントに関しては、下記のように複数行コメントの先頭に ! を記述します。 /*! * Copyright 2018 Maku */ body { color: #333; } コメント内での変数の参照（インターポレーション） SCSS のコメント記述内で変数 ($var) の値を参照するには、#{$var} という形式で参照します。 この参照の仕方をインターポレーション (interpolation) と呼びます。 // 変数の定義 $author: &#34;Maku&#34;; // コメント内での変数の参照 /* This CSS is created by #{$author} */ 参考: SCSS で変数を使用する"},{url:"/p/by8fhor/",title:"Sassメモ: 文字列変数の引用符の展開ルール",date:"2018-12-17T00:00:00+09:00",body:"Sassメモ: 文字列変数の引用符の展開ルール 引用符で囲まれた文字列、囲まれていない文字列 Sass の文字列変数には、引用符で囲まれた文字列と、囲まれていない文字列の 2 種類があります。 文字列変数を $変数 の形で参照すると、変数定義時の引用符のありなしがそのまま反映されて展開されます。 入力 (SCSS) $family1: &#34;Lucida Grande&#34;; $family2: &#39;Lucida Sans&#39;; $family3: sans-serif; main { font-family: $family1, $family2, $family3; } 出力 (CSS) main { font-family: &#34;Lucida Grande&#34;, &#34;Lucida Sans&#34;, sans-serif; } インターポレーション セレクタ名やコメント、文字列の中で文字列変数を参照する場合は、#{$変数} のようなインターポレーション形式で参照する必要があります。 入力 (SCSS) $name: &#34;maku&#34;; /* これはコメントです by #{$name} */ .note-#{$name} { content: &#34;I am #{$name}&#34; } 出力 (CSS) @charset &#34;UTF-8&#34;; /* これはコメントです by maku */ .note-maku { content: &#34;I am maku&#34;; } 入力ファイルのエンコーディング形式を判別して、@charset ディレクティブまで自動で挿入してくれるみたいですね。 インターポレーション (#{}) で文字列変数を参照すると、変数定義時に付いていた引用符が削除されるという効果があります（後述の unquote 関数を使う方法もあります）。 入力 (SCSS) $family: &#34;sans-serif&#34;; main { font-family: $family; font-family: #{$family}; } 出力 (CSS) main { font-family: &#34;sans-serif&#34;; font-family: sans-serif; } 引用符を外す関数 (unquote) Sass の unquote 関数を使用すると、明示的に文字列の引用符 (&quot;) を取り除くことができます。 入力 (SCSS) $family: &#34;sans-serif&#34;; main { font-family: unquote($family); } 出力 (CSS) main { font-family: sans-serif; } 文字列を結合する 文字列は + 演算子を使って結合することができます。 main { font-family: &#34;Lucida &#34; + &#34;Grande&#34;; //=&gt; &#34;Lucida Grande&#34; font-family: sans- + serif; //=&gt; sans-serif } 引用符で囲まれた文字列と囲まれていない文字列を結合した場合、+ の左側が引用符で囲まれているかどうかで結合結果が引用符で囲まれるかどうかが決まります。 main { font-family: &#34;Lucida &#34; + Grande; //=&gt; &#34;Lucida Grande&#34; font-family: sans- + &#34;serif&#34;; //=&gt; sans-serif } ただし、文字列以外の値と、引用符で囲まれた文字列の結合結果は、必ず引用符で囲まれた文字列になります。 main { content: red + &#34; ocean&#34;; //=&gt; &#34;red ocean&#34; （color型との結合） content: 10 + &#34; miles&#34;; //=&gt; &#34;10 miles&#34; （number型との結合） }"},{url:"/p/tx93n26/",title:"Sassメモ: Sass とは／sassコマンドのインストール／sassコマンドの使い方",date:"2018-12-12T00:00:00+09:00",body:"Sassメモ: Sass とは／sassコマンドのインストール／sassコマンドの使い方 Sass とは Sass は CSS (Cascading Style Sheets) ファイルを効率的に作成するための変換ツールで、Hampton Catlin (ハンプトン・キャトリン) と Nathan Weizenbaum (ネイサン・バイゼンバウム) によって作成されました。 従来の CSS には存在しない変数の仕組みや、ループ処理、モジュールの仕組みなどを使用できるため、効率的に CSS ファイルを作成することができます。 変数の仕組みなどは、CSS のバージョンアップとともにネイティブでサポートされつつありますが、Web ブラウザによって対応状況がまちまちだったりするため、Sass を使って多くのブラウザがサポートしている CSS フォーマットに変換するという方法はまだまだ有効です。 SASS 記法と SCSS 記法 Sass へのインプットに使用するファイルは、「SASS フォーマット」 あるいは 「SCSS フォーマット」 で記述します。 どちらも変換後は CSS ファイルになるのですが、記述方法が若干異なります。 SASS 記法: .sass 拡張子でファイルを作成する。Jade や Python のようにインデントによって構造化する。昔使われていた記法。 SCSS 記法: .scss 拡張子でファイルを作成する。CSS と同様に括弧 ({ と }) で構造化する。Sassy CSS の略で、Sass 3.0 で導入された。現在主流の記法。 現在は、CSS と互換性のある SCSS フォーマットで記述するのが主流です。 CSS ファイルは SCSS ファイルとしても正しい文法とみなせるため、とりあえず .scss 拡張子のファイルに従来の CSS フォーマットでスタイル定義しておいて、徐々に SCSS の機能を使って内容を充実させていく、といった使い方が可能です。 sass コマンドをインストールする scss/sass ファイルを css ファイルに変換するための sass コマンドは、Sass: Install Sass のページに記述された手順に従って簡単にインストールすることができます。 例えば、Node.js の環境がインストールされている環境であれば、npm (node package manager) を使用して、次のようにインストールできます。 $ npm install -g sass インストールが完了したら、下記のように sass コマンドを実行できるようになります。 $ sass --version 1.15.2 compiled with dart2js 2.1.0 Static Web サイトジェネレータである Hugo、Jekyll (GitHub Pages)、Middleman などには、組み込みで Sass の機能が備えられているため、これらのツール上で Sass の機能を使用するだけであれば、sass コマンドを単体でインストールする必要はありません（参考: まくまく Hugo ノート）。 ただ、Sass の振る舞いを確認するために単体の sass コマンドをインストールしておくのもよいでしょう。 sass コマンドの使い方 scss ファイルを css に変換する $ sass sass/input.scss css/output.css 入力ファイル (sass/input.scss) $COLOR_MAIN: #333; body { color: $COLOR_MAIN; } 変換結果 (css/output.css) body { color: #333; } /*# sourceMappingURL=output.css.map */ 出力ファイル名を指定しないで実行すると、変換結果は標準出力に出力されます。 $ sass sass/input.scss body { color: #333; } scss ファイルの変更を監視する 下記のように --watch オプションを付けて実行すると、入力ファイル (input.scss) を監視するモードで起動します。 input.scss の内容が変更されたとき（上書き保存されたとき）に、自動的に変換が行われて出力ファイル (output.css) の内容が更新されます。 $ sass --watch input.scss output.css インタラクティブモード 単体の sass コマンドをインストールしておくと、インタラクティブモード（対話モード）で sass のプロセッサを起動することができます。 Sass の関数の動作を確認したり、算術演算の結果を確認したいときに便利です。 インタラクティブモードを起動するには、sass コマンドの実行時に -i オプションを指定します。 $ sass -i &gt;&gt; 10px + 10px 20px &gt;&gt; 10px * 10 100px &gt;&gt; 10px * 10px 100px*px &gt;&gt; lighten(#8cd, 20%) #d7eef4 &gt;&gt; darken(#8cd, 20%) #39aac6 インタラクティブモードでは、Sass の関数は呼び出せますが、ディレクティブ（@for など）は使用できないようです。 &gt;&gt; @for $i from 1 through 3 SyntaxError: Invalid CSS after &#34;&#34;: expected expression (e.g. 1px, bold), was &#34;@for $i from 1 ...&#34;"},{url:"/p/34uu8u7/",title:"Sassメモ: SCSS ファイルの書き方の基本",date:"2018-12-12T00:00:00+09:00",body:"Sassメモ: SCSS ファイルの書き方の基本 Sass (SCSS) を使用すると、CSS では扱えないネスト構造でのスタイル記述が可能になります。 Sass には多くの機能がありますが、このネストの仕組みだけでも Sass 導入の価値があります。 入れ子構造 従来の CSS は、一階層のセレクタブロック（{ ～ }）でしかルールセットを記述できませんが、SCSS では下記のような入れ子構造で定義していくことができます。 入力 (SCSS) #main { width: 97%; p, div { font-size: 2em; a { font-weight: bold; } } pre { font-size: 3em; } } 上記のような入れ子構造は子孫セレクタを表現しているとみなされ、Sass プロセッサにより、下記のようにフラットな構造の CSS に展開されます。 出力 (CSS) #main { width: 97%; } #main p, #main div { font-size: 2em; } #main p a, #main div a { font-weight: bold; } #main pre { font-size: 3em; } 子孫セレクタ以外のセレクタシーケンス（子セレクタ (&gt;) や隣接セレクタ (+)）なども、同様に入れ子の形で定義することができます。 入力 (SCSS) .xArticle { &gt; h2 { font-size: 1.4rem; margin-top: 1.5em; } } p { + ul { margin-top: 2em; } } 出力 (CSS) .xArticle &gt; h2 { font-size: 1.4rem; margin-top: 1.5em; } p + ul { margin-top: 2em; } 親セレクタの参照 (&amp;) SCSS のネストされたスタイル定義において、&amp; 記号を使用すると、親セレクタの名前を省略して記述することができます。 この記法は、下記のような :hover 擬似クラスなどでよく使用されます。 入力 (SCSS) #main { color: #333; a { font-weight: bold; &amp;:hover { color: red; } } } 出力 (CSS) #main { color: #333; } #main a { font-weight: bold; } #main a:hover { color: red; } &amp; を使用して定義したルールは、階層としては親セレクタと同じレベルに出力されることに注意してください（SCSS の記述では入れ子になっていますが、CSS に変換された後はひとつ上のレベルに出力されます）。 この仕組みは、クラス名のプレフィックスとして親クラスの名前を付けるときにも使用することができます。 BEM のようなネーミングルールを採用している場合は、この仕組みを使用すると、簡潔にネスト構造を表現できるようになります。 入力 (SCSS) .menu { color: #333; border: 1px solid #D5D5D5; &amp;__section { font-weight: bold; } &amp;__item { color: blue; } } 出力 (CSS) .menu { color: #333; border: 1px solid #D5D5D5; } .menu__section { font-weight: bold; } .menu__item { color: blue; } ネームスペース機能 CSS にはネームスペースという概念があり、例えば、font ネームスペースには、font-family、font-size、font-weight などのプロパティが定義されています（ハイフンでネームスペースの区切りを表しています）。 SCSS では、このような特定のネームスペース下のプロパティを、入れ子の形でまとめて定義することができます。 入力 (SCSS) .funky { font: { family: fantasy; size: 30em; weight: bold; } } 出力 (CSS) .funky { font-family: fantasy; font-size: 30em; font-weight: bold; } 下記のように記述すれば、font プロパティそのものに対して値を設定することも可能です。 入力 (SCSS) .funky { font: 20px/24px fantasy { weight: bold; } } 出力 (CSS) .funky { font: 20px/24px fantasy; font-weight: bold; } @media ディレクティブの入れ子 通常の CSS では、@media ディレクティブはルートレベルに記載する必要がありますが、SCSS ではセレクタブロックの中に記述することができます。 これにより、同じセレクタを複数個所に定義する必要がなくなります。 入力 (SCSS) #sidebar { display: none; // 幅が狭いときはサイドバーは表示しない float: none; @media screen and (min-width: 800px) { display: block; // 幅が広いときはサイドバーを表示 float: right; width: 20rem; margin-left: 1rem; background: #ccc; } } 出力 (CSS) #sidebar { display: none; float: none; } @media screen and (min-width: 800px) { #sidebar { display: block; float: right; width: 20rem; margin-left: 1rem; background: #ccc; } } @media ディレクティブを入れ子で使用すると、それぞれのクエリが and で接続された状態で出力されます。 入力 (SCSS) @media screen { #sidebar { @media (orientation: landscape) { width: 500px; } } } 出力 (CSS) @media screen and (orientation: landscape) { #sidebar { width: 500px; } } ちなみに、メディアクエリを使用したスタイル定義は、Mixin の機能でコンテントブロック (@content) を使用するとよりきれいに記述することができます。"},{url:"/p/3b52x28/",title:"Node.jsメモ: モジュール自身のコードにテストコードを記述する (require.main)",date:"2018-12-10T00:00:00+09:00",body:"Node.jsメモ: モジュール自身のコードにテストコードを記述する (require.main) Node.js で実行中のプログラムから require.main を参照すると、エントリポイントとして起動した module インスタンスを参照することができます。 つまり、下記のようにして、エントリポイントとして起動された JavaScript ファイルかどうかを判別することができます。 if (require.main === module) { // このモジュールを node で直接起動した場合のみ実行される } あるいは、下記のように判定することもできます。 if (require.main.filename === __filename) { // ... } この仕組みを利用して、あるモジュールのテストコードを、そのモジュールのコード内に埋め込むことができます。 下記は、add 関数と subtract 関数を提供する簡単なモジュールのサンプルです。 mymath.js function add(a, b) { return a + b; } function subtract(a, b) { return a - b; } module.exports = { add: add, subtract: subtract }; // このモジュール自身のテストコード if (require.main === module) { let assert = require(&#39;assert&#39;); assert.equal(add(1, 2), 3); assert.equal(subtract(1, 2), -1); } 末尾に記述されているテストコードは、下記のように直接モジュールを起動することで実行できます。 $ node mymath.js 逆に、他の JavaScript コードからこのモジュールをロードする場合は、テストコードの部分は実行されません。 main.js var mymath = require(&#39;./mymath&#39;); // テストコードは実行されない console.log(mymath.add(100, 50)); // =&gt; 150"},{url:"/p/uf6zrk6/",title:"Node.jsメモ: 外部の JSON ファイルを読み込む (require)",date:"2018-12-10T00:00:00+09:00",body:"Node.jsメモ: 外部の JSON ファイルを読み込む (require) Node.js の require は、外部の JSON ファイルを読み込むのにも使用することができます。 下記は、設定情報を settings.json というファイルに記述しておき、その情報を読み込む例です。 settings.json { &#34;srcDir&#34;: &#34;src/main/js&#34;, &#34;testDir&#34;: &#34;src/test/js&#34; } main.js var settings = require(&#39;./settings.json&#39;); // 拡張子は省略可能 console.log(settings.srcDir); //=&gt; &#39;src/main/js&#39; console.log(settings.testDir); //=&gt; &#39;src/test/js&#39; 上記では require に渡すファイル名として ./settings.json と拡張子まで指定していますが、./settings のように拡張子を省略することもできます。 ただし、同じディレクトリに ./settings.js があると、そちらが優先的に読み込まれてしまうので注意してください（拡張子だけ異なるファイルは作らない方がよいです）。"},{url:"/p/jbi9ojq/",title:"Hugo で参照するデータファイルをショートコードのパラメータで切り替える",date:"2018-12-07T00:00:00+09:00",body:"Hugo で参照するデータファイルをショートコードのパラメータで切り替える 下記の記事では、data ディレクトリの基本的な使い方を説明しています。 全ページから参照できるデータを用意する（data ディレクトリ） ここではもう少し踏み込んで、ショートコードを使って、パラメータで指定した名前のデータファイルを読み込めるようにしてみます。 まず、サンプルデータとして下記のようなデータファイルを用意します。 ファミコンのゲームタイトルの一覧です。 data/games/nes.yaml （データファイル） - title: ドンキーコング date: 1983-07-15 maker: 任天堂 - title: ドンキーコングJR. date: 1983-07-15 maker: 任天堂 - title: ポパイ date: 1983-07-15 maker: 任天堂 次に、このデータファイルを使って、HTML の table として出力するショートコードを作成します。 layouts/shortcodes/games.html （ショートコード） &lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;発売日&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;&lt;th&gt;メーカー&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {{- range .Site.Data.games.nes }} &lt;tr&gt;&lt;td&gt;{{ .date }}&lt;/td&gt;&lt;td&gt;{{ .title }}&lt;/td&gt;&lt;td&gt;{{ .maker }}&lt;/td&gt;&lt;/tr&gt; {{- end }} &lt;/tbody&gt; &lt;/table&gt; コンテンツページから、次のように使用することができます。 content/ref/nes-games.md --- title: &#34;ファミコンのゲームタイトル一覧&#34; --- {{% games %}} 上記のショートコードは、data/games/nes.yaml という決まったデータファイルを読み込むようにしていますが、下記のようにすれば、パラメータで指定した YAML ファイルを読み込めるようになります。 こうすることで、例えば、スーパーファミコンのタイトルリストを別の YAML ファイルで作成しておき、同じショートコードを使ってテーブル出力できるようになります。 layouts/shortcodes/games.html （ショートコード） &lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;発売日&lt;/th&gt;&lt;th&gt;タイトル&lt;/th&gt;&lt;th&gt;メーカー&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {{- range (index .Site.Data.games (.Get 0)) }} &lt;tr&gt;&lt;td&gt;{{ .date }}&lt;/td&gt;&lt;td&gt;{{ .title }}&lt;/td&gt;&lt;td&gt;{{ .maker }}&lt;/td&gt;&lt;/tr&gt; {{- end }} &lt;/tbody&gt; &lt;/table&gt; .Get 0 という部分で、ショートコードに渡されたパラメータ（例えば nes）を取得しています。 この games ショートコードは下記のように使用します。 ショートコードのパラメータとして、nes、snes を指定することで、それぞれデータファイルとして nes.yaml、snes.yaml が使用されます。 content/ref/nes-games.md --- title: &#34;ファミコンのゲームタイトル一覧&#34; --- {{% games nes %}} content/ref/snes-games.md --- title: &#34;スーパーファミコンのゲームタイトル一覧&#34; --- {{% games snes %}}"},{url:"/p/7srzpt3/",title:"Node.jsメモ: npm コマンドでインストールされている Node.js 用パッケージの一覧を表示する (npm list, ll)",date:"2018-11-22T00:00:00+09:00",body:"Node.jsメモ: npm コマンドでインストールされている Node.js 用パッケージの一覧を表示する (npm list, ll) npm install によってインストールされた Node パッケージの一覧は、npm list コマンドで確認することができます（エイリアスとして npm ls も使用可能）。 $ npm list # ローカルモードでインストールしたパッケージを一覧表示 $ npm list -g # グローバルモードでインストールしたパッケージを一覧表示 各パッケージが依存しているパッケージに関しても、階層構造ですべて表示してくれます。 例: require パッケージがインストールされている場合 D:\\y\\sandbox&gt; npm list D:\\y\\sandbox `-- require@2.4.20 +-- std@0.1.40 `-- uglify-js@2.3.0 +-- async@0.2.10 +-- optimist@0.3.7 | `-- wordwrap@0.0.3 `-- source-map@0.1.43 `-- amdefine@1.0.1 npm list の代わりに、npm la や npm ll を使用すると、より詳細な情報を表示することができます。 D:\\y\\sandbox&gt; npm ll | D:\\y\\sandbox | `-- require@2.4.20 | javascript module management! brings node&#39;s require statement to the browser | git://github.com/marcuswestin/require.git | https://github.com/marcuswestin/require +-- std@0.1.40 | javascript standard library | git://github.com/marcuswestin/std.js.git | https://github.com/marcuswestin/std.js#readme `-- uglify-js@2.3.0 | JavaScript parser, mangler/compressor and beautifier toolkit | git+https://github.com/mishoo/UglifyJS2.git | http://lisperator.net/uglifyjs +-- async@0.2.10 | Higher-order functions and common patterns for asynchronous code | git+https://github.com/caolan/async.git | https://github.com/caolan/async#readme +-- optimist@0.3.7 | | Light-weight option parsing with an argv hash. No optstrings attached. | | git+ssh://git@github.com/substack/node-optimist.git | | https://github.com/substack/node-optimist#readme | `-- wordwrap@0.0.3 | Wrap those words. Show them at what columns to start and stop. | git://github.com/substack/node-wordwrap.git | https://github.com/substack/node-wordwrap#readme `-- source-map@0.1.43 | Generates and consumes source maps | git+ssh://git@github.com/mozilla/source-map.git | https://github.com/mozilla/source-map `-- amdefine@1.0.1 Provide AMD&#39;s define() API for declaring modules in the AMD format git+https://github.com/jrburke/amdefine.git http://github.com/jrburke/amdefine"},{url:"/p/akf8eh9/",title:"Node.jsメモ: npm コマンドでインストール可能なパッケージを検索する (npm search)",date:"2018-11-22T00:00:00+09:00",body:"Node.jsメモ: npm コマンドでインストール可能なパッケージを検索する (npm search) npm search コマンドを使用すると、npm によって取得可能なパッケージを検索することができます。 例えば、次のように実行すると、パッケージ名や Description、キーワードリストなどに express という単語が含まれているパッケージの一覧を表示することができます。 例: express に関するパッケージを検索 $ npm search express NAME | DESCRIPTION | AUTHOR | DATE | VERSION | KEYWORDS express | Fast,… | =dougwilson… | 2018-10-11 | 4.16.4 | express framework sinatra web rest restful router app api path-to-regexp | Express style path… | =blakeembrey… | 2018-08-26 | 2.4.0 | express regexp route routing cors | Node.js CORS… | =dougwilson… | 2018-11-04 | 2.8.5 | cors express connect middleware morgan | HTTP request logger… | =dougwilson | 2018-09-11 | 1.9.1 | express http logger middleware ... また、下記の npm のホームページでパッケージを検索することもできます。 https://www.npmjs.com"},{url:"/p/3i3j2hx/",title:"Linux シェルスクリプト: expect で外部コマンドの出力を待機する",date:"2018-11-10T00:00:00+09:00",body:"Linux シェルスクリプト: expect で外部コマンドの出力を待機する Linux や macOS の expect コマンドを使用すると、任意のコマンドの出力を待ち受けて、自動でそれに応答するといったことを実現できます。 expect の基本的な使い方 expect がインストールされていない場合は、パッケージ管理ツール（apt や yum）を使用してインストールしてください（macOS には最初からインストールされています）。 まずは、簡単な例として、下記のような簡単なユーザ入力を必要とするスクリプトを自動で動作させてみます。 greet.sh #!/bin/bash echo -n &#34;Enter your name: &#34; read name echo &#34;Hello, $name&#34; これをそのまま実行すると、下記のようにユーザ入力の待ち受け状態となります。 $ ./greet.sh Enter your name: このような状態になったときに、自動的に入力を行うには、下記のように expect -c コマンドを使ったシェルスクリプトを作成します。 sample.sh #!/bin/bash expect -c &#34; set timeout 3 spawn ./greet.sh expect \\&#34;Enter your name:\\&#34; send \\&#34;Maku\\n\\&#34; interact &#34; expect -c の後ろのダブルクォートで囲まれた部分には、expect で実行するスクリプトを記述します。 この中でダブルクォートを使用したいときは、\\&quot; のようにエスケープしなければいけないことに注意してください。 スクリプト中の各行は次のような意味を持っています。 set timeout 3 &hellip; 外部プログラムの実行を 3 秒待つ spawn ./greet.sh &hellip; 指定した外部プログラム (./greet.sh) を実行する expect &quot;Enter your name:&quot; &hellip; 外部プログラムの出力 (Enter your name:) を待つ send &quot;Maku\\n&quot; &hellip; 外部プログラムに Maku → Enter と入力する interact &hellip; 外部プログラムとのインタラクションへ戻る 上記のシェルスクリプトを実行すると、外部プログラム greet.sh の入力待ちに対して、自動的に Maku という入力を行います。 実行結果 $ ./sample.sh spawn ./greet.sh Enter your name: Maku Hello, Maku コマンドラインからのパスワード入力を自動化する あまりよくない例かもしれませんが、ssh や rsync コマンドなどのパスワード入力も同様に自動化することができます。 下記のスクリプトを実行すると、ssh コマンドがパスワード入力を求めてきたときに、自動でパスワードを入力してログイン処理が完了します。 例: ssh 接続時のパスワード入力を自動化 (autologin.sh) #!/bin/bash expect -c &#34; set timeout 3 spawn ssh username@example.com expect \\&#34;password:\\&#34; send \\&#34;x5sd6sfc\\n\\&#34; interact &#34; 実行結果 $ ./autologin.sh spawn ssh username@example.com username@examle.com&#39;s password: Last login: Sat Nov 10 19:58:51 2018 from hogehoge.ap.example.jp username$ ログイン後に、何らかのコマンド（例えば ls -aFl）を実行するところまで自動化したいのであれば、下記のようにプロンプトの $ を待ち受けて次の入力を行えばよいでしょう。 #!/bin/bash expect -c &#34; set timeout 3 spawn ssh username@example.com expect \\&#34;password:\\&#34; send \\&#34;x5sd6sfc\\n\\&#34; expect \\&#34;$\\&#34; send \\&#34;ls -aFl\\n\\&#34; interact &#34; ちなみに、rsync コマンドでファイル転送するときも同様にパスワード入力を自動化できます。 #!/bin/bash expect -c &#34; spawn rsync -r -h -v --delete public user@example.com:public expect \\&#34;Password:\\&#34; send \\&#34;abcabcabc\\n\\&#34; interact &#34; ただし、このような使い方をすると、シェルスクリプトにパスワードをそのまま記述することになるので、ファイルの保存場所には十分に注意してください。 ここでは、プログラムの例としてパスワード入力を扱いましたが、SSH 接続を行うのであれば、通常は ~/.ssh/config ファイルによる SSH キー設定 を用いた方がよいでしょう。"},{url:"/p/b9tsccu/",title:"Vim/Neovim でインサートモード中に Backspace キーや CTRL-W で文字を削除するときの振る舞いを変更する (backspace)",date:"2018-11-07T00:00:00+09:00",body:"Vim/Neovim でインサートモード中に Backspace キーや CTRL-W で文字を削除するときの振る舞いを変更する (backspace) backspace オプション（Vim の場合） Vim エディタでは、インサートモード中に Backspace キーを押すと、入力した文字が削除されますが、デフォルトではインサートモードに入ったカーソル位置より前の文字を削除することはできません。 代表的な削除系のキー入力は、下記のような振る舞いをします。 Backspace: カーソル位置の直前の 1 文字を削除する。ただし、インサートモードに入ったときのカーソル位置までしか削除できない。 CTRL-W: カーソル位置の直前の 1 単語を削除する。ただし、インサートモードに入ったときのカーソル位置までしか削除できない。 CTRL-U: カーソル位置からインサートモードに入ったときのカーソル位置までを削除する。 backspace オプションを設定すると、上記のようなキー入力によって削除可能な文字の範囲を広げることができます。 backspace オプションには次のような値をカンマ区切りで設定します。 indent: オートインデント機能で挿入されたスペースを削除できる eol: 改行を削除できる（前の行に遡って削除していける） start: インサートモードに入ったときのカーソル位置よりも前の文字を削除できる（ただし、CTRL-W や CTRL-U による削除は、インサートモードに入ったカーソル位置までで削除範囲が一度止まる） 設定例 (~/.vimrc) &#34; インサートモード中の BS、CTRL-W、CTRL-U による文字削除を柔軟にする set backspace=indent,eol,start 上記のように設定しておくと、それぞれの削除系のキー入力の振る舞いは下記のように変化します。 Backsapce: カーソル位置の直前の 1 文字を削除する。インサートモードに入った時のカーソル位置よりも前の文字を削除できる。 CTRL-W: カーソル位置の直前の 1 単語を削除する。インサートモードに入った時のカーソル位置よりも前の単語を削除できる。ただし、インサートモードに入った時のカーソル位置も単語の境界とみなす。 CTRL-U: カーソル位置から行頭までを削除する。ただし、インサートモードに入ったときのカーソル位置も行頭とみなす。 backspace オプション (Neovim の場合） Neovim の場合は、backspace オプションの設定値が デフォルトで indent,eol,start となっているため、何も設定しなくても Backspace キーが直感的に振る舞います（編集開始位置よりも前の文字を削除できます）。"},{url:"/p/7m6n4j2/",title:"Hugo で Markdown ファイルに本文が記述されていない場合だけ特別な出力をする",date:"2018-11-02T00:00:00+09:00",body:"Hugo で Markdown ファイルに本文が記述されていない場合だけ特別な出力をする 例えば、あるページの Markdown ファイルが下記のようにフロントマターだけの記述になっていると、 --- title: &#34;ページタイトル&#34; date: &#34;2018-11-02&#34; --- テンプレートから Page 変数の {{ .Content }} を参照したときの値は空っぽ になります。 このような場合だけ別の出力をしたい場合は、下記のように場合分け処理を記述します。 layouts/_default/single.html（抜粋） {{ with .Content }} {{ . }} {{ else }} &lt;b&gt;本文が記述されていません。&lt;/b&gt; {{ end }} このような分岐出力は、セクションページ（_index.md）などで活用できると思います。 例えば、次のようにセクションテンプレートを記述しておけば、セクションページに本文が記述されている場合はその内容を表示し、本文が記述されていない場合はそのセクション直下のページリストを表示できます。 layouts/_default/section.html（抜粋） {{- with .Content }} {{ . }} {{- else }} &lt;ul class=&#34;pageList&#34;&gt; {{/* カレントセクション直下のセクション */}} {{- range .Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; /&lt;/li&gt; {{- end -}} {{/* カレントセクション直下の記事ページ */}} {{- range .RegularPages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/li&gt; {{- end }} &lt;/ul&gt; {{- end }} コンテンツファイルが下記のような構成で配置されているとすると、 content/ +-- mysection/ +-- _index.md +-- page1.md +-- page2.md +-- page3.md セクションページの mysection/_index.md の本文に何も書かなかった場合は、自動的にサブページ (page1, page2, page3) へのリンクが表示されます。 本文を記述した場合は、その本文だけが表示されるので、自力で子ページへのリンクを記述するようにします。"},{url:"/p/pdvgf4v/",title:"Vim で行末の余分なスペースをまとめて削除する",date:"2018-11-01T00:00:00+09:00",body:"Vim で行末の余分なスペースをまとめて削除する ノーマルモードから下記のように実行すると、行末にある余計なスペースをまとめて削除することができます。 :%s/\\s*$// 各項目の意味 % &ndash; すべての行を変更対象にする \\s* &ndash; 0個以上のスペース（半角スペースやタブ） $ &ndash; 行末 ここでは、% を指定してすべての行を対象にしていますが、SHIFT-V のビジュアルモードで行を選択してから :s/\\s*$// と入力すれば、選択した行のみを対象にでききます。"},{url:"/p/4xbztoe/",title:"Vim で上の行の文字、下の行の文字をコピーする (CTRL-Y, CTRL-E)",date:"2018-10-31T00:00:00+09:00",body:"Vim で上の行の文字、下の行の文字をコピーする (CTRL-Y, CTRL-E) インサートモードで下記のようなキー入力を行うと、カーソルのすぐ上の行の文字や、すぐ下の行の文字をコピーする形でカーソル位置に挿入できます。 テキストの一部だけが異なる文章を挿入したいときなどに便利です。 CTRL-Y: カーソル位置の上の行の文字をコピーして挿入 CTRL-E: カーソル位置の下の行の文字をコピーして挿入"},{url:"/p/qt8z5d3/",title:"Vim でプログラムの関数定義などにジャンプする（tags ファイルの利用）",date:"2018-10-30T00:00:00+09:00",body:"Vim でプログラムの関数定義などにジャンプする（tags ファイルの利用） Universal Ctags コマンドのインストール タグジャンプ系の機能を使用するには、あらかじめ検索対象のソースコードから tags ファイルを生成しておく必要があります。 tags ファイルを作成するには、外部コマンドの ctags を使用するのですが、このコマンドは下記の Universal Ctags で提供されているものを使用するのがよいでしょう。 Universal Ctags 各OS用のインストールパッケージ Windows であれば、ダウンロードしたアーカイブに含まれている ctags.exe をパスの通ったディレクトリに配置するだけでインストールは完了です。 昔は exhuberant ctags で提供されている ctags が主流でしたが、現在はメンテナンスされておらず、新しい言語にも対応していないので、そこから fork されたプロジェクトである Universal Ctags の方を使うことをオススメします。 Univasal Ctags でサポートしている言語は、下記のようにして確認することができます。 $ ctags --list-languages tags ファイルを作成する tags ファイルを作成するには、検索したいソースコードファイルのあるディレクトリで ctags コマンドを実行します。 ディレクトリを再帰的に走査するには -R (--recurse) オプションを付けて実行してください。 $ ctags -R ある言語のファイル群だけ（例えば .java だけ）を対象にしたいときは、--languages オプションを使用して以下のように実行します。 $ ctags -R --language=Java 指定するのは拡張子ではなく、言語名であることに注意してください（ctags --list-languages で表示される言語名から選択）。 複数の言語を指定することも可能です。 $ ctags -R --languages=Java,C,C++,Make,Python,Ruby しばらく待って、カレントディレクトリに tags ファイルが生成されれば成功です。 どの拡張子のファイルが検索対象になるか どのような言語名でどの拡張子のファイルが走査対象になるかは、--list-maps オプションで確認することができます（指定するときは大文字と小文字の違いは気にしなくてよいようです）。 $ ctags --list-maps | head -5 Ada *.adb *.ads *.Ada Ant build.xml *.build.xml *.ant *.xml Asciidoc *.asc *.adoc *.asciidoc *.asc *.adoc *.asciidoc Asm *.A51 *.29[kK] *.[68][68][kKsSxX] *.[xX][68][68] *.asm *.ASM *.s *.S Asp *.asp *.asa いくつかの言語名にはエイリアス名が定義されていて、エイリアス名でも指定することができるようになっています。 エイリアス名の一覧は ctags --list-aliases で確認することができます。 $ ctags --list-aliases | head -5 #LANGUAGE ALIAS Awk gawk Awk mawk C# csharp JavaScript js Vim に tags ファイルの検索パスを設定する（tags オプションの設定） Vim が tags ファイルをどのように検索するかは、tags オプションで設定されています。 デフォルトでは下記のように設定されています（大文字の TAGS も含まれているかも）。 :set tags=./tags,tags 複数のパスがカンマ区切りで指定されており、それぞれ下記のような意味をもっています。 ./tags: 現在編集中のファイルと同じディレクトリから tags を探す tags: カレントディレクトリから tags を探す この設定のままだと、同じディレクトリに tags ファイルがないとタグジャンプ機能が使えない（「E433: タグファイルが見つかりません」エラーになる）のでとても不便です。 次のように末尾にセミコロン (;) を入れて設定しておくと、親ディレクトリを上って tags ファイルを検索してくれるようになります。 ~/.vimrc （tags ファイルを上位のディレクトリからも検索） set tags=./tags;,tags; 逆に下位ディレクトリを再帰的に検索する (**) といったワイルドカードなども使用できます。 このあたりの Vim のファイル検索の仕組みは、:help file-searching のヘルプで確認することができます。 tags ファイルを使って定義位置にタグジャンプする タグジャンプの基本 作成された tags ファイルを利用して、関数などの定義位置にタグジャンプするには下記のように :tag（あるいは :tags）コマンドを使用します。 :tag FuncName &#34;現在のウィンドウでタグジャンプ :stag FuncName &#34;ウィンドウを分割してタグジャンプ あるいは、検索したい単語にカーソルを合わせ、下記のように入力することでもタグジャンプできます。 CTRL-]: 現在のウィンドウでタグジャンプ CTRL-W]: ウィンドウを分割してタグジャンプ ジャンプ元に戻るには、CTRL-T と入力します。 連続してタグジャンプした場合は、繰り返し CTRL-T を入力することで、順番にジャンプ元に戻っていきます。 戻りすぎた場合は、:tag とパラメータなしで実行すれば、タグジャンプ先に戻れます。 例えば、下記ようなシナリオを考えてみるとわかりやすいと思います。 ファイル1から :tag MyFunc で MyFunc を含むファイル2にタグジャンプ ファイル2から CTRL-] でカーソル下のキーワードを含むファイル3にタグジャンプ ファイル3から CTRL-T でファイル2に戻る ファイル2から CTRL-T でファイル1に戻る ファイル1から :tag でファイル2にジャンプ（戻りすぎのリドゥ） タグジャンプで移動してきた履歴は :tags コマンドで確認することができます。 CTRL-] でジャンプ元に戻ったり、:tag コマンドで再びジャンプするときは、このタグジャンプ履歴に従って飛び回っていることになります。 ビジュアルモードでテキストを選択した状態で CTRL-] を入力すると、その選択範囲の文字列と一致する関数定義へタグジャンプできます。 例えば、MyMouseListener の中の MouseListener の部分だけをビジュアルモードで選択して CTRL-] とすれば、MouseListener の定義位置にタグジャンプすることができます（それはおそらく MyMouseListener の親クラスです）。 複数のタグジャンプ候補がある場合 :tag MyFunc でタグジャンプする場合も、CTRL-] でタグジャンプする場合も、ジャンプ先の候補が複数見つかったとしても、最初に見つかったところにしかジャンプしてくれません。 複数のジャンプ先が想定される場合は、:tag コマンドの代わりに、:tselect あるいは :tjump を使用します。 :tselect MyFunc: タグジャンプ先の候補を表示して選択。 :stselect MyFunc: 上記のウィンドウ分割版。 :tjump MyFunc: タグジャンプ先の候補を表示して選択。候補が1つしかない場合は即ジャンプ :tsjump MyFunc: 上記のウィンドウ分割版。 これらのコマンドにも、カーソル下のキーワードをもとにジャンプするショートカットキーが割り当てられています。 | コマンド | カーソル下のキーワードを使用するショートカット | | :tag MyFunc | CTRL-] | | :stag MyFunc | CTRL-WCTRL-] または CTRL-W] | | :tselect MyFunc | g] | | :stselect MyFunc | CTRL-Wg] | | :tjump MyFunc | gCTRL-] | | :stjump MyFunc | CTRL-WgCTRL-] | たくさんありますが、タグジャンプの基本的となる CTRL-] と、候補選択できる gCTRL-] を覚えておけばよいと思います。 タグジャンプ後に、複数のジャンプ先候補がある場合は、次のようなコマンドで順番に開いていくことができます。 :tnext: 次の候補へジャンプ :tprevious: 前の候補へジャンプ :trewind: 最初の候補へジャンプ :tlast: 最後の候補へジャンプ 正規表現で検索 :tag コマンドや :tjump コマンドで単純にキーワードを入力してジャンプする場合は、そのキーワードが実在する関数名などと完全一致していなければいけません。 関数名の一部しか思い出せないような場合は、キーワードの先頭に / を付加することで、正規表現パターンを使って部分一致検索を行えます。 関数名に FooBar を含む関数の定義へジャンプ :tag /FooBar &#34;最初に見つかった定義へジャンプ :tjump /FooBar &#34;複数候補があればリストから選択 関数名の先頭だけがわかっているのであれば、次のように検索できます。 getLast という名前で始まっている関数の定義へジャンプ :tag /^getLast :tjump /^getLast Vim 起動時にいきなりタグジャンプ Vim を起動するときに、-t オプションを使用すると、指定した関数の定義部分をいきなり開くことができます。 MyFunc 関数の定義位置を Vim で開く $ gvim -t MyFunc ファイル名すら指定する必要がないので、使い方によってはかなり便利です。 まぁ、Vim を起動したあとで :tjump MyFunc した方が、タグジャンプ先候補が複数ある場合にも対応できて実用性は高いのですが、これを人の前でやってみせると知らない人は驚いてくれます(笑)。 上記のように単純にキーワード指定すると、完全一致するキーワードでしか検索してくれませんが、下記のように / で始まるように記述すれば、正規表現で検索してくれます。 関数名に MyFunc を含む関数の定義位置を Vim で開く（正規表現検索） $ gvim -t /MyFunc マウスでタグジャンプ Vim ユーザーであれば、マウスの使用頻度は低いかもしれませんが、マウス操作でもタグジャンプを行えるようになっています。 Ctrl + 左クリック: カーソル下のキーワードでタグジャンプ（CTRL-] と同じ） Ctrl + 右クリック: タグジャンプ元へ戻る（CTRL-T と同じ） ヘルプをブラウズするときや、プログラムのソースコードを探索しているときなどはマウスだけでどんどん読んでいけるので便利かもしれません。 コラム: タグジャンプはヘルプでも大活躍 :help コマンドで起動できるヘルプでは、各キーワードに対してあらかじめ Ctrl-] でタグジャンプできるようになっています。 あらかじめ doc ディレクトリ内に、ヘルプファイル用の tags ファイルが格納されているためタグジャンプが可能になっています。 応用: 指定したディレクトリに tags ファイルを出力する ctags コマンドで -f オプションを使用すると、指定したパスに tags ファイルを出力することができます。 例えば、ホームディレクトリに tags ファイルを作成するには次のように実行します。 Windows の場合 $ ctags -f %HOME%/tags -R --languages=Java %CD% Linux、macOS の場合 $ ctags -f $HOME/tags -R --languages=Java `pwd` このように tags ファイルを決められたパスに置く場合は、タグファイル内のパス記述を絶対パスで出力しておかなければいけません。 上記の実行例の末尾で %CD% や pwd を指定しているのはそのためです。 既存の tags ファイルに追記する形で出力するには、-a (--append) オプションを使用します。 $ ctags -f %HOME%/tags -a -R --languages=Java %CD% このように、固定されたパスに置かれた tags ファイルを利用するためには、下記のように Vim の tags オプションにそのパス情報を追加しておきます（末尾に ~/tags と追加しています）。 ~/.vimrc set tags=./tags,tags,~/tags こうすることで、どのファイルを編集中であっても ~/tags を利用したタグジャンプを行えるようになります。 とはいえ、多くの場合は上位ディレクトリの tags ファイルを検索するだけの設定 (set tags=./tags;,tags;) で十分です。"},{url:"/p/7uxykzp/",title:"Vim で現在のキーマップの一覧を表示する (map)",date:"2018-10-28T00:00:00+09:00",body:"Vim で現在のキーマップの一覧を表示する (map) 参考: Vim のキーマップの基本 (map, noremap) ユーザ定義のキーマップを確認する Vim でユーザが定義しているキーマップの一覧を表示するには、下記のように map 系のコマンドをパラメータなしで実行します。 キーマップの一覧を表示 :map &#34; ノーマルモードとビジュアルモードのキーマップ :nmap &#34; ノーマルモードのキーマップ :vmap &#34; ビジュアルモードのキーマップ :imap &#34; インサートモードのキーマップ :cmap &#34; コマンドラインモードのキーマップ :map! &#34; インサートモードとコマンドラインモードのキーマップ また、次のように verbose コマンド（省略形は verb）と組み合わせて使用すると、そのキーマップがどの設定ファイルで定義されているかを確認することができます。 キーマップの一覧と定義元のファイルを表示 :verbose map :verbose nmap :verbose vmap :verbose imap :verbose cmap :verbose map! デフォルトのキーマップを確認する Vim がデフォルト定義しているキーマップの一覧は、下記のヘルプファイルで参照することができます。 :help index.txt :help index 例えば、インサートモード時の Ctrl-H がどのようなマッピングになっているかは、i_CTRL-H という項目に記述されています（same as &lt;BS&gt; と書かれているので、BackSpace キーと同様の振る舞いをします）。 初めからどのモードのキーマッピングを調べたいかが決まっているときは、上記のようにヘルプを起動する代わりに、下記のように起動するとそのセクションから読み始めることができます。 :help normal-index &#34; ノーマルモードのデフォルトマッピングを表示 :help visual-index &#34; ビジュアルモードのデフォルトマッピングを表示 :help insert-index &#34; インサートモードのデフォルトマッピングを表示 もっと具体的に、調べたいキーコンビネーションが決まっている場合は、そのキーに対応するヘルプを直接開くことができます。 :help i_CTRL-H"},{url:"/p/s8wxbon/",title:"Vim でカレントディレクトリを Windows エクスプローラーで開く",date:"2018-10-22T00:00:00+09:00",body:"Vim でカレントディレクトリを Windows エクスプローラーで開く Vim で任意のファイルを開いているときに、下記のように入力すると、そのファイルのあるディレクトリを Windows エクスプローラーで開くことができます。 :silent ! start %:h 使用頻度が高ければ、下記のようにキーマッピングしておけば、F12 キーを押すだけで Windows エクスプローラーを開くことができるようになります。 ~/.vimrc nmap &lt;F12&gt; :silent ! start %:h&lt;CR&gt;"},{url:"/p/m3si4w6/",title:"Python で標準エラー出力へ出力する (sys.stderr)",date:"2018-10-14T00:00:00+09:00",body:"Python で標準エラー出力へ出力する (sys.stderr) 標準エラー出力への出力 Python の print の出力先を標準エラー出力 (STDERR) にするには、file オプションで sys.stderr を指定します。 標準エラー出力への出力 import sys # ... if not is_valid_config(): print(&#34;Error: invalid configuration&#34;, file=sys.stderr) sys.exit(1) ちなみに、file 引数には write メソッドを持っているオブジェクトを渡せるようになっています。 sys.stderr オブジェクトも write メソッドを持っているので、上記のように file 引数に渡すことができます。 上記の例では、標準エラーにメッセージ出力をして、さらに sys.exit(1) でプログラムをエラー終了させていますが、実はこの処理は、sys.exit 関数にエラーメッセージを渡すことで 1 行で記述できます。 標準エラーへ出力してエラー終了する sys.exit(&#34;Error: invalid configuration&#34;) コラム: Python2 までの方法 Python2 までは下記のように標準エラー出力に出力することができました。 古い Python2 のやり方 import sys print &gt;&gt; sys.stderr, &#39;エラーメッセージ&#39;"},{url:"/p/25gqyai/",title:"Linuxメモ: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ",date:"2018-10-11T00:00:00+09:00",body:"Linuxメモ: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ Linux の echo コマンドで文字列変数 $str の値を出力しようとして、下記のように実行すると、文字列に含まれている連続するスペースが 1 つのスペースにまとめられてしまいます。 sample.sh（間違った方法） #!/bin/bash str=&#34;AAA BBB CCC&#34; echo $str 実行結果 AAA BBB CCC これは、変数展開が行われることによってダブルクォートが取り除かれ、下記のように echo コマンドに 3 つのパラメータが渡されたものとして扱われるからです。 パラメータの区切りとして使われるスペースの数は関係なく、各パラメータ (AAA、BBB、CCC) が 1 つのスペースで結合されて出力されます。 $ echo AAA BBB CCC AAA BBB CCC スペースを含む文字列を 1 つの文字列として echo コマンドに渡すには、次のようにダブルクォートで囲む必要があります。 sample.sh（正しい方法） #!/bin/bash str=&#34;AAA BBB CCC&#34; echo &#34;$str&#34; 実行結果 AAA BBB CCC"},{url:"/p/usqqvps/",title:"HTML の画像要素 (img) を親要素の左右両端に表示する",date:"2018-09-26T00:00:00+09:00",body:"HTML の画像要素 (img) を親要素の左右両端に表示する HTML のある親要素の左右両端に画像などの子要素を配置する方法を紹介します。 Flex レイアウトを使って子要素を左右に配置する方法 （別ページで開く） Flex レイアウトの配置方法として justify-content: space-between を指定すると、「子要素を均等に配置し、最初のアイテムは先頭に寄せ、最後のアイテムは末尾に寄せる」という意味になります。 HTML &lt;div class=&#34;box&#34;&gt; &lt;img src=&#34;tree.png&#34;&gt; &lt;img src=&#34;tree.png&#34;&gt; &lt;/div&gt; CSS .box { display: flex; justify-content: space-between; } position: abosolute 指定で子要素を左右に配置する方法 （別ページで開く） スタイルに position: absolute 指定を行うと、親要素の原点を基準に要素を配置することができます。 この指定に加えて、left: 0 とすれば左寄せ（デフォルト）、right: 0 とすれば右寄せで子要素を配置することができます（親要素の左端、右端に配置される）。 HTML &lt;div class=&#34;box&#34;&gt; &lt;img class=&#34;box_left&#34; src=&#34;tree.png&#34;&gt; &lt;img class=&#34;box_right&#34; src=&#34;tree.png&#34;&gt; &lt;/div&gt; CSS .box { /* 子要素のタイトルを aboslute 配置するために必要 */ position: relative; } .box .box_left { position: absolute; left: 0; } .box .box_right { position: absolute; right: 0; } 応用例: ウェブサイトのヘッダ部分で使えそうな例 （別ページで開く） ここでは、両端に配置した画像の間にテキストを追加しています。 テキストに関しても同じ階層に position: absolute 配置し、中央寄せで表示しています。 このような構成にすることで、横幅が狭くなった場合に、画像の上にテキストが重なる形で表示されるようになります。 下記は CSS と HTML の抜粋ですが、ヘッダーの帯部分の高さに対して、上下方向にも中央寄せするようにしているため若干複雑になっています。 HTML &lt;div class=&#34;titleBox&#34;&gt; &lt;img class=&#34;titleBox_imageLeft&#34; src=&#34;tree.png&#34;&gt; &lt;img class=&#34;titleBox_imageRight&#34; src=&#34;tree.png&#34;&gt; &lt;h1&gt;これはウェブサイトのタイトルです&lt;/h1&gt; &lt;/div&gt; CSS .titleBox { position: relative; /* 子要素の aboslute 配置用 */ height: 200px; background: #597380; } .titleBox &gt; * { /* 子要素をすべて上下に中央寄せする */ position: absolute; top: 50%; transform: translateY(-50%); } .titleBox &gt; .titleBox_imageLeft { left: 0; } .titleBox &gt; .titleBox_imageRight { right: 0; } .titleBox &gt; h1 { margin: 0; padding: 0; width: 100%; text-align: center; color: #eee; text-shadow: 2px 2px 3px black; }"},{url:"/p/oukq4dh/",title:"Linuxメモ: シェルスクリプトのコーディングスタイル",date:"2018-09-25T00:00:00+09:00",body:"Linuxメモ: シェルスクリプトのコーディングスタイル Bash のシェルスクリプトを記述するときに最低限揃えておきたいコーディングスタイルです。 Google のコーディングスタイルを参考にしています。 基本的に bash を使用することとし、1 行目の Shebang として #!/bin/bash と記述する インデント: 半角スペース 2 文字（タブ文字は使用しない） if と同じ行に then を記述する for や while と同じ行に do を記述する 1 行あたりの文字数は 80 文字まで 関数名や変数名はすべて小文字（例: my_func） 外部コマンドを実行するときはバッククォート (\\) を使用せず、$(func arg1 arg2) という形式を使用する シェル変数は小文字 ($src_dir)、環境変数は大文字 ($FOO_BAR)"},{url:"/p/etgm2a4/",title:"Vim で行を連結する (J, gJ)",date:"2018-09-20T00:00:00+09:00",body:"Vim で行を連結する (J, gJ) スペースを入れて行連結、スペース入れずに行連結 行末の改行を削除して次の行と連結するには下記のコマンドを使用します。 J: スペースを1文字いれて連結する。 gJ: スペースを入れずに連結する。 複数行をまとめて連結する ビジュアルモード (SHIFT-V) で複数行を選択してから J や gJ と入力すると、複数の行をまとめて連結することができます。 3行以上の行をスペースを入れずに連結したい場合は、上図のようにビジュアルモードで複数行を選択した状態で gJ とするか、一行だけ gJ で連結しておいて、残りの行を . の連打で連結するのがお手軽です。 文章の終わりはスペース 2 つで連結される J による行の連結部分には、通常 1 つの半角スペースが挿入されますが、行末が句点（.、 ?、!）で終了している場合は 2 つの半角スペースが挿入されます。 この振る舞いを変更するには、以下のオプションを設定します。 :set joinspaces &#34;行連結時に句点のあとに 2 つのスペースを挿入 (default) :set nojoinspaces &#34;行連結時に句点のあとに 1 つのスペースを挿入"},{url:"/p/q7eoz2z/",title:"Vim のサイレントバッチモードで ex スクリプトをファイルに適用する (-es)",date:"2018-09-18T00:00:00+09:00",body:"Vim のサイレントバッチモードで ex スクリプトをファイルに適用する (-es) vim (gvim) コマンドを起動するときに、-es オプションを使用すると、サイレントバッチモードで起動し、任意の ex スクリプトを指定したファイルに適用することができます。 例えば、下記のスクリプトは AAA という文字を XXX に置換して保存するだけの簡単な ex スクリプトです。 replace.vim :%s/AAA/XXX/g :wq このスクリプトを任意のテキストファイル (ここでは input.txt) に適用するには、下記のように実行します。 $ gvim -es -S replace.vim input.txt 例えば、入力したファイルの内容が下記のような内容だとすると、 input.txt AAA BBB AAA BBB BBB AAA BBB AAA AAA BBB AAA BBB 次のように変更されます。 input.txt（変更後） XXX BBB XXX BBB BBB XXX BBB XXX XXX BBB XXX BBB 指定したファイル自体の内容が変更されることに注意してください。 ex スクリプトの中で wq を実行しているため、上書き保存して終了するところまでがワンセットで実行されます。 -eq オプションの代わりに、-c オプションを使用すると、コマンドラインで直接 ex コマンドを指定して実行することができます。 $ gvim -c &#34;%s/AAA/XXX/g&#34; -c &#34;wq&#34; input.txt"},{url:"/p/bf2nban/",title:"GitHub Pages で独自の 404 ページを用意する",date:"2018-09-12T00:00:00+09:00",body:"GitHub Pages で独自の 404 ページを用意する GitHub Pages で存在しないページにアクセスすると、デフォルトでは GitHub が用意している 404 ページが表示されます。 Web サイトのルートパスに 404.html ファイルを配置すると、独自の 404 ページを表示することができます。 ここでは、Jekyll のページ生成の仕組みを使って、独自の 404 ページを作成する方法を説明します。 図: GitHub Pages で独自の 404 ページを表示した例 コンテンツファイル (404.md) の作成 まず、プロジェクトのルートディレクトリに 404.md を作成し、404.html というページが出力されるようにします。 404.md --- title: &#34;404&#34; layout: &#34;404&#34; permalink: &#34;404.html&#34; --- 表示内容に関しては、404 ページ専用のレイアウト (_layouts/404.html) の方で定義することにします。 よって、上記の Markdown ファイルでは、フロントマターで出力設定だけを記述しておきます。 レイアウトファイル (_layouts/404.html) の作成 404 ページの出力内容は特有のレイアウトになることが多いので、専用のレイアウトファイルで作成するのがオススメです。 ここでは、_layouts/404.html というパスにファイルを作成します（404.md のフロントマターで指定したレイアウト名に合わせてください）。 _layouts/404.html の記述例 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;ja&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta property=&#34;og:title&#34; content=&#34;{{ page.title }} | {{ site.name }}&#34; /&gt; &lt;title&gt;{{ page.title }} | {{ site.name }}&lt;/title&gt; &lt;link rel=&#34;icon&#34; sizes=&#34;16x16 32x32 48x48 64x64&#34; href=&#34;/assets/img/favicon/favicon.ico&#34; /&gt; &lt;link rel=&#34;apple-touch-icon-precomposed&#34; href=&#34;/assets/img/favicon/favicon-152.png&#34; /&gt; &lt;style&gt; body { background: #eee; margin: 1em auto; text-align: center; } .content { width: 500px; margin: 0 auto; } h1 { font-size: 3rem; margin: 1em 0; } a { color: #36f; font-weight: bolder; text-decoration: none; } a:hover { color: white; background: #36f; } img { width: 100px; vertical-align: bottom; } &lt;/style&gt; {% if jekyll.environment != &#34;development&#34; %} {% include analytics.html %} {% endif %} &lt;/head&gt; &lt;body&gt; &lt;h1&gt;{{ page.title }}&lt;/h1&gt; &lt;div class=&#34;content&#34;&gt; &lt;p&gt;ページが見つかりませんでした。&lt;/p&gt; &lt;p&gt;&lt;a href=&#34;{{ site.url }}&#34;&gt;{{ site.name }}のトップページ&lt;/a&gt;へ移動するか、&lt;br&gt; 下記から検索してみてください。&lt;/p&gt; &lt;p&gt;{% include search-bar.html %}&lt;/p&gt; &lt;p&gt;&lt;a href=&#34;{{ site.url }}&#34;&gt;&lt;img src=&#34;{{ site.logo }}&#34;&gt;&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 上記の例では、Google Analytics 用のコード (_includes/analytics.html) も挿入するようにしています。 こうしておけば、404 ページへのアクセスも解析できるようになるので便利です。 Google Analytics を使用していないのであれば外してください。 また、404 ページからトップページへ飛ばすだけでは不親切なので、Google カスタム検索のためのフォーム (_includes/search-bar.html) も配置するようにしています。 このあたりは適宜調整してください。 上記のレイアウトファイルでは、site 変数を使ってサイト名 (site.name) やロゴファイル名 (site.logo) を取得しているので、_config.yml の中で下記のような感じで設定しておいてください。 _config.yml name: 天才まくまくノート url: https://maku77.github.io logo: /assets/img/logo.jpg あとは、作成した 404.md と _layouts/404.html を GitHub 上のリポジトリにプッシュすれば完成です。 参考サイト Creating a custom 404 page for your GitHub Pages site - User Documentation"},{url:"/p/p4n5m3i/",title:"Hugo に全文検索（インクリメンタルサーチ）の機能を付ける",date:"2018-09-11T00:00:00+09:00",body:"Hugo に全文検索（インクリメンタルサーチ）の機能を付ける ここでは、Hugo サイトに全文検索の機能を付ける方法を説明します。 全文検索を実現する方法としては、Google カスタム検索を導入する方法もありますが、Google カスタム検索は、インターネット上に公開する Web サイトにしか適用できません。 ここで紹介する JavaScript を利用した全文検索は、ローカルで運用する Web サイトでも利用できますし、インクリメンタルサーチも実現することができます（実際のサイトの例）。 図: 全文検索＋インクリメンタルサーチの完成イメージ 大まかに、下記のようなコードを含む HTML ファイルを出力できれば、サイト内の全文検索を実現することができます。 検索用 JavaScript データ (const data = [...]) 検索用 HTML フォーム (&lt;input&gt;) 検索用 JavaScript 関数 (function search() {...}) ここでは、全文検索のためのページとして search という名前のページ (content/search.md) を作成することにします（URL としては http://localhost:1313/search/ という形でアクセスすることになります）。 すでに search という名前のページを作成している場合は適宜変更してください。 ☝️ 2023-05-04 追記 以前の実装では、検索用データ (search/data.js) と検索用ページ (search/index.html) を分けて出力していましたが、検索用ページに統合するように変更しました。 Hugo がバージョンアップして、出力ファイルに livereload 用の script タグを自動挿入するようになり、正しい data.js ファイルとして出力できなくなってしまったからです。 コンテンツファイル (content/search.md) の作成 まず、全文検索用のページを出力するためのコンテンツファイルを作成しておきます。 content/search.md --- title: &#34;サイト内全文検索&#34; layout: search _build: { list: never } --- フロントマターの layout プロパティで search という名前のテンプレートを使うことを指定しておきます。 ついでに、_build プロパティで、このページをリスト系ページの一覧に列挙しないようにしておきます（参考: 記事一覧に列挙されないページを作る）。 本文はすべてテンプレート側で出力するので、Markdown ファイルには上記のようにフロントマターだけ記述しておけば OK です。 テンプレートファイル (layouts/_default/search.html) の作成 検索用 JavaScript データの出力 全ページの本文を JavaScript から検索できるようするために、検索用のデータ（インデックス）を作成します。 ここでは、HTML ファイルの &lt;script&gt; 要素内に、次のようなフォーマットで data 変数を出力することにします。 const data = [ { url:&#34;ページURL1&#34;, title:&#34;タイトル1&#34;, body:&#34;本文1…&#34; }, { url:&#34;ページURL2&#34;, title:&#34;タイトル2&#34;, body:&#34;本文2…&#34; }, { url:&#34;ページURL3&#34;, title:&#34;タイトル3&#34;, body:&#34;本文3…&#34; }, ... ]; data 変数は、各ページの情報を配列として保持しています。 ユーザーが検索キーワードを入力したときに、この変数内の body プロパティの内容を検索するように実装します。 テンプレートファイル内で次のように実装しておけば、全ページの情報を含む data 変数のコードを出力することができます。 layouts/_default/search.html（途中経過） {{- /* エスケープ処理（改行を空白化、前後の空白削除、連続する空白を集約） */}} {{- define &#34;escape&#34; }} {{- trim (replace . &#34;\\n&#34; &#34; &#34;) &#34; &#34; | replaceRE &#34; +&#34; &#34; &#34; -}} {{- end }} &lt;script&gt; // 検索用のインデックスデータ const data = [ {{- range $index, $page := .Site.Pages }} { url: {{ $page.RelPermalink }}, title: {{ $page.Title }}, date: {{ $page.Date }}, body: {{ template &#34;escape&#34; (printf &#34;%s %s&#34; $page.Title $page.Plain) }} }, {{- end }} ]; &lt;/script&gt; 本文内の連続するスペースの集約や、改行文字の削除を行うために、escape という部分テンプレートを定義しています（define で定義し、template で呼び出しています）。 タグの一覧ページ（.Kind = taxonomy) や、タグの付いた記事の一覧ページ (.Kind = term) を検索対象にしたくないときは、上記の .Pages の range ループの中に次のような if - end 条件分岐を追加すればフィルタできます。 {{- if not (or (eq $page.Kind &#34;taxonomy&#34;) (eq $page.Kind &#34;term&#34;)) }} { ... }, {{- end }} ここまでできたら、hugo serve でローカルサーバーを起動して http://localhost:1313/search/ にアクセスして、出力されたファイルの内容を確かめてみるとよいでしょう。 ただし、この時点ではブラウザ上での表示は空っぽです。 data 変数は &lt;script&gt; 要素内に出力されているため、その内容を確認するためには、ブラウザ上で右クリックして「ページのソースを表示」などから確認する必要があります。 検索用 HTML フォームと JavaScript 関数の出力 あとは、全体の UI として、ユーザーがキーワードを入力するための &lt;input&gt; 要素などを配置し、そのキーワードで data 配列の内容を検索するための JavaScript 関数 (search) などを追加します。 スタイルシート (CSS) まで含んでいるので若干長いですが、やっていることは単純で、キーワードを含むページを見つけてその概要を出力しているだけです。 layouts/_default/search.html（完成版） {{- /* エスケープ処理（改行を空白化、前後の空白削除、連続する空白を集約） */}} {{- define &#34;escape&#34; }} {{- trim (replace . &#34;\\n&#34; &#34; &#34;) &#34; &#34; | replaceRE &#34; +&#34; &#34; &#34; -}} {{- end }} &lt;!DOCTYPE html&gt; &lt;html lang=&#34;ja&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;{{ .Page.Title }} | {{ .Site.Title }}&lt;/title&gt; &lt;style&gt; body { background: #fafafa; } input { color: deeppink; font-size: 1.2em; font-weight: bolder; } input::-webkit-input-placeholder { color: pink; } #result { margin: 1em; } .item_title { text-decoration: none; color: #36f; font-weight: bolder; } .item_excerpt { background: white; margin: 0.5em 2em 1em; padding: 0.5em; border: dashed 1px lightgray; font-size: smaller; } .item_excerpt b { background: pink; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;{{ .Page.Title }}&lt;/h1&gt; &lt;input onkeyup=&#34;search(this.value)&#34; size=&#34;15&#34; autocomplete=&#34;off&#34; autofocus placeholder=&#34;検索ワード&#34; /&gt; &lt;span id=&#34;inputWord&#34;&gt;&lt;/span&gt; &lt;span id=&#34;resultCount&#34;&gt;&lt;/span&gt; &lt;div id=&#34;result&#34;&gt;&lt;/div&gt; &lt;script&gt; // 検索用のインデックスデータ const data = [ {{- range $index, $page := .Site.Pages }} {{- if not (or (eq $page.Kind &#34;taxonomy&#34;) (eq $page.Kind &#34;term&#34;)) }} { url: {{ $page.RelPermalink }}, title: {{ $page.Title }}, date: {{ $page.Date }}, body: {{ template &#34;escape&#34; (printf &#34;%s %s&#34; $page.Title $page.Plain) }} }, {{- end }} {{- end }} ]; function search(query) { const result = searchData(query); const html = createHtml(result); showResult(html); showResultCount(result.length, data.length); } function searchData(query) { // 検索にヒットした情報を下記のような配列として格納していく // [データのインデックス, 文字の開始位置, 文字の終了位置] const result = []; query = query.trim(); if (query.length &lt; 1) { return result; } const re = new RegExp(query, &#39;i&#39;); for (let i = 0; i &lt; data.length; ++i) { const pos = data[i].body.search(re); if (pos != -1) { result.push([i, pos, pos + query.length]); } } return result; } function createHtml(result) { const htmls = []; for (let i = 0; i &lt; result.length; ++i) { const dataIndex = result[i][0]; const startPos = result[i][1]; const endPos = result[i][2]; const url = data[dataIndex].url; const title = data[dataIndex].title; const body = data[dataIndex].body; htmls.push(createEntry(url, title, body, startPos, endPos)); } return htmls.join(&#39;&#39;); } function createEntry(url, title, body, startPos, endPos) { return &#39;&lt;div class=&#34;item&#34;&gt;&#39; + &#39;&lt;a class=&#34;item_title&#34; href=&#34;&#39; + url + &#39;&#34;&gt;&#39; + title + &#39;&lt;/a&gt;&#39; + &#39;&lt;div class=&#34;item_excerpt&#34;&gt;&#39; + excerpt(body, startPos, endPos) + &#39;&lt;/div&gt;&#39; + &#39;&lt;/div&gt;&#39;; } function excerpt(body, startPos, endPos) { return [ body.substring(startPos - 30, startPos), &#39;&lt;b&gt;&#39;, body.substring(startPos, endPos), &#39;&lt;/b&gt;&#39;, body.substring(endPos, endPos + 200) ].join(&#39;&#39;); } function showResult(html) { const el = document.getElementById(&#39;result&#39;); el.innerHTML = html; } function showResultCount(count, total) { const el = document.getElementById(&#39;resultCount&#39;); el.innerHTML = &#39;&lt;b&gt;&#39; + count + &#39;&lt;/b&gt; 件見つかりました（&#39; + total + &#39;件中）&#39;; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; これで、http://localhost:1313/search/ といった URL にアクセスすれば、全文検索のページが表示されるようになります。 （応用）URL のハッシュフラグメントに検索ワードを入れる やりたいこと ハッシュフラグメントとは、次のような、URL の末尾についた # 以降の文字列のことです。 http://localhost:1313/search/#検索ワード ここでは、ハッシュフラグメントに設定された検索ワードを使って全文検索を実行するようにしてみます。 コードは複雑になりますが、このような仕組みにすることで、 検索結果のページにリンクを張れるようになる 検索結果のページをブックマークできるようになる といった利点があります（正確には検索結果のページにリンクを張るわけではなく、ページを開いてから検索を実行します）。 全文検索のページのコードを修正 元のコードでは、input 要素の onkeyup 属性を使って search() 関数を呼び出すようにしていましたが、次のように、入力した値を URL のハッシュフラグメントにセットするように変更します（2021-06 追記: location.hash=this.value としてましたが、これだとキー入力のたびに履歴に追加されてしまうので、location.replace() を使うように変更しました）。 &lt;input id=&#34;query&#34; onkeyup=&#34;location.replace(&#39;#&#39; + this.value)&#34; size=&#34;15&#34; autocomplete=&#34;off&#34; autofocus placeholder=&#34;検索ワード&#34; /&gt; これにより、ユーザーが検索ワードを入力するたびに、ブラウザの URL 欄のハッシュフラグメントにその値が反映されるようになります。 次に、ページの表示時 (DOMContentLoaded) と、ハッシュフラグメントの変更時 (hashchange) に、ハッシュフラグメントの値を使って search() 関数を呼び出すようにします。 // ハッシュフラグメントの値で検索を実行 function searchWithHash() { const hash = decodeURI(location.hash.substring(1)); search(hash); // 必要があれば input 要素の値を更新 const queryElem = document.getElementById(&#39;query&#39;); if (queryElem.value !== hash) { queryElem.value = hash; } } // ハッシュフラグメント付きの URL でページを開いたときに検索 window.addEventListener(&#39;DOMContentLoaded&#39;, searchWithHash); // ページ表示後にハッシュフラグメントが変化したら検索 window.addEventListener(&#39;hashchange&#39;, searchWithHash); これで、ハッシュフラグメント経由での全文検索を実行できるようになります。 検索ワード付きの URL をブラウザで開いたときには、その検索ワードを使って即全文検索が実行されるようになり、その検索ワードが input 要素に表示されます。 ページ表示後にユーザーが input 要素のテキストを変更すれば、URL のハッシュフラグメントに反映され、その値で再度検索が実行されます。 他のページに検索ボックスを配置する 次のような検索フォームを任意のページに配置しておけば、そこから検索ワードを入力して全文検索のページにジャンプできるようになります。 &lt;form&gt; &lt;input id=&#34;searchKeyword&#34; type=&#34;search&#34; size=&#34;20&#34;&gt; &lt;input id=&#34;searchButton&#34; type=&#34;submit&#34; value=&#34;検索&#34;&gt; &lt;/form&gt; &lt;script&gt; const SEARCH_URL = &#39;/search/&#39;; window.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; { const searchButton = document.getElementById(&#39;searchButton&#39;); const searchKeyword = document.getElementById(&#39;searchKeyword&#39;); // 検索ボタンのクリックで検索ページへジャンプ searchButton.addEventListener(&#39;click&#39;, e =&gt; { e.preventDefault(); // Prevent default form&#39;s behavior const query = searchKeyword.value; const url = query ? SEARCH_URL + &#39;#&#39; + query : SEARCH_URL; location.href = url; }); }); &lt;/script&gt; form 要素のデフォルトアクションではハッシュフラグメントに検索ワードを付加できないので、検索ボタンの click イベントをハンドルし、自力でハッシュフラグメントをセットした上でページ遷移を行うようにしています。 参考 URL 内のハッシュフラグメントの値を扱う (hashchange, location.hash) ｜ まくまくJavaScriptノート Hugo で Google カスタム検索を設置して記事を検索できるようにする"},{url:"/p/tvuztbm/",title:"JavaScript で文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec)",date:"2018-09-11T00:00:00+09:00",body:"JavaScript で文字列から正規表現パターンに一致する部分を取り出す (String#match, RegExp#exec) JavaScript の String オブジェクトの中で正規表現を利用できるメソッドとしては、search()、replace()、split() などがありますが、中でも強力なのは match() メソッドです。 String#match(regexp) メソッドを使用すると、指定した正規表現パターンに一致する部分を配列オブジェクトとして取得することができます。 一致する部分がひとつも見つからない場合は null を返します。 match メソッドは、パラメータとして渡す正規表現パターンで g フラグを指定した場合と指定しない場合で振る舞いが変化します。 match の正規表現パターンに g フラグを指定したとき String#match(regexp) の正規表現パターンで、g フラグを付加すると、戻り値はパターンに一致した部分文字列の配列 になります。 例: 数値部分だけを抽出して配列で取得する const text = &#39;ABC 123 DEF 456 GHI 789 123ABC&#39;; const arr = text.match(/\\b\\d+\\b/g); if (arr != null) { console.log(arr); //=&gt; [ &#39;123&#39;, &#39;456&#39;, &#39;789&#39; ] } match の正規表現パターンに g フラグを指定しなかったとき String#match(regexp) の正規表現パターンで g フラグを付加しない場合、RegExp#exec(string) を単発で呼び出した場合と同様の振る舞い をします。 具体的には、戻り値の配列の先頭には、パターンに一致した部分の全体が格納され、残りの配列要素（インデックス 1 以降）には、( と ) でグルーピングされたパターンに一致した部分文字列が順番に格納されます。 これを利用すると、特定のフォーマットに従った文字列から各パートの文字列を抽出するということが簡単に実現できます。 URL 形式の文字列から、プロトコル、ホスト、パスを抽出 const re = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)/; const text = &#39;Visit my website at https://maku77.github.io/js&#39;; const matches = text.match(re); if (matches != null) { const url = matches[0]; //=&gt; &#39;https://maku77.github.io/js&#39; const protocol = matches[1]; //=&gt; &#39;https&#39; const host = matches[2]; //=&gt; &#39;maku77.github.io&#39; const path = matches[3]; //=&gt; &#39;js&#39; } 実は、match メソッドの戻り値として返されるオブジェクトには、index プロパティと input プロパティも含まれています。 これらには、正規表現に（最初に）一致した位置と、入力として使ったテキスト全体が含まれています。 下記は、match メソッドの戻り値を console.log(matches) で出力した結果です。 [ &#39;https://maku77.github.io/js&#39;, &#39;https&#39;, &#39;maku77.github.io&#39;, &#39;js&#39;, index: 20, input: &#39;Visit my website at https://maku77.github.io/js&#39; ] index プロパティの値が 20 ということは、検索された URL が 20 の位置から始まっていることを示しています。 input プロパティには、検索対象となったテキストへの参照が含まれているのがわかります。 String#match(regexp) を使用したこのようなパターン抽出は非常に便利ですが、1つのテキスト内に一致する部分が複数含まれているような場合にはうまく抽出できないことに注意してください。 なぜなら、String#match(regexp) は、最初に見つかった部分の結果だけを抽出して返すからです（String#search() が最初に見つかった部分の位置を返すのと同様です）。 先に述べたように、正規表現パターンに g フラグを付けて検索すれば、パターンに一致する文字列をまとめて配列として取得できますが、ここで説明したような特定のフォーマットに一致する文字列の各パート（( と ) でグルーピングした部分）を抽出するということはできません。 この問題を解決するには、次に説明する正規表現オブジェクトの RegExp#exec() メソッドを使用する必要があります。 RegExp オブジェクトを使用したパターン抽出（最強！） String#match(regexp)（正規表現の g フラグなし）のような特定のフォーマットに従った部分文字列の抽出を、1 つの検索対象テキストの中で繰り返し実行（グローバル検索）したい場合は、RegExp#exec(string) メソッドを使用する必要があります。 両者の使用方法はほぼ同様ですが、呼び出しの関係が下記のように入れ替わることに注意してください。 正規表現オブジェクト.exec(検索対象テキスト) ここでは、下記のような検索対象テキストの中から、URL のホスト名、パス部分を繰り返し抽出するようなケースを考えてみます（2 つの URL からそれぞれホスト名とパスを抽出します）。 Visit my website at https://example.com/file1 and https://example.co.jp/file2 RegExp#exe(string) の戻り値は、String#match(regexp) の（g オプションなしで呼び出した場合の）戻り値と同様の配列で、最初の要素としてパターンに一致した部分の全体が格納され、残りの配列要素（インデックス1以降）には、( と ) でグルーピングされたパターンに一致した部分文字列が順番に格納されます。 検索パターンに一致する文字列が見つからなかった場合は、null を返します。 String#match(regexp) と異なるのは、RegExp#exec(string) は検索結果を返す度に、自分自身の lastIndex プロパティを更新し、次の検索はその位置から検索を始めるという点です。 この仕組みにより、繰り返し exec メソッドを呼び出すことでパターンに一致する部分をすべて検索することが可能になっています。 const re = /(\\w+):\\/\\/([\\w.]+)\\/(\\S*)/g; // gフラグを忘れない！ const text = `Visit my website at https://example.com/file1 and https://example.co.jp/file2`; let matches; while ((matches = re.exec(text)) != null) { const protocol = matches[1]; const host = matches[2]; const path = matches[3]; console.log(&#39;host = &#39; + host); console.log(&#39;path = &#39; + path); console.log(&#39;lastIndex = &#39; + re.lastIndex); console.log(&#39;----------------&#39;); } 実行結果 host = example.com path = file1 lastIndex = 45 ---------------- host = example.co.jp path = file2 lastIndex = 77 ---------------- 検索結果が返される度に、次の検索開始位置を示す RegExp#lastIndex の値が更新されていることに注目してください。 このように、1 つの検索対象テキストに対して複数回の検索を実行する場合は、必ず 正規表現の g フラグ（グローバル検索）を ON にしておく 必要があります。 これを忘れると、RegExp#exec() メソッドを実行したときに、RegExp オブジェクトの lastIndex プロパティが更新されず、毎回先頭からの検索になっていまいます（結果的に上記のような while ループは無限ループになってしまう）。 ☝️ ワンポイント RegExp#exec() による検索が最後まで進むと（戻り値で null が返されるまで実行されると）、lastIndex の値は自動的に 0 にリセットされます。 そのため、通常は複数の検索対象テキストに対して、同じ RegExp オブジェクトを使って検索を続けることができます。 ただし、検索を途中で中断して別のテキストを検索したい場合は、明示的に lastIndex の値を 0 にリセットする必要があります。 RegExp#exec() メソッドの振る舞いは若干ややこしいところがありますが、これを使いこなせるようになれば、正規表現を利用した文字列抽出のタスクはほとんどカバーできるようになります。"},{url:"/p/p5nx3n9/",title:"JavaScript で文字列の中から文字列を検索する (String#search, RegExp#test)",date:"2018-09-11T00:00:00+09:00",body:"JavaScript で文字列の中から文字列を検索する (String#search, RegExp#test) String#search による文字列検索 search の基本 String#search() メソッドを使用すると、正規表現パターンを使用して String オブジェクト内の文字列を検索することができます。 文字列が見つかった場合は、その先頭のインデックスを返し、見つからなかった場合は -1 を返します。 パラメータには RegExp オブジェクトを指定するか、次のように正規表現リテラルで検索パターンを指定します（単純な文字列を渡した場合は、内部で RegExp オブジェクトが生成されます）。 例: text の中から leader という文字列を検索 const text = &#34;A leader is a dealer in hope.&#34;; const index = text.search(/leader/); if (index == -1) { console.log(&#34;見つかりませんでした&#34;); } else { console.log(`位置 ${index} に見つかりました`); } 実行結果 位置 2 に見つかりました。 大文字と小文字を区別しない検索 String#search() メソッドのパラメータとして渡す正規表現の属性として i を指定すると、大文字と小文字を区別しない検索を行えます。 const index = text.search(/javascript/i); 上記のようにすると、JavaScript にも javascript にも JAVASCRIPT にも一致します。 コラム: グローバル検索はない String#search() メソッドは、最初に見つかった文字列のインデックスを返すため、次のように正規表現属性の g（グローバル検索）を指定しても無視されます（意味がありません）。 検索時は正規表現の g 属性は無視される var text = &#34;Pen pineapple apple pen&#34;; var index = text.search(/apple/g); console.log(index); //=&gt; 8 上記の例では、テキスト内に apple という文字列は 2 か所（8と14）見つかりますが、返されるインデックスは最初に見つかった文字列のインデックス 8 のみです。 RegExp#test による文字列検索 正規表現オブジェクトの RegExp#test(string) メソッドを使っても、String#search(regexp) と同様に文字列検索を行うことができます。 ただし、こちらの場合は、見つかった位置を返すのではなく、単純に見つかったかどうかを示す真偽値 (true/false) を返します。 const re = /java/i; console.log(re.test(&#39;Javascript is not Java&#39;)); //=&gt; true console.log(re.test(&#39;Python is cool&#39;)); //=&gt; false console.log(re.test(&#39;Ruby is fantastic&#39;)); //=&gt; false ユーザ入力を使った検索 ユーザが入力したテキストなど、文字列変数に格納された値を使って正規表現オブジェクトを作成するには、RegExp コンストラクタを使用します。 RegExp コンストラクタの第 2 引数では、正規表現属性（g、i、gi などのフラグ）を指定することができます。 // ユーザの入力したテキストが input 変数に格納されていると仮定 // const input = &#34;Java&#34;; var re = new RegExp(input, &#34;i&#34;); if (re.test(&#34;Javascript is not Java&#34;)) { console.log(&#34;見つけたっ&#34;); }"},{url:"/p/mp48ku2/",title:"Vim で複数行の行頭に同じテキストを挿入する",date:"2018-09-04T00:00:00+09:00",body:"Vim で複数行の行頭に同じテキストを挿入する すべての行の行頭にテキストを追加 すべての行の行頭にスペース4文字を挿入したいときは、次のように置換コマンドを実行します。 :%s/^/ / % はすべての行に対して置換を実行することを表します。 ^ は行頭を表す記号です。 選択範囲の行の行頭にテキストを追加 特定範囲の行の行頭だけに、文字を挿入したいときは次のようにします。 0 で行頭にフォーカスを移動する。 Ctrl-v で矩形選択モードにし、j を数回押して、対象範囲の行の行頭がすべて選択された状態にする。 Shift-i で行頭への挿入モードに入り、任意の文字を入力。 Esc で挿入モードを抜ける。 文字の入力中は、カレント行にしか文字が挿入されていないかのように見えますが、最後に Esc キーで挿入モードを抜けたときに、すべての行に同じ文字が挿入されます。 ソースコードの複数行をまとめてコメントアウトしたり、（上記アニメーションのように）Markdown 内のテキストをまとめて箇条書きにしたりするときに便利できます。"},{url:"/p/k7jv7hs/",title:"Hugo で Sass (SASS/SCSS) スタイルシートを使用する",date:"2018-08-16T00:00:00+09:00",body:"Hugo で Sass (SASS/SCSS) スタイルシートを使用する Hugo 0.46 で Sass (SASS/SCSS) がサポートされました。 これを使うと、スタイルシートを効率的に記述できるようになります。&quot; Sass とは Sass (SASS/SCSS) は CSS のプリプロセッサで、これを利用すると、柔軟な変数の仕組みや、入れ子構造を用いたスタイルシート記述が可能になります。 Sass: Syntactically Awesome Style Sheets Sass の記述フォーマットとしては、古い SASS 記法（拡張子 .sass）と、新しい SCSS 記法（拡張子 .scss）がありますが、現在は CSS のフォーマットと互換性のある SCSS 記法が主流になっています。 最新の CSS では、ネイティブに変数の仕組みなどをサポートしていますが、ブラウザの対応状況もまだまだなので、しばらくは Sass が使われ続けるでしょう。 Hugo で Sass を使用する Hugo で Sass を使用する方法は、下記の本家ドキュメントに記述されています。 Hugo Pipes ＞ SASS/SCSS Hugo Pipes ＞ Hugo Pipes Introduction 大まかな手順は次の通りです。 ルートの assets ディレクトリ以下に .scss ファイルを配置する。 テンプレート内でパイプコマンドを利用して .scss ファイルを .css に変換し、変換後の .css ファイル名を link 要素で指定する。 1. assets ディレクトリに .scss ファイルを配置する 本家のドキュメントでは、resources.Get 関数を使って .scss ファイルを読み込む方法が紹介されています。 デフォルトの設定では、この関数はプロジェクトのルートにある assets ディレクトリ以下のファイルを検索するようになっています。 ここでは、assets ディレクトリ以下に sass ディレクトリを作成し、その中に .scss ファイルを格納していくことにしましょう。 main.scss ファイルの中から _color.scss ファイルの内容をインポートするようにしています。 assets/sass/main.scss @import &#34;color.scss&#34;; body { background: $BASE_COLOR; } assets/sass/_color.scss $BASE_COLOR: #f3f3f3; 2. テンプレート内で .scss ファイルを .css に変換し、link 要素で指定する これも本家のドキュメントに記載されている通りです。 head 要素を出力するテンプレート（ここでは baseof テンプレート）の中に下記のように記述します。 layouts/_default/baseof.html（抜粋） {{ $style := resources.Get &#34;sass/main.scss&#34; | toCSS | minify | fingerprint }} &lt;link rel=&#34;stylesheet&#34; href=&#34;{{ $style.Permalink }}&#34;&gt; resources.Get で読み込んだ SCSS をパイプでいくつかの関数に渡していますが、最低限必要なのは toCSS による変換処理です。 その後ろに続く minify は CSS のコード圧縮、fingerprint は SCSS の変更が反映されないことを防ぐ（ファイル名に毎回違うサフィックスを付加してキャッシュが使用されるのを防ぐ）ための処理です。 これで、Hugo で Sass (SASS/SCSS) を使えるようになります。 あとは、main.scss ファイルの内容を更新すれば、自動的に CSS に変換されて反映されるようになります。"},{url:"/p/kma3bsu/",title:"Android Gradleメモ: Android アプリが使用している依存ライブラリをツリー構造で表示する（dependencies/androidDependencies タスク）",date:"2018-07-26T00:00:00+09:00",body:"Android Gradleメモ: Android アプリが使用している依存ライブラリをツリー構造で表示する（dependencies/androidDependencies タスク） Gradle の dependencies タスクを実行すると、あるプロジェクトが依存するライブラリ（およびサブモジュール）の一覧を、ツリー構造で表示することができます。 一般的な Android アプリの構成では app が最上位のモジュールになるので、:app:dependencies というタスクを実行すれば、アプリ全体（APK 全体）のライブラリ依存関係を調べることができます（:app 部分を省略するとエラーになるので注意してください）。 $ gradlew -q :app:dependencies デフォルトではすべてのコンフィギュレーションにおける依存関係が表示される（テストビルド時の依存関係なども表示される）ので、大量のテキストが出力されます。 出力対象を絞り込むために、--configuration オプションを指定して次のように実行します。 $ gradlew -q :app:dependencies --configuration releaseCompileClasspath &gt; deps-tree-compile.txt $ gradlew -q :app:dependencies --configuration releaseRuntimeClasspath &gt; deps-tree-runtime.txt コンフィギュレーション名のプレフィックス部分 (上記の場合は release) はビルドバリアント名であり、アプリごとに異なることに注意してください。 prodRelease であったり、hogehogeDebug だったりします。 下記は、出力結果の例です。 deps-tree-runtime.txt ------------------------------------------------------------ Project :app ------------------------------------------------------------ releaseRuntimeClasspath - Resolved configuration for runtime for variant: release +--- com.android.support:support-annotations:27.1.1 +--- com.android.support:support-core-utils:27.1.1 | +--- com.android.support:support-annotations:27.1.1 | \\--- com.android.support:support-compat:27.1.1 | +--- com.android.support:support-annotations:27.1.1 | \\--- android.arch.lifecycle:runtime:1.1.0 | +--- android.arch.lifecycle:common:1.1.0 | \\--- android.arch.core:common:1.1.0 +--- project :common:hoge | \\--- project :common:mylib | +--- com.android.support:support-annotations:27.1.1 | +--- com.fasterxml.jackson.core:jackson-databind:2.4.2 | | +--- com.fasterxml.jackson.core:jackson-annotations:2.4.0 | | \\--- com.fasterxml.jackson.core:jackson-core:2.4.2 | +--- com.example.lib:property:1.18.0 | +--- com.example.lib:network:1.0.0 | \\--- com.example.lib:upgrade:1.0.1 +--- project :common:mylib (*) | ...省略... | \\--- project :feature:recommend +--- com.android.support:support-annotations:27.1.1 +--- com.android.support:support-core-utils:27.1.1 (*) +--- project :common:hoge (*) \\--- project :common:mylib (*) - dependencies omitted (listed previously) 依存関係は上記のように再帰的に検索されてツリー形式で表示されます。 サブモジュール名の末尾に (*) が付いているものは、それよりも前の行ですでに依存情報が出力されているため、出力が省略されたことを示しています。 dependencies タスクの代わりに、androidDependencies タスクを使用すると、ライブラリの依存関係が一階層でシンプルに出力されます。 $ gradlew -q :app:androidDependencies &gt; deps-all.txt 上記のように、ファイルに出力しておいて、対象のビルドバリアント名 (release など）のセクションを検索し、その下の xxxCompileClasspath や xxxRuntimeClasspath の内容を確認するとよいでしょう。 deps-all.txt release releaseCompileClasspath - Dependencies for compilation +--- androidx.activity:activity-ktx:1.2.3@aar +--- androidx.activity:activity:1.2.4@aar +--- androidx.annotation:annotation-experimental:1.1.0@aar +--- androidx.annotation:annotation:1.3.0@jar +--- androidx.appcompat:appcompat-resources:1.4.1@aar +--- androidx.appcompat:appcompat:1.4.1@aar ... releaseRuntimeClasspath - Dependencies for runtime/packaging +--- androidx.activity:activity-ktx:1.2.3@aar +--- androidx.activity:activity:1.2.4@aar +--- androidx.annotation:annotation-experimental:1.1.0@aar +--- androidx.annotation:annotation:1.3.0@jar +--- androidx.appcompat:appcompat-resources:1.4.1@aar +--- androidx.appcompat:appcompat:1.4.1@aar ..."},{url:"/p/dsfzi4n/",title:"Hugo のページ内に Tex 形式の数式を埋め込めるようにする (MathJax)",date:"2018-06-21T00:00:00+09:00",body:"Hugo のページ内に Tex 形式の数式を埋め込めるようにする (MathJax) Hugo のテンプレートで MathJax という Javascript ライブラリを組み込むと、Markdown 記事内に Tex 形式で数式を埋め込むことができるようになります。 下記は、MathJax による数式表示の例です。 $$ -b\\pm \\sqrt{b^2 -4ac} \\over 2a $$ 図: MathJax による数式表示 MathJax を有効にする MathJax を有効にするのは簡単で、HTML 内で MathJax の Javascript ファイルを読み込むだけです。 次の例では、Hugo の ベーステンプレート (baseof.html) の head 要素内に、MathJax を読み込むための script 要素を追加しています。 layouts/_default/baseof.html &lt;!DOCTYPE html&gt; &lt;html{{ with .Site.LanguageCode }} lang=&#34;{{ . }}&#34;{{ end }}&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; ... &lt;script type=&#34;text/javascript&#34; id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; 上記の例では、配信元の CDN として cdn.jsdeliver.net を指定していますが、他の CDN で配信されているものを使用することもできます。 詳しくは下記の MathJax のドキュメントを参照してください。 参考: Getting Started with MathJax Components 数式の記述例 ブロック形式 (displayed mathematics) ブロック形式（独立した段落）の数式を表示するには、Markdown ファイル内に $$ で囲む形で TeX を記述します（あるいは \\\\[ と \\\\] で囲みます）。 次の例では、Sum 記号（Σ）や分数を表示しています。 Markdown 内での記述例 $$ F(x) = \\sum_{n=1}^{N} \\frac{1}{N} $$ $$ F(x) = \\sum_{n=1}^{N} \\frac{1}{N} $$ 図: 出力結果 インライン形式 (in-line mathematics) 文章内にインライン形式で数式を埋め込むには、\\\\( と \\\\) で TeX 命令を囲みます。 Markdown 内での記述例 次の数式は \\\\(F(x) = \\sum_{n=1}^{N} \\frac{1}{N}\\\\) 文章内に埋め込まれます。 表示結果: 次の数式は \\(F(x) = \\sum_{n=1}^{N} \\frac{1}{N}\\) 文章内に埋め込まれます。 参考 数学メモ: TeX チートシート｜まくろぐ 必要なときのみ MathJax を読み込むようにする 数式を使わないページで MathJax の JavaScript ファイルを読み込むのは無駄です。 次の例では、記事のフロントマターに useMath: true という指定があるときのみ MathJax を有効化しています。 layouts/_default/baseof.html &lt;!DOCTYPE html&gt; &lt;html{{ with .Site.LanguageCode }} lang=&#34;{{ . }}&#34;{{ end }}&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; ... {{- if eq .Params.useMath true }} &lt;script type=&#34;text/javascript&#34; id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt; &lt;/script&gt; {{- end }} &lt;/head&gt; ... あとは、数式を使用する記事ページで次のようにフロントマターを記述すれば OK です。 MathJax の有効化 --- title: &#34;ページタイトル&#34; date: &#34;2023-10-21&#34; useMath: true --- オイラーの公式： \\\\(\\mathrm{e}^{\\mathrm{i}\\theta} = \\cos(\\theta) + \\mathrm{i}\\sin(\\theta)\\\\) （おまけ）水平方向にスクロールできるようにする 数式（特にブロック形式）が長くなって親要素の横幅に収まらない場合、デフォルトでは親要素をはみ出して数式が描画されてしまいます。 次のような CSS を設定しておけば、横幅が足りないときに水平方向のスクロールバーを表示してスクロールできるようになります。 /* MathJax の数式が横に長いときにスクロールバーを表示 */ mjx-container { overflow-x: auto; overflow-y: hidden; max-width: 100%; }"},{url:"/p/8env4bi/",title:"Hugo で Markdown (.md) ファイルのパス情報を取得する",date:"2018-06-14T00:00:00+09:00",body:"Hugo で Markdown (.md) ファイルのパス情報を取得する Hugo のテンプレートファイル内で、File 変数を参照すると、記事ページのもとになった Markdown ファイルのパス情報を取得することができます。 File 変数の一覧は下記のページで参照できます。 File Variables｜Hugo File 変数の使用例 テンプレートファイルに下記のようなコードを追加すれば、File 変数の内容を簡単に確認できます。 layouts/_default/baseof.html（抜粋） &lt;pre&gt; .File.Filename = {{ .File.Filename }} .File.Path = {{ .File.Path }} .File.Dir = {{ .File.Dir }} .File.LogicalName = {{ .File.LogicalName }} .File.BaseFileName = {{ .File.BaseFileName }} .File.Extension = {{ .File.Extension }} &lt;/pre&gt; 例えば、C:\\Users\\maku\\website\\content\\diary\\2018.md から生成されたページ (diary/2018.html) にアクセスすると、以下のようなパス情報を取得することができます。 .File.Filename = C:\\Users\\maku\\website\\content\\diary\\2018.md .File.Path = diary\\2018.md .File.Dir = diary\\ .File.LogicalName = 2018.md .File.BaseFileName = 2018 .File.Extension = md Hugo サーバ動作させているときに Markdown ファイルのパスを表示する テンプレート内に下記のように記述しておけば、Hugo のローカルサーバで Web サイトをホスティングしている場合のみ、ローカル PC 内の Markdown ファイルのパスを表示することができます。 {{- /* Markdown ファイルのパスを表示 */}} {{- if hugo.IsServer -}} &lt;div style=&#34;text-align:right; font-size: smaller;&#34;&gt; {{- with .File }}{{ .Filename }}{{ end -}} &lt;/div&gt; {{- end }} 記事内に表示されたパスをターミナル上にコピペして、任意のエディタで開くということが素早く行えるようになります。 タグの一覧ページなど、生成元の Markdown ファイルが存在しない場合は、.File.Filename の値は空っぽになることに注意してください。 応用 Hugo ページの生成元になった Markdown (.md) ファイルを VS Code で開くリンクを表示する"},{url:"/p/q4o6n4k/",title:"Hugo でファイルが存在する場合のみ処理するコードを記述する (fileExists)",date:"2018-06-11T00:00:00+09:00",body:"Hugo でファイルが存在する場合のみ処理するコードを記述する (fileExists) Hugo のテンプレートの中で、fileExists 関数を使用すると、指定したファイルが存在する時のみ有効になる処理を記述することができます。 例えば、次のようにすると、static ディレクトリに画像ファイル (img/site-logo.png) が存在する場合のみ、その画像を表示する img 要素を出力します。 {{ if (fileExists &#34;static/assets/img/site-logo.png&#34;) }} &lt;img src=&#34;{{ &#34;assets/img/site-logo.png&#34; | absURL }}&#34;&gt; {{ end }} 参考: fileExists｜Hugo"},{url:"/p/8ogzaxd/",title:"Hugo のページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする",date:"2018-06-02T00:00:00+09:00",body:"Hugo のページャー（ページネーター）で複数の記事を切り替えながら表示できるようにする Hugo には Pagenator という標準のページャー機能が備わっており、比較的簡単にページャー機能を組み込むことができます（参考: Pagination｜Hugo）。 ページャーの基本 ページャーとは、Google の検索結果のページなどで表示される、下記のようなものです。 図: ページャーの例 あるカテゴリに属する記事のリストを表示するときや、数日分の日記をまとめて表示するようなケースでは、1 ページが長くなりすぎないように、ページャーを導入することを検討するのがよいでしょう。 Hugo でページャーを導入すると、デフォルトでは /page/1、/page/2、/page/3 といった URL で、それぞれのグループ（複数の記事をまとめたページ）を表示するためのページにアクセスできるようになります（page というパスは、Hugo のコンフィグファイルの PaginatePath で変更できます）。 図: ページャーによる切り替え Hugo のページャー機能は、ホームページとリスト系ページ（セクションページや、タクソノミーリスト）のみで有効です。 つまり、ホームページテンプレート (layouts/index.html) や、リストテンプレート (layouts/_default/list.html) などに適用することになります。 ホームページテンプレートに適用すれば、それぞれのグループを表示するためのページには、次のようなアドレスでアクセスできるようになります。 https://example.com/page/1 （https://example.com/ のエイリアス） https://example.com/page/2 https://example.com/page/3 セクションテンプレートに適用した場合は、次のようなアドレスでアクセスできるようになります。 https://example.com/&lt;SECTION&gt;/page/1 （https://example.com/&lt;SECTION&gt;/ のエイリアス） https://example.com/&lt;SECTION&gt;/page/2 https://example.com/&lt;SECTION&gt;/page/3 ここでのポイントは、上記のようなファイル群は、1 つのホームページテンプレート（あるいはセクションテンプレート）から自動的に生成されるということです。 つまり、複数のページとして出力されてはいるものの、ページャー部分以外のコンテンツは同じになります。 後述するように、テンプレート内で .Pagenator にアクセスすると、Hugo は自動的にこれらのファイルを出力するようになります。 ちなみに、単独のページを出力するためのシングルページテンプレート (layouts/_default/single.html) ではページャー機能は使えないので、代わりに、ページ切り替え用の「次のページ」、「前のページ」といったリンク を表示しておくのがよいでしょう。 ページャーを導入する 組み込みの pagination テンプレートを使用する 1 グループごとの記事のリストは、.Pagenator.Pages で参照することができるようになっているので、これを range を使って列挙すれば OK です。 デフォルトでは 10 記事ごとがグルーピングされていますが、このサイズは Hugo のコンフィグファイルの Paginate で変更できます。 肝心のページ切り替え部分は、Hugo 組み込みのテンプレート _internal/pagination.html を使用して出力することができます。 つまり、ページャー機能を使って、シンプルにグループ内の記事リンクを列挙し、さらに切り替え部分を表示するなら、下記のようなテンプレートを記述すればよいことになります。 layouts/index.html（ホームページテンプレートの抜粋） &lt;h3&gt;ページリスト&lt;/h3&gt; &lt;ul&gt; {{- range .Paginator.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; &lt;h3&gt;切り替え&lt;/h3&gt; {{ template &#34;_internal/pagination.html&#34; . }} 上記のようなテンプレートからは、下記のような URL でアクセス可能な HTML ファイルが出力されます。 ここでは、先頭のグループにアクセスするため、下記のいずれかのアドレスにアクセスしたと考えてください。 https://&lt;ドメイン&gt;/ https://&lt;ドメイン&gt;/page/1 （上記のエイリアス） HTML 出力サンプル &lt;h3&gt;ページリスト&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/title1/&#34;&gt;タイトル1&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title2/&#34;&gt;タイトル2&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title3/&#34;&gt;タイトル3&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title4/&#34;&gt;タイトル4&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title5/&#34;&gt;タイトル5&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title6/&#34;&gt;タイトル6&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title7/&#34;&gt;タイトル7&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title8/&#34;&gt;タイトル8&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title9/&#34;&gt;タイトル9&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/title10/&#34;&gt;タイトル10&lt;/a&gt; &lt;/ul&gt; &lt;h3&gt;切り替え&lt;/h3&gt; &lt;ul class=&#34;pagination&#34;&gt; &lt;li&gt;&lt;a href=&#34;/&#34; aria-label=&#34;First&#34;&gt;&lt;span aria-hidden=&#34;true&#34;&gt;&amp;laquo;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&#34;disabled&#34;&gt;&lt;a href=&#34;&#34; aria-label=&#34;Previous&#34;&gt;&lt;span aria-hidden=&#34;true&#34;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&#34;active&#34;&gt;&lt;a href=&#34;/&#34;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#34;/page/2/&#34;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#34;/page/3/&#34;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=&#34;disabled&#34;&gt;&lt;span aria-hidden=&#34;true&#34;&gt;&amp;hellip;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#34;/page/8/&#34;&gt;8&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#34;/page/2/&#34; aria-label=&#34;Next&#34;&gt;&lt;span aria-hidden=&#34;true&#34;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#34;/page/8/&#34; aria-label=&#34;Last&#34;&gt;&lt;span aria-hidden=&#34;true&#34;&gt;&amp;raquo;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 後半のグループ切り替え部分は、Hugo 組み込みのテンプレート (_internal/pagination.html) によって出力されたもので、Bootstrap ベースの構造で出力されています。 Bootstrap を採用していない Web サイトでは、そのままでは思ったような表示にならないので、出力に合わせた CSS を定義してやる必要があります。 ul 要素に設定される pagination クラス li 要素の active クラス（現在のページ）と disabled クラス（その他のページ） あたりを考慮した CSS を記述すればよさそうです。 下記は、Bootstrap の pagination クラスまわりの定義を抜粋したものです。 .pagination { display: inline-block; padding-left: 0; margin: 20px 0; border-radius: 4px; } .pagination &gt; li { display: inline; } .pagination &gt; li &gt; a, .pagination &gt; li &gt; span { position: relative; float: left; padding: 6px 12px; margin-left: -1px; line-height: 1.42857143; color: #337ab7; text-decoration: none; background-color: #fff; border: 1px solid #ddd; } .pagination &gt; li:first-child &gt; a, .pagination &gt; li:first-child &gt; span { margin-left: 0; border-top-left-radius: 4px; border-bottom-left-radius: 4px; } .pagination &gt; li:last-child &gt; a, .pagination &gt; li:last-child &gt; span { border-top-right-radius: 4px; border-bottom-right-radius: 4px; } .pagination &gt; li &gt; a:hover, .pagination &gt; li &gt; span:hover, .pagination &gt; li &gt; a:focus, .pagination &gt; li &gt; span:focus { z-index: 2; color: #23527c; background-color: #eee; border-color: #ddd; } .pagination &gt; .active &gt; a, .pagination &gt; .active &gt; span, .pagination &gt; .active &gt; a:hover, .pagination &gt; .active &gt; span:hover, .pagination &gt; .active &gt; a:focus, .pagination &gt; .active &gt; span:focus { z-index: 3; color: #fff; cursor: default; background-color: #337ab7; border-color: #337ab7; } .pagination &gt; .disabled &gt; span, .pagination &gt; .disabled &gt; span:hover, .pagination &gt; .disabled &gt; span:focus, .pagination &gt; .disabled &gt; a, .pagination &gt; .disabled &gt; a:hover, .pagination &gt; .disabled &gt; a:focus { color: #777; cursor: not-allowed; background-color: #fff; border-color: #ddd; } この CSS 定義を使用すると、ページャーの切り替え部分は下記のような表示になります。 図: ページャーの表示例 切り替え部分のテンプレートを自作する ページャーによる切り替え部分は、Hugo の組み込みテンプレート (_internal/pagination.html) を使って出力することができました。 この組み込みテンプレートの出力内容が気に入らない場合は、その内容を参考にしながら独自のテンプレートを作成することになるでしょう。 _internal/pagination.html の内容は、Hugo の GitHub リポジトリで参照することができます。 tpl/tplimpl/embedded/templates/pagination.html &ndash; gohugoio/hugo"},{url:"/p/zxk6pat/",title:"Hugo で Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics)",date:"2018-06-01T00:00:00+09:00",body:"Hugo で Google アナリティクス用のトラッキングコードを埋め込む (googleAnalytics) Google Analytics を使用すると、Web サイトのアクセス情報を多角的に分析できるようになります。 ここでは、Hugo で作成する Web サイトに、簡単に Google Analytics 用のコードを埋め込めるようにしてみます。 ☝️ Google Analytics 4 (GA4) への移行 Google は従来 Google Analytics (Universal Analytics) を提供していましたが、2023 年 7 月以降は、最新バージョン Google Analytics 4 (GA4) しか使用できなくなります。 ただし、乗り換えは簡単で、設定するトラッキング ID を GA4 用のものに変更するだけです。 Analytics ID の先頭部分を見ると、どちらのバージョンを使用しているかが分かります。 （旧）Universal Analytics の ID &hellip; UA-12345678-1 （新）Google Analytcs 4 (GA4) の ID &hellip; G-12345ABCDE トラッキング ID をコンフィグファイルで設定する まずは、Google Analytics の管理画面から、「プロパティの追加」を実行し、分析したい Web サイトのアドレスを追加しておきます（Google Analytics のアカウントを持っていない場合は、先にアカウントから作成しておく必要があります）。 そのとき発行されるトラッキング ID（G-12345ABCDE のような ID）が、その Web サイトへのアクセスを判別するための識別情報となります。 この ID は、Web サイトごとに別のものを使用するので、Hugo のコンフィグファイルで設定するのがよいでしょう。 Hugo には、コンフィグファイル用のパラメータとして、あらかじめ googleAnalytics というパラメータが用意されています。 下記のような感じで、Google Analytics のサイトで発行したトラッキング ID を設定しましょう。 config.toml baseURL = &#34;https://example.com/&#34; languageCode = &#34;ja-jp&#34; title = &#34;まく日記&#34; theme = &#34;maku&#34; googleAnalytics = &#34;G-12345ABCDE&#34; 上記のように設定すると、テンプレートファイルの中から、.Site.GoogleAnalytics でトラッキング ID を参照できるようになります。 トラッキングコード (JS) を自動で埋め込むようにする Google Analytics を有効にするには、各ページの head 要素の先頭に、次のような トラッキングコード を埋め込む必要があります（参考: gtag.js を使用してアナリティクスのトラッキングを設定する）。 &lt;!-- Google tag (gtag.js) --&gt; &lt;script async src=&#34;https://www.googletagmanager.com/gtag/js?id=G-12345ABCDE&#34;&gt;&lt;/script&gt; &lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(&#39;js&#39;, new Date()); gtag(&#39;config&#39;, &#39;G-12345ABCDE&#39;); &lt;/script&gt; ここでは、Hugo のパーシャルテンプレートを使い、上記の HTML コードを各ページに埋め込むようにしましょう。 G-12345ABCDE のようなトラッキング ID を指定する部分は、コンフィグファイルの googleAnalytics パラメータで指定した値で置換するようにします。 layouts/partials/analytics.html {{ if not hugo.IsServer }} {{ with .Site.GoogleAnalytics }} &lt;!-- Google tag (gtag.js) --&gt; &lt;script async src=&#34;https://www.googletagmanager.com/gtag/js?id={{ . }}&#34;&gt;&lt;/script&gt; &lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(&#39;js&#39;, new Date()); gtag(&#39;config&#39;, &#39;{{ . }}&#39;); &lt;/script&gt; {{ end }} {{ end }} ☝️ ワンポイント 上記テンプレートの 1、2 行目では、ローカルな Hugo サーバでテストしている場合や、googleAnalytics が設定されていない場合に、トラッキングコードを出力しないように制御しています。 作成したパーシャルテンプレートは、下記のようにテンプレートファイルからインクルードします（ここでは、ベーステンプレート (baseof) からインクルードしています）。 layouts/_default/baseof.html &lt;!DOCTYPE html&gt; &lt;html lang=&#34;ja&#34;&gt; &lt;head&gt; {{- partial &#34;analytics&#34; . -}} &lt;meta charset=&#34;UTF-8&#34;&gt; ...省略... &lt;/head&gt; &lt;body&gt; ...省略... &lt;/body&gt; &lt;/html&gt; これで、すべてのページに Google Analytics のトラッキングコードが埋め込まれるようになります。 （おまけ）Hugo 組み込みのテンプレート 実は、Hugo は組み込みの Internal Template として、Google Analytics のトラッキングコードを埋め込むためのテンプレートを用意しています。 任意のテンプレートファイルの中で、 {{ template &#34;_internal/google_analytics.html&#34; . }} &lt;!-- 同期バージョン --&gt; {{ template &#34;_internal/google_analytics_async.html&#34; . }} &lt;!-- 非同期バージョン --&gt; のように記述するだけで、簡単にトラッキングコードを埋め込むことができます。 ただし、組み込みのテンプレートは、ローカルサーバー動作時のコード出力抑制には対応していませんし、Google の変更に柔軟に対応することもできないので、できればパーシャルテンプレートは自作してしまった方がよいでしょう。"},{url:"/p/5m9tdwg/",title:"Hugo でコンフィグファイルに設定した情報を参照する",date:"2018-06-01T00:00:00+09:00",body:"Hugo でコンフィグファイルに設定した情報を参照する コンフィグファイルの基本 Hugo サイトの全般的な設定は、ルートディレクトリに置いた下記のいずれかのコンフィグファイルで行います（最初に見つかったものが採用されます）。 hugo.toml （TOMLフォーマットで記述） hugo.yaml （YAMLフォーマットで記述） hugo.json （JSONフォーマットで記述） hugo.toml の記述例 baseURL = &#34;https://example.com/&#34; languageCode = &#34;ja-jp&#34; title = &#34;まく日記&#34; themesDir = &#34;../hugo_themes&#34; theme = &#34;maku&#34; 設定可能なパラメータや、それぞれのデフォルト値は下記に一覧があります。 Configure Hugo｜Hugo ☝️ hugo.toml と config.toml Hugo v0.110.0 でコンフィグファイル名が config.toml から hugo.toml に変更されました。 互換性のために config.toml のままでも動作するようですが、各種エディタやツールとの連携のためのリネームらしいので、新しい名前に乗り換えておいた方がよいでしょう。 設定値を参照する Hugo が定義しているパラメータを参照する コンフィグファイルで設定したパラメータは、テンプレートファイル内から、.Site 変数を使って参照することができます。 例えば、hugo.toml ファイルの中で設定した title や baseURL パラメータの値は次のようにして参照することができます。 このサイトのタイトルは &lt;b&gt;{{ $.Site.Title }}&lt;/b&gt; です。 このサイトのベースアドレスは &lt;b&gt;{{ $.Site.BaseURL }}&lt;/b&gt; です。 パラメータ名の先頭は、大文字になっていることに注意してください（.Site.title ではなく .Site.Title が正しい）。 それぞれの設定値が、どのようなプロパティ名で参照できるようになっているかは、下記の Site 変数の一覧を見るとわかります。 Site Variables｜Hugo パラメータが設定されているかどうかで処理を分岐させたい場合は、例えば次のように記述しておけばよいでしょう。 ここでは、googleAnalytics というパラメータで、Google Analytics 用のトラッキング ID が設定されているかどうかをチェックしています。 {{ with $.Site.GoogleAnalytics }} Google Analytics のトラッキング ID は &lt;b&gt;{{ . }}&lt;/b&gt; です。 {{ else }} Google Analytics のトラッキング ID が設定されていません。 {{ end }} 参考: Google アナリティクス用のトラッキングコードを埋め込む 独自定義のパラメータを参照する コンフィグファイルで独自定義のパラメータを設定するには、params セクションの下にパラメータを追加します。 hugo.toml baseURL = &#34;https://example.com/&#34; languageCode = &#34;ja-jp&#34; title = &#34;まく日記&#34; [params] GitHubUser = &#34;maku77&#34; Twitter = &#34;hogehoge&#34; Subtitle = &#34;天才まくまくのゆるふわ日記といろんなメモ&#34; Description = &#34;ここには、このサイトの詳細情報を記述します。&#34; SidebarRecentLimit = 5 ListOfFoo = [&#34;foo1&#34;, &#34;foo2&#34;] 独自定義のパラメータは、テンプレートファイル内から $.Site.Params.名前 という形で参照することができます。 下記の例では、独自パラメータの Description の値を参照しています。 独自パラメータを参照する (layouts/partials/head.html) &lt;meta name=&#34;description&#34; content=&#34;{{ if .IsHome }}{{ $.Site.Params.description }}{{ else }}{{ .Description }}{{ end }}&#34; /&gt; ちなみに、このサンプルでは、ホームページではサイトのコンフィグ設定 ($.Site.Params.Description) を参照し、それ以外のページでは、各ページのフロントマターに設定した description パラメータの値を参照するようにしています。"},{url:"/p/taxh3m7/",title:"Hugo サーバーで記事の変更内容が反映されない場合",date:"2018-05-29T00:00:00+09:00",body:"Hugo サーバーで記事の変更内容が反映されない場合 Hugo サーバーを立ち上げて記事の更新をしていると、Web ブラウザをリロードしても変更内容が反映されないことがあります（特に layouts や partials など、共有して使う部分など）。 ページのビルドに成功しているのに変更内容が反映されない場合は、Hugo サーバーのキャッシュを疑ってみるとよいかもしれません。 hugo server コマンドを実行するときに、--ignoreCache オプションをつけると、キャッシュを使わずにレンダリングされます。 $ hugo server --ignoreCache"},{url:"/p/pocxi4n/",title:"Hugo で最近更新された記事（新着記事）のリストを表示する",date:"2018-05-29T00:00:00+09:00",body:"Hugo で最近更新された記事（新着記事）のリストを表示する 新しく作成した記事を列挙する 下記のテンプレートコードは、日付（フロントマターの date フィールドの値）の新しい順に、 5 件分のリンクを表示します。 作成日 (date) 順に 5 件のリンクを表示する &lt;h2&gt;新着記事&lt;/h2&gt; &lt;ul&gt; {{ range first 5 .Site.RegularPages.ByDate.Reverse }} &lt;li&gt; &lt;b&gt;&lt;a href=&#34;{{.RelPermalink}}&#34;&gt;{{.Title}}&lt;/a&gt;&lt;/b&gt; &lt;time&gt;{{.Date.Format &#34;2006-01-02&#34;}}&lt;/time&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; .Site.RegularPages.ByDate.Reverse という部分で、サイト内の全ページを日付の逆順に列挙することを示しています（インデックス系のページも列挙したい場合は .RegularPages の部分を .Pages に変更してください）。 first 5 は、その中の最初の 5 件を取り出すという命令です。 .Date.Format による日時フォーマットの指定方法は、こちらの Go 言語の記事 を参考にしてください。 更新日 (lastmod) の新しい順に列挙する date ではなく lastmod を使う 上記の例では、記事の作成日（date フィールド）を基準にして最新記事を列挙しましたが、更新日時（lastmod フィールド）を基準に最新記事を列挙することもできます。 次のようにコードを置き換えるだけで OK です。 .Date → .Lastmod .ByDate → .ByLastmod 最終更新日 (lastmod) 順に 5 件のリンクを表示する &lt;h2&gt;最近更新された記事&lt;/h2&gt; &lt;ul&gt; {{ range first 5 .Site.RegularPages.ByLastmod.Reverse }} &lt;li&gt; &lt;b&gt;&lt;a href=&#34;{{.RelPermalink}}&#34;&gt;{{.Title}}&lt;/a&gt;&lt;/b&gt; &lt;time&gt;{{.Lastmod.Format &#34;2006-01-02&#34;}}&lt;/time&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; 記事のフロントマターに lastmod フィールドが定義されていない場合は、date フィールドが使用されるようになっています。 このようなフォールバックの仕組みが用意されているので、最新記事を列挙するときは、.ByDate よりも .ByLastmod を使うようにしておくのがよさそうです。 ただし、typo の修正などで lastmod を更新してしまうと、それだけで記事が一番上に出てきてしまうので、ある程度内容のある更新をしたときのみ lastmod の日付を更新するなどの工夫が必要かもしれません。 Git と連携して lastmod の日付を自動で設定する Hugo の設定ファイルで、下記のように設定しておくと、lastmod フィールドが設定されていない記事に対して、Git のコミット日時を自動的に設定してくれるようになります（Page 変数の .Lastmod を参照して日時を表示してください）。 config.toml（抜粋） enableGitInfo = true Git を使用しているのであれば、この設定を入れておくと便利かもしれません（参考: Git Info Variables｜Hugo）。 新着記事のリストにドラフトページを含めない where 関数を組み合わせて使用すると、新着記事の一覧から、ドラフトページ（ページのフロントマターに draft: true と書かれたもの）を除くことができます（参考: ドラフトページを作成する）。 &lt;h2&gt;新着記事&lt;/h2&gt; &lt;ul&gt; {{ range first 5 (where .Site.RegularPages.ByLastmod.Reverse &#34;.Draft&#34; &#34;!=&#34; true) }} &lt;li&gt; &lt;b&gt;&lt;a href=&#34;{{.RelPermalink}}&#34;&gt;{{.Title}}&lt;/a&gt;&lt;/b&gt; &lt;time&gt;{{.Lastmod.Format &#34;2006-01-02&#34;}}&lt;/time&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; ☝️ ワンポイント ドラフトページはデフォルトでは出力されないので、通常はこのようなフィルタリングは必要ありません。 hugo コマンドを実行するときに、-D オプションを指定すると、ドラフトページが出力されるようになります。 hugo server コマンドで Hugo サーバーのホスティングを行うときも同様です。 独自のページ変数を用意して、新着記事への表示／非表示を制御するというのもありですね。 例えば、ページのフロントマターに working: true と設定されていたら新着記事に列挙しないようにするには次のようにします。 &lt;h2&gt;新着記事&lt;/h2&gt; &lt;ul&gt; {{ range first 5 (where .Site.RegularPages.ByLastmod.Reverse &#34;.Params.working&#34; &#34;!=&#34; true) }} &lt;li&gt; &lt;b&gt;&lt;a href=&#34;{{.RelPermalink}}&#34;&gt;{{.Title}}&lt;/a&gt;&lt;/b&gt; &lt;time&gt;{{.Lastmod.Format &#34;2006-01-02&#34;}}&lt;/time&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; where 関数の条件式の &quot;.Draft&quot; &quot;!=&quot; true というところが &quot;.Params.working&quot; &quot;!=&quot; true に変わっただけです。"},{url:"/p/t8yiqm8/",title:"Linuxメモ: Deep Learning や仮想通貨のマイニング時に CPU 使用率が 100% になってしまうのを防ぐ (cpulimit)",date:"2018-05-02T00:00:00+09:00",body:"Linuxメモ: Deep Learning や仮想通貨のマイニング時に CPU 使用率が 100% になってしまうのを防ぐ (cpulimit) 概要 普段使い用の PC 上でディープラーニングのプログラムを走らせたりすると、CPU の負荷が 100% になってしまい、別の作業に支障が出てしまうことがあります（特に計算処理に GPU を使えない環境の場合）。 CPU の発熱量が半端なく、ファンが全力で回転してうるさくて集中できなくなってしまいます。 長時間高温な状態で動作させると、ハードウェアへのダメージも大きくなってしまうでしょう。 CPU 負荷を下げようとして、nice コマンドや renice コマンドを使用してプロセスの優先度（nice 値）の値を変更しても無駄です。 なぜなら、プロセスの優先度設定は、あくまで別のプロセスと比較したときの CPU 使用率の割合を変更するものであり、システムをアイドル状態にすることを促すものではないからです。 優先度の低いプロセスであっても、CPU に空きがあったら 100% まで使用してしまいます。 このようなときは、cpulimit を使ってプロセスの CPU 使用率を制限してやることで、負荷の低い状態をキープすることができます。 もちろん、そのプロセス内の処理には時間がかかるようになってしまいますが、ゆっくりでいいから処理が進めばいい、といったケースでは重宝すると思います。 cpulimit のインストール方法 cpulimit はそれぞれの OS 用のパッケージを使ってインストールしてしまうのが手っ取り早いでしょう。 Mac の場合（Homebrew を使用） $ brew install cpulimit Ubuntu (Linux) の場合 $ sudo apt-get install cpulimit cpulimit の使い方 cpulimit の -l (--limit) オプションを使用して、特定のプロセスの CPU 使用率をパーセンテージ指定で制限することができます。 例: プロセス番号 12345 を CPU 使用率50％に制限 $ cpulimit -l 50 -p 12345 ps コマンドなどで実行中のプロセスのプロセス ID を確認することができれば、その ID を指定して CPU 使用率に制限をかけることができます。 上記のように CPU 使用率を制限した場合、cpulimit のプロセスの方を Ctrl-C で停止すれば制限が解除されます。 例: CPU 使用率を指定して任意のコマンドを起動 $ cpulimit -l 50 &lt;コマンド&gt; 上記のように実行すると、最初から CPU 使用率に制限をかけた状態で任意のコマンドを起動することができます。 マルチコア CPU の場合の CPU 使用率 マルチコア CPU の環境を使用している場合、-l (--limit) オプションで指定可能なパーセンテージは、100 を超えます。 例えば、8 コアの CPU の場合、-l (--limit) オプションで指定できる値は 0〜800 になります。 現在の環境でどの範囲の値を指定することができるかは、下記のように cpulimit コマンドのヘルプの表示で確認することができます。 $ cpulimit -h | grep percentage -l, --limit=N percentage of cpu allowed from 0 to 800 (required) 例えば、下記の画面は Mac のアクティビティモニタ上で CPU の使用率を表示したものですが、先頭に表示されている Python プログラムは 8 コアの CPU すべてを使い、700% 前後の使用率で動作しています。 図: 700% 近くの CPU 使用率 次のように実行すれば、このプロセスの CPU 使用率を 200% に制限できます。 $ cpulimit -p 32645 -l 200 Process 32645 found しばらくすると、アクティビティモニタ上の CPU 使用率も 200% 程度に下がっていることを確認できます。 図: CPU 使用率が 200% に制限された cpulimit は内部で何をやっているか？ 下記は cpulimit の GitHub サイトからの抜粋です。 The control of the used CPU amount is done sending SIGSTOP and SIGCONT POSIX signals to processes. All the children processes and threads of the specified process will share the same percentage of CPU. 指定したプロセスの CPU 使用率が -l (--limit) オプションによる制限を超えた場合、SIGSTOP シグナルを送ってプロセスを一時停止、その後 SIGCONT シグナルで処理を再開、ということを行って CPU の使用率が上がらないように制御しているようです。"},{url:"/p/vfsc5ra/",title:"faceswap/ffmpeg で動画の顔を好きな顔に置き換える",date:"2018-04-28T00:00:00+09:00",body:"faceswap/ffmpeg で動画の顔を好きな顔に置き換える 概要 faceswap というツールを使用すると、機械学習の技術を使用して2人の画像の顔を入れ替えることができます。 このツール自体は静止画を対象としているので、動画の顔を入れ替えることはできないのですが、 ffmpeg を使って動画から静止画を生成 faceswap を使って静止画の顔を入れ替える ffmpeg を使って静止画を結合して動画を生成 というステップを踏むことによって、結果的に動画内の顔を入れ替えるということができます。 faceswap 環境のインストール faceswap のダウンロード まずは、下記サイトの Clone or download ボタンを押して、zip ファイルをダウンロードします（約100MB）。 https://github.com/deepfakes/faceswap faceswap は Python 製のツールであり、tensorflow などパッケージをインストールする必要があります。 Dockerfile が用意されていますので、Docker の実行環境 がインストールされているのであれば、比較的簡単に faceswap の実行環境を整えることができます。 Python 製のツールなので、Virtualenv を使って仮想環境を整えることもできます。 以下、Docker による環境構築方法と、Virtualenv による環境構築方法をそれぞれ示します（本家の INSTALL ドキュメントはこちらの情報が元になっています）。 Docker コンテナで faceswap 環境を作る場合 Docker がインストールされていない (docker コマンドが使えない) 場合は、まずは Docker をインストールします。 Install Docker 例えば Mac であれば、下記から docker.dmg をダウンロードして簡単にインストールできます。 Docker Community Edition for Mac Docker 環境のインストールができたら、faceswap に付属している Dockerfile を使用して、Docker コンテナをビルドします（10分程度かかります）。 ここでは、CPU 版のコンテナを作成します。 $ cd faceswap $ docker build -t deepfakes -f Dockerfile.cpu . コンテナの作成が終わったら、シェルを起動します。 $ docker run --rm --name deepfakes -v $(pwd):/srv -it deepfakes bash faceswap.py が実行できるようになっていれば成功です。 root@xxxxx:/srv# ./faceswap.py -h Virtualenv を使って faceswap 環境を作る場合 ここでは、Virtualenv による faceswap 実行環境を構築してみます。 MacBook Pro (A1398) で確認しています。 必ずしも Virtualenv を使用する必要はないのですが、Virtualenv を使って実行環境を構築すると、faceswap のためにインストールした Python パッケージ群をその実行環境内に閉じて管理することができます（ディレクトリ削除すれば綺麗な環境に戻る）。 Virtualenv の使い方に関しては、下記に詳しく記述されていますので、使用したことのない方は読んでみてください。 faceswap に限らず、Python 製のツールを使用するときに活用できると思います。 Python の実行環境を切り替えて使用する (virtualenv) 1) Python3 のインストール faceswap は Python スクリプトで作成されているので、Python 3 の処理系をインストールしておく必要があります。 例えば、Mac では Homebrew を使用して下記のようにインストールできます。 $ brew install python3 2) Virtualenv で仮想環境を作成 Virtualenv で、faceswap 用の Python 実行環境を作成します。 ここでは、ベタに ENV という名前で作成しましょう。 間違いなく Python 3 の処理系が使われるように、--python オプションを指定しています。 指定しなくても大丈夫かもしれません。 $ cd faceswap $ virtualenv --python=python3 ENV 3) 仮想環境のセットアップ Virtualenv で作成した仮想環境内に入り、その中で必要なツール群をインストールしていきます。 NVIDIA の GPU が搭載されていれば、GPU 版の環境を使用することができます。 その場合は、CUDA（GPU 機能を使用するプラットフォーム）、cuDNN（CUDA 用の Deep Learning ライブラリ）をインストールしておく必要があります。 CUDA Download cuDNN Download faceswap には、pip 用の requirements ファイルが用意されているので、これを使って必要な Python パッケージをまとめてインストールできます。 CPU 用、GPU 用という具合に別れていますので、環境に応じて使い分けてください。 $ source ENV/bin/activate (ENV)$ pip install -r requirements-python36.txt （GPUを使えない場合） (ENV)$ pip install -r requirements-gpu-python36-cuda9.txt （GPUを使える場合） Mac の場合、下記のような感じで tensorflow パッケージのインストールに失敗することがあります。 Could not find a version that satisfies the requirement tensorflow-gpu==1.5.0 このような場合は、TensorFlow 公式サイトの指示にしたがって、明示的に URL 指定します（参考: Installing TensorFlow on macOS）。 $ sudo pip3 install --upgrade \\ https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-1.7.0-py3-none-any.whl pip によるパッケージインストール時に、cmake が入ってなくて、 No such file or directory: &#39;cmake&#39; というビルドできない感じのエラーが出たら、 $ brew install cmake などで cmake をインストールしてから再チャレンジしてみてください。 faceswap で静止画の画像を入れ替える faceswap を使用すると、2人の画像の顔を置換することができます（本家の USAGE ドキュメントはこちら）。 写真から顔を抽出する (Extract) ここでは、人物1の写真と人物2の写真をそれぞれ用意し、人物1の写真の中の顔を人物2の顔に入れ替えることを考えます。 作業用の data ディレクトリを作成し、次のような構成で2人の写真を置いてください（少なくとも 64 ファイル以上ないと、スクリプト内で assert が発生するみたいです）。 +-- faceswap/ +-- data/ +-- photos-person1/ （人物1の写真 - この顔を） +-- photos-person2/ （人物2の写真 - この顔に入れ替える） 次のように実行すると、data/photos-person1 の中の写真から顔だけを抽出した画像ファイルが、data/faces-person1 に保存されます。 $ ./faceswap.py extract -i data/photos-person1 -o data/faces-person1 同様にして、人物2の写真 (data/photos-person2) からも顔画像を抽出すれば完了です。 抽出した顔画像のサイズは、256x256 で統一されています。 機械学習で顔1から顔2への変換モデルを作成する (Train) 2人分の顔画像が準備できたら、顔1 (data/faces-person1) を顔2 (data/faces-person2) に置き換えるためのモデルデータを作成します。 次のように実行すると学習が始まり、data/models-person1-person2 以下にモデルデータが作成されます。 $ ./faceswap.py train -A data/faces-person1 -B data/faces-person2 -m data/models-person1-person2 この学習処理はものすごく時間がかかりますが、特に CPU で処理している場合は忍耐強く待つ必要があります。 顔画像のファイル数が少なすぎると、以下のようなアサーションエラーが発生します。 AssertionError: Number of images is lower than batch-size (Note that too few images may lead to bad training). # images: 13, batch-size: 64 メッセージの通り、デフォルトではバッチサイズが 64 となっており、顔画像が 64 ファイル以上ないと怒られます。 バッチサイズは、下記のように -bs (--batch-size) オプションで2のべき乗の値 (64,128,256) を指定できます。 $ ./faceswap.py train -A data/faces-person1 -B data/faces-person2 -m data/models-person1-person2 -bs ＜2のべき乗＞ 顔を入れ替える 作成したモデルデータ (data/models-person1-person2) を使って、人物1の写真 (data/photos-person1) の顔を入れ替えるには、下記のように実行します。 $ ./faceswap.py convert -i data/photos-person1 -o data/photos-result -m data/models-person1-person2 data/photos-result ディレクトリに、結果の写真が格納されます。 ffmpeg で動画ファイルの顔を入れ替える ffmpeg を使うと、動画ファイルを静止画ファイルに分割したり、逆に、静止画ファイルから動画ファイルを作成したりすることができます。 faceswap では、直接動画ファイル内の顔を置換することはできないので、まずは ffmpeg を使って、動画を静止画に変換しておく必要があります。 ffmpeg のインストール ffmpeg は下記サイトからダウンロードすることができます。 https://www.ffmpeg.org/ それぞれのプラットフォーム用のパッケージをダウンロードして、ffmpeg ファイルを、パスの通ったディレクトリに置けば OK です。 動画を静止画ファイルに変換 ffmpeg を使って動画ファイルから静止画ファイルを生成するには以下のようにします。 例: video.mp4 から静止画ファイルを生成する $ mkdir data/photos-someone # 出力先ディレクトリを作成しておく $ ffmpeg -i data/video.mp4 -vf fps=25 data/photos-someone/%06d.png 上記では fps=25（1 秒あたり 25 枚の静止画）で切り出していますが、学習用のファイルとしては、あまり似たような画像があってもしょうがないので、fps=1 などに調整して作成するとよいでしょう。 ただし、最終的に顔の置換対象とする画像ファイル群は、ある程度のフレーム数で切り出しておいて、動画ファイルの形に結合する必要があります。 学習用の静止画: 1fps 置換対象の静止画: 25fps という感じで作り分けるとよいかもしれません。 静止画ファイルから動画ファイルに変換 静止画ファイルができたら、faceswap を使用して顔の入れ替えなどの画像処理を行います。 画像処理が終わったら、下記のようにして動画ファイルの形に結合することができます。 例: data/photos-result ディレクトリ内の静止画から動画ファイルを生成する $ ffmpeg -r 25 -i data/photos-result/%06d.png -vcodec libx264 -pix_fmt yuv420p -r 60 result.mp4 最初の -r 25 は入力画像のフレームレート（何枚で1分になるか）を表しており、次の -r 60 は出力される動画のフレームレートを表しています。"},{url:"/p/yqjs3aw/",title:"Python の実行環境を virtualenv で切り替える（Python 3.2 以前）",date:"2018-04-28T00:00:00+09:00",body:"Python の実行環境を virtualenv で切り替える（Python 3.2 以前） virtualenv コマンドを使用すると、仮想的な Python の実行環境を作成することができます。 （追記）Python 3.3 以降は、virtualenv と同様の機能を提供する venv モジュールが標準搭載されたので、そちらを使うようにしましょう。 Python の実行環境を切り替えて使用する (venv) virtualenv とは Virtualenv Python 製のツールを使おうとすると、使用可能な Python のバージョンが制限されていたり、依存する Python パッケージを pip コマンドでたくさんインストールしなければいけなかったりします。 こういったツールを実行するために、パッケージをどんどんインストールしていくと、PC 内の Python 環境がぐちゃぐちゃになってしまいます（システムの site-packages ディレクトリに大量のパッケージがインストールされて管理できなくなる）。 そこで便利なのが、独立した Python 環境を作成することができる virtualenv コマンドです。 virtualenv で作成した仮想環境の中では、特定のバージョンの Python を使用することができ、閉じた環境内に Python パッケージをインストール (pip install) することができます。 もし、その環境が必要なくなったら、仮想環境ごと削除してしまえば、PC 内のグローバルな Python 実行環境はクリーンなままです。 例えば、何らかの Python 製ツール app があったとして、そのツールを使用するにはいくつかの Python パッケージをインストールしなければならないとします。 virtualenv を使用して、その Python 製ツールを使用するための環境を作る流れは以下のようになります。 app ディレクトリに移動する (cd app) app 用の Python 仮想環境を作成する (virtualenv 環境名) 仮想環境に入る (source 環境名/bin/activate) app に必要な Python パッケージをインストールする (pip install XXX) app を使う (python app.py) 仮想環境を抜ける (deactivate) virtualenv コマンドのインストール virtualenv コマンドは、pip コマンドで簡単にインストールすることができます。 $ pip install virtualenv （うまくいかない場合は sudo をつけてみる） virtualenv コマンドが実行できるようになればインストール成功です。 $ virtualenv --version 15.2.0 virtualenv で Python 仮想環境を作成／使用／削除する 仮想環境を作成する virtualenv コマンドで新しい Python 仮想環境を作成するには、下記のように実行します。 ENV というのは任意の環境名で、ここで指定した名前のディレクトリがカレントディレクトリに作成されます。 $ virtualenv ENV 仮想環境に入る (activate) この環境を使用するには、ENV ディレクトリの中に作成された bin/activate スクリプトを読み込みます（Windows の場合はバッチファイルになっています）。 仮想環境に入ると、プロンプトに (環境名) と表示されるようになります。 $ source ENV/bin/activate （source の代わりに . でもOK） (ENV)$ 仮想環境に入った状態で python コマンドを実行すると、その仮想環境内に配置された ENV/bin/python が参照されます（この処理系の切り替え方法は後述）。 (ENV)$ which python /Users/maku/ENV/bin/python また、pip コマンドでインストールする Python パッケージも、仮想環境内の ENV/lib/python3.6/site-packages に格納されるようになるので、たくさんパッケージをインストールしても、仮想環境の外の Python 実行環境を汚染することがありません。 仮想環境を抜ける (deactivate) 仮想環境を抜けて元の世界に戻るには、deactivate コマンドを実行します。 このコマンドは、ENV/bin/deactivate として配置されているのですが、仮想環境に入るときに ENV/bin にパスが通されるので、どこからでも実行することができます。 (ENV)$ deactivate $ 仮想環境を削除する 仮想環境自体が不要になったら、ディレクトリごと削除してしまえば OK です。 $ rm -r ENV virtualenv の高度な使い方 仮想環境で使用する Python のバージョンを指定する 仮想環境で使用する Python (ENV/bin/python) のバージョンは、デフォルトでは virtualenv のインストールに使用した Python 処理系と同じバージョンになります（要するに pip コマンドが使用する python のバージョンということ）。 仮想環境内から使用する Python 処理系のバージョンを指定したい場合は、仮想環境の作成時に、--python オプションで指定します（ENV/bin/python として配置する処理系を指定する）。 $ virtualenv --python=python ENV $ virtualenv --python=python2.7 ENV $ virtualenv --python=python3 ENV $ virtualenv --python=/opt/python-2.7/bin/python ENV この例からも分かるように、指定できる Python 処理系は、あらかじめインストールされているものだけだということに注意してください。 Python 2.7 しかインストールされていない環境で、Python 3 を使用する仮想環境を作成したいときは、先に Python 3 をインストールしておく必要があります。 仮想環境からグローバルな site-packages を参照できるようにする システムにインストールされている Python パッケージ群を、仮想環境からも参照できるようにするには、仮想環境を作成するときに --system-site-packages オプションを指定します。 $ virtualenv --system-site-packages ENV ☝️ ワンポイント 過去のバージョンの virtualenv では、デフォルトで仮想環境からグローバルな site-packages を参照できるようになっており、これを抑制するためには --no-site-packages オプションが必要でした。 現在は、デフォルトでグローバルな site-package は参照できないようになっており、--no-site-packages オプションも deprecated（廃止予定）扱いとなっています。 仮想環境内に Linux コマンドなどをインストールする virtualenv の仮想環境に入ると、ENV/bin ディレクトリに自動的にパスが通されるようになっています。 $ . ENV/bin/activate (ENV)$ echo $PATH /Users/maku/ENV/bin:... つまり、この ENV/bin ディレクトリ内に何らかのコマンドラインツールを配置すれば、仮想環境内でのみ使用可能なコマンドとして扱うことができます。 仮想環境が必要なくなった場合は、ENV ディレクトリごと削除してしまえばよいので、外部の環境に影響を与えずに済みます。"},{url:"/memo/",title:"設計ノート",date:"2018-04-28T00:00:00+09:00",body:"設計ノート 設計ノウハウ／ベストプラクティス 不具合修正に対する向き合い方 ソフトウェアの静的品質と動的品質 プログラム内のコメントの書き方 (Javadoc ドキュメンテーションコメントの書き方） アプリ内の名前空間（Java のパッケージ階層）に迷った時のヒント ゴッドクラス (God Class) とは スケジューリングや見積りの段階では要求と設計要素のマトリクスで考える 可変オブジェクトのメンバ参照を返さない プロジェクト内での null の扱い方をルール化する 時制や単数形・複数形を考慮して命名する 肯定形で表現する 単位を明確にする 設定値の伝搬タイミングを意識する 型変換用メソッドは受け取り側クラスに作る 静的チェックのレベルはプロジェクト初期に厳しくする リソースは finally ブロックで閉じる コメント内で使える特殊キーワード（XXX、TODO など）を理解する よいツールの条件 無駄な汎用性ではなくシンプルな設計を (YAGNI) テスト テストピラミッドを意識してテストの自動化を進める 単体テスト、結合テスト、システムテスト、受入テストの関係を理解する Jenkins Jenkins CLI を使ってコマンドラインから Jenkins を操作する Groovy スクリプトで Jenkins サーバを制御する Groovy スクリプトで Jenkins 上のすべての Job を制御する Groovy スクリプトで Jenkins 上のすべてのスレーブを制御する Jenkins ジョブの設定 (config.xml) を確認する お試しインスタンスとして Jenkins サーバを起動する (jenkins.war) Jenkins サーバの設定ファイルの場所 Amazon EC2 に Jenkins をインストールする ツール make を使いこなすためのメモ CPD でコードクローンを発見する TFTP の使い方（TFTP によるファイル転送） Windows (MinGW) で GLUT を使用する Tera Term のマクロで特定の文字列を検出して処理を実行する faceswap/ffmpeg で動画の顔を好きな顔に置き換える ドキュメント用ツール Enterprise Architect の図をシンプルにして Power Point に貼り付ける テキストからシーケンス図を作成するツール (sdedit) ネットワーク／暗号／セキュリティ IP によるインターネットワーキングの基礎（昔々2000年くらいに書いた記事） GENA と SSDP プロトコルを理解する 共通鍵暗号化方式と公開鍵暗号化方式 ダイナミック・ルーティング・プロトコルのメモ (RIP, OSPF, BGP-4) ルーティングテーブルの管理 NAT の種類のメモ（SNAT、DNAT、NAPT、IP マスカレード） VMware のネットワーク設定 雑多メモ PIC めもめも（電子工作、PIC アセンブラのメモ） XML の名前空間について 意外と知られていない XML 記述のルール GoFのデザインパターン: Visitor パターン ぐちゃぐちゃなコードしかないチーム／プロジェクトに配属された場合のポジティブ思考 パッケージ管理ツールいろいろ"},{url:"/p/sw5kgj2/",title:"HTML のリスト要素 (ul, ol, li) のマージン指定方法を理解する",date:"2018-04-23T00:00:00+09:00",body:"HTML のリスト要素 (ul, ol, li) のマージン指定方法を理解する HTML でリストを表示するには ul や ol 要素を使いますが、これらのマージン、インデント設定は若干わかりにくいので、ここではいろいろなパターンの表示例を確認しながら理解を深めます。 ul 要素と li 要素の padding-left 図: ul 要素と li 要素の padding プロパティの意味 この図は、ul 要素（あるいは ol 要素）の padding-left の値と、li 要素の padding-left の値がどの領域のサイズとして反映されるかを示しています。 特に気をつけなければいけないのは、ul 要素の padding-left 値は、li 要素の描画領域の左端までのサイズになるというところです。 言い換えると、リストマーカー（・など）の右端までのサイズです。 つまり、ul 要素の padding-left の値は、リストマーカーまで含んだサイズ であることを意識して設定する必要があります。 Chrome では ul 要素の padding-left の規定値は 40px になっているようです。 一方で、li 要素の padding-left の値は、リストマーカーの右端から、テキストの左端までのサイズ を表します。 こちらの値は 0 になっていても、特におかしな表示にはなりません。 ul のインデント設定は padding-left で行うのが基本 下記は、ul 要素の padding-left プロパティだけを設定した場合の表示デモです（その他の margin 設定や padding 設定は 0 です）。 入れ子になった ul 要素も、それっぽくインデントされていることがわかります。 これが、ul 要素や ol 要素に対してインデントサイズを指定するときの基本的な方法です。 表示デモ 1 （別ページで開く） 表示デモの中の外側の矩形は、ul 要素を配置する親要素の描画領域を示しています。 ul 要素の描画領域はピンク背景、li 要素の描画領域は下線を引くことで、それぞれの要素の位置関係が分かるようにしています。 ここでは ul { padding-left: 3em; } と指定していますが、このサイズは、上記の表示では、ピンク領域の左端 ～ テキストの下線が始まるところまでのサイズとして反映されています。 ☝️ ワンポイント サイズの単位として em を使うようにすれば、ul 要素内のフォントサイズを基準にして指定することができます。 表示デモ 2 （別ページで開く） ul 要素の padding-left を 0 にしてしまうと、上記のように入れ子要素のインデントがなくなり、さらに、リストマーカーを表示する余裕もないので、親要素をはみ出してリストマーカーが表示されてしまいます。 ul 要素の padding-left には、余裕を持ったサイズを指定しなければいけないということです。 表示デモ 3 （別ページで開く） 上記は、padding-left の代わりに margin-left を設定した場合の表示デモですが、この方法でもうまくインデントされているかのように見えます。 ただし、margin プロパティの値は、他の要素と並べて配置した時に、それらの margin と相殺される性質を持っています。 思わぬ表示位置のずれを防ぐためにも、ul/ol 要素のインデントサイズ指定には padding-left だけを使う ことをおススメします。 ちなみに padding-left と margin-left を両方設定すると、次のようにインデント幅がものすごく大きくなったように見えます。 表示デモ 4 （別ページで開く） li の padding-left は 0 で OK li 要素の padding-left プロパティでは、リストマーカーの右端からテキストの先頭までの距離を設定します。 次の例では、各 li 要素の padding-left の値を少しずつ増やしながら表示しています。 表示デモ 5 （別ページで開く） 入れ子になった ul 要素は li 要素の子要素として配置されるため、li 要素の padding-left を大きくすると、その下の ul 要素自体のインデント幅が大きくなったかのように見えます。 表示デモ 6 （別ページで開く） ☝️ ワンポイント 間違えがちですが、ul 要素の直下に ul を配置することはできません。 ul 要素の直下には、必ず li 要素を配置する必要があります。 入れ子になった（2 階層目以降の）ul のインデントだけ小さくする 1 階層目の ul のインデントだけ小さくしたい場合や、2 階層目以降の ul のインデントだけ小さくしたい場合は、例えば以下のように設定すればよいでしょう。 ul, ol { padding-left: 3em; } li &gt; ul, li &gt; ol { /* 2 階層目以降はインデントを小さく */ padding-left: 1em; } ul 要素の親要素が li であることを示すセレクタ (li &gt; ul) を使用することで、2 階層目以降の ul 要素に対するスタイル設定を行うことができます。 表示デモ 7 （別ページで開く） 画面幅が狭い時にインデントを小さくする（レスポンシブ対応） リストのインデントを大きくしすぎると、ブラウザの画面サイズが小さいとき（スマホで表示した場合など）に、表示できる文字数が少なくなってしまいます。 このような問題を避けるためには、メディアクエリを使用して、画面サイズに応じてインデントサイズを変更するようにします。 CSS の例 ul, ol { padding-left: 2em; } li &gt; ul, li &gt; ol { padding-left: 1em; } /* スクリーンサイズが大きいときはインデントを大きくする */ @media (min-width: 35rem) { ul, ol { padding-left: 3em; } li &gt; ul, li &gt; ol { padding-left: 2em; } } 次の例では、ブラウザの画面サイズが小さいときに、リストのインデント幅も小さくなるように設定しています（フレームの右下をドラッグしたり、Ctrl-+ でフォントサイズを変更したりすると、インデントサイズが変化することを確認できます）。 表示デモ 8 （別ページで開く） まとめ ul/ol 要素を入れ子にしたときのインデントサイズは ul/ol 要素の padding-left で設定する。 2 階層目以降の ul/ol 要素のインデントサイズだけ変更したい場合は li &gt; ul というセレクタを使用する。 margin-left は使用しない。 padding-left の値のサイズとしては em を使用するのがおすすめ。"},{url:"/p/sc9t737/",title:"Hugo で次のページ、前のページへのリンクを表示する",date:"2018-04-22T00:00:00+09:00",body:"Hugo で次のページ、前のページへのリンクを表示する ページ変数の .NextInSection や .PrevInSection を使用すると、同じセクション内の次のページ、前のページを参照することができます。 同じ階層にある「前のページ」「次のページ」へのリンクを表示する 下記のテンプレートコードは、前のページへのリンクと、次のページへのリンクを表示するシンプルな例です。 テンプレートコード（抜粋） {{ with .PrevInSection }} &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt; {{ end }} {{ with .NextInSection }} &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt; {{ end }} Page 変数の .PrevInSection や .NextInSection には、同じセクション内にある通常ページ (regular page) の内、前のエントリと次のエントリにあたるページ が格納されています。 これらの変数は、通常ページ (regular page) でしか有効でないことに注意してください（つまり、シングルページレイアウトで使用します）。 セクションページなどで参照すると、nil が返されます。 ☝️ .Title ではなく .LinkTitle を出力する リンクのタイトルをなるべく短く表示するため、.Title ではなく .LinkTitle を参照していることに注意してください。 こうしておくと、ページのフロントマターで linkTitle プロパティが設定されている場合に、title プロパティよりも優先的に参照されるようになります。 体裁を整えるのであれば、前のページへのリンクは左寄せ、次のページへのリンクは右寄せで表示するとよいでしょう。 表示イメージとしては次のような感じです。 ≪前のページへ 次のページへ≫ さらに、コードは prev-next パーシャルテンプレートとして、使い回しがきくようにしておきましょう。 下記は完成版のパーシャルテンプレートです。 layouts/partials/prev-next.html &lt;div class=&#34;xPrevNextLink&#34;&gt; {{ with .PrevInSection }} &lt;div class=&#34;xPrevNextLink_prev&#34;&gt; &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt; &lt;/div&gt; {{ end }} {{ with .NextInSection }} &lt;div class=&#34;xPrevNextLink_next&#34;&gt; &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt; &lt;/div&gt; {{ end }} &lt;/div&gt; 左寄せ、右寄せ用のスタイルも定義しておきます。 リンクタイトルの前後に表示される ≪ 記号や ≫ 記号も、CSS で表示するように設定します。 static/assets/css/main.css（例） /* 前ページ、次ページへのリンク */ .xPrevNextLink { display: flex; justify-content: space-between; } .xPrevNextLink_prev::before { content: &#34;≪&#34;; } .xPrevNextLink_next::after { content: &#34;≫&#34;; } prev-next パーシャルテンプレートを使用するには、任意のテンプレートファイル内で次のように呼び出します。 layouts/_default/single.html（抜粋） &lt;body&gt; &lt;main&gt; ... {{ partial &#34;prev-next&#34; . }} ... &lt;/main&gt; &lt;/body&gt; セクションページも含めて「前のページ」「次のページ」へのリンクを表示する 上記の .PrevInSection や .NextInSection は、通常ページ (regular page) のみを対象 として、「前のページ」や「次のページ」へのリンクを実現するための機能でした。 例えば、content ディレクトリ内に次のような構成で記事を作成したとすると、 section-0/_index.md section-1/_index.md section-2/_index.md section-3/_index.md page-1.md page-2.md page-3.md page-1、page-2、page-3 の 3 つの通常ページを前後に移動するためのリンクとして働きます。 セクションページは対象にならないため、page-1 から section-3 へのリンク（およびその逆のリンク）は張られません。 section-1、section-2、section-3 などのセクションページも含めて、前後に移動できるようにするには、.PrevInSection や .NextInSection を使用せず、自力で前後のページへの参照を求める必要があります。 下記のサンプルコードは、セクションページを含めた「前のページ」「次のページ」へのリンクを出力する例です。 layouts/partials/prev-next-siblings.html {{ if .Parent }} {{- /* まずは同じ階層のセクションとページから prev と next を決める */}} {{- range .Parent.Pages }} {{ if eq . $ }} {{ $.Scratch.Set &#34;found&#34; true }} {{ else }} {{ if $.Scratch.Get &#34;found&#34; }} {{ if not ($.Scratch.Get &#34;next&#34;) }} {{/* Set &#34;next&#34; entry as just after the current page. */}} {{ $.Scratch.Set &#34;next&#34; . }} {{ end }} {{ else }} {{/* Update &#34;prev&#34; entry until the current page is found. */}} {{ $.Scratch.Set &#34;prev&#34; . }} {{ end }} {{ end }} {{ end }} {{/* 見つかった prev と next のリンクを表示 */}} &lt;div class=&#34;xPrevNextLink&#34;&gt; {{- with ($.Scratch.Get &#34;prev&#34;) -}} &lt;div class=&#34;xPrevNextLink_prev&#34;&gt; &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; &lt;/div&gt; {{- end -}} {{- with ($.Scratch.Get &#34;next&#34;) -}} &lt;div class=&#34;xPrevNextLink_next&#34;&gt; &lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; &lt;/div&gt; {{- end -}} &lt;/div&gt; {{ end }} ちょっと長いですが、大まかには次のようなことを行っています。 同一階層にある通常ページおよびセクションページをループ処理（前から順番に見ていく） カレントページにたどり着いた時点で、その前後のページが判明する（&quot;prev&quot; と &quot;next&quot;） &quot;prev&quot; と &quot;next&quot; のページへのリンクを出力 ☝️ ワンポイント 現時点の Hugo バージョン v0.47.1 は、range ループの break をサポートしていなかったため、前後のページを発見した後も最後までループ処理が継続してしまいます。 Hugo（が使用している Go テンプレート）が break に対応すれば、もう少し効率的な処理が可能になります。 とはいえ、そのままでも十分速いですが。 上記の prev-next-siblings パーシャルテンプレートは、通常ページ (regular page) 専用の Page 変数である .PrevInSection や .NextInSection を使用せずに実装されているため、下記のようにセクションテンプレートなどからも使用することができます。 このセクションテンプレートは、ベーステンプレートと組み合わせて使用する ことを想定しています。 layouts/_default/section.html（使用例） {{ define &#34;article&#34; }} &lt;article class=&#34;xArticle&#34;&gt; {{ partial &#34;prev-next-siblings&#34; . }} {{ .Render &#34;inc-article&#34; }} &lt;/article&gt; {{ end }} Hugo がネイティブでこのようなリンク出力用の Page 変数を用意してくれれば楽なんですけどね(^^;"},{url:"/p/5ru4kte/",title:"Hugo で全ページから参照できるデータを用意する（data ディレクトリ）",date:"2018-04-08T00:00:00+09:00",body:"Hugo で全ページから参照できるデータを用意する（data ディレクトリ） Hugo プロジェクトの data ディレクトリに YAML、JSON、TOML、CSV などの形式でデータファイルを作成しておくと、すべてのページから自由に参照できるようになります。 データファイルを作成する data ディレクトリに置くデータファイルは、下記のいずれかのフォーマットで作成します。 YAML フォーマット JSON フォーマット TOML フォーマット CSV フォーマット ここでは英単語の辞書データを YAML 形式のファイル data/words.yaml として作成してみましょう（拡張子は .yaml でも .yml でも構いません）。 data ディレクトリは、サイトのルートディレクトリに作成します（content ディレクトリや layouts ディレクトリと同じ階層に data ディレクトリを置きます）。 data/words.yaml - en: apple jp: りんご - en: banana jp: バナナ - en: grape jp: ぶどう ☝️ ワンポイント Hugo 0.37 より前のバージョンには YAML 処理の不具合があり、上記のようにルートレベルに配列データを記述することができませんでした。 hugo version コマンドでバージョンを確認し、必要があれば 最新の Hugo に更新 しましょう。 あるいは、JSON ファイルとして作成するのであればこんな感じです。 data/words.json [ { &#34;en&#34; : &#34;apple&#34;, &#34;jp&#34; : &#34;りんご&#34; }, { &#34;en&#34; : &#34;banana&#34;, &#34;jp&#34; : &#34;バナナ&#34; }, { &#34;en&#34; : &#34;grape&#34;, &#34;jp&#34; : &#34;ぶどう&#34; } ] できれば、よりシンプルに記述できる YAML 形式を使いたいですね。 データファイルを参照する data ディレクトリ以下に作成したデータファイルを参照するには、テンプレートファイルの中で .Site.Data.ファイル名（拡張子は除く）のように参照します。 ここでは、words セクションのインデックスページ (content/words/_index.md) にのみ適用されるセクションテンプレートを作成することにしましょう。 layouts/words/list.html（抜粋） &lt;ul&gt; {{- range .Site.Data.words }} &lt;li&gt;{{ .en }} は {{ .jp }} です。&lt;/li&gt; {{- end }} &lt;/ul&gt; 次に、words セクションのコンテンツファイルを作成します。 セクションの生成が目的ですから、本文は空っぽで構いません。 content/words/_index.md --- title: &#34;単語集&#34; --- （本文は空っぽでOK） これで、http://&lt;サイト&gt;/words/ にアクセスすると、次のような HTML コンテンツが表示されるはずです。 &lt;ul&gt; &lt;li&gt;apple は りんご です。&lt;/li&gt; &lt;li&gt;banana は バナナ です。&lt;/li&gt; &lt;li&gt;grape は ぶどう です。&lt;/li&gt; &lt;/ul&gt; 複数のデータファイルをループ処理する data ディレクトリ以下のディレクトリ内に、複数のデータファイルを同じフォーマットで作成しておくと、テンプレート内でループ処理することができます。 次の例では、data/books ディレクトリ内に、書籍情報を表す YAML ファイルを配置しています。 1 つの YAML ファイルに、1 つの書籍の情報を記述します。 ディレクトリ内のファイルをすべてループ処理するので、YAML ファイルの名前は何でも構いません。 data/books/title1.yaml title: ライザップ式 2 週間ダイエットレシピ author: RIZAP 株式会社 isbn13: 978-4537215489 data/books/title2.yaml title: 大人女子の体にライザップ author: RIZAP 株式会社 isbn13: 978-4537215618 本当はこれくらいの情報量であれば、1 ファイルに記述してしまった方がよいのですが、ここでは説明のために分けていると考えてください。 これらのデータファイルを参照するテンプレートは、例えば以下のように記述します。 ここでは、1 データごとの出力内容を、パーシャルテンプレートに分けてみましょう。 layouts/_default/list.html（抜粋） {{- range .Site.Data.books }} {{ partial &#34;book&#34; . }} {{- end }} layouts/partials/book.html &lt;div class=&#34;book&#34;&gt; &lt;div class=&#34;book_title&#34;&gt;{{ .title }}&lt;/div&gt; &lt;div&gt;著者: {{ .author }}&lt;/div&gt; &lt;div&gt;ISBN-13: {{ .isbn13 }}&lt;/div&gt; &lt;/div&gt; レンダリング結果は次のような感じになります。 &lt;div class=&#34;book&#34;&gt; &lt;div class=&#34;book_title&#34;&gt;ライザップ式 2 週間ダイエットレシピ&lt;/div&gt; &lt;div&gt;著者: RIZAP 株式会社&lt;/div&gt; &lt;div&gt;ISBN-13: 978-4537215489&lt;/div&gt; &lt;/div&gt; &lt;div class=&#34;book&#34;&gt; &lt;div class=&#34;book_title&#34;&gt;大人女子の体にライザップ&lt;/div&gt; &lt;div&gt;著者: RIZAP 株式会社&lt;/div&gt; &lt;div&gt;ISBN-13: 978-4537215618&lt;/div&gt; &lt;/div&gt;"},{url:"/p/jbr6kzd/",title:"Hugo のローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する",date:"2018-04-02T00:00:00+09:00",body:"Hugo のローカルサーバーで動作させているとき（開発時）のみ内容を出力する private ショートコードを作成する 自分の作業用備忘録としてはメモとして残したいけれど、インターネット上には公開したくない内容に関しては、Hugo をローカルサーバーとして動作させているときだけ出力するようなショートコードを作成しておくと便利です。 private ショートコードを作成する そのショートコードが、Hugo のローカルサーバ上 (hugo server) で使用されたかを判別するには、hugo.IsServer を参照します。 layouts/shortcodes/private.html {{ if hugo.IsServer }} ローカルサーバで動作しています。 {{ end }} あとは、.Inner 変数で、渡されたテキストを参照することができるので、たとえば次のように実装すればよいでしょう。 layouts/shortcodes/private.html {{ if hugo.IsServer }} &lt;div class=&#34;private&#34;&gt;{{ .Inner }}&lt;/div&gt; {{ end }} ここでは、出力する div 要素に private というクラスを割り当てています。 下記は private クラスに適用するスタイルシートの例です（赤系の色で強調表示するようにしています）。 .private { background: #fee; color: #f11; padding: 0.5em; border: solid 1px #f11; } .private::before { content: &#34;Private メモ&#34;; display: block; font-weight: bolder; } 使用方法 作成した private ショートコードは、記事ファイルの中で次のように利用します。 content/sample.md --- title: &#34;サンプルタイトル&#34; --- {{&lt; private &gt;}} これは非公開なメモだよ。 {{&lt; /private &gt;}} 次のように、内部のテキストで Markdown 構文を使用することもできます（その場合は、ショートコード名を % 記号で囲むことに注意してください）。 {{% private %}} これは非公開なメモだよ。 - Markdown の構文も使えるよ - Markdown の構文も使えるよ - Markdown の構文も使えるよ {{% /private %}} （おまけ）IsServer が使えなかった頃はどうやっていたか？ hugo.IsServer は Hugo v.0.120.0 で追加されました。 また、それ以前は、Site 変数の .Site.IsServer を使っていました。 .Site.IsServer 変数は Hugo v.0.38 で追加されました。 v.0.37 以前のバージョンでは、ローカルサーバーで Web ページをホスティングしているかどうかを、.Site.BaseURL の値が http://localhost で始まっているかどうかで判断していました。 layouts/shortcodes/private.html {{ if hasPrefix .Site.BaseURL &#34;http://localhost&#34; }} ローカルサーバーで動作しています。 {{ end }}"},{url:"/p/hoffk3g/",title:"HTML の audio 要素で音声ファイルを再生する",date:"2018-02-14T00:00:00+09:00",body:"HTML の audio 要素で音声ファイルを再生する HTML の audio 要素を使用すると、Web ページ内に音声コンテンツを埋め込むことができます。 audio 要素の使用例 次の例では、音声ファイル (coin.mp3) を再生するためのコントールパネルを表示しています。 音声ファイルをダウンロード HTML 記述例 &lt;audio src=&#34;coin.mp3&#34; controls&gt; &lt;p&gt;&lt;a src=&#34;coin.mp3&#34;&gt;音声ファイルをダウンロード&lt;/a&gt;&lt;/p&gt; &lt;/audio&gt; &lt;audio&gt; 〜 &lt;/audio&gt; のブロック内には、audio 要素がサポートされていない環境で表示されるメッセージを記述することができます。 ここでは、コントロールパネルを表示できないときに、音声ファイルをダウンロードするリンクを表示するようにしています。 audio 要素の属性 audio 要素には、次のような属性が用意されています。 （論理属性）(boolean attributes) と書かれているものは、値を指定せずに単純にその属性名だけを記述すれば有効になる属性です。 src 再生する音声ファイルの URL を指定します。 source 要素を使って音声ファイルを指定する場合は、audio 要素の src 属性は指定できません。 controls （論理属性） 音声ファイルを再生するためのコントロールパネルを表示します。 autoplay （論理属性） ページが読み込まれたときに、自動的に音声ファイルを再生します。 loop （論理属性） ループ再生します。 muted （論理属性） デフォルトの音量を 0 に設定します。 preload 音声ファイルのプリロード方法を指定します。 none: 事前読み込みしない。 metadata: 音声のメタデータのみ事前読み込みする。 auto: 事前読み込みする。 指定しなかった場合の振る舞いは、ブラウザの実装に依存します。 preload の指定は、ブラウザにプリロードのヒントを与えるだけで、必ずしも指定した通りに振る舞うとは限りません。 例えば、autoplay 属性が指定されている場合は、音声ファイルをダウンロードしなければいけないことは明らかなので、preload=&quot;none&quot; という指定は意味を持ちません。 crossorigin 元文書とは異なるオリジンからデータを取得する際の認証方法を指定します。 anonymous または use-credentials を指定します。 source 要素で複数の音声ファイルを指定する audio 要素の src 属性の代わりに、次のように source 要素を使って、種類の異なる音声ファイルを指定することができます。 音声ファイルの MIME タイプを type 属性で指定します。 ブラウザがサポートしている MIME タイプのうち、最初に見つかった音声ファイルが再生されます。 &lt;audio controls autoplay&gt; &lt;source src=&#34;file/sample.mp3&#34; type=&#34;audio/mp3&#34;&gt; &lt;source src=&#34;file/sample.ogg&#34; type=&#34;audio/ogg&#34;&gt; &lt;source src=&#34;file/sample.wav&#34; type=&#34;audio/wav&#34;&gt; &lt;p&gt; ご利用のブラウザは&lt;a src=&#34;file/sample.mp3&#34;&gt;音声ファイル&lt;/a&gt;の再生に対応していません。 &lt;/p&gt; &lt;/audio&gt; 使用しているブラウザがどの MIME タイプもサポートしない場合は、最後の要素として指定したメッセージが表示されます。"},{url:"/p/7o7ymst/",title:"Hugo でサイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示）",date:"2018-01-23T00:00:00+09:00",body:"Hugo でサイドバー用のページツリーを表示する（現在表示しているページを考慮した階層表示） サイドバーメニューに、サイトの階層構造に応じたリンクを表示しておくと、サイト内の様々なページに簡単に移動できるようになります。 サイドバーでのページツリー表示のイメージ サイト全体のページ一覧をツリー構造で表示する方法は、下記のページで紹介しています。 サイト内の全ページの一覧をセクションの階層構造に従って表示する しかし、上記のページで説明している方法でツリー表示すると、すべてのページが展開された状態で表示されてしまうため、サイドバーに表示するツリーとしてはちょっと情報量が多すぎます。 ここでは、もう少しコンパクトに表示されるように、現在のページの上位ノードだけを展開したツリーを表示するようにしてみます。 イメージとしては次のような感じで、表示中のページ（ここでは page1）の上位のセクションだけを展開したツリーを表示することを考えます。 - sec1/ - sec2/ - sec2-1/ - sec2-2/ - page1 （表示中のページ） - page2 - sec2-2-1/ - sec2-2-2/ - sec2-3/ - sec3/ - sec4/ このようなツリーをサイドバーなどに表示しておくことで、ユーザが今、サイト全体でどの位置の記事を読んでいるかを簡単に把握できるようになります（パンくずリストなども同様の効果がありますが、ツリー表示の方が、より全体を把握しやすいといえます）。 展開すべきノードを知る 自分自身のページが所属するセクションだけを展開したツリーを表示するには、テンプレートコード内で、セクションの親子関係を（先祖まで含めて）把握する必要があります。 そのために、Page オブジェクトの以下のようなメソッドを利用することができます（参考: Hugo - Section Variables and Methods）。 Hugo 本家のマニュアルページでは、.InSection や .IsAncestor、.IsDescendant メソッドは、Section 変数 の Methods として記述されていますが、通常ページを含む Page オブジェクトのメソッドとして参照することができます。 $p1.InSection $p2 $p1 と $p2 が同一のセクションに所属していれば true（$p1 = $p2 の場合も true）。 それ以外は false。 (Whether the given page is in the current section.) $p1.IsAncestor $p2 $p1 が $p2 の先祖ページかどうかを調べる。 $p1 セクションが $p2 のカレントセクションよりも上位のセクションであれば true。 $p1 が通常ページの場合は常に false。 $p1 = $p2 の場合も false。 (Whether the current page is an ancestor of the given page.) $p1.IsDescendant $p2 $p1 が $p2 の子孫ページかどうかを調べる。$p2.IsAncestor $1 とするのと同じ。 (Whether the current page is a descendant of the given page.) ☝️ ワンポイント Hugo 0.100 で .IsDescendant と .IsAncestor の振る舞いが変更されました。 IsDescendant/IsAncestor returns true for self · Issue #9925 · gohugoio/hugo Notes release notes 0.100 · Issue #9934 · gohugoio/hugo なかなか分かりにくいですね。このような場合は実際にテストしてみるのが一番です。 これらのメソッドがどういう振る舞いをするのかを明確にするため、次のようなディレクトリ構成（セクション構成）のダミーサイトでテストしてみます。 /_index.md /page.md /sec1/_index.md /sec1/page.md /sec1/sec1-1/_index.md /sec1/sec1-1/page1.md /sec1/sec1-1/page2.md /sec1/sec1-1/sec1-1-1/_index.md /sec1/sec1-1/sec1-1-1/page.md /sec1/sec1-2/_index.md /sec1/sec1-2/page1.md /sec1/sec1-2/page2.md 次の表は、各ページの Page オブジェクト ($p1) の .InSection、.IsAncestor、.IsDescendant メソッドに、別ページの Page オブジェクト ($p2) を渡したときにどう判定されるかの一覧です（Hugo 0.110.0 で確認）。 → 別ウィンドウで開く $p1 がセクションの場合と通常ページの場合で振る舞いが変わったりするので若干ややこしいですが、これらのメソッドは、セクションページのみで使用する ようにすれば比較的わかりやすいコードを記述できると思います。 特に、サイドバーなどに表示するページツリーを生成するときは、.IsAncestor が true になるセクションだけを、さらに深く辿っていく ようにすれば、カレントページの上位セクションのみを開いたページツリーを生成することができます。 このテストに使用したコードはこちら: https://github.com/maku77/p-7o7ymst/ サイドバー用のページツリーを作成する 下記のパーシャルテンプレートは、現在表示中のページよりも上位のセクションを展開して、ページツリーを表示します。 /layouts/partials/nav-tree.html &lt;h3&gt;メニュー&lt;/h3&gt; {{- template &#34;nav-tree-internal&#34; (dict &#34;section&#34; .Site.Home &#34;current&#34; .) }} {{- define &#34;nav-tree-internal&#34; }} {{- $section := .section }}{{/* 今回処理するセクション */}} {{- $current := .current }}{{/* 現在表示中のページ */}} &lt;ul&gt; {{- /* セクション直下のセクションページをループ表示 */}} {{- range $section.Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}{{ if eq . $current }}★{{ end }}&lt;/a&gt; {{- if or (.IsAncestor $current) (eq . $current) }} {{- /* 開いているページよりも上位のセクション（あるいは自分自身）であればさらに辿る */}} {{- template &#34;nav-tree-internal&#34; (dict &#34;section&#34; . &#34;current&#34; $current) }} {{- end }} {{- end }} {{- /* セクション直下の通常ページをループ表示 */}} {{- range $section.RegularPages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}{{ if eq . $current }}★{{ end }}&lt;/a&gt; {{- end }} &lt;/ul&gt; {{- end }} 例えば、サイドバー用のパーシャルテンプレートなどから次のような感じで使用します。 /layouts/partials/side-bar.html {{ partial &#34;nav-tree&#34; . }} すると、次のような感じのツリーメニューが表示されます。 現在表示中のページには ★ マークが表示され、それよりも上位のセクションだけが展開されて表示されます。 メニュー - sec1/ - sec1-1/ - sec1-1-1/ - page1.html★ - page2.html - sec1-2/ - page.html - page.html ちなみに、ここでは最上位のホームページへのリンクは表示しないようにしています（無駄に階層が 1 つ深くなってしまうため）。 トップページのリンクを表示したいときは、下記のように個別に表示すればよいでしょう。 &lt;a href=&#34;{{ &#34;/&#34; | relURL }}&#34;&gt;Home&lt;/a&gt;"},{url:"/p/co8p6n4/",title:"Hugo で各種ページの .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧",date:"2018-01-11T00:00:00+09:00",body:"Hugo で各種ページの .Kind や .IsPage、.IsSection、.IsNode の値がどうなるかの一覧 Hugo のテンプレートで、ページの種類によって条件分岐するコードを記述するには、レンダリング時のコンテキストにおいて、.Kind の値や .IsPage などの値がどう変化するかを知っておく必要があります。 ページ種類 .RelPermalink の例 .Section .Type .Kind .IsHome .IsNode .IsPage .IsSection ホームページ / nil page home true true false false セクションページ（第 1 階層） /sec1/ sec1 sec1 section false true false true セクションページ（第 2 階層） /sec1/sec2/ sec1 sec1 section false true false true タクソノミーターム /tags/ tags tags taxonomy ※ false true false false タクソノミーリスト /tags/xxx/ tags tags term ※ false true false false 404 ページ nil nil page 404 false true false false 記事ページ（第 1 階層） /mypage/ nil page page false false true false 記事ページ（第 2 階層） /sec1/mypage/ sec1 sec1 page false false true false 記事ページ（第 3 階層） /sec1/sec2/mypage/ sec1 sec1 page false false true false ☝️ ※ taxonomy と term という名前 Hugo v0.73 において taxonomyTerm → taxonomy、taxonomy → term という .Kind 値の変更が入っているので、バージョンアップ時はご注意ください。 上記の値は、次のようなテンプレートコードを、ベーステンプレート (layouts/_default/baseof.html) に記述して調べています（2020-04-27: .IsSection を追記、.URL (deprecated) を .RelPermalink に変更）。 &lt;pre&gt; .RelPermalink = {{ .RelPermalink }} .Section = {{ .Section }} .Type = {{ .Type }} .Kind = {{ .Kind }} .IsHome = {{ .IsHome }} .IsNode = {{ .IsNode }} .IsPage = {{ .IsPage }} .IsSection = {{ .IsSection }} &lt;/pre&gt; これらの情報を使って分岐処理するときの方針としては、まずは、大まかに .IsHome、.IsNode、.IsPage、.IsSection の値で分岐できないかを考え、もう少し細かい分岐処理が必要であれば、.Kind の値を利用する、という感じにするとよいでしょう。 次の例では、title 要素のテキストを構築するときに、.IsHome の値を使って分岐処理しています。 ホームページの場合は「サイト名」だけを表示し、その他のページでは「ページタイトル｜サイト名」のように連結して表示するようにしています。 &lt;title&gt;{{ if not .IsHome }}{{ .Title }}｜{{ end }}{{ .Site.Title }}&lt;/title&gt; あるいは、cond 関数を利用して次のように書くこともできます。 &lt;title&gt;{{ cond .IsHome .Site.Title (print .Title &#34;｜&#34; .Site.Title)}}&lt;/title&gt;"},{url:"/p/bbxj5pa/",title:"Hugo のベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html)",date:"2018-01-10T00:00:00+09:00",body:"Hugo のベーステンプレートを作成して、各種テンプレートの基本構成を統一する (baseof.html) ベーステンプレートの仕組み Hugo のベーステンプレート機能を利用すると、各種テンプレートの親テンプレートのようなものを作成することができます。 ベーステンプレートを作成することで、すべてのページの HTML 構成を統一することができ、個々のテンプレートの見通しもよくなります。 Hugo では、リストテンプレートやシングルページテンプレートなど、用途によって別々のテンプレートファイルを用意することになっています。 でも、HTML 全体の大まかな構成は共通した部分が多いはずです。 例えば、どのページでも HTML は次のような構成になっているはずです。 &lt;!DOCTYPE html&gt; &lt;html lang=&#34;ja&#34;&gt; &lt;html&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; ... &lt;/head&gt; &lt;body&gt; ... &lt;/body&gt; &lt;/html&gt; Hugo のベーステンプレート機能を使用すると、上記のような全体の構成をベーステンプレート (baseof.html) として作成し、その中の部分的なブロックだけを通常のテンプレート（リストテンプレートやシングルページテンプレート）で定義した内容で置き換えるということができます。 図: ベーステンプレートの仕組み Hugo のベーステンプレート機能は、Go のテンプレートライブラリの block template という仕組みを使用しており、block で定義した部分を、define で定義した内容で置き換えるという動作をします。 上の図を見ると分かりやすいと思いますが、ベーステンプレート (baseof.html) を用意すると、基本的にすべてのページがベーステンプレートを利用してレンダリングされるようになり、その中の部分的なブロック（上記では main という名前のブロック）が子テンプレートで定義した内容で置き換えられます。 このとき、どの子テンプレートが使用されるかは、ベーステンプレートの仕組みを使用しない場合と同様で、表示するページの種類によって決まります。 例えば、ホームページやセクションページなどのレンダリングには list.html が使用され、個々の記事ページのレンダリングには single.html が使用されます。 具体的なベーステンプレートの利用例 下記はベーステンプレートの具体的な記述例です。 main 要素以下のメインコンテンツを block template の機能で置き換えるようにしています。 layouts/_default/baseof.html（ベーステンプレート） &lt;!DOCTYPE html&gt; &lt;html lang=&#34;{{ .Site.LanguageCode }}&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width,initial-scale=1.0&#34;&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;{{ &#34;assets/css/main.css&#34; | relURL }}&#34;&gt; &lt;title&gt;{{ if not .IsHome }}{{ .Title }}｜{{ end }}{{ .Site.Title }}&lt;/title&gt; {{ partial &#34;head/favicon&#34; . }} &lt;/head&gt; &lt;body&gt; &lt;div id=&#34;root&#34;&gt; &lt;div id=&#34;pageTitle&#34;&gt;&lt;a href=&#34;{{ &#34;/&#34; | relURL }}&#34;&gt;{{ .Site.Title }}&lt;/a&gt;&lt;/div&gt; {{ partial &#34;menu&#34; . }} &lt;main id=&#34;main&#34;&gt; {{ block &#34;main&#34; . }}main ブロックが見つかりません。{{ end }} &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; layouts/_default/list.html（リストテンプレート） {{ define &#34;main&#34; }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ partial &#34;breadcrumb&#34; . }} {{ .Content }} &lt;h2&gt;ページリスト&lt;/h2&gt; &lt;ul&gt; {{- range .Data.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; {{ end }} layouts/_default/single.html（シングルページテンプレート） {{ define &#34;main&#34; }} &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ partial &#34;breadcrumb&#34; . }} {{ partial &#34;tags-in-page&#34; . }} {{ .Content }} {{ end }} 子テンプレートにはテキスト出力するコードを入れない ベーステンプレート（親テンプレート）を使用したレンダリングを行いたい場合は、子テンプレート側では何も出力しないようにする必要があるようです。 例えば、下記のシングルページテンプレートでは、部分テンプレート main を定義していますが、その直後に「こんにちは！」と出力しています。 layouts/_default/single.html {{ define &#34;main&#34; }} メインコンテンツ１ {{ end }} こんにちは！ このように記述してしまうと、シングルページレイアウトには、ベーステンプレート (baseof.html) によるレイアウトが適用されなくなり、「こんにちは！」としか表示されなくなってしまうようです。 逆に、ベーステンプレートを適用したくないテンプレートファイルでは、そのテンプレートファイルだけで出力を完結してしまえばよいということですね。"},{url:"/p/xuwd7tn/",title:"Hugo でサイト内の全ページの一覧をセクションの階層構造に従って表示する",date:"2018-01-09T00:00:00+09:00",body:"Hugo でサイト内の全ページの一覧をセクションの階層構造に従って表示する 現在の階層のページ一覧を出力するテンプレートを再帰的に呼び出すようにすると、サイト内の全てのセクションとページを、ツリー構造で表示することができます。 すべてのページのリンクが出力されるので、サイトマップの出力に使用したり、ホームページ用のテンプレートに利用するとよいでしょう。 ツリー出力の基本 下記は、サイト内のすべてのページをツリー形式で表示するサンプルテンプレートです。 セクション変数の .Pages を参照すると、そのセクションに含まれるサブセクションや通常ページを取得することができるので、それを range でループ処理しています。 部分テンプレート hierarchy を定義し、これをホームページ (.Site.Home) から再帰的に呼び出すことで全ページのツリー構造を出力しています。 layouts/index.html（抜粋） &lt;h2&gt;全ページのリスト&lt;/h2&gt; {{- define &#34;hierarchy&#34; }} &lt;ul&gt; {{- range .Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- if .IsSection }}{{ template &#34;hierarchy&#34; . }}{{ end }} {{- end }} &lt;/ul&gt; {{- end }} {{ template &#34;hierarchy&#34; .Site.Home }} 出力結果のイメージ（実際には各項目がリンクになります） * タイトル A * セクション 1 * セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * タイトル B * タイトル C * セクション 2 * セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B ここでは、hierarchy のパラメータとして .Site.Home を渡しているため、サイト全体のページツリーが出力されていますが、任意のセクションをルートにしてページツリーを出力することができます。 例えば、セクションテンプレートで次のように呼び出せば、現在のページが所属しているセクション (.CurrentSection) 以下のセクションおよびページをツリー表示できます。 {{ template &#34;hierarchy&#34; .CurrentSection }} セクションページを優先的に表示する ページをリスト化するときに、セクションページを通常ページよりも先に表示したいときは、例えば次のようにします。 ここでは、セクションページと通常ページを .Pages でまとめてループ処理するのではなく、.Sections でセクションページのみを先にループ処理してから、.RegularPages で通常ページをループ処理するようにしています。 layouts/index.html（抜粋） {{- define &#34;hierarchy&#34; }} &lt;ul&gt; {{- /* セクションページをループ処理 */}} {{- range .Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;📁{{ .Title }}&lt;/a&gt; {{- template &#34;hierarchy&#34; . }} {{- end }} {{- /* 通常の記事ページをループ処理 */}} {{- range .RegularPages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; {{- end }} {{ template &#34;hierarchy&#34; .Site.Home }} 出力結果のイメージ（セクションページが先に表示される） * 📁セクション 1 * 📁セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * 📁セクション 2 * 📁セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B * タイトル A * タイトル B * タイトル C ちなみに、セクション名の前にはフォルダアイコンを表示しています（Unicode の数値文字参照で &amp;#128193; と書いても OK）。 フォルダアイコンを表示する別の方法として、Hugo の絵文字表示機能 (emojify) を使って、{{ emojify &quot;:open_file_folder:&quot; }} のように記述する方法もあります。 指定したセクションも含めて表示する ツリー構造が一段深くなってしまうのでオススメはしませんが、指定したセクション（ルートセクション）も含めてツリー表示するには、例えば次のように実装します。 {{- define &#34;hierarchy&#34; }} &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;📁{{ .Title }}&lt;/a&gt; {{- range .Sections }} {{- template &#34;hierarchy&#34; . }} {{- end }} {{- range .RegularPages }} &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; &lt;/ul&gt; {{- end }} &lt;/ul&gt; {{- end }} {{ template &#34;hierarchy&#34; .Site.Home }} 次のように、ホームページをルートとしてツリー表示されます。 出力結果のイメージ * 📁ホーム * 📁セクション 1 * 📁セクション 1-1 * タイトル 1-1-A * タイトル 1-1-B * タイトル 1-A * タイトル 1-B * 📁セクション 2 * 📁セクション 2-1 * タイトル 2-1-A * タイトル 2-1-B * タイトル A * タイトル B * タイトル C 2 階層目までを表示する 下記の例では、hierarchy ローカルテンプレートに level というパラメータを追加し、そのパラメータで指定した階層までのページリストを表示するように変更したものです。 ここでは level に 2 を指定して、2 階層目までのページをツリー出力しています。 layouts/index.html（抜粋） &lt;h2&gt;2 階層目までのページのリスト&lt;/h2&gt; {{- define &#34;hierarchy&#34; }} {{- $section := .section }} {{- $level := .level }} &lt;ul&gt; {{- range $section.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ if .IsSection }}📁{{ end }}{{ .Title }} {{- if and .IsSection (gt $level 1) }} {{- template &#34;hierarchy&#34; (dict &#34;section&#34; . &#34;level&#34; (sub $level 1)) }} {{- end }} &lt;/li&gt; {{- end }} &lt;/ul&gt; {{- end }} {{ template &#34;hierarchy&#34; (dict &#34;section&#34; .Site.Home &#34;level&#34; 2) }} 出力結果のイメージ * タイトル A * 📁セクション 1 * セクション 1-1 * タイトル 1-A * タイトル 1-B * タイトル B * タイトル C * 📁セクション 2 * 📁セクション 2-1 hierarchy テンプレートを再帰呼び出しするときに、sub 関数で level パラメータの値を 1 つずつ減らすことで、再帰処理を途中で止めるようにしています。"},{url:"/p/vqran9d/",title:"CSS のふくろうセレクターで全要素の上下マージンを設定する",date:"2018-01-08T00:00:00+09:00",body:"CSS のふくろうセレクターで全要素の上下マージンを設定する HTML の各要素の上下のマージンを、それぞれの要素の margin-top や margin-bottom で設定していると、ちょっとした調整が全体のレイアウトの崩れにつながります。 Owl セレクタ（ふくろうセレクタ） と呼ばれている * + * という CSS セレクタを利用すると、全要素のマージンをまとめて設定することができるので、サイト全体のレイアウトに一貫性を持たせることができます。 * + * という指定は、ユニバーサルセレクタ (*) と隣接セレクタ (+) の組み合わせから成っており、要するに、連続する 2 番目以降の要素をすべて選択するという意味になります。 * + * によって選択された要素の上マージン (margin-top) を設定してやることで、要素間のマージンをまとめて設定できます。 下記の例では、main 要素直下に配置された、すべての要素間に 1rem のマージンを設定しています（つまり、そのページのフォントサイズで１行分のマージン）。 CSS * { margin: 0; /* ブラウザ依存のマージンはリセット */ } html { font-size: 100%; /* ユーザの指定した表示サイズを尊重する */ line-height: 1.5; } main &gt; * + * { margin-top: 1rem; /* サイト全体で上下マージンを統一 */ } main &gt; * + h2, main &gt; * + h3, main &gt; * + h4, main &gt; * + h5, main &gt; * + h6 { margin-top: 1.5em; /* ヘッダ要素の上マージンは広めに取る */ } ただし、h2 や h3 などのヘッダの上マージンまで同じサイズになってしまうと、セクションごとのまとまりが分かりにくくなってしまいます。 そこで、ヘッダに関しては特別に 1.5em のマージンを設定しています。 このマージンには、単位として rem ではなく、em を使用していることに注意してください。 em を使用することで、ヘッダ自身のフォントサイズを基準として、1.5 行分のマージンが設定されることになります。 つまり、h2 要素のマージンの方が、h3 要素のマージンよりも大きくなるということです（h2 のフォントサイズの方が大きければですが）。 参考サイト: Axiomatic CSS and Lobotomized Owls"},{url:"/p/37hwzxi/",title:"Python で定数を定義する (typing.Final)",date:"2018-01-08T00:00:00+09:00",body:"Python で定数を定義する (typing.Final) Python 3.8 以降では、typing.Final による型アノテーションを使って、再代入できない変数（定数）であることを表現できます（参考: PEP 591）。 定数名は すべて大文字（+ アンダースコア） で構成するのが慣例となっています。 このあたりの標準的な命名規則は PEP8 に記載されています。 参考: PEP 8 &ndash; Style Guide for Python Code｜Python.org Constants are usually defined on a module level and written in all capital letters with underscores separating words. Examples include MAX_OVERFLOW and TOTAL. 例: ファイル内（モジュールレベル）の定数 from typing import Final MAX_FILE_NUM: Final = 10 ORIGIN_COORD: Final = (0, 0) DEFAULT_NAME: Final = &#34;Player&#34; クラス定数も下記のようにして同様に定義することができます。 例: クラス定数 from typing import Final class Player: DEFAULT_NAME: Final = &#34;Player&#34; DEFAULT_LIFE: Final = 0 def __init__(self, name: str = DEFAULT_NAME, life: int = DEFAULT_LIFE) -&gt; None: self.name = name self.life = life Final アノテーションは、Mypy などの型チェッカーが再代入を検出するためのヒントとして使用するものです。 例えば、Visual Studio Code に Mypy 拡張 をインストールしておくと、コーディング中に不正な再代入を検出してくれるようになります。 ただし、コードの実行時には、Final を付けた変数に再代入できてしまうことに注意してください。 コラム: 定数を扱うためのモジュール (const.py) を作成する 下記のような、定数を扱うためのクラスが Python Recipes で紹介されています（Python3 の構文に合わせて若干書き換えてます）。 const.py &#34;&#34;&#34; Constant types in Python. &#34;&#34;&#34; class _const: class ConstError(TypeError): pass def __setattr__(self, name, value): if name in self.__dict__: raise self.ConstError(&#34;Can&#39;t rebind const (%s)&#34; % name) self.__dict__[name] = value import sys sys.modules[__name__] = _const() 元ネタは書籍の『Python Cookbook』ですね。 この定数モジュールは下記のように定数の入れ物として使用します。 sample.py import const const.FOO = 100 const.BAR = &#39;Hello&#39; 下記のように、同じ名前の定数に再代入しようとすると、ランタイムエラー (独自定義の const.ConstError) が発生して、プログラムが停止します。 const.HOGE = 100 const.HOGE = 200 # const.ConstError: Can&#39;t rebind const (HOGE)"},{url:"/p/xwog7ip/",title:"Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re)",date:"2018-01-07T00:00:00+09:00",body:"Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re) replace_files.py 複数のテキストファイル内の文字列を一気に置換してしまう Python スクリプトの実装例を紹介します。 ここでは、カレントディレクトリ以下の Markdown ファイル (.md) 内の時刻情報を書き換えてみます。 置換対象のテキストは、下記のような日付情報を表すテキストです（created: の部分を date: に置き換えます）。 （置換前のテキスト）created: &quot;2018-01-01&quot; （置換後のテキスト）date: &quot;2018-01-01&quot; replace_files.py import glob import re GLOB = &#39;**/*.md&#39; REPLACE_FROM = re.compile(r&#39;created: (\\d{4}-\\d{2}-\\d{2})&#39;) REPLACE_TO = r&#39;date: &#34;\\1&#34;&#39; def write_lines(filename, lines): with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.write(lines) def read_lines(filename): with open(filename, encoding=&#39;utf-8&#39;) as f: return f.read() def process_file(filename): src_lines = read_lines(filename) dst_lines = REPLACE_FROM.sub(REPLACE_TO, src_lines) if src_lines == dst_lines: print(filename) else: write_lines(filename, dst_lines) print(filename + &#39;: CHANGED&#39;) if __name__ == &#39;__main__&#39;: for filename in glob.iglob(GLOB, recursive=True): process_file(filename) このスクリプトを実行すると、既存のファイル自体を書き換えることに注意してください（実行する前に、必ずバックアップを取ってください）。 置換パターンに一致する行が見つからなかった場合は、そのファイルに対する書き換え処理は行われません（同じ内容を書き戻すような無駄な処理はしません）。 実行例 $ python replace_files.py python/io/basename.md: CHANGED python/io/yaml.md: CHANGED python/io/user-input.md: CHANGED python/io/script-path.md: CHANGED ... ☝️ ワンポイント 上記のサンプルコードでは、パターンに一致する部分のうち、最初に見つかった部分だけを置換します。 パターンに一致する全ての文字列を置換したい場合は、sub メソッドの代わりに gsub メソッドを使用してください。 参考 Python で文字列を置換する (str.replace, re.sub, re.subn)"},{url:"/p/on7omgt/",title:"JavaScript で HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索",date:"2018-01-06T00:00:00+09:00",body:"JavaScript で HTML の DOM 要素を取得する (1) タグ名、クラス名、ID を検索 タグ名で要素を取得する (getElementsByTagName) document.getElementsByTagName() 関数を使用すると、指定したタグ名を持つ要素を取得することができます。 同じタグ名を持つ要素は複数存在する可能性があるので、戻り値は配列になります。 例: p 要素をすべて取得する &lt;p&gt;こんにちは&lt;/p&gt; &lt;p&gt;おやすみ&lt;/p&gt; &lt;script&gt; window.onload = function() { const elems = document.getElementsByTagName(&#34;p&#34;); for (const e of elems) { console.log(e.innerText); } }; &lt;/script&gt; 実行結果 こんにちは おやすみ クラス名で要素を取得する (getElementsByClassName) document.getElementsByClassName() 関数を使用すると、指定したクラス名が class 属性に含まれている要素を取得することができます。 そのような要素は複数存在する可能性があるので、戻り値は配列になります。 &lt;div class=&#34;foo&#34;&gt;AAA&lt;/div&gt; &lt;div class=&#34;foo bar&#34;&gt;BBB&lt;/div&gt; &lt;div class=&#34;foo bar baz&#34;&gt;CCC&lt;/div&gt; &lt;script&gt; window.onload = function() { const elems = document.getElementsByClassName(&#34;foo&#34;); for (const e of elems) { console.log(e.innerText); } }; &lt;/script&gt; 実行結果 AAA BBB CCC ID で要素を取得する (getElementById) document.getElementById() 関数を使用すると、指定した ID を id 属性に持つ要素を取得することができます。 指定した ID を持つ要素が見つからない場合は null を返します。 例: id 属性に message が含まれている要素を取得する &lt;span id=&#34;message&#34;&gt;ばよえーん&lt;/span&gt; &lt;script&gt; window.onload = function() { const elem = document.getElementById(&#34;message&#34;); if (elem) { console.log(elem.innerText); //=&gt; ばよえーん } }; &lt;/script&gt; 特定の ID を持つ要素は高々ひとつしか存在することができないので、getElementsByTagName や getElementsByClassName とは異なり、getElementById は単一の要素を返すことに注意してください。 子要素からのみ検索する document の代わりに、特定の親要素に対して前述のメソッドを呼び出すようにすれば、その子要素だけを検索対象とすることができます。 下記の例では、まず ID で要素を検索し、次にタグ名による検索を行なっています。 子要素の検索 &lt;ul id=&#34;my-data&#34;&gt; &lt;li&gt;AAA&lt;/li&gt; &lt;li&gt;BBB&lt;/li&gt; &lt;li&gt;CCC&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; window.onload = function() { const data = document.getElementById(&#34;my-data&#34;); const elems = data.getElementsByTagName(&#34;li&#34;); for (const e of elems) { console.log(e.innerText); } }; &lt;/script&gt; 実行結果 AAA BBB CCC セレクタ API で要素を取得する (querySelector, querySelectorAll) CSS のセレクタ形式（#foo や .bar など）で要素を指定して取得したいときは、document.querySelector() 関数や document.querySelectorAll() 関数を使用します。 前者は最初に見つかった要素、後者は見つかった全ての要素を返します。 例: id 属性が sample の要素を取得 window.onload = function() { const elem = document.querySelector(&#34;#sample&#34;); console.log(elem); }; 例: class 属性に sample を持つ要素をすべて取得 window.onload = function() { const elems = document.querySelectorAll(&#34;.sample&#34;); console.log(elems); }; 例: div 要素で、かつ、class 属性に note を持つ要素をすべて取得 window.onload = function() { const elems = document.querySelectorAll(&#34;div.note&#34;); console.log(elems); }; 例: li 要素で、偶数番目のものをすべて取得 window.onload = function() { const elems = document.querySelectorAll(&#34;li:nth-child(even)&#34;); console.log(elems); }; ☝️ jQuery と同じ？ jQuery が登場した当初は、このようなセレクタ API が使えることがひとつのウリでした。 現在は JavaScript の機能として querySelectAll() が使えるようになっているので、セレクタ API だけのために jQuery を使用する必要はなくなりました。"},{url:"/p/vemn3c4/",title:"Hugo でパンくずリストを表示する",date:"2018-01-02T00:00:00+09:00",body:"Hugo でパンくずリストを表示する パンくずリストは、親ページに素早くジャンプするための次のようなリンクです。 ホーム &gt; セクション1 &gt; セクション2 &gt; ページタイトル ここでは、Hugo のテンプレート機能を使って、パンくずリストを出力する方法を説明します。 パンくずリストを表示するためのテンプレート 下記は、パンくずリストを出力するための breadcrumb テンプレートの定義です（Hugo 本家で紹介されているコードを参考にしています）。 {{- define &#34;breadcrumb&#34; }} {{- if .node.Parent }} {{- template &#34;breadcrumb&#34; (dict &#34;node&#34; .node.Parent &#34;start&#34; .start) }} {{- else if not .node.IsHome }} {{- template &#34;breadcrumb&#34; (dict &#34;node&#34; .node.Site.Home &#34;start&#34; .start) }} {{- end }} {{- if eq .node .start }} &lt;li&gt;{{ .node.LinkTitle }} {{- else }} &lt;li&gt;&lt;a href=&#34;{{ .node.Permalink }}&#34;&gt;{{ .node.LinkTitle }}&lt;/a&gt; {{- end }} {{- end }} 実際にパンくずリストを出力したい部分で下記のように呼び出します。 &lt;ol class=&#34;breadcrumb&#34;&gt; {{- template &#34;breadcrumb&#34; (dict &#34;node&#34; . &#34;start&#34; .) }} &lt;/ol&gt; さらに、下記のようなスタイルを適用すれば、リンクがいい感じで横方向に並んでくれます。 .breadcrumb { padding: 0; } .breadcrumb li { display: inline; list-style: none; } .breadcrumb li:not(:last-child)::after { content: &#39;&gt;&#39;; padding: 0 0.5em; } 表示イメージ ホーム &gt; セクション1 &gt; セクション2 &gt; ページタイトル ☝️ ワンポイント ここでは、リンクタイトルとして、.LinkTitle で取得したページタイトルを表示しています。 記事のフロントマターに、linkTitle プロパティが設定されている場合、title の設定よりも優先して表示されます。 linkTitle に短めのタイトルを設定しおくことで、パンくずリストをシンプルに表示できます。 解説 パンくずリストを作成する基本的な考え方は、自分自身のページから親ページを辿るという方法です。 Hugo では、.Parent で親ページ（親セクション）を参照することができるので、下記のように再帰的に .Parent を辿っていくことで、最上位のホームページまで辿ることができます（ホームページまで到達すると .Parent の値が nil になるのでそこで再帰呼び出しが止まります）。 {{- define &#34;breadcrumb&#34; }} {{- if .Parent }} {{- template &#34;breadcrumb&#34; .Parent }} {{- end }} &lt;li&gt;{{ .Title }} {{- end }} &lt;ol&gt; {{- template &#34;breadcrumb&#34; . }} &lt;/ol&gt; 例えば、ホームページから見て 2 階層下のセクション内のページで、上記のテンプレートを適用すると、次のような HTML が出力されます。 &lt;ol&gt; &lt;li&gt;ホームページ &lt;li&gt;セクション &lt;li&gt;サブセクション &lt;li&gt;サブセクション内の記事タイトル &lt;/ol&gt; 通常の記事ページやセクションページでパンくずリストを表示するときは、このアルゴリズムで十分なのですが、これだけだと、タクソノミーリスト（あるタグを持つ記事一覧）のページを表示するケースで、最上位にホームページが表示されません。 なぜなら、タクソノミーリストのページで .Parent を参照してもホームページを取得することはできず、nil になってしまうからです。 パンくずリストの最上位に必ずホームページを表示するには、下記のように else if を追加する必要があります。 {{- define &#34;breadcrumb&#34; }} {{- if .Parent }} {{- template &#34;breadcrumb&#34; .Parent }} {{- else if not .IsHome }} {{- template &#34;breadcrumb&#34; .Site.Home }} {{- end }} &lt;li&gt;{{ .Title }} {{- end }} &lt;ol&gt; {{- template &#34;breadcrumb&#34; . }} &lt;/ol&gt; 親ページが見つからなかったときに、自分自身がホームページではないとすると、自分自身はタクソノミーリストのページだと考えられます。 なので、そのようなケースでは、強制的に .Site.Home をパラメータに渡して、ホームページを出力するようにしています。 上記のテンプレートを、タクソノミーリストのページに適用すると、例えば下記のような感じで表示されます（正しく先頭にホームページが表示されます）。 &lt;ol&gt; &lt;li&gt;ホームページ &lt;li&gt;タグ１ &lt;/ol&gt; あとは、リンク出力やスタイル定義などを加えてあげれば、立派なパンくずリストが完成します。"},{url:"/p/pkww45p/",title:"Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき）",date:"2018-01-01T00:00:00+09:00",body:"Hugo テンプレート内で define による部分テンプレート定義を行う（関数もどき） Hugo のテンプレートファイル内で define を使用すると、部分的なテンプレートを定義することができ、別の場所から関数のように呼び出すことができます。 define による部分テンプレート定義の基本 Hugo のテンプレート定義は、基本は layouts ディレクトリ内に置いたテンプレートファイル（HTML ファイル）単位で行うのですが、そのテンプレートファイルの中で、define アクションを使用することで、入れ子でテンプレート定義を行うことができます。 テンプレートファイル内で使える関数定義のようなもの だと思うと分かりやすいです。 次の例では、define を使用して、showParentSection というテンプレートを定義しています。 showParentSection テンプレートを定義する {{/* セクションの一覧を出力します */}} {{ define &#34;showParentSection&#34; }} &lt;h2&gt;セクション一覧&lt;/h2&gt; &lt;ul&gt; {{- range .Site.Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; {{ end }} define で定義したテンプレートを呼び出すには、template 関数を使用します。 {{ template &#34;showParentSection&#34; . }} 2 番目のパラメータで渡した値が、部分テンプレート側のドットコンテキスト (.) として参照できるようになります。 多くの場合は、上記のようにドット (.) を指定し、Page オブジェクトを参照できるようにします。 複数のパラメータを受け取る部分テンプレートを定義する template 関数を使って部分テンプレートを呼び出すときは、引数に . を指定して Page オブジェクトを渡すことが多いのですが、単純な文字列や数値をパラメータとして渡すこともできます。 次の例では、パラメータで渡された名前を使って挨拶文を出力する greet テンプレートを定義しています。 greet テンプレートを定義する {{ define &#34;greet&#34; }} Hello, {{ . }}! {{ end }} この greet テンプレートを呼び出すには次のようにします。 {{ template &#34;greet&#34; &#34;Maku&#34; }} 出力結果 Hello, Maku! パラメータとして マップオブジェクト を渡せば、名前付きパラメータを実現できます。 次の例で定義している calc テンプレートは、x と y というキーを含むマップオブジェクトを受け取ることを想定しています。 {{ define &#34;calc&#34; }} {{ printf &#34;%d+%d=%d&#34; .x .y (add .x .y) }} {{ end }} この calc テンプレートは次のように呼び出します。 マップオブジェクトを作成するときは、dict 関数のパラメータに、キーと値を交互に指定します。 {{ template &#34;calc&#34; (dict &#34;x&#34; 100 &#34;y&#34; 200) }} 出力結果 100+200=300 ☝️ ワンポイント マップオブジェクトを受け取る部分テンプレートを定義するときは、次のように先頭でローカル変数（$x や $y）に代入してしまう慣例もあるようです。 このように記述しておくことで、この部分テンプレートにどのようなキーを持つマップオブジェクトを渡せばよいのかが一目で分かるようになります。 {{ define &#34;calc&#34; }} {{ $x := .x }} {{ $y := .y }} {{ printf &#34;%d+%d=%d&#34; $x $y (add $x $y) }} {{ end }} パーシャルテンプレートとの違い layouts/partials/foo.html というファイル名で作成したパーシャルテンプレートは、次のように partial を使って呼び出します。 {{ partial &#34;foo&#34; . }} 一方で、define で定義した部分テンプレート（Go のドキュメントでは nested template と呼んでいます）は、次のように template を使って呼び出します。 {{ template &#34;foo&#34; . }} 呼び出し方がちょっと異なるだけで、ほとんど同じような感覚で使えるようです。 使い分けの基準としては、 複数のテンプレートファイルから共通で使用するものは、パーシャルテンプレート (layouts/partials/xxx.html) として定義する。 1 つのテンプレートファイル内でのみ使用する部分テンプレートは、define による部分テンプレートとして定義する。 と考えておけばよいでしょう。 応用: Hugo のパーシャルテンプレートから値を返す（関数化）"},{url:"/p/topd7uy/",title:"Hugo で記事ページに付けられたターム一覧（タグ一覧）を表示する",date:"2018-01-01T00:00:00+09:00",body:"Hugo で記事ページに付けられたターム一覧（タグ一覧）を表示する シングルページテンプレートにおいて、その記事ページに付けられたタグの一覧を表示するようにしておくと、関連する記事（同じタグの付けられた記事）を探しやすくなります。 タクソノミーターム（タグやカテゴリ）は、各ページの front matter 部分で定義するので、ページ変数 (.Params) 経由でその情報を取得することができます。 次のパーシャルテンプレートは、記事ページに付けられたタグの情報を取得し、リスト形式で出力します。 layouts/partials/tags-in-page.html &lt;ul class=&#34;tags&#34;&gt; {{- range .Params.tags -}} &lt;li&gt;&lt;a href=&#34;{{ &#34;/tags/&#34; | relLangURL }}{{ . | urlize }}&#34;&gt;{{ . }}&lt;/a&gt; {{- end -}} &lt;/ul&gt; タグが設定されていない場合に、先頭の ul 要素ごと出力しないようにするには、ちょっとだけ変えて下記のようにします。 {{ with .Params.tags }} &lt;ul class=&#34;tags&#34;&gt; {{- range . -}} &lt;li&gt;&lt;a href=&#34;{{ &#34;/tags/&#34; | relLangURL }}{{ . | urlize }}&#34;&gt;{{ . }}&lt;/a&gt; {{- end -}} &lt;/ul&gt; {{ end }} 上記のパーシャルテンプレートを使用するときは、シングルページテンプレート内で次のように記述します。 layouts/_default/single.html {{ partial &#34;tags-in-page&#34; . }} デフォルトでは、li 要素は単純な箇条書きのリスト形式で表示されてしまいます。 次のようなスタイルを定義しておくと、それっぽく横並びで表示されてよい感じになります。 CSS .tags { padding: 0; } .tags li { display: inline-block; /* 横に並べる */ list-style-type: none; margin-right: 0.5em; } .tags li a { display: block; /* 選択範囲を広げる */ text-decoration: none; padding: 0.5em 1em; background: lightgray; color: #333; } .tags li a:hover { background: #555; color: white; } 実際に表示すると次のような感じになります。"},{url:"/p/5v7o2xp/",title:"Hugo で記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする",date:"2018-01-01T00:00:00+09:00",body:"Hugo で記事ページに複数のターム（カテゴリ）を割り当てた場合にエラーにする Hugo の仕組みでは、1 つのタクソノミーに割り当てられるタームの数を制限することはできません。 ここでは、複数のタームを割り当ててしまった場合に、エラー表示を行う方法を紹介します。 １つの記事ページに複数のタグを付けるのはよくあることですが、Web サイトのポリシーによっては、1 つの記事に付けられるカテゴリーは 1 つまでに制限したい、ということがあるかもしれません。 Hugo のデフォルトの仕組みでは、そのような制限はできないのですが、複数のカテゴリが付けられた記事を表示したときに、ログとページ上にメッセージを表示することはできます。 下記のシングルページテンプレートでは、categories タクソノミーに 2 つ以上の値（ターム）が設定されている場合に警告メッセージを出力しています。 errorf 関数を使ってテキスト出力を行うことで、画面上への出力と同時に、コンソール上にもエラーメッセージを出力することができます。 layouts/_default/single.html（抜粋） {{ if .Params.categories }} {{ if gt (len .Params.categories) 1 }} &lt;b&gt;{{ errorf &#34;カテゴリが 1 つ以上設定されています！&#34; }}&lt;/b&gt; {{ end }} {{ end }} ☝️ ワンポイント len .Params.categories を実行するときに、.Params.categories が存在しないと nil dereference のエラーが発生してしまいます。 そのため、最初に if .Params.categories という存在チェックを入れています。 例えば、記事ページの先頭のフロントマターで、下記のように複数のカテゴリを割り当てるような記述をすると、上記の警告メッセージが表示されます。 content/sample-page.md --- title: &#34;サンプルページ&#34; categories: [&#34;カテゴリ1&#34;, &#34;カテゴリ2&#34;] --- サンプルページの本文。"},{url:"/p/tfk4tdg/",title:"Hugo でサイト全体のターム一覧（タグ一覧）を表示する",date:"2017-12-31T00:00:00+09:00",body:"Hugo でサイト全体のターム一覧（タグ一覧）を表示する Web サイトのサイドバーなどに、タクソノミータームの一覧（つまりタグの一覧、タグクラウドなど）を表示しておくと、同じ系統の記事に素早くアクセスできて便利です。 ここでは、タクソノミーとして Hugo デフォルトの tags と categories が定義されていることを前提とします。 特定のタクソノミーのターム一覧を表示（タグの一覧を表示する） ここでは、tags タクソノミーに含まれているターム一覧を表示する例を示します（つまりタグの一覧です）。 多くのサイトでは、使用するタクソノミーの数は限られている（デフォルトの tags や categories で間に合うことが多い）ので、この使い方が一番多いかもしれません。 テンプレートの実装 &lt;h3&gt;タグ一覧&lt;/h3&gt; &lt;ul&gt; {{- range $termName, $entries := .Site.Taxonomies.tags }} &lt;li&gt;&lt;a href=&#34;{{ &#34;/tags/&#34; | relLangURL }}{{ $termName | urlize }}&#34;&gt;{{ $termName }}&lt;/a&gt; ({{ $entries.Count }}) {{- end }} &lt;/ul&gt; 出力結果 &lt;h3&gt;タグ一覧&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B01&#34;&gt;タグ1&lt;/a&gt; (5) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B02&#34;&gt;タグ2&lt;/a&gt; (10) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B03&#34;&gt;タグ3&lt;/a&gt; (15) &lt;/ul&gt; 各リンクの後ろには、そのタグを含むページの数を表示しています。 ページ数の多い順に列挙するには次のようにします。 テンプレートの実装 &lt;h3&gt;タグ一覧&lt;/h3&gt; &lt;ul&gt; {{- range .Site.Taxonomies.tags.ByCount }} &lt;li&gt;&lt;a href=&#34;{{ &#34;/tags/&#34; | relLangURL }}{{ .Term | urlize }}&#34;&gt;{{ .Term }}&lt;/a&gt; ({{ .Count }}) {{- end }} &lt;/ul&gt; 出力結果 &lt;h3&gt;タグ一覧&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B03&#34;&gt;タグ3&lt;/a&gt; (15) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B02&#34;&gt;タグ2&lt;/a&gt; (10) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B01&#34;&gt;タグ1&lt;/a&gt; (5) &lt;/ul&gt; ターム一覧と、そのタームに所属するページを列挙する タグ別にページの一覧まで表示してしまいたい場合は次のようにします。 テンプレートの実装 &lt;h3&gt;タグ別ページ一覧&lt;/h3&gt; &lt;ul&gt; {{- range $termName, $entries := .Site.Taxonomies.tags }} &lt;li&gt;{{ $termName }} &lt;ul&gt; {{- range $entries.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt; {{- end }} &lt;/ul&gt; &lt;/li&gt; {{- end }} &lt;/ul&gt; 出力結果 &lt;h3&gt;タグ別ページ一覧&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;タグ1 &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/page1/&#34;&gt;記事ページ1&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/page2/&#34;&gt;記事ページ2&lt;/a&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;タグ2 &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/page3/&#34;&gt;記事ページ3&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/page4/&#34;&gt;記事ページ4&lt;/a&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;タグ3 &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/page2/&#34;&gt;記事ページ2&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/page4/&#34;&gt;記事ページ4&lt;/a&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; 全タクソノミーのターム一覧を表示 タクソノミーが tags や categories 以外にもたくさん定義されている場合、全てのタクソノミーをループ処理で出力してしまうのがよいかもしれません。 下記の例では、1 つ目の range ループですべてのタクソノミーをループ処理し、2 つ目の range ループで各タクソノミー内のタームをループ処理しています。 テンプレートの実装 &lt;h3&gt;全タクソノミーのターム一覧を表示&lt;/h3&gt; &lt;ul&gt; {{- range $taxonomyName, $taxonomy := .Site.Taxonomies }} {{- $taxonomyUrl := print (&#34;/&#34; | relLangURL) ($taxonomyName | urlize) }} &lt;li&gt;&lt;a href=&#34;{{ $taxonomyUrl }}&#34;&gt;{{ $taxonomyName }}&lt;/a&gt; &lt;ul&gt; {{- range $termName, $entries := $taxonomy }} &lt;li&gt;&lt;a href=&#34;{{ print $taxonomyUrl &#34;/&#34; ($termName | urlize) }}&#34;&gt;{{ $termName }}&lt;/a&gt; ({{ $entries.Count }}) {{- end }} &lt;/ul&gt; &lt;/li&gt; {{- end }} &lt;/ul&gt; 出力結果 &lt;h3&gt;全タクソノミーのターム一覧を表示&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/categories&#34;&gt;categories&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/categories/%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA1&#34;&gt;カテゴリ1&lt;/a&gt; (7) &lt;li&gt;&lt;a href=&#34;/categories/%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA2&#34;&gt;カテゴリ2&lt;/a&gt; (3) &lt;li&gt;&lt;a href=&#34;/categories/%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA3&#34;&gt;カテゴリ3&lt;/a&gt; (9) &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=&#34;/tags&#34;&gt;tags&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B01&#34;&gt;タグ1&lt;/a&gt; (5) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B02&#34;&gt;タグ2&lt;/a&gt; (10) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B03&#34;&gt;タグ3&lt;/a&gt; (15) &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; タクソノミーごとにタームの一覧情報だけ出力すればよいのであれば、$.Site.GetPage を組み合わせて使用することで、もう少しシンプルに記述することができます。 {{- range $taxonomyName, $taxonomy := .Site.Taxonomies }} &lt;h2&gt;{{ $taxonomyName }}&lt;/h2&gt; &lt;ul&gt; {{- range ($.Site.GetPage &#34;taxonomyTerm&#34; $taxonomyName).Pages }} &lt;li&gt;&lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/li&gt; {{- end }} &lt;/ul&gt; {{- end }} さらに、タームが付加されている各ページへのリンクをすべて表示したいのであれば、次のような感じで記述すればよいでしょう。 &lt;h1&gt;全ページのタクソノミー別リンク&lt;/h1&gt; {{- range $taxonomyName, $taxonomy := .Site.Taxonomies }} &lt;h2&gt;{{ $taxonomyName }}&lt;/h2&gt; {{- range $termName, $entries := $taxonomy }} &lt;h3&gt;{{- $termName }}&lt;/h3&gt; &lt;ul&gt; {{- range $entries.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink}}&#34;&gt;{{ .LinkTitle }}&lt;/a&gt; {{- end }} &lt;/ul&gt; {{- end }} {{- end }} 出力結果は長くなってしまうので省略します。 大きなサイトではあまりにも巨大なリンク集になってしまうので使いものにならないかもしれませんが、小規模なサイトでは、タクソノミー別のサイトマップを作成したいときに使えるかもしれません。"},{url:"/p/aqchnnq/",title:"Hugo でタクソノミー関連のテンプレートを定義する",date:"2017-12-31T00:00:00+09:00",body:"Hugo でタクソノミー関連のテンプレートを定義する あるタクソノミーに所属するタームの一覧（例えばタグの一覧）などを表示するページは Hugo によって自動的に生成されます。 ただし、そのためのレイアウト（テンプレート）ファイルをあらかじめ作成しておく必要があります。 タクソノミー関連の２種類のテンプレート タクソノミー関連のテンプレートには、大きく分けて下記の２種類があります。 タクソノミー・ターム・テンプレート (Taxonomy Terms Template) あるタクソノミーに含まれているタームの一覧を表示するためのレイアウトです。 https://example.com/tags/ といった URL にアクセスしたときに使用されます。 タクソノミー・リスト・テンプレート (Taxonomy List Template) あるタームが付加されているページの一覧を表示するためのレイアウトです。 https://example.com/tags/mytag/ といった URL にアクセスしたときに使用されます。 以下、それぞれのテンプレートをどのように作成するかを説明していきます。 タクソノミー・ターム・テンプレートを作成する タクソノミー・ターム・テンプレートは、あるタクソノミーに所属するタームの一覧 を表示するときに使用されるテンプレートです。 例えば、tags というタクソノミーが定義されている時、このテンプレートによって https://example.com/tags/ という URL でアクセスできるタグ一覧ページが生成されます。 下記のテンプレートファイルのうち、最初に見つかったファイルがタクソノミー・ターム・テンプレートとして使用されます。 /layouts/taxonomy/&lt;単数系のタクソノミー名&gt;.terms.html /layouts/_default/terms.html /themes/&lt;テーマ名&gt;/layouts/taxonomy/&lt;単数系のタクソノミー名&gt;.terms.html /themes/&lt;テーマ名&gt;/layouts/_default/terms.html 全てのタクソノミーで共通のレイアウトを使用するのであれば、まずは layouts/_default/terms.html を作成しておけばよいでしょう。 下記のサンプルテンプレートは、対象のタクソノミーに所属するタームの一覧を表示します。 layouts/_default/terms.html（抜粋） &lt;h1&gt;{{ .Title }}&lt;/h1&gt; &lt;ul&gt; {{- $plural := .Data.Plural }} {{- range $index, $term := .Data.Terms.Alphabetical }} &lt;li&gt;&lt;a href=&#34;{{ $.Site.LanguagePrefix }}/{{ $plural }}/{{ $term.Name | urlize }}&#34;&gt;{{ $term.Name }}&lt;/a&gt; ({{ $term.Count }}) {{- end }} &lt;/ul&gt; ここでは、簡略化のために &lt;head&gt; 要素などの記述を省略していますが、本番環境では、正しく全体の HTML コードを出力するようにしてください。 上記のようなタクソノミー・ターム・テンプレートを配置した後で、http://example.com/tags にアクセスすると、以下のような HTML がレンダリングされます（日本語のタグ名を含む URL は正しくエスケープされます）。 &lt;h1&gt;Tags&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B01&#34;&gt;タグ1&lt;/a&gt; (10) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B02&#34;&gt;タグ2&lt;/a&gt; (7) &lt;li&gt;&lt;a href=&#34;/tags/%E3%82%BF%E3%82%B02&#34;&gt;タグ3&lt;/a&gt; (12) &lt;/ul&gt; ここでは、tags タクソノミーに、「タグ1」「タグ2」「タグ3」というタームが存在していると仮定しています。 各リンクの後ろに表示された数字は、そのタグが付加されているページの数が表示されています。 ☝️ タームの表示順序 前述のテンプレートでは、アルファベット順にターム名を表示しています。 .Data.Terms.Alphabetical という部分を .Data.Terms.ByCount に置き換えると、ページ数の多い順にタグの一覧を表示することができます。 上記のリンクをクリックすると、そのターム（ここではタグ）が設定された記事の一覧ページにジャンプします。 そこで使われるテンプレートが、次に説明するタクソノミー・リスト・テンプレートです。 タクソノミー・リスト・テンプレートを作成する タクソノミー・リスト・テンプレートは、あるタクソノミーの、あるタームが付加されているページの一覧 を表示するときに使用されるテンプレートです。 例えば、tags タクソノミーに、mytag というタームが設定されているページの一覧は、https://example.com/tags/mytag/ という URL で表示できるのですが、そのページを生成するときに使用されます。 下記のテンプレートファイルのうち、最初に見つかったファイルがタクソノミー・リスト・テンプレートとして使用されます。 /layouts/taxonomy/&lt;単数系のタクソノミー名&gt;.html /layouts/_default/taxonomy.html /layouts/_default/list.html /themes/&lt;テーマ名&gt;/layouts/taxonomy/&lt;単数系のタクソノミー名&gt;.html /themes/&lt;テーマ名&gt;/layouts/_default/taxonomy.html /themes/&lt;テーマ名&gt;/layouts/_default/list.html 汎用リストテンプレートである layouts/_default/list.html は、タクソノミー・リスト・テンプレートとしても使用できるのですが、汎用リストテンプレートはホームページやセクションページのレンダリングにも使用されるものです。 セクションの記事一覧ページと、ターム別の記事一覧ページのレイアウトを異なるものにしたい場合は、layouts/_default/taxonomy.html などの専用ファイルとして作成してください。 ここでは、汎用リストテンプレートである layouts/_default/list.html を作成することにします。 layouts/_default/list.html &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{- .Content }} &lt;ul&gt; {{- range .Data.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink}}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; このテンプレートにより、例えば下記のような記事ページ一覧用の HTML ファイルが生成されます。 &lt;h1&gt;Mytag&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/post/page1/&#34;&gt;記事ページ１&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/post/page2/&#34;&gt;記事ページ２&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/post/page3/&#34;&gt;記事ページ３&lt;/a&gt; &lt;/ul&gt; 上記テンプレートも、説明用に簡略化したものなので、本番環境では head 要素などをちゃんと出力してください。"},{url:"/p/mtfmaxr/",title:"Hugo のタクソノミー機能の基本（タグやカテゴリなど）",date:"2017-12-31T00:00:00+09:00",body:"Hugo のタクソノミー機能の基本（タグやカテゴリなど） タクソノミーとターム Hugo では、多くのブログツールや CMS ツールと同様に、各ページに「タグ」や「カテゴリ」といった付加情報を付けてグルーピング（分類）することができます。 このグルーピング（分類）のことを タクソノミー (taxonomy) と呼んでいます。 タクソノミー (taxonomy) グルーピング（分類）のための項目名。 例えば、「タグ」や「カテゴリ」といった分類名自体がタクソノミーです。 Hugo は、デフォルトで tags と categories というタクソノミーが定義されています。 ターム (term) タクソノミーに割り当てる具体的な値。 例えば、あるページのタグとして、「経済」と「日本」という値を割り当てたとすると、「経済」と「日本」のことをタームと呼びます。 タグの一覧ページで表示される個々のタグ名がタームです。 コンテンツ（ページ）にタクソノミー・タームを割り当てる コンテンツにタクソノミーを割り当てるには、記事先頭のフロントマター部分に、タクソノミー名とそこに割り当てるターム配列を記述します。 次の例では、tags: と categories: というところでタクソノミーの設定を行なっています。 content/page.md --- title: &#34;記事のタイトル&#34; date: &#34;2017-12-31&#34; tags: [&#34;タグ1&#34;, &#34;タグ2&#34;] categories: [&#34;カテゴリ1&#34;, &#34;カテゴリ2&#34;] --- この記事では、`tags` タクソノミーとして「タグ1」「タグ2」というターム、 `categories` タクソノミーとして「カテゴリ1」「カテゴリ2」というタームを割り当てています。 Hugo のデフォルトのタクソノミーとして、tags と categories が用意されています。 上記ではそれぞれのタクソノミーに タグ1 や カテゴリ1 といったタームを設定しています。 それぞれのタクソノミーの使い方は自由ですが、 どのタクソノミーにも複数のタームを割り当てることができます。 逆に、「1 種類のタクソノミーには 1 つのタームしか割り当てられない」という設定はできません。 そのような場合は、単純にフロントマターで categories に割り当てるタームを 1 つだけにする、といった運用でカバーします（それよりは、セクションの機能（ディレクトリ階層）で分けた方がよいですね）。 参考までに、1 つのページに複数のカテゴリを割り当ててしまった場合にエラー表示する方法を こちらで紹介しています。 タクソノミータームの一覧ページ コンテンツ（記事ページ）に何らかのタクソノミーを割り当てると、タクソノミーごとのターム一覧ページが自動的に生成されます。 例えば、tags タクソノミーに含まれているタームの一覧ページ（タグの一覧ページ）は、下記のようなアドレスでアクセスできるようになります。 https://example.com/tags/ 同様に、categories タクソノミーに含まれているタームの一覧ページ（カテゴリの一覧ページ）は、下記のようなアドレスでアクセスできます。 https://example.com/categories/ ☝️ ワンポイント これは、つまり、通常の記事ページとして tags.md や categories.md という名前のファイルを作成してしまうと、上記のようなタームの一覧ページにはアクセスできなくなってしまうということを示しています。 このあたりは URL をシンプルに保つためのトレードオフですね。 上記のような一覧ページ（HTML ファイル）は Hugo の仕組みで自動的に生成されますが、デフォルトでは空っぽ（真っ白）の HTML ページが出力されるだけです。 タームの一覧ページを正しくレンダリングするには、専用のテンプレートファイルを作成しておく必要があります。 詳しくは、下記のページを参照してください。 タクソノミー関連のテンプレートを定義する"},{url:"/p/4sxmnfi/",title:"Hugo でセクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages)",date:"2017-12-30T00:00:00+09:00",body:"Hugo でセクションを持たない記事ページ（ルートの記事ページ）の一覧を表示する (.Site.Home.RegularPages) Home ページ直下の記事ページ ＝ セクションを持たないページ ホームページを示す Page オブジェクトの RegularPages プロパティを参照すると、content ディレクトリ直下に置かれた通常ページの一覧 を取得することができます。 つまり、どのセクションにも所属していない記事ページの一覧です。 &lt;h3&gt;セクションを持たない記事ページ一覧（タイトル順）&lt;/h3&gt; &lt;ol&gt; {{ range .Site.Home.RegularPages.ByTitle }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ol&gt; さらに first 関数を組み合わせて使用すれば、最初の 5 件のみに絞り込んで表示することができます。 &lt;h2&gt;セクションを持たない記事ページ一覧（最初の５件）&lt;/h2&gt; &lt;ol&gt; {{ range first 5 .Site.Home.RegularPages.ByTitle }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ol&gt; （コラム）Hugo v0.58.0 より前のバージョンでのやり方 Hugo v0.58.0 より前のバージョンでは、ホームページの Page オブジェクトの .RegularPages が、サイト全体の記事ページを返してしまっていたので、別の方法でセクションに所属していない記事ページを取得する必要がありました。 例えば、$.Site.RegularPages で取得したサイト内の記事ページの一覧（Page 配列）を、where 関数を使ってフィルタすることで、目的の記事ページだけに絞り込んでいました。 &lt;h3&gt;セクションを持たない記事ページ一覧（タイトル順）&lt;/h3&gt; &lt;ol&gt; {{ range (where $.Site.RegularPages &#34;Section&#34; &#34;&#34;).ByTitle }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ol&gt;"},{url:"/p/fprd6w4/",title:"CSS の box-sizing プロパティで width の計算方法を制御する",date:"2017-12-29T00:00:00+09:00",body:"CSS の box-sizing プロパティで width の計算方法を制御する CSS の width プロパティが要素のどの部分の幅を示すかは、box-sizing プロパティの設定によって変化します。 段組などのレイアウトを正しく行うには、box-sizing の考え方を理解しておく必要があります。 content-box 指定と border-box 指定 下記の図は、HTML 要素の width の値が、具体的にどの部分の幅であるかを示しています。 ここでは簡略化のために width の例を示していますが、height も同様です。 box-sizing プロパティのデフォルト値は content-box になっており、簡単に言うと、テキストの描画部分の領域のことを表しています。 デフォルトの状態で、width: 300px; というスタイル指定を行った場合、その 300px にはパディング (padding) 部分や、ボーダー (border) 部分のサイズは含まれません。 つまり、width: 300px; と指定された要素が実際に描画されるときには、それよりも大きなサイズで描画されることになります。 ボーダー領域まで含めたサイズを、width プロパティや height プロパティで指定したいときは、box-sizing プロパティの値を border-box に指定します。 CSS .sample { /* width と height にボーダー領域まで含める */ box-sizing: border-box; } 実際に試してみる 下記のデモは、box-sizing プロパティの値を content-box（デフォルト）と border-box に設定したときの表示の違いを示しています。 分かりやすくするために、ボーダー領域は青色で表示しています。 パディング領域だけに色をつけることはできないため、テキストの周りの微妙な隙間がパディング領域だと思ってください。 図: box-sizing のデモ（別ページで開く） どちらも、width は 300px としていますが、box-sizing: border-box; と指定した場合は、ボーダー領域まで width に含めて計算するようになるため、実際の表示も若干小さくなります。 HTML &lt;div class=&#34;content-box&#34;&gt; box-sizing: &lt;b&gt;content-box&lt;/b&gt;; &lt;/div&gt; &lt;div class=&#34;border-box&#34;&gt; box-sizing: &lt;b&gt;border-box&lt;/b&gt;; &lt;/div&gt; CSS div { width: 300px; height: 100px; margin: 10px; padding: 10px; border: solid 10px #59f; background: #ddd; } div.content-box { box-sizing: content-box; } div.border-box { box-sizing: border-box; } ☝️ ワンポイント ちなみに margin に関しては、width の計算に含まれることはありません。 margin はあくまで 要素の外側 のマージンだと考えましょう。 段組レイアウトでは box-sizing: border-box が便利 ２つ以上のボックスを横に並べて段組レイアウトを行う場合、デフォルトの box-sizing アルゴリズム (content-box) を使用していると、width 値の指定が非常に複雑になります（パディングやボーダーのサイズを考慮して width 値を調整しなければならないため）。 このような場合、横に並べるボックス要素に、box-sizing: border-box; の指定を行っておくと、直感的な width 指定を行うことができます。 図: box-sizing のデモ 2（別ページで開く） CSS &lt;div&gt; &lt;div class=&#34;pane pane-left&#34;&gt;Left (150px)&lt;/div&gt; &lt;div class=&#34;pane pane-right&#34;&gt;Right&lt;/div&gt; &lt;/div&gt; CSS .pane { box-sizing: border-box; height: 100vh; padding: 10px; } .pane-left { float: left; width: 150px; background: #f9c; } .pane-right { margin-left: 150px; background: #9fa; }"},{url:"/p/hbh4dwr/",title:"CSS の rem や em を使用したサイズ指定を理解する",date:"2017-12-28T00:00:00+09:00",body:"CSS の rem や em を使用したサイズ指定を理解する CSS の rem や em といった相対的なサイズ指定方法を理解すると、Web サイト全体のレイアウトの整合性を保ちやすくなります。 rem と em の違い rem や em などのフォントサイズに比例する単位は、W3C の下記のページに詳しく説明されています。 CSS Values and Units Module Level 3 - 5.1.1. Font-relative lengths: the em, ex, ch, rem units rem も em も小文字の m の幅にほぼ等しいサイズを表しますが、下記のように、どの要素のフォントサイズを基準にするかが異なります。 rem (root em) font size of the root element（ルート要素のフォントサイズ） em font size of the element（要素のフォントサイズ） これだけでは分かりにくいので、それぞれの単位の意味を詳しく見てみましょう。 rem の意味 rem はルート要素のフォントサイズを基準にした単位です。 例えば、下記のようなスタイルを考えてみます。 html { font-size: 100%; } p { font-size: 1rem; } h2 { font-size: 1.5rem; } ルートの html 要素でフォントサイズを 100% に設定しているため、ブラウザのデフォルトサイズ（通常は 16px = 12pt）が 1rem となります。 つまり、p 要素は 1rem = 12pt、h2 要素は 1.5rem = 18pt になります。 ただし、ユーザがブラウザ設定で表示フォントサイズを変更している場合は、それに応じて 1rem あたりの実際のサイズが変わってきます。 いずれにしても、全ての要素のフォントサイズを rem を使って指定しておけば、ウェブサイト全体でフォントサイズの整合性を保ちやすくなるでしょう。 em の意味 単位 em の意味は、font-size プロパティに使用するか、それ以外のプロパティに使用するかで意味が異なってきます。 font-size プロパティの値の単位に em を使用すると、親要素の font-size を 1em とした相対サイズ でのフォントサイズ指定が可能です。 例えば、下記のようにすると、p 要素のフォントサイズは、親要素の 1.5 倍のフォントサイズになります。 p { font-size: 1.5em; } font-size 以外のプロパティに em を使用すると、自分自身の font-size を 1em とした相対サイズ での指定になります。 例えば、下記のようにすると、p 要素自身のフォントサイズの 1.5 倍のマージンが設定されます。 p { margin-top: 1.5em; } rem と em の使い道 rem と em は、上記のようにフォントサイズの指定に使用するだけでなく、レイアウト全般に活用することができます。 例えば、次のようにすればメインコンテンツのカラム幅を、ルート要素の文字幅 50 字分 (50rem) に設定することができます。 main { max-width: 50rem; } 次のようにすれば、現在の要素のフォントサイズで 1 文字分 (1em) のインデントを入れることができます。 p { text-indent: 1em; } 次のようにすれば、各ヘッダの上部にヘッダレベルに応じたマージンを入れることができます。 マージン設定の記述は共通ですが、単位に em を使用することで、h2 のマージンの方が h3 のマージンよりも大きくなります（もちろん、h2 の font-size の方が h3 のものより大きいことを前提としています）。 * + h2, * + h3 { margin-top: 1.5em; } 大まかな方針としては、rem はサイト全体の各要素の配置、em は要素内でのインデントやマージン設定などに使用すると考えるとよいでしょう。"},{url:"/p/wvi3n7q/",title:"Hugo でサイトのヘッダーとフッターをパーシャルファイルに分離する",date:"2017-12-27T00:00:00+09:00",body:"Hugo でサイトのヘッダーとフッターをパーシャルファイルに分離する パーシャルテンプレートでページ構成を分割する サイト内で共通のヘッダー部分とフッター部分を Hugo の パーシャルテンプレートファイル として作成しておくと、全てのテンプレートから参照できるため、テンプレートの記述をシンプルにすることができます。 Hugo のテンプレート構成では、下記のような感じでテンプレート前半部分と後半部分をまるごとパーシャルファイルで構成してしまうのが一般的のようです。 図: ヘッダーとフッターをパーシャルテンプレート化 上記ではリストテンプレート (list.html) の例を示していますが、ホームページテンプレート (layouts/index.html) や、セクションテンプレート (layouts/_default/section.html)、シングルページテンプレート (layouts/_default/single.html) などを記述する際も同様に構成します。 つまり、パーシャルファイルとして作成する header.html や footer.html は、どのテンプレートファイルからでも使用できるように、汎用的な記述をしておく必要があります。 layouts/partials/header.html &lt;!DOCTYPE html&gt; &lt;html lang=&#34;{{ .Site.LanguageCode }}&#34;&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width,initial-scale=1.0&#34;&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;/assets/css/main.css&#34;&gt; &lt;title&gt;{{ if not .IsHome }}{{ .Title }} | {{ end }}{{ .Site.Title }}&lt;/title&gt; {{ partial &#34;header-favicon&#34; . }} &lt;/head&gt; &lt;body&gt; layouts/partials/footer.html &lt;/body&gt; &lt;/html&gt; 上記のようなパーシャルテンプレートは、各レイアウト用のテンプレートから次のように使用します。 layouts/_default/list.html {{ partial &#34;header&#34; . }} &lt;main id=&#34;main&#34;&gt; &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ .Content }} &lt;/main&gt; {{ partial &#34;footer&#34; . }} ここでは、リストテンプレート内で使用する方法を示していますが、ホームテンプレートや、シングルページテンプレートなどでも同様に使用できます。 ベーステンプレートの機能を使うのがオススメ 上記では、HTML の前半部分や後半部分をパーシャルテンプレートとして分離する方法を示しましたが、Hugo の仕組みに慣れてきたら、ベーステンプレートの機能 を使って HTML を構成する方法がお勧めです。 参考: ベーステンプレートを作成して、各種テンプレートの基本構成を統一する"},{url:"/p/vczuozw/",title:"Hugo でサイト内の全セクションの一覧を表示する (.Site.Sections)",date:"2017-12-22T00:00:00+09:00",body:"Hugo でサイト内の全セクションの一覧を表示する (.Site.Sections) .Site.Sections を参照すると、サイト内のすべてのセクションページを示す Page 配列を取得することができます。 layouts/index.html &lt;h3&gt;全セクションのリスト&lt;/h3&gt; &lt;ul&gt; {{ range .Site.Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; ここで参照できるセクションページは、第一階層に存在するセクションのみであることに注意してください。 下のようなコンテンツ構造だとすると、.Site.Sections に含まれるのは、★のついたセクションページのみです。 content/ +-- dir1/_index.md ★ | +-- dir1-1/_index.md | +-- dir1-2/_index.md +-- dir2/_index.md ★ +-- dir2-1/_index.md +-- dir2-2/_index.md"},{url:"/p/sgrjpfu/",title:"Hugo でサイト内の全ページの一覧を表示する (.Site.Pages)",date:"2017-12-22T00:00:00+09:00",body:"Hugo でサイト内の全ページの一覧を表示する (.Site.Pages) .Site.Pages を参照すると、サイト内のすべてのページを示す Page 配列を取得することができます。 下記はホームページテンプレート内で、サイト内のすべてのページのリンクを表示する例です。 layouts/index.html &lt;h3&gt;全ページのリスト&lt;/h3&gt; &lt;ul&gt; {{ range .Site.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; .Site.Pages はデフォルトで、日時 (.Date) の一番新しいものから昇順に並べられた Page 配列を返します。 ☝️ ワンポイント .Site.Pages は、現在選択中の言語内でのページ一覧を返します。 全言語を含むページ一覧を取得したいときは、代わりに .Site.AllPages を参照してください。"},{url:"/p/ffr2bku/",title:"Hugo でホームページの Page オブジェクトを取得する",date:"2017-12-22T00:00:00+09:00",body:"Hugo でホームページの Page オブジェクトを取得する Hugo テンプレートの中で、ホームページを表す Page オブジェクトを取得するには次のようにします。 {{ $home := .Site.Home }} {{ printf &#34;%#v&#34; $home }} 公式ドキュメントの .Site 変数のページには書いてないのですが、上記のように簡単にホームページの Page オブジェクトを取得できるみたいです。 2 行目では、取得した Page オブジェクトの内容を出力して確認しています。 GetPage 関数を使用して、Kind パラメータに &quot;home&quot; を指定するというのもありです。 {{ $home := .Site.GetPage &#34;home&#34; }} {{ printf &#34;%v&#34; (eq $home .Site.Home) }} {{/* true になるはず */}} このような取得方法を知るまでは、次のような感じでものすごく面倒な書き方してました。。。 {{ $home := index (where .Site.Pages &#34;URL&#34; &#34;==&#34; &#34;/&#34;) 0 }} まず、where 関数を使い、全ページ (.Site.Pages) 中で URL が / であるものの Page オブジェクトの配列を取得しています。 実際にはホームページは 1 つだけなのですが、where は Page オブジェクトの配列を返すので、index 関数を使って 1 番目の要素だけを取り出しています。 なんて非効率的な（＾＾；"},{url:"/p/8vm6xqm/",title:"Hugo テンプレートで数値によるループ処理を行う (range, seq)",date:"2017-12-22T00:00:00+09:00",body:"Hugo テンプレートで数値によるループ処理を行う (range, seq) Hugo のテンプレート内では、Go 言語のような for を使用した数値ループは記述できません。 代わりに range を使用します。 次の例では、seq 関数 を使用して 1 から 5 の数値シーケンスを作成し、それらを range を使ってループ処理しています。 テンプレート内での記述例 &lt;ul&gt; {{ range $val := seq 5 }} &lt;li&gt;{{ $val }} {{ end }} &lt;/ul&gt; 出力結果 &lt;ul&gt; &lt;li&gt;1 &lt;li&gt;2 &lt;li&gt;3 &lt;li&gt;4 &lt;li&gt;5 &lt;/ul&gt; 戻り値を 2 つの変数で受け取れば、0 始まりのインデックスも同時に得ることができます。 テンプレート内での記述例 &lt;ul&gt; {{ range $index, $val := seq 5 }} &lt;li&gt;{{ $index }} : {{ $val }} {{ end }} &lt;/ul&gt; 出力結果 &lt;ul&gt; &lt;li&gt;0 : 1 &lt;li&gt;1 : 2 &lt;li&gt;2 : 3 &lt;li&gt;3 : 4 &lt;li&gt;4 : 5 &lt;/ul&gt;"},{url:"/p/pgub54h/",title:"Hugo で同一セクション内のページ／セクションの一覧を表示する",date:"2017-12-22T00:00:00+09:00",body:"Hugo で同一セクション内のページ／セクションの一覧を表示する そのセクション内のページ一覧を取得する (.Pages、.RegularPages) リストテンプレートやセクションテンプレートの中で、.Pages を参照すると、そのセクション（やタクソノミー）直下の記事ページ (regular page) とセクションページ (list page) の一覧を Page オブジェクトの配列として取得することができます。 layouts/_default/section.html &lt;h3&gt;セクションに含まれる記事ページ（あるいはセクションページ）の一覧&lt;/h3&gt; &lt;ul&gt; {{ range .Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; 記事ページ (regular page) のみを列挙したい場合は、.Pages の部分を .RegularPages に変更してください。 逆に、セクションページ (list page) のみを列挙したい場合は、.Pages の部分を Sections に変更してください。 .Pages &hellip; セクションページと記事ページの一覧 .RegularPages &hellip; 記事ページの一覧 .Sections &hellip; セクションページの一覧 上記のようなテンプレートは、タクソノミーテンプレート（タグの一覧ページ）でも同様に使用することができます。 ただし、.Pages や .RegularPages は、リスト系のページから参照することが想定されているため、シングルページテンプレート内で参照すると、サイズ 0 の配列 が返されることに注意してください。 そのため、基本的には上記のコードはリスト系のテンプレートでのみ使用することができます。 シングルページテンプレートからも、同一セクション内のページの一覧を取得したい場合は、まず .CurrentSection でカレントセクションを示す Page オブジェクトを取得するとよいでしょう（下記参照)。 同一セクション内のページ一覧を取得する (.CurrentSection.Pages) 下記のテンプレートコードは、現在の記事ページ（あるいはセクションページ）が所属するセクションの直下のページ（記事ページおよびセクションページ）の一覧を表示します。 例えば、ホームページを含むトップレベルの階層に置いた記事で実行された場合は、第一階層にあるセクションおよび記事ページの一覧が表示されます。 何らかのセクション内の記事で実行された場合は、その記事が所属するセクション内のサブセクションおよび記事ページの一覧が表示されます。 layouts/_default/single.html など &lt;h3&gt;同じセクション内のページ一覧（セクションページを含む）&lt;/h3&gt; {{ with .CurrentSection }} &lt;ul&gt; {{ range .Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; {{ end }} .Pages 変数はリスト系ページ（セクションページなど）の Page オブジェクトにしか要素が格納されない（記事ページでは空配列）になってしまうので、まずは自分自身の記事ページが所属するセクションに対応する Page オブジェクトを、.CurrentSection で取得してから処理を行うようにしています。 先に説明したのと同様、記事ページのみを列挙したい場合は .Pages の代わりに .RegularPages を、セクションページのみを列挙したい場合は .Pages の代わりに .Sections を参照してください。 このコードは、シングルページテンプレートからも、リストテンプレートからも使用できます。 参考: Hugo | Page Variables a collection of associated pages. This value will be nil for regular content pages. .Pages is an alias for .Data.Pages. 参考: hugo/page.go at master · gohugoio/hugo · GitHub Since Hugo 0.18 we got rid of the Node type. So now all pages are pages (regular pages, home page, sections etc.). Sections etc. will have child pages. These were earlier placed in .Data.Pages, but can now be more intuitively also be fetched directly from .Pages. This collection will be nil for regular pages. （コラム）ホームページでの .Pages 変数の振る舞いについて （下記は Hugo v0.58.0 より前のバージョンの記事です） Hugo v0.58.0 で、ホームページにおける .Pages 変数、.RegularPages 変数の振る舞いが、他のセクションページと同じになりました（そのセクション直下のページだけ返す）。 なので、v0.58.0 以降を使用する場合は、下記の対応は必要ありません。 参考: Hugo v0.58.0 Release Note home.Pages now behaves like all the other sections, see #6240. If you want to list all the regular pages, use .Site.RegularPages. ホームページテンプレートとセクションテンプレートでの .Pages の振る舞いの違い ホームページテンプレート (layouts/index.html) 内で .Pages を参照すると、サイト内のすべてのページ の Page 配列が返されるのですが、セクションテンプレート (layouts/_default/section.html) 内で .Pages を参照すると、その セクション直下にあるページ のみの Page 配列が返されるという違いがあるようです。 テンプレート内で .Pages 変数を参照するときは、そのテンプレートがホームページテンプレートと、セクションテンプレートのどちらのコンテキストで使用されるかを意識して扱い方を変える必要があります。 特に、layouts/_default/list.html のような、ホームページテンプレートとしても、セクションテンプレートとしても使用されるファイルを作成する場合には注意してください。 次の節では、この点を考慮して、カレントセクション直下に配置されたページのみのリストを取得する方法を示します。 同一セクションの直下の記事ページのリストを表示する 下記のテンプレートコードは、現在のページが所属するセクションの直下に配置された記事ページのリストを表示します。 layouts/partials/subpages.html {{- $sec := .CurrentSection }} {{- if $sec }} {{- if $sec.IsHome }} {{ .Scratch.Set &#34;pages&#34; (where $.Site.RegularPages &#34;Section&#34; &#34;&#34;) }} {{- else }} {{ .Scratch.Set &#34;pages&#34; $sec.Pages }} {{- end }} {{- end }} &lt;h3&gt;同じセクション内の記事ページ一覧&lt;/h3&gt; &lt;ul&gt; {{- range (.Scratch.Get &#34;pages&#34;) }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; 例えば、mysection セクションに所属する記事ページのテンプレートで上記のコードが実行されると、同じ mysection セクションに所属する記事ページのリストが表示されます。 また、ホームページを含む、トップレベル（content ディレクトリ直下）に配置したページ内で実行した場合は、トップレベルに配置した記事ページのリストが表示されます。 つまり、上記のパーシャルテンプレートは、下記のような様々なテンプレートファイル内から同様に使用することができます。 ホームページテンプレート (layouts/index.html) セクションテンプレート (layouts/_default/section.html) 汎用リストテンプレート (layouts/_default/list.html) {{ partial &#34;subpages&#34; . }} テンプレートコードが若干複雑になっているのは、.Pages の振る舞いがコンテキストによって変わってくることが影響しています。 セクションページ内では、単純に .Pages を参照すれば、セクション直下の記事ページ一覧を取得できるのですが、ホームページで .Pages を参照すると、サイト内のすべてのページが含まれてしまいます。 そこで、現在のページがトップレベルの階層の記事である場合は、ちょっと特殊な方法、セクションを持たない記事の一覧を取得する (where $.Site.RegularPages &quot;Section&quot; &quot;&quot;) といった回りくどいことを行っています。 ちなみに、前半部分は次のようにセクション名 (.Section) の有無で分岐するように書けそうですが、このような記述はタクソノミーテンプレートのコンテキストではエラーになってしまいます。 なぜなら、https://example.com/tags/tag1/ のようなタグページにアクセスした場合に、セクション名 (.Section) に tags という文字列が格納されるのにもかかわらず、.CurrentSection の値は nil になってしまうからです（.CurrentSection の nil dereference エラーが発生する）。 {{/* カレントセクション直下の記事ページ一覧を &#34;pages&#34; スクラッチに格納 */}} {{- if .Section }} {{ .Scratch.Set &#34;pages&#34; .CurrentSection.Pages }} {{- else }} {{ .Scratch.Set &#34;pages&#34; (where $.Site.RegularPages &#34;Section&#34; &#34;&#34;) }} {{- end }} このような記述をするのであれば、全体を {{ if nq .Kind &quot;taxonomy&quot; }} 〜 {{ end }} のように囲んで、タクソノミーテンプレートのコンテキストでは実行されないようにしておくべきでしょう。 そうすると、結局のところ、最初の例とあまりコード量は変わらなくなります。 あと、$pages 変数のようなものを作成せずに、わざわざ .Scratch.Set を使ってスクラッチ領域にページリストを保存しているのは、Go テンプレートの構文で、変数の条件代入を行ううまい方法が用意されていないからです。 このあたりの話は、こちらの Hugo のサイトで議論されています。 スクラッチ領域 (.Scratch) を使用するのが気持ち悪いという場合は、下記のように、define による部分テンプレートを定義してしまえば、変数を用意しなくてすみますね。 {{- define &#34;showPageList&#34; }} &lt;h3&gt;同じセクション内の記事ページ一覧&lt;/h3&gt; &lt;ul&gt; {{- range . }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; {{- end }} {{- with $sec := .CurrentSection }} {{- if $sec.IsHome }} {{ template &#34;showPageList&#34; (where $.Site.RegularPages &#34;Section&#34; &#34;&#34;) }} {{- else }} {{ template &#34;showPageList&#34; $sec.Pages }} {{- end }} {{- end }} 条件代入は cond 関数でスッキリかける！？（2017-12-30 追記） Hugo v0.27 で、三項演算子のようなことが実現できる cond 関数が追加されました（参考: Ternary operator-like function · Issue #3860 · gohugoio/hugo · GitHub）。 まだ公式ドキュエントには cond 関数の記載がないようですが、下記のように使用できます。 {{ $変数 := (cond (条件式) 真の場合の値 偽の場合の値) }} これで回りくどい .Scratch イディオムを使用しなくて済む！やったー！(^o^)/ と思って、下記のように書いてみました。 &lt;h3&gt;同じセクション内の記事ページ一覧&lt;/h3&gt; &lt;ul&gt; {{- $pages := (cond (eq .Section &#34;&#34;) (where $.Site.RegularPages &#34;Section&#34; &#34;&#34;) .CurrentSection.RegularPages) }} {{- range $pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{- end }} &lt;/ul&gt; がしかし！ cond 関数を使用して上記のように記述すると、条件式が真と判定される場合も、後ろの .CurrentSection.Pages の部分が評価されてしまうようです（値が実際に使われなくても実行される）。 .CurrentSection は nil になるケースがあるので、そのようなコンテキストで実行された場合にエラーになってしまいます。 Go の並列実行の都合なのだと思いますが、惜しい！"},{url:"/p/bdox8hr/",title:"Web サイトに favicon を設定する",date:"2017-12-18T00:00:00+09:00",body:"Web サイトに favicon を設定する favicon の基本 Web サイトの favicon は、Web ブラウザのタブのアイコンや、ブックマークのアイコンとして使用されます。 favicon 用の画像は、PNG、ICO、GIF のいずれかのフォーマットで作成します（PNG 形式が推奨）。 favicon のパスは、HTML の head 要素内で下記のように指定します。 ルートからの相対 URL で指定する場合 &lt;link rel=&#34;icon&#34; href=&#34;/favicon.ico&#34; /&gt; ドメインを含めた URL で指定する場合 &lt;link rel=&#34;icon&#34; href=&#34;https://example.com/favicon.ico&#34; /&gt; ICO ファイルは複数のサイズのアイコンを含むことができるので、どのようなサイズを含めておくべきか迷うところですが、Microsoft は下記のようなサイズで作ることを推奨しています。 16 x 16 24 x 24 32 x 32 48 x 48 64 x 64 X-Icon Editor のサイト を使用すると、Web ブラウザ上で複数サイズのアイコンを含む ICO ファイルを作成することができます。 PNG ファイルで favicon を用意する方法 ICO 形式は古いフォーマットのため、現在では PNG 形式のファイルで favicon を作成するのが一般的 です。 PNG ファイルは、ICO ファイルと異なり、複数サイズのアイコンを含むことができないので、特定のサイズに最適されたアイコンを用意する場合は、複数の PNG ファイルとして作成しておく必要があります。 link 要素の type 属性、sizes 属性を使用すると、クライアントに対して、favicon に関する付加的な情報を与えることができます。 PNG フォーマットで favicon ファイルを用意する場合は、下記のように属性指定を行い、サイズ別にどのファイルを使用するか明示しておくとよいでしょう。 &lt;link rel=&#34;icon&#34; type=&#34;image/png&#34; href=&#34;/favicon-16x16.png&#34; sizes=&#34;16x16&#34; /&gt; &lt;link rel=&#34;icon&#34; type=&#34;image/png&#34; href=&#34;/favicon-32x32.png&#34; sizes=&#34;32x32&#34; /&gt; &lt;link rel=&#34;icon&#34; type=&#34;image/png&#34; href=&#34;/favicon-96x96.png&#34; sizes=&#34;96x96&#34; /&gt; 上記で指定した PNG ファイルのうち、複数のファイルが適用可能な場合は、最後に宣言されたものが選択されることが一般的なため、上記のように 解像度の低いものから順番に指定する ようにしましょう。 sizes 属性には複数のサイズを指定することができるため、下記のように同一のアイコンで複数サイズの表示に対応させることもできます（この場合、きれいに拡大・縮小されて表示されるかどうかはクライアントの実装依存になります）。 &lt;link rel=&#34;icon&#34; type=&#34;image/png&#34; href=&#34;/favicon.png&#34; sizes=&#34;16x16 24x24 32x32 48x48 64x64&#34; /&gt; スマホ（Android、iPhone）用の高解像度アイコンの指定 Android や iPhone などのスマホ、Windows 10、Android TV（旧: Google TV）のような様々なデバイスでは、より高解像度なアイコンを表示するようになってきています。 これらのアイコンは Web サイトの顔（エントリポイント）となるものですから、できるだけ最適なサイズで用意しておくとよいでしょう。 例えば、iOS version 8 までの全ての Apple Touch icon サイズに対応するのであれば、下記のようなサイズのアイコンを用意しておく必要があります。 &lt;!-- Android &amp; iPhone --&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;57x57&#34; href=&#34;/asset/favicon/apple-touch-icon-57x57.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;60x60&#34; href=&#34;/asset/favicon/apple-touch-icon-60x60.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;72x72&#34; href=&#34;/asset/favicon/apple-touch-icon-72x72.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;76x76&#34; href=&#34;/asset/favicon/apple-touch-icon-76x76.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;114x114&#34; href=&#34;/asset/favicon/apple-touch-icon-114x114.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;120x120&#34; href=&#34;/asset/favicon/apple-touch-icon-120x120.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;144x144&#34; href=&#34;/asset/favicon/apple-touch-icon-144x144.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;152x152&#34; href=&#34;/asset/favicon/apple-touch-icon-152x152.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; sizes=&#34;180x180&#34; href=&#34;/asset/favicon/apple-touch-icon-180x180.png&#34; /&gt; 最低限どのようなアイコンファイルを用意しておくべき？ デバイスごとに最適なサイズのアイコンは、多種多様なため、すべてのサイズのアイコンを用意するのは大変です。 てっとり早く、ある程度きれいな表示を行いたいのであれば、とりあえずは下記のサイズのアイコンを用意しておけばよいでしょう。 32x32 の PNG アイコン（favicon 用） 152x152 の PNG アイコン（Apple Touch icon 用） HTML 内では下記のように指定します。 &lt;head&gt; ... &lt;link rel=&#34;icon&#34; type=&#34;image/png&#34; href=&#34;/asset/favicon/favicon-32x32.png&#34; /&gt; &lt;link rel=&#34;apple-touch-icon&#34; href=&#34;/asset/favicon/apple-touch-icon-152x152.png&#34;&gt; ... &lt;/head&gt; ルートに favicon.ico を置く方法 HTML ファイルの link 要素で favicon の URL を指定する方法が推奨されていますが、Web サイトのルートに /favicon.ico を置くことでも favicon を認識させることができます。 shortcut icon という指定はダメ IE8 以前は、link 要素に下記のように rel 属性として shortcut icon を指定していましたが、これは非標準な指定方法なので、rel 属性は icon とだけ指定するようにしましょう。 間違った指定方法 &lt;link rel=&#34;shortcut icon&#34; href=&#34;/path/favicon.ico&#34;&gt; link 要素の rel 属性に指定可能な値の一覧は下記にまとまっています。 Link types - HTML｜MDN icon の説明欄に、shortcut という指定が間違いであることが示されています。 icon より以前はリンクタイプ shortcut がよく使用されていましたが、これは非準拠で無視されますので Web 作者は今後使用してはいけません。 どうしても、IE8 以下のバージョンにも対応したいのであれば、下記のように IE 用の条件分岐を使用してファイルを指定しておくのがよいでしょう。 &lt;link rel=&#34;icon&#34; href=&#34;/asset/favicon.ico&#34;/&gt; &lt;!--[if IE]&gt; &lt;link rel=&#34;shortcut icon&#34; href=&#34;/asset/favicon.ico&#34;/&gt; &lt;![endif]--&gt; 参考になるサイト favicon の説明 Favicons, Touch Icons, Tile Icons, etc. Which Do You Need? ｜ CSS-Tricks All About Favicons (And Touch Icons) favicon 作成サイト 様々なファビコンを一括生成。favicon generator"},{url:"/p/yhqogz6/",title:"Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range)",date:"2017-12-16T00:00:00+09:00",body:"Hugo テンプレート内でマップ（辞書）変数を扱う (dict, index, range) Hugo テンプレート内で辞書変数を定義すると、キーと値のマップ情報を管理することができます。 マップを定義する (dict) dict 関数 のパラメータに、キーと値のペアを並べていくと、マップ変数を作成することができます。 下記の例では、3 つのキー＆値を持つマップを定義して、その内容を出力しています。 テンプレート内でのマップ定義例 {{ $d := dict &#34;key1&#34; 100 &#34;key2&#34; 200 &#34;key3&#34; 300 }} {{ printf &#34;%#v&#34; $d }} 実行結果 map[string]interface {}{&#34;key1&#34;:100, &#34;key2&#34;:200, &#34;key3&#34;:300} ☝️ ワンポイント 関数名が dict なので、「辞書」と訳したほうがよいのかもしれませんが、内部的には Go の map オブジェクトなので、ここでは「マップ」と呼ぶことにします。 Go のテンプレート内で使用できる文法は、Go 言語の文法とは異なっています。 Go 言語でマップを定義する ときは map を使用しますが、Hugo のテンプレート内でマップ（辞書）を定義するときは dict 関数を使用しなければいけないことに注意してください。 マップの要素を参照する (index) マップ変数の後ろに、ドットで繋げてキー名を指定すると、そのキーに対応する要素の値を参照することができます（存在しないキーを指定した場合は何も出力されません）。 テンプレート内での記述例 {{ $d := dict &#34;key1&#34; 100 &#34;key2&#34; 200 &#34;key3&#34; 300 }} &lt;ul&gt; &lt;li&gt;{{ $d.key1 }} &lt;li&gt;{{ $d.key2 }} &lt;li&gt;{{ $d.key3 }} &lt;/ul&gt; 実行結果 &lt;ul&gt; &lt;li&gt;100 &lt;li&gt;200 &lt;li&gt;300 &lt;/ul&gt; ただし、このようにドットを使ってキーを指定する方法は、キー名がアルファベット（やアンダースコア）で始まっている場合にしか使用できません。 より汎用的なキー（数字始まりなど）を使用して、マップ内の要素を参照するには、index 関数 を使用します。 テンプレート内での記述例 {{ $d := dict &#34;123&#34; 100 &#34;-a-&#34; 200 &#34;$foo&#34; 300 }} &lt;ul&gt; &lt;li&gt;{{ index $d &#34;123&#34; }} &lt;li&gt;{{ index $d &#34;-a-&#34; }} &lt;li&gt;{{ index $d &#34;$foo&#34; }} &lt;/ul&gt; ☝️ ワンポイント index 関数は、配列（スライス）変数内の要素を参照するときにも使用します（例: {{ index $arr 0 }}）。違いは、第 2 引数が文字列か数値かだけです。 マップをループで処理する (range) マップ内のすべての要素を、range を使ってループ処理することができます。 次の例では、マップ内のキーと値を順番に取り出しています。 テンプレート内での記述例 {{ $d := dict &#34;key1&#34; 100 &#34;key2&#34; 200 &#34;key3&#34; 300 }} &lt;ul&gt; {{- range $key, $val := $d }} &lt;li&gt;{{ $key }} = {{ $val }} {{- end }} &lt;/ul&gt; 実行結果 &lt;ul&gt; &lt;li&gt;key1 = 100 &lt;li&gt;key2 = 200 &lt;li&gt;key3 = 300 &lt;/ul&gt; あまり使い道はないかもしれませんが、次のようにキー用の変数を省略して記述すると、値だけを取り出しながらループ処理することができます。 {{ $d := dict &#34;key1&#34; 100 &#34;key2&#34; 200 &#34;key3&#34; 300 }} &lt;ul&gt; {{- range $val := $d }} &lt;li&gt;{{ $val }} {{- end }} &lt;/ul&gt; マップをパーシャルテンプレートの引数として渡す Hugo の本家サイトには、下記のようなパーシャルテンプレートのパラメータとしてマップを受け取る例が掲載されています（本家のコードは細かい間違いが多いので若干修正してます）。 このパーシャルテンプレートは、指定された色、サイズで外部リンクアイコンを表示します。 layouts/partials/svgs/link-ext.svg &lt;svg version=&#34;1.1&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; xmlns:xlink=&#34;http://www.w3.org/1999/xlink&#34; fill=&#34;{{ .fill }}&#34; width=&#34;{{ .size }}&#34; height=&#34;{{ .size }}&#34; viewBox=&#34;0 0 32 32&#34; aria-label=&#34;External Link&#34;&gt; &lt;path d=&#34;M25.152 16.576v5.696q0 2.144-1.504 3.648t-3.648 1.504h-14.848q-2.144 0-3.648-1.504t-1.504-3.648v-14.848q0-2.112 1.504-3.616t3.648-1.536h12.576q0.224 0 0.384 0.16t0.16 0.416v1.152q0 0.256-0.16 0.416t-0.384 0.16h-12.576q-1.184 0-2.016 0.832t-0.864 2.016v14.848q0 1.184 0.864 2.016t2.016 0.864h14.848q1.184 0 2.016-0.864t0.832-2.016v-5.696q0-0.256 0.16-0.416t0.416-0.16h1.152q0.256 0 0.416 0.16t0.16 0.416zM32 1.152v9.12q0 0.48-0.352 0.8t-0.8 0.352-0.8-0.352l-3.136-3.136-11.648 11.648q-0.16 0.192-0.416 0.192t-0.384-0.192l-2.048-2.048q-0.192-0.16-0.192-0.384t0.192-0.416l11.648-11.648-3.136-3.136q-0.352-0.352-0.352-0.8t0.352-0.8 0.8-0.352h9.12q0.48 0 0.8 0.352t0.352 0.8z&#34;&gt;&lt;/path&gt; &lt;/svg&gt; パーシャルテンプレートに渡されたマップの要素は、下記のようにキーを指定することで参照することができます。 {{ .fill }} このパーシャルテンプレートを使用するテンプレート側では、下記のように記述します。 layouts/_default/list.html {{ partial &#34;svgs/link-ext.svg&#34; (dict &#34;fill&#34; &#34;#01589B&#34; &#34;size&#34; 20) }} パーシャルテンプレートはこんな感じで SVG 画像を生成するのにも利用できるんですね。"},{url:"/p/y39gzkc/",title:"Hugo テンプレート内で変数を扱う",date:"2017-12-15T00:00:00+09:00",body:"Hugo テンプレート内で変数を扱う Hugo テンプレート内で変数を定義するときは、変数名のプレフィックスとして $ を付けます。 変数定義の基本 Hugo テンプレート内で変数を定義するには、下記のような構文を使用します。 = ではなくて、:= を使用することに注意してください。 {{ $変数名 := 初期値 }} 上記の構文から分かるように、独自の変数を定義する場合は、変数名のプレフィックスとして $ を付けます。 ☝️ ワンポイント より正確に言うと、上記のように $ で始まるようにアクションを記述すると、それが変数定義のためのアクションだと見なされるということです。 次の例では、数値変数 $x と、文字列変数 $y を定義し、それらの値を出力しています。 変数定義のアクションを実行しただけでは、その変数の値は出力されないので、変数出力のためのアクションを続けて記述しています（下の例では {{ $x }} や {{ $y }} という部分）。 テンプレート内での記述例 {{ $x := 100 }} &lt;p&gt;{{ $x }}&lt;/p&gt; {{ $y := &#34;Hello&#34; }} &lt;p&gt;{{ $y }}&lt;/p&gt; 出力結果 &lt;p&gt;100&lt;/p&gt; &lt;p&gt;Hello&lt;/p&gt; 処理結果を変数に格納する ある値をパイプで関数に渡して、処理を行った結果を変数に格納する、といったこともできます。 次の例では、文字列 maku を printf 関数に渡し、その結果をさらに printf 関数に渡しています。 変数 $x には、その最終的な結果が格納されます。 テンプレート内での記述例 {{ $x := &#34;maku&#34; | printf &#34;Hello %s.&#34; | printf &#34;%s What&#39;s up?&#34; }} &lt;p&gt;{{ $x }}&lt;/p&gt; 出力結果 &lt;p&gt;Hello maku. What&#39;s up?&lt;/p&gt; 上記では、文字列 maku をパイプで printf 関数に渡していますが、次のように printf 関数のパラメータとして指定することもできます。 {{ $x := printf &#34;%s What&#39;s up?&#34; (printf &#34;Hello %s.&#34; &#34;maku&#34;) }} &lt;p&gt;{{ $x }}&lt;/p&gt; どちらの方法でも結果は同じですが、上記のように 1 つの値を連続して変換していくようなケースでは、パイプを使って記述したほうが読みやすいように感じます。 ☝️ ワンポイント パイプ (|) を使用して処理を繋げると、パイプの前に記述した処理結果が、後ろの関数の 最後のパラメータ として渡されます。 range アクションでの変数の使用 range アクションによって配列をループ処理する場合は、各要素の値を変数に取り出しながら処理することができます。 &lt;h3&gt;ページ一覧&lt;/h3&gt; &lt;ul&gt; {{ range $page := .Site.AllPages }} &lt;li&gt;&lt;a href=&#34;{{ $page.RelPermalink }}&#34;&gt;{{ $page.Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; ただし、上記のように要素の値のみを取り出す場合は、デフォルトのドット (.) のコンテキストを置き換えて下記のようにループ処理する方が簡潔に記述できます。 &lt;h3&gt;ページ一覧&lt;/h3&gt; &lt;ul&gt; {{ range .Site.AllPages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; 次のように、2 つの変数を用意することで、インデックス（0 始まり）を取得しながらループ処理することもできます。 &lt;h3&gt;ページ一覧&lt;/h3&gt; &lt;ul&gt; {{ range $index, $page := .Site.AllPages }} &lt;li&gt;&lt;a href=&#34;{{ $page.RelPermalink }}&#34;&gt;{{ printf &#34;%d: %s&#34; (add $index 1) $page.Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; &lt;ul&gt; じゃなくて &lt;ol&gt; で表示すればいいじゃん、というツッコミはなしで（＾＾； with アクションでの変数の使用 with アクションで変数スコープを制限する場合にも、変数を使用することができます。 {{ with $x := &#34;maku&#34; }} Hello {{ $x }} {{ end }} 上記のようにすると、with ～ end のブロックの外からは、変数 $x は参照できなくなります。"},{url:"/p/7bvjywy/",title:"Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range)",date:"2017-12-15T00:00:00+09:00",body:"Hugo テンプレート内で配列（スライス）変数を扱う (slice, index, range) Hugo テンプレートの中で slice 関数を使用すると、渡されたパラメータ群から新しいスライス（配列）を作成することができます。 配列（スライス）を定義する (slice) Hugo テンプレートでは、新しくスライス（配列）を定義するための構文は用意されていないため、そのような場合はスライス（配列）を戻り値として返す slice 関数 を使用する必要があります。 下記の例では、slice 関数に 3 つのパラメータを渡し、それらの要素からなるスライスを生成しています。 テンプレート内での記述例 {{ $arr := slice &#34;AAA&#34; &#34;BBB&#34; &#34;CCC&#34; }} {{ printf &#34;%#v&#34; $arr }} 実行結果 []interface {}{&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;} ☝️ ワンポイント Go のテンプレート内で使用できる文法は、Go 言語の文法とは異なっています。 スライスを定義するときに、Go 言語と同じ構文で、$arr := []string{&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;} と記述することはできないことに注意してください。 配列（スライス）の要素を参照する (index) インデックス番号指定で配列（スライス）内の要素を参照するには、index 関数 を使用します。 この書き方は、慣れるまでは若干わかりにくいかもしれません。 テンプレート内での記述例 {{ $arr := slice &#34;AAA&#34; &#34;BBB&#34; &#34;CCC&#34; }} &lt;ul&gt; &lt;li&gt;{{ index $arr 0 }} &lt;li&gt;{{ index $arr 1 }} &lt;li&gt;{{ index $arr 2 }} &lt;/ul&gt; 実行結果 &lt;ul&gt; &lt;li&gt;AAA &lt;li&gt;BBB &lt;li&gt;CCC &lt;/ul&gt; 配列（スライス）をループで処理する (range) 配列の全要素をループで処理したい場合は、range を使って以下のように記述します。 テンプレート内での記述例 {{ $arr := slice &#34;AAA&#34; &#34;BBB&#34; &#34;CCC&#34; }} &lt;ul&gt; {{- range $arr }} &lt;li&gt;{{ . }} {{- end }} &lt;/ul&gt; 実行結果 &lt;ul&gt; &lt;li&gt;AAA &lt;li&gt;BBB &lt;li&gt;CCC &lt;/ul&gt; 上記の例ではドットコンテキストを置き換えて、各要素をドット (.) で参照するようにしていますが、次のように変数名を付けてアクセスすることもできます。 テンプレート内での記述例 {{ $arr := slice &#34;AAA&#34; &#34;BBB&#34; &#34;CCC&#34; }} &lt;ul&gt; {{- range $val := $arr }} &lt;li&gt;{{ $val }} {{- end }} &lt;/ul&gt; ☝️ ワンポイント range を使ってループ処理をするときに、ループ用の変数を明示的に割り当てても、結局ドットコンテキストの方は置き換えられてしまうようなので、この書き方はあまり意味がないかもしれません。 range で配列をループ処理するときに、下記のように 2 つの変数を指定すると、配列のインデックス番号を取得しながらループ処理することができます。 テンプレート内での記述例 {{ $arr := slice &#34;AAA&#34; &#34;BBB&#34; &#34;CCC&#34; }} &lt;ul&gt; {{- range $index, $val := $arr }} &lt;li&gt;{{ $index }} : {{ $val }} {{- end }} &lt;/ul&gt; 実行結果 &lt;ul&gt; &lt;li&gt;0 : AAA &lt;li&gt;1 : BBB &lt;li&gt;2 : CCC &lt;/ul&gt;"},{url:"/p/5zwytgx/",title:"Hugo テンプレート内にコメントを記述する",date:"2017-12-15T00:00:00+09:00",body:"Hugo テンプレート内にコメントを記述する Hugo のテンプレートファイル内では、C/C++ や Java に似た形式（/* と */）でコメントを記述することができます。 コメントとして記述した部分は、HTML ファイルに出力するときに削除されます。 {{/* a comment */}} 複数行にまたがるコメントを記述することもできます。 {{/* comment comment comment */}}"},{url:"/p/ewoqwrk/",title:"Hugo テンプレート内で if や with で分岐処理する",date:"2017-12-11T00:00:00+09:00",body:"Hugo テンプレート内で if や with で分岐処理する Hugo テンプレートの中で、if アクションや with アクションを使用することで、分岐処理を行うことができます。 if による分岐処理 if の構文 Hugo のテンプレート内で分岐処理を行うには、下記のように if ~ end を使用します。 必要に応じて、else や else if を挟むことができます。 {{ if ● }} ... {{ end }} {{ if ● }} ... {{ else }} ... {{ end }} {{ if ● }} ... {{ else if ▲ }} ... {{ end }} {{ if ● }} ... {{ else if ▲ }} ... {{ else }} ... {{ end }} {{ と }} で囲まれた部分は、Go のテンプレートでは アクション と呼ばれている部分で、基本的に 1 つのアクションだけを記述することができます（関数をパイプで結んだりすることはできる）。 if による条件式を記述する部分と、end でブロックを閉じる部分は、上記のように分けて記述する必要があるため、若干まわりくどくなってしまうケースがあるかもしれませんが、そこは我慢するしかありません。 if の条件式（上記の ● の部分）において「偽」とみなされる値は、空値 (empty value) です。 空値となるのは下記のような値です。 false 0 とみなされる数値（0.0 も含む） サイズ 0 の配列、スライス、マップ 空文字列 (&quot;&quot;) nil ポインタ 真とみなされる例（T と表示される） {{ if true }} T {{ else }} F {{ end }} {{ if &#34;ABC&#34; }} T {{ else }} F {{ end }} {{ if 1 }} T {{ else }} F {{ end }} {{ if -1 }} T {{ else }} F {{ end }} 偽とみなされる例（F と表示される） {{ if false }} T {{ else }} F {{ end }} {{ if &#34;&#34; }} T {{ else }} F {{ end }} {{ if 0 }} T {{ else }} F {{ end }} {{ if 0.0 }} T {{ else }} F {{ end }} 条件式の部分で、値の比較を行いたい場合は、下記のような eq や ne といった二値関数 (boolean functions) を使用します。 比較する 2 つの値は、後ろに続けて記述することに注意してください。 記述方法 いつ真とみなすか？ リファレンス eq ARG1 ARG2 ARG1 ＝ ARG2 のとき eq 関数 ne ARG1 ARG2 ARG1 ≠ ARG2 のとき ne 関数 lt ARG1 ARG2 ARG1 ＜ ARG2 のとき lt 関数 le ARG1 ARG2 ARG1 ≦ ARG2 のとき le 関数 gt ARG1 ARG2 ARG1 ＞ ARG2 のとき gt 関数 ge ARG1 ARG2 ARG1 ≧ ARG2 のとき ge 関数 if の使用例 次の例では、数値変数の値が 100 より大きいかを、gt 関数を使用して調べています。 変数 $x の値が 100 より大きいか調べる {{ $x := 200 }} {{ if gt $x 100 }} x is greater than 100 {{ end }} 文字列変数の比較 にも eq（等しい）や ne（等しくない）を使用することができます。 変数 $s の値が hello かどうか調べる {{ $s := &#34;hello&#34; }} {{ if eq $s &#34;hello&#34; }} s is hello {{ end }} with による分岐処理 with の構文 if アクションの代わりに、with アクションを使用して分岐処理を記述すると、ブロックの中のコンテキスト（ドット .）を、条件式で評価した値に置き換えることができます。 {{ with ● }} ... {{ end }} {{ with ● }} ... {{ else }} ... {{ end }} 使い方は、例を見たほうが分かりやすいかもしれません。 次の例では、with アクションの条件式で Maku という文字列が指定されているため、ブロックの中でドット (.) を参照することで、Maku という文字列を取得することができます。 テンプレート内で with アクションを利用する {{ with &#34;Maku&#34; }} {{ printf &#34;I am %s&#34; . }} {{ end }} 実行結果 I am Maku 通常、ドット (.) はトップレベルのコンテキスト（Hugo のレイアウトファイルの中では通常 Page オブジェクト）を表しますが、上記のように with アクションを使用することで、コンテキストを切り替えて、ブロック内の記述をシンプルにすることができます。 逆に、with ブロックでコンテキストを切り替えた後に、トップレベルのコンテキストを明示的に参照したい場合は、次のように $ プレフィックスを指定して参照します。 with ブロックの中からトップレベルコンテキストを参照する {{ with &#34;Maku&#34; }} {{ printf &#34;Hello, %s. Page title is %s&#34; . $.Title }} {{ end }} 実行結果 Hello, Maku. Page title is SAMPLE_TITLE. with の使用例 下記のサンプルコードは、Web サイトの設定ファイル (config.toml) に、サイトの説明文や作者が設定されている場合に、それを meta 要素として出力する例です。 テンプレート内での記述例 {{ with .Site.Params.author -}} &lt;meta name=&#34;author&#34; content=&#34;{{ . }}&#34;&gt; {{- end }} {{ with .Site.Params.description -}} &lt;meta name=&#34;description&#34; content=&#34;{{ . }}&#34;&gt; {{- end }} 設定ファイルの記述例 (config.toml) title = &#34;My New Hugo Site&#34; [params] author = &#34;Maku&#34; description = &#34;This is my first Hugo site. It&#39;s very cool.&#34; 出力結果 &lt;meta name=&#34;author&#34; content=&#34;Maku&#34;&gt; &lt;meta name=&#34;description&#34; content=&#34;This is my first Hugo site. It&amp;#39;s very cool.&#34;&gt; クォーテーションマークが、出力箇所のコンテキストに応じて、自動的にエスケープ処理されてますね。Cool!"},{url:"/p/8vrj4ui/",title:"Hugo でセクションの階層構造を取得する (.CurrentSection、.Parent、.Sections)",date:"2017-12-05T00:00:00+09:00",body:"Hugo でセクションの階層構造を取得する (.CurrentSection、.Parent、.Sections) Hugo のテンプレートファイル内から参照できる .Parent や .Sections といった Page 変数を参照すると、親セクションの情報や、子セクションの情報を取得することができます。 セクション系の情報を取得するための Page 変数 には下記のようなものがあります。 .CurrentSection 自分自身が所属するセクションの情報。自分自身がセクションページであったり、ホームページである場合は、自分自身のページの情報。型は Page オブジェクト。通常の記事ページ、ホームページ、セクションページ以外では nil になります（例えば、タクソノミーリストのページでは nil になります）。 .Parent 自分自身がセクションページの場合、親セクションの情報。自分自身が通常ページの場合、自分が所属するセクションの情報。型は Page オブジェクト。 .Sections 自分自身のセクションが含む子セクションの配列（ホームページテンプレート、あるいは、セクションテンプレートのみで意味を持つ）。型は Page オブジェクトの配列。 レイアウトファイル内で、これらのセクション情報を参照することで、階層構造に応じたナビゲーション用リンクを自動で生成 したりすることができるようになります。 ここでは、下記のような階層構造のコンテンツを用意して、それぞれのページで参照できるセクション情報がどのように変化するかを見てみましょう。 contents/ +-- _index.md (home page) +-- dir1/ | +-- _index.md (section page) | +-- page.md (single page) | +-- dir1-1/ | | +-- _index.md (section page) | | +-- page.md (single page) | +-- dir1-2/ | +-- _index.md (section page) | +-- page.md (single page) +-- dir2/ | +-- _index.md (section page) +-- dir3/ +-- _index.md (section page) .CurrentSection（自分が所属するセクション） テンプレートファイル内で .CurrentSection を参照すると、自分自身のページが所属するセクション (同一階層の _index.md）の Page オブジェクトを取得することができます。 テンプレートファイル（レイアウトファイル）内で、.CurrentSection の値を出力して、どのような値が格納されているかを調べてみましょう。 ここでは、次のような３種類のテンプレートファイルを用意することにします。 Home page template: layouts/index.html Section page template: layouts/_default/section.html Single page template: layouts/_default/single.html テンプレートファイル内の記述（上記 3 ファイルとも共通） &lt;pre&gt; {{ with .CurrentSection }} .CurrentSection = {{ . }} .CurrentSection.File.Path = {{ .File.Path }} .CurrentSection.Title = {{ .Title }} .CurrentSection.Kind = {{ .Kind }} .CurrentSection.Section = {{ .Section }} {{ end }} &lt;/pre&gt; .CurrentSections は通常ページ、ホームページ、セクションページ以外のテンプレートから参照すると nil になります。 つまり、layout/_default/taxonomy.html の中で参照すると必ず nil になるので、タクソノミーリストテンプレートの中では参照してはいけません。 また、layouts/_default/list.html の中で参照した場合でも、それがタクソノミーリストテンプレートとして使用されたときに .CurrentSections は nil になります。 layouts/_default/list.html の中で .CurrentSection の値を使用するときは、上記のように with ブロックや if ブロックで nil チェックしてから参照すると安全です。 参考: hugo/site_sections.go at master · gohugoio/hugo · GitHub CurrentSection returns the page&rsquo;s current section or the page itself if home or a section. Note that this will return nil for pages that is not regular, home or section pages. ホームページ (/index.html) にアクセスしたとき .CurrentSection = Page(&#34;タイトル (/index.html)&#34;) .CurrentSection.File.Path = _index.md .CurrentSection.Title = タイトル (/index.html) .CurrentSection.Kind = home .CurrentSection.Section = ホームページ (/index.md) にアクセスしたときの .CurrentSection 変数の値は、自分自身のページ（ホームページ）を表す Page オブジェクトになります。 つまり、ホームページテンプレート (/layouts/index.html) の中では、.CurrenctSection.Title と .Title の値は同じになります。 ホームページはルート階層のコンテンツなので、どのセクションにも存在しておらず、セクション名 (.Section) は空っぽになっています。 ☝️ ワンポイント .Section は .CurrentSection と混同しがちですが、まったく違うものであることに注意してください。 .Section は自分自身のページが配置されている一階層目のディレクトリ名（String 型）を表し、.CurrentSection は自分自身のページが所属するセクション（同一階層の _index.md）の Page オブジェクトを表しています。 ルート階層の通常ページ (/page.html) にアクセスしたとき .CurrentSection = Page(&#34;タイトル (/index.html)&#34;) .CurrentSection.File.Path = _index.md .CurrentSection.Title = タイトル (/index.html) .CurrentSection.Kind = home .CurrentSection.Section = ルート階層に置いた通常ページ（シングルページ）にアクセスしたときの .CurrentSection 変数の値は、ホームページ（ルート階層の _index.md）の Page オブジェクトになります。 上記の出力結果を見ると、ホームページ (/index.html) にアクセスしたときと同じ結果になっていることが分かります。 1 階層目のセクションページ (/dir1/index.html) にアクセスしたとき .CurrentSection = Page(&#34;タイトル (/dir1/index.html)&#34;) .CurrentSection.File.Path = dir1/_index.md .CurrentSection.Title = タイトル (/dir1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 セクションページ（ディレクトリ内の _index.md）にアクセスしたときの .CurrentSection 変数の値は、自分自身のページ（セクション）を表す Page オブジェクトになります。 つまり、セクションページテンプレート (/layouts/_default/section.html) の中では、.CurrentSection.Title と .Title の値は同じになります。 1 階層目のセクションに所属する通常ページ (/dir1/page.html) にアクセスしたとき .CurrentSection = Page(&#34;タイトル (/dir1/index.html)&#34;) .CurrentSection.File.Path = dir1/_index.md .CurrentSection.Title = タイトル (/dir1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 あるセクションに所属する通常ページ（シングルページ）にアクセスしたときの .CurrentSection 変数の値は、同じ階層の _index.md（つまり、所属するセクションのセクションページ）を表す Page オブジェクトになります。 2 階層目のセクションページ (/dir1/dir1-1/index.html) にアクセスしたとき .CurrentSection = Page(&#34;タイトル (/dir1/dir1-1/index.html)&#34;) .CurrentSection.File.Path = dir1/dir1-1/_index.md .CurrentSection.Title = タイトル (/dir1/dir1-1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 2 階層目のセクションページにアクセスしたときの .CurrentSection 変数の値も同様に、自分自身のページ（2 階層目のセクション）を表す Page オブジェクトになります。 深い階層のセクションであっても、.Section 変数の値は、1 階層目のディレクトリ名になることに注意してください。 2 階層目のセクションに所属する通常ページ (/dir1/dir1-1/page.html) にアクセスしたとき .CurrentSection = Page(&#34;タイトル (/dir1/dir1-1/index.html)&#34;) .CurrentSection.File.Path = dir1/dir1-1/_index.md .CurrentSection.Title = タイトル (/dir1/dir1-1/index.html) .CurrentSection.Kind = section .CurrentSection.Section = dir1 2 階層目のセクションに所属する通常ページ（シングルページ）にアクセスした場合も、これまでと同じ考え方ですね。 .CurrentSection の値は、同じ階層にある _index.md から生成されるセクションページの Page オブジェクトになります。 .Parent（親セクション） テンプレートファイル（レイアウトファイル）内から、.Parent を参照すると、親セクションのセクションページを表す Page オブジェクトを取得することができます。 親セクションというのは、自分自身がセクションページの場合は 1 階層上のセクションページ、自分自身が通常ページ（シングルページ）の場合は同一階層のセクションページを表します。 各種テンプレートの内容を次のように変更して、それぞれのページにアクセスしたときにどのような値が表示されるかを確認してみましょう。 &lt;pre&gt; {{ with .Parent }} .Parent = {{ . }} .Parent.File.Path = {{ .File.Path }} .Parent.Title = {{ .Title }} .Parent.Kind = {{ .Kind }} .Parent.Section = {{ .Section }} {{ end }} &lt;/pre&gt; ホームページ (/index.html) にアクセスしたとき ホームページは、最上位のセクションを表すページであるため、ホームページテンプレートからは親セクションを取得することはできません。 .Parent を参照したときの値は nil になるため、上記テンプレートでは何も表示されません。 ☝️ ワンポイント 正確には、ホームページはセクションページには分類されませんが、.Parent で参照する親セクションを考えるときには、通常のセクションと同様に考えたほうが分かりやすいです。 ルート階層の通常ページ (/page.html) にアクセスしたとき .Parent = Page(&#34;タイトル (/index.html)&#34;) .Parent.File.Path = _index.md .Parent.Title = タイトル (/index.html) .Parent.Kind = home .Parent.Section = ルート階層に配置された通常ページのテンプレート（シングルページテンプレート）から .Parent を参照すると、ホームページを表す Page オブジェクトを取得することができます。 1 階層目のセクションページ (/dir1/index.html) にアクセスしたとき .Parent = Page(&#34;タイトル (/index.html)&#34;) .Parent.File.Path = _index.md .Parent.Title = タイトル (/index.html) .Parent.Kind = home .Parent.Section = 1 階層目のセクションのセクションページから .Parent を参照すると、ホームページを表す Page オブジェクトを取得できます。 1 階層目のセクションに所属する通常ページ (/dir1/page.html) にアクセスしたとき .Parent = Page(&#34;タイトル (/dir1/index.html)&#34;) .Parent.File.Path = dir1/_index.md .Parent.Title = タイトル (/dir1/index.html) .Parent.Kind = section .Parent.Section = dir1 1 階層目のセクションに属する通常ページのテンプレート（シングルページテンプレート）から .Parent を参照すると、そのページが所属するセクションのセクションページを表す Page オブジェクトを取得することができます。 2 層目のセクションページ (/dir1/dir1-1/index.html) にアクセスしたとき .Parent = Page(&#34;タイトル (/dir1/index.html)&#34;) .Parent.File.Path = dir1/_index.md .Parent.Title = タイトル (/dir1/index.html) .Parent.Kind = section .Parent.Section = dir1 2 階層目のセクションのセクションページから .Parent を参照すると、1 階層上のセクションのセクションページを表す Page オブジェクトを取得することができます。 2 階層目のセクションに所属する通常ページ (/dir1/dir1-1/page.html) にアクセスしたとき .Parent = Page(&#34;タイトル (/dir1/dir1-1/index.html)&#34;) .Parent.File.Path = dir1/dir1-1/_index.md .Parent.Title = タイトル (/dir1/dir1-1/index.html) .Parent.Kind = section .Parent.Section = dir1 2 階層目のセクションに属する通常ページのテンプレート（シングルページテンプレート）から .Parent を参照すると、自分自身が所属するセクション（2 階層目のセクション）のセクションページを表す Page オブジェクトを取得することができます。 .Sections（子セクションの配列） テンプレートファイル（レイアウトファイル）の中から、.Sections を参照すると、そのセクションの下位セクション（子セクション）の配列を取得することができます。 .Sections に子セクションの値が格納されるのは、ホームページテンプレート、あるいは、セクションテンプレートから参照したときです（シングルページテンプレートから .Sections を参照すると、空配列になります）。 ここでは、各種テンプレートファイルに下記のように記述し、出力される値を確かめてみましょう。 &lt;ul&gt; {{ range .Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt; ホームページ (/index.html) にアクセスしたとき &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/dir1/&#34;&gt;タイトル (/dir1/index.html)&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/dir2/&#34;&gt;タイトル (/dir2/index.html)&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/dir3/&#34;&gt;タイトル (/dir3/index.html)&lt;/a&gt; &lt;/ul&gt; 最上位には、dir1/、dir2/、dir3/ というセクション（ディレクトリ）が配置されているため、ホームページテンプレートから .Sections を参照すると、それらのセクションページを表す Page オブジェクトの配列を取得することができます。 ルート階層の通常ページ (/page.html) にアクセスしたとき 通常ページのテンプレート（シングルページテンプレート）からは、子セクションの値を取得できません。 Sections の値はサイズ０の配列になります。 &lt;ul&gt; &lt;/ul&gt; 1 階層目のセクションページ (/dir1/index.html) にアクセスしたとき &lt;ul&gt; &lt;li&gt;&lt;a href=&#34;/dir1/dir1-1/&#34;&gt;タイトル (/dir1/dir1-1/index.html)&lt;/a&gt; &lt;li&gt;&lt;a href=&#34;/dir1/dir1-2/&#34;&gt;タイトル (/dir1/dir1-2/index.html)&lt;/a&gt; &lt;/ul&gt; 1 階層目のセクション (/dir1) には、2 階層目のセクション (dir1-1、dir1-2) が存在するため、.Sections を参照すると、それらの下位セクションのセクションページを表す Page オブジェクトの配列を取得することができます。 1 階層目のセクションに所属する通常ページ (/dir1/page.html) にアクセスしたとき 通常ページのテンプレート（シングルページテンプレート）からは、子セクションの値を取得できません。 Sections の値はサイズ 0 の配列になります。 &lt;ul&gt; &lt;/ul&gt; 2 階層目のセクションページ (/dir1/dir1-1/index.html) にアクセスしたとき 2 階層目のセクション (/dir1/dir1-1) には、下位セクションが存在しないため、.Sections はサイズ 0 の配列になります。 &lt;ul&gt; &lt;/ul&gt; 2 階層目のセクションに所属する通常ページ (/dir1/dir1-1/page.html) にアクセスしたとき 通常ページのテンプレート（シングルページテンプレート）からは、子セクションの値を取得できません。 Sections の値はサイズ 0 の配列になります。 &lt;ul&gt; &lt;/ul&gt; 応用例（兄弟セクションの一覧） シングルページテンプレート内で次のように記述すれば、そのページが所属するセクションの子セクションの一覧（つまり、兄弟セクションの一覧）を表示することができます。 &lt;ul&gt; {{ range .CurrentSection.Sections }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; {{ end }} &lt;/ul&gt;"},{url:"/p/mn4ji9o/",title:"Hugo のセクションテンプレート (section.html) の中でセクションのタイトルを表示する",date:"2017-11-28T00:00:00+09:00",body:"Hugo のセクションテンプレート (section.html) の中でセクションのタイトルを表示する セクションテンプレートの中では、.Title や .Section を利用してセクションページ用のタイトルを生成することができます。 それぞれの変数の違いについて説明します。 セクションテンプレートとは セクションテンプレート（あるいはセクションページテンプレート）は、content ディレクトリ内の各セクションのインデックスファイル (_index.md) をレンダリングするときに使用されるテンプレートファイルです。 ディレクトリ構成の例 content/ +-- mysection1/ | +-- _index.md ★このファイルや、 | +-- page1.md | +-- page2.md +-- mysection2/ +-- _index.md ★このファイルに適用されるレイアウトです +-- page1.md +-- page2.md どのようなファイルがセクションテンプレートとして使用されるかは、本家サイトの下記ページに詳しく説明されています。 Section Template Lookup Order すべてのセクションで共通のテンプレートを使用したいのであれば、まずは下記のようなパスにテンプレートファイルを用意するのがよいでしょう。 /layouts/_default/section.html （セクション専用のテンプレート） /layouts/_default/list.html （セクション以外にも様々なリスト系ページで使われるテンプレート） ＜ テーマとしてテンプレートファイルを提供したいときは、テーマディレクトリの下に同じ構成でファイルを作成すれば OK です。 /themes/&lt;テーマ名&gt;/layouts/_default/section.html /themes/&lt;テーマ名&gt;/layouts/_default/list.html list.html の方は、ホームページ（ルートの _index.md）や、タグやカテゴリーのインデックスページなどにも使用されます。 セクションのインデックスページとしてのみ適用したいテンプレートであれば、section.html という名前で作成しましょう。 セクションテンプレートから .Title を参照する セクションテンプレート layouts/_default/section.html（存在しない場合は list.html）の中で {{ .Title }} と記述すると、そのセクションの _index.md ファイルのフロントマターに定義した title の情報が参照されます。 これはすなわち「セクションページのタイトル」として使用できるものです。 ☝️ ワンポイント シングルページテンプレート layouts/_default/single.html の場合も、同様に {{ .Title }} と記述することで、各ページのフロントマターに記述した title 情報を参照することができます。 ディレクトリ構成の例 content/ +-- mysection/ +-- _index.md （セクションページ） +-- a.md +-- b.md +-- c.md セクションページの例 (content/mysection/_index.md) --- title: &#34;サンプルセクション&#34; --- これは本文のサンプル。 セクションテンプレートの例 (layouts/_default/section.html) &lt;h1&gt;{{ .Title }}&lt;/h1&gt; 上記のような構成で、http://localhost:1313/mysection/ にアクセスすると、下記のような HTML が表示されることになります。 &lt;h1&gt;サンプルセクション&lt;/h1&gt; 想定通り、_index.md のフロントマターに記述した title フィールドの値が表示されていることがわかります。 同様に、セクションテンプレートの中から {{ .Content }} を参照すると、_index.md に記述した本文の内容がそこに展開されます（この場合は、「これは本文のサンプル。」というテキストが展開されます）。 _index.md がない場合に .Title を参照するとどうなるか？ 実は、上記のディレクトリ構成で示した content/mysection/_index.md というファイルを作成しなくても、そのセクションの index.html ファイルは暗黙的に生成されます。 そのようなケースでも、テンプレートファイルとしてはセクションテンプレート (section.html) が使用されます。 擬似的な空っぽの _index.md ファイルが存在し、そのファイルに対してセクションテンプレートが適用されていると考えればよいでしょう。 ただし、この場合は _index.md のフロントマター記述も存在しないため、{{ .Title }} で参照できるはずの title 情報を取得することができません。 その代わりに、Hugo は セクションのディレクトリ名から自動的にセクションページのタイトルを生成 し、それを {{ .Title }} の値として使用します。 そのとき生成されるタイトルは、ディレクトリ名と同一ではないことに注意してください。 Hugo はセクションのディレクトリ名の 先頭を大文字にし、さらに複数形に変換した単語 をタイトルとして生成します。 上記のディレクトリ構成の場合は、セクションのディレクトリ名は mysection なので、自動生成されるタイトルは Mysections となります。 http://localhost:1313/mysection/ にアクセスした場合のレンダリング結果 &lt;h1&gt;Mysections&lt;/h1&gt; セクション名が自動的に複数形になってしまうのを防ぎたい場合は、Hugo の設定ファイル（config.toml など）で下記のように設定します。 /config.toml # Pluralize titles in lists using inflect pluralizeListTitles = false セクションテンプレートから .Section を参照する セクションテンプレートの中で {{ .Section }} を参照すると、セクションのディレクトリ名をそのまま取得することができます。 {{ .Title }} と異なり、自動的に先頭を大文字にしたり、複数形にしたりすることがないので、ディレクトリ構成をそのまま出力したい場合にはこちらを使用するのがよいでしょう。 セクションテンプレートの例 (layouts/_default/section.html) &lt;h1&gt;{{ .Section }}&lt;/h1&gt; http://localhost:1313/mysection/ にアクセスした場合のレンダリング結果 &lt;h1&gt;mysection&lt;/h1&gt;"},{url:"/p/zg4n7q9/",title:"Hugo のレイアウト用テンプレートの種類を理解する",date:"2017-11-28T00:00:00+09:00",body:"Hugo のレイアウト用テンプレートの種類を理解する Hugo では様々なタイプのテンプレートファイルを用意することができ、コンテンツファイルのパスに応じて、どのテンプレートファイルを使ってレンダリングされるかが決定されます。 Hugo のテンプレートファイル Hugo で Web サイトを作成する場合、コンテンツファイルとして Markdown ファイルを作成していきます。 この Markdown ファイルが HTML の形にレンダリングされるとき、テンプレートファイル が使用されます。 Hugo のテンプレートの仕組みを理解することは、Hugo を使いこなすキモとなります。 ここでは、どのような種類のテンプレートファイルが、どのようなコンテンツに対して適用されてレンダリングされるのかを把握しましょう。 ここでは、下記のようなコンテンツ階層があるものとして説明していきます。 コンテンツのディレクトリ階層 content/ +-- _index.md （ホームページ） +-- page1.md （通常のページ） +-- page2.md （通常のページ） +-- section1/ | +-- _index.md （セクションのインデックスページ ＝ セクションページ） | +-- pagel-1.md （通常のページ） | +-- page1-2.md （通常のページ） +-- section2/ +-- _index.md （セクションのインデックスページ ＝ セクションページ） +-- page2-1.md （通常のページ） +-- page2-2.md （通常のページ） ホームページテンプレート (Homepage Template) Homepage Template 最上位の _index.md をレンダリングするときは、ホームページテンプレート が使用されます。 content/ +-- _index.md ★ホームページテンプレートを使用してレンダリング +-- page1.md +-- page2.md +-- section1/ | +-- _index.md | +-- pagel-1.md | +-- page1-2.md +-- section2/ +-- _index.md +-- page2-1.md +-- page2-2.md ホームページテンプレートといっても、特定のテンプレートファイルが適用されるのではなく、下記のようなファイルのうち最初に見つかったテンプレートファイルが使用されることになります。 /layouts/index.html /layouts/_default/list.html /themes/＜テーマ名＞/layouts/index.html /themes/＜テーマ名＞/layouts/_default/list.html ☝️ ワンポイント このように複数の候補の中からテンプレートファイルを探す仕組みは、別の種類のコンテンツファイルの場合も同様に採用されています。 この仕組みによって、異なる種類のコンテンツに、共通のテンプレートファイルを適用するといったことができるようになっています。 セクションテンプレート (Section Templates) Section Page Templates セクションごとのインデックスページ (_index.md) をレンダリングするときは、セクションテンプレート が使用されます。 content/ +-- _index.md +-- page1.md +-- page2.md +-- section1/ | +-- _index.md ★セクションテンプレートを使用してレンダリング | +-- pagel-1.md | +-- page1-2.md +-- section2/ +-- _index.md ★セクションテンプレートを使用してレンダリング +-- page2-1.md +-- page2-2.md 下記のファイルの内、最初に見つかったテンプレートファイルがセクションテンプレートとして使用されます。 /layouts/section/＜セクション名＞.html /layouts/＜セクション名＞/list.html /layouts/_default/section.html /layouts/_default/list.html /themes/＜テーマ名＞/layouts/section/＜セクション名＞.html /themes/＜テーマ名＞/layouts/＜セクション名＞/list.html /themes/＜テーマ名＞/layouts/_default/section.html /themes/＜テーマ名＞/layouts/_default/list.html パスに ＜セクション名＞ を含んでいるものは、そのセクション固有のテンプレートを提供したいときに使用します。 多くの場合は、すべてのセクションページで共通のセクションテンプレートを使用しますので、3 番目の /layouts/_default/section.html を用意すると考えておけばよいでしょう。 リストテンプレート (List Templates) List Templates リストテンプレート は、前述のテンプレートファイルとは若干概念が異なるものです。 鋭い方は、ホームページテンプレート (Homepage Template) とセクションテンプレート (Section Templates) として使用されるテンプレートファイルの候補に、共通の /layouts/_default/list.html が含まれていることに気が付いたかもしれません。 Web サイトのホームページや、セクションごとのインデックスページ（セクションページ）には、そこに含まれるコンテンツのリストを表示するという共通の目的があります。 Hugo では、このようなリスト表示を目的としたコンテンツに適用可能できる、共通のテンプレートファイルとして /layouts/_default/list.html を参照するようになっています。 つまり、ホームページとセクションページで共通のレイアウトを使用するのであれば、/layouts/_default/list.html というファイルを 1 つだけ作成しておけばよいことになります。 この仕組みをリストテンプレートと呼んでいます。 content/ +-- _index.md ★リストテンプレートの適用対象 +-- page1.md +-- page2.md +-- section1/ | +-- _index.md ★リストテンプレートの適用対象 | +-- pagel-1.md | +-- page1-2.md +-- section2/ +-- _index.md ★リストテンプレートの適用対象 +-- page2-1.md +-- page2-2.md ☝️ テンプレートの優先度 リストテンプレートの適用優先度は低く設定されているため、/layouts/_default/list.html ファイルは主にフォールバック機構により適用されることになります。 例えば、ホームページのレンダリングには、まずは /layouts/index.html テンプレートを適用しようとしますが、そのファイルが見つからなかった場合に /layouts/_default/list.html テンプレートを適用する、という動作をします。 シングルページテンプレート (Single Page Templates) Single Page Templates シングルページテンプレート は、前述のリスト系のコンテンツに当てはまらないページ、つまり、個別記事のコンテンツに対して適用されるテンプレートです。 content/ +-- _index.md +-- page1.md ★シングルページテンプレートを使用してレンダリング +-- page2.md ★シングルページテンプレートを使用してレンダリング +-- section1/ | +-- _index.md | +-- pagel-1.md ★シングルページテンプレートを使用してレンダリング | +-- page1-2.md ★シングルページテンプレートを使用してレンダリング +-- section2/ +-- _index.md +-- page2-1.md ★シングルページテンプレートを使用してレンダリング +-- page2-2.md ★シングルページテンプレートを使用してレンダリング 下記のテンプレートファイルのうち、最初に見つかったファイルがシングルページテンプレートとして使用されます。 /layouts/＜タイプ名＞/＜レイアウト名＞.html /layouts/＜セクション名＞/＜レイアウト名＞.html /layouts/＜タイプ名＞/single.html /layouts/＜セクション名＞/single.html /layouts/_default/single.html /themes/＜テーマ名＞/layouts/＜タイプ名＞/＜レイアウト名＞.html /themes/＜テーマ名＞/layouts/＜セクション名＞/＜レイアウト名＞.html /themes/＜テーマ名＞/layouts/＜タイプ名＞/single.html /themes/＜テーマ名＞/layouts/＜セクション名＞/single.html /themes/＜テーマ名＞/layouts/_default/single.html セクションテンプレートと同様、セクション固有のテンプレートファイルを用意することもできますが、まずは /layouts/_default/single.html を作成し、すべてのページを同じレイアウトでレンダリングするところから始めるのがよいでしょう。"},{url:"/p/s9r9q7n/",title:"Linuxシェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)",date:"2017-11-01T00:00:00+09:00",body:"Linuxシェルスクリプト: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read) パイプで while read につなぐ方法 外部コマンドの出力結果を 1 行ずつ変数に取得しながらループ処理するには、コマンドの出力をパイプ (|) で while read につなぎます。 次の例では、外部コマンド find . -name '*.sh'（カレントディレクトリ以下の .sh ファイルを再帰的に列挙）の出力結果を 1 行ずつ line 変数に取得してループ処理しています。 find . -name &#39;*.sh&#39; | while read line; do echo &#34;$line&#34; done line という変数名は別の名前に変えても大丈夫です。 この例では 1 ファイルずつループ処理しているので、file という変数名の方が直感的かもしれません。 ☝️ ワンポイント echo 出力時に &quot;$line&quot; のようにダブルクォートで囲んでいるのは、echo が連続したスペースを 1 つのスペースにまとめて出力してしまうのを防ぐためです。 パス内にスペースが含まれていなければ問題は発生しませんが、必ずダブルクォートで囲むようにしましょう。 外部コマンドの出力を配列として受け取る方法 パイプ (|) を使用せず、$(command) の形で実行した外部コマンドの出力を、配列で受け取る方法もあります。 list=$(find . -name &#39;*.sh&#39;) for line in &#34;$list&#34;; do echo &#34;$line&#34; done 外部コマンドの出力を 1 行ずつ正しくループ処理するために、$list をダブルクォートで囲むことを忘れないでください。 for ループの in の後ろには、スペース区切りで各要素が列挙されているものとして認識されます。 行内にスペースが含まれている場合に、行全体を 1 つの要素として処理するためには、$list 変数を展開するときにダブルクォートで囲んでおく必要があります。"},{url:"/p/3dtq7o5/",title:"CSS の position プロパティによるレイアウト方法を理解する",date:"2017-10-23T00:00:00+09:00",body:"CSS の position プロパティによるレイアウト方法を理解する CSS の position プロパティには、static、fixed、relative、absolute を指定することができます。 これらの使い方を理解することで、HTML 要素の配置方法に広がりが出ます。 4 つの position 指定 position: static; 何も指定しない場合の初期値です。デフォルトの表示ルールによって要素が配置されます。あえて明示的に指定することはおそらくありません。 position: fixed; 画面上の指定した位置に固定配置します。スクロールしても表示位置の変わらないサイトヘッダーや、SNS ボタン群の表示などに利用することができます。 position: relative; 本来表示される位置から相対的に位置をずらします。補助的な使用方法として、自分自身の z-index プロパティを指定する場合や、子要素に position: absolute; を指定する場合にも使用されます。 position: absolute; 親要素の位置を基準にした絶対位置で配置します。position: absolute; を指定するには、その親要素に position: relative;（あるいは fixed、absolute）を指定しておく必要があります（親要素を移動させる必要がないときは、単純に position: relative; とだけ記述しておけば OK）。 position: fixed 図: position: fixed; の振る舞い position: fixed; を指定すると、ブラウザの表示領域内で位置を固定して表示することができます。 図: position: fixed; のデモ（別ページで開く） 具体的な表示位置は、top、bottom、left、right プロパティで指定します。 例えば、top: 0px; left: 0px; という指定を行えば、その要素はブラウザの画面上の左上に固定表示され、ユーザが画面スクロールを行ってもその要素は移動しません。 例えば、上記の表示例のように、サイトのヘッダ情報を画面上部に固定表示したり、サイドバーのメニューを固定表示したりするのに利用することができます。 position: relative 図: position: relative; の振る舞い position: relative; を指定すると、本来その要素が表示されるはずだった位置からのオフセットを指定して、表示位置をずらすことができます。 図: position: relative; のデモ（別ページで開く） 要素の表示位置をずらしたとしても、後続の要素は、その位置ずらしがなかったものとして配置される ことに注意してください。 上記の表示例を見るとよくわかると思います。 ちなみに、position: relative; の指定をだけを行い、top、bottom、left、right の指定を行わなかった場合は、その要素は本来表示されるべき位置にそのまま表示されます。 このような一見無駄に見える指定は、z-index プロパティ（要素の重なりの順序）を指定する際によく行われます。 なぜなら、z-index プロパティの指定は、position プロパティがデフォルトの static 値のままだと効果を発揮しないからです。 下記の例では、z-index プロパティの指定を有効にする目的のために position: relative; を指定しています。 .sample { position: relative; /* z-index の有効化のため（座標値は変わらない） */ z-index: 100; /* 要素同士の重なり順序を指定（上の方に表示） */ } また同様に、後述の position: absolute; という指定を有効にするためにも、親要素の position 指定を行う必要があります。 この場合も、position プロパティの値としては fixed、relative、absolute のいずれでも構わないのですが、表示位置に影響のない position: relative; という指定がよく使われます。 position: absolute 図: position: absolute; の振る舞い position: absolute; を使用すると、その親要素を基準とした絶対位置で表示位置を指定することができます（感覚的には絶対位置というよりは相対位置ですが）。 図: position: absolute; のデモ（別ページで開く） 注意しなければいけないのは、親要素の position プロパティとして、fixed、relative、absolute のいずれかを指定しておく必要があるというところです（つまり、デフォルトの static のままだと有効になりません）。 親要素の表示位置を特に移動させる必要がない場合は、親要素で position: relative; とだけ指定しておくのがよいでしょう。 例えば、下記のようにすると、親要素 (.parent) の左上に重なる形で、子要素 (.child) が表示されます。 .parent { position: relative; } .child { position: absolute; top: 0px; left: 0px; } position: absolute; は、画像の上にタイトル表示を重ねる場合などによく使用されます。 下記の例では、うさぎの画像に、「うさぎ」というテキストを重ねて表示しています。 図: position: absolute; でテキストを重ねる HTML 抜粋 &lt;figure class=&#34;catalog&#34;&gt; &lt;img src=&#34;rabbit.png&#34;&gt; &lt;figcaption&gt;うさぎ&lt;/figcaption&gt; &lt;/figure&gt; CSS 抜粋 .catalog { position: relative; /* 子要素で position: absolute; を使うため */ max-width: 300px; } .catalog img { width: 100%; vertical-align: bottom; /* これを入れないとテキストの位置が微妙に下にずれる */ } .catalog figcaption { position: absolute; /* 親要素の位置を基準に表示位置を指定する */ bottom: 0px; left: 0px; width: 100%; text-align: center; font-size: 20pt; color: white; background: rgba(0, 0, 0, 0.5); } ちなみに、top、bottom、left、right などのプロパティにマイナスの値を指定すると、親要素からその分だけはみ出した位置に子要素を表示させることができます。 うまく利用すれば、画像を隠さないようにキャプションを表示することができます。"},{url:"/p/4m7gqfx/",title:"複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir)",date:"2017-10-14T00:00:00+09:00",body:"複数の Hugo サイトで同じテーマディレクトリを参照する (themesDir) ローカル PC 上でいくつもの Hugo サイトを作成していて、さらに共通したテーマも同時に作成している場合は、同一のテーマディレクトリを参照して開発できると便利です。 複数の Hugo プロジェクトから、同一のテーマを参照するには、下記のような方法があります。 GitHub などにテーマ用のリポジトリを作成して、そのリポジトリを複数の Hugo プロジェクトに clone する。 各 Hugo プロジェクトの themes ディレクトリを、共通のテーマディレクトリへのシンボリックリンクへ置き換える。 設定ファイル (config.toml) で、共通のテーマディレクトリを参照するように設定する。 1 番目の方法は王道ですが、Git を介して各サイトのテーマを同一に保つのは、開発段階ではちょっと手間がかかって面倒かもしれません。 そんなときオススメなのは 2 番目と 3 番目の方法です。 シンボリックリンクで共通のテーマディレクトリを参照する Linux や macOS などのようにシンボリックリンクを作成できる OS では、共通のテーマディレクトリをシンボリックリンクで参照してしまうのがお手軽です。 例えば、下記のように共通で使用するテーマディレクトリ (hugo_themes) と、参照元となる３つの Hugo プロジェクト (site1、site2、site3) があるとします。 - hugo_themes/ （共通のテーマディレクトリ） +-- mytheme/ +-- archetypes/ +-- layouts/ +-- static/ +-- ... - site1/ （Hugo サイト 1） - site2/ （Hugo サイト 2） - site3/ （Hugo サイト 3） 各 Hugo プロジェクト内の themes ディレクトリを、hugo_themes へのシンボリックリンクに置き換えてしまえば、すべてのサイトから同じテーマディレクトリを参照できます。 $ cd site1 $ rmdir themes $ ln -s ../hugo_themes themes 使用するテーマ名の設定はあいかわらず必要なので、各 Hugo プロジェクトの設定ファイル (config.toml) でテーマ名を設定しておくことを忘れないでください。 site1/config.toml theme = &#34;mythemes&#34; 設定ファイルで共通のテーマディレクトリを設定する Hugo の設定ファイル (config.toml) で、共通のテーマディレクトリを設定する方法もあります。 テーマディレクトリの設定は themesDir という変数で設定するのですが、このディレクトリパスには、その Hugo プロジェクトよりも上位のディレクトリのパスを設定することができます。 config.toml themesDir = &#34;../hugo_themes&#34; theme = &#34;mythemes&#34; 例えば、各 Hugo プロジェクトの設定ファイルで、上記のように設定しておくと、上位のディレクトリに置いた共通のテーマディレクトリ (hugo_themes/mythemes/) を使用することができます。 設定ファイルを使わずに、hugo コマンドの --themesDir オプションでテーマディレクトリを指定することもできます。 $ hugo server --themesDir ~/gitwork/hugo_themes 設定ファイルの themesDir 変数と、コマンドライン引数の --themesDir の両方が指定された場合は、コマンドライン引数の方が優先されます。"},{url:"/p/yg4o9rb/",title:"複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる",date:"2017-10-10T00:00:00+09:00",body:"複数の Hugo サーバーを 1 つのコマンドプロンプト上で立ち上げる Hugo サーバーの複数起動について 複数のサイトを Hugo で運用しているケースでは、ひとつのコマンドプロンプトから同時にサーバー起動できると便利です。 ここでは、下記のようにホームディレクトリ以下に複数の Hugo プロジェクトが存在するとします。 C:/website/site1 C:/website/site2 C:/website/site3 各 Hugo プロジェクトに対して Hugo サーバーを起動するには、例えば次のように実行していきます。 ポート番号を指定して Hugo サーバーを複数起動する C:\\&gt; hugo server -p 50001 -s C:/website/site1 C:\\&gt; hugo server -p 50002 -s C:/website/site2 C:\\&gt; hugo server -p 50003 -s C:/website/site3 参考: カレントディレクトリを気にせずに hugo コマンドを実行する 参考: ポート番号を指定して Hugo サーバーを起動する ただし、上記のようにすると、1 つのサーバープロセスが 1 つのコマンドプロンプトを占有するため、複数の Hugo サーバーを起動しているときに複数のコマンドプロンプトを開いたままにしなければいけません。 1 つのターミナルで複数の Hugo サーバーを起動する Windows の場合 Windows の start コマンドを使用すると、バックグラウンドで hugo コマンドを実行することができるので、追加でコマンドプロンプトを開くことなしに複数の Hugo サーバーを起動することができます。 例えば、下記のバッチファイルは、３つの Hugo サーバーをバックグラウンドで起動します。 start-servers.bat @echo off start /b hugo server -p 50001 -s C:/website/site1 start /b hugo server -p 50002 -s C:/website/site2 start /b hugo server -p 50003 -s C:/website/site3 title Hugo Servers ☝️ ワンポイント 最後の行の title Hugo Servers では、コマンドプロンプトのウィンドウタイトルを Hugo Servers に変更しています。 ウィンドウタイトルを変更しておくと、タスクバーを見ただけで何のためのウィンドウなのかを判別しやすくなるのでお勧めです。 バックグラウンドで動作している Hugo サーバーをまとめて終了するには、例えば、taskkill コマンドを使用して、hugo.exe によるプロセスをまとめて終了します。 stop-servers.bat @echo off taskkill /f /im hugo.exe Windows の start コマンドや、taskkill コマンドの詳細は、まくまく Windows ノートを参照してください。 Linux の場合 Linux や macOS の場合は、下記のように末尾に &amp; を付けて hugo コマンド実行すれば、簡単に複数のサーバーをバックグラウンドで立ち上げることができます。 start-servers.sh hugo server -p 50001 -s ~/website/site1 &amp; hugo server -p 50002 -s ~/website/site2 &amp; hugo server -p 50003 -s ~/website/site3 &amp; Hugo サーバーのプロセスをまとめて終了したいときは、killall コマンドで簡単に終了できます。 stop-servers.sh killall hugo これくらいの規模であれば、シェルスクリプトではなく、関数やエイリアスとして定義してしまうのが手っ取り早いかもしれません。 ~/.bash_profile（抜粋） function hugo-start { hugo server -p 50001 -s ~/website/site1 &amp; hugo server -p 50002 -s ~/website/site2 &amp; hugo server -p 50003 -s ~/website/site3 &amp; } function hugo-stop { killall hugo }"},{url:"/p/8ihz7es/",title:"Hugo のセクション機能の基本（記事を階層化する）",date:"2017-10-04T00:00:00+09:00",body:"Hugo のセクション機能の基本（記事を階層化する） Hugo では、記事ファイルをディレクトリ内に格納するだけで、その名前の セクション に所属する記事として扱うことができます。 この機能は、記事を物理的な階層構造で管理するために使用することができます。 セクションの基本 Hugo の記事ファイル（.md ファイル）は、content ディレクトリに格納していきますが、content ディレクトリの下にさらにディレクトリを作成して、そこに格納することもできます。 例えば、次のように author というサブディレクトリを作成して、その下に .md ファイルを配置することができます。 /content/author/maku.md このようなディレクトリ階層を作成すると、maku.md という記事は、author という セクションに所属する記事 として扱われるようになります。 セクションはディレクトリ階層で表現されるため、1 つの記事は、1 つのセクションにしか所属できません。 セクション名は、記事のテンプレート内から {{ .Section }} で参照することができます（Page オブジェクトのプロパティ）。 個々の記事のレイアウトは、single.html というテンプレートファイル (single page template) によって行われるため、まずはこのテンプレートファイルを作成しましょう。 layouts/_default/single.html &lt;h1&gt;{{ .Title }}&lt;/h1&gt; セクション名: {{ with .Section }}{{ . }}{{ else }}なし{{ end }} &lt;main&gt; {{ .Content }} &lt;/main&gt; ☝️ ワンポイント ここで使用している with という構文は、if の拡張構文です。 指定した値が存在する場合、シンプルに {{ . }} でその値を参照できます。 上記のテンプレートファイルの例では、.Section が存在する場合だけその値を表示し、存在しない場合は「なし」と表示するようにしています。 記事ファイル (.md) としては、次の 2 種類を用意してどのように表示されるか比べてみます。 content/sample.md（どのセクションにも所属しない記事） --- title: &#34;サンプル&#34; date: &#34;2017-10-04&#34; --- ダミー本文 content/author/maku.md（author セクションに所属する記事） --- title: まく date: &#34;2017-10-04&#34; --- ダミー本文 それぞれのページにアクセスすると、下記のように表示されます。 図: content/sample.md の場合 図: content/author/maku.md の場合 author ディレクトリ以下に配置した記事だけ、セクション名を取得できていることがわかります。 セクションの index ページを作成する (_index.md) セクション用の index ページ（section page と呼びます）は、そのセクションのディレクトリ直下に _index.md というファイル名で作成します。 例えば、下記は event セクションに属するコンテンツの構成を示しています。 event セクションの記事 /content/event/_index.md (section page) /content/event/page1.md (single page) /content/event/page2.md (single page) /content/event/page3.md (single page) 上記の index ページには、http://localhost:1313/event/ というアドレスでアクセスできるようになります。 セクションの index ページがレンダリングされるとき、レイアウトファイルとしては section.html (section page template) 、あるいは list.html (list page template) が使用されます。 個々の記事ファイルをレンダリングするときに使用される single.html (single page template) とは異なるレイアウトファイルが使用されることに注意してください。 これはつまり、index ページがセクション内のコンテンツを 一覧表示するためのリストページ として特殊扱いされることを意味しています。 より具体的には、下記のファイルのうち、最初に見つかったレイアウトファイルが _index.md のレンダリングに使用されます（Section Page Templates より抜粋）。 セクションの index ページ用のレイアウトファイル /layouts/section/&lt;SECTION&gt;.html /layouts/&lt;SECTION&gt;/list.html /layouts/_default/section.html /layouts/_default/list.html /themes/&lt;THEME&gt;/layouts/section/&lt;SECTION&gt;.html /themes/&lt;THEME&gt;/layouts/&lt;SECTION&gt;/list.html /themes/&lt;THEME&gt;/layouts/_default/section.html /themes/&lt;THEME&gt;/layouts/_default/list.html ☝️ list.html は section.html よりも汎用的に使われる /layouts/_default/list.html は、ホームページ（ルートの _index.html）や、タクソノミーリスト（あるタグがついたページの一覧）などのレイアウトファイルとしても使用されます。 ホームページ専用のレイアウトファイル、タクソノミーリスト専用のレイアウトファイルを用意したい場合は、/layouts/index.html、/layouts/_default/taxonomy.html などを作成します。 このあたりの詳細は、Hugo マニュアルの Homepage Template、Taxonomy Templates を参照してください。 ここでは、/layouts/_default/list.html というファイルとしてレイアウトファイルを作成してみます（list.html は、ホームページやタクソノミーリストのページにも使用される、リスト系ページ用の汎用レイアウトファイルです）。 /layouts/_default/list.html &lt;main&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;{{ .Title }}&lt;/h1&gt; &lt;/header&gt; {{ .Content }} &lt;/article&gt; &lt;ul&gt; {{ range .Data.Pages }} &lt;li&gt; &lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Title }} ({{ .Date.Format &#34;2006-01-02&#34; }})&lt;/a&gt; &lt;/li&gt; {{ end }} &lt;/ul&gt; &lt;/main&gt; 上記のテンプレートを作成した後で、http://localhost:1313/event/ にアクセスすると、下記のように表示されます。 セクションの index ページ専用のレイアウトを作成する (section.html) layouts/_default/list.html というレイアウトファイルは、汎用的な list page template として使用されるため、各セクションの _index.md のレンダリング以外にも、ホームページ（ルートの _index.md）のレンダリングや、タグの一覧ページのレンダリングにも使用されます。 各セクションの _index.md をレンダリングするための専用のレイアウトファイルを用意したいときは、list.html という名前のレイアウトファイルの代わりに、次のような名前のレイアウトファイルを作成します。 セクションの index ページ専用のレイアウトファイル /layouts/section/&lt;SECTION&gt;.html /layouts/_default/section.html /themes/&lt;THEME&gt;/layouts/section/&lt;SECTION&gt;.html /themes/&lt;THEME&gt;/layouts/_default/section.html 上記のうち最初に見つかったレイアウトファイルが使用されます。 パスの中にセクション名 (&lt;SECTION&gt;) を含むファイルを用意しておくと、そのセクション専用の index ページをレンダリングするためのレイアウトファイルとして使用されます。 例えば、/layouts/section/event.html というレイアウトファイルは、event セクションの _index.md をレンダリングするためのレイアウトファイルとして使用されます。 全セクションの _index.md で共通のレイアウトファイルを使用するのであれば、layouts/_default/section.html というファイルをひとつだけ用意しておけば OK です。"},{url:"/p/t4sdxi3/",title:"Hugo のショートコードの中からフロントマターのパラメータを参照する ($.Page.Params)",date:"2017-10-02T00:00:00+09:00",body:"Hugo のショートコードの中からフロントマターのパラメータを参照する ($.Page.Params) Hugo のショートコードの中で $.Page.Params を参照すると、コンテンツファイルのフロントマターに記述したパラメータにアクセスすることができます。 下記の hello ショートコードは、コンテンツファイル (.md) のフロントマターに記述された title パラメータと date パラメータの値を表示します。 layouts/shortcodes/title-and-date.html {{ $.Page.Params.title }}&lt;br&gt; {{ $.Page.Params.date | dateFormat &#34;Mon, 02 Jan 2006&#34; }} ☝️ ワンポイント 時刻情報は dateFormat 関数に渡すことで、任意のフォーマットで出力することができます。 パイプで渡すのではなく、関数の第 2 パラメータとして次のように渡すこともできます。 {{ dateFormat &#34;Mon, 02 Jan 2006&#34; $.Page.Params.date }} Go 言語の時刻の扱いに関しては こちらを参照 してください。 作成した title-and-date ショートコードは、コンテンツファイルの中から次のように使用します。 content/page1.md --- title: &#34;ページタイトル&#34; date: &#34;2017-10-02&#34; --- {{&lt; title-and-date &gt;}} 上記のショートコードの部分は、HTML ファイル出力時に次のように展開されます。 Page1 Title&lt;br&gt; Mon, 02 Oct 2017"},{url:"/p/53patex/",title:"Hugo のショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params)",date:"2017-10-02T00:00:00+09:00",body:"Hugo のショートコードの中から設定ファイルのパラメータを参照する ($.Site.Params) Hugo のショートコードの中で $.Site.Params を参照すると、設定ファイル (config.toml) の params セクションに記述した情報を取得することができます。 例えば、設定ファイルに下記のように記述されていたとします。 config.toml baseURL = &#34;http://example.org/&#34; languageCode = &#34;ja-jp&#34; title = &#34;わたしのブログ&#34; theme = &#34;my-theme&#34; [params] subtitle = &#34;Hugo を使って日記を書いています&#34; authors = [ &#34;Maku&#34;, &#34;Ponyo&#34; ] 上記の params セクションに記述した設定値は、ショートコードの中から $.Site.Params.&lt;パラメータ名&gt; で参照することができます。 下記の site-info ショートコードは、サイトのタイトルとサブタイトル、筆者情報を表示するショートコードの実装例です。 layouts/shortcodes/site-info.html &lt;div class=&#34;title&#34;&gt;{{ $.Site.Title }}&lt;/div&gt; &lt;div class=&#34;subtitle&#34;&gt;{{ $.Site.Params.subtitle }}&lt;/div&gt; &lt;ul&gt; {{ range $.Site.Params.authors }} &lt;li&gt;{{- . -}}&lt;/li&gt; {{ end }} &lt;/ul&gt; ☝️ ワンポイント 上記のコードの中で、{{- . -}} と書いてある部分は、ループ処理で取り出した著者の名前を出力することを示しています。 {{ . }} と記述する代わりに、前後にハイフンを入れておくことで、出力時に前後の余計なスペースを取り除いてくれます。 コンテンツファイル (.md) の中からは、下記のようにしてショートコードを呼び出すことができます。 --- title: &#34;ページタイトル&#34; date: &#34;2017-10-02&#34; --- {{&lt; site-info &gt;}} ショートコードの部分は、下記のように展開されます。 &lt;div class=&#34;title&#34;&gt;わたしのブログ&lt;/div&gt; &lt;div class=&#34;subtitle&#34;&gt;Hugo を使って日記を書いています&lt;/div&gt; &lt;ul&gt; &lt;li&gt;Maku &lt;li&gt;Ponyo &lt;/ul&gt;"},{url:"/p/ttfyk5o/",title:"Hugo で独自のショートコードを作成する",date:"2017-09-29T00:00:00+09:00",body:"Hugo で独自のショートコードを作成する Hugo で独自のショートコードを作成すると、定型の HTML コードを記事内に簡単に埋め込めるようになります。 ショートコード作成の基本 ショートコードは、layouts/shortcodes ディレクトリ内に .html 拡張子のファイルとして作成します。 layouts/shortcodes/my-shortcode.html This is my first short code. ファイル名から拡張子を除いたものが、ショートコード名となります。 上記の例の場合、my-shortcode というショートコードを作成したことになります。 記事（Markdown ファイル）の中から、下記のように呼び出すと、上記の内容がそこに展開されます。 content/page1.md --- title: &#34;ページタイトル&#34; --- {{&lt; my-shortcode &gt;}} ショートコードにパラメータを渡す (.Get) 単純なパラメータ ショートコード呼び出し時に、パラメータを渡すことができます。 下記の例では、２つのパラメータ red、32px を渡しています。 {{&lt; my-shortcode red 32px &gt;}} 渡されたパラメータは、ショートコードの中で {{ .Get インデックス番号 }} のように参照することができます。 layouts/shortcodes/my-shortcode.html &lt;div style=&#34;color:{{ .Get 0 }}; font-size:{{ .Get 1 }};&#34;&gt; This is my first short code. &lt;/div&gt; 名前付きパラメータ 上記の例では、参照するパラメータをインデックス番号 (0, 1, 2, &hellip;) で指定していますが、2 つ以上のパラメータを持つショートコードを作成するときは、名前付きパラメータ の仕組みを使うと分かりやすくなります。 {{&lt; my-shortcode color=&#34;red&#34; size=&#34;32px&#34; &gt;}} 名前付きパラメータとして渡された値を参照するには、{{ .Get &quot;パラメータ名&quot; }} のように、インデックス番号の代わりにその名前を引用符で囲んで指定します。 &lt;div style=&#34;color:{{ .Get `color` }}; font-size:{{ .Get `size` }};&#34;&gt; This is my first short code. &lt;/div&gt; 上記のように HTML 要素の属性値の中で .Get のパラメータ名を記述するときは、ダブルクォーテーション (&quot;) の代わりにバッククォート (`) で囲むと、引用符の対応がわかりやすくなります。 パラメータの有無を調べる パラメータが渡されたかどうかで処理を分岐するには、.Get で取得した値を if や with で評価します。 次の例では、ショートコードに class パラメータが渡されたときに、span 要素の class 属性の値として出力しています。 &lt;span{{ with .Get &#34;class&#34;}} class=&#34;{{.}}&#34;{{ end }}&gt;{{ .Inner }}&lt;/span&gt; default 関数を組み合わせて使うと、パラメータが指定されなかった場合のデフォルト値を用意しておくことができます。 以下のいずれの書き方も同様に振る舞いますが、1 つ目の書き方が直感的かと思います。 width パラメータのデフォルト値を auto にする {{ $width := .Get &#34;width&#34; | default &#34;auto&#34; }} {{ $width := default &#34;auto&#34; (.Get &#34;width&#34;) }} {{ $width := or (.Get &#34;width&#34;) &#34;auto&#34; }} ショートコードにテキストデータを渡す (.Inner) ショートコードの開始タグと終了タグで任意のテキスト（内部テキスト）を囲むと、ショートコードのテンプレート内からそのテキストを参照することができます。 下記は、caution という独自ショートコードにテキストを渡す例です。 content/page1.md --- title: &#34;ページタイトル&#34; --- {{&lt; caution &gt;}} 決して、この発射ボタンを押さないでください。 {{&lt; /caution &gt;}} 開始タグと終了タグで囲まれた内部テキストは、ショートコードの中から {{ .Inner }} で参照することができます。 layouts/shortcodes/caution.html &lt;div style=&#34;color:red;&#34;&gt; {{ .Inner }} &lt;/div&gt; 内部テキストを最終的に Markdown プロセッサで処理してもらいたい場合は、下記のように % を使用した呼び出し方をする必要があります。 --- title: &#34;ページタイトル&#34; --- {{% caution %}} 決して、この __発射ボタン__ を押さないでください。 {{% /caution %}} テーマ用のショートコード テーマの付属品として配布されるショートコードは、次のようなパスに配置します。 themes/&lt;THEME&gt;/layouts/shortcodes/&lt;SHORTCODE&gt;.html 同じ名前のショートコードが、現在の Hugo プロジェクト自身のショートコードディレクトリ (layouts/shortcodes) に存在する場合は、そちらが優先して使用されます。"},{url:"/p/tsfzj4n/",title:"Hugo のショートコードで本文内に HTML スニペットを埋め込む",date:"2017-09-29T00:00:00+09:00",body:"Hugo のショートコードで本文内に HTML スニペットを埋め込む 記事の中に定型のコード（YouTube 動画表示用 HTML など）を埋め込みたいときは、Hugo のショートコード (Shortcode) の機能を使用すると便利です。 ショートコードの基本 Hugo は基本的にマークダウン形式で記事を記述していくのですが、マークダウンの表現力には限界があるので、ときには HTML を直接記述したくなることがあります。 しかし、毎回同じような HTML を記述するのでは、マークダウン形式を使用する意味がなくなってしまいます。 このような場合に、HTML 部分をショートコードとして外部ファイルに保存しておくと、記事の中に簡単にその HTML を埋め込めるようになります。 ☝️ ワンポイント ショートコードは記事（コンテンツファイル）の中から呼び出すことができますが、テンプレートファイルの中からは呼び出せないことに注意してください。 テンプレートの中から同様のことを行いたい場合は、パーシャルテンプレートの仕組みを使用します。 Hugo には、いくつかの組み込みのショートコードが用意されています。 例えば、下記は Youtube の動画や、Instagram の投稿を埋め込むためのショートコードの使い方の例です。 例: Youtube 動画を記事内に埋め込む {{&lt; youtube w7Ft2ymGmfc &gt;}} {{&lt; youtube id=&#34;w7Ft2ymGmfc&#34; autoplay=&#34;true&#34; &gt;}} 例: Instagram の投稿を記事内に埋め込む {{&lt; instagram BWNjjyYFxVx &gt;}} 例: ツイートを記事内に埋め込む {{&lt; tweet 877500564405444608 &gt;}} ショートコードの呼び出し方 記事内からショートコードを呼び出すには、下記のような構文を使用します。 {{&lt; shortcode-name param1 param2 &gt;}} 名前付きのパラメータを使用する場合は、param1=&quot;value1&quot; のように記述します。 {{&lt; shortcode-name param1=&#34;value1&#34; param2=&#34;value2&#34; &gt;}} HTML タグのように、開始タグと終了タグで内部テキストを囲むこともできます (paired shortcode)。 {{&lt; shortcode-name &gt;}} 長めのテキストをショートコードへの入力として扱う場合は、このように開始タグと終了タグで囲む方式を使うとよいです。 この部分のテキストは、ショートコードの実装の中で .Inner という変数で参照できます。 {{&lt; /shortcode-name &gt;}} 内部テキストの中で Markdown 記法を使う場合は、{{&lt; と &gt;}} の代わりに、{{% と %}} でショートコード名を囲みます。 {{% shortcode-name %}} 内部テキストの中で __強調テキスト__ や `inline code` などの Markdown 記法を使うことができます。 {{% /shortcode-name %}} 参考: 独自のショートコードを作成する"},{url:"/p/tbf357g/",title:"インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding)",date:"2017-09-12T00:00:00+09:00",body:"インタフェース埋め込みと構造体埋め込みによる拡張 (Embedding) Go 言語には継承の仕組みはありませんが、埋め込み (Embedding) という仕組みによって型の拡張（結合）を行うことができます。 インタフェース埋め込み (Interface Embedding) Go 言語標準の io パッケージには、下記のような Reader インタフェースと Writer インタフェースが定義されています。 type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } ここで、Read メソッドと Write メソッドを両方とも備えるインタフェースを単純に定義しようとすると、下記のように記述することになります。 type ReadWriter interface { Read(p []byte) (n int, err error) Write(p []byte) (n int, err error) } Go 言語では、このようなケースのために 埋め込み (Embedding) の仕組みが提供されており、次のように既存のインタフェースを再利用する形で新しいインタフェースを定義することができます。 type ReadWriter interface { Reader Writer } ReadWriter インタフェースを備えるオブジェクトは、ReadWriter 型のパラメータを取る関数だけでなく、Reader 型のパラメータを取る関数や、Writer 型のパラメータを取る関数にも渡すことができます。 ちなみに、この ReadWriter インタフェースも標準の io パッケージで定義されています。 構造体埋め込み (Struct Embedding) 埋め込み (Embedding) の仕組みは、インタフェースだけでなく、構造体でも同様に使用することができます。 下記の例では、Product 構造体を埋め込む形で Stock 構造体を定義しています。 Product 構造体は、メソッドを１つ実装しています。 type Product struct { Model string Name string Price int } func (p *Product) AdLabel() string { return fmt.Sprintf(&#34;%s (%s)&#34;, p.Model, p.Name) } type Stock struct { *Product Quantity int } Product 構造体に定義されているフィールドやメソッドは、Stock オブジェクト経由で直接参照することができます。 Stock オブジェクトは下記のように生成します。 s := &amp;Stock{ Product: &amp;Product{Model: &#34;PR102&#34;, Name: &#34;Printer&#34;, Price: 300}, Quantity: 100, } fmt.Println(s.Model) //=&gt; PR102 fmt.Println(s.AdLabel()) //=&gt; Printer (PR102) オブジェクト生成時は、埋め込んだ構造体のオブジェクトを生成して初期化しなければいけないことに注意してください（初期化すべきフィールドの名前も、埋め込んだ構造体の型名と同じになります）。 次のように、埋め込んだ構造体のフィールドを直接初期化することはできません。 間違った初期化方法 s := &amp;Stock{ Model: &#34;PR102&#34;, // 初期化時に Product のフィールドは参照できない Name: &#34;Printer&#34;, // 初期化時に Product のフィールドは参照できない Price: 300, // 初期化時に Product のフィールドは参照できない Quantity: 100, }"},{url:"/p/29dgjnq/",title:"ベンチマークを行う (testing.B)",date:"2017-09-12T00:00:00+09:00",body:"ベンチマークを行う (testing.B) Go のベンチマーク機能の基本的な使い方 Go にはテストフレームワーク（testing パッケージ）の一機能として、ベンチマークを行う仕組みが搭載されています。 ここでは、下記のような構造体を、「値渡し」した場合と、「ポインタ渡し」した場合のパフォーマンスの違いを調べてみましょう。 type Book struct { Title string Author string Price int } func CallByValue(b Book) { } func CallByPointer(b *Book) { } ベンチマーク実行用の関数は、下記のように、Benchmark という名前で始まり、*testing.B 型のパラメーターを持つ関数として定義します。 func BenchmarkXxxYyyZzz(b *testing.B) 例えば、次のような感じで実装します。 // CallByValue の実行速度を計測 func BenchmarkCallByValue(b *testing.B) { book := Book{&#34;Golang&#34;, &#34;Maku&#34;, 1500} for i := 0; i &lt; b.N; i++ { CallByValue(book) } } // CallByPointer の実行速度を計測 func BenchmarkCallByPointer(b *testing.B) { book := Book{&#34;Golang&#34;, &#34;Maku&#34;, 1500} for i := 0; i &lt; b.N; i++ { CallByPointer(&amp;book) } } 上記のように、ループ回数に b.N を指定しておくと、有意な実行時間が計測できるまで繰り返し実行してくれるようになります。 ベンチマーク用の実装ファイルは、ファイル名のサフィックスを _test.go としておく必要があります（あくまでベンチマークはテストの一部という位置付け）。 下記に全体のコードを示しておきます。 sample_test.go package main import &#34;testing&#34; type Book struct { Title string Author string Price int } func CallByValue(b Book) { } func CallByPointer(b *Book) { } func BenchmarkCallByValue(b *testing.B) { book := Book{&#34;Golang&#34;, &#34;Maku&#34;, 1500} for i := 0; i &lt; b.N; i++ { CallByValue(book) } } func BenchmarkCallByPointer(b *testing.B) { book := Book{&#34;Golang&#34;, &#34;Maku&#34;, 1500} for i := 0; i &lt; b.N; i++ { CallByPointer(&amp;book) } } ベンチマークを実行するときは、go test コマンドを -bench オプション付きで実行します。 $ go test -bench . goos: windows goarch: amd64 BenchmarkCallByValue-8 2000000000 1.62 ns/op BenchmarkCallByPointer-8 2000000000 0.27 ns/op PASS ok /Users/maku/sandbox 5.060s この結果は、CallByValue と CallByPointer がそれぞれ 2000000000 回実行され、１回あたりの実行にかかった時間が 1.62 ns と、0.27 ns であったことを示しています（ポインタ渡しの方が高速だということ）。 メモリの使用効率を調べる (benchmem) go test -bench でベンチマークを実行するときに、-benchmem オプションを追加で指定すると、実行速度だけではなく、メモリ割り当ての統計情報も一緒に表示してくれます。 下記のサンプルコードは、スライスの append 処理のベンチマークを取っています。 FuncA の方は、初期サイズ 0 からの append の繰り返し、FuncB の方は、あらかじめ初期容量を確保しおいてからの append の繰り返しを行っています。 sample_test.go package main import &#34;testing&#34; const SIZE = 10000 func FuncA() { s := []int{} for i := 0; i &lt; SIZE; i++ { s = append(s, 1) } } func FuncB() { s := make([]int, 0, SIZE) for i := 0; i &lt; SIZE; i++ { s = append(s, 1) } } func BenchmarkFuncA(b *testing.B) { for i := 0; i &lt; b.N; i++ { FuncA() } } func BenchmarkFuncB(b *testing.B) { for i := 0; i &lt; b.N; i++ { FuncB() } } 次のようにベンチマークを起動します。 -benchmem オプションは最後に指定することに注意してください。 $ go test -bench . -benchmem goos: windows goarch: amd64 BenchmarkFuncA-8 30000 40035 ns/op 386296 B/op 20 allocs/op BenchmarkFuncB-8 200000 9985 ns/op 81920 B/op 1 allocs/op PASS ok /Users/maku/sandbox 3.807s ベンチマーク結果の 386296 B/op 20 allocs/op というところは、386296 バイトのメモリを使用したということ、20 回のメモリアロケーションを行ったということを示しています。 つまり、FuncA が 20 回もスライスの容量を拡張しているのに対し、FuncB は最初に make 関数で容量を確保してから一度も拡張されていないということが読み取れます。 プログラムの実行速度が思わしくないときは、このように -benchmem オプションを追加してベンチマーク実行すれば、メモリ割り当てが影響しているかどうかを調べることができます。 セットアップに時間がかかるときは b.ResetTimer テスト用データの構築に時間がかかるようなケースで、それにかかった時間をベンチマーク結果には含めたくない場合は、セットアップ処理が終わった時点で b.ResetTimer() を呼ぶようにします。 func BenchmarkBigLen(b *testing.B) { big := NewBig() b.ResetTimer() // ここから計測開始 for i := 0; i &lt; b.N; i++ { big.Len() } }"},{url:"/p/sy58beh/",title:"時刻データを扱う (time)",date:"2017-09-12T00:00:00+09:00",body:`時刻データを扱う (time) Go 言語で日付や時刻の情報を扱うには、組み込みの time パッケージを使用します。 時刻データ (time.Time) を作成する 現在時刻を取得する Go 言語で日時を表す型は、time パッケージで定義されている time.Time 型です。 現在の時刻を取得するには、time.Now 関数を使用します。 t := time.Now() fmt.Printf(&#34;%v\\n&#34;, t) // time.Time が保持する値を表示 fmt.Printf(&#34;%T\\n&#34;, t) // 型名を表示 実行結果 2017-09-12 21:23:23.7770078 +0900 JST m=+0.003000200 time.Time 日時を指定して作成する time.Date 関数を使用して、指定した日時の time.Time を作成することができます。 パラメータには、年、月、日、時、分、秒、ナノ秒、Location を指定します。 t := time.Date(2017, 9, 12, 23, 0, 0, 0, time.Local) fmt.Println(t) // &#34;2017-09-12 23:00:00 +0900 JST&#34; Location には、ローカルタイムで設定することを表す time.Local や、協定世界時で設定することを表す time.UTC を指定することができます。 文字列表現から作成する time.Parse 関数 を使用すると、日時を表す文字列から time.Time オブジェクトを作成することができます。 第 1 パラメータに、日時文字列の形式を表す layout string（後述）、第 2 パラメータに、実際に変換する文字列を渡します。 const layout = &#34;2006-01-02&#34; t, err := time.Parse(layout, &#34;2017-09-27&#34;) if err != nil { panic(err) } fmt.Println(t) // 2017-09-27 00:00:00 +0000 UTC layout string には、下記のようにいろいろなパターンを指定することができます。 const layout = &#34;Jan 2, 2006 at 3:04pm (MST)&#34; t, _ := time.Parse(layout, &#34;Feb 3, 2013 at 7:54pm (PST)&#34;) fmt.Println(t) // 2013-02-03 19:54:00 +0000 PST 指定しなかったフィールドは、0 で初期化されます。 例えば、下記のように日付だけを指定した場合は、０時０分０秒になります。 const layout = &#34;2006-Jan-02&#34; t, _ := time.Parse(layout, &#34;2013-Feb-03&#34;) fmt.Println(t) // 2013-02-03 00:00:00 +0000 UTC layout string 中に JST などのタイムゾーンを示す文字列を指定しない場合は、time.Parse が生成する時刻データは世界協定時 UTC の時刻が指定されたものとして扱われます。 ローカルタイムの時刻を指定して time.Time を生成したい場合は、次のように time.ParseInLocation 関数を使用します。 const layout = &#34;2006-01-02 15:04:05&#34; t, err := time.ParseInLocation(layout, &#34;2017-01-01 00:00:00&#34;, time.Local) if err != nil { panic(err) } fmt.Println(t) // 2017-01-01 00:00:00 +0900 JST layout string time.Parse 関数を使用して文字列から time.Time を作成するときや、Format メソッドで time.Time を文字列表現に変換するときには、どのような形式の文字列として扱うかを示す layout string を指定する必要があります。 layout string に指定する文字列は、2006年1月2日 15時4分5秒 (MST) の日時を表すパーツを組み合わせて指定する必要があります（Go 言語の time パッケージの決まりです）。 この日時を扱うのは、次のように 1 ～ 7 の数字が並べられることが理由のようです。 詳しくは公式ドキュメントを参照してください。 01/02 03:04:05PM &#39;06 -0700 例えば、次のような文字列を layout string として使用することができます。 Mon Jan 2 15:04:05 -0700 MST 2006 2006-01-02 2006/01/02 2006-Jan-02 2006-01-02 15:04:05 2006-01-02T15:04:05 2006-01-02 (Mon) 15:04:05 Jan 2, 2006 at 3:04pm (MST) time パッケージには、下記のような layout string 定数があらかじめ定義されています。 const ( ANSIC = &#34;Mon Jan _2 15:04:05 2006&#34; UnixDate = &#34;Mon Jan _2 15:04:05 MST 2006&#34; RubyDate = &#34;Mon Jan 02 15:04:05 -0700 2006&#34; RFC822 = &#34;02 Jan 06 15:04 MST&#34; RFC822Z = &#34;02 Jan 06 15:04 -0700&#34; // RFC822 with numeric zone RFC850 = &#34;Monday, 02-Jan-06 15:04:05 MST&#34; RFC1123 = &#34;Mon, 02 Jan 2006 15:04:05 MST&#34; RFC1123Z = &#34;Mon, 02 Jan 2006 15:04:05 -0700&#34; // RFC1123 with numeric zone RFC3339 = &#34;2006-01-02T15:04:05Z07:00&#34; RFC3339Nano = &#34;2006-01-02T15:04:05.999999999Z07:00&#34; Kitchen = &#34;3:04PM&#34; // Handy time stamps. Stamp = &#34;Jan _2 15:04:05&#34; StampMilli = &#34;Jan _2 15:04:05.000&#34; StampMicro = &#34;Jan _2 15:04:05.000000&#34; StampNano = &#34;Jan _2 15:04:05.000000000&#34; ) 時刻情報を参照する 年、月、日、曜日、時、分、秒を取得する time.Time 構造体には、時分秒などの各パートの情報を切り出して取得するためのメソッドが用意されています。 t := time.Now() fmt.Printf(&#34;%d\\n&#34;, t.Year()) // 2017（年） fmt.Printf(&#34;%d\\n&#34;, t.Month()) // 9（月） fmt.Printf(&#34;%d\\n&#34;, t.Day()) // 12（日） fmt.Printf(&#34;%d\\n&#34;, t.YearDay()) // 255（年内通算日数） fmt.Printf(&#34;%d\\n&#34;, t.Weekday()) // 2（曜日: time.Sunday==0） fmt.Printf(&#34;%d\\n&#34;, t.Hour()) // 21（時） fmt.Printf(&#34;%d\\n&#34;, t.Minute()) // 37（分） fmt.Printf(&#34;%d\\n&#34;, t.Second()) // 11（秒） 月や曜日は単純な int ではなく、time.Month と time.Weekday という型で定義されており、それぞれの月や曜日を表す定数も定義されています（time.January や time.Sunday）。 time.Month 型 &hellip; type Month int time.Weekday 型 &hellip; type Weekday int 上記の型には String() メソッド（fmt.Stringer インタフェース）が実装されているため、次のようにして文字列表現の月、曜日を取得することができます。 t := time.Now() month := t.Month().String() //=&gt; &#34;September&#34; weekday := t.Weekday().String() //=&gt; &#34;Tuesday&#34; もちろん、Printf 系メソッドのフォーマットで %s を指定して文字列表現で出力することもできます。 t := time.Now() fmt.Printf(&#34;%s, %s\\n&#34;, t.Month(), t.Weekday) //=&gt; &#34;September, Tuesday&#34; 年月日データのみ、時分秒データのみを取得する パラメータなしの Date() メソッドは、年、月、日の情報を戻り値として返します。 同様に、Clock() メソッドは、時、分、秒の情報を戻り値として返します。 t := time.Now() year, month, day := t.Date() hour, minute, second := t.Clock() 文字列形式で出力する time.Format 関数 を使用すると、time.Time オブジェクトを任意のフォーマットの文字列に変換することができます。 Format 関数には、取得する文字列の形式を表す layout string を指定します。 main.go package main import &#34;fmt&#34; import &#34;time&#34; func main() { const layout = &#34;2006-01-02 Mon 15:04:05 (MST)&#34; t := time.Now() fmt.Println(t.Format(layout)) } 実行結果 2017-09-12 Tue 23:30:58 (JST) ちなみに、time.Time 構造体の String() 関数は下記のようなフォーマットで、文字列を返すように実装されています。 2006-01-02 15:04:05.999999999 -0700 MST`},{url:"/p/aimpsvz/",title:"Go 言語のインタフェースの扱いを理解する (interface)",date:"2017-09-11T00:00:00+09:00",body:`Go 言語のインタフェースの扱いを理解する (interface) Go 言語で、ある型にインタフェースを実装するときは、Java などとは異なり、implements キーワードを使ったインタフェースの明示は行いません。 Ruby や Python と同様に、同じシグネチャのメソッドを実装した時点で、そのインタフェースを備えているとみなされます。 インタフェースを定義する (type &hellip; interface) Go 言語でインタフェースを定義するときは、構造体 (struct) の定義と同様に type キーワードを使用します。 下記は Go 言語で定義されているインタフェースの例です。 fmt.Stringer インタフェース type Stringer interface { String() string } io.Reader インタフェース type Reader interface { Read(p []byte) (n int, err error) } 上記の例からも想像できるように、Go 言語では、1 つのメソッドだけを持つインタフェースの名前は、メソッド名＋er とする規約となっています。 String 関数だけを持つ → Stringer インタフェース Read 関数だけを持つ → Reader インタフェース Write 関数だけを持つ → Writer インタフェース Format 関数だけを持つ → Formatter インタフェース インタフェースを使用する インタフェースを引数として受け取る関数を定義すると、そのインタフェースが定義するメソッドを実装しているオブジェクトだけを渡せるようになります。 func PrintSomething(s fmt.Stringer) { // String() メソッドを呼び出せることが保証されている fmt.Println(s.String()) } Java などの言語では、あるクラスがあるインタフェースを実装していることを示すために implements キーワードを使用しますが、Go 言語では明示的にインタフェース名を指定して実装することはありません。 ただ単純に、インタフェースによって示されているメソッドを実装するだけで、その型はそのインタフェースを備えている（実装している）とみなされます。 このような思想は Ruby や Python でも採用されており、通称 ダックタイピング と言われているものです（アヒルのように歩いて鳴けば、それはアヒルであるという考え方）。 例えば、下記の Book 構造体は、String() メソッドを実装しているため、Go コンパイラは fmt.Stringer インタフェースを備えているとみなします。 type Book struct { Title string Author string } func (this *Book) String() string { return fmt.Sprintf(&#34;%s : %s&#34;, this.Title, this.Author) } よって、この Book 構造体のインスタンスは、先に示した PrintSomething 関数に渡せることになります。 b := &amp;Book{Title: &#34;Golang&#34;, Author: &#34;Maku&#34;} PrintSomething(b) //=&gt; &#34;Golang : Maku&#34; また、Book は fmt.Stringer インタフェースを備えているので、fmt.Stringer 型の変数に代入することができます。 var s fmt.Stringer = &amp;Book{Title: &#34;Golang&#34;, Author: &#34;Maku&#34;} println(s.String()) すべてのオブジェクトを示す空っぽインタフェース ここで、次のようにメソッドを１つも持たない空っぽのインタフェース (empty interface) を考えてみます。 interface{} Go 言語では、インタフェースが示すメソッドを実装していれば、そのインタフェースを備えていると判断されます。 つまり、上記のような空インタフェースは、すべての型が備えているインタフェースということになります（Java における Object クラスに近い）。 関数のパラメータとして、inteface{} 型を受け取るように実装されている場合は、任意の型のオブジェクト を渡すことができるということを示しています。 例えば、fmt.Println 関数は、任意の型の引数を複数受け取るように実装されています。 func Println(a ...interface{}) (n int, err error) また、空インタフェース型の変数を定義すると、その変数にはどのような型の値でも代入できるようになります。 var i interface{} // 空インタフェース型の変数を定義 空インタフェースのゼロ値は nil で、型も nil となります。 下記のサンプルコードは、空インタフェースに色々な型の値を代入できること、代入される値によって変数の型が変化することを示しています。 package main import &#34;fmt&#34; func printTypeAndValue(i interface{}) { fmt.Printf(&#34;%v (type:%T)\\n&#34;, i, i) } func main() { var i interface{} printTypeAndValue(i) // &lt;nil&gt; (type:&lt;nil&gt;) i = 100 printTypeAndValue(i) // 100 (type:int) i = &#34;Hello&#34; printTypeAndValue(i) // Hello (type:string) } 空インタフェースをパラメータとして受け取る関数の中で、型スイッチ (Type Switch) の仕組みを使用すれば、実際に渡された値の型によって処理を分岐することができます。`},{url:"/p/j47aswy/",title:"Golang のパニックによるエラー処理 (panic, recover)",date:"2017-09-11T00:00:00+09:00",body:"Golang のパニックによるエラー処理 (panic, recover) Go 言語には try ~ catch による例外処理の仕組みは存在しませんが、panic という仕組みが用意されています。 パニックとは？ Go 言語では、関数呼び出し時に発生するエラーは、error オブジェクトを戻り値として返す方法が採用されています（参考: 関数を定義する）。 一方で、実行を継続できないランタイムエラー（スライスの範囲外アクセスなど）が発生した場合には、パニック (panic) を発生させる仕組みになっています。 vals := []int{10, 20, 30} println(vals[3]) // panic: runtime error: index out of range [3] with length 3 パニックが発生すると、デフォルトでは プログラム全体が終了します。 一般的なアプリケーションではパニックは発生させるべきではなく、関数内でエラーが発生したときは error オブジェクトを返すことが推奨されています。 パニックを発生させる (panic) 関数の中から明示的にパニックを発生させるには、panic 関数を呼び出します。 panic 関数には、エラーの内容を示す error オブジェクトを渡すことができます。 import &#34;errors&#34; func dumpBook(b *Book) { if b == nil { panic(errors.New(&#34;Book cannot be nil&#34;)) } // ... } このようにパニックの仕組みは簡単に使えてしまいますが、実行を継続できないケースに限って使用すべきです。 通常シーケンスで発生するエラーに関しては、戻り値として error オブジェクトを返すようにし、呼び出し側で簡単にハンドルできるようにしておきましょう。 panic 関数の代わりに、log パッケージの log.Panicln 関数や log.Panicf 関数を使用すると、時刻付きのログを出力したあとで、パニックを発生させてくれます。 import &#34;log&#34; func foo() { log.Panicln(&#34;Something wrong happened&#34;) } パニックから復帰する (recover) 関数内の処理で、何らかのパニックが発生したとしても、あらかじめ defer 登録された処理は、関数を抜ける前に実行されます。 この defer 処理の中で recover 関数を呼び出すと、パニック発生時に panic 関数に渡されたオブジェクト（通常は error オブジェクト）を取得することができます。 パニック発生時には、通常はプログラム全体が終了しますが、defer 処理の中で recover を呼び出すように実装した場合、プログラムの実行は継続されます。 package main import &#34;log&#34; func hello() { // パニックをハンドルするための処理を defer 登録 defer func() { if err := recover(); err != nil { log.Printf(&#34;ぎゃー: %v&#34;, err) } }() // out of range エラーをわざと発生させる println([]int{}[0]) } func main() { hello() println(&#34;パニックが発生してもここまで処理が継続される&#34;) } 実行結果 2017/09/11 23:21:10 ぎゃー: runtime error: index out of range 2017/09/11 23:21:10 パニックが発生してもここまで処理が継続される 参考: Handling panics - The Go Programming Language"},{url:"/p/jruz369/",title:"型キャストと型アサーションによる型変換",date:"2017-09-11T00:00:00+09:00",body:`型キャストと型アサーションによる型変換 Go 言語では暗黙的な型キャストは許されていません。明示的な型変換関数を使用するか、Type Assertion という仕組みを使用して型の変換を行う必要があります。 型キャスト Go 言語では暗黙的な型変換は許されていないため、下記のような異なる型の変数への代入はコンパイルエラーになります。 var i int = 100 var f float64 = i // cannot use i (type int) as type float64 このようなケースでは、型名(値) という形で明示的な 型キャスト を行います。 var i int = 100 var f float64 = float64(i) // OK 下記は様々な型変換の例です。 int8 → int32 var a uint8 = 100 var b uint32 = uint32(a) int32 → int8 var a uint32 = 1234567890 var b uint8 = uint8(a) fmt.Println(b) // 210（情報が欠落する） string → []byte var str string = &#34;ABC&#34; var bytes []byte = []byte(str) fmt.Println(bytes) // [65 66 67] []byte → string bytes := []byte{65, 66, 67} str := string(bytes) fmt.Println(str) // &#34;ABC&#34; 型アサーション (Type Assertion) による型変換 Go 言語で任意の型の変数（型の定まっていない変数）は、空インタフェース型 (interface{}) として表現されます。 このような値を、特定の型 T の変数に代入するには、型アサーション (Type Assertion) という仕組みを使用する必要があります。 型アサーションは、下記のような構文で実行します。 var x = i.(T) x := i.(T) // 関数内であればこの省略形で OK これにより、空インタフェース型 (interface{}) の変数 i が、型 T の変数 x に代入されます。 空インタフェース型の i を、型 T に変換できない場合は パニック が発生します。 下記の doGreet 関数は、パラメータで受け取った任意の型のオブジェクトに対して、Greet メソッドを実行します。 空インタフェースは Greet メソッドを備えていないので、まずは、i.(Greeter) という型アサーションで Greeter 型に変換してから Greet メソッドを呼び出しています。 type Greeter interface { Greet() } func doGreet(i interface{}) { g := i.(Greeter) g.Greet() } 上記の doGreet 関数は、Greet() メソッドを実装したオブジェクトを渡された場合にうまく動作します。 下記のサンプルでは、Greet() メソッドを実装した People 構造体のオブジェクトを、doGreet 関数に渡しています。 type People struct { Name string } func (this *People) Greet() { fmt.Printf(&#34;Hello, I am %s\\n&#34;, this.Name) } func main() { p := &amp;People{&#34;Maku&#34;} doGreet(p) //=&gt; &#34;Hello, I am Maku&#34; } 逆に、Greet() メソッドを実装していないオブジェクトを doGreet 関数に渡すと、型アサーションによる型変換に失敗し、パニックが発生します。 doGreet(&#34;Hoge&#34;) // panic: interface conversion: // string is not main.Greeter: missing method Greet このように、実際に実行するまでパニックが発生するかどうか分からないような関数は、安心して実行することができません。 そこで、型アサーションには、型変換がうまくいったかどうかを調べる構文が用意されています（マップ のキーの有無を確認する構文と同じです）。 x, ok := i.(T) 上記のように、2 つの戻り値を受け取るように型アサーションを実行すると、2 番目の戻り値 (bool) で、型変換に成功したかどうかを判別することができます。 型変換に失敗してもパニックは発生せず、x には型 T のゼロ値が格納されます。 下記の doGreet 関数は、渡された interface{} オブジェクトを Greeter 型に変換できるか確認し、変換できた場合のみ Greet() メソッドを呼び出しています。 func doGreet(i interface{}) { if g, ok := i.(Greeter); ok { g.Greet() } else { fmt.Printf(&#34;Type %T is not Greeter\\n&#34;, i) } } func main() { doGreet(&amp;People{&#34;Maku&#34;}) //=&gt; Hello, I am Maku doGreet(100) //=&gt; Type int is not Greeter doGreet(0.5) //=&gt; Type float64 is not Greeter doGreet(&#34;Hoge&#34;) //=&gt; Type string is not Greeter } ちなみに、より多くの型への型変換を試みなければならないケース (Printf のような関数の実装）では、型スイッチの構文 を使用するとより簡潔に記述することができます。`},{url:"/p/s4qbuez/",title:"Hugo で独自のテーマを作成する",date:"2017-09-10T00:00:00+09:00",body:"Hugo で独自のテーマを作成する 独自テーマの新規作成 Hugo には、ネット上に公開されているテンプレートがたくさんありますが、思い通りのデザインをするときは、自分でテーマを作成することになります。 テーマを作成するときは、まずは下記のコマンドで雛形を出力します。 $ hugo new theme &lt;テーマ名&gt; 例えば下記のように実行すると、themes/my-theme ディレクトリが生成されます。 $ hugo new theme my-theme 生成されるファイル群は下記のようになっていて、ディレクトリ構成はバッチシできていますが、ファイル内の記述はほとんど空っぽです。 このファイル群をベースにして、テンプレートを作成していきます。 独自テーマの雛形 themes/my-theme/ ├── LICENSE.md （MIT ライセンス） ├── archetypes/ │ └── default.md （ほぼ空っぽ） ├── layouts/ │ ├── 404.html （空っぽ） │ ├── _default/ │ │ ├── list.html （空っぽ） │ │ └── single.html （空っぽ） │ ├── index.html （空っぽ） │ └── partials/ │ ├── footer.html （空っぽ） │ └── header.html （空っぽ） ├── static/ │ ├── css/ │ └── js/ └── theme.toml （デフォルトの設定ファイル） トップページのレイアウト (layouts/index.html) を作成する 図: 独自テーマを使ったはじめてのページ テーマディレクトリ内の layouts/index.html は、サイトのトップページ用のテンプレートファイルです。 もし、ひとつの HTML ファイルだけで構成されるサイト (SPA: Single Page Application) を作成するのであれば、このファイルだけを作成すればよいことになります。 初期状態では何も記述されていないので、まずは手始めに、サイト名だけを表示するように修正してみましょう。 themes/my-theme/layouts/index.html &lt;h1&gt;{{ .Site.Title }}&lt;/h1&gt; 上記のようにすると、サイト情報を保持する .Site 変数の、Title フィールドの値を出力することができます。 ここには、サイトの設定ファイル (config.toml) の title に設定した値が展開されます。 ここまで作成したら、このテーマを使ってサイトを表示してみましょう。 hugo コマンドで使用するテーマを指定するには、-t &lt;テーマ名&gt; オプションを使用します。 $ hugo server -t my-theme 上記のように Hugo サーバを立ち上げたら、http://localhost:1313/ にアクセスすれば、表示を確認できます。 トップページに全ページのリストを表示する トップページのテンプレート (layouts/index.html) 内で、.Data.Pages 変数を参照すると、すべてのページの情報 (Page 変数) を取得することができます。 この情報を range を使ってループ処理すれば、すべてのページへのリンクを出力することができます。 themes/my-theme/layouts/index.html &lt;h1&gt;{{ .Site.Title }}&lt;/h1&gt; &lt;ul&gt; {{ range .Data.Pages }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt; ({{ .Date.Format &#34;2006-01-02&#34; }})&lt;/li&gt; {{ end }} &lt;/ul&gt; 各ページ用のレイアウトを作成する (layouts/_default/single.html) リンク先の各ページは、layouts/_default/single.html テンプレートファイルを元に生成されるので、このファイルもあらかじめ作成しておく必要があります。 このテンプレートの中では、Page 変数 のフィールドを参照することができます。 例えば、.Title でページタイトル、.Content でページ本文を参照できます。 themes/my-theme/layouts/_default/single.html &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ .Content }} 各ページの内容は、content/ ディレクトリ内に下記のような感じで作成しておきます。 content/page1.md --- title: &#34;Page1 Title&#34; date: &#34;2017-09-10&#34; --- Page1 Content 上記のようにレイアウトファイルとコンテンツを作成しておけば、各ページの内容が下記のように表示されるはずです。 図: シングルページテンプレートによる出力 あとは、同様にして layouts ディレクトリ内のテンプレートコードを育てていくことで独自テーマが完成します。 Markdown ファイルから使える ショートコード なども独自テーマの付属品 (layouts/shortcodes) として提供できます。"},{url:"/p/z8behko/",title:"テンプレート機能を使用する (text/template, html/template)",date:"2017-09-10T00:00:00+09:00",body:"テンプレート機能を使用する (text/template, html/template) Go には標準パッケージとしてテンプレート機能が用意されています。 テンプレート機能は、定型の Web ページ作成などに活用できます。 ２つのテンプレートパッケージ Go 言語には、組込みのテンプレート・パッケージとして、text/template と html/template パッケージが搭載されています。 Web ページの構築に使用する場合は、パラメータを HTML エスケープ処理してくれる html/template パッケージの方を利用します。 text/template Package html/template Package テンプレート機能の基本的な使い方 Template オブジェクトの生成 テンプレート機能を使用するには、まずは Template オブジェクトを生成します。 テンプレートファイルを使用する場合は template.ParseFiles 関数、文字列データをテンプレートとして使用する場合は template.Parse 関数を使用します。 t, err := template.ParseFiles(&#34;./template.html&#34;) if err != nil { log.Fatal(err) } テンプレートファイルのパース処理が成功することが分かっている場合は、次のように template.Must 関数を組み合わせて使用することで、エラー処理の記述を省略することができます（エラーになった場合は panic が発生します）。 t := template.Must(template.ParseFiles(&#34;./template.html&#34;)) テンプレートへの値の埋め込み テンプレートへの値の埋め込みは、Template オブジェクトの Execute メソッドによって行います。 第一引数には出力先、第二引数には埋め込むデータを渡します。 data := &#34;Hello World&#34; if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } 渡されたデータは、テンプレートファイル内の、{{ . }} という部分に展開されます。 この構文は、Hugo という静的サイトジェネレーターを使っている場合はおなじみかもしれません。 下記はシンプルなテンプレートファイルの例です。 template.html &lt;h1&gt;{{ . }}&lt;/h1&gt; 出力結果 &lt;h1&gt;Hello World&lt;/h1&gt; 全体のコード sample.go package main import ( &#34;html/template&#34; &#34;log&#34; &#34;os&#34; ) func main() { // テンプレートの読み込み t := template.Must(template.ParseFiles(&#34;./template.html&#34;)) // 値の埋め込み data := &#34;Hello World&#34; if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } テンプレートへの入力データとしてマップや構造体を使用する Template オブジェクトの Execute メソッドには、単純な文字列だけではなく、マップや構造体を渡すこともできます（こちらの方が一般的）。 下記のコードでは、３つのキーを持つマップを渡しています。 data := map[string]int{ &#34;key1&#34;: 100, &#34;key2&#34;: 200, &#34;key3&#34;: 300, } if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } 渡されたデータは、テンプレート内で {{ .キー名 }} で参照することができます。 &lt;ul&gt; &lt;li&gt;{{ .key1 }} &lt;li&gt;{{ .key2 }} &lt;li&gt;{{ .key3 }} &lt;/ul&gt; 次のサンプルコードでは、構造体のオブジェクトをテンプレートに渡しています。 type Book struct { Title string Author string } data := Book{Title: &#34;Golang&#34;, Author: &#34;Maku&#34;} if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } テンプレートに渡された構造体の各フィルードの値も、マップの場合と同様な形式でアクセスすることができます。 &lt;ul&gt; &lt;li&gt;{{ .Title }} &lt;li&gt;{{ .Author }} &lt;/ul&gt; 構造体のフィールドとして、構造体やマップを持っているようなケースでは、次のようにドットで連鎖させることで参照できます。 &lt;h1&gt;{{ .Site.Title }}&lt;/h1&gt; テンプレート内でのループ処理 range キーワードを使用すると、テンプレートファイル内でループ処理を行うことができます。 template.html &lt;ul&gt; {{ range . }} &lt;li&gt;{{ . }} {{ end }} &lt;/ul&gt; sample.go package main import &#34;html/template&#34; import &#34;os&#34; func main() { t := template.Must(template.ParseFiles(&#34;./template.html&#34;)) data := []string{&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;} if err := t.Execute(os.Stdout, data); err != nil { log.Fatal(err) } } 出力結果 &lt;ul&gt; &lt;li&gt;AAA &lt;li&gt;BBB &lt;li&gt;CCC &lt;/ul&gt; Go 言語のように、インデックスと値を取得しながらループ処理することもできます。 &lt;ul&gt; {{ range $i, $val := . }} &lt;ul&gt;{{ $i }} : {{ $val }} {{ end }} &lt;/ul&gt; 出力結果 &lt;ul&gt; &lt;ul&gt;0 : AAA &lt;ul&gt;1 : BBB &lt;ul&gt;2 : CCC &lt;/ul&gt; テンプレートの中からテンプレートをインクードする テンプレートファイルの中で、template 関数を使用すると、別のテンプレートファイルの内容をそこに展開することができます。 template.html &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt; {{ template &#34;partial.html&#34; . }} &lt;/p&gt; partial.html Hello, &lt;b&gt;{{ . }}&lt;/b&gt; 入れ子構造で読み込むテンプレートファイルも、template.ParseFiles 関数で指定しておく必要があります。 sample.go package main import &#34;html/template&#34; import &#34;os&#34; func main() { t := template.Must(template.ParseFiles(&#34;template.html&#34;, &#34;partial.html&#34;)) if err := t.Execute(os.Stdout, &#34;Maku&#34;); err != nil { panic(err) } } 実行結果 &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt; Hello, &lt;b&gt;Maku&lt;/b&gt; &lt;/p&gt; その他 コメント テンプレートファイルの中で、{{/* と */}} で囲んだ部分はコメントと見なされ、テンプレートのコンパイル時に削除されます。 {{/* これはコメント */}} 前後の空白を削除 テンプレート内で値を出力するときに、{{- と -}} で囲むようにすると、前後のスペース（前のタグからそこまでと、そこから後ろのタグまでのスペース）を削除して出力することができます。 template.html（置換部分の前後のスペースを削除） &lt;p&gt; {{- . -}} &lt;/p&gt; 出力結果 &lt;p&gt;Hello&lt;/p&gt; 前方のスペースのみ、あるいは、後方のスペースのみを削除することもできます。 template.html（置換部分の前のスペースだけ削除） &lt;p&gt; {{- . }} &lt;/p&gt; 出力結果 &lt;p&gt;Hello &lt;/p&gt;"},{url:"/p/6eimpsv/",title:"Golang でファイルを読み書きする (os, io)",date:"2017-09-08T00:00:00+09:00",body:`Golang でファイルを読み書きする (os, io) Go 言語でファイルの読み書きを行うには、os パッケージや io パッケージを使用します。 ファイルからバイトデータを読み出す（io.Reader） 既存のファイルを読み込み用にオープンするには、os.Open 関数を使用して下記のようにします。 // ファイルを読み取りオープン file, err := os.Open(&#34;./input.txt&#34;) // *os.File if err != nil { log.Fatal(err) } defer file.Close() // 関数を抜けるときに自動実行 defer キーワードでクローズ処理を登録しておくことで、関数から抜けるときに自動的にファイルクローズを実行してくれるようになります。 ファイルを扱うときは、常にこのように記述しておくことで、関数の途中で return したときなどのクローズ忘れを防ぐことができます。 ファイルを開いてすぐに実行すべきイディオムとして覚えておきましょう。 ファイルのオープンに失敗すると、２番目の戻り値として error オブジェクトが返され、下記のようなエラーメッセージを表示して終了 (log.Fatal) します。 2017/09/08 23:43:40 open ./input.txt: The system cannot find the file specified. ファイルのオープンに成功したら、取得した os.File オブジェクトの Read メソッドを使用して読み出し処理を行います（Read は io.Reader インタフェースで定義されているメソッドです）。 Read メソッドは、引数で渡した []byte スライスにファイルの内容を読み込みます。 一度に読み込むサイズは、パラメータとして渡すスライスの長さ (len(s)) になるため、あらかじめ make 関数などを使ってスライス長を確保しておく必要があります。 Read 関数は、ファイルの末尾まで読み込み終わると、0, io.EOF を返します。 ２番目の戻り値が io.EOF になるまで繰り返し Read を実行するようにすれば、すべてのデータを読み出すことができます。 // 10 バイト分のバッファを用意 buf := make([]byte, 10) // ファイルから読み出し for { count, err := file.Read(buf) if err == io.EOF { break // Reached to EOF } if err != nil { log.Fatal(err) } fmt.Printf(&#34;%q\\n&#34;, buf[:count]) } 下記は、サンプルの入力ファイルと、実行可能な全体のコード、実行結果です。 ここでは、分かりやすさのために入力ファイルとしてテキストファイル (input.txt) を使用していますが、Read メソッドによる読み出しは、通常はバイナリファイルを扱うことを想定しています。 input.txt AAA BBB CCC DDD EEE FFF GGG HHH III sample.go package main import ( &#34;fmt&#34; &#34;io&#34; &#34;log&#34; &#34;os&#34; ) func main() { // ファイルを読み取りオープン file, err := os.Open(&#34;./input.txt&#34;) // *os.File if err != nil { log.Fatal(err) } defer file.Close() // 関数脱出時に実行 // ファイルから読み出し buf := make([]byte, 10) for { count, err := file.Read(buf) if err == io.EOF { break // Reached to EOF } if err != nil { log.Fatal(err) } fmt.Printf(&#34;%q\\n&#34;, buf[:count]) } } 実行結果 $ go run sample.go &#34;AAA BBB CC&#34; &#34;C\\nDDD EEE &#34; &#34;FFF\\nGGG HH&#34; &#34;H III\\n&#34; ファイルを一度に読み出す (os.ReadFile) io.Reader インタフェースで定義されている Read メソッドは、指定したサイズのバイトデータしか読み込めませんが、os.ReadFile を使用すると、ファイル全体を一度に読み出すことができます。 package main import ( &#34;fmt&#34; &#34;log&#34; &#34;os&#34; ) func main() { bytes, err := os.ReadFile(&#34;./input.txt&#34;) if err != nil { log.Fatal(err) } fmt.Println(string(bytes)) // os.Stdout.Write(bytes) } ちなみに、os.ReadFile はファイルの読み出し専用ですが、代わりに io.ReadAll を使用すると、io.Reader を実装した任意のインスタンスから全データを読み出すことができます。 次の例では、string.Reader からすべてのテキストを読み出しています。 r := strings.NewReader(&#34;AAA\\nBBB\\nCCC&#34;) bytes, err := io.ReadAll(r) if err != nil { log.Fatal(err) } fmt.Printf(&#34;%s\\n&#34;, bytes) テキストファイルを 1 行ずつ読み出す (bufio.Scanner) Read([]byte) 関数を使ったファイルの読み出しは、byte スライスによる読み出しになってしまうため、テキストファイルを 1 行ずつ読み出したい場合などに不便です。 テキストファイルを 1 行ずつ読み出すときは bufio.Scanner を使用すると簡単です。 bufio.Scanner を使用すると、テキストファイルの内容を 1 行ごとに string オブジェクトの形で取得していくことができます。 bufio.Scanner オブジェクトは、下記のファクトリ関数で生成することができます。 io.File オブジェクトは Read メソッドを実装しているため、このファクトリ関数のパラメータとして渡すことができます。 func bufio.NewScanner(r io.Reader) *Scanner 下記に、テキストファイル input.txt を 1 行ずつ読み出すサンプルコードを示します。 sample.go package main import ( &#34;bufio&#34; &#34;fmt&#34; &#34;log&#34; &#34;os&#34; ) func main() { // ファイルを読み出し用にオープン file, err := os.Open(&#34;./input.txt&#34;) if err != nil { log.Fatal(err) } defer file.Close() // 1 行ずつ読み出し scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Text() fmt.Println(line) } // スキャン時のエラーをハンドル if err := scanner.Err(); err != nil { log.Fatal(err) } } scanner.Scan のループ処理を抜けた後に、scanner.Err メソッドでエラーの有無をチェックする必要があることに注意してください。 実行結果 $ go run sample.go AAA BBB CCC DDD EEE FFF GGG HHH III ファイルにバイトデータを書き込む (io.Writer, os.WriteFile) io.Writer の Write メソッドを使う方法 ファイルを書き込み用にオープン（新規作成）するには、os.Create 関数を使用します（読み出しのときは os.Open）。 os.Create はファイルのオープンに成功すると *os.File を返します。 os.File の Write([]byte) メソッドを使用して、バイトデータを書き込むことができます。 package main import ( &#34;log&#34; &#34;os&#34; ) func main() { // ファイルを書き込み用にオープン (mode=0666) file, err := os.Create(&#34;./output.txt&#34;) if err != nil { log.Fatal(err) } defer file.Close() data := []byte(&#34;Hello\\nWorld&#34;) _, err = file.Write(data) if err != nil { log.Fatal(err) } } os.WriteFile 関数を使う方法 os.WriteFile 関数を使うと、ファイル名と書き込むバイトデータを指定するだけで、ファイルへの出力を一気に済ませることができます。 package main import ( &#34;log&#34; &#34;os&#34; ) func main() { bytes := []byte(&#34;Hello\\nWorld&#34;) if err := os.WriteFile(&#34;./output.txt&#34;, bytes, 0666); err != nil { log.Fatal(err) } } ファイルに 1 行ずつテキストを書き込む (WriteString) os.File が実装している io.Writer インタフェースの Write([]byte) メソッドは、バイトデータの書き込みを想定しているため、テキストデータの書き込みには不便です（string を []byte に変換する手間がかかります）。 os.File は、実は WriteString(string) というメソッドを備えており、これを使用すると、指定したテキストデータ (string) をそのまま書き込むことができます。 package main import ( &#34;log&#34; &#34;os&#34; ) func main() { // ファイルを書き込み用にオープン (mode=0666) file, err := os.Create(&#34;./output.txt&#34;) if err != nil { log.Fatal(err) } defer file.Close() // テキストを書き込む _, err = file.WriteString(&#34;Hello\\nWorld\\n&#34;) if err != nil { log.Fatal(err) } } 参考: Golang で JSON 形式の文字列やファイルを扱う (encoding/json)`},{url:"/p/5cgjnqt/",title:"マップを扱う (map)",date:"2017-09-05T00:00:00+09:00",body:`マップを扱う (map) Go 言語でマップを定義するには、map キーワードを使用します。 マップを定義する (map) Go 言語のマップ型は、map[キーの型]値の型 のように表現します。 どこにもスペースをいれないことに注意してください（go fmt コマンドで自動的にこのようにフォーマットされます）。 例えば、キーの型を string、値の型を int とするマップは次のように作成できます。 空のマップを作る方法 var m = map[string]int{} m := map[string]int{} // 関数内ではこの省略形が使える m := make(map[string]int) // make を使う方法 次のように初期値を指定せずにマップを作成するとゼロ値 (nil) になります。 要素数ゼロのマップとして参照はできますが、要素を追加しようとすると panic が発生します。 あまり意味のない nil マップの作成方法 var m map[string]int // これはゼロ値 (nil) になる println(len(m)) // 0 m[&#34;maku&#34;] = 14 // panic 配列やスライス と同様、初期値を同時に設定してしまうこともできます（前述の例では初期値を空っぽ {} にしています）。 下記のように複数行に分けて初期値を記述する場合、最後の要素の後ろのカンマは省略できないことに注意してください。 m := map[string]int{ &#34;maku&#34;: 14, &#34;puni&#34;: 7, &#34;hemu&#34;: 10, } fmt.Printf(&#34;%v\\n&#34;, m) //=&gt; map[maku:14 puni:7 hemu:10] マップ要素を参照するときは、配列やスライスと同様に [] を使用してキーを指定します。 存在しないキーを指定して新しい値を設定することもできます。 i := m[&#34;maku&#34;] // 既存の要素の取得 m[&#34;panyo&#34;] = 20 // 新しい要素を追加 マップの要素を for ループで処理する (range) マップの要素は、配列やスライスと同様に for ループと range を使ってひとつずつ取得することができます。 m := map[string]int{ &#34;maku&#34;: 14, &#34;puni&#34;: 7, &#34;hemu&#34;: 10, } for k, v := range m { fmt.Printf(&#34;key: %s, value: %d\\n&#34;, k, v) } 実行結果 key: maku, value: 14 key: puni, value: 7 key: hemu, value: 10 あるキーが存在するかどうか調べる マップに存在していないキーを指定すると、値の型の ゼロ値 が返されます（例えば int 型の値であれば 0 です）。 i := m[&#34;panyo&#34;] //=&gt; 0 そのため、マップの値を参照してゼロ値が返された場合、「キーが存在しない」のか、あるいは「値として 0 が格納されている」のかを区別することができません。 キーがもともと存在していたのかどうかを判別するには、2 つ目の戻り値として返される bool 値 を参照します。 val, ok := m[&#34;maku&#34;] if ok { println(val) } else { println(&#34;見つからない&#34;) } 取得した値を if ブロックの中でしか参照しないのであれば、下記のように変数スコープを限定してしまうのがよいです。 if val, ok := m[&#34;maku&#34;]; ok { println(val) } else { println(&#34;見つからない&#34;) } キーの存在のみを調べたいときは、1 つ目の戻り値をアンダースコア (_) で受け取って無視します。 if _, ok := m[&#34;maku&#34;]; ok { println(&#34;あるよ&#34;) } マップの要素を削除する (delete) 組み込み関数の delete を使用すると、マップから指定したキーの要素を削除することができます。 m := map[string]int{ &#34;maku&#34;: 100, &#34;pani&#34;: 200, } println(len(m)) //=&gt; 2 println(m[&#34;maku&#34;]) //=&gt; 100 delete(m, &#34;maku&#34;) // キー &#34;maku&#34; を削除する println(len(m)) //=&gt; 1（サイズが減っている） println(m[&#34;maku&#34;]) //=&gt; 0（存在しないキーを参照するとゼロ値が返される） 削除しようとしたキーが存在しなかった場合は、何も実行されません（エラーにはなりません）。 マップの値としてマップを持つ マップの値にマップを持つマップを定義することもできます。 値として map[string]int というマップを持つマップを定義する m := map[string]map[string]int{ &#34;maku&#34;: {&#34;aaa&#34;: 10, &#34;bbb&#34;: 20}, &#34;puni&#34;: {&#34;aaa&#34;: 30, &#34;bbb&#34;: 40}, &#34;hemu&#34;: {&#34;aaa&#34;: 50, &#34;bbb&#34;: 60}, } fmt.Println(m[&#34;maku&#34;][&#34;aaa&#34;]) //=&gt; 10 この場合も、型名にはどこにもスペースを入れてはいけません。 若干読みにくいですが、気合いで読み解きましょう。 マップのキーでソートした順に要素を取り出す Go 言語には、マップをキー順にソートしてループ処理する簡潔な方法はないようです。 以下のサンプルでは、キーのリストを自力で作成し、そのリストをソートしています。 main.go package main import &#34;fmt&#34; import &#34;sort&#34; func main() { m := map[string]int{ &#34;ccc&#34;: 10, &#34;aaa&#34;: 20, &#34;bbb&#34;: 30, } // ソート済みのキーリストを作成する keys := make([]string, 0, len(m)) for k := range m { keys = append(keys, k) } sort.Strings(keys) // キーの型が int なら sort.Ints とする // キーリストの順番通りに値を列挙する for _, k := range keys { fmt.Println(&#34;key:&#34;, k, &#34;value:&#34;, m[k]) } } 実行結果 $ go run main.go key: aaa value: 20 key: bbb value: 30 key: ccc value: 10`},{url:"/p/4behkor/",title:"メソッドを定義する（レシーバ付き関数）",date:"2017-09-05T00:00:00+09:00",body:"メソッドを定義する（レシーバ付き関数） Go 言語にはクラスは存在しませんが、構造体型にメソッドを追加するという方法で同様のことを実現することができます。 メソッドは次のような文法で定義します。 func (レシーバ) 関数名(パラメータ) 戻り値 { ... } 通常の関数定義の関数名の前に、(レシーバ) という部分が追加されただけです。 例えば、下記の raisePrice メソッドは、レシーバとして Book オブジェクトを受け取り、そのフィールド値を書き換えます。 パラメータと戻り値はありません。 func (b *Book) raisePrice() { b.Price *= 2 } フィールド値を書き換える場合は、このようにレシーバをポインタ型で指定する必要があります。 このメソッドを呼び出すには、次のようにレシーバとして渡すオブジェクトにドットを付けて呼び出します。 b.raisePrice() // raisePrice メソッドの呼び出し 下記は、完全に動作するサンプルコードです。 package main // Book 構造体を定義 type Book struct { Title string Price int } // Book 構造体にメソッドを追加 func (b *Book) raisePrice() { b.Price *= 2 } func main() { b := Book{Title: &#34;Golang&#34;, Price: 2500} println(b.Price) // 2500 b.raisePrice() println(b.Price) // 5000 }"},{url:"/p/8z2o63r/",title:"構造体を定義する (struct)",date:"2017-09-05T00:00:00+09:00",body:"構造体を定義する (struct) Go 言語の構造体は、struct というキーワードを使って定義します。 構造体の基本 構造体は、複数のデータをまとめて扱うためのデータ構造です。 下記の例では、書籍のタイトルと著者、値段をフィールドとして持つ Book という構造体を定義しています。 type Book struct { Title string Authors []string Price int } 組込み型に別名を付ける ときには type Age int のように記述しますが、この後ろの int の部分が struct {...} という記述に置き換わったと考えればよいでしょう。 定義した構造体は下記のように使用することができます。 // Book 構造体を定義する type Book struct { Title string Authors []string Price int } func main() { // Book オブジェクトを生成する b := Book{ Title: &#34;Golang ABC&#34;, Authors: []string{&#34;Maku&#34;, &#34;Moja&#34;}, Price: 2500, } // 各フィールドの値を参照する fmt.Println(b.Title) // Golang ABC fmt.Println(b.Authors) // [Maku Moja] fmt.Println(b.Price) // 2500 } この例では、各フィールドの 名前を大文字で始めている（例えば Title）ので、そのフィールドは別のパッケージからも参照可能なフィールドとして公開されます。 逆に小文字で始める（例えば title）ように定義すると、そのフィールドは同じパッケージ内のコードからのみ参照できるようになります（≒ 同じディレクトリ内の .go ファイルであれば参照できる）。 ちなみに、オブジェクトを生成するときに、下記のようにフィールド名を省略して初期値を設定することもできます。 その場合は、構造体定義時と同じ順序で、すべてのフィールドの初期値を指定する必要があります。 b := Book{&#34;Golang ABC&#34;, []string{&#34;Maku&#34;, &#34;Moja&#34;}, 2500} フィールド名を指定する方法であれば、任意のフィールドの初期値を省略してオブジェクトを生成することができます。 省略したフィールドの値は、その型の ゼロ値 となります。 // すべてのフィールドを省略 b1 := Book{} //=&gt; &#34;&#34;, [], 0 // Title フィールドだけ初期値を指定 b2 := Book{Title: &#34;Golang&#34;} //=&gt; &#34;Golang&#34;, [], 0 構造体へのポインタ 関数に渡された構造体データのフィールドを書き換えたいときは、ポインタ型で渡す必要があります（そうしないとコピーが渡されてしまいます）。 下記サンプルの、raisePrice 関数は、渡された Book オブジェクトの Price フィールドの値を２倍に書き換えます。 func raisePrice(b *Book) { b.Price *= 2 } func main() { b := Book{ Title: &#34;Golang ABC&#34;, Price: 2500, } raisePrice(&amp;b) fmt.Println(b.Price) //=&gt; 5000（2倍になってる） } C/C++ の文法とは異なり、ポインタ経由のフィールドアクセスにもドット (.) を使用していることに注目してください。 C/C++ の場合: b-&gt;Price Go の場合: b.Price Go 言語では、ポインタ経由のアクセスも同じ記法を使えるようにすることで、コードをシンプルに保てるようにしています。 この性質を利用すると、上記の main 関数は下記のように書き直すことができます。 変数 b を最初からポインタ型として定義してしまうことで、それ以降のコードで &amp;b のような形でアドレス取得する手間を省くことができます（ここでは一か所だけですけどね＾＾）。 func main() { b := &amp;Book{ Title: &#34;Golang ABC&#34;, Price: 2500, } raisePrice(b) fmt.Println(b.Price) } ここでのサンプルコードでは、raisePrice 関数のパラメータとして Book ポインタを受け取るように実装しましたが、オブジェクト指向風に実装するのであれば、メソッドの形で実装 してしまえばシンプルになります。 new 関数による初期化 すべてのフィールドをゼロ値で初期化したオブジェクトを生成するときは、new(型) という組込み関数を使って C++ 風の書き方をすることもできます。 new 関数の戻り値は、指定した型のポインタとなります。 空のオブジェクトを生成する方法いろいろ var b *Book = new(Book) var b *Book = &amp;Book{} // 関数内なら次のように簡潔に書けます b := new(Book) b := &amp;Book{} &amp;Book{} の形式を使うとタイプ数を削減できますが、new(Book) の方がわかりやすいかもしれません。"},{url:"/p/cuxyj8c/",title:"組込み型に独自の型名を付ける (type)",date:"2017-09-05T00:00:00+09:00",body:`組込み型に独自の型名を付ける (type) 独自型を定義する Go 言語で type キーワードを使用すると、組込み型に新しい名前を付けることができます。 これは単なるエイリアスではなく新しい型として認識されるので、コンパイル時の型チェックの対象となり、コーディングミスを減らすことができます。 また、自身の値を操作対象とするメソッドを追加することができます。 次のような構文で、既存の組込み型をベースにして、新しい型を定義することができます。 type 型名 既存の型 下記の例では、string 型と同じように使用できる Title 型と Author 型を定義しています。 type Title string type Author string 独自型で型安全なコードを記述する 独自に定義した型を関数のパラメータの型として使うことで、コンパイル時に正しい型のデータが渡されているかをチェックしてくれるようになります。 独自型を使った型安全なコード package main import &#34;fmt&#34; type Title string type Author string func printBook(title Title, author Author) { fmt.Printf(&#34;Title:&#39;%s&#39;, Author:&#39;%s&#39;\\n&#34;, title, author) } func main() { t := Title(&#34;Golang ABC&#34;) // var t Title = &#34;Golang ABC&#34; でも OK a := Author(&#34;Maku&#34;) // var a Author = &#34;Maku&#34; でも OK printBook(t, a) } 上記の printBook 関数は、パラメータとして Title、Author 型の値を受け取るように定義しているため、組み込み型の string 変数を渡そうとするとコンパイルエラーになります。 エラーになる例 t := &#34;Golang ABC&#34; // これは標準の string 型 a := &#34;Maku&#34; printBook(t, a) // Error: cannot use t (type string) as type Title このチェックのおかげで、Title と Author の順番を間違えて渡してしまうといったコーディングミスを防ぐことができます。 ただし、下記のように文字列リテラルを直接渡してしまうと、コンパイルエラーとしては検出してくれないので注意してください。 printBook(&#34;Golang ABC&#34;, &#34;Maku&#34;) // これはエラーにならない 独自型にメソッドを追加する 新しい型を作成することのもうひとつの利点として、メソッドによる拡張があります。 int や string などの組み込み型にはメソッドを追加することはできませんが、独自の型には追加できます。 例えば、次の Age 型（中身は int）は String() メソッド（fmt.Stringer インタフェース）を実装し、fmt.Println などに渡したときの出力をカスタマイズしています。 package main import &#34;fmt&#34; type Age int func (a Age) String() string { return fmt.Sprintf(&#34;%d years old&#34;, a) } func main() { a := Age(14) fmt.Println(a) //=&gt; 14 years old }`},{url:"/p/nwqjyx8/",title:"Vim で編集中のスクリプト（Ruby や Python など）をショートカットキーで実行する",date:"2017-09-04T00:00:00+09:00",body:"Vim で編集中のスクリプト（Ruby や Python など）をショートカットキーで実行する Vim の :autocmd コマンドを使用すると、編集中のファイルの種類に応じた設定を行うことができます。 参考: autocmd で自動コマンドを登録する これと :map コマンドを組み合わせて使用することで、単一のショートカットキー（例えば F5 キー）で編集中のスクリプトを、適切な処理系（python コマンドなど）で実行することができるようになります。 競技プログラミングなどでは、現在編集中のソースコードをさくっとコンパイルして、main 関数の実行結果をさくっと表示できると便利です。 .vimrc（Windows の場合は _vimrc） &#34; File type detection is On. filetype on augroup vimrc &#34; Remove all autocommands in this group autocmd! &#34; &lt;F5&gt; key execution autocmd FileType java nmap &lt;buffer&gt; &lt;F5&gt; :!javac -encoding UTF-8 % &amp;&amp; java %&lt;&lt;CR&gt; autocmd FileType javascript nmap &lt;buffer&gt; &lt;F5&gt; :!node %&lt;CR&gt; autocmd FileType php nmap &lt;buffer&gt; &lt;F5&gt; :!php %&lt;CR&gt; autocmd FileType python nmap &lt;buffer&gt; &lt;F5&gt; :!python %&lt;CR&gt; autocmd FileType ruby nmap &lt;buffer&gt; &lt;F5&gt; :!ruby %&lt;CR&gt; autocmd FileType go nmap &lt;buffer&gt; &lt;F5&gt; :!go run %&lt;CR&gt; autocmd FileType groovy nmap &lt;buffer&gt; &lt;F5&gt; :!groovy %&lt;CR&gt; autocmd FileType vim nmap &lt;buffer&gt; &lt;F5&gt; :source %&lt;CR&gt; augroup END ☝️ ワンポイント 上記のように、nmap によるキーマップ設定時に &lt;buffer&gt; オプションを指定すると、キーマップ設定がカレントバッファにのみ反映されるようになります。 上記の例では、各言語のソースコードを編集中に &lt;F5&gt; キーを押すことで、次のような処理を実行するように設定しています。 編集中のファイルのタイプ 実行する処理 Java ファイル javac -encoding UTF-8 ファイル名 でビルドし、さらに java コマンドでそのクラスの main メソッドを起動 JavaScript ファイル node ファイル名 を実行 PHP ファイル php ファイル名 を実行 Python ファイル python ファイル名 を実行 Ruby ファイル ruby ファイル名 を実行 Go ファイル go run ファイル名 を実行 Groovy ファイル groovy ファイル名 を実行 Vim ファイル Vim 自身の :source コマンドで実行 これら以外の言語に対しても、同じように追加していくことができます。 下記は、さらに C++ プログラム用に clang++ コマンドを使用してコンパイル＆実行できるようにした例です。 例: F5 キーで C/C&#43;&#43; コードをコンパイル＆実行 augroup vimrc &#34; ...省略... autocmd FileType c,cpp nmap &lt;buffer&gt; &lt;F5&gt; :DoClang&lt;CR&gt; augroup END &#34; C/C++ コードをコンパイル＆実行する関数 command! DoClang call s:DoClang() function! s:DoClang() if has(&#34;win64&#34;) :!clang++ % -o %&lt;.exe &amp;&amp; %&lt;.exe else :!clang++ % -o %&lt;.out &amp;&amp; ./%&lt;.out endif endfunction この例では、autocmd の末尾に直接実行するコマンドを記述するのではなく、DoClang という独自定義の関数を呼び出してコンパイルと実行を行うようにしています。"},{url:"/p/rj6oatw/",title:"Vim の autocmd で自動コマンドを登録する",date:"2017-09-04T00:00:00+09:00",body:"Vim の autocmd で自動コマンドを登録する autocmd の概要 Vim の autocmd コマンドを使って自動コマンドを登録しておくと、ファイルのオープン時、保存時、カーソル移動時など、様々なタイミングで任意の処理を行えるようになります。 例えば、下記のようなことが行えます。 プログラミング言語のソースコードを開いたときに、言語に応じてインデントを設定する 圧縮されたテキストファイルを開いたときに、自動的に解凍してテキストを編集できるようにする（保存するときに再び自動で圧縮する） ノーマルモードに戻った時に、IME（日本語入力モード）をオフにする 日記ファイルを開いたときに自動で本日の日付を挿入する ファイルの種類によって異なる種類のキーワードハイライト設定を有効にする 下記は具体的な autocmd コマンドの使い方のサンプルです。 例: .txt ファイルを編集するときはタブキー入力をスペースに展開する :autocmd BufEnter *.txt setlocal expandtab autocmd コマンドに関する詳細なドキュメントは、Vim から :help autocmd.txt と入力して参照することができます。 下記サイトでも同じ内容のドキュメントを読むことができます。 autocmd - Vim Documentation（日本語） autocmd - Vim Documentation（英語） autocmd は構文が若干複雑なのでとっつきにくいのですが、使いこなせると非常に便利なので、是非ここで使い方をマスターしましょう。 autocmd で自動コマンドを設定する :autocmd ＜イベント＞ ＜ファイルパターン＞ ＜実行コマンド＞ という形式で :autocmd を実行すると、＜ファイルパターン＞ に一致するファイルにおいて、＜イベント＞ が発生したときに、＜実行コマンド＞ が実行されるようになります。 例: .html ファイルを読み込んだときに（この設定ファイルと）同じディレクトリにある html.vim を実行する :autocmd BufNewFile,BufRead *.html source &lt;sfile&gt;:h/html.vim 上記では、分かりやすくするために、＜イベント＞、＜ファイルパターン＞、＜実行コマンド＞ を 2 文字分のスペースで区切っています。 イベント ＜イベント＞ の部分に指定できるイベント名は、下記のヘルプに一覧があります。 autocmd-events - Vim Documentation イベント名はヘルプファイル上では CamelCase の形式で記載されていますが、イベント名の大文字と小文字の違いは無視されます。 複数のイベントに対して同じ自動コマンドを登録したいときは、イベント名をカンマで並べて指定することができます。 ただし、カンマの前後にスペースを入れてはいけないことに注意してください（例: BufNewFile,BufRead）。 BufNewFile イベントは新しいファイルを作成するときに発生し、BufRead インベントは既存のファイルを読み込んだときに発生します。 ファイルパターン ＜ファイルパターン＞ の部分には、対象とするファイルを下記のような感じで指定します。 パターン 説明 * すべてのファイル *.html 拡張子 .html を持つファイル *.txt,*.info 拡張子 .txt あるいは .info を持つファイル（カンマの前後にスペースを入れてはいけません） */tests/*.java ファイルパスのどこかに tests ディレクトリを含む *.java ファイル ~/.vimrc ホームディレクトリ内の .vimrc ファイル ディレクトリセパレータは、Windows の場合でもスラッシュ (/) を使用することに注意してください。 バックスラッシュ (\\) は特殊な意味を持つため、ディレクトリセパレータとしては使用できません。 ファイルパターンの指定には、*.txt のような指定だけではなく、*/doc/*.txt というワイルドカードの組み合わせも指定できます。 この場合、任意のパスにある doc ディレクトリ以下の *.txt ファイルにマッチするようになります。 例えば、あるプロジェクト内のソースコードだけ、特殊なインデントで編集したい場合などに利用できます。 例: mysite ディレクトリ以下の .md ファイルのみタブのスペース数を 2 に設定する :autocmd BufEnter */mysite/*.md setl expandtab tabstop=2 shiftwidth=2 softtabstop=2 shiftround アスタリスク (*) は、ディレクトリセパレータを含む任意のパスにマッチするので、上記の指定は、/Users/maku/mysite/aaa/bbb/ccc.md といった深い階層にあるファイルにもマッチします。 ＜イベント＞ に FileType を指定した場合（ファイルタイプの変更イベントを監視）は、ファイル名のパターンの代わりに c,cpp や java のようなファイルタイプ名を指定することができます。 例: C/C&#43;&#43; と Java のソースコードのインデント方法を設定する :autocmd FileType c,cpp,java setl cindent expandtab tabstop=4 shiftwidth=4 softtabstop=4 shiftround autocmd の一覧を表示する autocmd コマンドをパラメータなしで実行すると、現在登録されている自動コマンド (autocommands) の一覧を表示することができます。 すべての autocmd を列挙する :autocmd イベント名を指定すると、そのイベント用に登録されている自動コマンドのみを列挙することができます。 FileType イベント用の autocmd を列挙する :autocmd FileType 自動コマンドのグループ化と設定のクリア (augroup, autocmd!) autocmd は、実行するたびに自動コマンドを追加していきます。 つまり、.vimrc に autocmd の定義が書かれている場合に、その .vimrc を何度も source で読み込んでいると、同じ自動コマンドが重複して登録されてしまいます。 このような自動コマンドの重複登録を避けるには、autocmd による各種自動コマンドの登録前に、autocmd! を呼び出すことで前回登録した自動コマンドをクリアするようにします。 Vim のヘルプ (:help autocmd.txt) には、次のようにグループ単位で自動コマンドの登録をクリアする方法が示されています。 ~/.vimrc augroup hoge autocmd! &#34; Clear the autocommands in the hoge group first au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim augroup END この例のように、augroup hoge &hellip; augroup END というブロック内に処理を記述すると、autocmd! による自動コマンドのクリアや、autocmd による自動コマンドの登録が hoge という自動コマンドグループに対して作用するようになります。 hoge というグループ名の部分は、任意の名前を付けることができますが、end や END はグループブロックの終了を表すキーワードとして使用されるため、グループ名としては使用できません。 より明確に言うと、augroup END という宣言は、それ以降の autocmd 対象グループをデフォルトグループに変更するという意味を持っています。 結果として、上記の例のように記述しておくと、最初にすべての自動コマンドをクリアし、改めて autocmd で自動コマンドを登録し直していくという動作になります。 これにより、.vimrc ファイルをリロード (:source ~/.vimrc) したときに、自動コマンドが重複登録されるのを防ぐことができます。 ちなみに、自動コマンドの登録を上記のようにグルーピングしておくことで、登録されている自動コマンドの一覧をそのグループに絞って確認することができるようになります。 例: hoge グループに登録された自動コマンドの一覧を表示する :autocmd hoge いろいろな autocmd の例 &#34; C++ のソースコードを編集するときは、タブキーでスペースによるインデントを挿入する :autocmd FileType cpp setlocal expandtab &#34; Makefile を編集するときは、タブキーでタブ文字をそのまま挿入する :autocmd FileType make setlocal noexpandtab &#34; ~/.vimrc を保存したときは直ちにリロードする（source コマンドで変更を反映する） :autocmd BufWritePost ~/.vimrc source ~/.vimrc &#34; 拡張子 .cpp のファイルを開いたバッファに入るとき、~/.vimrc_cpp を実行する :autocmd BufEnter *.cpp source ~/.vimrc_cpp &#34; C 言語のソースコードを編集し始めるときに、カーソルを最初の関数に合わせる :autocmd BufRead *.c,*.h 1;/^{ &#34; 新規に .java ファイルを作成する場合にテンプレートファイルを使用する（:e new.java や :tabnew new.java としたとき） :autocmd BufNewFile *.java 0r ~/vim/skeleton.java &#34; 新規に .hello ファイルを作成する場合に Hello というテキストを挿入する :autocmd BufNewFile *.hello put=&#39;Hello&#39;"},{url:"/p/vpz8fnv/",title:"ポインタを扱う (＊)",date:"2017-09-04T00:00:00+09:00",body:`ポインタを扱う (＊) Go 言語には、C/C++ と同様にポインタが存在します。構文もかなり似ていますが、簡潔に記述できるような工夫がされています。 Go 言語のポインタの基本 Go 言語では、変数の型のプレフィックスとしてアスタリスク (*) を付けると、ポインタ型の変数になります。 ポインタ変数は、その型の値が格納されているメモリアドレスを保持します。 ポインタ変数のゼロ値（初期値）は nil です。 var p *int // p is a pointer to int fmt.Printf(&#34;%v\\n&#34;, p) // &lt;nil&gt; 既存の変数のアドレスは &amp; プレフィックスをつけて取得できます。 次の例では、int 型変数 i のアドレスを p に格納しています。 i := 100 p := &amp;i fmt.Printf(&#34;%v (%T)\\n&#34;, i, i) // 100 (int) fmt.Printf(&#34;%v (%T)\\n&#34;, p, p) // 0xc00018a000 (*int) 逆にポインタが指し示す値にアクセスするには、ポインタ変数の前に * を付けて参照します。 下記の例では、ポインタ経由で参照先の値を書き換えています。 var i int = 100 var p *int = &amp;i fmt.Println(i) //=&gt; 100 fmt.Println(*p) //=&gt; 100 *p = 200 // ポインタ経由で値を書き換える fmt.Println(i) //=&gt; 200 fmt.Println(*p) //=&gt; 200 このあたりのポインタの文法は、C/C++ 言語とほとんど同じです。 ただし、Go 言語ではポインタ演算（アドレスの足し算など）を行うことはできません。 そういったアクセスを禁止することで、不正なメモリアドレスへアクセスしてしまう危険性を排除しています。 関数内から呼び出し元の変数の値を書き換える Go 言語の関数のパラメーターは、通常は値渡し（値のコピーが渡される）となるため、下記のような関数を実行しても呼び出し側の数値を変更することはできません。 func add100(n int) { n += 100 // 呼び出し側の値は変更されない } 関数のパラメーターをポインタ型にすると、呼び出し元の変数が格納されているメモリアドレスを受け取ることができます。 そのメモリアドレスに格納されている値を、関数内から直接書き換えることができるようになるため、結果的に呼び出し側でパラメーターとして渡した変数の値を書き換えることができます。 下記のコードでは、int のポインタを受け取り、呼び出し側の int 変数の値を変更しています。 func add100(n *int) { *n += 100 // 呼び出し側の値を変更できる } func main() { n := 50 add100(&amp;n) println(n) //=&gt; 150 }`},{url:"/p/as29hpw/",title:"Go 言語の組込み型一覧",date:"2017-09-01T00:00:00+09:00",body:"Go 言語の組込み型一覧 Go 言語には次のような組込み型が定義されています。 真偽値 bool &hellip; true or false 文字列 string &hellip; 文字列。文字列リテラルは、&quot;あいうえお&quot; のようにダブルクォートで囲んで表現する。文字列は immutable（不変）であり、文字列の内容を部分的に書き換えることはできない（1 文字でも違う場合は、必ず別の文字列を作成する必要がある）。空文字列 (&quot;&quot;) は格納できるが、nil は格納できない。 数値 整数 int &hellip; システム依存サイズの符号あり整数（ただし、少なくとも 32 ビット以上） int8 &hellip; 8 ビット符号あり整数 int16 &hellip; 16 ビット符号あり整数 int32 &hellip; 32 ビット符号あり整数 int64 &hellip; 64 ビット符号あり整数 uint &hellip; システム依存サイズの符号なし整数（ただし、少なくとも 32 ビット以上） uint8 &hellip; 8 ビット符号なし整数 uint16 &hellip; 16 ビット符号なし整数 uint32 &hellip; 32 ビット符号なし整数 uint64 &hellip; 64 ビット符号なし整数 byte &hellip; uint8 のエイリアス 浮動小数点数 float32 &hellip; 32 ビット浮動小数点数 float64 &hellip; 64 ビット浮動小数点数 複素数 complex64 &hellip; 64 ビット複素数 complex128 &hellip; 128 ビット複素数 ポインタ uintptr &hellip; ポインタ値（アドレス）を格納する、システム依存サイズの符号なし整数 文字 rune &hellip; １文字を表す（Unicode のコードポイント）。int32 のエイリアス。文字リテラルは、'あ' のようにシングルクォートで囲んで表現する。 エラー用インタフェース error"},{url:"/p/5dhkoru/",title:"変数を定義する (var)／ゼロ値について",date:"2017-09-01T00:00:00+09:00",body:`変数を定義する (var)／ゼロ値について Go 言語では明示的に型を指定した変数定義と、コンパイラによる型推論を利用した変数定義を行うことができます。 変数定義の基本 Go 言語では、var キーワードを使用して、var 変数名 型名 というフォーマットで変数定義します。 Pascal や Ada のように、型名を後ろに指定することに注意してください。 var x int 同じ型の変数を複数定義するときは、下記のように型名を一度だけ記述するだけで済みます（逆に、var x int, y int, z int のように冗長に記述することはできません）。 var x, y, z int 括弧を使用して複数行に分けて変数定義することもできます。 var ( name string age int ) 変数の初期値を指定する = キーワードを使用して、変数の初期値を指定することができます。 var x int = 100 var a, b int = 100, 200 var ( name string = &#34;Rei Ayanami&#34; age int = 14 ) Go には型推論の仕組みが備わっているため、変数の初期値を指定する場合は、型の記述を省略することができます。 var x = 100 var a, b = 100, 200 var ( name = &#34;Rei Ayanami&#34; age = 14 ) 関数の中で変数を定義するときは、:= を使用することで var と型の記述を両方とも省略することができます。 func hello() { s := &#34;yatta-ne&#34; x, y := 100, 200 // ... } ちなみに、変数の型は fmt.Printf 関数のフォーマット文字列で %T を指定して確認することができます。 func main() { x := 100 fmt.Printf(&#34;%T\\n&#34;, x) //=&gt; int } 変数のグルーピング var ( ... ) というシンタックスは、変数のグルーピングのために利用することもできます。 下記は、本家の Effective Go (Commentary) からの抜粋ですが、エラー情報を表す変数を var ( ... ) でグループ化して定義し、グループに対してコメントを付加しています。 // Error codes returned by failures to parse an expression. var ( ErrInternal = errors.New(&#34;regexp: internal error&#34;) ErrUnmatchedLpar = errors.New(&#34;regexp: unmatched &#39;(&#39;&#34;) ErrUnmatchedRpar = errors.New(&#34;regexp: unmatched &#39;)&#39;&#34;) ... ) ゼロ値 変数の定義時に初期値を指定しなかった場合、それぞれの型の ゼロ値 (Zero Value) が初期値として設定されます。 型 ゼロ値 整数 0 浮動小数点数 0.0 文字列 (string) &quot;&quot;（空文字列） 真偽値 (bool) false 構造体 (struct) 各フィールドがゼロ値の構造体 配列 各要素がゼロ値の配列 その他（ポインタ、スライス、マップ、関数、インタフェース、チャネル） nil 例えば、var i int とだけ記述した場合、i の初期値は 0 になります。 var i int fmt.Println(i); //=&gt; 0 ポインタの初期値は nil です。 var p *int fmt.Println(p); //=&gt; nil`},{url:"/p/6dhkoru/",title:"構造体のコンストラクタ（ファクトリ関数）を定義する",date:"2017-09-01T00:00:00+09:00",body:"構造体のコンストラクタ（ファクトリ関数）を定義する Go 言語には構造体のコンストラクタ用の文法は用意されていません。 通常の関数の形で構造体のファクトリ関数を実装します。 ただ、簡単なプログラムであれば、下記のような初期化リストを使ったオブジェクト生成で間に合ってしまいます。 b := Book{Title: &#34;Title&#34;, Price: 2500} 任意のパラメータからオブジェクトを生成できるようにしたい場合は、New で始まる名前のファクトリ関数を作成し、構造体のポインタを返す のが慣例となっています。 book/book.go package book type Book struct { Title string Author string Price int } func NewAuthorlessBook(title string) *Book { return &amp;Book{ Title: title, Author: &#34;Unknown Author&#34;, Price: 100, } } 上記では、book パッケージの中で Book 構造体とそのファクトリ関数を定義してみました。 外部の main パッケージから使用する場合は、下記のような感じのコードになります。 main.go package main import &#34;fmt&#34; import &#34;local.packages/book&#34; func main() { b := book.NewAuthorlessBook(&#34;The World&#34;) fmt.Printf(&#34;%+v\\n&#34;, b) } 実行結果 $ go run main.go &amp;{Title:The World Author:Unknown Author Price:100}"},{url:"/p/cjosvz3/",title:"配列とスライスを扱う",date:"2017-09-01T00:00:00+09:00",body:`配列とスライスを扱う Go 言語の配列は固定長ですが、スライスを組み合わせて使用することで、可変長配列のように扱うことができます。 配列定義の基本 ([n], [&hellip;]) Go で配列を定義するときは、変数の型名の前に [サイズ] プレフィックスを付けて定義します。 例えば、サイズ 3 の int 配列を定義するには次のようにします。 var arr [3]int variable arr is array 3 of int. と自然な英文として読めるような文法になっています。 配列の各要素には、Java や C/C++ のように 0 から始まるインデックスを指定してアクセスすることができます。 var arr [3]int arr[0] = 100 arr[1] = 200 arr[2] = 300 fmt.Println(arr) //=&gt; [100 200 300] // 下記はビルドエラー (invalid argument: array index 3 out of bounds [0:3]) // arr[3] = 400 次のようにすれば、配列定義と同時に 初期値 を設定することができます。 var arr = [3]int{100, 200, 300} // 関数内であれば次のように書ける arr := [3]int{100, 200, 300} 初期値と指定する要素の数と同じサイズの配列を定義するのであれば、配列サイズを下記のように ... と指定することができます。 var arr = [...]int{100, 200, 300} // 関数内であれば次のように書ける arr := [...]int{100, 200, 300} Go では、サイズの異なる配列は、型が異なるとみなします。 固定サイズの配列をパラメータにとる関数は、同じサイズの配列のみ受け取ることができます。 func myfunc(arr [3]int) { //... } func main() { arr1 := [3]int{100, 200, 300} arr2 := [4]int{100, 200, 300, 400} myfunc(arr1) myfunc(arr2) // Error: cannot use arr2 (type [4]int) as type [3]int } なお、上記のように固定サイズの配列を受け取る関数に配列を渡すと、値渡しで配列が渡されます（値がコピーされる）。 従って、関数内部で配列要素を書き換えても、呼び出し側の配列は変化しません。 呼び出し側の配列の内容を変更するには、後述のスライスを使用します。 配列の各要素を for ループで処理する (range) for ループで range キーワードを使用すると、配列要素のインデックスと値を 1 つずつ取り出しながら処理することができます。 arr := [...]int{100, 200, 300} for idx, val := range arr { fmt.Printf(&#34;arr[%d] = %d\\n&#34;, idx, val) } 実行結果 arr[0] = 100 arr[1] = 200 arr[2] = 300 ループ時にインデックスだけが必要な場合は、２番目のパラメータを省略して次のように記述します。 arr := [...]int{100, 200, 300} for idx := range arr { fmt.Printf(&#34;arr[%d] = %d\\n&#34;, idx, arr[idx]) } 値だけを取得したいときは、次のように１番目のパラメータに _ を指定して無視するようにします。 arr := [...]int{100, 200, 300} sum := 0 for _, val := range arr { sum += val } fmt.Println(sum) //=&gt; 600 スライス スライスの基本 ([]) Go 言語の配列は固定長ですが、スライスという型を可変長配列のように扱うことができます。 Go 言語では、メモリ効率が重視されるとき以外は、配列よりもスライスの方がよく使用されるようです。 スライスを定義するには、下記のようにします（配列のサイズを指定しないような構文で定義します）。 配列と同様に、初期値とする要素を設定することもできます。 var s []int // 初期値なし var s = []int{100, 200, 300} // 初期値あり s := []int{100, 200, 300} // 初期値あり（関数内ならこう書ける） スライスの要素を追加するには、組込みの append 関数を使用します。 複数の要素をまとめて追加することもできます。 var s []int s = append(s, 100) s = append(s, 200) s = append(s, 300, 400) fmt.Println(s) //=&gt; [100 200 300 400] スライスのサイズを拡張していく過程で、メモリ領域が再割り当てされて参照位置が変わる可能性があるので、append 関数による拡張結果は戻り値として受け取る必要があります。 スライスの要素数と容量 (len, cap) スライスは内部データとして、現在格納されている要素数 (len) と、メモリ上に確保された容量 (cap) の情報を持っています。 それぞれの値は、len(s)、cap(s) のような組込関数を使って取得することができます。 スライスの初期化時には要素数と容量は等しくなっており、append 関数などで要素の追加を行った際に容量オーバーすると、自動的に２倍の容量が新しいメモリ領域に割り当てられます（ただし、容量が 1024 が超えるあたりから、確保サイズの計算方法が変化するようです）。 下記のテストコードで、要素数 (len) と容量 (cap) の変化を確かめてみてください。 var s []int for i := 0; i &lt; 10; i++ { fmt.Printf(&#34;len=%d cap=%d %v\\n&#34;, len(s), cap(s), s) s = append(s, i) } 実行結果 len=0 cap=0 [] len=1 cap=1 [0] len=2 cap=2 [0 1] len=3 cap=4 [0 1 2] len=4 cap=4 [0 1 2 3] len=5 cap=8 [0 1 2 3 4] len=6 cap=8 [0 1 2 3 4 5] len=7 cap=8 [0 1 2 3 4 5 6] len=8 cap=8 [0 1 2 3 4 5 6 7] len=9 cap=16 [0 1 2 3 4 5 6 7 8] 確かに、容量 (cap) は２倍、２倍と拡張されていることがわかります。 容量の拡張時には、内部で新しいメモリ領域へのデータコピーが発生するため、頻繁な容量拡張が発生すると効率が悪くなります。 あらかじめ追加するおおよその要素数が分かっている場合は、後述の make 関数を使うことで、容量を指定したスライス生成を行えます。 make によるスライスの初期化 Go 言語の組込み関数の make を使用してスライスを作成すると、初期要素数 (len) と、初期容量 (cap) を指定してスライスを作成できます。 make 関数の第 1 引数には生成するスライスの型（[]int など）、第 2 引数には初期要素数 (len)、第 3 引数は初期容量 (cap) を指定します。 第 3 引数の初期容量 (cap) は省略可能で、省略すると初期要素数 (len) と同じサイズになります。 各要素はゼロ値で初期化 されます。 len=cap=5 のスライスを作成 s := make([]int, 5) fmt.Printf(&#34;len=%d cap=%d %v&#34;, len(s), cap(s), s) //=&gt; len=5 cap=5 [0 0 0 0 0] 次の例では、初期要素数 (len) と異なる初期容量 (cap) を指定してスライスを作成しています。 初期容量 (cap) は、初期要素数 (len) 以上の値を指定する必要があります。 len=0、cap=100 のスライスを作成 s := make([]int, 0, 100) fmt.Printf(&#34;len=%d cap=%d %v&#34;, len(s), cap(s), s) //=&gt; len=0 cap=100 [] あらかじめ追加する要素数が分かっている場合は、このように初期容量を指定してスライスを生成した方が、パフォーマンスの面で有利です。 実際にどの程度の速度差が出るかは、ベンチマーク機能 を使って調べることができます。 スライスは参照 スライス変数は、配列とは異なり、内部的なメモリ領域へのアドレス値を格納しています（Java の参照のように扱えます）。 つまり、スライス変数の代入は、同じメモリ領域を参照するように指示していることになります。 下記の例で、スライス s1 と s2 が保持する要素は、同じメモリ領域を共有しているため、どちらか一方で要素を変更すると、もう一方のスライスの要素も変更されます。 s1 := []string{&#34;AAA&#34;, &#34;BBB&#34;, &#34;CCC&#34;} s2 := s1 // s1 と s2 は同じ要素群を参照する s1[0] = &#34;XXX&#34; // s1 の変更は s2 にも影響する fmt.Printf(&#34;s1=%v, s2=%v\\n&#34;, s1, s2) //=&gt; s1=[XXX BBB CCC], s2=[XXX BBB CCC] この性質を利用して、関数のパラメータとしてスライスを受け取り、呼び出し側のスライスの要素を書き換えることができます。 スライスの内容を変更する関数 func double(values []int) { for i := 0; i &lt; len(values); i++ { values[i] *= 2 } } func main() { s := []int{100, 200, 300} double(s) fmt.Println(s) //=&gt; [200 400 600] } ちなみに、上記の double 関数の中の for ループを、次のように range を使用するように変更すると、スライスの要素の値は変更されないことに注意してください。 間違った実装 func double(values []int) { for _, v := range values { v *= 2 // ローカル変数の v の値を書き換えているだけ } } 配列、スライスの要素を切り出す 任意の配列やスライス（あるいは string）を、arr[m:n]（m と n は数値）という形で参照すると、元の配列の「m ～ n-1」の領域の要素を参照可能なスライスを取得することができます。 開始インデックスを省略した場合は先頭要素からの切り出し (s[:2] == s[0:2])、終了インデックスを省略した場合は末尾要素までの切り出し (s[2:] == s[2:len(s)]) として扱われます。 s := []int{0, 1, 2, 3, 4, 5} s1 := s[1:4] //=&gt; [1, 2, 3] s2 := s[4:] //=&gt; [4, 5] s3 := s[:2] //=&gt; [0, 1] s4 := s[:] //=&gt; [0, 1, 2, 3, 4, 5] 切り出し後のスライスは、元の配列やスライスのメモリ領域を共有する ことに注意してください。 切り出し後のスライス経由で要素の値を変更すると、元のスライスにも影響を与えます。 下記のように、それぞれのスライスのアドレスを表示してみると、同じメモリ領域を共有していることが分かります（s1 と s2 は先頭要素の位置がずれている分だけアドレスもずれています）。 s := []int{0, 1, 2, 3, 4, 5} s1 := s[1:4] //=&gt; [1, 2, 3] s2 := s[4:] //=&gt; [4, 5] s3 := s[:2] //=&gt; [0, 1] s4 := s[:] //=&gt; [0, 1, 2, 3, 4, 5] fmt.Printf(&#34;%p\\n&#34;, s) // 0xc0000a8060 fmt.Printf(&#34;%p\\n&#34;, s1) // 0xc0000a8068 fmt.Printf(&#34;%p\\n&#34;, s2) // 0xc0000a8080 fmt.Printf(&#34;%p\\n&#34;, s3) // 0xc0000a8060 fmt.Printf(&#34;%p\\n&#34;, s4) // 0xc0000a8060 確実に別のメモリ領域を扱うスライスを作成したい場合は、組み込み関数 copy を使用してスライスをコピーします。 スライスをコピーする (copy) Go の組み込み関数 copy を使用すると、あるスライスの内容を、別スライスの領域へコピーすることができます。 関数の定義は下記のようになっており、 copy(dst, src []T) int コピー元スライス src から、コピー先スライス dst に実際にコピーされた要素数が返されます。 ただし、コピー元スライスの要素数 (len(src))、あるいは、コピー先のスライスの要素数 (len(src)) のうち小さい方の数だけしかコピーされません。 つまり、同じ要素を持つスライスを作成するには、あらかじめコピー元スライスと同じ要素数のスライスを make 関数で確保しておく必要があります。 下記のサンプルでは、src スライスをコピーして、同じ要素を持つ dst スライスを作成しています。 スライス src の要素を dst へコピー src := []int{100, 200, 300} dst := make([]int, len(src)) // コピー先スライスの要素数を確保 (len=3) n := copy(dst, src) fmt.Printf(&#34;%d elements have been copied\\n&#34;, n) fmt.Printf(&#34;src=%v, dst=%v\\n&#34;, src, dst) 実行結果 3 elements have been copied src=[100 200 300], dst=[100 200 300] コピーされる要素数を決定するための判断基準は、あくまでスライスの要素数 (len) であって、容量 (cap) ではないことに注意してください。 なので、次のように容量だけを確保してもコピーは実行されません。 dst := make([]int, 0, 3) // len=0, cap=3 s[m:n] 形式での要素の切り出しを組み合わせて使用すれば、スライスの部分的なコピーが可能になります。 src のインデックス 1～(3-1) の要素を dst のインデックス 2 以降にコピー src := []int{100, 200, 300, 400, 500} dst := []int{1, 2, 3, 4, 5} n := copy(dst[2:], src[1:3]) fmt.Printf(&#34;%d elements have been copied\\n&#34;, n) fmt.Printf(&#34;src=%v, dst=%v\\n&#34;, src, dst) 実行結果 2 elements have been copied src=[100 200 300 400 500], dst=[1 2 200 300 5] さらに、copy 関数の仕様として、コピー元とコピー先の領域がオーバーラップすることが許されているので、次のように、自分自身のスライスの領域間でコピーすることもできます。 src := []int{1, 2, 3, 4, 5, 6, 7, 8} copy(src[4:], src[2:]) fmt.Println(src) //=&gt; [1, 2, 3, 4, 3, 4, 5, 6] スライス同士を結合する (append) Go の組み込み関数 append を使用すると、スライスに対して要素を追加することができますが、別のスライスの要素をすべて結合してしまうこともできます。 結合された結果のスライスは、戻り値として受け取る必要があることに注意してください。 s1 := []int{100, 200, 300} s2 := []int{400, 500, 600} s3 := append(s1, s2...) //=&gt; [100, 200, 300, 400, 500, 600] 上記の例では、結合結果を新しいスライス s3 に割り当てていますが、もちろん既存のスライス s1 に上書き代入してしまうこともできます。 s1 := []int{100, 200, 300} s2 := []int{400, 500, 600} s1 = append(s1, s2...) //=&gt; [100, 200, 300, 400, 500, 600] このケースでは、append 後に新しいメモリ領域が確保されるため、代入後の s1 のアドレスは、元の s1 のアドレスから変化していることに注意してください。`},{url:"/p/kswy47a/",title:"Golang で関数を定義する (func)",date:"2017-09-01T00:00:00+09:00",body:"Golang で関数を定義する (func) Go 言語の関数定義はシンプルでありながら、複数の値を返すことができるなど、十分な機能を備えています。 関数定義の基本 Go 言語で関数を定義するときは、func キーワードを使用します。 func 関数名(パラメータ) 戻り値の型 { // ... } パラメータや、戻り値を持たない場合は、それぞれ省略することができます。 次の例は、メッセージを出力するだけの単純な関数の実装例です。 パラメータも戻り値もない関数 func hello() { fmt.Println(&#34;Hello&#34;) } 次の関数は、２つの int 型パラメータを受け取り、足し合わせた結果を返します。 func add(a, b int) int { return a + b } 複数の戻り値を持つ関数を定義する（多値関数） Go 言語の関数は、複数の戻り値を返すことができます。 その場合、戻り値の型をカンマで区切って並べ、括弧で囲みます。 func swap(a, b int) (int, int) { return b, a } func main() { x, y := swap(10, 20) fmt.Println(x, y) //=&gt; 20, 10 } 複数の戻り値をひとつの変数で受け取ろうとすると、コンパイルエラーになります。 x := swap(10, 20) // Error: multiple-value swap() in single-value context 必要のない戻り値がある場合は、アンダースコア (_) を使って受け取ります。 x, _ := swap(10, 20) // 1 つ目の戻り値のみ欲しい場合 _, y := swap(10, 20) // 2 つ目の戻り値のみ欲しい場合 ちなみに、Go 言語で変数値をスワップするときは次のように簡単に書けます。 x, y = y, x 名前付き戻り値 関数の戻り値に名前をつけておくと、その名前の変数に代入した値を戻り値として返すことができます。 次の例では、２つの int 型の戻り値に、それぞれ index と value という名前を付けています。 func findMax(arr []int) (index int, value int) { ... } 関数から return するときに、その時点で変数 index と変数 value に格納されている値が戻り値として扱われます。 それぞれの変数の初期値は、その型のゼロ値になります（例えば int であれば 0）。 package main import &#34;fmt&#34; // 配列の中から最大値を持つ要素を検索し、そのインデックスと値を返します。 func findMax(arr []int) (index int, value int) { // index = 0 // index のゼロ値は 0 なので上記の初期化処理は省略できる value = arr[0] for i := 1; i &lt; len(arr); i++ { if value &lt; arr[i] { value = arr[i] index = i } } return // return index, value と同じ } func main() { arr := []int{3, 6, 100, 7, 8} i, v := findMax(arr) fmt.Println(i, v) //=&gt; 2, 100 } 上記のように、関数が同じ型の戻り値を複数返すようなケースでは、戻り値に名前を付けておくと、戻り値の順序を間違えて return してしまうようなミスを防ぐことができます。 エラーを返す関数を定義する Go 言語には例外の仕組みがないため（ランタイムエラーを扱う panic は存在します）、関数内でエラーが発生した場合は、戻り値としてエラーを返すことでそれを表現します（成功時は nil を返します）。 f, err := os.Open(&#34;/tmp/sample.txt&#34;) if err != nil { log.Fatal(err) } // 正常シーケンス defer f.Close() // ... 自作の関数の中でエラーを返したいときは、戻り値の型を error と定義し、エラーを errors.New 関数で作成します。 下記の例では、フィボナッチ数列の n 番目の値を返す fibonacci 関数を定義しています。 パラメータに 1 より小さい値を指定された場合は、2 番目の戻り値でエラーを返すようにしています。 package main import ( &#34;errors&#34; &#34;fmt&#34; &#34;log&#34; ) func fibonacci(n int) (int, error) { if n &lt; 1 { return 0, errors.New(&#34;fibonacci() must take a natural number&#34;) } x, y := 1, 1 for ; n &gt; 1; n-- { x, y = y, x+y } return x, nil } func main() { n, err := fibonacci(7) if err != nil { log.Fatal(err) } fmt.Println(n) } エラーメッセージを作成するときに、フォーマット文字列を指定したい場合は、errors.New 関数の代わりに fmt.Errorf 関数を使用できます。 func fibonacci(n int) (int, error) { if n &lt; 1 { return 0, fmt.Errorf(&#34;fibonacci() cannot take a number %d&#34;, n) } //... } 可変長引数 関数のパラメータの定義で、型名の前に ... というプレフィックス を指定することで、可変長引数を表現することができます。 渡された引数は、関数内部ではスライスとして参照することができます。 func sum(values ...int) (result int) { for _, v := range values { result += v } return } func main() { x := sum(1, 2, 3, 4, 5) println(x) //=&gt; 15 } 可変長引数を受け取る関数に対してスライスを渡したいときは、次のように スライスの後ろに ... を付けて展開して渡します。 s := []int{1, 2, 3, 4, 5} x := sum(s...) （固定長の）配列を渡すときは、下記のように一度スライスに変換してから同じように渡すことができますが、これはもう少しよいやり方があるかも。。。 arr := [...]int{1, 2, 3, 4, 5} x := sum(arr[:]...)"},{url:"/p/xs3ahpw/",title:"（旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する",date:"2017-08-31T00:00:00+09:00",body:"（旧）GitHub 上のパッケージを参照する／GitHub にパッケージを公開する 主要なプログラミング言語には、インターネット上のセントラルリポジトリでパッケージを配布する仕組みが提供されていることが多いのですが（Ruby の RubyGems など）、Go 言語では、Git リポジトリ上（主に GitHub）に公開されたソースコードを直接取得 (go get) してインポートする方法を採用しています。 GitHub 上のパッケージをインポートする go get コマンドで、GitHub リポジトリのパスを下記のように指定すると、GitHub 上で公開されている Go パッケージ（ここでは github.com/maku77/gosample）のコードを、$GOPATH/src ディレクトリに取得することができます（$GOPATH についてはこちらを参照）。 github.com/maku77/gosample パッケージを取得する $ go get github.com/maku77/gosample 取得したパッケージは、標準パッケージと同じようにインポートして使用することができます。 sample.go package main import &#34;github.com/maku77/gosample&#34; func main() { gosample.Hello(&#34;Maku&#34;) } ビルド＆実行 $ go run sample.run Hello, Maku! go get コマンドの面白いところは、GitHub 上で公開されているリポジトリ名そのものではなく、そのサブディレクトリで公開されている Go パッケージ名を指定してコードを取得できるところです（git clone コマンドではこのようなことはできませんね）。 例えば、代表的な Pretty Print 系のパッケージである github.com/davecgh/go-spew/spew パッケージは、GitHub 上でのリポジトリ名は https://github.com/davecgh/go-spew.git ですが、そのサブディレクトリとして公開されているパッケージ名を指定して取得することができます。 $ go get github.com/davecgh/go-spew/spew 実際には、go-spew.git リポジトリ以下のファイルがすべて取得されますが、その配下のパッケージを使用するユーザが特に意識する必要はありません。 下記は spew パッケージの使用例です。 sample.go package main import ( &#34;github.com/davecgh/go-spew/spew&#34; ) type Book struct { Title string Author string } func main() { a := Book{ Title: &#34;Golang ABC&#34;, Author: &#34;Maku&#34;, } spew.Dump(a) } ビルド＆実行 $ go run sample.go (main.Book) { Title: (string) (len=10) &#34;Golang ABC&#34;, Author: (string) (len=4) &#34;Maku&#34; } GitHub にパッケージを公開する 自作のパッケージを GitHub に公開したいときは、単純に、Go で作成したソースコードを自分のアカウントで作成した GitHub リポジトリにコミットするだけで OK です。 まずは、リポジトリ名を決めて GitHub 上で新規リポジトリを作成しましょう。 ここでは、https://github.com/maku77/gosample というリポジトリを作成し、その中のコードを作成していくことにします。 GitHub 上で新規リポジトリを作成したら、ローカルでの作業用に git clone で取得します。 取得先は、$GOPATH/src/github.com/＜ユーザ名＞/＜リポジトリ名＞/ というディレクトリにします（go get コマンドの取得先に合わせる）。 $ git clone https://github.com/maku77/gosample.git $GOPATH/src/github.com/maku77/gosample 次に、簡単な Hello 関数を実装してみます。 $GOPATH/src/github.com/maku77/gosample/gosample.go package gosample import &#34;fmt&#34; func Hello(name string) { fmt.Printf(&#34;Hello, %s!\\n&#34;, name) } ビルドできるか確認します。 $ go build github.com/maku77/gosample 何もエラーがでなければ成功です。 GitHub にコミットする前に、ちゃんと動作するかテストプログラムを実行して確かめておきましょう。 sample.go package main import &#34;github.com/maku77/gosample&#34; func main() { gosample.Hello(&#34;Maku&#34;) } ビルド＆実行 $ go run sample.go Hello, Maku! 正しく動作していることが確認できたら、コミットして GitHub へ公開します。 $ git add gosample.go $ git commit -m &#34;Add Hello function&#34; $ git push これで、他のユーザは go get github.com/maku77/gosample と実行するだけで、GitHub からパッケージ取得できるようになります。"},{url:"/p/u48bfim/",title:"（旧）GOPATH によるコードの一元管理",date:"2017-08-31T00:00:00+09:00",body:"（旧）GOPATH によるコードの一元管理 Go 言語を用いた開発では、他のプログラミング言語とは異なり、1 つのワークスペース内ですべてのコードを管理するという慣習があります。 （追記）Go 1.11 以降は Go modules の仕組みで、任意のディレクトリでプロジェクト（モジュール）を作成できるようになりました。 ワークスペースの構成 Go のワークスペースは下記のように、bin、pkg、src という３つのディレクトリで構成することが決められています。 このルールに従ってファイルを配置することで、Makefile のようなビルド設定ファイルを用意しなくても、ビルドコマンド (go build) は構造化されたディレクトリ構成のプロジェクトを認識できるようになっています。 ~/gowork/ +-- bin/ # 作成したバイナリファイル（go install したときの保存先） +-- pkg/ # 依存パッケージのオブジェクトファイル（.a ファイルなど） +-- src/ # ソースコード（実行対象のファイルやインポートするファイルを配置） Go による開発では、ひとつのシステム内（PC 内）に、ひとつのワークスペースだけを用意して、その中ですべての作業を完結させる方法が主流となっています。 自分で作成しているパッケージも、go get コマンドでインターネット上から取得したパッケージも、PC で唯一のワークスペース内の src/ ディレクトリの中に格納します。 Go のプログラム内から外部パッケージをインポートするときは、まず pkg/ ディレクトリ内のバイナリ版が検索され、次に src/ ディレクトリが参照されるようになっています。 他の言語と比べると、特殊な管理方法（ほとんどルールベースで動作する）なので最初は戸惑うかもしれませんが、一度分かってしまえばそれほど複雑な仕組みではありません（こういった１ワークスペースでの開発が、Google 社内の開発ルールに適していたのかもしれませんね）。 GOPATH によるワークスペースの指定 Go 言語用のワークスペースとして扱うディレクトリ（上記の例では gowork ディレクトリ）は、GOPATH 環境変数であらかじめ指定しておく必要があります。 Go 1.8 以上では、GOPATH を明示的に指定しなかった場合のデフォルトパスは $HOME/go となります（Windows の場合は %USERPROFILE%\\go です）。 $ export GOPATH=$HOME/gowork Go が認識している GOPATH の値は、go env GOPATH コマンドで確認することができます。 $ go env GOPATH /Users/maku/gowork go build や go install などのコマンドは、$GOPATH/src 以下のコードに対して実行されるため、どのディレクトリからでも実行することができます。 例えば、任意のディレクトリから、 $ go install foo/bar/hello と実行すると、$GOPATH/src/foo/bar/hello ディレクトリ以下の .go ファイル群がビルドされて、その中で package main と記述された .go ファイルが実行ファイルの形になって $GOPATH/bin にインストールされます。 $GOPATH/src/foo/bar/hello/hello.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello&#34;) } ビルドしてできた実行ファイルは $GOPATH/bin にインストールされるので、そこに PATH を通しておくと便利かもしれません。 $ export PATH=$PATH:$GOPATH/bin $ hello Hello ちなみに、go build foo/bar/hello や go install foo/bar/hello のようにパッケージ名を指定してビルドした場合、パッケージ名をもとに実行ファイルが生成される（この場合は hello というディレクトリ名）ので、ソースコードのファイル名は何でも構いません（ここでは hello.go としたけど、main.go というファイル名にしてもよい）。 ただし、下記のように .go ファイル名を直接指定してビルドする場合は、ファイル名に基いてカレントディレクトリに実行ファイルが生成されます。 $ go build hoge/moge/sample.go $ ls hoge/ sample*"},{url:"/p/dkpsvz3/",title:"Go ツアーを起動して Go 言語の基本を勉強する",date:"2017-08-31T00:00:00+09:00",body:"Go ツアーを起動して Go 言語の基本を勉強する Go ツアーの Web サイトで学ぶ Go には、Go ツアーという Go 言語勉強用のツールが用意されています。まずはこれで Go の基本を一通り学んでみるのがよいです。 下記の Web サイトでは、ブラウザ上で Go 言語のコードを記述、実行しながら Go 言語の基本を学んでいくことができます。 A Tour of Go (https://go.dev/tour/) ローカルで Go ツアーを起動する方法 A Tour of Go は、次のようにローカルの Web サーバーとして立ち上げることができます。 サーバーが立ち上がると、自動的に Web ブラウザが開きます。 $ go run golang.org/x/website/tour@latest 次のようにして、tour コマンドとしてインストールすることもできます。 $ go install golang.org/x/website/tour@latest デフォルトでは $HOME/go/bin 以下に tour コマンドがインストールされるので、次のように起動できます。 $ ~/go/bin/tour GOBIN 環境変数や GOPATH 環境変数を設定している場合は、go install によるコマンドのインストール先が変わるので注意してください。 参考: go install のコマンドインストール先にパスを通す (GOBIN, GOPATH/bin)"},{url:"/p/pw258be/",title:"Golang の if による条件分岐",date:"2017-08-31T00:00:00+09:00",body:"Golang の if による条件分岐 Go 言語の if 文の構文は、Java や C++ とほぼ同じですが、括弧の使用ルールが微妙に異なります。 if 文の構文 Go 言語の if 文は、条件部を括弧で囲みません。 一方で、実行部分のブロックを囲む中括弧（{ と }）は省略することができません。 x, y := 100, 200 if x &gt; y { fmt.Println(&#34;x is larger than y&#34;) } else if x &lt; y { fmt.Println(&#34;x is smaller than y&#34;) } else { fmt.Println(&#34;x is equal to y&#34;) } 比較演算子としては、Java や C++ と同様の ==、!=、&lt;、&lt;=、&gt;、&gt;= が使用できます。 文字列の比較も == 演算子で行えます。 論理演算子も同様に、||、&amp;&amp;、! を使用できます。 s := &#34;hemu&#34; x, y := 100, 200 if s == &#34;hemu&#34; &amp;&amp; x &lt; y { // ... } ちなみに Go 言語には Java や C++ のような三項演算子 (a ? b : c) は用意されていません。 言語として三項演算子や if 式を採用してしまうと、複雑なコードが書かれやすいというのが理由っぽいです（適度に使えば便利なんですけどね^^;）。 参考: Why does Go not have the ?: operator? if スコープの変数 if 変数定義; 条件式 { // ... } という形で変数定義を行うと、その変数のスコープを if あるいは、else のブロック内に制限することができます。 例えば、下記のように記述すると、err 変数は if の条件式と処理ブロックの中でのみ参照できるようになります。 if err := recover(); err != nil { log.Fatal(err) } 次の例では、マップ変数 m にキー AAA が存在するときのみ、その値を参照しています。 m := map[string]int{ &#34;AAA&#34;: 100, &#34;BBB&#34;: 200, &#34;CCC&#34;: 300, } if val, ok := m[&#34;AAA&#34;]; ok { fmt.Println(val) }"},{url:"/p/x6adgjn/",title:"Golang の switch 条件分岐（switch の基本、便利な使い方、型スイッチ）",date:"2017-08-31T00:00:00+09:00",body:`Golang の switch 条件分岐（switch の基本、便利な使い方、型スイッチ） Go 言語の switch 文は、Java や C++ に比べて簡潔に記述できるようになっています。 switch 文の基本 Go 言語の switch 文では、case に複数の値をカンマで区切って指定することができます。 １つの case が実行されると自動的に switch 文を終了するため、C 言語のように case ごとに break と記述する必要はありません。 逆に、次の case を続けて実行したい場合は、明示的に fallthrough と記述する必要があります。 func checkNumber(i int) { switch i { case 0: fmt.Println(&#34;zero&#34;) case 2, 3, 5, 7: fmt.Println(&#34;primary number&#34;) fallthrough default: fmt.Println(&#34;good number&#34;) } } if 文の代わりに switch 文を使うことでコードを簡潔にできることがあります。 func shouldEscape(c byte) bool { switch c { case &#39; &#39;, &#39;?&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;#&#39;, &#39;+&#39;, &#39;%&#39;: return true } return false } if 文と同様に、switch 文でも変数のスコープをブロック内に絞った変数定義を行うことができます。 次の os 変数は、switch 文の中でのみ参照できます。 switch os := runtime.GOOS; os { case &#34;darwin&#34;: fmt.Println(&#34;OS = OS X&#34;) case &#34;linux&#34;: fmt.Println(&#34;OS = Linux&#34;) default: // freebsd, openbsd, plan9, windows... fmt.Printf(&#34;OS = %s\\n&#34;, os) } 連続する if else の代わりとして switch 文を使用する switch 文の条件部分を省略 すると、switch true と記述するのと同様の振る舞いをします。 この記述方法は、連続した if else を簡潔に記述するために使用することができます。 典型的なのは、ある変数の値を大小比較したいケースです。 func unhex(c byte) byte { switch { case &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;: return c - &#39;0&#39; case &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;f&#39;: return c - &#39;a&#39; + 10 case &#39;A&#39; &lt;= c &amp;&amp; c &lt;= &#39;F&#39;: return c - &#39;A&#39; + 10 } return 0 } もう 1 つ例を。 func greet() { t := time.Now() switch { case t.Hour() &lt; 12: fmt.Println(&#34;Good morning.&#34;) case t.Hour() &lt; 17: fmt.Println(&#34;Good afternoon.&#34;) default: fmt.Println(&#34;Good evening.&#34;) } } 上記の変数 t のスコープを switch 文の内部に絞りたいのであれば、下記のように変数定義します（セミコロンの後ろの条件部分だけを省略します）。 switch t := time.Now(); { case t.Hour() &lt; 12: fmt.Println(&#34;Good morning.&#34;) case t.Hour() &lt; 17: fmt.Println(&#34;Good afternoon.&#34;) default: fmt.Println(&#34;Good evening.&#34;) } ちなみに上記の switch を if else を使って書き換えると次のようになります。 if t := time.Now(); t.Hour() &lt; 12 { fmt.Println(&#34;Good morning!&#34;) } else if t.Hour() &lt; 17 { fmt.Println(&#34;Good afternoon.&#34;) } else { fmt.Println(&#34;Good evening.&#34;) } まぁ、このくらいであればそれほど差はありませんが、それでも switch の方が可読性は高そうです。 型スイッチ (Type Switch) Go 言語の関数で任意の型の引数を受け取るには、空インタフェース型 interface{} を使用します。 オブジェクトの実際の型に基づいて分岐処理を行うには、次のように 型スイッチ (Type Switch) の仕組みを使います。 func checkType(value interface{}) { switch v := value.(type) { case nil: fmt.Println(&#34;value is nil&#34;) case int: fmt.Printf(&#34;value is int (%d)\\n&#34;, v) case float64: fmt.Printf(&#34;value is float64 (%f)\\n&#34;, v) case func(int) string: fmt.Println(&#34;value is function that takes int and returns string&#34;) case bool, string: fmt.Println(&#34;value is bool or string&#34;) default: fmt.Printf(&#34;value has unknown type (%T)\\n&#34;, v) } } 上記の例では、value 変数の実際の型によって分岐処理を行っています。 さらに、分岐後は v 変数をその型の値として参照することができます。 型スイッチは、型アサーション (Type Assertion) の特殊形態だと考えることができます。`},{url:"/p/t269cgj/",title:"パッケージの作成とインポート (import)",date:"2017-08-31T00:00:00+09:00",body:"パッケージの作成とインポート (import) Go 言語でパッケージを作る方法と、他のパッケージを参照する色々な方法を紹介します。 パッケージとモジュール パッケージ Go 言語のパッケージは、1 つのディレクトリ内にまとめられたソースコードの集まりです。 下記のディレクトリ構成では、mymodule というモジュール（後述）に、pkg1 と pkg2 という名前の 2 つのパッケージが含まれています。 - mymodule/ - pkg1/ - auth.go (package pkg1) - user.go (package pkg1) - pkg2/ - hoge.go (package pkg2) パッケージ内のファイルの分割粒度は自由で、あるコードがパッケージ内のどの Go ファイルに記述されているかで違いはありません。 パッケージのインポート時にはパッケージ名しか指定しないので、パッケージの利用者は、パッケージを構成する各々の Go ファイルの存在を意識する必要はありません。 パッケージの実装者は、パッケージ内のファイルを都合のいいように分割できます。 Go 言語のソースコードは、必ず 1 つのパッケージに所属している必要があり、ソースコードの先頭の package ディレクティブでパッケージ名（＝親ディレクトリ名）を指定します。 package pkg1 特に、プログラムのエントリポイントとなる main 関数は、main パッケージに存在している必要があり、典型的にはモジュールルートを main パッケージとして扱います。 package main function main() { // ... } モジュール Go 1.11 以降は モジュール という考え方が導入され、Go 1.10 以前の GOPATH によるコードの一元管理 からの移行が進みました。 簡単に言うと、プロジェクト単位でディレクトリを自由な場所に置けるようになりました（以前はすべてのプロジェクトを $GOPATH 以下に置かなければいけませんでした）。 モジュールは単一あるいは複数のパッケージを集めたもので、GitHub などで管理するときののリリース単位として用いられます。 モジュール ◇── パッケージ モジュールのルートディレクトリには go.mod、go.sum というファイルが置かれ、依存するパッケージのバージョンやハッシュ情報などが管理されます。 公開されるモジュール名は世界で一意になっている必要があり、一般的に GitHub のリポジトリで管理されるため、次のような名前が使われます。 github.com/&lt;username&gt;/&lt;modulename&gt; 例えば、github.com/maku77/golibs として公開されているモジュールの、pkg1 パッケージを利用したい場合、次のようにインポートできます。 import &#34;github.com/maku77/golibs/pkg1&#34; 上記のように、モジュール内の単一のパッケージをインポートする場合でも、モジュール全体がダウンロードされるため、初回のビルドには少し時間がかかります。 インポートの使い方 基本 Go 言語のプログラムの中から、他のパッケージをインポートするには import を使用します。 GitHub で公開されているパッケージを直接インポートすることもできます。 import &#34;fmt&#34; import &#34;os&#34; import &#34;strings&#34; import &#34;github.com/ユーザー名/リポジトリ名/パッケージ名&#34; 括弧を使って次の様にまとめることもできます。 import ( &#34;fmt&#34; &#34;os&#34; &#34;strings&#34; &#34;github.com/ユーザー名/リポジトリ名/パッケージ名&#34; ) パッケージで定義されている関数を参照するときは、パッケージ名.関数名 という形で呼び出します。 大文字で始まる関数のみ参照できます。 次の例では、cmp パッケージの Diff 関数を呼び出しています。 package main import &#34;fmt&#34; import &#34;github.com/google/go-cmp/cmp&#34; func main() { fmt.Println(cmp.Diff(&#34;Hello World&#34;, &#34;Hello Go&#34;)) } オプション パッケージをインポートするときに、パッケージ名の前にオプションを指定することで、別名を付けたり、パッケージ名を省略してアクセスできるようになります。 package main import ( . &#34;fmt&#34; // パッケージ名を省略して関数名だけで呼び出せるようにする sample &#34;github.com/maku77/gosample&#34; // パッケージに別名を付けて参照 _ &#34;math/rand&#34; // 参照していなくてもコンパイルエラーにしない ) func main() { Println(&#34;Good morning&#34;) sample.Hello(&#34;Maku&#34;) } パッケージ名の前に . オプションを付けると、パッケージ名を省略してアクセスできるようになります。 上記の例では、fmt.Println の呼び出しを、Println と記述できるようにしています。 2 つ目の例では、gosample パッケージに sample という別名を付けてアクセスできるように指定しています。 Go 言語では、パッケージ名を階層構造で表現しない（潔い！）ので、パッケージ名のコンフリクトが発生しやすくなっています。 同じ名前のパッケージをインポートするときは、この別名の仕組みを利用して解決しましょう。 同一パッケージ内の関数を参照する 同じパッケージ内（つまり、同じディレクトリ内）の Go ファイルで定義されている関数は、互いに参照することができます。 下記は、プログラムのエントリポイントとなる main.go ファイルです。 main.go package main func main(){ hello(&#34;Maku&#34;) } hello 関数は、同じパッケージ（同じディレクトリ内）の別のファイルで定義しています。 greet.go package main import &#34;fmt&#34; func hello(name string) { fmt.Printf(&#34;Hello, %s\\n&#34;, name) } 実行するときは、これらを一緒にビルドする必要があります。 $ go run *.go Hello, Maku ビルドして、実行ファイル myapp を作るときも同様です。 $ go build -o myapp *.go $ ./myapp Hello, Maku go.mod ファイルを生成してモジュール対応モードにしておけば、go build は引数なしで実行できます。 $ go mod init myapp $ go build $ ./myapp Hello, Maku 別のパッケージの関数を参照する ある関数を別のパッケージから参照できるようにするには、関数名を大文字で始める必要があります（例: Hello）。 ここでは、次のようなディレクトリ構成の myapp モジュールを作って、main.go（main パッケージ）から mymath/mymath.go（mymath パッケージ）で定義した関数を参照したいとします。 myapp/ go.mod main.go （main パッケージ） mymath/ （mymath パッケージ） mymath.go まず、モジュールのルートディレクトリ (myapp) で、go mod init コマンドを実行して、go.mod ファイルを生成します。 GitHub で管理することを想定しているのであれば、モジュールパス名はリポジトリ名に合わせて github.com/&lt;user&gt;/&lt;repo&gt; のようにします。 これにより、モジュールパス名が世界で一意になるとともに、別のモジュールから GitHub 経由でインポートできるようになります。 ローカルでテスト開発するだけのアプリであれば、とりあえずモジュールパス名は myapp のように適当に付けちゃって構いません。 $ cd ~/gitwork/myapp $ go mod init github.com/maku77/myapp # GitHub で管理するならリポジトリ名を指定 $ go mod init myapp # ローカルでのテスト用ならこれでも OK mymath パッケージでは、簡単な足し算を行う Add 関数を提供することにします。 パッケージ外部から参照できるようにするには、関数名を大文字で始める必要があります。 mymath/mymath.go package mymath func Add(a, b int) int { return a + b } この mymath.Add 関数を、main パッケージの main 関数から参照するには次のようにします。 main.go package main import &#34;fmt&#34; import &#34;github.com/maku77/myapp/mymath&#34; func main() { fmt.Println(mymath.Add(100, 200)) } main パッケージ（の main 関数）は次のように実行できます。 $ go run . 300 ビルドして実行ファイル myapp を生成することもできます。 $ go build $ ./myapp 300 Go 言語のパッケージは、&quot;./mymath&quot; のような 相対パスではインポートできない ことに注意してください。 必ず &quot;github.com/maku77/myapp/mymath&quot; のようにモジュール名を含むパッケージパス全体（絶対パス）を指定する必要があります（go mod init でモジュールパス名を myapp のように簡略化した場合は、&ldquo;myapp/mymath&rdquo; のようにインポートします）。 昔は同一モジュール内のパッケージであれば相対パスでインポートできたのですが、現在は外部モジュールのパッケージと同様に絶対パスによる指定に統一されています。"},{url:"/p/v58cfik/",title:"Golang のループ処理（for ループ）",date:"2017-08-31T00:00:00+09:00",body:"Golang のループ処理（for ループ） Go 言語では、for キーワード 1 つだけで while ループや無限ループを表現することができます。 C/C++ 言語風の for ループ for 初期化; 条件式; 後処理 { // ... } Go 言語の for ループは、C/C++ 言語に似た構文を使用しますが、for の直後は括弧で囲みません。 ただし、実行部分の括弧は必ず記述する必要があります。 このあたりのルールは、if 文と同じですね。 記述例 for i := 0; i &lt; 3; i++ { fmt.Println(i) } 実行結果 0 1 2 ちなみに、i++ という部分を、++i という前置インクリメントに置き換えることはできません。 Go 言語では、i++ という後置インクリメントは文として扱われる（評価後の値を得られない）ため、式の中に埋め込むことができないようになっています。 そのため、前置インクリメントと後置インクリメントを区別する必要がそもそもなく、文法として後置インクリメントの形に統一するようになっています。 while ループ（としての for ループ） Go 言語には while ループ（条件に一致する限り繰り返し）は存在しませんが、for ループで代用できます。 i := 0 // i が 3 より小さい間、繰り返す for i &lt; 3 { fmt.Println(i) i++ } for ループの初期化ステートメントや条件式、後処理ステートメントはそれぞれ省略することができるので、上記の for ループは、実は下記のような記述の省略形です（上記のように省略して記述すべきです）。 for ; i &lt; 3; { // ... } 無限ループ（としての for ループ） Go 言語では、無限ループも for を使用して記述するよう統一されています。 i := 0 for { i += 1 if i &gt; 5 { break } if i % 2 == 0 { continue } fmt.Println(i) } 実行結果 1 3 5 C/C++ 言語の無限ループの記載方法 (for (;;) { }) に慣れているのであれば、上記は下記のような記述の省略形だと考えれば良いでしょう（このように書くべきではありませんが）。 for ;; { // ... } ループの継続に continue、終了に break キーワードを使用するのも C/C++ 言語と同様です。"},{url:"/p/qqy9gok/",title:"定数を定義する (const, iota)",date:"2017-08-31T00:00:00+09:00",body:"定数を定義する (const, iota) Go 言語の定数は、変数を定義するのと同じ感覚で定義することができます。 定数定義の基本 (const) Go 言語の定数は、const キーワードを使用して定義します。 func main() { const foo = 100 fmt.Println(foo) } 次のように複数の定数をまとめて定義することもできます。 const ( hoge = 100 fuga = 200 ) 定数値をパッケージ外に公開する パッケージ外に公開する定数値は、名前を大文字で始めます（関数や変数と同様です）。 逆に、小文字で始まる定数値は、同じパッケージ内からのみ参照可能です。 mypkg/mypkg.go package mypkg const PublicConst = 100 // 別のパッケージから mypkg.PublicConst で参照可能 const privateConst = 200 // mypkg 内からのみ参照可能 main.go package main import &#34;fmt&#34; import &#34;mypkg&#34; func main() { fmt.Println(mypkg.PublicConst) //=&gt; 100 } 標準パッケージの math パッケージも、円周率πを math.Pi という大文字で始まる定数名で公開しています。 package main import &#34;fmt&#34; import &#34;math&#34; func main() { fmt.Println(math.Pi) //=&gt; 3.141592653589793 } 定数には型を指定しない Go 言語で定数を定義するときは、const Foo int = 100 のように型を明示することもできますが、通常は型を指定せずに const Foo = 100 とだけ記述します。 こうして untyped なままで定義しておくことで、実際にその定数値を使用するときに適切な型の値として扱ってくれるようになります。 例えば、定数 Foo を int 型と明示して定義すると、下記の 3 行目で型のミスマッチが発生してエラーになってしまいます。 const Foo int = 100 var a uint = 100 a += Foo // invalid operation: a += Foo (mismatched types uint and int) 定数の型を指定しないようにしておけば、その定数が使用されるときに適切な型の定数として扱ってくれるのでエラーが発生しません。 const Foo = 100 var a uint = 100 a += Foo // OK このように、定数を定義するときは型を指定しない方が便利に（かつ直感的に）使用できます。 必ず特定の型でしか使って欲しくない場合のみ、定数の型を明示するようにしましょう。 連番の定数を定義する (iota) 定数ジェネレータの iota を使用すると、連番からなる定数を簡単に定義することができます。 const ( FAST = iota //=&gt; 0 NORMAL //=&gt; 1 SLOW //=&gt; 2 ) iota は呼び出されるごとに 0、1、2 という連番を返しますが、2 つ目以降の呼び出しは上記のように省略することができます。 つまり、上記のコードは下記のコードと同等です。 const ( FAST = iota //=&gt; 0 NORMAL = iota //=&gt; 1 SLOW = iota //=&gt; 2 0 始まりではなく、1 始まりの連番が欲しい場合は、次のように最初の値を _ で無視します。 const ( _ = iota //=&gt; 0 FAST //=&gt; 1 NORMAL //=&gt; 2 SLOW //=&gt; 3 ) あるいは、次のように記述することもできます。 const ( FAST = iota + 1 //=&gt; 1 NORMAL //=&gt; 2 SLOW //=&gt; 3 ) iota が返す値は、次の const キーワードが出現したときに 0 にリセットされます。 const ( a = iota //=&gt; 0 b //=&gt; 1 c //=&gt; 2 ) const ( d = iota //=&gt; 0 e //=&gt; 1 f //=&gt; 2 ) 次のようにシフトと組み合わせて使用することもできます。 const ( a = 1 &lt;&lt; iota //=&gt; 1 b = 1 &lt;&lt; iota //=&gt; 2 c = 1 &lt;&lt; iota //=&gt; 4 d = 1 &lt;&lt; iota //=&gt; 8 ) 上記のように計算を組み合わせた定義も、下記のように省略することができます（代入式が暗黙的に繰り返されます）。 const ( a = 1 &lt;&lt; iota //=&gt; 1 b //=&gt; 2 c //=&gt; 4 d //=&gt; 8 ) 参考記事 Constants - The Go Blog"},{url:"/p/nuz369c/",title:"Go 言語で Hello World をコンパイル、実行する",date:"2017-08-30T00:00:00+09:00",body:"Go 言語で Hello World をコンパイル、実行する ここでは、Go 言語を使用して簡単な Hello World プログラムを作成し、コンパイル＆実行してみます。 Go 言語で Hello World を実装する Go 言語のソースコードファイルの拡張子は、.go を使用します。 hello.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello Go&#34;) } エントリポイントとなる Go プログラムは、main パッケージとして作成し、main 関数を含んでいる必要があります（main.main と表現します）。 ファイル名は何でも構いません。 Hello World を実行する Go 言語はコンパイル型の言語ですが、go run コマンドを使用すると、ソースコードファイルを指定してそのまま実行することができます。 $ go run hello.go Hello Go ビルドして実行ファイル（Windows なら hello.exe）を作成するには、go build コマンドを使用します。 $ go build hello.go $ ./hello Hello Go 作成された実行ファイルは、同じ環境（OS、アーキテクチャ）であれば、Go の処理系がインストールされていなくてもそのまま実行することができます。 別の OS 用にビルドする場合は、クロスコンパイルの機能を使用します。 Go のクロスコンパイルがサポートしている OS と CPU アーキテクチャは、こちらのドキュメント に記述されています。 （応用）モジュール対応モードでアプリを作成する いろいろな外部パッケージを活用して Go アプリを作る場合、モジュールとしてアプリを初期化します（module-aware mode と呼びます）。 モジュールを初期化するには、モジュールルートにしたいディレクトリの下で go mod init &lt;モジュールパス名&gt; を実行します。 Node.js アプリの開発経験があるなら、npm init のようなものだと考えると分かりやすいです。 Go モジュールの初期化 $ mkdir hello &amp;&amp; hello $ go mod init hello # GitHub で管理するなら github.com/maku77/hello など go: creating new go.mod: module hello 上記のように、モジュールのルートディレクトリ (hello) に go.mod ファイルが作成されれば成功です。 このファイルには、このモジュールの名前や、Go のバージョン、パッケージの依存情報 (dependency tracking) などが保存されます。 hello/go.mod module hello go 1.18 シンプルな構成のアプリでは、モジュールのルートディレクトリに、main パッケージとする .go ファイルを配置します。 ファイル名は何でもいいですが、main.go としておきます。 hello/main.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello Go&#34;) } モジュールのディレクトリ構成は次のようになっています。 hello/ （モジュールルート） main.go （main 関数を含む main パッケージの実装） go.mod （go mod init で自動生成された） このアプリを実行するには、モジュールルートから次のように go run を実行します。 モジュール対応モードの場合、main パッケージのディレクトリ名 (.) を指定するだけでよいことに注意してください。 $ go run . Hello Go ビルドして実行ファイルを作りたい場合は、go build を実行します。 ここでは、パッケージ名の指定すら必要ありません。 出力される実行ファイルの名前はモジュール名に従って hello、あるいは hello.exe になります（-o オプションで変更できます）。 $ go build $ ./hello Hello Go これで、Go 言語での簡単な Hello World アプリの導入は完了ですが、ある程度の規模のアプリを開発する場合は、自分でパッケージ用のディレクトリを作ったり、外部パッケージをインポートして実装していくことになります。 Go 言語でのパッケージの概念に関しては、下記を参考にしてください。 パッケージの作成とインポート"},{url:"/p/wxhzfvc/",title:"Go 言語とは？／Go をインストールする",date:"2017-08-30T00:00:00+09:00",body:"Go 言語とは？／Go をインストールする Go 言語 (Golang) は、Google が 2009 年に発表したオープンソースのプログラミング言語です。 コンパクトな実行ファイルを生成できるため、サーバーレス環境やコンテナ化されたアプリケーションとの相性がよく、多くのプロジェクトでメイン言語として採用されることが増えてきています。 ここでは Go 言語の特徴と、インストール方法を紹介します。 Go 言語の特徴 Go 言語は下記のような特徴を持っています。 マスコットキャラクター（Gopher: ホリネズミ）が 気持ち悪い かわいい 開発者 Ken Thompson（ケン・トンプソン）（C 言語の開発者） Rob Pike（ロブ・パイク）（UTF-8 の開発者） Brad Fitzpatrick（ブラッド・フィッツパトリック）（memcached の開発者） コンパイル型の言語 コンパイルが非常に高速 コンパイルせずにソースコードを指定して実行することも可能（go run sample.go) クロスコンパイルをサポートしており、Windows、Linux、macOS 用の実行ファイルを容易に生成できる 今まで C/C++ で行っていたシステムレイヤのプログラミングをより効率的に行う目的で作成された（ミドルウェアなどの実装に最適） シンプルな言語仕様のため習得が用意で、大規模開発にも耐えられる 最小限の構文により、コーディングのミスを防ぎ、コンパイルを最適化している 例えば、ループ構文は for ループしかない、三項演算子もない 行末のセミコロンは必要ない マクロなどのプリプロセッサ構文はない（コンパイルの低速化の原因のため） 暗黙の型変換はない ポインタはあるが、危険なポインタ演算はない GC による自動メモリ解放（C 言語と Java のいいとこ取り） 継承、ジェネリックプログラミング、アサーション、オーバーロードなども存在しない 2022-03-15 の Go 1.18 リリース でジェネリクスがサポートされました 不要なインポートがあるとコンパイルエラーになる（警告ではなくエラー） try-catch による例外の仕組みがない（関数が多値を返すことでカバー）（panic と recover という仕組みがある） クラスはないが、構造体＋レシーバ付き関数でカバー 豊富な標準パッケージを同梱（暗号化、圧縮、RDB、JSON、テスト用のライブラリなど） 並行処理もネイティブにサポート（ゴルーチンという軽量スレッド、チャネルによるスレッド間通信） テスト実行 (go test) やドキュメント生成 (godoc) のコマンドを標準搭載 バージョン 1.5 以降は Go 言語自体が Go 言語で記述されている（一部アセンブラ） Go 言語は、静的サイトジェネレータ Hugo や、コンテナ型仮想環境ツール Docker のベースとなる言語としても使用されており、これらのツールの高速な動作は、Go 言語によって支えられています。 Go をインストールする Go は各環境用のインストールパッケージを使用して簡単にインストールできます。 下記から Windows、Linux、macOS 用のパッケージをダウンロードしてインストールを実行してください。 Getting Started - The Go Programming Language インストールが完了したら、下記のようにバージョン情報を表示することで動作確認できます。 $ go version go version go1.9 windows/amd64 Go のバージョン推移 go1.19 (released 2022-08-02) ドキュメンテーションコメントの記述が強化され、ドキュメント間のリンクなどが可能になった。 go1.18 (released 2022-03-15) ジェネリクス をサポート。 Fuzzing テストのサポート。 go get はパッケージのビルドもインストールもしなくなり、go.mod ファイルの依存情報を更新するだけになった（= -d フラグが常に有効）。そのため、モジュールの外（go.mod がない）ディレクトリで go get を実行するとエラーになるようになった。 GOPATH モード (GO111MODULE=off) にすれば、go get コマンドは以前のようにパッケージのビルドとインストールを行う。 go.mod ファイルと go.sum ファイルは、go get、go mod tidy、go mod download コマンドのみで更新される。 go1.17 (released 2021-08-16) go get によるコマンドのインストールが非推奨に。代わりに go install cmd@ver を使う。 Windows の 64-bit ARM アーキテクチャをサポート。 ビルド制御のための //go:build コメントをサポート（古い型式の // +build は gofmt で置換してくれる）。 go1.16 (released 2021-02-16) パッケージビルドは module-aware モードがデフォルトになった（go.mod ファイルが存在しなくても）。今後、すべてのプロジェクトは module-aware モードでのビルドが推奨とされた。 GO111MODULE による振る舞い（未指定時が on とみなされるようになった） 未指定 &hellip; 常に module-aware モードで動作（下記 on と同様に動作） on &hellip; 常に module-aware モードで動作 off &hellip; 常に GOPATH モードで動作（go1.10 までと同じ） auto &hellip; $GOPATH/src 以下で go.mod ファイルが存在しない場合のみ GOPATH モードで動作（go1.15 までのデフォルト動作） go1.15 (released 2020-08-11) GOMODCACHE でモジュールキャッシュ用のディレクトリを $GOPATH/pkg/mod から変更できるようになった。 go1.14 (released 2020-02-25) go1.13 (released 2019-09-03) go1.12 (released 2019-02-25) go mod init で go.mod ファイルにデフォルトで go directive （go のバージョン情報）が入るようになった。 Go tour がメインバイナリに含まれなくなったので、go tool tour は go get -u golang.org/x/tour と実行するようになった。 go1.11 (released 2018-08-24) module-aware（モジュール対応）モード の導入。go コマンドは、コンテキストに応じて GOPATH モードと module-aware モードのどちらかで動作するようになった。 GOPATH モード &hellip; go1.10 までのモードで、コード管理を GOPATH で指定されたディレクトリ内で行う module-aware モード &hellip; コード管理を任意のディレクトリ（モジュールディレクトリ）で行う GO111MODULE による振る舞い 未指定 &hellip; 下記 auto と同様に動作 on &hellip; 常に module-aware モードで動作 off &hellip; 常に GOPATH モードで動作（go1.10 までと同じ） auto &hellip; $GOPATH/src 以下で go.mod ファイルが存在しない場合のみ GOPATH モードで動作（go1.15 までのデフォルト動作） go1.10 (released 2018-02-16) go1.9 (released 2017/08/24) go1.8 (released 2017/02/16) go1.7 (released 2016/08/15) go1.6 (released 2016/02/17) &ndash; 64 ビット MIPS 上の Linux、32 ビット x86 上の Android をサポート go1.5 (released 2015/08/19) &ndash; iOS をサポート go1.4 (released 2014/12/10) &ndash; Android をサポート go1.3 (released 2014/06/18) go1.2 (released 2013/12/01) go1.1 (released 2013/05/13) go1 (released 2012/03/28) &ndash; Linux、Mac OSX に加え、Windows をサポート Release History - The Go Programming Language より"},{url:"/p/rz47adg/",title:"Go 言語のコーディングスタイル（コーディング規約）",date:"2017-08-30T00:00:00+09:00",body:"Go 言語のコーディングスタイル（コーディング規約） Go 言語には、標準のコーディング規約が用意されており、それに合わせた組み込みのコードフォーマッター (go fmt) も提供されています。 Go 言語のコーディング規約 Go 言語におけるコーディングスタイルは、下記のドキュメントが参考になるでしょう。 Effective Go - The Go Programming Language ポイントを簡単にまとめておきます。 インデントにはハードタブ（タブ文字）を使用 し、ソフトタブ（半角スペース）を使用しない。 １行あたりの文字数に制限はない。もちろん、長すぎる場合は改行してもよい。 連続した変数定義やコメントは縦に揃える type T struct { name string // name of the object value int // its value } 演算子の前後にスペースを入れない。演算子の優先順位を明確にするときのみスペースを入れる。その代わり余計な括弧を使わない。 x&lt;&lt;8 + y&lt;&lt;16 x, y = y, x+y 命名規則 公開メソッド、フィールド: MexedCaps（大文字で始める） 非公開メソッド、フィールド: mixedCaps（小文字で始める） コンストラクタ: NewBook（New + 生成対象の構造体名） １つのメソッドを持つインタフェース: Reader（Read メソッドだけを持つインタフェース） というように、いくつかのフォーマットルールがあるのですが、Go には下記のような自動整形ツールが付属しているので、これを実行して自動で整形してしまうのが手っ取り早いです。 コードを自動整形する (go fmt と gofmt) Go 言語には、コーディング規約に従ってコードを自動整形するためのツール (go fmt) が標準で搭載されています。 例: hello.go ファイルを直接フォーマットする $ go fmt hello.go 上記のように実行すると、hello.go ファイルの内容が整形されて書き換えられます。 指定したソースコードが直接変更される ことに注意してください。 次のように実行すれば、プロジェクト内のすべての .go ファイルをフォーマットできます。 $ go fmt ./... 元のソースコードを書き換えずに標準出力へ整形結果を出力したい場合は、go fmt の代わりに gofmt コマンドを使用します。 例: hello.go のフォーマット結果を標準出力へ出力する $ gofmt hello.go package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello Go&#34;) } go fmt の振る舞いは、gofmt -l -w と同様のようです。"},{url:"/p/rqcwgyj/",title:"Hugo で日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage)",date:"2017-08-29T00:00:00+09:00",body:"Hugo で日本語を正しく扱えるようにしてページサマリーが長くなるのを防ぐ (hasCJKLanguage, isCJKLanguage) Hugo の記事一覧ページでは、記事の先頭部分を特定の単語数 (70 words) だけサマリー表示するようになっています。 ただし、このワードカウントはデフォルトでは英語などの単語数をベースに計算されているので、日本語などでは正しくカウントされずに、長大なサマリーが表示されてしまいます。 日本語の文字数を正しく数えて、短いサマリーを表示できるようにするには、設定ファイルで下記のように hasCJKLanguage を true に設定します。 config.toml の場合 hasCJKLanguage = true config.yaml の場合 hasCJKLanguage: true これで、Hugo 内部の .Summary や .WordCount が日本語で正しく動作するようになり、短いサマリー文章が表示されるようになります。 各ページごとに設定を行いたい場合は、下記のようにフロントマターで、isCJKLanguage を true に設定します。 --- title: &#34;記事のタイトル&#34; date: &#34;2017-08-29&#34; isCJKLanguage: true --- 記事の本文 設定ファイルでは hasCJKLanguage を設定し、Markdown ファイルのフロントマターでは isCJKLanguage を設定することに注意してください。"},{url:"/p/utmg42x/",title:"Hugo で特定の記事を常にリスト上方に表示する（weight プロパティ）",date:"2017-08-28T00:00:00+09:00",body:"Hugo で特定の記事を常にリスト上方に表示する（weight プロパティ） Hugo で記事（コンテンツ）の一覧を表示しようとすると、通常は記事の作成日時順に表示されます。 一覧ページで特定の記事を最初に表示したい場合は、記事のフロントマターの weight プロパティで、記事の重要度（整数値）を設定します。 記事のヘッダ (Front matter) の記述例 --- title: &#34;重要な記事&#34; date: &#34;2017-08-28&#34; weight: 1 --- ...本文... weight プロパティに設定した値は、小さいほど重要度が高いと認識されます。 つまり、weight 値を 1 にすると、重要な記事として上の方に表示されます。 2 はその次、3 はさらにその次、というように、昇順に表示されます。 0 は特別で、weight 値を指定していないのと同じ意味になります。 weight 値には、実はマイナスの値も設定することができるため、-99999 といった値を設定しておくと、1 や 2 と設定したものよりも上位に表示されます（優先度がものすごく高いと見なされる）。 weight 値の設定されていない（あるいは weight: 0 に設定した）通常の記事は、どのような weight 値を持つ記事よりも優先度が低いと見なされませます（後ろに表示されます）。"},{url:"/p/q7sdwgy/",title:"Hugo で記事を作成する",date:"2017-08-25T00:00:00+09:00",body:"Hugo で記事を作成する 記事ファイルを作成する Hugo で公開する Web サイトの記事は、content ディレクトリに Markdown ファイルとして作成します（例: sample.md）。 記事ファイルは、空っぽのテキストファイルから作成していくこともできますが、hugo new コマンドを使用することで、記事のひな形ファイル (archetypes/default.md) をベースにして Markdown ファイルを自動生成することができます。 記事ファイル（Markdown ファイル）を作成 $ hugo new sample.md /Users/maku/my_site/content/sample.md created 上記のように実行すると、content ディレクトリ内に sample.md ファイルが作成されます。 作成されたファイルの先頭部分には、下記のような Front matter というヘッダが記述されています。 このヘッダが、archetypes/default.md をもとにして自動生成されたものです。 content/sample.md --- title: &#34;Sample&#34; date: 2017-08-25T22:55:55+09:00 draft: true --- あとは、タイトル (title) を適切なものに書き換え、Front matter ヘッダ以降に記事の本文を記述していきます。 公開できるレベルまで記述できたら、ヘッダ部分の draft: true の行を削除します。 Archetypes ここで、ベースとなっている archetypes/default.md を覗いてみましょう。 archetypes/default.md --- title: {{ replace .TranslationBaseName &#34;-&#34; &#34; &#34; | title }}&#34; date: {{ .Date }} draft: true --- title フィールドには hugo new コマンドで指定した名前が自動で入り、date フィールドには現在の時刻が自動で入るようになっています。 このファイルの内容をもとに、記事ファイルが作成されていることが分かりますね。 記事作成と同時にエディタで編集を始める hugo new コマンドで記事ファイルを作成するときに、--editor オプションを指定すると、記事ファイルの生成と同時に指定したエディタでファイルを開くことができます。 例: 記事ファイルを作成して vim で開く $ hugo new sample.md --editor vim"},{url:"/p/h2cku5d/",title:"Hugo のテーマを設定する",date:"2017-08-25T00:00:00+09:00",body:"Hugo のテーマを設定する テーマをダウンロードする Hugo で Web サイトを生成するときは、外観のベースとなる テーマ を設定する必要があります。 テーマを設定せずに hugo コマンドで Web サイトを出力しても、真っ白なページが表示されてしまうだけです。 テーマは自分で作成することもできますが、Hugo Themes というサイトに、有志の人によって作られたテーマが公開されていますので、まずはここからダウンロードして使ってみるのがよいでしょう。 使用方法はテーマごとに少しずつことなるので、詳細はそれぞれのテーマの説明 (README.md) を読んでください。 テーマの ZIP ファイルをダウンロードする方法 例えば、下記の bootstrap4-blog というテーマがよさそうであれば、Download ボタンを押します。 通常は、GitHub のサイトに飛ぶので、Clone or download のボタンを押してテーマをダウンロードしてください。 ダウンロードしたテーマは、プロジェクトの themes ディレクトリに配置します。 このケースでは、themes/bootstrap4-blog ディレクトリとして配置します。 テーマを Git で取得する方法 テーマは GitHub 上で管理されていますので、Git コマンドが使える環境であれば、下記のように git clone してしまうのが簡単です（もちろん先にリポジトリの URL は調べておく必要はありますが）。 $ git clone https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/bootstrap4-blog もし、自分のサイトを Git 管理しているのであれば、次のようにテーマを Git サブモジュール として取り込んでしまうがよいです。 Git サブモジュールのコマンド (git submodule) はちょっと難しいですが、テーマをサブモジュールとして管理すれば、テーマ側の更新を適宜反映できるようになります。 # テーマをサブモジュールとして取り込む $ git submodule add https://github.com/alanorth/hugo-theme-bootstrap4-blog.git themes/bootstrap4-blog # テーマ側の更新を取り込むとき $ git submodule update --remote --recursive （必要に応じて）テーマごとのセットアップ テーマによっては、外部コンポーネントに依存していて、初期設定が必要なものもあります。 上記の bootstrap4-blog テーマでは、下記のように関連モジュールをインストールしてくださいと説明がありますので、その通りに実行しておきます。 $ npm install $ npm run build ちなみに、npm は Node.js 用のパッケージマネージャで、Node.js をインストールすれば一緒にインストールされます。 使用するテーマを指定する テーマは themes ディレクトリにいくつでもダウンロードしておくことができます。 その中から実際に使用するテーマは、Hugo の設定ファイルの中で以下のように設定します。 config.toml（抜粋） theme = &#34;bootstrap4-blog&#34; テーマを設定したら、hugo コマンドで Web サイトを生成してみてください。 設定したテーマをもとに、public ディレクトリ以下にアップロード用のファイル群が出力されるはずです。 $ hugo hugo server コマンドで、Web サーバを立ち上げる場合にも config.toml で設定したテーマが使用されます。 hugo コマンドを実行するときに、-t オプションで使用するテーマを指定することもできます。 $ hugo -t theme_name （サイトを出力する場合） $ hugo server -t theme_name （Web サーバを立ち上げる場合）"},{url:"/p/wdyk5n7/",title:"カレントディレクトリを気にせずに hugo コマンドを実行する",date:"2017-08-25T00:00:00+09:00",body:"カレントディレクトリを気にせずに hugo コマンドを実行する hugo コマンドを実行するときに、-s (--source) オプションを使用することで、ソースディレクトリのパスを指定して起動することができます。 例: ~/mysite 以下のソースコードを使って Hugo サーバーを起動する $ hugo server -s ~/mysite 例: ~/mysite 以下の記事を新規作成する $ hugo new sample.md -s ~/mysite 上記の例では、-s ~/mysite というソースディレクトリの指定を末尾に持ってきましたが、hugo の直後に指定しても動作するようです。 これを利用して、下記のようなコマンドエイリアスを作成しておけば、どのディレクトリからでもすぐに記事作成を始められて便利です。 ~/.bash_profile alias hugo-mysite=hugo -s ~/mysite 例えば、下記のように使用することができます。 $ hugo-mysite new sample.md # 記事の作成 $ hugo-mysite server # Hugo サーバーを起動 $ hugo-mysite # サイトをビルド（~/mysite/public に出力）"},{url:"/p/jj7rcvf/",title:"ポート番号を指定して Hugo サーバーを起動する",date:"2017-08-25T00:00:00+09:00",body:"ポート番号を指定して Hugo サーバーを起動する Hugo サーバーを hugo server コマンドで起動すると、デフォルトでは 1313 ポートを使用する Web サーバが立ち上がります。 ただし、複数の Hugo サーバーを同時に立ち上げようとすると、2 つめ以降の Hugo サーバーにはランダムなポート番号が割り当てられます（おそらく Private ports である 49152～65535 の範囲のポート番号が使用されます）。 任意のポート番号を使うように指定するには、下記のように -p (--port) オプションを使用します。 例: ポート番号 51234 で Hugo サーバーを立ち上げる $ hugo server -p 51234 たくさんの Hugo サーバーを同時に起動するようなケースでは、それぞれのサイトでどのポート番号を使用するかを決めておくとよいでしょう。 例: 3 つの Hugo サーバーを同時に立ち上げる $ hugo server -p 50001 -s ~/mysite1 $ hugo server -p 50002 -s ~/mysite2 $ hugo server -p 50003 -s ~/mysite3 上記のように立ち上げた Web サイトは、それぞれ下記のようなアドレスでアクセスできるようになります。 http://localhost:50001/ http://localhost:50002/ http://localhost:50003/"},{url:"/p/m2oatdw/",title:"Hugo でドラフトページを作成する",date:"2017-08-24T00:00:00+09:00",body:"Hugo でドラフトページを作成する ドラフト記事 Hugo のドラフト機能は、未完成の記事ファイルを一時的にほかの記事と同じ場所に保存しておくための機能です。 ページの Front matter 部分に、draft: true という記述があると、そのページはドラフトとして扱われます。 YAML 形式の場合 --- draft: true --- 本文 TOML 形式の場合 +++ draft = true +++ 本文 ドラフトとして作成された記事は、デフォルトでは HTML ファイルとして出力されません。 ドラフト記事も出力するようにするには、hugo コマンドに -D (--buildDrafts) オプションを指定します。 ドラフト記事を出力 $ hugo -D # サイトを生成する場合 $ hugo server -D # サーバーを立ち上げる場合 public ディレクトリに出力されたドラフト記事に注意 hugo コマンドは、デフォルトで public ディレクトリに HTML ファイルなどを出力しますが、このとき、public ディレクトリ内に既に存在するドラフト記事を削除することはありません。 $ hugo -D # ここでドラフト記事も含めて生成される $ hugo # 次にドラフトモード OFF で生成しても、既存のドラフト記事が削除されない Web サイトを公開するときは、ドラフト記事が間違ってアップロードされないように気を付けてください。 記事のアップロード前は、public ディレクトリを削除してから hugo コマンドで再生成すると安全です。 Linux / macOS の場合 $ rm -Rf public &amp;&amp; hugo Windows の場合 C:\\&gt; rmdir /s /q public &amp; hugo ドラフト記事の一覧を表示する コマンドラインから コマンドラインで hugo list drafts と実行すると、contents ディレクトリ内の記事のうち、ドラフトとしてマークされている（フロントマターに draft: true と記述されている）ファイルの一覧を確認することができます。 $ hugo list drafts draft.md diaries/temp.md books/work-shift.md 参考: hugo list drafts｜Hugo テンプレートから テンプレートファイル内で、ドラフト記事のリンクを列挙するには以下のようにします。 layouts/index.html（抜粋） &lt;h2&gt;ドラフト記事の一覧&lt;/h2&gt; &lt;ul&gt; {{ range (where .Site.Pages &#34;.Draft&#34; true) }} &lt;li&gt;&lt;a href=&#34;{{ .RelPermalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/li&gt; {{ end }} &lt;/ul&gt; ☝️ ワンポイント where .Site.Page &quot;.Draft&quot; true という部分で、ドラフト記事を抽出するための検索条件を指定しています。 サイト内のすべてのページ (.Site.Pages) から、ページ変数の .Draft の値が true であるもの (&quot;.Draft&quot; true) を列挙する、という指定になっています。 テンプレートの中でドラフト記事かどうかを判別する テンプレートファイル の中で、今レンダリングしている記事がドラフトである（フロントマターに draft: true と記述されている）かどうかを調べるには、Page 変数 の .Draft を参照します。 layouts/_default/single.html（抜粋） &lt;h1&gt;{{ .Title }}&lt;/h1&gt; {{ if .Draft }} &lt;b&gt;注: この記事はまだドラフトです。&lt;/b&gt; {{ end }}"},{url:"/p/bt5enw6/",title:"Hugo で新規の Web サイトを作成する",date:"2017-08-23T00:00:00+09:00",body:"Hugo で新規の Web サイトを作成する ここでは、Hugo を使用して、新しく Web サイトを構築するための手順を示します。 図: Hugo で生成したサイトの例 サイトのスケルトンを生成する まずは Hugo をインストールして、hugo コマンドを使用できる状態にしてください。 下記のように hugo new site コマンドを使用して、Web サイトのひな型を作成することができます。 新しい Web サイト (my_site) を作成する $ hugo new site my_site Congratulations! Your new Hugo site is created in C:\\Users\\maku\\my_site. Just a few more steps and you&#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/, or create your own with the &#34;hugo new theme &lt;THEMENAME&gt;&#34; command. 2. Perhaps you want to add some content. You can add single files with &#34;hugo new &lt;SECTIONNAME&gt;\\&lt;FILENAME&gt;.&lt;FORMAT&gt;&#34;. 3. Start the built-in live server via &#34;hugo server&#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 生成されるファイル群はものすごくシンプルで、下記のようにファイル２つと、いくつかのディレクトリだけです。 my_site/ +-- config.toml （サイト全体の設定） +-- archetypes/ （新しいページを作成するときのひな形） | +-- default.md +-- content/ （記事を格納。Markdown 形式のファイルを置いていく） +-- data/ （サイト生成時に利用するデータ） +-- layouts/ （レイアウトテンプレート） +-- static/ （画像ファイルなど、サイト生成時にそのままコピーするファイルを置く） +-- themes/ （テーマディレクトリを配置。実際にどのテーマを使用するかは config.toml で指定） サイトのテーマをインストール、設定する 参考: Hugo のテーマを設定する Hugo で新規に Web サイトを生成したら、外観を定義するためのテーマを１つ設定します（何らかのテーマを設定しておかないと、生成されたサイトは空っぽ（真っ白）になってしまいます）。 hugo new site によるサイト生成では、テーマまでは生成されないので、ネット上に公開されているテーマをダウンロードしてきます。 ここでは、mainroad というテーマ を使用してみましょう。 Hugo のテーマは、themes ディレクトリの下に、テーマ用のディレクトリを作って保存します。 テーマ別にディレクトリを分けて保存するので、複数のテーマをあらかじめダウンロードしておくことができます（実際に使用するテーマは簡単に切り替えられます（後述））。 テーマは GitHub で配布されているので、Git がインストールされているのであれば、下記のように簡単にインストールできます。 $ cd themes $ git clone https://github.com/vimux/mainroad themes/mainroad というディレクトリが作成されれば OK です。 あとは、実際にこのテーマを使用するように、Hugo の設定ファイル (config.toml) に下記の一行を追加してください。 config.toml（抜粋） theme = &#34;mainroad&#34; これでテーマの設定は完了です。 サイトのタイトルと言語を設定する サイトの設定ファイルでは、テーマ設定以外にも、サイトタイトル (title) や、全体で使用する言語 (languageCode) の設定を行っておきます。 config.toml baseURL = &#34;http://example.org/&#34; languageCode = &#34;ja-jp&#34; title = &#34;My New Hugo Site&#34; theme = &#34;mainroad&#34; ☝️ ワンポイント ここで設定した値は、テンプレートファイルの中から、{{ .Site.Title }}、{{ .Site.BaseURL }}、{{ .Site.LanguageCode }} のように参照することができます。 記事を作成する 参考: Hugo で記事を作成する ここでは、サンプル記事を 1 つだけ作成しておきましょう。 次のように hugo new コマンドを実行すると、content ディレクトリ以下に記事ファイル（Markdown ファイル）が自動作成されます。 コマンドはプロジェクトのトップディレクトリで実行してください。 $ hugo new post/sample.md これで content/post/sample.md というファイルが生成されるので、下記のような感じになるように修正してください。 content/post/sample.md --- title: &#34;記事のタイトル&#34; date: 2017-08-25T22:20:24+09:00 --- 記事の本文 記事の本文 記事の本文 ヘッダ部分に、draft: true という行があると、ページが出力されなくなってしまうので、その行は削除してください（参考: Hugo でドラフトページを作成する）。 Hugo の Web サーバーを起動する Web サイトのテーマ設定や記事作成が終わったら、hugo server コマンドを実行して Web サーバーを起動します（実際には、Web サーバーは起動したままで記事の作成を行っていけます）。 $ hugo server Started building sites ... Built site for language en: 0 draft content 0 future content 0 expired content 1 regular pages created 6 other pages created 0 non-page files copied 1 paginator pages created 0 tags created 0 categories created total in 8 ms Watching for changes in C:\\Users\\maku\\my_site\\{data,content,layouts,static,themes} Serving pages from memory Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop Hugo サーバーの起動にかかった時間は、たったの 8ms です。爆速ですね。 Hugo サーバが起動した状態で、Web ブラウザから http://localhost:1313/ にアクセスすると、サイトのトップページが表示されます。 あとは、hugo new コマンドを使って記事をどんどん作成していくだけです。 Hugo サーバは、content ディレクトリ内の変更を監視しており、記事が作成されたり修正されたりした場合に自動的にリロードしてくれるので、Hugo サーバは一度立ち上げたら立ち上げっぱなしで大丈夫です。 記事のカスタマイズ方法は、テーマごとに異なりますので、詳しくは各テーマのサイトを参照してください。"},{url:"/p/r8ufyk5/",title:"Hugo とは／Hugo をインストールする",date:"2017-08-23T00:00:00+09:00",body:"Hugo とは／Hugo をインストールする Hugo とは Hugo (https://gohugo.io/) Hugo は Jekyll や Middleman と同様の静的サイトジェネレータです。 Markdown 形式などで記述したコンテンツから、HTML ファイルを作成してくれます。 Hugo は Google の Go 言語 で作成されており、他のサイトジェネレータに比べて 動作が非常に速い という特徴を持っています（それに比べて Jekyll は特に遅いですね ^^;）。 公式サイトでも動作の高速さをアピールしており、今後もその方針は変わらなさそうなので安心です。 また、インストールに関しても、他の（Ruby 製や Python 製の）サイトジェネレータは、さまざまな外部モジュールをインストールしなければいけないので時間がかかったりすることがありますが、Hugo であれば一瞬で終わります。 例えば、Windows の実行環境を構築する場合も、hugo.exe という１ファイルを置くだけで終わります。 LiveReload などの機能もデフォルトで組み込まれており、立ち上げまでの導入が非常にシンプルです。 Hugo のインストール Mac OS の場合 Mac の場合は、Homebrew (brew) で簡単に Hugo をインストール できます。 $ brew install hugo すでに Hugo がインストールされている状態で、Hugo を最新バージョンに更新 したいときは次のようにします。 $ brew upgrade hugo 現在インストールされている Hugo のバージョン は次のように確認できます。 $ hugo version Windows の場合 Windows の場合は、Hugo の Releases ページから zip アーカイブ（hugo_extended_0.110.0_windows-amd64.zip など）をダウンロードしてしまうのが手っ取り早いでしょう。 Sass などの機能を使う場合は、hugo_extended で始まるファイルを使わないといけないことに注意してください。 展開した hugo.exe を適当なディレクトリに置いて、パスを通せばインストール完了です。 簡単！ 現在インストールされている Hugo のバージョン は次のように確認できます。 $ hugo version"},{url:"/p/k84zg8x/",title:"git プロトコルではなく強制的に https プロトコルで git clone するようにする (url.xxx)",date:"2017-08-22T00:00:00+09:00",body:"git プロトコルではなく強制的に https プロトコルで git clone するようにする (url.xxx) プロキシ環境化で作業している場合は、git プロトコルによるフェッチを実行したときも、強制的に https プロトコルを使用してフェッチしたいことがあります。 $ git clone git://github.com/xxx/yyy.git # のようなコマンドの実行を、 $ git clone https://github.com/xxx/yyy.git # というコマンドで実行したことにしたい このようなときは、下記の設定を行っておくと、自動的に https プロトコル経由でのフェッチに置き換えてくれるようになります。 $ git config --global url.https://github.com/.insteadOf git://github.com/ 自分でフェッチ先の URL を https://... と指定できるようなケースではこのような設定は必要ないのですが、何らかのツールが内部で git プロトコルを使用する前提になっているときにはこの設定を活用できます。 例えば、Ruby の Bundler などでモジュールをインストールするときには、内部で勝手に git プロトコル経由でフェッチすることがあり、プロキシ環境下からアクセスできないことがあります。 このような場合は、上記のような設定で強制的に https 経由のアクセスに置き換えることで https プロキシ経由でアクセスできるようになります。"},{url:"/p/6vkj2pi/",title:"Linuxメモ: 実行中のシェルスクリプトのファイル名を取得する ($0)",date:"2017-08-20T00:00:00+09:00",body:"Linuxメモ: 実行中のシェルスクリプトのファイル名を取得する ($0) シェルスクリプト内から、自身のファイル名を取得するには $0 という特殊変数を参照します。 sample.sh #!/bin/bash echo &#34;$0&#34; 正確には、$0 に格納されているパスは、そのスクリプト実行時に実際に指定したパスになります。 そのため、どのようにスクリプトを起動したかによって結果が変わってきます。 # 絶対パスで起動した場合 $ /Users/maku/sample.sh /Users/maku/sample.sh # 相対パスで起動した場合 $ cd /Users $ maku/sample.sh maku/sample.sh # カレントディレクトリのスクリプトを起動した場合 $ ./sample.sh ./sample.sh # sh コマンドのパラメータで起動した場合 $ sh sample.sh sample.sh 確実にファイル名（ベース名）だけを取得したい場合や、絶対パスを取得したい場合は以下のようにするのがよいでしょう。 sample.sh #!/bin/bash MY_BASENAME=$(basename $0) MY_ABS_PATH=$(cd $(dirname $0); pwd)/$MY_BASENAME echo &#34;$MY_BASENAME&#34; echo &#34;$MY_ABS_PATH&#34; 実行結果 $ ~/sample.sh sample.sh /Users/maku/sample.sh"},{url:"/p/cj2uie9/",title:"git diff や git status での日本語の文字化けを防ぐ (core.page, core.quotepath)",date:"2017-08-19T00:00:00+09:00",body:"git diff や git status での日本語の文字化けを防ぐ (core.page, core.quotepath) git diff での文字化け git diff の出力に日本語が含まれているときに、下記のように２桁の数値ばかりの表示に文字化けしてしまうことがあります。 $ git diff diff --git a/README.txt b/README.txt index 0005c4e..5d6ea9c 100644 --- a/README.txt +++ b/README.txt @@ -1 +1 @@ -&lt;E3&gt;&lt;81&gt;&lt;82&gt;&lt;E3&gt;&lt;81&gt;&lt;84&gt;&lt;E3&gt;&lt;81&gt;&lt;86&gt;&lt;E3&gt;&lt;81&gt;&lt;88&gt;&lt;E3&gt;&lt;81&gt;&lt;8A&gt; +&lt;E3&gt;&lt;81&gt;&lt;8B&gt;&lt;E3&gt;&lt;81&gt;&lt;8D&gt;&lt;E3&gt;&lt;81&gt;&lt;8F&gt;&lt;E3&gt;&lt;81&gt;&lt;91&gt;&lt;E3&gt;&lt;81&gt;&lt;93&gt; このような場合は、ページャの設定 (core.pager) で下記のように LESSCHARSET を設定するようにします。 $ git config --global core.pager &#34;LESSCHARSET=utf-8 less&#34; あるいは、システムの環境変数で Git のページャ設定を行っておくこともできます。 ~/.bashrc export GIT_PAGER=&#34;LESSCHARSET=utf-8 less&#34; これで正しく日本語の差分が表示されるようになります。 $ git diff diff --git a/README.txt b/README.txt index 0005c4e..5d6ea9c 100644 --- a/README.txt +++ b/README.txt @@ -1 +1 @@ -あいうえお +かきくけこ Windows の場合は、環境変数 LANG を設定しておくとよいようです。 C:\\&gt; set LANG=ja_JP.UTF-8 git status での文字化け git status の表示で、日本語のファイル名が下記のように文字化けしてしまうことがあります。 $ git status On branch master Untracked files: (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed) &#34;\\343\\201\\202\\343\\201\\202\\343\\201\\202.txt&#34; nothing added to commit but untracked files present (use &#34;git add&#34; to track) このような場合は、下記のように core.quotepath 設定を false に設定します。 $ git config --global core.quotepath false これで正しく日本語のファイル名が表示されるようになります。 $ git status On branch master Untracked files: (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed) あああ.txt nothing added to commit but untracked files present (use &#34;git add&#34; to track) 設定の確認と削除 上記で設定した値を確認するには次のようにします。 $ git config --global --list core.pager=LESSCHARSET=utf-8 less core.quotepath=false 設定した値をクリアするには次のようにします。 $ git config --global --unset core.pager $ git config --global --unset core.quotepath"},{url:"/p/3qnenzf/",title:"Linuxメモ: ディレクトリ内のファイルを zip ファイルにバックアップする",date:"2017-08-19T00:00:00+09:00",body:"Linuxメモ: ディレクトリ内のファイルを zip ファイルにバックアップする zip コマンドの基本 下記のようにすると、sample ディレクトリ内のファイルをすべて sample.zip アーカイブとして保存することができます。 $ zip -r sample.zip sample より上位のディレクトリからアーカイブを作成する場合は、同様に、 $ zip -r sample.zip aaa/bbb/ccc/sample とすることができますが、このようにすると、アーカイブ内に aaa/bbb/ccc ディレクトリが含まれてしまいます。 アーカイブ内のトップのディレクトリを sample ディレクトリにしたい場合は、次のようにカレントディレクトリを変更してから zip コマンドを実行するようにします。 $ (cd aaa/bbb/ccc &amp;&amp; zip -r sample.zip sample) コマンド全体を括弧で囲んでいるのは、コマンド実行後にシェルのカレントディレクトリを元のディレクトリに復帰させるためです。 アーカイブファイル名に日付を入れる date コマンドと組み合わせて、下記のように実行すれば、アーカイブ名に自動的に日付を入れることができます（例: sample-20170819.zip）。 $ zip -r sample-`date +%Y%m%d`.zip sample 指定したディレクトリを除いてアーカイブする 例えば、アーカイブの対象から .git ディレクトリを除きたいときは、下記のように --exclude オプションを指定します。 $ zip -r sample.zip --exclude=*/.git/* sample 複数の --exclude オプションを指定することもできます。 $ zip -r sample.zip --exclude=*/.git/* --exclude=*/.svn/* sample"},{url:"/p/je3xamc/",title:"Gradle Wrapper スクリプト (gradlew) をサブプロジェクトから簡単に呼び出せるようにする",date:"2017-08-07T00:00:00+09:00",body:"Gradle Wrapper スクリプト (gradlew) をサブプロジェクトから簡単に呼び出せるようにする Gradle Wrapper Wrapper (gradleww) とは Gradle Wrapper Wrapper (gradleww) を使用すると、サブプロジェクト（サブディレクトリ）で作業しているときに、プロジェクトのルートにおいてある gradlew を簡単に呼び出すことができるようになります。 例えば、通常はサブプロジェクトで作業しているときは、gradlew コマンドを実行するときにこんな感じで実行することになります。 $ ../../gradlew assembleDebug gradlew の代わりに gradleww コマンドを実行するようにすれば、次のように簡単に呼び出すことができます（内部で自動的に上位ディレクトリの gradlew を実行してくれます）。 $ gradleww assembleDebug Gradle Wrapper (gradlew) をさらにラップしたコマンドのため、Gradle Wrapper Wrapper (gradleww) と呼んでいます。 Gradlew Wrapper Wrapper (gradleww) のインストール Gradle Wrapper Wrapper（gradleww コマンド）は、RubyGems パッケージとして配布されているため、Ruby 環境がインストールされていれば、下記のように簡単にインストールすることができます。 $ gem install gradleww"},{url:"/p/uu32hpo/",title:"（旧）CSS によるフレキシブルボックスの旧式の定義方法",date:"2017-08-03T00:00:00+09:00",body:"（旧）CSS によるフレキシブルボックスの旧式の定義方法 参考: フレキシブルボックスによるレスポンシブレイアウト フレキシブルボックスの定義に、昔は display: box を使用していましたが、最新の W3C 仕様では display: flex となっています。 Chrome ~20: display:-webkit-box Chrome ~28: display:-webkit-flex Chrome 28~: display:flex Firefox ~21: display:-moz-box Firefox 22~: display:flex IE9: (not supported) IE10: display:-ms-flexbox IE11: display:flex Safari ~6.0: display:-webkit-box Safari 6.1~: display:-webkit-flex Android ~4.3: display:-webkit-box Android 4.4~: display:flex iOS(Safari) ~6.1: display:-webkit-box iOS(Safari) 7.0~: display:-webkit-flex フレキシブルボックス用の display 指定は、このように定義しておけばよさそうです。 display: flex; display: -webkit-flex; display: -webkit-box; display: -moz-box; さらに、伸縮時の割合の指定は、box-flex の代わりに flex-grow を使用します。 flex-grow: 1; -webkit-flex-grow: 1; -webkit-box-flex: 1; -moz-box-flex: 1; 参考: Can I use &hellip; Support tables for HTML5, CSS3, etc 参考: 可変ボックス (&ldquo;Flexbox&rdquo;) レイアウトの更新 (Windows)"},{url:"/octave/",title:"Octave",date:"2017-03-31T00:00:00+09:00",body:"Octave 行列／ベクトルの作成 行列／ベクトルを作成する 零行列（零行列）を作成する (zeros) 単位行列を作成する (eye) すべての要素が 1 の行列を作成する (ones) ランダムな数値で行列を作成する (rand) 転置行列を作成する 逆行列を作成する (inv) 対角行列を作成する (diag) 行列／ベクトルに対する処理 行列／ベクトルのサイズ（形状）を確認する (size, length) 行列／ベクトルのサイズを変更する 行列／ベクトル内の要素を参照する 行列／ベクトルを結合する 行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う 制御命令／関数 Octave の制御命令: if ~ else Octave の制御命令: switch ~ case Octave の制御命令: for / while / until ループ Octave で関数を定義する (function) ファイル／入出力／表示設定 ファイルに記述したプログラムを実行する（スクリプトファイル） ファイルに記述した関数を実行する（関数ファイル） ファイルに記述したデータを読み込む/保存する (load, save) 出力する桁数を増やす (format) メモ コーディングルールなど インデントは 4。 文字列はシングルクォート (') で囲む。 画像は 400x300 の PNG で出力する (print '-S400,300' fig.png)。 TeX チートシート｜まくろぐ"},{url:"/p/o9qhvyu/",title:"Octave でファイルに記述した関数を実行する（関数ファイル）",date:"2017-03-31T00:00:00+09:00",body:"Octave でファイルに記述した関数を実行する（関数ファイル） 関数ファイルの基本 Octave で読み込む外部ファイル (.m) が、関数定義 (function) で始まっていると、そのファイルは 関数ファイル として認識され、組み込み関数のように呼び出せるようになります。 関数ファイルの名前は、ファイルの先頭で定義する関数名に合わせます。 次の例では myfunc という関数を定義しているので、ファイル名は myfunc.m とします。 myfunc.m function y = myfunc(x) y = x**2; end 上記のように関数ファイルで定義した関数は、組み込み関数と同じ感覚で呼び出すことができます。 &gt;&gt; myfunc(7) 49 サブファンクション 関数ファイルで定義された関数は、先頭で定義した関数だけが公開されます。 例えば、下記の関数ファイルでは、hello 関数と hello2 関数を定義していますが、外部から呼び出せる関数は hello 関数だけであり、hello2 関数はファイル内からのみ呼び出せるサブファンクション として定義されます。 hello.m % 先頭で定義されているこの関数だけが公開される function hello() disp(&#39;hello&#39;); hello2(); end % 以降の関数はサブファンクションとみなされて外部には公開されない function hello2() disp(&#39;hello2&#39;) end 実行例 &gt;&gt; hello hello hello2 &gt;&gt; hello2 % サブファンクションは外からは直接呼び出せない error: &#39;hello2&#39; undefined near line 1 column 1 プライベートファンクション サブファンクションは、定義したファイル内でしか呼び出すことができないので、いろいろな関数から呼び出したいヘルパー関数を作成したいときには都合が悪いです。 このような場合は、ヘルパー関数を プライベートファンクション として別の関数ファイルに分離しておきます。 作成方法は通常の関数ファイルと同様ですが、作成したファイルを private ディレクトリ内に格納するようにします。 下記の例では、通常の関数ファイル hello.m から、プライベートファンクションとして定義された private_func を呼び出しています。 hello.m function hello() disp(&#39;hello&#39;); private_func(); end private/private_func.m function private_func() disp(&#39;private_func&#39;); end 実行例 &gt;&gt; hello() hello private_func 1 つのファイルで複数の関数を公開する 関数ファイルでは、先頭で定義した関数しか公開されませんが、複数の関数定義を含んだファイルをスクリプトとして実行してしまうことは可能です。 例えば、下記のように、関数 foo と関数 bar の定義を含んだスクリプトを用意して、これをスクリプトとして読み込めば、2 つの関数を外部から呼び出せるようになります。 functions.m 1; % Load as a script function foo() disp(&#39;foo&#39;); end function bar() disp(&#39;bar&#39;); end 先頭が function 定義で始まってしまうと、関数ファイルとして認識されてしまうので、ダミーの 1; というコードを入れて、強制的にスクリプトファイルとして処理されるようにしていることに注意してください。 あとは、このスクリプトを実行すれば、2 つの関数（foo と bar）を任意のタイミングで呼び出せるようになります。 実行例 &gt;&gt; functions % スクリプトとして functions.m を実行 &gt;&gt; foo() foo &gt;&gt; bar() bar"},{url:"/p/vo54icm/",title:"Octave で関数を定義する (function)",date:"2017-03-29T00:00:00+09:00",body:`Octave で関数を定義する (function) 関数定義の基本 Octave で関数を定義するには、function ~ end の構文を使用します。 例えば、渡された数値の 2 乗を返す関数 myfunc は下記のように定義できます。 myfunc 関数を定義する function ret = myfunc(x) ret = x ** 2; end myfunc 関数を呼び出す y = myfunc(7); %=&gt; 49 戻り値は return で指定するのではなく、関数値用に宣言した変数に代入することで表現することに注意してください。 上記の例では、関数値を表す変数は ret という名前で定義していますが、任意の名前を付けることができます。 もちろん、関数を途中で抜けるときは return を使用することができますが、その場合も戻り値はあらかじめ関数値用の変数に格納しておく必要があります。 途中で関数を抜ける場合 function y = f(x) if x == 0 y = -1; % 戻り値は return では返せない return end ... end 戻り値を持たない関数を定義する 戻り値を持たない関数も同様に定義できます（関数というよりサブルーチンというのが正しいのかも）。 内部で出力処理まで終わらせてしまうような関数がこれにあたります。 function greet(name) printf(&#39;Hello %s\\n&#39;, name); end 多値関数（複数の戻り値を持つ関数）を定義する 関数値としてベクトルを返すように定義すれば、複数の戻り値を持つ関数として扱うことができます。 下記の例では、除算結果の商と剰余を返す関数を定義しています。 2 つの値を返す関数 function [quotient, remainder] = div(x, y) quotient = floor(x / y); remainder = rem(x, y); end 呼び出し方 [a, b] = div(10, 3); printf(&#39;a=%d, b=%d\\n&#39;, x, y); % a=3, b=1 パラメーターにデフォルト値（オプショナル引数）を設定する パラメーター名の後にデフォルト値を指定しておくことができます。 パラメーターを省略して関数を呼び出した場合に、デフォルト値が使用されます。 デフォルト値を持つパラメーター function greet(name = &#39;Maku&#39;) printf(&#39;Hello, %s\\n&#39;, name); end 呼び出し方 greet(); %=&gt; Hello, Maku greet(&#39;John&#39;); %=&gt; Hello, John`},{url:"/p/bi5rv73/",title:"Octave でファイルに記述したデータを読み込む/保存する (load, save)",date:"2017-03-27T00:00:00+09:00",body:"Octave でファイルに記述したデータを読み込む/保存する (load, save) ファイルからデータを読み込む (load) Octave で、ファイルに保存したデータファイルを読み込むには、組み込み関数の load を使用します。 例えば、下記のような二次元データ（行列データ）があるとします。 mydata.txt 100 200 300 400 500 600 700 800 900 このデータファイルを読み込むには、下記のようにします（あらかじめ cd コマンドで、データファイルのあるディレクトリに移動しておいてください）。 データファイルの内容は、ファイル名と同じ名前の変数に格納されます。 データファイルを読み込む &gt;&gt; load mydata.txt &gt;&gt; mydata mydata = 100 200 300 400 500 600 700 800 900 データファイルの内容を別の名前の変数に格納したいときは、次のように load 関数の戻り値を変数に代入します。 データファイルを指定した変数に読み込む &gt;&gt; A = load(&#39;mydata.txt&#39;) A = 100 200 300 400 500 600 700 800 900 ちなみに、現在定義されている変数の一覧を表示するには、whos コマンドを使用します。 変数の一覧を表示 &gt;&gt; whos Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== mydata 3x3 72 double ファイルから読み込んだ mydata が、サイズ 3x3 のデータとして定義されていることが分かります。 ファイルにデータを保存する (save) 逆に、Octave の実行環境上で作成した行列データなどをデータファイルとして出力するには、save 関数を使用します。 次の例では、行列 A と B のデータを mydata.txt というファイルに保存しています。 行列データをファイルに保存する &gt;&gt; A = [1 2 3; 4 5 6; 7 8 9]; &gt;&gt; B = [100 200 300; 400 500 600]; &gt;&gt; save mydata.txt A B ここでは保存する変数を、save のパラメーターで明示的に列挙していますが、変数の指定を省略すると、ワークスペース内で定義されている変数（whos で出てくるデータ）がすべて保存されます。 save の実行に成功すると、下記のようなファイルが生成されます。 mydata.txt # Created by Octave 4.2.1, Mon Mar 27 22:13:04 2017 GMT &lt;unknown@unknown&gt; # name: A # type: matrix # rows: 3 # columns: 3 1 2 3 4 5 6 7 8 9 # name: B # type: matrix # rows: 2 # columns: 3 100 200 300 400 500 600 save コマンドで作成したファイルには、上記のようにヘッダ情報が付け加えられており、変数名（ここでは A や B）も一緒に保存されています。 このファイルを load で読み込んだときは、ヘッダに記述された変数名でデータがロードされます。 データファイルからすべての変数を復旧する &gt;&gt; clear % ワークスペースの変数をすべてクリア &gt;&gt; load mydata.txt % ファイル読み込み &gt;&gt; whos % 変数を確認 Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== A 3x3 72 double B 2x3 48 double ファイル内の任意のデータだけをロードすることもできます。 下記の例では、mydata.txt に保存された B のデータのみを読み込んでいます。 データファイルから指定した変数のみ復旧する &gt;&gt; clear &gt;&gt; load mydata.txt B % 変数 B だけ取り出す &gt;&gt; whos Variables in the current scope: Attr Name Size Bytes Class ==== ==== ==== ===== ===== B 2x3 48 double"},{url:"/p/mgjgq8m/",title:"Octave でファイルに記述したプログラムを実行する（スクリプトファイル）",date:"2017-03-27T00:00:00+09:00",body:"Octave でファイルに記述したプログラムを実行する（スクリプトファイル） スクリプトファイルと実行方法 Octave では、カレントディレクトリに スクリプト名.m という名前でスクリプトファイルを作成しておくと、下記のようにしてそのスクリプトを実行することができます。 スクリプト名.m の呼び出し &gt;&gt; スクリプト名 ただし、スクリプトファイルが置かれたディレクトリで実行しなければいけません。 カレントディレクトリを移動するには、cd コマンドを実行します。 次のようにしてスクリプトを格納したディレクトリに移動しましょう。 &gt;&gt; cd D: % D ドライブのルートへ移動 カレントディレクトリがどこになっているかを確認するには、pwd コマンドを実行します。 &gt;&gt; pwd ans = C:\\Users\\maku スクリプトの実行例 ここでは、下記のようなスクリプトファイルを用意してみます。 myscript.m [X, Y] = meshgrid(-8:.5:8); R = sqrt(X.^2 + Y.^2) + eps; Z = sin(R) ./ R; figure mesh(X, Y, Z) このファイルが置いてあるディレクトリに移動して、拡張子 .m を除いた部分の名前を入力すると、スクリプトを実行できます。 &gt;&gt; cd somewhere &gt;&gt; myscript 次のようなグラフが表示されれば成功です。 図: myscript.m によるグラフ描画"},{url:"/p/8tddagn/",title:"Octave で対角行列を作成する (diag)",date:"2017-03-27T00:00:00+09:00",body:"Octave で対角行列を作成する (diag) $$ diag(c_1, c_2, &hellip;, c_n) = \\begin{pmatrix} c_1 &amp; &amp; &amp; 0 \\\\ &amp; c_2 &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; \\\\ 0 &amp; &amp; &amp; c_n \\end{pmatrix} $$ 正方行列のうち、対角成分 (diagonal elements) 以外がすべて零のものを 対角行列 (diagonal matrix) といいます。 Octave の組み込み関数 diag を使用すると、対角行列からの対角成分の抽出や、対角成分からの対格行列の生成を行うことができます。 対角行列から対角成分を抽出する &gt;&gt; A = [3 0 0; 0 -1 0; 0 0 2] A = 3 0 0 0 -1 0 0 0 2 &gt;&gt; v = diag(A) v = 3 -1 2 抽出された対角成分は、列ベクトルとして返されます。 対角成分から対角行列を生成する &gt;&gt; A = diag([3 -1 2]) A = Diagonal Matrix 3 0 0 0 -1 0 0 0 2 指定する対角成分は、行ベクトルでも縦ベクトルでも構いません（上記では行ベクトルを渡しています）。"},{url:"/p/xfuxvwq/",title:"Octave で行列／ベクトルのサイズを変更する",date:"2017-03-27T00:00:00+09:00",body:"Octave で行列／ベクトルのサイズを変更する 行列サイズを拡張する 既存の行列の存在しない領域の要素に代入を行うと、行列のサイズが自動的に拡張されます。 下記の例では、2x2 の行列に対して、(4,4) の位置に値を代入する操作をしています。 &gt;&gt; A = [1 2; 3 4] A = 1 2 3 4 &gt;&gt; A(4, 4) = 7 A = 1 2 0 0 3 4 0 0 0 0 0 0 0 0 0 7 上記のように、行列のサイズは自動的に拡張されて、4x4 になります。 自動的に拡張されて、値が指定されていない部分の値は 0 が設定されます。 ベクトルのサイズも同様に拡張できます。 &gt;&gt; v = 1:3 v = 1 2 3 &gt;&gt; v(7) = 100 v = 1 2 3 0 0 0 100 もちろん、下記のように行列を結合した場合も、行列のサイズは自動的に拡張されることになります。 &gt;&gt; v = [1 2; 3 4] v = 1 2 3 4 &gt;&gt; v = [v [5 6]&#39;] v = 1 2 5 3 4 6 行列のサイズを縮小する 行列から部分行列を抽出すれば、行列のサイズを縮小したものとして扱うことができます。 下記の例では、ランダムに作成した 5x5 の行列から、3x3 の部分行列を抽出して、自分自身に書き戻しています。 &gt;&gt; A = floor(rand(5)*10) % 0～9 のランダム値で 5x5 行列を生成 A = 6 5 9 6 7 8 8 4 7 4 2 2 3 1 4 3 4 0 3 0 9 6 7 9 3 &gt;&gt; A = A(1:3, 1:3) A = 6 5 9 8 8 4 2 2 3"},{url:"/p/h9pgnw6/",title:"Octave の制御命令: for / while / until ループ",date:"2017-03-27T00:00:00+09:00",body:"Octave の制御命令: for / while / until ループ Octave のループ構文は、下記のようなものが用意されています。 for ループ while ループ do ~ until ループ Octave には do ~ while ループや、単純な until ループは存在しないことに注意してください。 C++ や Java と同様に、各ループ処理の中では、continue によるループ継続や、break によるループ脱出を行えます。 for ループ for x = ベクトル ... end とすると、ベクトル要素（あるいは行列要素）を 1 つずつ取り出しながらループ処理を行うことができます。 下記の例では、1～5 までの値を順番に足しこんでいく様子を表示しています。 1 ~ 5 まで合計する sum = 0 for x = 1:5 sum += x; disp(sum) end 実行結果 1 3 6 10 15 for ループは入れ子構造で記述することもできます。 下記は 2 重ループで 3x3 の行列を初期化しています。 3x3 行列の初期化 for i = 1:3 for j = 1:3 A(i, j) = i * j; end end disp(A) 実行結果 1 2 3 2 4 6 3 6 9 次の例では、行列 A の各要素をループでひとつずつ取得して表示しています。 組み込み関数の size は行列のサイズを返してくれますが、第２パラメータで 1 と 2 を指定することで、それぞれ行数、列数を返してくれるようになります。 これを利用して、正しい数だけループ処理しています。 行列の要素を行ごとにループ処理 A = [1 2 3; 4 5 6]; for i = 1:size(A, 1) % 行の数だけループ（２回） for j = 1:size(A, 2) % 列の数だけループ（３回） disp(sprintf(&#39;A(%d,%d)=%d&#39;, i, j, A(i,j))) end end 実行結果 A(1,1)=1 A(1,2)=2 A(1,3)=3 A(2,1)=4 A(2,2)=5 A(2,3)=6 下記のように行、列のサイズを別々の変数に取得してしまうのもアリですね。 [i_max, j_max] = size(A); for i = 1:i_max for j = 1:j_max disp(A(i,j)) end end while ループ while ループでは、指定した条件を満たす限りループ処理が継続されます。 i = 0; while (i &lt; 10) ++i endwhile 条件式に true を指定すれば、無限ループを作成することができますが、その場合はループ内で何らかの条件で break しなければいけません。 下記の例では、ユーザが 10 以上の数値を入力するまで、ユーザからの入力を求め続けます。 10 以上の値が入力されるまで繰り返す while true num = input(&#39;num? &#39;); if (num &gt; 10) break end endwhile Octave の if ブロックは、上記のように必ず end で終わらなければいけないことに注意してください（end を省略することはできません）。 do ～ until ループ do ~ until ループは、ある条件を満たすまでループを実行します。 条件判定はブロック内の処理を実行してから行われるため、必ず 1 回はブロック内の処理が実行されます。 i が 10 以上になるまでループ処理 i = 0; do ++i until (i &gt;= 10)"},{url:"/p/4x34ejm/",title:"Octave の制御命令: if ～ else",date:"2017-03-27T00:00:00+09:00",body:"Octave の制御命令: if ～ else Octave (MATLAB) の if ～ else の構文は以下のようになっています。 if (COND) ... elseif (COND) ... else ... end 条件式では下記のような比較演算子が使用できます。 特に、a と b が等しくないことを表す記号が ~= であることに注意してください。 演算子 意味 a == b a と b が等しい a ~= b a と b が等しくない a &lt; b a が b より小さい a &gt; b a が b より大きい a &lt;= b a が b 以下 a &gt;= b a が b 以上 a a が 0 以外 また、論理演算子を組み合わせて使用できます。 演算子 意味 COND1 || COND2 COND1 あるいは COND2 が真ならば真 COND1 &amp;&amp; COND2 COND1 と COND2 両方が真ならば真 !COND1 真偽値の反転 例: x の値によって分岐する x = 2 if (x == 1) disp(&#39;one&#39;) elseif (x == 2) disp(&#39;two&#39;) else disp(&#39;other&#39;) end"},{url:"/p/r9h53gn/",title:"Octave の制御命令: switch ～ case",date:"2017-03-27T00:00:00+09:00",body:"Octave の制御命令: switch ～ case 変数に格納された値の種類によって分岐処理を行うには、次のように switch と case で分岐させます。 val = 2 switch val case 1 disp(&#39;one&#39;) case 2 disp(&#39;two&#39;) otherwise disp(&#39;other&#39;) endswitch 下記のように、複数のパターンを１つの case でまとめて処理することもできます。 yesno = &#39;yes&#39;; switch yesno case {&#39;Yes&#39; &#39;yes&#39; &#39;YES&#39; &#39;y&#39; &#39;Y&#39;} value = 1; case {&#39;No&#39; &#39;no&#39; &#39;NO&#39; &#39;n&#39; &#39;N&#39;} value = 0; otherwise error (&#39;invalid value&#39;); endswitch 逆に、下記のように、複数の case を連続して記述する方法はうまくいかないので注意してください（値が 1 のケースは何も処理しないという意味になってしまいます）。 間違った書き方 switch val case 1 % 間違った書き方 case 2 disp(&#39;one or two&#39;) otherwise disp(&#39;other&#39;) endswitch"},{url:"/p/ngxvjuy/",title:"Octave ですべての要素が 1 の行列を作成する (ones)",date:"2017-03-24T00:00:00+09:00",body:"Octave ですべての要素が 1 の行列を作成する (ones) Octave の組み込み関数 ones を使用すると、すべての要素が 1 である行列を作成することができます。 &gt;&gt; ones(3) ans = 1 1 1 1 1 1 1 1 1 &gt;&gt; ones(2, 4) ans = 1 1 1 1 1 1 1 1 スカラー値を掛けることで、1 以外の任意の値にすることができます。 &gt;&gt; ones(2, 4) * 7 ans = 7 7 7 7 7 7 7 7 ones 関数のドキュメント &gt;&gt; help ones &#39;ones&#39; is a built-in function from the file libinterp/corefcn/data.cc -- ones (N) -- ones (M, N) -- ones (M, N, K, ...) -- ones ([M N ...]) -- ones (..., CLASS) Return a matrix or N-dimensional array whose elements are all 1. If invoked with a single scalar integer argument N, return a square NxN matrix. If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions. To create a constant matrix whose values are all the same use an expression such as val_matrix = val * ones (m, n) The optional argument CLASS specifies the class of the return array and defaults to double. For example: val = ones (m,n, &#34;uint8&#34;)"},{url:"/p/kyjrsit/",title:"Octave でランダムな数値の行列を作成する (rand)",date:"2017-03-24T00:00:00+09:00",body:"Octave でランダムな数値の行列を作成する (rand) 0 ～ 1 のランダムな実数を生成する 組み込み関数の rand を使用すると、(0, 1) の範囲のランダムな実数を生成することができます。 &gt;&gt; x = rand() x = 0.68694 パラメータとして、行列のサイズを指定することで、ランダムな数値からなる行列を生成することができます。 &gt;&gt; rand(3) ans = 0.21961 0.93511 0.42575 0.40439 0.57059 0.47850 0.33873 0.52912 0.58643 &gt;&gt; rand(2, 4) ans = 0.710878 0.077407 0.991165 0.606275 0.807493 0.428040 0.497468 0.606412 任意の範囲のランダム値を生成する 任意の数値の範囲のランダム値を生成するには、下記のような演算を行います。 例: 0 ～ 10 の範囲のランダム値を生成 &gt;&gt; rand * 10 ans = 8.0312 例: -5 ～ 5 の範囲のランダム値を生成 &gt;&gt; rand * 10 - 5 ans = -4.6596 整数値にしたいときは、floor 関数を使って小数部分を切り捨てます。 例: 0 ～ 9 のランダムな整数を生成 &gt;&gt; floor(rand * 10) ans = 7 行列の要素にも適用できます。 例: 0 ～ 9 のランダムな整数からなる行列を生成 &gt;&gt; floor(rand(3) * 10) ans = 0 6 4 7 9 2 3 4 4"},{url:"/p/fism9pp/",title:"Octave で出力する桁数を増やす (format)",date:"2017-03-24T00:00:00+09:00",body:"Octave で出力する桁数を増やす (format) Octave の内部では倍精度の浮動小数点数（10 進数で 15 桁程度の精度）で計算が行われていますが、画面出力時のデフォルト桁数は 5 桁に設定されています。 &gt;&gt; pi pi = 3.1416 表示桁数を増やすには、下記のように format 関数を使用します。 表示桁数を増やす &gt;&gt; format long &gt;&gt; pi ans = 3.14159265358979 上記のように、パラメーターとして long を指定すると、倍精度実数の表現限界である 15 桁程度の数値を表示してくれるようになります。 元に戻したい場合は、パラメータなしで format 関数を実行します。 表示桁数を元に戻す &gt;&gt; format &gt;&gt; pi ans = 3.1415 format 関数で指定できるパラメータの詳細は、次のようにヘルプで確認できます。 &gt;&gt; help format"},{url:"/p/h24njtn/",title:"Octave で単位行列を作成する (eye)",date:"2017-03-24T00:00:00+09:00",body:"Octave で単位行列を作成する (eye) eye 関数 Octave で任意のサイズの 単位行列 \\(I\\) を作成するには、組み込み関数の eye を使用します。 $$ I = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; \\ldots &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; \\ldots &amp; 0 \\\\ &amp; \\vdots &amp; &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; \\ldots &amp; 1 \\end{pmatrix} $$ &gt;&gt; eye(3) ans = Diagonal Matrix 1 0 0 0 1 0 0 0 1 &gt;&gt; eye(5) ans = Diagonal Matrix 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1"},{url:"/p/aodnfsx/",title:"Octave で行列／ベクトルのサイズ（形状）を確認する (size, length)",date:"2017-03-24T00:00:00+09:00",body:"Octave で行列／ベクトルのサイズ（形状）を確認する (size, length) 行列のサイズを調べる (size) Octave の組み込み関数 size を使用すると、行列（あるいはベクトル）の形状（サイズ）を調べることができます。 &gt;&gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &gt;&gt; size(A) ans = 2 3 size メソッドの戻り値自体も、1 行 2 列の行列（行ベクトル）になっています。 &gt;&gt; size(size(A)) ans = 1 2 ベクトルのサイズを調べる (length) ベクトルのサイズを調べるときにも、size 関数を使用することができますが、代わりに length 関数を使用することで、スカラ値でベクトルのサイズを取得することができます。 length 関数は、行ベクトルの場合でも、列ベクトルの場合でも同様な値を返してくれます。 行ベクトルの場合 &gt;&gt; v = [1 2 3 4 5]; &gt;&gt; length(v) ans = 5 列ベクトルの場合 &gt;&gt; v = [1; 2; 3; 4; 5]; &gt;&gt; length(v) ans = 5 上記のように、行ベクトルでも列ベクトルでも共通の値を返してくれるのは、length 関数が 「行のサイズと列のサイズのうち大きい方を返す」 という振る舞いをするからです。 行列に対して length 関数を適用すると、下記のようにあまり意味のない結果を返すことになるので、length 関数はベクトル用だと思って使うのがよいでしょう。 &gt;&gt; length([1 2; 3 4; 5 6; 7 8]) ans = 4 &gt;&gt; length([1 2 3 4 5; 6 7 8 9 10]) ans = 5"},{url:"/p/hfgbxqq/",title:"Octave で行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う",date:"2017-03-24T00:00:00+09:00",body:"Octave で行列／ベクトルの四則演算（加算、減算、乗算、除算）を行う 行列同士の四則演算 下記のような 2 行 3 列の行列を 2 つ用意します。 &gt;&gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &gt;&gt; B = [10 20 30; 40 50 60] B = 10 20 30 40 50 60 各要素同士の四則演算を行うには、+、-、.*、./ という演算子を使用します。 .* と ./ は、ドットが必要なことに注意してください。 &gt;&gt; A + B ans = 11 22 33 44 55 66 &gt;&gt; A - B ans = -9 -18 -27 -36 -45 -54 &gt;&gt; A .* B ans = 10 40 90 160 250 360 &gt;&gt; A ./ B ans = 0.10000 0.10000 0.10000 0.10000 0.10000 0.10000 行列とスカラ値の演算 行列とスカラ値との四則演算を行うと、各要素の演算でそのスカラ値が使用されます。 &gt;&gt; A + 100 ans = 101 102 103 104 105 106 &gt;&gt; A * 100 ans = 100 200 300 400 500 600 &gt;&gt; A / 100 ans = 0.010000 0.020000 0.030000 0.040000 0.050000 0.060000 &gt;&gt; A - 100 ans = -99 -98 -97 -96 -95 -94 単項演算子を使って各要素の符号を反転することができます。 &gt;&gt; -A ans = -1 -2 -3 -4 -5 -6 次のようにすると、各要素を 2 乗できます。 &gt;&gt; A .^ 2 ans = 1 4 9 16 25 36 各要素の逆数を取ることもできます。 &gt;&gt; 1 ./ A ans = 1.00000 0.50000 0.33333 0.25000 0.20000 0.16667 各行、各列ごとにベクトルを足しこむ 行列に対してベクトルを用いた四則演算を行うと、縦方向、あるいは横方向にベクトルの要素が拡張（コピー）されて演算が行われます。 &gt;&gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &gt;&gt; A + [100 200 300] ans = 101 202 303 104 205 306 &gt;&gt; A + [100; 200] ans = 101 102 103 204 205 206"},{url:"/p/6vpzojf/",title:"Octave で行列／ベクトルを結合する",date:"2017-03-24T00:00:00+09:00",body:"Octave で行列／ベクトルを結合する 下記のような 2 行 3 列の行列が 2 つあるとします。 &gt;&gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &gt;&gt; B = [11 12 13; 14 15 16] B = 11 12 13 14 15 16 これらの行列を横方向、あるいは縦方向に繋げて新しい行列を作成することができます。 横方向に結合する &gt;&gt; C = [A B] C = 1 2 3 11 12 13 4 5 6 14 15 16 縦方向に結合する &gt;&gt; D = [A; B] D = 1 2 3 4 5 6 11 12 13 14 15 16 横方向に結合する場合は行のサイズ、縦方向に結合する場合は列のサイズが等しくなければいけません。 上記の例の場合は、たまたま行列 A と行列 B の形状が同じなので、どちらの方向にも結合できています。 次のように、直接ベクトルデータを追加するように記述することもできます。 &gt;&gt; C = [A; [7 8 9]] C = 1 2 3 4 5 6 7 8 9 &gt;&gt; D = [A [7; 8]] D = 1 2 3 7 4 5 6 8"},{url:"/p/6ss2mk8/",title:"Octave で行列／ベクトル内の要素を参照する",date:"2017-03-24T00:00:00+09:00",body:"Octave で行列／ベクトル内の要素を参照する 行列内の特定の要素を参照する 下記のような 3x3 の行列があるとします。 &gt;&gt; A = [1 2 3; 4 5 6; 7 8 9] A = 1 2 3 4 5 6 7 8 9 この行列の 1 行 2 列の位置の要素を参照するには次のようにします。 各要素を参照する方法です。 1 行 2 列の要素を参照する &gt;&gt; A(1, 2) ans = 2 行列内の要素を行単位、列単位で取得する すべての行や列を表すには、: を使います。 3 行目の要素をすべて取得する（行ベクトル） &gt;&gt; A(3, :) ans = 7 8 9 2 列目の要素をすべて取得する（列ベクトル） &gt;&gt; A(:, 2) ans = 2 5 8 1 行目と 3 行目の要素をすべて取得する &gt;&gt; A([1 3], :) ans = 1 2 3 7 8 9 指定した位置への代入にも使用することができます。 下記の例では、3 行目の各要素を書き換えています。 &gt;&gt; A(3, :) = [10 20 30] A = 1 2 3 4 5 6 10 20 30 末尾のインデックスを表す特殊キーワード end 行列要素を参照するときに、行や列の位置を 開始位置:終了位置 という形で指定すると範囲指定になります。 この 終了位置 には、末尾を表す end を指定することができます。 下記の例では、2 行目から最後の行までの要素を抽出しています。 &gt;&gt; A = [1 2 3; 4 5 6; 7 8 9]; &gt;&gt; A(2:end, :) ans = 4 5 6 7 8 9 ベクトル内の特定の要素を参照する ベクトル内の特定の位置の要素を参照するときも、行列と同様にインデックスを指定します。 ただし、ベクトルの場合は指定するインデックスは 1 つだけです。 &gt;&gt; v = [10 20 30 40 50]; &gt;&gt; v(2) ans = 20 上記は行ベクトルのケースですが、列ベクトルの場合も同じように位置指定することができます。 &gt;&gt; v = [10; 20; 30; 40; 50]; &gt;&gt; v(2) ans = 20 範囲指定で部分ベクトルを抽出することもできます。 下記の例では、2 番目から 4 番目までの要素を抽出しています。 &gt;&gt; v = [10 20 30 40 50]; &gt;&gt; v(2:4) ans = 20 30 40 末尾を示す end キーワードも使用できます。 &gt;&gt; v = [10 20 30 40 50]; &gt;&gt; v(2:end) ans = 20 30 40 50"},{url:"/p/fkau9he/",title:"Octave で逆行列を作成する (inv)",date:"2017-03-24T00:00:00+09:00",body:"Octave で逆行列を作成する (inv) $$ \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\end{bmatrix}^{-1} = \\begin{bmatrix} -2 &amp; 1 \\\\ 1.5 &amp; -0.5 \\end{bmatrix} $$ Octave で行列 \\(A\\) の逆行列 \\(A^{-1}\\) を求めるには、組み込み関数の inv を使用します。 &gt;&gt; A = [1 2; 3 4] A = 1 2 3 4 &gt;&gt; inv(A) ans = -2.00000 1.00000 1.50000 -0.50000 元の行列と逆行列の積は、単位行列になります（\\(AA^{-1} = A^{-1}A = I\\)）。 &gt;&gt; A * inv(A) ans = 1.00000 0.00000 0.00000 1.00000 &gt;&gt; inv(A) * A ans = 1.00000 0.00000 0.00000 1.00000"},{url:"/p/o9bmzfy/",title:"Octave で零行列（ゼロ行列）を作成する",date:"2017-03-24T00:00:00+09:00",body:"Octave で零行列（ゼロ行列）を作成する zeros 関数 $$ O = \\begin{pmatrix} 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\ 0 &amp; 0 &amp; \\ldots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\ldots &amp; 0 \\end{pmatrix} $$ Octave でゼロ行列 (zero vector) を作成するには、組み込みの zeros 関数を使用します。 &gt;&gt; O = zeros(3) O = 0 0 0 0 0 0 0 0 0 &gt;&gt; O = zeros(2, 4) O = 0 0 0 0 0 0 0 0 zeros のドキュメント &gt;&gt; help zeros &#39;zeros&#39; is a built-in function from the file libinterp/corefcn/data.cc -- zeros (N) -- zeros (M, N) -- zeros (M, N, K, ...) -- zeros ([M N ...]) -- zeros (..., CLASS) Return a matrix or N-dimensional array whose elements are all 0. If invoked with a single scalar integer argument, return a square NxN matrix. If invoked with two or more scalar integer arguments, or a vector of integer values, return an array with the given dimensions. The optional argument CLASS specifies the class of the return array and defaults to double. For example: val = zeros (m,n, &#34;uint8&#34;)"},{url:"/p/65afkmg/",title:"Octave で行列／ベクトルを作成する",date:"2017-03-23T00:00:00+09:00",body:"Octave で行列／ベクトルを作成する 行列の定義 ３行２列 $$ A = \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{bmatrix} $$ A = [1 2; 3 4; 5 6]; 行ごとにセミコロンで区切ります。 ２行３列 $$ A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{bmatrix} $$ &gt;&gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 ベクトルの定義 行ベクトル (row vector) $$ v = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\end{bmatrix} $$ &gt;&gt; v = [1 2 3] % 行ベクトル v = 1 2 3 列ベクトル (column vector) $$ v = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$ &gt;&gt; v = [1; 2; 3] % 列ベクトル v = 1 2 3 範囲指定でベクトルを生成する コロン : を使用して、数値の範囲を指定してベクトルを生成することができます。 1 から 5 までの連番 &gt;&gt; v = 1:5 v = 1 2 3 4 5 1 から 10 までの範囲で、ステップ数 2 の連番 &gt;&gt; v = 1:2:10 v = 1 3 5 7 9"},{url:"/p/a7z6ojh/",title:"Octave で転置行列を作成する",date:"2017-03-23T00:00:00+09:00",body:"Octave で転置行列を作成する 転置行列を求める $$ {A} = \\left[ \\begin{array}{ccc} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{array} \\right] $$ $$ {A}^{\\mathrm{T}} = \\left[ \\begin{array}{cc} 1 &amp; 4 \\\\ 2 &amp; 5 \\\\ 3 &amp; 6 \\end{array} \\right] $$ 行列 A の転置行列 (transposed matrix) である \\(A^T\\) は、ダッシュ記号 (') を付加するだけで求められます。 &gt;&gt; A = [1 2 3; 4 5 6] A = 1 2 3 4 5 6 &gt;&gt; A&#39; ans = 1 4 2 5 3 6 転置行列と共役転置行列 A' で得られる行列は、正確には 共役転置行列 であり、転置行列の各要素の複素共役をとったものになっています。 各要素の値が実数の場合は違いはありませんが、複素数が含まれていると結果が変わってきます。 &gt;&gt; A = [1+2i 3+4i; 5-6i 7-8i] A = 1 + 2i 3 + 4i 5 - 6i 7 - 8i &gt;&gt; A&#39; ans = 1 - 2i 5 + 6i 3 - 4i 7 + 8i 単純な転置行列を求めたい場合は、A' ではなく、A.' とします。 &gt;&gt; A.&#39; ans = 1 + 2i 5 - 6i 3 + 4i 7 - 8i"},{url:"/p/htducs9/",title:"NumPy 配列 (ndarray) の作成方法まとめ",date:"2017-02-27T00:00:00+09:00",body:"NumPy 配列 (ndarray) の作成方法まとめ NumPy 配列 (ndarray) は、np.array() 関数を使って次のように生成するのが基本ですが、 import numpy as np # 1 次元の場合 a = np.array([1, 2, 3]) print(a[0]) #=&gt; 1 # 2 次元の場合 a = np.array([[1, 2, 3], [4, 5, 6]]) print(a[0]) #=&gt; [1 2 3] print(a[0][2]) #=&gt; 3 NumPy は ndarray インスタンス生成用の様々なユーティリティ関数を提供しています。 全要素が 0 の NumPy 配列 (np.zeros) 零ベクトル np.zeros() 関数で、すべての要素が 0 の配列データ（ベクトル）を作成できます。 データタイプ (dtype) はデフォルトで float64 になりますが、dtype パラメーターで変更することが可能です。 &gt;&gt;&gt; np.zeros(3) array([0., 0., 0.]) &gt;&gt;&gt; np.zeros(3, dtype=&#34;int64&#34;) array([0, 0, 0], dtype=int64) 零行列 すべての要素（成分）が 0 である行列のことを零行列（ゼロ行列; zero matrix）と呼びます。 NumPy で零行列を生成するには、np.zeros 関数の第 1 引数 (shape) にタプル形式で (行サイズ, 列サイズ) を渡します。 &gt;&gt;&gt; np.zeros((2, 3)) array([[ 0., 0., 0.], [ 0., 0., 0.]]) データタイプ (dtype) はデフォルトで float64 になりますが、次のように明示的に指定することが可能です。 a = np.zeros((2, 3), dtype=&#34;int32&#34;) 全要素が 1 の NumPy 配列 (np.ones) 全ての要素が 1 である NumPy 配列を生成するには np.ones 関数を使用します。 第 1 引数 (shape) で要素数を指定します。 多次元配列の場合は、タプル形式で各次元の要素数を指定します。 データタイプ (dtype) はデフォルトで float64 になります。 &gt;&gt;&gt; np.ones(3) array([1., 1., 1.]) &gt;&gt;&gt; np.ones((2, 3)) array([[ 1., 1., 1.], [ 1., 1., 1.]]) &gt;&gt;&gt; np.ones((2, 3), dtype=&#34;int32&#34;) array([[1, 1, 1], [1, 1, 1]]) 単位行列 (np.identity) 単位行列（identity matrix）は、対角線上の要素（対角成分）が全て 1 で、それ以外の要素が全て 0 の正方行列です。 単位行列は、行列の乗法の単位元としての役割を果たします。 np.identity 関数で単位行列の ndarray インスタンスを生成することができます。 行と列のサイズは等しいため、サイズ指定のためのパラメーターは 1 つだけであることに注意してください。 &gt;&gt;&gt; np.identity(3) array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) np.identity() 関数の戻り値は、必ず 2 次元の NumPy 配列になります（shape としては (1, 1) や (2, 2) や (3, 3) のようになります）。 連番からなる NumPy 配列 (np.arange) np.arange 関数を使用して、連番からなる NumPy 配列 (ndarray) を生成することができます。 開始番号 (start) や、1 ステップあたりの変化数 (step) を指定することもできます。 連番の ndarray を生成する &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; np.arange(5) array([0, 1, 2, 3, 4]) &gt;&gt;&gt; np.arange(3, 10) array([3, 4, 5, 6, 7, 8, 9]) &gt;&gt;&gt; np.arange(2, 10, 2) array([2, 4, 6, 8]) &gt;&gt;&gt; np.arange(10, 0, -1) array([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) &gt;&gt;&gt; np.arange(1, step=0.1) array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]) データタイプ (dtype) は基本的に int32 になりますが、ステップ数を小数点数で刻むと float64 になります。 関数名は arrange ではなく、arange であることに注意してください（array range の略です）。 np.arange は 1 次元配列を作成しますが、reshape メソッドを使えば多次元配列の形に変換できます。 &gt;&gt;&gt; np.arange(9).reshape((3, 3)) array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) ランダムな NumPy 配列 (np.random) np.random.rand() は 0 以上 1 未満のランダム float 値を生成する関数ですが、引数で各次元のサイズを指定することで、ランダムな値を持つ NumPy 配列を生成できます。 似た関数に np.random.randn() がありますが、こちらは標準正規分布に従ったランダム値を生成します。 &gt;&gt;&gt; np.random.rand() # スカラー値 0.5926286463704019 &gt;&gt;&gt; np.random.rand(3) # 1 次元 NumPy 配列 array([0.88829851, 0.22662687, 0.30925015]) &gt;&gt;&gt; np.random.rand(2, 3) # 2 次元 NumPy 配列　array([[0.05874757, 0.31040971, 0.09503772], [0.99130323, 0.34005123, 0.57641306]]) 整数のランダム値が欲しいときは、np.random.randint() を使います。 size パラメーターを指定することで、任意の次元の NumPy 配列を生成できます。 &gt;&gt;&gt; np.random.randint(10) # スカラー値（0 以上 10 未満の整数） 7 &gt;&gt;&gt; np.random.randint(-3, 3) # スカラー値（-3 以上 3 未満の整数） -3 &gt;&gt;&gt; np.random.randint(5, size=3) # 1 次元 NumPy 配列（0 以上 5 未満の整数） array([2, 0, 4]) &gt;&gt;&gt; np.random.randint(5, size=(2, 3)) # 2 次元 NumPy 配列（0 以上 5 未満の整数） array([[0, 4, 3], [2, 4, 4]]) ランダム関数のシード値は、np.random.seed() で設定することができます。 同じシード値を設定すると、生成されるランダム値を再現することができます。 &gt;&gt;&gt; np.random.seed(252525) # シード値を設定 &gt;&gt;&gt; np.random.randint(100) 43 &gt;&gt;&gt; np.random.randint(100) 75 &gt;&gt;&gt; np.random.seed(252525) # 同じシード値を再設定 &gt;&gt;&gt; np.random.randint(100) 43 &gt;&gt;&gt; np.random.randint(100) 75"},{url:"/p/wbudtbr/",title:"Python の Pandas でラベル付き 1 次元データを扱う (pandas.Series)",date:"2017-01-23T00:00:00+09:00",body:"Python の Pandas でラベル付き 1 次元データを扱う (pandas.Series) Python の Pandas ライブラリは、データ操作および分析を容易にするためのデータ型および関数群を提供します。 Pandas ライブラリの内部では、NumPy ライブラリの多次元配列 (ndarray) や数値演算関数が使用されています。 先に NumPy に慣れておくと理解が早くなります。 参考: NumPy 配列 (ndarray) の基本 pandas.Series はラベル付き 1 次元配列 pandas.Series は、1 次元の NumPy 配列 (ndarray) に、インデックス用のラベルを付加したデータ型です。 通常の配列データは 0、1、2 というインデックスで各要素にアクセスしますが、pandas.Series では各インデックスに意味のあるラベルを付けることができます。 pandas.Series を生成する pandas.Series コンストラクタで、次のように初期データだけを指定すると、通常の配列と同様にインデックスとして 0、1、2 が割り振られます。 sample.py import pandas as pd s = pd.Series([100, 200, 300]) print(s) 実行結果 0 100 1 200 2 300 dtype: int64 各インデックスにラベルを設定する pandas.Series コンストラクタで第 2 引数 (index) を追加指定すると、明示的に各インデックスのラベルを設定することができます。 import pandas as pd s = pd.Series([100, 200, 300], index=[&#34;aaa&#34;, &#34;bbb&#34;, &#34;ccc&#34;]) # s = pd.Series([100, 200, 300], [&#34;aaa&#34;, &#34;bbb&#34;, &#34;ccc&#34;]) # 同上 print(s) 実行結果 aaa 100 bbb 200 ccc 300 dtype: int64 次のように、辞書オブジェクトから同様の pandas.Series を生成することもできます。 data = {&#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;ccc&#34;: 300} s = pd.Series(data) Matplotlib による描画 Pandas は Matplotlib と統合されており、簡単にチャート描画を行うことができます。 図: Matplotlib による Pandas の Series データのプロット import matplotlib.pyplot as plt import pandas as pd s = pd.Series([100, 200, 300], index=[&#34;aaa&#34;, &#34;bbb&#34;, &#34;ccc&#34;]) # 出力設定 fig = plt.figure(facecolor=&#34;white&#34;, layout=&#34;tight&#34;, dpi=72, figsize=(6, 3)) # Pandas の Series データを棒グラフとしてプロット s.plot.bar() # 必要に応じて画面に表示 plt.show() # 画像として保存 fig.savefig(&#34;img-001.svg&#34;)"},{url:"/p/watbs9p/",title:"Python の Pandas でラベル付き 2 次元データを扱う (pandas.DataFrame)",date:"2017-01-23T00:00:00+09:00",body:"Python の Pandas でラベル付き 2 次元データを扱う (pandas.DataFrame) pandas.DataFrame はラベル付き 2 次元配列 Python の Pandas ライブラリが提供する pandas.DataFrame 型は、テーブル形状のデータを表す 2 次元データ型で、Pandas によるデータ解析の要となるデータ形式です。 内部では NumPy ライブラリの ndarray が利用されていますが、pandas.DataFrame を使うと、X 軸（列）、Y 軸（行）の各インデックスに任意のラベルを付けることができます （1 次元データを表現する pandas.Series 型も用意されています）。 NumPy の ndarray は同じデータタイプの値しか持てませんが、pandas.DataFrame であれば、列ごとに異なるデータタイプの値を保持することができます。 pandas.DataFrame を生成する pandas.DataFrame コンストラクタで、次のように初期値となる 2 次元データだけを渡すと、行と列のラベルとして、0、1、2 という連番が割り振られます。 pandas.DataFrame オブジェクトを print 関数に渡すと、見やすい形で出力してくれます。 sample.py import pandas as pd data = [[100, 200, 300], [400, 500, 600], [700, 800, 900]] df = pd.DataFrame(data) print(df) 実行結果 0 1 2 0 100 200 300 1 400 500 600 2 700 800 900 各インデックスにラベルを設定する pandas.DataFrame コンストラクタの columns パラメータを使うと、X 軸（列）の各インデックスのラベルを設定することができます。 同様に、index パラメータを使うと、Y 軸（行）の各インデックスのラベルを設定することができます。 import pandas as pd data = [[100, 200, 300], [400, 500, 600], [700, 800, 900]] columns = (&#39;x1&#39;, &#39;x2&#39;, &#39;x3&#39;) index = (&#39;y1&#39;, &#39;y2&#39;, &#39;y3&#39;) df = pd.DataFrame(data, columns=columns, index=index) print(df) 実行結果 x1 x2 x3 y1 100 200 300 y2 400 500 600 y3 700 800 900 ディクショナリから DataFrame を生成する Python のディクショナリオブジェクトを pandas.DataFrame に変換することができます。 pandas.DataFrame コンストラクタにディクショナリを渡すと、そのキーがカラム名として使用されます。 ディクショナリから DataFrame を生成する import numpy as np import pandas as pd data = { &#39;A&#39;: 1.0, &#39;B&#39;: [100, 200, 300], &#39;C&#39;: np.array([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]), &#39;D&#39;: pd.Series([0.1, 0.2, 0.3]), &#39;E&#39;: pd.Categorical([&#39;apple&#39;, &#39;lemon&#39;, &#39;peach&#39;]), &#39;F&#39;: pd.date_range(&#39;2017-01-01&#39;, periods=3) } df = pd.DataFrame(data) print(df) 実行結果 A B C D E F 0 1.0 100 a 0.1 apple 2017-01-01 1 1.0 200 b 0.2 lemon 2017-01-02 2 1.0 300 c 0.3 peach 2017-01-03 この例では、キーがたまたまディクショナリの初期化時と同じ順番で並んでいますが、ディクショナリの要素には順序性はないので、このような順番でカラムが並ぶことは保証されていないことに注意してください（カラム名とそれに関連付けられた Series データがあるだけです）。 ランダム値や連番からなる DataFrame を生成する NumPy 配列から pandas.DataFrame を生成することもできます。 NumPy ライブラリには、いろいろな形の NumPy 配列を生成するユーティリティ関数が用意されているので、これを利用してテスト用の pandas.DataFrame を簡単に生成できます。 ランダムな DataFrame import numpy as np import pandas as pd np.random.seed(2525) # 乱数シードを設定 arr = np.random.randint(0, 1000, size=(2, 3)) df = pd.DataFrame(arr, columns=(&#34;x1&#34;, &#34;x2&#34;, &#34;x3&#34;)) print(df) 実行結果 x1 x2 x3 0 636 952 324 1 21 289 966 ランダムな値を使うときは、上記のようにシード値を設定しておくことで、同じデータを再現できるようになります。 連番の DataFrame arr = np.arange(10).reshape((2, 5)) df = pd.DataFrame(arr, columns=(&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;)) print(df) 実行結果 A B C D E 0 0 1 2 3 4 1 5 6 7 8 9 参考: NumPy 配列 (ndarray) の作成方法まとめ"},{url:"/p/8j4k3iy/",title:"Python の pandas.DataFrame から部分データを抽出する",date:"2017-01-23T00:00:00+09:00",body:"Python の pandas.DataFrame から部分データを抽出する Python の pandas ライブラリが提供する pandas.DataFrame はテーブル形式データを保持していますが、ここから部分的なデータを抽出する方法がたくさん用意されています。 サンプルデータ 最初に、後述の説明のためにサンプルデータを用意しておきます。 次のコードでは、10 行 3 列のデータを持つ pandas.DataFrame を生成しています。 import numpy as np import pandas as pd data = np.random.randn(10, 3) # 10x3 の NumPy 配列を生成（標準正規分布の乱数） indices = pd.date_range(&#34;2010-01-01&#34;, periods=10) # 日付の連番からなるインデックスを生成 columns = (&#34;A&#34;, &#34;B&#34;, &#34;C&#34;) # カラム名 my_dataframe = pd.DataFrame(data, index=indices, columns=columns) print(my_dataframe) 実行結果 A B C 2010-01-01 -1.083348 0.780602 -1.249351 2010-01-02 -0.421893 1.417954 2.196932 2010-01-03 -1.129684 -0.751984 0.920735 2010-01-04 -0.668949 -2.082924 -0.018011 2010-01-05 1.542745 -1.014717 -0.587786 2010-01-06 0.535100 -0.680070 0.630020 2010-01-07 0.563422 0.856276 1.343315 2010-01-08 1.586091 -1.304232 -1.084707 2010-01-09 -1.561553 -1.884124 0.849059 2010-01-10 -0.817422 -1.244994 0.143166 行方向（インデックス）で絞り込んで抽出する 先頭／末尾の数データのみ抽出する (DataFrame#head, DataFrame#tail) DataFrame オブジェクトの head メソッドや tail メソッドを使用すると、巨大なデータフレームから、先頭あるいは末尾の数データのみを抽出することができます。 最新のデータを取得したいときや、データ構成を簡単に把握したいときに便利です。 戻り値の型は DataFrame です。 print(my_dataframe.head(3)) # 先頭の 3 つのデータのみ抽出 =&gt; DataFrame print(my_dataframe.tail(3)) # 末尾の 3 つのデータのみ抽出 =&gt; DataFrame 図: pandas.DataFrame の head 関数と tail 関数 実行結果 A B C 2010-01-01 -1.083348 0.780602 -1.249351 2010-01-02 -0.421893 1.417954 2.196932 2010-01-03 -1.129684 -0.751984 0.920735 A B C 2010-01-08 1.586091 -1.304232 -1.084707 2010-01-09 -1.561553 -1.884124 0.849059 2010-01-10 -0.817422 -1.244994 0.143166 head や tail のパラメータを省略すると、デフォルトで 5 つ のデータが抽出されます。 インデックスの範囲指定でデータを抽出する DataFrame を参照するときに、Python のスライス構文を使って、インデックス番号やインデックス名で範囲を指定すると、その範囲の部分データを抽出することができます。 単一のインデックス指定ではなく、どのケースも範囲指定になっていることに注意してください。 戻り値は DataFrame オブジェクトです。 print(my_dataframe[0:3]) # 先頭の 3 つのデータを取得 print(my_dataframe[:3]) # 同上 print(my_dataframe[-2:]) # 末尾の 2 つのデータを取得 print(my_dataframe[&#34;2010-01-05&#34;:&#34;2010-01-07&#34;]) # インデックス名で範囲指定 図: DataFrame から複数の行を抽出 特定のインデックスのデータを抽出する DataFrame の loc メソッドを使用すると、特定のインデックスのデータのみを Series オブジェクトとして取得することができます（配列風に 1 つのラベル名だけを指定してアクセスすると、インデックス名ではなくカラム名を指定したことになってしまうので（列方向の抽出）、インデックス名を指定するための loc が用意されています）。 print(my_dataframe.loc[&#34;2010-01-01&#34;]) # 特定インデックスのデータを取得 =&gt; Series print(my_dataframe.iloc[0]) # 番号指定の場合は iloc を使う =&gt; Series 図: DataFrame から 1 つの行を抽出 実行結果 A -1.083348 B 0.780602 C -1.249351 Name: 2010-01-01 00:00:00, dtype: float64 DataFrame ではカラム名だった A, B, C が、戻り値の Series データではインデックス名になっていることに注意してください。 列方向（カラム）で絞り込んで抽出する 特定のカラムのデータを抽出する DataFrame オブジェクトの [] 演算子でカラム名を 1 つだけ指定すると、そのカラムのすべてのデータが pandas.Series データとして抽出されます。 戻り値は、指定した列のみデータを含む 1 次元データなので pandas.Series 型になります。 ☝️ ワンポイント [] 演算子で単一の値を指定すると、インデックス（行）ではなく、カラム（列）の指定だとみなされることに注意してください。 逆に、インデックスを 1 つだけ指定して特定の行を抽出するには、loc[&quot;インデックス名&quot;] や iloc[インデックス番号] を使用する必要があります。 カラム名 C のデータを Series として取得 print(my_dataframe[&#34;C&#34;]) # =&gt; pandas.Series 図: DataFrame から 1 つの列を抽出 実行結果 2010-01-01 -1.249351 2010-01-02 2.196932 2010-01-03 0.920735 2010-01-04 -0.018011 2010-01-05 -0.587786 2010-01-06 0.630020 2010-01-07 1.343315 2010-01-08 -1.084707 2010-01-09 0.849059 2010-01-10 0.143166 Freq: D, Name: C, dtype: float64 特定のカラムのデータを Series ではなく、DataFrame として抽出するには次のようにします。 カラム名 C のデータを DataFrame として取得 print(my_dataframe[(&#34;C&#34;)]) # =&gt; pandas.DataFrame この記法では、複数のカラムを指定することもできます。 カラム名 A と C のデータを DataFrame として取得 print(my_dataframe[(&#34;A&#34;, &#34;C&#34;)]) # カラム名 A と C の全データを取得 図: DataFrame から複数の列を抽出 インデックスラベルとカラムを両方指定して取得 (loc, iloc) DataFrame の loc[] で、インデックスとカラムの範囲を組み合わせて指定することができます。 戻り値の型はデータの抽出範囲によって変化する ことに注意してください。 取得結果が 1 次元データとなる場合は Series オブジェクト、2 次元データとなる場合は DataFrame オブジェクトとなります。 # 単一インデックス ＋ 単一カラム指定 =&gt; numpy.float64 print(my_dataframe.loc[&#39;2010-01-01&#39;, &#39;A&#39;]) # 単一インデックス ＋ 複数カラム指定 =&gt; pandas.Series print(my_dataframe.loc[&#39;2010-01-01&#39;, [&#39;A&#39;, &#39;C&#39;]]) # インデックス範囲指定 ＋ 単一カラム指定 =&gt; pandas.Series print(my_dataframe.loc[&#39;2010-01-01&#39;:&#39;2010-01-03&#39;, &#39;A&#39;]) # 全インデックス指定 ＋ 複数カラム指定 =&gt; pandas.DataFrame print(my_dataframe.loc[:, [&#39;A&#39;, &#39;C&#39;]]) ラベルではなく、インデックス番号で指定する場合は、loc[] の代わりに iloc[] を使用します。 # 先頭のデータ =&gt; pandas.Series print(my_dataframe.iloc[0]) # 先頭から 3 つのデータ =&gt; pandas.DataFrame print(my_dataframe.iloc[0:3]) # 先頭のデータの 2 つ目のカラムの値 =&gt; numpy.float64 print(my_dataframe.iloc[0, 1]) # 全データの 3 つ目までのカラムのデータ =&gt; pandas.DataFrame print(my_dataframe.iloc[:, 0:3])"},{url:"/p/jwfxfvd/",title:"Python の NumPy 配列 (ndarray) の基本",date:"2017-01-01T00:00:00+09:00",body:"Python の NumPy 配列 (ndarray) の基本 NumPy 配列 (ndarray) とは Python の NumPy ライブラリ (numpy) は、多次元配列を高速かつ便利に扱うための ndarray クラスを提供しています（n-dimensional array の略）。 ndarray は Python 標準のリストと比べて次のような違いがあります。 内部実装に C 言語などの低レベル言語が利用されており、処理が高速でメモリ効率がよい C 言語の配列と同様、単一のデータタイプ で 固定サイズ の配列である（サイズ変更は新しい ndarray の生成になる） 全要素に対するブロードキャスト演算や、行列（ベクトル）演算など、便利な演算方法 が提供されている NumPy はこのような特徴を持つため、次のように様々なライブラリで利用されています。 データ解析ライブラリ: Pandas 画像処理ライブラリ: OpenCV 科学計算ライブラリ: SciPy 機械学習ライブラリ: TensorFlow、scikit-learn プロットライブラリ: Matplotlib つまり、ほとんどの数学的、科学的な処理を行うライブラリは NumPy を利用していると考えられます。 NumPy 配列を生成する（numpy.array 関数） ndarray インスタンスは、numpy.array() 関数で生成することができます。 実際には、numpy ライブラリは np という別名でインポートするのが慣例となっているので、コード中では numpy.array() ではなく np.array() と記述されることが多いです。 1 次元の ndarray 次の例では、1 次元の ndarray インスタンスを生成しています。 1 次元の ndarray を生成 &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a = np.array([1, 2, 3]) &gt;&gt;&gt; a array([1, 2, 3]) &gt;&gt;&gt; type(a) &lt;class &#39;numpy.ndarray&#39;&gt; 多次元の ndarray 多次元の ndarray インスタンスも同様に生成できます。 2 次元（2 行 3 列）ndarray を生成 &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]]) &gt;&gt;&gt; a array([[1, 2, 3], [4, 5, 6]]) NumPy 配列の形状（各次元のサイズ）は、shape 属性を参照することで調べることができます。 ndarray の形状を調べる &gt;&gt;&gt; a.shape (2, 3) # 2 行 3 列を表すタプルが返される 行列として扱うには、各行のサイズ（列数）は揃えておく必要があります。 次のように、各行のサイズが異なるとエラーになります。 a = np.array([[1, 2, 3], [4, 5]]) # ValueError! NumPy 配列は 1 つのデータタイプ (dtype) の要素のみを持つ 効率化のため、NumPy 配列に格納される要素の型（データタイプ）は統一されます。 データタイプは ndarray インスタンスの初期化時の要素の値によって自動的に設定されます。 ndarray インスタンスが保持している要素のデータタイプを調べるには、dtype 属性を参照します。 ndarray のデータタイプを調べる &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]]) # 整数値のみで初期化 &gt;&gt;&gt; a.dtype dtype(&#39;int64&#39;) &gt;&gt;&gt; a = np.array([[1, 2, 3], [1.5, 2.5, 3.5]]) # 浮動小数点数を含む値で初期化 &gt;&gt;&gt; a.dtype dtype(&#39;float64&#39;) データタイプは、NumPy 配列の生成時に dtype オプションで明示的に指定することができます。 次の例では、整数値のみで NumPy 配列を初期化していますが、浮動小数点数の要素として扱うように指定しています。 ndarray のデータタイプを指定する &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], dtype=&#39;float64&#39;) &gt;&gt;&gt; a.dtype dtype(&#39;float64&#39;) &gt;&gt;&gt; a array([[ 1., 2., 3.], [ 4., 5., 6.]]) NumPy 配列のインデックスアクセスとスライス NumPy 配列 (ndarray) の各要素は、リストと同様にインデックスでアクセスできます。 a = np.array([[1, 2, 3], [4, 5, 6]]) print(a[0][2]) # 3 a[0][2] = 100 # 値の変更 print(a[0]) # [1 100 3] print(len(a)) # 2 print(len(a[0])) # 3 ndarray はリストよりも柔軟なスライスを行うことができます。 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 2 行目だけを取得 print(a[1]) # [4, 5, 6] print(a[1, :]) # 同上 # 2 行目以降を取得 print(a[1:]) # [[4, 5, 6], [7, 8, 9]] print(a[1:, :]) # 同上 # すべての行の 2 列目までを取得 print(a[:, :2]) # [[1, 2], [4, 5], [7, 8]] print(a[:, :-1]) # 同上 # すべての行の列を 1 つ飛びで取得 print(a[:, ::2]) # [[1, 3], [4, 6], [7, 9]] ndarray のスライスは、元の ndarray のデータの参照であることに注意してください。 スライス経由での値の変更は、スライス元の ndarray の変更を意味します。 一方で、Python 標準のリストのスライスは、Shallow Copy（一階層目だけコピー）です。 # NumPy 配列のスライスは元のデータを参照する np_arr = np.array([1, 2, 3]) np_slice = np_arr[:] np_slice[0] = 100 print(np_arr) # [100, 2, 3] # リストのスライスは Shallow Copy（一階層目はコピーによって作られた新しいデータ） py_arr = [1, 2, 3] py_slice = py_arr[:] py_slice[0] = 100 print(py_arr) # [1, 2, 3] NumPy 配列に対する演算（ブロードキャスト） NumPy 配列 (ndarray) やそのスライスに対してスカラー値（単一の値）の四則演算や代入操作を行うと、全ての要素に対してその演算 が実行されます（この仕組みを ブロードキャスト と呼びます）。 これは非常に強力な仕組みで、この仕組みをうまく活用することで、多くの計算をループを記述せずに実装することができます。 ndarray とスカラー値のブロードキャスト演算 a = np.array([[1, 2, 3], [4, 5, 6]]) a[0] = 10 # 1 行目の要素をすべて 10 にする print(a) # [[10, 10, 10], [4, 5, 6]] a -= 1 # すべての要素をマイナス 1 する print(a) # [[9, 9, 9], [3, 4, 5]] a[1] **= 2 # 2 行目の要素をすべて 2 乗する print(a) # [[9, 9, 9], [9, 16, 25]] a[:, 1] = 0 # 全ての行の 2 列目の要素を 0 にする print(a) # [[9, 0, 9], [9, 0, 25]] NumPy 配列 (ndarray) 同士の四則演算も、それぞれ対応する要素に対して演算が行われます。 ただし、形状の異なる NumPy 配列同士で演算しようとすると ValueError が発生します。 行列同士の四則演算 a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([[5, 5, 5], [2, 2, 2]]) c = a + b # [[6, 7, 8], [6, 7, 8]] c = a - b # [[-4, -3, -2], [2, 3, 4]] c = a * b # [[5, 10, 15], [8, 10, 12]] c = a / b # [[0.2, 0.4, 0.6], [2.0, 2.5, 3.0]] c = a // b # [[0, 0, 0], [2, 2, 3]] c = a % b # [[1, 2, 3], [0, 1, 0]] c = a ** b # [[1, 32, 243], [16, 25, 36]] 特に、除算 (a / b) の結果は、float64 型のデータタイプになることに注意してください。 多次元の NumPy 配列と、1 次元の NumPy 配列の演算でもブロードキャストの仕組みが働きます。 列のサイズは等しくないといけません。 行列とベクトルの四則演算 a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) b = np.array([1, 2, 3]) c = a + b # [[2, 4, 6], [5, 7, 9], [8, 10, 12]] c = a - b # [[0, 0, 0], [3, 3, 3], [6, 6, 6]] c = a * b # [[1, 4, 9], [4, 10, 18], [7, 16, 27]] c = a / b # [[1.0, 1.0, 1.0], [4.0, 2.5, 2.0], [7.0, 4.0, 3.0]] c = a // b # [[1, 1, 1], [4, 2, 2], [7, 4, 3]] c = a % b # [[0, 0, 0], [0, 1, 0], [0, 0, 0]] c = a ** b # [[1, 4, 27], [4, 25, 216], [7, 64, 729]] 行列演算（内積、外積、転置） NumPy 配列 (ndarray) には、行列の内積、外積、転置などの演算を行うためのメソッドが用意されています。 内積 (dot) a = np.array([[1, 2, 3], [4, 5, 6]]) b = np.array([1, 2, 3]) result = a.dot(b) # array([14, 32]) 外積 (cross) a = np.array([1, 2, 3]) b = np.array([10, 10, 10]) result = np.cross(a, b) # array([-10, 20, -10]) 転置 (transpose) a = np.array([[1, 2, 3], [4, 5, 6]]) result = a.transpose() # array([[1, 4], [2, 5], [3, 6]]) ちなみに、各メソッドの引数としては、ndarray インスタンスではなく、リストやタプルも渡せるようになっていますが、戻り値は結局 ndarray になります。 result = np.cross([1, 2, 3], (10, 10, 10)) # array([-10, 20, -10])"},{url:"/p/n4n5m3i/",title:"Python でモジュールやパッケージを作成する",date:"2016-12-16T00:00:00+09:00",body:"Python でモジュールやパッケージを作成する モジュールとパッケージ Python では、再利用可能な関数などを集めたスクリプトファイルのことをモジュールと呼びます。 さらに、同系列のモジュールを集めたものをパッケージと呼びます。 モジュール &hellip; 再利用可能なスクリプト (.py) パッケージ &hellip; 上記のモジュールをディレクトリに集めたもの モジュールやパッケージを作成しておくと、他のファイルから import して使用することができます。 ☝️ Node.js も同じ名前 モジュールやパッケージといった名称は、言語によって使われ方が様々ですが、Node.js に関してはほぼ同じ意味で使われています。 Node.js では、.js ファイルのことをモジュール、それらをまとめたものをパッケージと読んでいます。 モジュールを作成する 下記は、簡単な関数（add と sub）を提供する mymath モジュールを定義する例です。 といっても、単純に関数を定義するだけです。 モジュールは、モジュール名.py というファイル名で作成する必要があります。 mymath.py（モジュールの実装例） def add(a, b): &#34;&#34;&#34;Return the sum of a and b.&#34;&#34;&#34; return a + b def sub(a, b): &#34;&#34;&#34;Subtract b from a.&#34;&#34;&#34; return a - b 上記の mymath.py で定義されている関数を使用するには、Python 標準のモジュールと同様に、import mymath という形でインポートします。 main.py（モジュールの使用例） import mymath if __name__ == &#39;__main__&#39;: print(mymath.add(1, 2)) print(mymath.sub(1, 2)) パッケージを作成する 複数のモジュール (*.py) をディレクトリにまとめたものを パッケージ と呼びます。 下記の例では、mylib ディレクトリに mymath.py を格納することで、mylib パッケージを作成しています。 ちなみに、パッケージ名（ディレクトリ名）には、アンダースコア (_) は含めるべきではない とされています。 このあたりの命名規則に関しては Python のコーディングスタイル を参照してください。 +-- main.py +-- mylib/ +-- mymath.py パッケージ内のモジュールの実装方法は、通常のモジュールの場合と変わりません。 mylib/mymath.py def add(a, b): return a + b def sub(a, b): return a - b mylib パッケージ内の mymath モジュールを使用するには、次のように mylib.mymath という形でインポートします。 main.py import mylib.mymath if __name__ == &#39;__main__&#39;: print(mylib.mymath.add(1, 2)) print(mylib.mymath.sub(1, 2)) このようにパッケージ名とモジュール名を繋げた名前でインポートした場合、関数を呼び出すときもその名前をプレフィックスに付けて呼び出す必要があります（例: mylib.mymath.add(1, 2)）。 Python の部分インポート (partial import) の構文 (from mylib import mymath) を使うと、パッケージ名を省略して呼び出せるようになります。 from mylib import mymath if __name__ == &#39;__main__&#39;: print(mymath.add(1, 2)) print(mymath.sub(1, 2)) モジュール内の関数などを呼び出すときは、import の後ろに記述したシンボル名をプレフィックスとして付けると覚えておけば OK です（例えば上記の場合は、import mymath としているので、add 関数の呼び出し時は mymath プレフィックスを付けて mymath.add とします）。 モジュール内の特定メンバーだけをインポートする 前述の例では、モジュール単位でインポートしましたが、モジュール内の特定のメンバー（関数、クラス、定数など）を指定してインポートすることもできます。 次の例では、mymath モジュール内の、add 関数のみをインポートしています。 関数の呼び出し時に、モジュール名のプレフィックスを付ける必要はありません。 メンバー単位のインポート from mymath import add if __name__ == &#39;__main__&#39;: print(add(1, 2)) パッケージ内のモジュール内の関数をインポートする場合も、ほぼ同じ指定方法でいけます。 from mylib.mymath import add if __name__ == &#39;__main__&#39;: print(add(1, 2)) 別名を付ける (as) インポートするモジュールや関数の名前が長すぎて扱いにくい場合や、名前の衝突が起きてしまう場合は、as キーワードを使って別名を付けることができます。 long_long_module.py をインポートするとき import long_long_module as llm llm.hello() mypackage/long_long_module.py をインポートするとき from mypackage import long_long_module as llm llm.hello() パッケージ内のモジュールから別のモジュールをインポートするときの注意 +-- main.py +-- libs/ +-- mod1.py +-- mod2.py このようなディレクトリ構成で libs パッケージを作っていて、mod1.py から mod2.py をインポートしたいときは、次のように from . を付けて、相対パスインポート の形で記述する必要があります（逆に、ドット (.) を使わないインポートを絶対パスインポートと呼びます）。 libs/mod1.py（パッケージ内モジュールからのインポート） from . import mod2 def hello(): mod2.hello() libs/mod2.py def hello(): print(&#39;hello&#39;) 上記の from . import mod2 となっているところを、単純に import mod2 と書いてしまうと、main.py から次のように mod1 経由で読み込もうとしたときに ModuleNotFoundError: No module named 'mod2' エラーになってしまいます。 main.py from libs import mod1 mod1.hello() ☝️ なぜ相対パスで import しないといけないのか？ パッケージ内モジュールからの絶対パスインポートが失敗する原因は、Python の検索パスの仕組み (sys.path) にあります。 python コマンドで何らかのスクリプト (.py) を起動すると、そのファイルが存在するディレクトリがモジュールの検索パスに追加されます。 上記の例で言うと、main.py と同じディレクトリにあるモジュールであれば絶対パスでインポートできるようになります。 一方で、libs/mod1.py が処理されているときも、libs ディレクトリは検索パスに含まれていないため、import mod2 という絶対パスインポートはエラーになってしまいます（main.py と同じディレクトリの mod2.py を探そうとしてしまう）。 もちろん、main.py からの絶対パスで from libs import mod2 と記述することは可能ですが、それよりは相対パスで from . import mod2 と記述した方が分かりやすいでしょう。 別の階層のモジュールをインポートする 同じパッケージ階層のモジュールをインポートするときは、相対パスで from . import モジュール名 としましたが、1 つ上の階層にあるモジュールをインポートしたいときは、ドットの数を 1 つ増やして from .. import モジュール名 とします。 2 つ上の階層のモジュールをインポートしたければ、さらにドットを増やして from ... import モジュール名 とします。 同じ階層のモジュール（内のメンバー）のインポートする場合 from . import mod from .mod import hello 1 つ上の階層のモジュール（内のメンバー）のインポートする場合 from .. import mod from ..mod import hello 2 つ上の階層のモジュール（内のメンバー）のインポートする場合 from ... import mod from ...mod import hello 例えば、下記のような 2 つのサブパッケージを含むパッケージ mylib があったとします。 +-- mylib/ +-- sub1/ | +-- mod1.py +-- sub2/ +-- mod2.py sub1/mod1.py の中から、sub2/mod2.py をインポートするには下記のように記述します。 sub1/mod1.py from ..sub2 import mod2 def hello(): mod2.hello() パッケージの初期化ファイル (__init.py__) Python 3.3 より前のバージョンでは、パッケージディレクトリに __init__.py というファイルを置かなければ、そのディレクトリをパッケージとして認識させることができませんでした（ImportError: No module named ... というエラーが発生する）。 Python 3.3 以降では単純にディレクトリ内に .py ファイルを放り込んでおけば、そのディレクトリをパッケージとして扱うことができるようになっています（詳細は PEP 420 &ndash; Implicit Namespace Packages を参照）。 パッケージディレクトリに置かれた __init__.py は、そのパッケージ（あるいはその中のモジュール）をインポートしたときに実行されます。 例えば、__init__.py の中で各モジュールをインポートするように記述しておけば、パッケージを利用するときに個々のモジュールを指定してインポートする必要がなくなります（ただし、必要のないモジュールまでデフォルトでインポートしてしまうのは効率が悪いので、オススメはできません）。 ディレクトリ構成 +-- main.py +-- mylib/ （パッケージ） +-- __init__.py +-- mymod1.py （モジュール） +-- mymod2.py （モジュール） mylib/__init__.py from . import mymod1 from . import mymod2 main.py import mylib # これだけで mylib.mymod1 と mylib.mymod2 がインポートされる if __name__ == &#39;__main__&#39;: mylib.mymod1.foo() mylib.mymod2.bar() モジュールのドキュメンテーションコメントを記述する モジュールの先頭に &quot;&quot;&quot;コメント&quot;&quot;&quot; という形式のドキュメンテーションコメントを記述しておくと、そのモジュールのドキュメントして認識されます。 fibo.py &#34;&#34;&#34;Fibonacci numbers module.&#34;&#34;&#34; def fib(n): &#34;&#34;&#34;Print fibonacci series up to n.&#34;&#34;&#34; a, b = 0, 1 while b &lt; n: print(b, end=&#39; &#39;) a, b = b, a+b このように記述したドキュメントは、pydoc コマンドや help 関数などで参照することができます。 $ pydoc fibo Help on module fibo: NAME fibo - Fibonacci numbers module. FUNCTIONS fib(n) Print fibonacci series up to n. FILE D:\\y\\sandbox\\python\\fibo.py パッケージ単位のドキュメントを記述したいときは、そのパッケージの __init__.py の先頭にドキュメンテーションコメントを記述します。 mylib/__init__.py &#34;&#34;&#34;My first package.&#34;&#34;&#34; pydoc コマンドでパッケージドキュメントを参照すると、そのパッケージに含まれているモジュールのリスト (PACKAGE CONTENTS) も表示してくれます。 $ pydoc mylib Help on package mylib: NAME mylib - My first package. PACKAGE CONTENTS mymod1 mymod2 パッケージ内の個々のモジュールのドキュメントを参照したい場合は、pydoc mylib.mymod1 のように、パッケージ名の後ろにドットで繋げてモジュールを指定します。"},{url:"/p/qs6iv8j/",title:"NumPy / pandas / Matplotlib の概要とインストール",date:"2016-12-13T00:00:00+09:00",body:"NumPy / pandas / Matplotlib の概要とインストール NumPy / pandas / Matplotlib とは NumPy、pandas、Matplotlib などのライブラリは組み合わせて使用することの多いライブラリで、それぞれ下記のような特徴を持っています。 NumPy - 数値計算ライブラリ (numpy.org) C で実装された高速な多次元配列である ndarray（通称 NumPy 配列）、及び関連メソッドを扱うことができます。 Python のみで行列を表現しようとすると、配列の配列（要素ごとに可変長）を作ることになりますが、NumPy 配列ではn x m の固定サイズ、単一タイプのデータとして扱うことで非常に高速な計算処理を行えるようになっています。 pandas &ndash; 数値解析ライブラリ (pandas.pydata.org) R 言語のような数値解析を行うことができるライブラリです。 データファイルの読み込み、加工、集計、可視化までを総合的に行うことができます。 データのプロットには内部で Matplotlib を使用しており、pd.DataFrame.plot() がラッパーとして提供されています。 Matplotlib &ndash; グラフ描画ライブラリ (matplotlib.org) 単独でグラフを描画するために使用できるライブラリですが、pandas による計算結果を描画するために内部で使用されています。 NumPy / pandas / Matplotlib のインストール Python 3.4 以降はパッケージ管理のための pip コマンドが標準で搭載されているので、これを使って NumPy と pandas と Matplotlib をインストールするのがお手軽です。 まずは、pip コマンド自体を最新にアップグレードします。 $ pip install --upgrade pip 引き続き、NumPy と Matplotlib のインストールを行います。 $ pip install numpy $ pip install pandas $ pip install matplotlib これで、import numpy、import pandas、import matplotlib といった感じでインポートできるようになります。 慣例になっている別名 各ライブラリを import するときは、下記のように略称 (plt, np, pd) を定義して使用するのが慣例ととなっています。 import matplotlib.pyplot as plt import numpy as np import pandas as pd トラブルシューティング: tkinter モジュールが見つからない import matplotlib.pyplot などを実行したときに、下記のように tkinter モジュールが足りないというエラーが出ることがあります。 ImportError: No module named &#39;tkinter&#39; tkinter は GUI ライブラリの Tk を Python から利用できるようにしたモジュールです。 Tk 自体はもはや時代遅れの GUI ライブラリですが、matplotlib ではまだ Tk を使用しているので、tkinter のインストールが必要です。 Linux の場合は、python3-tk パッケージを導入すれば、Python 内で tkinter モジュールをインポートできるようになります。 $ sudo apt-get install python3-tk Windows の場合は、Python のインストーラ を実行して、 &ldquo;tcl/tk and IDLE&rdquo; という項目にチェックをいれてインストールしてください。"},{url:"/p/6h2izfh/",title:"Windows で pydoc コマンドを使用できるようにする",date:"2016-12-08T00:00:00+09:00",body:"Windows で pydoc コマンドを使用できるようにする pydoc コマンドを使用すると、下記のように Python の API ドキュメントを手軽に参照できます。 $ pydoc list.sort Help on method_descriptor in list: list.sort = sort(...) L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* Windows では Python をインストールしただけでは pydoc コマンドは使用できませんが、実装自体は Lib/pydoc.py というスクリプトとしてインストールされます。 下記のようなバッチファイルを python.exe と同じディレクトリに作成しておけば、Windows でも pydoc コマンドを使用できるようになります。 pydoc.cmd @python %~dp0\\Lib\\pydoc.py %* 実行例 C:\\&gt; pydoc dict.update Help on method_descriptor in dict: dict.update = update(...) D.update([E, ]**F) -&gt; None. Update D from dict/iterable E and F. If E is present and has a .keys() method, then does: for k in E: D[k] = E[k] If E is present and lacks a .keys() method, then does: for k, v in E: D[k] = v In either case, this is followed by: for k in F: D[k] = F[k]"},{url:"/p/gxajt4d/",title:"Python で ZIP/JAR ファイルの内容を読み込む (zipfile)",date:"2016-12-06T00:00:00+09:00",body:"Python で ZIP/JAR ファイルの内容を読み込む (zipfile) Python に標準搭載されている zipfile モジュール を使用すると、ZIP ファイルや JAR ファイルの読み書きを手軽に行うことができます。 ZIP ファイル内のファイル一覧を取得する 下記のサンプルでは、指定した ZIP ファイル内のファイルリストとその（展開後の）サイズを出力します。 zipfile.ZipFile コンストラクタで ZipFile オブジェクトを生成し、infolist メソッドで ZIP 内のファイル情報 (ZipInfo) を取得できます。 dump_zip.py import zipfile with zipfile.ZipFile(&#34;sample.zip&#34;, &#34;r&#34;) as zf: for info in zf.infolist(): if info.is_dir(): continue # ディレクトリ情報は出力せずにスキップ print(f&#34;{info.filename} ({info.file_size} bytes)&#34;) 実行結果 $ python dump_zip.py data/sample1.txt (4560 bytes) data/sample2.txt (2284 bytes) data/sample3.txt (5712 bytes) README.txt (1417 bytes) ファイル名でソートして出力したい場合は、下記のようにいったんリストにしてソートしてしまえば OK です。 with zipfile.ZipFile(&#34;sample.zip&#34;, &#34;r&#34;) as zf: arr = list(zf.infolist()) arr.sort(key=lambda x: x.filename) for info in arr: print(f&#34;{info.filename} ({info.file_size} bytes)&#34;) ZIP ファイル内のファイルを読み込む ZIP ファイル内の個々のファイルの内容を読み込むには、ZipFile#read メソッド を使用します。 このメソッドは、ファイルの内容をバイトデータ (bytes) として返します。 バイトデータをテキストデータに変換するには、bytes#decode メソッドを使用します。 ZIP ファイル内のテキストファイルを読み込む import zipfile with zipfile.ZipFile(&#34;sample.zip&#34;, &#34;r&#34;) as zf: for info in zf.infolist(): if info.is_dir(): continue # ディレクトリならスキップ if not info.filename.endswith(&#34;.txt&#34;): continue # .txt 以外のファイルもスキップ # ファイルのバイトデータを読み込んでテキストに変換する text = zf.read(info).decode(&#34;utf-8&#34;) print(f&#34;=== {info.filename} ===&#34;) print(text) 実行結果 === data/sample1.txt === ...（省略）... === data/sample2.txt === ...（省略）... === data/sample3.txt === ...（省略）... === README.txt === ...（省略）... JAR ファイル内のクラス一覧を取得する JAR ファイルもフォーマット上は ZIP ファイルと同じ構造なので、ZIP ファイルを扱うのと同様に処理することができます。 ここでは、JAR ファイル内の .class ファイルのみを処理するために、ファイルの拡張子が .class であるかを確認しながらループ処理しています。 ここでは、ファイル名から拡張子を抽出するために os.path.splitext を使っていますが、もっと単純に str#endswith などで代用してもよいかもしれません。 dump_classes.py import zipfile import os import sys def iter_classes_in_jar(jar_name): &#34;&#34;&#34;JAR ファイル内の .class ファイルの名前をもとに Java クラス名を列挙します。&#34;&#34;&#34; with zipfile.ZipFile(jar_name, &#34;r&#34;) as zf: for info in zf.infolist(): classname, ext = os.path.splitext(info.filename) if ext != &#34;.class&#34;: continue # .class 以外のファイルはスキップ yield classname if __name__ == &#34;__main__&#34;: jar_name = sys.argv[1] # List all classes for clazz in iter_classes_in_jar(jar_name): print(clazz) 実行結果 $ python dump_classes.py app.jar com/example/myapp/Bar com/example/myapp/Foo com/example/myapp/Main ..."},{url:"/p/6k5m4jy/",title:"Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP)",date:"2016-12-05T00:00:00+09:00",body:"Python の対話型シェルのスタートアップ処理を設定する (PYTHONSTARTUP) python コマンドを単独で実行したときのインタラクティブシェルは、環境変数 PYTHONSTARTUP に指定したスタートアップ・スクリプトを最初に実行します。 これを利用して、日常的に使用したい関数などを自動的に定義することができます。 例えば、下記の例では、ホームディレクトリにある .pythonstartup スクリプトを読み込むように設定しています。 ~/.bash_profile (Linux や Mac OSX の場合） export PYTHONSTARTUP=~/.pythonstartup Windows の場合は、システムのプロパティから環境変数を設定してください（~/ という表記は使用できないので、スタートアップ・スクリプトの位置はフルパスで指定する必要があります）。 コマンドラインから環境変数を設定することもできます。 C:\\&gt; setx PYTHONSTARTUP D:/x/myconf/pythonstartup.py （コマンドプロンプトを再起動して反映） 下記のスタートアップ・スクリプトでは、モジュールのソースコードをさくっと確認するための DEV.code 関数を定義しています。DEV.file 関数の方は、指定したモジュールのコードを Vim エディタで開きます。 ~/.pythonstartup class DEV: @staticmethod def code(obj): import inspect print(inspect.getsource(obj)) @staticmethod def file(obj): import inspect import os os.system(&#39;gvim &#39; + inspect.getfile(obj)) あとは、Python のインタラクティブシェルを起動すれば、上記の関数が定義された状態で起動します。 $ python ... &gt;&gt;&gt; import os &gt;&gt;&gt; DEV.code(os.path.split) def split(p): &#34;&#34;&#34;Split a pathname. Return tuple (head, tail) where tail is everything after the final slash. Either part may be empty.&#34;&#34;&#34; seps = _get_bothseps(p) d, p = splitdrive(p) # set i to index beyond p&#39;s last slash i = len(p) while i and p[i-1] not in seps: i -= 1 head, tail = p[:i], p[i:] # now tail has no slashes # remove trailing slashes from head, unless it&#39;s all slashes head = head.rstrip(seps) or head return d + head, tail"},{url:"/p/xbucsaq/",title:"Python の関数やクラスのソースコードを確認する (inspect)",date:"2016-12-05T00:00:00+09:00",body:"Python の関数やクラスのソースコードを確認する (inspect) 関数のコードを表示する Python のプログラムを作成しているときに、ある関数のソースコードを確認したくなったときは、inspect モジュールの getsource 関数を使用して簡単に調べることができます。 次の例では、Python の対話型シェル（python3 コマンド）を起動して、os.path.abspath 関数の実装コードを確認しています。 例: os.path.abspath の実装コードを確認する &gt;&gt;&gt; import inspect &gt;&gt;&gt; import os &gt;&gt;&gt; print(inspect.getsource(os.path.abspath)) def abspath(path): &#34;&#34;&#34;Return an absolute path.&#34;&#34;&#34; path = os.fspath(path) if not isabs(path): if isinstance(path, bytes): cwd = os.getcwdb() else: cwd = os.getcwd() path = join(cwd, path) return normpath(path) （おまけ）シェルスクリプト化しておく 次のようなシェルスクリプト (pycode) を作っておくと、Python の関数の実装コードを簡単に確認できるようになります。 このシェルスクリプトは、PATH の通ったディレクトリに置いて、chmod +x pycode で実行権限を付けておきます。 /Users/maku/bin/pycode #!/bin/bash # # pycode - Python の関数やクラスの実装コードを表示します # # Usage: # $ pycode &lt;モジュール名&gt; &lt;関数名|クラス名&gt; # # 使用例: # $ pycode os path.abspath # # 引数の数を確認 if [ &#34;$#&#34; -ne 2 ]; then echo &#34;Usage: $(basename $0) &lt;モジュール名&gt; &lt;関数名|クラス名&gt;&#34; exit -1 fi # 引数からモジュール名と関数名を取得 module_name=&#34;$1&#34; function_name=&#34;$2&#34; # 関数のコードを表示するための Python コード python_code=$(cat &lt;&lt;END import $module_name import inspect try: function_code = inspect.getsource($module_name.$function_name) print(function_code) except (ImportError, AttributeError): print(f&#34;シンボルが見つかりません: {module_name}.{function_name}&#34;) END ) # Python コマンドを実行して関数のコードを表示 python3 -c &#34;$python_code&#34; 例えば、os モジュールの path.abspath 関数のコードを確認するには次のように実行します。 pycode の使用例 $ pycode os path.abspath 関数が定義されているファイル全体を表示する inspect.getsource 関数でモジュール名を指定すれば、そのモジュール全体のコードを取得することができるのですが、ハイライト表示なしで長いコードが表示されると非常に読みにくいです。 ここでは、モジュールが定義されているファイルそのものをテキストエディタで開く方法を紹介します。 inspect.getfile 関数を使用すると、指定したクラス、関数、オブジェクトなどが定義されているファイルのパスを取得することができます。 例: os モジュールのソースコードのパスを調べる &gt;&gt;&gt; import inspect &gt;&gt;&gt; import os &gt;&gt;&gt; inspect.getfile(os) &#39;C:\\\\Python35\\\\lib\\\\os.py&#39; あとは、そのファイルを任意のエディタで開けば OK です。 エディタの実行ファイルにパスが通っているのであれば、os.system 関数を使って、そのエディタでさくっと開くことができます。 例: os モジュールのソースコードを gvim エディタで開く &gt;&gt;&gt; import inspect &gt;&gt;&gt; import os &gt;&gt;&gt; os.system(&#39;gvim &#39; + inspect.getfile(os))"},{url:"/java/",title:"Java",date:"2016-11-24T00:00:00+09:00",body:"Java アノテーション アノテーションとは Java でカスタムアノテーションを作成する Javadoc でアノテーションのサンプルコードを記述するときの @ の扱い マルチスレッド Executor によるタスク処理 (1) Executor インタフェースを使用する Executor によるタスク処理 (2) ExecutorService インタフェースで Executor を停止する Executor によるタスク処理 (3) Future オブジェクトによりタスクの実行結果を取得する Executor によるタスク処理 (4) 既存の Thread から Future オブジェクトを取得する Executor によるタスク処理 (5) ScheduledExecutorService によるタスクのスケジュール BlockingQueue を使ってスレッド間の通信を行う Lock と Condition による条件ごとのスレッド待機 TimeUnit によって単位時間を明確にする スレッドで発生した Uncaught Exception（未捕捉例外）をハンドルする Java のオブジェクトロックは再入可能であることを理解する Boolean 型で synchronized するのは NG ファイル JAR/ZIP jar コマンドで JAR ライブラリを作成する jar コマンドで実行可能な JAR ファイルを作成する JAR ファイルの署名について Zip ファイル内の要素（ファイルとディレクトリ）を列挙する XML DOM プログラミング - XML のルート要素を取得する DOM プログラミング - 子要素のテキストノードの値を取得する DOM プログラミング - 同じタグ名を持つ全ての子要素をループ処理する ファイル一般 Propertiesファイルから設定値を読み込む MANIFEST.MF ファイルの内容を取得する 数値／文字列／ユニコード 数値と文字列の変換方法いろいろ バイト配列から 16 進数文字列を作成する 文字列をデリミタで分割する (String.split) CSV 形式の文字列を配列に分割する (String.split, Pattern.split) 文字列を単語単位で分割する (BreakIterator) 文字列の結合には StringBuffer ではなく StringBuilder を使用する 小文字と大文字の変換を行う 小文字と大文字の判別を行う ある文字が空白文字（スペース）かどうかを判別する 全角文字と半角文字を含んだ文字列を正規化して表記ゆれを吸収する コードポイントに対応するユニコード文字 (char) を取得する ある文字のコードポイントに対応するユニコード名を調べる 対応している文字セット (Charset) の一覧を取得する 文字列が正規表現に完全に一致するか調べる (String.matches) 文字列の一部が正規表現に一致するか調べ、一致した部分をグループごとに抜き出す (Pattern.matcher) 文字列の正規表現に一致した部分を置き換える (String.replaceAll) 複数行のテキストを含んだ String を一行ずつ処理する 組み合わせ 順列 (permutation) を作成する データベース/JDBC JDBC ドライバの一覧を取得する Java から SQLite を扱えるようにする JDBC による DB 操作の流れ JDBC でプレースホルダを使用して SQL クエリを作成する JDBC で最初のレコードだけを取得する 解析／デバッグ コールスタックを表示する Java で Linux の CPU 使用率を調べる SuprressWarnings アノテーションで Checkstyle の警告を抑制する Java ビルドツールのまとめ (Ant, Maven, Gradle) クラスやメソッドの依存関係を調べる (jdeps, cfa) DEBUG フラグでログ出力を ON/OFF するときは、呼び出し側で if 分岐すること その他 Javadoc コメントの書き方 例外のテストを記述する Java7 の try with resources でストリームの close を自動的に行う コレクションクラスのまとめ static ブロックが実行されるタイミング シングルトンクラスの Lazy Loading イディオム オブジェクトプールを実現するためのクラスを実装する JNI (Java Native Interface) の基本 Java でランダムな UUID を生成する enum の各項目に任意のデータを関連付ける 既定の Web ブラウザで URL を開く コラム J2SE から Java SE へ System.out.println() でオブジェクトを出力するときは toString() しない Effective Java や Java の鉄則など コンストラクタの代わりに static ファクトリメソッドを検討する 数多くのコンストラクタパラメータに直面したときにはビルダーを検討する private のコンストラクタか enum 型でシングルトン特性を強制する private のコンストラクタでインスタンス化不可能を強制する 不必要なオブジェクトの生成を避ける 廃れたオブジェクト参照を取り除く ファイナライザを避ける equals をオーバライドする時は一般契約に従う equals をオーバライドする時は常に hashCode をオーバライドする toString を常にオーバライドする clone を注意してオーバライドする Comparable の実装を検討する コンストラクタからオーバライド可能なメソッドを呼び出さない 国際化 Java アプリケーションの国際化 (i18n) と Locale クラス Locale が変わったときに変化すべき表示項目 Swing 基本 Swing で Hello World Swing - Container と JComponent と JFrame の関係 Swing - JPanel に GUI コンポーネントを配置する Swing - 標準的なダイアログいろいろ Swing - OK ボタンと Cancel ボタンのあるダイアログを作る Swing - JDialog のウィンドウサイズを変更できるようにする Swing - スプリッターを配置してウィンドウを分割する Swing - スプリッターを折り畳み可能にする Swing - スプリッターの分割方向を動的に変更する Swing - コンポーネントにツールティップを表示する Swing - ショートカットキーでフォーカスを移動する Swing - 右クリックでポップアップメニューを表示する Swing - ルック＆フィールを切り替える レイアウト Swing - レイアウトマネージャの種類 Swing - デフォルトのレイアウトマネージャについて Swing - BorderLayout でコンポーネントを上下左右中央に並べる Swing - BorderLayout で中央に配置するコンポーネントのデフォルトサイズを設定する Swing - BorderLayout でコンポーネント間のスペースを設定する Swing - BoxLayout でコンポーネントを縦方向、横方向に並べる Swing - BoxLayout で左寄せ／中央寄せ／右寄せ表示する Swing - FlowLayout でコンポーネントを左上から並べる Swing - FlowLayout でコンポーネントが複数行表示されるときに左寄せ／右寄せする コンポーネント（ウィジェット） Swing - JButton（ボタン）にショートカットキーを割り当てる Swing - JComboBox でルック＆フィールの選択肢を表示する Swing - JEditorPane で HTML コンテンツを表示する Swing - JEditorPane で画像ファイルを表示する Swing - JEditorPane にスタイルシート (CSS) を設定する Swing - JEditorPane でハイパーリンク関連のイベントをハンドルする Swing - JEditorPane で先頭部分を表示する Swing - JList で項目のリストを表示する Swing - JList で扱えるモデルクラスを作成する Swing - JList に動的に要素を追加／削除する Swing - JList で項目を選択したときのイベントをハンドルする Swing - JList で最初に表示される行数を指定する Swing - JList で選択されている項目を取得する Swing - JList で単一の項目のみ選択できるようにする Swing - JList で最後の項目を選択する Swing - JList でリスト項目としてチェックボックスを表示する Swing - JSpinner を使って上下矢印で値を入力できるようにする Swing - JTextArea で複数行のテキストを表示する Swing - JTextArea のテキストを画面端で折り返す Swing - JTextArea のテキストを編集不可にする Swing - JTextArea に表示するフォントを設定する Swing - JTextArea でテキストの先頭部分を表示する Swing - JTextField で Enter キーを押したときにテキストを取得する Swing - JTextFiled で Esc キーを押したときにテキストをクリアする Swing - JTextField のテキストを右寄せで表示する Swing - JTextField でテキストの先頭／末尾部分を強制的に表示する Swing - JTree でツリービューを作成する Swing - JTree に動的にノードを追加する Swing - JTree で選択されているノードを取得する Swing - JTree でノードを選択したときのイベントをハンドルする Swing - JTree でルートノードを表示する Swing - JTree で一階層目のノード間に水平線を表示する Swing - JTree で同時に1つのノードしか選択できないようにする Swing - JTree で指定したノードを選択する SWT (Standard Widget Toolkit) SWT - AWT と Swing と SWT と JFace の違い SWT - SWT を使用するための設定 SWT - Mac で SWT を使用する SWT - SWT アプリケーションの雛形コード SWT - SWT の Layout は Composite の入れ子で構成する SWT - RowLayout でウィジェットを縦／横方向に並べる SWT - FillLayout でウィジェットを縦／横に等間隔に並べる SWT - SashForm でウィンドウを分割して配置する SWT - リストボックス (List) を表示する SWT - ツリービュー (Tree) を表示する SWT - いろいろなダイアログ (MessageBox) を表示する SWT - ブラウザウィジェット (Browser) で HTML を表示する SWT - SWT/JFace における色 (Color) 情報の扱い方 SWT - 矢印ボタンを作る SWT - Canvas を使って自由に描画する SWT - Cannot load 32-bit SWT libraries エラーが発生する場合 JFace を使用するための設定 JFace アプリケーションの雛形コード JFace のウィンドウにウィジェットを配置する JFace のウィンドウのタイトルを設定する JFace の ListViewer を使用する JFace の TreeViewer を使用する JFace の TreeViewer を使ってディレクトリツリーを表示する 階層構想を表現した RDB のデータを JFace の TreeViewer でツリー表示する JFace の CheckboxTreeViewer を使用する JFace の TableViewer を使用してテーブルにデータを表示する トラブルシューティング CLASSPATH 関連のエラーに対処する Mac で javac の出力が文字化けする"},{url:"/p/mpqhkpv/",title:"クラスやメソッドの依存関係を調べる (jdeps, cfa)",date:"2016-11-24T00:00:00+09:00",body:"クラスやメソッドの依存関係を調べる (jdeps, cfa) パッケージ／クラスレベルの依存関係を調べる (jdeps) JDK 8 に付属している jdeps コマンド を使用すると、JAR ファイル（.class ファイル）から、パッケージレベル、あるいは、クラスレベルの依存関係を調べることができます。 パッケージレベルの依存関係を調べる すべての依存を表示（グルーピングして表示） $ jdeps app.jar 1 行ごとに「依存元 -&gt; 依存先」というフォーマットで出力 $ jdeps -v app.jar あるパッケージへの依存のみを抽出したい場合は、-e オプションで次のように指定します。 com.example.util パッケージへの依存のみを表示 $ jdeps -e com.example.util.* app.jar ☝️ ワンポイント 特定のパッケージへの依存は、-p オプションでも検索することができますが、 こちらの場合は、完全にパッケージ名が一致するもののみを抽出します。 あるパッケージより下位のパッケージも含めて検索するには、上記のように -e オプションで正規表現の形でパッケージ名を指定する必要があります。 クラスレベルの依存関係を調べる $ jdeps -verbose:class app.jar メソッドレベルの依存関係を調べる (cfa) YaSuenag さんの作成している cfa (Class File Analyzer) というツールを使用すると、.class ファイルを解析して、メソッドレベルの依存関係を調べることができます。 https://github.com/YaSuenag/cfa/（fork しておく） 実行ファイルは cfa.jar です。 Windows であれば、下記のようなバッチファイルを JAR と同じディレクトリにおいて PATH を通しておくと、どのディレクトリからでも cfa と入力するだけで実行できて便利です。 cfa.cmd @echo off setlocal set jar=&#34;%~dp0%cfa.jar&#34; set java=java.exe if defined JDK_HOME ( set java=%JDK_HOME%\\bin\\java.exe ) %java% -jar %jar% %* endlocal cfa.jar は、JRE ではなく JDK に付属している java コマンド経由で実行する必要があることに注意してください。 実行時に下記のようなエラーが発生する場合は、JRE の java コマンドを参照してしまっている可能性が高いです。 Exception in thread &#34;main&#34; java.io.FileNotFoundException: tools.jar does not exist. このような場合は、JDK_HOME 環境変数に JDK をインストールしたディレクトリパス（例: C:\\jdk1.8.0_65）を設定してください。 上記のバッチファイルでは、この環境変数で設定された JDK の java コマンドを参照するようになっています。 下記は cfa コマンドの使用例です。 メソッドレベルの依存関係を調べる（参照しているクラスやフィールドの情報も表示されます） $ cfa app.jar com.example.aaa と com.example.bbb を参照しているメソッドだけを対象とする $ cfa -c com.example.aaa,com.example.bbb app.jar"},{url:"/p/b27pn7d/",title:"スケジューリングや見積りの段階では要求と設計要素のマトリクスで考える",date:"2016-11-02T00:00:00+09:00",body:"スケジューリングや見積りの段階では要求と設計要素のマトリクスで考える ソフトウェアで実現したいこと（ここでは「要求」と呼ぶことにします）と、そのために必要な設計要素は多対多の関係になることが多く、開発スケジュールを決める段階では、その関係を把握することポイントになってきます。 例えば、 要求 1 を実現するには、設計要素 A と B の実装が必要 要求 2 を実現するには、設計要素 A と C の実装が必要 といったケースでは、要求 1 と要求 2 の実装工数を別々に見積ることにあまり意味はありません。 なぜなら、それらを実現するために必要な設計要素 A が重複しているため、単純に合計したときに正しい見積りとならないからです（過大な工数見積りになってしまう）。 つまり、工数見積りは、あくまで設計要素に対して行い、それらの組み合わせとしてどの要求が満たされるか、といった考え方をするべきです。 要求変更や仕様変更に対する設計要素への影響を見える化するための「トレーサビリティ・マトリクス」という考え方がありますが、プロジェクトの初期段階ではそこまでしっかりとした表を作る必要はなく、ざっと工数見積りを行うための表を描いてみるとよいです。 例えば以下のような感じです。 工数 要求1 要求2 設計要素 A 7 ● ● 設計要素 B 1 ● 設計要素 C 3 ● このような表があれば、要求 1 だけを実現するための工数は 8 (7+1)、要求 2 だけを実現するための工数は 4 (1+3)、両方を実現するための工数は 11 (7+1+3)、と見積ることができます。 どのような実装をすれば、より少ない工数でより多くの要求を満たすことができるのかを把握できるようになります。"},{url:"/vagrant/",title:"Vagrant",date:"2016-11-01T00:00:00+09:00",body:"Vagrant Vagrant の基本 Vagrant とは？ Vagrant をインストールする Vagrant により仮想マシンを立ち上げる Vagrant の仮想マシンに SSH で接続する ホストマシンと仮想マシンでファイルを共有する 仮想マシンでシェルスクリプトを実行する 不要な Vagrant 仮想マシンを削除する (vagrant destroy) 不要な box を削除する (vagrant remove box) Vagrant のネットワーク構成 Vagrant の３種類のネットワーク構成の違い ホストオンリーネットワークを構成する (private network) ポートフォワードにより仮想マシン内のサーバにアクセスする ブリッジネットワークを構築する その他 Vagrant プラグインを vagrant up で自動的にインストールする 仮想マシンのプロキシを設定する 複数の仮想マシンを同時に立ち上げる 複数の仮想マシンで共通の SSH キーを使用する"},{url:"/p/6wsa466/",title:"Vagrantメモ: 不要な box を削除する (vagrant remove box)",date:"2016-11-01T00:00:00+09:00",body:"Vagrantメモ: 不要な box を削除する (vagrant remove box) box ファイルとは Vagrant の仮想マシンは、OS のスナップショットともいえる box ファイルをベースにして生成されるようになっています。 この仕組みによって、仮想マシンの破棄 (vagrant destroy)、再生性 (vagrant up)、Ansible による環境構築のテスト、といった試行錯誤が短時間で実行できるようになっています。 box ファイルの実体は VirtualBox などの仮想イメージなので、ファイルサイズは非常に大きくなります（数百 MB ～ 数 GB 程度）。 そのため、box ファイルは複数の Vagrant プロジェクトから共有されるようになっており、デフォルトでは ~/.vagrant.d ディレクトリに格納されています（Windows の場合は %USERPROFILE%\\.vagrant.d）。 $ ls ~/.vagrant.d/boxes centos-VAGRANTSLASH-7 hashicorp-VAGRANTSLASH-precise64 この例では、centos/7 と hashicorp/precise64 という box が格納されていることが分かります（スラッシュはファイル名に含められないので -VAGRANTSLASH- と置換されているようです）。 不要な box の削除 box ファイルはサイズが大きく、ホスト上のディスクスペースを消費してしまうため、本当に不要になったら削除してしまいましょう。 現在存在している box ファイルを確認するには、vagrant box list コマンドを使用します。 $ vagrant box list centos/7 (virtualbox, 1609.01) hashicorp/precise64 (virtualbox, 1.1.0) 不要な box が存在していることが分かったら、その box 名を vagrant box remove コマンドに渡します。 $ vagrant box remove centos/7 Removing box &#39;centos/7&#39; (v1609.01) with provider &#39;virtualbox&#39;... これで完全に box ファイルが削除されます。 再び同じ box イメージを使用して vagrant up で仮想環境を立ち上げようとすると、box イメージのダウンロードから始まるので時間がかかります。 box ファイルを削除しようとしたときに、その box から生成した仮想マシンが動作している場合は警告が表示されます。 $ vagrant box remove hashicorp/precise64 Box &#39;hashicorp/precise64&#39; (v1.1.0) with provider &#39;virtualbox&#39; appears to still be in use by at least one Vagrant environment. Removing the box could corrupt the environment. We recommend destroying these environments first: webserver1 (ID: 3894c5d21ba1487c889d285dd9ff42c6) この状態で box を削除しても、既に動作している仮想マシンが停止してしまうことはありませんが、念のため vagrant global-status コマンドでその仮想マシンを使用しているプロジェクトを確認し、本当に削除してよい box なのかを判断しましょう。 box ファイルの格納場所を変える VAGRANT_HOME 複数の Vagrant プロジェクトから共有される box ファイルなどは、デフォルトで ~/.vagrant.d 以下に格納されますが、VAGRANT_HOME という環境変数を設定することで異なるディレクトリを扱うように変更することができます。"},{url:"/p/joud5wr/",title:"Vagrantメモ: Vagrant の３種類のネットワーク構成の違い",date:"2016-10-31T00:00:00+09:00",body:"Vagrantメモ: Vagrant の３種類のネットワーク構成の違い ３種類のネットワーク構成の概要 Vagrant におけるホストマシンと仮想マシンの間のネットワーク構成は、下記の３種類の形態から選択して構築します。 ホストオンリーネットワーク (private network) ホストマシンと仮想マシンの間でプライベートなアドレス空間を割り当て、その範囲内で通信できるようにします。ホスト内で閉じた世界になります。 ポートフォワード (forwarded port) ホストマシンの特定のポート番号へのアクセスを、仮想マシンの特定のポート番号にフォワードします。物理ネットワーク上では、1台のホストマシンがすべてのサービスを提供しているかのように見えます。 ブリッジネットワーク (bridge network) ホストマシンが参加している物理ネットワークに仮想マシンを参加させます。物理ネットワーク上で IP アドレスが割り当てられるため、あたかも物理的なマシンが増えたかのように見えます。 どのネットワーク構成を選択するべきか それぞれのネットワーク構成に一長一短があり、状況に応じて適切なネットワーク構成を選ぶことになります。 ここでは、各マシン同士のアクセスが可能かどうかと、そこから判断した仮想マシン側のセキュリティリスクという観点でざっと特徴をまとめておきます。 ネットワーク構成 host ↓ guest guest ↓ host guest ↓ guest physical net ↓ guest Security risk ホストオンリーネットワーク (private network) OK OK OK &ndash; Low（仮想マシンは外から見えない） ポートフォワード (forwarded port) OK &ndash; &ndash; OK Medium（仮想マシンの特定のポートだけアクセス可能） ブリッジネットワーク (public network) OK OK OK OK High（仮想マシンが物理ネットワークに参加する）"},{url:"/p/ymenseo/",title:"Vagrantメモ: ブリッジネットワークを構築する",date:"2016-10-31T00:00:00+09:00",body:"Vagrantメモ: ブリッジネットワークを構築する Vagrant でブリッジネットワークを有効にすると、ホストマシンと同じ LAN 内に、あたかももう一台の物理マシンがあるかのように、仮想マシンに IP アドレスを割り当てることができます。 Public Networks - Networking - Vagrant by HashiCorp ホストオンリーネットワークと同様に、仮想マシンからホストマシンへアクセスできるようになるだけでなく、LAN 内の他のマシンから仮想マシンにアクセスすることもできます（LAN のセキュリティポリシーでマシン間のアクセスが制限されている場合を除く）。 ブリッジネットワークを有効にするには、下記のように config.vm.network のネットワークタイプとして、public_network を設定します。 LAN 内の DHCP サーバから IP アドレスを割り当てる Vagrant.configure(&#34;2&#34;) do |config| config.vm.network &#34;public_network&#34; end 静的に IP アドレスを割り当てる Vagrant.configure(&#34;2&#34;) do |config| config.vm.network &#34;public_network&#34;, ip: &#34;192.168.0.17&#34; end Vagrantfile を変更したら、仮想マシンを立ち上げなおせば設定が反映されます。 $ vagrant reload"},{url:"/p/oyoyz27/",title:"Vagrantメモ: ホストオンリーネットワークを構成する (private network)",date:"2016-10-31T00:00:00+09:00",body:"Vagrantメモ: ホストオンリーネットワークを構成する (private network) ホストオンリーネットワークの特徴 ホストオンリーネットワーク (private network) の構成を利用すると、ホストマシンと仮想マシンの間に専用のネットワークを構築できます。 ホストオンリーネットワークにはホストマシンと仮想マシンの間だけから見えるプライベート IP アドレスを割り当てるため、既存の物理 LAN 上に存在する他のマシンからは、仮想マシンの存在を知ることはできません。 既存の LAN への影響がないため、パブリックな環境でも安心して利用できるネットワーク構成と言えます（既存の物理 LAN とは異なるネットワークに割り当てて使用します）。 物理 LAN 上のマシン ----[NG]----&gt; 仮想マシン 一方で、ホストマシンと仮想マシンは同じ専用ネットワークに所属することになるため、相互に自由なアクセスが可能です。 例えば、仮想マシンからホスト上で動作しているサービスを利用する、といったことが行えます。 ホスト &lt;----[OK]----&gt; 仮想マシン ポートフォワードを利用したネットワーク構成と比べ、各マシンで動作するサーバに素のポート番号でアクセスできる（HTTP サーバにポート 80 でアクセスできる）ため、シンプルで分かりやすいネットワーク構成になります。 ホストオンリーネットワークを構成する ホストオンリーネットワークを構築するには、config.vm.network で private_network を指定します。 ここでは、プライベートネットワークとして 192.168.100.0 というネットワークアドレス使用することにします。 仮想マシンには 192.168.100.10 という IP アドレスを割り当てます。 仮想マシンの IP アドレスの末尾は１にしないようにしてください（後述）。 Vagrantfile（DHCP で構成する） Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.network &#34;private_network&#34;, ip: &#34;192.168.100.10&#34; end あとは Vagrant 仮想マシンをリロードすれば設定が反映されます。 $ vagrant reload ホスト側に割り当てられるプライベートアドレス ホストオンリーネットワークを構成すると、ホスト側のアドレスとしては、ネットワークアドレスの下位オクテット（最後の８ビット）が１になったアドレスが割り当てられます。 仮想マシン側のアドレスの末尾を１にしなかったのはそのためです。 ホスト側の IP アドレスを確認してみると、Host-Only Network というセクションで、192.168.100.1 と割り振られていることがわかります。 C:\\&gt; ipconfig ... イーサネット アダプター VirtualBox Host-Only Network #4: 接続固有の DNS サフィックス . . . : リンクローカル IPv6 アドレス. . . . : fe80::840f:cd57:4fa2:9c8c%20 IPv4 アドレス . . . . . . . . . . : 192.168.100.1 サブネット マスク . . . . . . . . : 255.255.255.0 デフォルト ゲートウェイ . . . . . : ... 仮想マシン側からは、このアドレスを指定することでホストマシンにアクセスできます。"},{url:"/p/y9zrmbf/",title:"Vagrantメモ: 複数の仮想マシンで共通の SSH キーを使用する",date:"2016-10-28T00:00:00+09:00",body:"Vagrantメモ: 複数の仮想マシンで共通の SSH キーを使用する Vagrant で作成した複数の仮想マシンを Ansible などでまとめて制御する場合、同じ SSH キーでアクセスできると便利だったりします。 Vagrant 1.7 以降のデフォルトでは、作成した仮想マシンごとに異なる SSH キーが設定されます。 例えば、ここでは、下記のような Vagrantfile を使用して３つの仮想マシンを作成してみます。 Vagrantfile BOX = &#34;hashicorp/precise64&#34; Vagrant.configure(&#34;2&#34;) do |config| config.vm.define &#34;vagrant1&#34; do |c| c.vm.box = BOX end config.vm.define &#34;vagrant2&#34; do |c| c.vm.box = BOX end config.vm.define &#34;vagrant3&#34; do |c| c.vm.box = BOX end end 立ち上げます。 $ vagrant up Bringing machine &#39;vagrant1&#39; up with &#39;virtualbox&#39; provider... Bringing machine &#39;vagrant2&#39; up with &#39;virtualbox&#39; provider... Bringing machine &#39;vagrant3&#39; up with &#39;virtualbox&#39; provider... 仮想マシンが作成されたら、vagrant ssh-config コマンドを使用して、それぞれの SSH 接続情報を確認することができます。 仮想マシンごとに別々のプライベートキーが作成されていることが分かります（★の部分）。 $ vagrant ssh-config Host vagrant1 HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile /home/maku/sandbox/.vagrant/machines/vagrant1/virtualbox/private_key ★ IdentitiesOnly yes LogLevel FATAL Host vagrant2 HostName 127.0.0.1 User vagrant Port 2200 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile /home/maku/sandbox/.vagrant/machines/vagrant2/virtualbox/private_key ★ IdentitiesOnly yes LogLevel FATAL Host vagrant3 HostName 127.0.0.1 User vagrant Port 2201 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile /home/maku/sandbox/.vagrant/machines/vagrant3/virtualbox/private_key ★ IdentitiesOnly yes LogLevel FATAL 複数の仮想マシンでひとつの SSH キーを使用するようにするには、下記のように config.ssh.insert_key = false を設定します。 Vagrantfile（同じ SSH キーを使用するように修正） BOX = &#34;hashicorp/precise64&#34; Vagrant.configure(&#34;2&#34;) do |config| # Use the same key for each machine config.ssh.insert_key = false config.vm.define &#34;vagrant1&#34; do |c| c.vm.box = BOX end config.vm.define &#34;vagrant2&#34; do |c| c.vm.box = BOX end config.vm.define &#34;vagrant3&#34; do |c| c.vm.box = BOX end end 仮想マシンを作り直します。 $ vagrant destroy $ vagrant up SSH 接続情報を確認してみると、すべての仮想マシンで同じ SSH キーが設定されていることが分かります。 $ vagrant ssh-config Host vagrant1 HostName 127.0.0.1 User vagrant Port 2222 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile ~/.vagrant.d/insecure_private_key ★ IdentitiesOnly yes LogLevel FATAL Host vagrant2 HostName 127.0.0.1 User vagrant Port 2200 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile ~/.vagrant.d/insecure_private_key ★ IdentitiesOnly yes LogLevel FATAL Host vagrant3 HostName 127.0.0.1 User vagrant Port 2201 UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile ~/.vagrant.d/insecure_private_key ★ IdentitiesOnly yes LogLevel FATAL 例えば、Ansible を使ってこれらの Vagrant 仮想マシンを制御する場合は、設定ファイル ansible.cfg には次のような感じで共通の SSH キーを設定しておくことができます。 ansible.cfg hostfile = hosts remote_user = vagrant host_key_checking = False private_keyfile = ~/.vagrant.d/insecure_private_key"},{url:"/p/2gdbr8x/",title:"Vagrantメモ: 不要な Vagrant 仮想マシンを削除する (vagrant destroy)",date:"2016-10-27T00:00:00+09:00",body:"Vagrantメモ: 不要な Vagrant 仮想マシンを削除する (vagrant destroy) Vagrant で試行錯誤して仮想マシンを作っていると、以前作成した仮想マシンのゴミが残ってしまうことがあります。 ポートフォワード設定が重複してしまうと、新しい仮想マシンの起動も下記のように失敗してしまいます。 The forwarded port to 8080 is already in use on the host machine. 不要な仮想マシンを特定して１つずつ削除する このような場合は、まず vagrant global-status で Vagrant で管理されている仮想マシンの一覧を表示します。 vagrant status と異なり、vagrant global-status はどのディレクトリからでも実行でき、ホスト上のすべての Vagrant 環境に関する情報を表示してくれます。 C:\\&gt; vagrant global-status id name provider state directory -------------------------------------------------------------------------- 963e6d9 vagrant1 virtualbox running D:/z/vagrant dd68a71 vagrant2 virtualbox poweroff D:/z/vagrant The above shows information about all known Vagrant environments on this machine. This data is cached and may not be completely up-to-date. To interact with any of the machines, you can go to that directory and run Vagrant, or you can use the ID directly with Vagrant commands from any directory. For example: &#34;vagrant destroy 1a2b3c4d&#34; 上記の情報を頼りにして、不要な仮想マシンを削除してしまえば OK です。 D:\\&gt; vagrant destroy dd68a71 vagrant2: Are you sure you want to destroy the &#39;vagrant2&#39; VM? [y/N] y ==&gt; vagrant2: Destroying VM and associated drives... 仮想マシン名の代わりに ID を指定すると、どのディレクトリからでも vagrant destroy を実行することができます。 どうしてもポートを占有しているプロセスが消えないとき The forwarded port to 10443 is already in use on the host machine. といったポート番号の占有エラーがどうしても解消できない場合は、そのポートを占有しているプログラムのプロセスを強引に kill してしまう方法があります。 下記は Windows の例です。 まずは、対象のポートを占有してしまっているプロセスの ID を調べます。 D:\\&gt; netstat -ao | findstr 10443 TCP 0.0.0.0:10443 0.0.0.0:0 LISTENING 10420 プロセス ID 10420 が犯人だと分かりましたので、今度はどんなプログラムによるプロセスなのかを調べます。 D:\\&gt; tasklist | findstr 10420 VBoxHeadless.exe 10420 Console 1 53,948 K VirtualBox 関連のプログラムっぽいので、どうやら殺しても大丈夫そうなことが分かります。 D:\\&gt; taskkill /F /PID 10420 成功: PID 10420 のプロセスに強制終了のシグナルを送信しました。 強引にプロセス削除成功！"},{url:"/p/uu87xz5/",title:"Vagrantメモ: 複数の仮想マシンを同時に立ち上げる",date:"2016-10-25T00:00:00+09:00",body:"Vagrantメモ: 複数の仮想マシンを同時に立ち上げる 複数の仮想マシンを立ち上げる Vagrant 仮想マシンとして複数のサーバを同時に立ち上げるには、Vagrantfile の中で下記のようにそれぞれの仮想マシン定義を行います。 ここでは、すべて仮想マシンの box として hashicorp/precise (Ubuntu 12.04) を指定していますが、仮想マシンごとに異なる box を設定することもできます。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.define &#34;vagrant1&#34; do |c| c.vm.network &#34;forwarded_port&#34;, guest: 80, host: 10080 c.vm.network &#34;forwarded_port&#34;, guest: 443, host: 10443 end config.vm.define &#34;vagrant2&#34; do |c| c.vm.network &#34;forwarded_port&#34;, guest: 80, host: 20080 c.vm.network &#34;forwarded_port&#34;, guest: 443, host: 20443 end config.vm.define &#34;vagrant3&#34; do |c| c.vm.network &#34;forwarded_port&#34;, guest: 80, host: 30080 c.vm.network &#34;forwarded_port&#34;, guest: 443, host: 30443 end end 各仮想マシンのコンフィギュレーションブロック内でポートフォワード設定を行っていますが、単純に仮想マシンを立ち上げるだけであれば、このあたりの個別の設定は後回しにしても構いません。 あとは、vagrant up とするだけで、すべての仮想マシンが順番に立ち上がります。 $ vagrant up Bringing machine &#39;vagrant1&#39; up with &#39;virtualbox&#39; provider... Bringing machine &#39;vagrant2&#39; up with &#39;virtualbox&#39; provider... Bringing machine &#39;vagrant3&#39; up with &#39;virtualbox&#39; provider... ... ちゃんと稼働しているかどうかは vagrant status コマンドで確認することができます。 $ vagrant status Current machine states: vagrant1 running (virtualbox) vagrant2 running (virtualbox) vagrant3 running (virtualbox) This environment represents multiple VMs. The VMs are all listed above with their current state. For more information about a specific VM, run `vagrant status NAME`. それぞれの仮想マシンに SSH 接続するときは、下記のように vagrant ssh コマンドのパラメータで仮想マシン名を指定します。 $ vagrant ssh vagrant1 複数の仮想マシンを同時に制御する 複数の仮想マシンが存在する環境では、Vagrant のコマンドも複数の仮想マシンに影響するように変化します。 $ vagrant reload # すべての仮想マシンを再起動 $ vagrant reload web1 # web1 という名前の仮想マシンを再起動 $ vagrant reload web1 web2 # web1 と web2 を再起動 $ vagrant reload /web\\d/ # 正規表現で仮想マシンを指定することも可能 上記は、vagrant reload の例ですが、vagrant up や vagrant halt も同様に仮想マシン名を指定した制御を行えます。"},{url:"/p/zssu72a/",title:"Vagrantメモ: ポートフォワードにより仮想マシン内のサーバにアクセスする",date:"2016-10-24T00:00:00+09:00",body:"Vagrantメモ: ポートフォワードにより仮想マシン内のサーバにアクセスする ポートフォワードによるネットワーク構成について Vagrant 仮想マシン内でサーバを立ち上げた場合、デフォルトではそのポートは仮想マシン内で閉じた世界のものになっています。 例えば、仮想マシン内で Web サーバをポート番号 80 で立ち上げただけでは、外の世界（ホスト側）から http://localhost/ でアクセスできるようにはなりません。 外の世界から仮想マシン内のサーバにアクセスできるようにするための方法として、ポートフォワードがあります（ブリッジネットワークを構築する方法もあります）。 ポートフォワードの設定では、ホストマシンのあるポート番号を、特定の仮想マシンのポート番号にマッピングします。 ホストマシンの特定のポート番号にアクセスがあったときに、ホストマシンが仮想マシンに対してリクエストを転送することで、間接的に仮想マシンへ接続されます。 LAN 上のマシン ----[port:10080]----&gt; ホスト ----[port:80]----&gt; 仮想マシン ポートフォワードを利用したネットワーク構成では、既存の物理 LAN 上の別のマシンからは、ホストマシンの IP アドレスしか見えません。 仮想マシンの存在は隠蔽されており、ホストマシンですべてのサービスが提供されているかのように見えます。 ポートフォワードの設定を行う Vagrantfile ファイルの中で、config.vm.network に forwarded_port を設定することで、ポートフォワードの設定を行うことができます。 下記は、仮想マシン内の HTTP (80) と HTTPS (443) のポートを、ホスト側のポート 10080 と 10443 にそれぞれマッピングする例です。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.network &#34;forwarded_port&#34;, guest: 80, host: 10080 # HTTP config.vm.network &#34;forwarded_port&#34;, guest: 443, host: 10443 # HTTPS end 設定を変更したら、仮想マシンをリロードして反映させます。 $ vagrant reload ... ==&gt; default: Forwarding ports... default: 80 (guest) =&gt; 10080 (host) (adapter 1) default: 443 (guest) =&gt; 10443 (host) (adapter 1) default: 22 (guest) =&gt; 2222 (host) (adapter 1) ... これで、Web ブラウザなどから http://localhost:10080/ にアクセスしたときに、仮想マシン内の Web サーバの 80 ポートに繋がるようになります（もちろん、仮想マシン側で nginx などの Web サーバを立ち上げておく必要があります）。 ポートフォワードの設定を確認する 現在動作している仮想マシンのポートフォワード設定は vagrant port コマンドで確認することができます。 $ vagrant port The forwarded ports for the machine are listed below. Please note that these values may differ from values configured in the Vagrantfile if the provider supports automatic port collision detection and resolution. 22 (guest) =&gt; 2222 (host) 80 (guest) =&gt; 10080 (host) 443 (guest) =&gt; 10443 (host) ポート番号 22 (SSH) はデフォルトでホスト側のポート 2222 にマッピングされています（これによって ssh vagrant@127.0.0.1 -p 2222 という接続が可能になっています）。 UDP トラフィックのフォワード config.vm.network &quot;forwarded_port&quot; のデフォルトの設定では、TCP プロトコルによるフォワード設定しか行われません。 UDP プロトコルのパケットも仮想マシンにフォワードしたい場合は、明示的に protocol: &quot;udp&quot; オプションを指定して設定する必要があります。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.network &#34;forwarded_port&#34;, guest: 2003, host: 12003, protocol: &#34;tcp&#34; config.vm.network &#34;forwarded_port&#34;, guest: 2003, host: 12003, protocol: &#34;udp&#34; end ポート番号のコンフリクトの自動解決 ポートフォワード設定を行って Vagrant の仮想マシンを立ち上げようとしたときに、ホスト側のポート番号がすでに使用されていてコンフリクトした場合、仮想マシンの立ち上げは失敗します。 $ vagrant reload ... Vagrant cannot forward the specified ports on this VM, since they would collide with some other application that is already listening on these ports. The forwarded port to 8080 is already in use on the host machine. ... 下記のように、auto_correct オプションを設定しておくと、ポート番号がコンフリクトした場合に、ホスト側で空いているポートを探して自動的にマッピングすることができます。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.network &#34;forwarded_port&#34;, guest: 80, host: 8080, auto_correct: true end 仮想マシンを立ち上げると、自動的にポート番号が割り当てられます。 $ vagrant up ==&gt; default: Checking if box &#39;hashicorp/precise64&#39; is up to date... ==&gt; default: Fixed port collision for 80 =&gt; 8080. Now on port 2200. ==&gt; default: Clearing any previously set network interfaces... ==&gt; default: Preparing network interfaces based on configuration... default: Adapter 1: nat ==&gt; default: Forwarding ports... default: 80 (guest) =&gt; 2200 (host) (adapter 1) default: 22 (guest) =&gt; 2222 (host) (adapter 1) ... ここでは、ホスト側のポート 8080 が開いていなかったため、自動的に 2200 が割り当てられています。 この自動割り当ての範囲は、デフォルトで 2200 から 2250 になっていますが、下記のように調整することもできます。 config.vm.usable_port_range = (10000..10050)"},{url:"/p/3wvm5wi/",title:"Vagrantメモ: Vagrant プラグインを vagrant up で自動的にインストールする",date:"2016-10-21T00:00:00+09:00",body:"Vagrantメモ: Vagrant プラグインを vagrant up で自動的にインストールする Vagrant のプラグインは下記のようにインストールすることができます。 $ vagrant plugin install ＜プラグイン名＞ Vagrantfile に下記のように記述しておけば、プラグインのインストールを、vagrant up 時に自動的に行うことができるようになります。 Vagrantfile def install_plugin(plugin) system &#34;vagrant plugin install #{plugin}&#34; unless Vagrant.has_plugin? plugin end # 必要なプラグインを指定 install_plugin(&#39;vagrant-proxyconf&#39;) Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; # ... end 実行例 $ vagrant up Installing the &#39;vagrant-proxyconf&#39; plugin. This can take a few minutes... Installed the plugin &#39;vagrant-proxyconf (1.5.2)&#39;! Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider..."},{url:"/p/ad8jegg/",title:"Vagrantメモ: ホストマシンと仮想マシンでファイルを共有する",date:"2016-10-21T00:00:00+09:00",body:"Vagrantメモ: ホストマシンと仮想マシンでファイルを共有する Vagrant ホスト側の Vagrantfile の置かれているディレクトリは、仮想マシン側からは、/vagrant というパスで参照することができます。 vagrant@precise64:~$ ls /vagrant Vagrantfile この性質を利用して、仮想マシン側で使用するシェルスクリプトを、ホスト側のエディタで編集するといったことが可能になります。"},{url:"/p/4qkuf64/",title:"Vagrantメモ: 仮想マシンでシェルスクリプトを実行する",date:"2016-10-21T00:00:00+09:00",body:"Vagrantメモ: 仮想マシンでシェルスクリプトを実行する Vagrant では、仮想マシンの作成時にシェルスクリプトを実行して、サーバ環境のセットアップを行うことができます。 下記のように、config.vm.provision でシェルスクリプトを指定しておくと、仮想マシン側で任意の処理を実行することができます。 外部のシェルスクリプトファイルを実行する Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.provision :shell, path: &#34;bootstrap.sh&#34; end シェルスクリプトは、Vagrantfile があるディレクトリと同じディレクトリに置きます。 bootstrap.sh apt-get update apt-get install -y nginx config.vm.provision で指定したシェルスクリプトは、仮想マシンの作成し直したときか、vagrant provision コマンドを実行したときに実行されます。 仮想マシンを作成し直すには、vagrant destroy と vagrant up の実行が必要なため時間がかかります。 テストで実行する場合は、vagrant provision コマンドを使用するとよいでしょう。 起動中の仮想マシンで provision 実行 $ vagrant provision Vagrantfile に埋め込んだシェルスクリプトを実行する 下記のようにすれば、仮想マシンで実行したいシェルスクリプトを Vagrantfile ファイル内に埋め込むことができます。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.vm.provision :shell, inline: $script end $script = &lt;&lt;END apt-get update apt-get install -y nginx END provision 実行 $ vagrant provision 詳細なコンフィギュレーションには Ansible を使うべし 上記のように、シェルスクリプトを利用してサーバ環境のセットアップを行うものよいのですが、シェルスクリプトは、あくまで仮想マシン作成時に一度だけ実行することを前提としています。 設定を少しずつ変更しながら環境を構築していきたい場合などは、Ansible や Chef などのツールを使用するのがオススメです。 Ansible や Chef には冪統性（べきとうせい）を保証する仕組みが備わっており、試行錯誤しながら最終的なコンフィギュレーションに近づけていくことができます。"},{url:"/p/jgcwrrg/",title:"Vagrantメモ: 仮想マシンのプロキシを設定する",date:"2016-10-21T00:00:00+09:00",body:"Vagrantメモ: 仮想マシンのプロキシを設定する Vagrant の仮想マシン側のプロキシ設定を行うには、vagrant-proxyconf プラグインを使用すると便利です。 vagrant-proxyconf によるプロキシ設定 Vagrant のプラグインは、vagrant plugin install で簡単にインストールすることができます。 vagrant-proxyconf プラグインのインストール $ vagrant plugin install vagrant-proxyconf Installing the &#39;vagrant-proxyconf&#39; plugin. This can take a few minutes... Installed the plugin &#39;vagrant-proxyconf (1.5.2)&#39;! あとは、Vagrantfile の中で下記のようにプロキシ設定を行います。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.proxy.http = &#34;http://proxy.example.com:8080&#34; config.proxy.https = &#34;http://proxy.example.com:8080&#34; config.proxy.no_proxy = &#34;localhost,127.0.0.1&#34; end すると、Vagrant 仮想マシンを立ち上げるときに、自動的に各アプリ用のプロキシが設定されます。 $ vagrant up ... ==&gt; default: Configuring proxy for Apt... ==&gt; default: Configuring proxy environment variables... これで、Vagrant 仮想マシンから apt-get コマンドなどを実行したときにプロキシ経由でアクセスするようになります。 ホスト側の環境変数 http_proxy の値で仮想マシンのプロキシを設定する Ruby では、環境変数の値を ENV で取得できるので、下記のようにすれば、ホスト側のプロキシ設定 (http_proxy) を、仮想マシン側のプロキシ設定にも反映することができます。 Vagrantfile Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; config.proxy.http = ENV[&#39;http_proxy&#39;] if ENV[&#39;http_proxy&#39;] config.proxy.https = ENV[&#39;https_proxy&#39;] if ENV[&#39;https_proxy&#39;] config.proxy.no_proxy = &#34;localhost,127.0.0.1&#34; end 連動させるのが好ましくない場合は、独自の環境変数 VAGRANT_VM_HTTP_PROXY などを定義するという運用にするのもよいでしょう。"},{url:"/p/ncmh8bj/",title:"Jenkins ジョブの設定 (config.xml) を確認する",date:"2016-10-20T00:00:00+09:00",body:"Jenkins ジョブの設定 (config.xml) を確認する 下記のようなアドレスにアクセスすると、そのジョブの設定情報 config.xml を確認することができます。 この情報は、Jenkins の REST API などを使用してジョブを作成するときに必要になります。 http://localhost:8080/job/＜ジョブ名＞/config.xml config.xml の例 &lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt; &lt;project&gt; &lt;description&gt;&lt;/description&gt; &lt;keepDependencies&gt;false&lt;/keepDependencies&gt; &lt;properties/&gt; &lt;scm class=&#34;hudson.scm.NullSCM&#34;/&gt; &lt;canRoam&gt;true&lt;/canRoam&gt; &lt;disabled&gt;false&lt;/disabled&gt; &lt;blockBuildWhenDownstreamBuilding&gt;false&lt;/blockBuildWhenDownstreamBuilding&gt; &lt;blockBuildWhenUpstreamBuilding&gt;false&lt;/blockBuildWhenUpstreamBuilding&gt; &lt;triggers/&gt; &lt;concurrentBuild&gt;false&lt;/concurrentBuild&gt; &lt;builders/&gt; &lt;publishers/&gt; &lt;buildWrappers/&gt; &lt;/project&gt;"},{url:"/p/4trtqtw/",title:"Vagrantメモ: Vagrant により仮想マシンを立ち上げる",date:"2016-10-19T00:00:00+09:00",body:"Vagrantメモ: Vagrant により仮想マシンを立ち上げる Vagrant は、仮想マシンの構成をするための情報として Vagrantfile というファイルを参照するので、まずはこのファイルを作成する必要があります。 Vagrantfile を生成する vagrant init コマンドで、Vagrantfile の雛形を生成することができます。 ここでは、HashiCorp の提供している Ubuntu 12.04 LTS 64-bit のイメージ (hashicorp/precise64) を使用するように指定しています。 $ vagrant init hashicorp/precise64 A `Vagrantfile` has been placed in this directory. You are now ready to `vagrant up` your first virtual environment! Please read the comments in the Vagrantfile as well as documentation on `vagrantup.com` for more information on using Vagrant. 仮想マシンのベースとなる OS イメージのことを box と呼びます。 デフォルトで使用可能な box は下記のようなものが用意されており、他の box は HashiCorp&rsquo;s Atlas で探すことができます。 ubuntu/trusty64: Ubuntu 14.04 LTS 64-bit (Trusty Tahr) hashicorp/precise64: Ubuntu 12.04 LTS 64-bit (Precise Pangolin) debian/jessie64: Vanilla Debian 8 (Jessie) centos/7: CentOS Linux 7 x86_64 vagrant init を実行すると、次のような Vagrantfile ファイルがカレントディレクトリに生成されます。 Vagrantfile のあるディレクトリが、Vagrant プロジェクトのルートとなります。 Vagrantfile（コメント群は省略） Vagrant.configure(&#34;2&#34;) do |config| config.vm.box = &#34;hashicorp/precise64&#34; end 仮想マシンを立ち上げる vagrant up コマンドを実行すると、Vagrantfile の記述に基いて、仮想マシンが構築されます。 $ vagrant up Bringing machine &#39;default&#39; up with &#39;virtualbox&#39; provider... ==&gt; default: Box &#39;hashicorp/precise64&#39; could not be found. Attempting to find and install... default: Box Provider: virtualbox default: Box Version: &gt;= 0 ==&gt; default: Loading metadata for box &#39;hashicorp/precise64&#39; default: URL: https://atlas.hashicorp.com/hashicorp/precise64 ==&gt; default: Adding box &#39;hashicorp/precise64&#39; (v1.1.0) for provider: virtualbox default: Downloading: https://atlas.hashicorp.com/hashicorp/boxes/precise64/versions/1.1.0/providers/virtualbox.box default: Progress: 7% (Rate: 132k/s, Estimated time remaining: 0:47:29)) ...（ダウンロードが終わるまでしばらく待つ）... ==&gt; default: Successfully added box &#39;hashicorp/precise64&#39; (v1.1.0) for &#39;virtualbox&#39;! ==&gt; default: Importing base box &#39;hashicorp/precise64&#39;... ==&gt; default: Matching MAC address for NAT networking... ==&gt; default: Checking if box &#39;hashicorp/precise64&#39; is up to date... ==&gt; default: Setting the name of the VM: vagrant_default_1476854130179_87997 ==&gt; default: Clearing any previously set network interfaces... ==&gt; default: Preparing network interfaces based on configuration... default: Adapter 1: nat ==&gt; default: Forwarding ports... default: 22 (guest) =&gt; 2222 (host) (adapter 1) ==&gt; default: Booting VM... ==&gt; default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127.0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it&#39;s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... ==&gt; default: Machine booted and ready! ==&gt; default: Checking for guest additions in VM... default: The guest additions on this VM do not match the installed version of default: VirtualBox! In most cases this is fine, but in rare cases it can default: prevent things such as shared folders from working properly. If you see default: shared folder errors, please make sure the guest additions within the default: virtual machine match the version of VirtualBox you have installed on default: your host and reload your VM. default: default: Guest Additions Version: 4.2.0 default: VirtualBox Version: 5.1 ==&gt; default: Mounting shared folders... default: /vagrant =&gt; D:/z/vagrant 仮想環境が何もインストールされていない場合は、下記のように「デフォルトの provider が見つかりません」といった類のエラーメッセージが表示されます。 VirtualBox などをインストールしましょう。 No usable default provider could be found for your system. 初回の vagrant up 実行時には、指定した OS の仮想マシンイメージがダウンロードされるため、しばらく時間がかかります。 ダウンロードが終わると、自動的に仮想マシンが立ち上がります。 仮想マシンが起動中かどうかは vagrant status コマンドで確認できます。 $ vagrant status Current machine states: default running (virtualbox) The VM is running. To stop this VM, you can run `vagrant halt` to shut it down forcefully, or you can run `vagrant suspend` to simply suspend the virtual machine. In either case, to restart it again, simply run `vagrant up`. 仮想マシンの停止と破棄 仮想マシンを停止したい場合は vagrant halt コマンドを実行します。 $ vagrant halt ==&gt; default: Attempting graceful shutdown of VM... 仮想マシンそのものを削除してしまいたい場合は、vagrant destroy コマンドを実行します。 $ vagrant destroy default: Are you sure you want to destroy the &#39;default&#39; VM? [y/N] ==&gt; default: Destroying VM and associated drives..."},{url:"/p/itd26k3/",title:"Vagrantメモ: Vagrant の仮想マシンに SSH で接続する",date:"2016-10-19T00:00:00+09:00",body:"Vagrantメモ: Vagrant の仮想マシンに SSH で接続する vagrant ssh コマンドで SSH 接続する vagrant up コマンドによる仮想マシンの起動が終わると、SSH でシェル接続が可能になります。 通常、SSH での接続にはサーバアドレスやユーザ ID の指定などが必要ですが、Vagrant によって立ち上げられた仮想マシンには、vagrant ssh コマンドを使用して簡単に SSH 接続できるようになっています。 $ vagrant ssh Welcome to Ubuntu 12.04 LTS (GNU/Linux 3.2.0-23-generic x86_64) * Documentation: https://help.ubuntu.com/ Welcome to your Vagrant-built virtual machine. Last login: Wed Oct 19 06:59:47 2016 from 10.0.2.2 vagrant@precise64:~$ vagrant ssh 経由で Vagrant の仮想マシンに接続するには、OpenSSH ベースの SSH クライアントがインストールされている必要があります。 SSH クライアントがインストールされていない場合のエラー $ vagrant ssh `ssh` executable not found in any directories in the %PATH% variable. OpenSSH ではない SSH クライアントがインストールされている場合（ここでは PuTTy）のエラー $ vagrant ssh The `ssh` executable found in the PATH is a PuTTY Link SSH client. Vagrant is only compatible with OpenSSH SSH clients. Please install an OpenSSH SSH client or manually SSH in using your existing client using the information below. Host: 127.0.0.1 Port: 2222 Username: vagrant Private key: D:/z/vagrant/.vagrant/machines/default/virtualbox/private_key Windows 用の OpenSSH クライアントは下記からダウンロードできます。 PowerShell/Win32-OpenSSH 通常の SSH クライアントで Vagrant 仮想マシンへ接続する vagrant ssh コマンド経由ではなく、直接 ssh コマンドを使用して仮想マシンに接続したい場合は、接続先のアドレスや、ユーザ名、Private キーなどの情報を知る必要があります。 これらの情報を調べるには、vagrant ssh-config を使用します。 $ vagrant ssh-config Host default HostName 127.0.0.1 ★ User vagrant ★ Port 2222 ★ UserKnownHostsFile /dev/null StrictHostKeyChecking no PasswordAuthentication no IdentityFile /Users/maku/sample/.vagrant/machines/default/virtualbox/private_key ★ IdentitiesOnly yes LogLevel FATAL 上記の★のついた部分が SSH 接続に必要な情報です。 これらの情報を ssh コマンドのパラメータで指定することで、Vagrant 仮想マシンに SSH 接続することができます。 $ ssh vagrant@127.0.0.1 -p 2222 -i /Users/maku/sample/.vagrant/machines/default/virtualbox/private_key Welcome to Ubuntu 12.04 LTS (GNU/Linux 3.2.0-23-generic x86_64) * Documentation: https://help.ubuntu.com/ Welcome to your Vagrant-built virtual machine. Last login: Wed Oct 19 06:54:45 2016 from 10.0.2.2 vagrant@precise64:~$"},{url:"/p/dwwvd7z/",title:"Vagrantメモ: Vagrant とは？ Vagrant をインストールする",date:"2016-10-18T00:00:00+09:00",body:"Vagrantメモ: Vagrant とは？ Vagrant をインストールする Vagrant とは？ Vagrant（ベイグラント）は、仮想環境の構築（OS 自体のインストールを含む）から設定までを自動で行うためのソフトウェアです。 Vagrantfile という設定ファイルを記述しておくと、同じ OS 環境、同じソフトウェアのインストールから設定を１ステップ (vagrant up) で再現できるようになります。 VirtualBox、VMware、Hyper-V などのローカルの仮想環境だけでなく、AWS (Amazon EC2) などのクラウド上の仮想環境もサポートします（Vagrant ではこれらを provider と呼びます）。共通の Vagrantfile を使用しつつ、立ち上げ先の環境だけを切り替えることができる (vagrant up --provider=aws) ので、VirtualBox から AWS へ乗り換えた場合なども、同じワークフローで環境構築できます（→ 運用エンジニア (Ops) のメリット）。 各開発者が同一のサーバ環境を構築できるようになり、開発環境の構築ミスによるエラーを防ぐことができます（→ 開発エンジニア (Dev) のメリット）。 環境構築の手順がコードによって管理されることにより、従来のソフトウェア開発においてソースコードに対して適用されていた、バージョン管理、レビュー、テストなどのプロセスを環境構築にも適用することができるようになります (→ IaaS: Infrastructure as a Code)。 Vagrant 自体の開発言語は Ruby です。 Vagrant をインストールする 各 OS 用の Vagrant パッケージは下記からダウンロードできます。 Vagrant by HashiCorp Vagrant 1.8.6 for Windows のパッケージサイズは 167 MB です。 正しくインストールできたかどうかは、下記のように確認できます。 D:\\&gt; vagrant --version Vagrant 1.8.6 仮想環境として、VirtualBox を使用する場合は、VirtualBox も別途インストールしておく必要があります。 AWS などのクラウド環境を使用する場合は、VirtualBox のインストールは必要ありません。 Oracle VM VirtualBox VirtualBox 5.1.8 for Windows のパッケージサイズは 117 MB です。"},{url:"/p/e8gyjh2/",title:"Amazon EC2 に Jenkins をインストールする",date:"2016-10-14T00:00:00+09:00",body:"Amazon EC2 に Jenkins をインストールする ここでは、EC2 インスタンスとして、Amazon Linux AMI (t2.micro) を選択した場合の Jenkins インストール方法を示します。 EC2 サーバへ Jenkins をインストールする EC2 インスタンスのコンソール上で下記のようにインストールできます（基本的に CentOS におけるセットアップ方法と同様です）。 システム全体の更新 $ sudo yum -y update OpenJDK 1.8 のインストール $ sudo yum install -y java-1.8.0-openjdk-devel.x86_64 $ sudo alternatives --set java /usr/lib/jvm/jre-1.8.0-openjdk.x86_64/bin/java yum でインストールできる JDK のバージョンは yum search openjdk-devel で確認できます。 alternatives コマンドでの切り替え先の JDK パスは、sudo alternatives --config java で確認できます（そこから数字を指定して選択することもできます）。 OpenJDK 1.8 だけ入っていればよいのであれば、先に yum remove java で OpenJDK 1.7 をアンインストールしちゃうって手もありです。 Jenkins のインストール $ sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo $ sudo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key $ sudo yum install jenkins Jenkins の起動と自動起動設定 $ sudo service jenkins start $ sudo chkconfig jenkins on インターネットから Jenkins への接続テスト Web サーバへのアクセスするときに指定する、インターネット側の IP アドレスは下記のように調べることができます（EC2 上で ifconfig を実行して表示されるアドレスは、ローカルアドレスですのでインターネット経由でのアクセスには使用できません）。 [ec2-user@ip-xxx]$ curl http://169.254.169.254/latest/meta-data/public-ipv4 54.214.194.23 あるいは、Amazon EC2 コンソール のサイト上で、インスタンスごとの Public IP アドレスを確認することもできます。 IP アドレスが分かったら、あとは Web ブラウザからアクセスするだけです。 http://54.214.194.23:8080/ アクセスできない場合は、EC2 のコンソールのセキュリティポリシーから、Jenkins 用のポート 8080 が解放されているかを確認してください。"},{url:"/p/2uxzo7h/",title:"Gradle のプロパティを環境変数 (ORG_GRADLE_PROJECT) で定義する",date:"2016-10-13T00:00:00+09:00",body:"Gradle のプロパティを環境変数 (ORG_GRADLE_PROJECT) で定義する 環境変数で Gradle プロジェクトのプロパティを設定する OS の環境変数として ORG_GRADLE_PROJECT_ というプレフィックスで始まる変数を定義しておくと、Gradle のビルドスクリプト内から、プロジェクトのプロパティとして参照できるようになります。 ユーザごとに異なる値（ユーザ ID やパスワード）を設定したいときに便利です。 下記の例では、Maven サーバ用のアクセス情報を示すプロパティ（MAVEN_USERNAME など）を設定しています。 ~/.bash_profile export ORG_GRADLE_PROJECT_MAVEN_URL=http://repo.mycompany.com/maven2 export ORG_GRADLE_PROJECT_MAVEN_USERNAME=xxx export ORG_GRADLE_PROJECT_MAVEN_PASSWORD=yyy あとは、下記のようにビルドスクリプトの中から簡単に参照することができます。 build.gradle repositories { maven { credentials { username MAVEN_USERNAME password MAVEN_PASSWORD } url MAVEN_URL } } プロパティが設定されているかどうか確認する 定義されていないプロパティを参照しようとするとエラーが発生します。 プロジェクトのプロパティが定義されているかどうかを調べるには、以下のように project.has メソッドを使用します（project. は省略可能です）。 if (!project.has(&#39;MAVEN_USERNAME&#39;)) { println &#39;ORG_GRADLE_PROJECT_MAVEN_USERNAME is not set&#39; } 環境変数 ORG_GRADLE_PROJECT_xxx で定義された値も、プロジェクトのプロパティとして参照できるようになるため、上記のようにして定義されているかどうかを確認することができます。 参考 ORG_GRADLE_PROJECT プレフィックスの環境変数について (The Build Environment - Gradle User Guide) Maven リポジトリの Credential 設定 (Dependency Management - Gradle User Guide)"},{url:"/p/yxha7mn/",title:"Groovy でパスワードなどをユーザに入力させる (readPassword)",date:"2016-10-13T00:00:00+09:00",body:"Groovy でパスワードなどをユーザに入力させる (readPassword) キーボードからのパスワード入力 Groovy を使用してユーザにパスワードを入力させるには、java.io.Console オブジェクトの readPassword メソッドを使用します。 sample.groovy def password = System.console().readPassword(&#39;Password? &#39;) println password 実行結果 $ groovy sample.groovy Password? （キーボードから abcabc と入力） abcabc"},{url:"/p/b962btg/",title:"Groovy のクロージャ",date:"2016-10-13T00:00:00+09:00",body:"Groovy のクロージャ クロージャの定義 Groovy におけるクロージャは、{ と } で囲まれた無名のコードブロックであり、通常のメソッドと同様にパラメータを受け取ったり、戻り値を返したりすることができます。 また、クロージャは変数への代入や、メソッドのパラメータとして渡すことが可能です。 下記は、渡されたパラメータを二乗するだけのクロージャの定義例です。 ここでは、定義したクロージャを square という名前の変数に代入し、後からメソッド呼び出しのように実行しています。 Closure square = { it * it } println square(3) 上記のように、クロージャに渡されるパラメータがひとつだけの場合は、デフォルトで it という名前で参照することができます（パラメータが渡されずに呼び出された場合、it の値は null になります）。 複数のパラメータを渡したい場合などは、下記のように定義します。 Closure add = { a, b -&gt; a + b } println add(1, 2) クロージャの利用例 クロージャは、コレクションに格納された要素に対する処理を記述する際などに使用されます。 次の例では、リストオブジェクトの each メソッドに対してクロージャを渡しています。 list = [1, 2, 3] list.each() { println it * 2 } Groovy ベースのビルドツールである Gradle では、コンフィギュレーションブロックの記述でクロージャが活用されています。 下記は、Gradle ビルドスクリプトの抜粋です。 dependencies { compile project(&#39;:mylib&#39;) } まるで設定ファイルの独自構文のような記述ですが、Groovy の処理系から見れば、実は dependencies というメソッドにクロージャを 1 つ渡しているだけです。"},{url:"/p/eezeq4g/",title:"ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast)",date:"2016-10-03T00:00:00+09:00",body:"ADB で Activity や Service を起動するインテントを投げる (am start/start-service/broadcast) 以下のコマンドは、adb shell でデバイスに接続した状態から実行することを想定しています。 接続と同時に実行するには、adb shell を先頭に追加して実行してください（例: adb shell am start ...）。 Activity（アクティビティ）を起動する シェル上で am start コマンドを実行すると、Intent を発生させて Activity を起動することができます。 am start &lt;INTENT&gt; Intent 引数（&lt;INTENT&gt; の部分）の指定方法は、Specification for INTENT arguments のページに詳しく記載されています。 具体的には、次のようなオプションの組み合わせで Intent を構成します。 -a &lt;ACTION&gt; 例: -a android.intent.action.VIEW -d &lt;DATA_URI&gt; 例: -d content://contacts/people/1 -t &lt;MIME_TYPE&gt; 例: -t image/png -c &lt;CATEGORY&gt; 例: -c android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 例: -n com.example.app/.ExampleActivity 必要に応じて、Bundle データを渡すこともできます。 --esn &lt;EXTRA_KEY&gt; （キーのみ） -e|--es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt; --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] --efa &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;[,&lt;EXTRA_FLOAT_VALUE...] 下記は、am start コマンドによる Activity の起動例です。 Activity のクラス名（コンポーネント名）を直接指定して起動する $ am start -n com.example.myapp/.MainActivity アクションを指定して起動する ブラウザを起動する（URL をハンドルするアプリを起動する） $ am start -a android.intent.action.VIEW http://google.com/ 電話を掛ける $ am start -a android.intent.action.CALL tel:123456789 着信音の選択画面を表示する am start -a android.intent.action.RINGTONE_PICKER HOME 画面を起動する $ am start -a android.intent.action.MAIN $ am start -a android.intent.action.MAIN -c android.intent.category.HOME サービス (Service) を起動・停止する サービスの起動 am start-service コマンドで任意のサービスを起動することができます。 例えば、アプリのパッケージ名 (com.example.myapp) とサービスのクラス名 (com.example.myapp.services.MyApp) が分かっているのであれば、次のようにサービスを起動できます。 ちなみに、-n オプションの後ろの部分を「コンポーネント名」と呼びます。 サービスを起動する $ adb shell am start-service -n com.example.myapp/.services.MyService Starting service: Intent { cmp=com.example.myapp/.services.MyService } Foreground サービスとして起動する場合は、am start-service の代わりに、am start-foreground-service を使用します。 $ adb shell am start-foreground-service -n com.example.myapp/.services.MyService Starting service: Intent { cmp=com.example.myapp/.services.MyService } サービスがちゃんと Foreground で動作しているかは、dumpsys コマンドで確認できます。 $ adb shell dumpsys activity s MyService | grep isForeground isForeground=true foregroundId=2 ... am start-service や am start-foreground-service コマンドでサービスを起動するには、そのサービスが AndroidManifext.xml で公開設定されている必要があります。 android:exported=&quot;false&quot; になっているサービスを起動しようとすると、Error: Requires permission not exported from uid 10077 といったエラーになります。 &lt;service android:name=&#34;com.example.myapp.services.MyService&#34; android:exported=&#34;true&#34; サービスの停止 サービスを停止するには、am stop-service コマンドを使います。 サービスを停止する $ adb shell am stop-service -n com.example.myapp/.services.MyService Stopping service: Intent { cmp=com.example.myapp/.services.MyService } Service stopped （おまけ）adb shell am help によるヘルプ表示の抜粋です。 start-service [--user &lt;USER_ID&gt; | current] &lt;INTENT&gt; Start a Service. Options are: --user &lt;USER_ID&gt; | current: Specify which user to run as; if not specified then run as the current user. start-foreground-service [--user &lt;USER_ID&gt; | current] &lt;INTENT&gt; Start a foreground Service. Options are: --user &lt;USER_ID&gt; | current: Specify which user to run as; if not specified then run as the current user. stop-service [--user &lt;USER_ID&gt; | current] &lt;INTENT&gt; Stop a Service. Options are: --user &lt;USER_ID&gt; | current: Specify which user to run as; if not specified then run as the current user. ブロードキャストインテント (Broadcast Intent) を投げる Intent をブロードキャストするには、am start の代わりに am broadcast を使用します。 $ am broadcast -a android.intent.action.XXX 下記は、端末の起動時にブロードキャストされる BOOT_COMPLETED インテントを明治的に投げる例です（root ユーザで実行）。 $ am broadcast -a android.intent.action.BOOT_COMPLETED （おまけ）adb shell am help によるヘルプ表示の抜粋です。 broadcast [--user &lt;USER_ID&gt; | all | current] [--receiver-permission &lt;PERMISSION&gt;] [--allow-background-activity-starts] [--async] &lt;INTENT&gt; Send a broadcast Intent. Options are: --user &lt;USER_ID&gt; | all | current: Specify which user to send to; if not specified then send to all users. --receiver-permission &lt;PERMISSION&gt;: Require receiver to hold permission. --allow-background-activity-starts: The receiver may start activities even if in the background. --async: Send without waiting for the completion of the receiver."},{url:"/p/2fnpkp9/",title:"Linuxメモ: curl で HTTP のレスポンスヘッダのみを確認する例",date:"2016-09-14T00:00:00+09:00",body:"Linuxメモ: curl で HTTP のレスポンスヘッダのみを確認する例 $ curl -s -D - localhost:8080 -o /dev/null HTTP/1.1 403 Forbidden Date: Wed, 14 Sep 2016 12:46:40 GMT Server: Jetty(8.y.z-SNAPSHOT) Expires: Thu, 01 Jan 1970 00:00:00 GMT Content-Type: text/html;charset=UTF-8 X-Hudson: 1.395 X-Jenkins: 1.565.1 X-Jenkins-Session: a53528f4 X-Hudson-CLI-Port: 41906 X-Jenkins-CLI-Port: 41906 X-Jenkins-CLI2-Port: 41906 X-You-Are-Authenticated-As: anonymous X-You-Are-In-Group: X-Required-Permission: hudson.model.Hudson.Read X-Permission-Implied-By: hudson.security.Permission.GenericRead X-Permission-Implied-By: hudson.model.Hudson.Administer Content-Length: 793 Vary: Accept-Encoding Proxy-Connection: Keep-Alive Connection: Keep-Alive Set-Cookie: JSESSIONID.e92abcec=jhmj6nosqyo51rcld8mgf20jc;Path=/"},{url:"/p/p6bu2pa/",title:"Gradle でディレクトリ内のファイルを ZIP 圧縮する (type: Zip)",date:"2016-09-09T00:00:00+09:00",body:"Gradle でディレクトリ内のファイルを ZIP 圧縮する (type: Zip) Gradle でディレクトリ内のファイルを ZIP 圧縮するには、次のように Zip 型のタスクを定義します。 task createArchive(type: Zip) { from &#39;docs/&#39; archiveName &#39;docs.zip&#39; } このように定義した createArchive タスクを実行すると、docs ディレクトリ内のファイルをまとめた docs.zip アーカイブファイルを作成できます。 $ gradlew createArchive"},{url:"/p/ofoencn/",title:"Gradle によるビルドのボトルネックを探す（プロファイリング） (--profile)",date:"2016-09-09T00:00:00+09:00",body:"Gradle によるビルドのボトルネックを探す（プロファイリング） (--profile) gradle コマンドを実行するときに、--profile オプションを追加して実行すると、ビルド中の各処理でどの程度時間がかかっているかのプロファイリング結果を出力してくれます。 プロファイリング結果は、build/reports/profile ディレクトリ以下に次のような HTML ファイルとして出力されます。 図: build/reports/profile/profile-2016-09-09-11-44-54.html Gradle によるビルドがあまりにも遅いと感じたら、このプロファイリング機能を使ってボトルネックを探るとよいです。"},{url:"/p/o46hp5y/",title:"Android Gradleメモ: Lint エラーが発生した場合もビルドを継続する (abortOnError)",date:"2016-09-07T00:00:00+09:00",body:"Android Gradleメモ: Lint エラーが発生した場合もビルドを継続する (abortOnError) Android Lint による静的解析がエラーになった場合でも、Gradle によるビルド処理を継続するには、対象プロジェクトの build.gradle で下記のように設定します。 build.gradle android { lintOptions { abortOnError false } } マルチプロジェクト構成になっている場合は、トップレベルの build.gradle ファイルの中で、下記のように記述しておけば、サブプロジェクトすべてに対して設定を行うことができます。 build.gradle（トップレベル） subprojects { afterEvaluate { project -&gt; if (project.hasProperty(&#39;android&#39;)) { project.android.lintOptions.abortOnError false } } }"},{url:"/p/n2rd4bp/",title:"Groovy スクリプトで Jenkins サーバを制御する",date:"2016-08-23T00:00:00+09:00",body:"Groovy スクリプトで Jenkins サーバを制御する Jenkins の API Jenkins CLI の groovy コマンドを使用すると、Groovy スクリプトを使って Jenkins サーバの制御を行えるようになります。 下記の Jenkins API を自由に扱うことができるので、ほとんどどのような処理もスクリプトで自動化することができます。 Jenkins Javadoc Jenkins CLI で Groovy スクリプトを実行する まずは、下記の記事を参考にして、Jenkins CLI コマンドを実行できるようにしておく必要があります。 Jenkins CLI を使ってコマンドラインから Jenkins を操作する Jenkins CLI が使用できるようになったら、groovy コマンドで実行したい Groovy スクリプトを指定すれば OK です。 $ java -jar jenkins-cli.jar -s http://localhost:8080 groovy sample.groovy 下記のサンプルスクリプトは、Jenkins のインストールされているディレクトリから再帰的にすべてのファイルを検索し、config.xml というファイルが見つかったときに、その絶対パスを表示しています。 sample.groovy root = jenkins.model.Jenkins.instance.getRootDir() println &#34;Seach files in ${root.getPath()} ...&#34; root.eachFileRecurse { file -&gt; if (file.getName() == &#39;config.xml&#39;) { println file.getPath() } } ちなみに、Groovy の == 演算子は equals() による比較として扱われるので、上記のように文字列比較も == 演算子で行えます。 実行例 C:\\&gt; java -jar jenkins-cli.jar -s http://localhost:8080 groovy sample.groovy Search files in C:\\app\\Jenkins ... C:\\app\\Jenkins\\config.xml C:\\app\\Jenkins\\jobs\\test-job\\config.xml C:\\app\\Jenkins\\nodes\\mynode1\\config.xml C:\\app\\Jenkins\\users\\maku\\config.xml スクリプトコンソールから Groovy スクリプトを実行する 実は Jenkins CLI を使用しなくても、ブラウザ上で Groovy スクリプトを貼り付けて実行することもできます。 Jenkins のメニューから、Jenkins の管理 → スクリプトコンソール と辿って起動するか、下記のアドレスにアクセスすると、スクリプトコンソールの画面を表示できます。 http://localhost:8080/script ここに、任意の Groovy スクリプトを貼り付けて実行できます。 スクリプトを実行するには、「実行」ボタンを押すか、Ctrl + Enter というキーボードショートカットを利用します。"},{url:"/p/xpnasmv/",title:"Groovy スクリプトで Jenkins 上のすべての Job を制御する",date:"2016-08-23T00:00:00+09:00",body:"Groovy スクリプトで Jenkins 上のすべての Job を制御する すべてのジョブを列挙する 下記のサンプルコードは、Jenkins で定義されているすべてのジョブの情報を表示します。 スクリプトコンソールに張り付けて実行することができます。 sample.groovy jenkins.model.Jenkins.instance.items.each { job -&gt; println &#34;Name: ${job.name}&#34; println &#34;Class: ${job.class}&#34; println &#34;Root Dir: ${job.rootDir}&#34; println &#34;URL: ${job.url}&#34; println &#34;Absolute URL: ${job.absoluteUrl}&#34; println &#34;Description: ${job.description}&#34; if (job.lastSuccessfulBuild != null) { println &#34;Last successful time: ${job.lastSuccessfulBuild.timestamp.time}&#34; } println &#39;----&#39; } ループ中に参照可能な Job オブジェクトの詳細に関しては、下記の API ドキュメントを参照してください。 hudson.model.Job クラス 実行結果 Name: MySampleJob1 Class: class hudson.model.FreeStyleProject Root Dir: C:\\app\\Jenkins\\jobs\\MySampleJob1 URL: job/MySampleJob1/ Absolute URL: http://localhost:8080/job/MySampleJob1/ Description: despcription text Last successful time: Tue Aug 23 16:34:04 JST 2016 ---- Name: MySampleJob2 Class: class hudson.model.FreeStyleProject Root Dir: C:\\app\\Jenkins\\jobs\\MySampleJob2 URL: job/MySampleJob2/ Absolute URL: http://localhost:8080/job/MySampleJob2/ Description: despcription text ---- ジョブの設定を変更する 各ジョブの setter 系メソッドを使用すれば、スクリプトからジョブの設定を変更することができます。 下記の例では、すべてのジョブの説明 (Description) をまとめて変更しています。 modify-description.groovy import java.util.Calendar Calendar cal = Calendar.getInstance() jenkins.model.Jenkins.instance.items.each { job -&gt; job.setDescription(&#34;Updated at ${cal.getTime().toString()}&#34;) println &#34;Name: ${job.name}&#34; println &#34;Description: ${job.description}&#34; println &#39;----&#39; } 実行結果 Name: MySampleJob1 Description: Updated at Tue Aug 23 17:45:51 JST 2016 ---- Name: MySampleJob2 Description: Updated at Tue Aug 23 17:45:51 JST 2016 ---- すべてのジョブの名前を一括で変更してしまうこともできます（実行するときは慎重に）。 modify-job-names.groovy println &#34;Renaming all jobs ...&#34; count = 1 jenkins.model.Jenkins.instance.items.each { job -&gt; job.renameTo(&#34;SampleJob ${count++}&#34;) }"},{url:"/p/g4f45uo/",title:"Groovy スクリプトで Jenkins 上のすべてのスレーブを制御する",date:"2016-08-23T00:00:00+09:00",body:"Groovy スクリプトで Jenkins 上のすべてのスレーブを制御する 下記のサンプルでは、現在マスターサーバに登録されている Jenkins スレーブをループで処理しています。 ループ中は、Slave オブジェクトの情報を扱うことができます。 hudson.model.Slave クラス スレーブの登録情報を列挙する slave-info.groovy for (slave in jenkins.model.Jenkins.instance.slaves) { println &#34;Slave name: ${slave.name}&#34; println &#34;Slave class: ${slave.class}&#34; println &#34;Slave node description: ${slave.nodeDescription}&#34; println &#34;Slave root path: ${slave.rootPath}&#34; println &#34;Slave label: ${slave.labelString}&#34; println &#34;Slave num executors: ${slave.numExecutors}&#34; println &#39;----&#39; } 実行結果 Slave name: mynode1 Slave class: class hudson.slaves.DumbSlave Slave node description: xxx Slave URL: xxx Slave label: xxx Slave num executors: 1 --- ... スレーブとなっている PC がオンラインかどうか確認する slave-check-online.groovy import jenkins.model.Jenkins Jenkins.instance.slaves.each { boolean isOn = it.getComputer().isOnline(); println it.name + (isOn ? &#34;: ON&#34; : &#34;: OFF&#34;) } 実行結果 mynode1: ON mynode2: OFF mynode3: OFF"},{url:"/p/j3ujkhd/",title:"Jenkins CLI を使ってコマンドラインから Jenkins を操作する",date:"2016-08-23T00:00:00+09:00",body:"Jenkins CLI を使ってコマンドラインから Jenkins を操作する Jenkins CLI とは Jenkins CLI (Jenkins Command Line Interface) クライアントを使用すると、コマンドラインから Jenkins サーバを操作することができるようになります。 例えば、Job の設定変更や、ビルドのトリガなどをコマンドラインから行うことができます。 また、Groovy のスクリプトを流し込んで Jenkins サーバ上で実行することも行えるため、Jenkins に対して行う作業のほとんどを自動化することができるようになっています。 Jenkins CLI のインストール CLI の実体は、Jenkins サーバからダウンロードできる jenkins-cli.jar です。 このファイルは任意の Jenkins サーバからダウンロードできますが、一応バージョンの問題が発生しないように、操作対象としている Jenkins サーバからダウンロードするのがよいでしょう。 ローカルホストで Jenkins サーバを稼働しているのであれば、下記のアドレスからダウンロードできます。 http://localhost:8080/jnlpJars/jenkins-cli.jar Jenkins CLI を使ってみる Jenkins CLI は、下記のようなフォーマットで使用します。 $ java -jar jenkins-cli.jar -s &lt;Jenkinsサーバアドレス&gt; &lt;コマンド&gt; 下記は、Jenkins CLI を使ってログイン、ヘルプの表示、ログアウトを実行する例です。 Jenkins CLI の各種コマンドを実行するには、最初に login コマンドを使用して、Jenkins ユーザ名を指定してログインしておく必要があります。 $ java -jar jenkins-cli.jar -s http://localhost:8080 login --username yourname Password: （指定した Jenkins ユーザのパスワードを入力） $ java -jar jenkins-cli.jar -s http://localhost:8080 help （CLI コマンドのヘルプが表示される） $ java -jar jenkins-cli.jar -s http://localhost:8080 logout 接続時に Java の Exception が発生する場合は、Jenkins CLI のサイトでエラーメッセージを検索して対応しましょう。 Jenkins CLI を使いやすくする Jenkins CLI コマンドを実行するときは、jenkins-cli.jar ファイルを指定する必要があったり、Jenkins サーバのアドレスを指定する必要があったりして、そのままでは若干扱いにくいです。 下記のような方法で、Jenkins CLI を使いやすくすることができます。 環境変数 JENKINS_URL で Jenkins のアドレスを指定する方法 環境変数 JENKINS_URL に Jenkins サーバのアドレス（http://localhost:8080 など）を指定しておくことで、Jenkins CLI を使用するときに毎回 -s オプションでアドレスを指定する必要がなくなります。 ~/.bash_profile export JENKINS_URL=http://localhost:8080 専用のコマンドを作ってしまう方法 下記は Windows のバッチファイルの例ですが、このファイルと jenkins-cli.jar ファイルを同じディレクトリに入れて、そのディレクトリに PATH を通しておけば、どのディレクトリからでも Jenkins CLI コマンドを実行できるようになります。 jenkins-cli-localhost.cmd @echo off set jarfile=&#34;%~dp0%jenkins-cli.jar&#34; set url=&#34;http://localhost:8080&#34; java -jar %jarfile% -s %url% %* ここでは、ローカルホスト上の Jenkins サーバにアクセスするためのコマンドだということを示すために、ファイル名に -localhost というサフィックスを付けています。 このような命名規則にしておけば、複数の Jenkins サーバを扱っている場合にも対応できます。 使用例 C:\\&gt; jenkins-cli-localhost login --username yourname C:\\&gt; jenkins-cli-localhost help C:\\&gt; jenkins-cli-localhost logout"},{url:"/p/dyas9zg/",title:"Gradle プラグインを作成する (2) JAR へのパッケージング",date:"2016-08-19T00:00:00+09:00",body:"Gradle プラグインを作成する (2) JAR へのパッケージング 配布可能な Gradle プラグインを作成する Gradle の独自プラグインを作成したら、最終的に JAR ファイルにパッケージングすることで、他のプロジェクトにも配布できるようになります。 配布用の Gradle プラグインをビルドするときにも Gradle を利用することができます。 プラグイン作成用のプロジェクトのディレクトリ構成は下記のような感じになります。 ここでは、com.mycompany.greeting という ID のプラグインを作成することとします（作成したプラグインは、apply plugin: 'com.mycompany.greeting' という形で適用できるようになります）。 GreetingPlugin +-- build.gradle +-- src/main/ +-- groovy/com/mycompany/greeting/GreetingPlugin.groovy +-- resources/META-INF/gradle-plugins/com.mycompany.greeting.properties 実装に使用する言語は Java でも構わないのですが、ここでは Groovy を使用しています。 ここからは、それぞれのファイルの内容を見ていきます。 ビルドスクリプト (build.gradle) ビルドスクリプトでは、プラグインの実装で Gradle パッケージを参照するための設定と、実装言語として Groovy を使用するための設定を行います。 build.gradle apply plugin: &#39;groovy&#39; dependencies { compile gradleApi() // org.gradle パッケージを使用するため compile localGroovy() // Groovy SDK を使用するため } プラグイン本体 (GreetingPlugin.groovy) この Groovy スクリプトで、Gradle プラグイン本体の実装を行います。 Plugin インタフェースを実装することで、このプラグインが適用されたときに実行される処理を定義します（ここでは、適用先のプロジェクトに hello タスクを追加しています）。 src/main/groovy/com/mycompany/greeting/GreetingPlugin.groovy package com.mycompany.greeting import org.gradle.api.Plugin import org.gradle.api.Project class GreetingPlugin implements Plugin&lt;Project&gt; { void apply(Project project) { println &#39;GreetingPlugin has been applied!&#39; project.task(&#39;hello&#39;) &lt;&lt; { println &#39;Hello GreetingPlugin!&#39; } } } プロパティファイル (com.mycompany.greeting.properties) このプロパティファイルには、Plugin インタフェースを実装したクラスの名前を指定しておきます。 プロパティファイルの名前は、プラグイン ID に合わせて付ける必要があります。 src/main/resources/META-INF/gradle-plugins/com.mycompany.greeting.properties implementation-class=com.mycompany.greeting.GreetingPlugin このプロパティファイル名から .properties 拡張子を除いた部分の名前を apply plugin のパラメータとして指定することになります。 一方で、implementation-class として指定するクラスの FQDN は、実はこのプラグイン ID とは異なっていても構いません。 独自プラグインのビルド プラグインの実装、および、プロパティファイルの記述が終わったら、下記のように assemble タスクを実行することでプラグインをビルドすることができます。 $ gradle assemble ビルドに成功すると、build/libs/GreetingPlugin.jar が生成されます。 この JAR ファイルを配布することで、他のプロジェクトからも独自プラグインを利用できるようになります。 ファイル名はプラグイン ID に合わせて、com.mycompany.greeting.jar としておいた方がよいかもしれませんね。 作成した Gradle プラグインを使用してみる 作成した com.mycompany.greeting プラグインを利用してみます。 ここでは、ローカルディレクトリにプラグインの JAR ファイルをコピーして参照します。 独自プラグインを利用する Sample プロジェクトのディレクトリ構成は、例えば下記のようになります。 Sample +-- build.gradle +-- plugins/GreetingPlugin.jar ビルドスクリプト (build.gradle) ビルドスクリプト内には、ローカルに配置したプラグインを参照するための dependencies コンフィギュレーションブロックを定義します。 プラグインの参照が行えるようになったら、apply メソッドを使用して、実際にプラグインを適用することができます。 build.gradle // 独自プラグインを参照するための設定 buildscript { dependencies { classpath files(&#39;plugins/GreetingPlugin.jar&#39;) } } // 独自プラグインを実際に適用する apply plugin: &#39;com.mycompany.greeting&#39; 実行してみる 独自プラグインを apply することによって、プロジェクトに hello タスクが定義されるので、そのタスクを実行してみます。 $ gradle -q hello GreetingPlugin has been applied! Hello GreetingPlugin! うまくいきました！ ٩(๑❛ᴗ❛๑)۶ わーぃ"},{url:"/p/w6ste5j/",title:"APK のパッケージ依存関係やクラス依存関係を調べる",date:"2016-08-17T00:00:00+09:00",body:"APK のパッケージ依存関係やクラス依存関係を調べる ここでは、jdeps と dex2jar を使って、APK ファイル内の依存関係を調査する方法を示します。 jdeps と dex2jar JDK 8 にはパッケージ依存関係やクラス依存関係を調べるための jdeps コマンドが標準搭載されました。 jdeps コマンド - Oracle Java Documentation これを使用すると、.class ファイル（あるいは .jar ファイル）を入力情報として、そこから参照しているクラスやパッケージの情報を調べることができるのですが、Android の APK としてビルドされたコードは .dex ファイルになっていますので、まずはこれを通常の .class 形式に変更してやる必要があります。 APK ファイル内の .dex を .class 形式に変換するには、dex2jar というツールを使用します。 dex2jar のダウンロード 上記から、たとえば dex-tools-2.1-20150601.060031-26.zip をダウンロードし、パスの通ったディレクトリに展開すればインストール完了です。 APK ファイルのパッケージ依存、クラス依存情報を調べる まず、d2j-dex2jar コマンドを使用して、APK ファイル内の .dex を .class 形式に変換します。 APK ファイルを unzip して取り出した .dex ファイルを変換することもできますが、下記のように直接 APK ファイルを .jar に変換してしまうのが手っ取り早いです。 apk から jar への変換 $ d2j-dex2jar app/build/outputs/apk/app-debug.apk -o app.jar dex2jar app/build/outputs/apk/app-debug.apk -&gt; app.jar これで .class ファイルの含まれた .jar ファイルが生成されるので、晴れて jdeps コマンドで依存関係を調べられるようになります。 $ jdeps app.jar ... com.example.myapp.function (app.jar) -&gt; android.content 見つかりません -&gt; android.content.pm 見つかりません -&gt; android.os 見つかりません -&gt; android.text 見つかりません -&gt; com.google.android.youtube.player app.jar -&gt; com.example.myapp.common.log app.jar -&gt; com.example.myapp.common.dialog app.jar -&gt; java.io -&gt; java.lang -&gt; java.lang.reflect -&gt; java.text -&gt; java.util ... デフォルトでは上記のようにパッケージ間の依存関係が出力されますが、-verbose:class オプションを指定すれば、クラスレベルで依存関係を出力することができます（大量に出力されます）。 $ jdeps -verbose:class app.jar ... com.example.myapp.function.LoggerService (app.jar) -&gt; android.app.Service 見つかりません -&gt; android.content.ContentResolver 見つかりません -&gt; android.content.Context 見つかりません -&gt; android.content.Intent 見つかりません -&gt; android.net.Uri 見つかりません -&gt; android.os.Handler 見つかりません -&gt; android.os.IBinder 見つかりません -&gt; com.example.myapp.common.log app.jar -&gt; com.example.myapp.common.text app.jar ... ちなみに上記の出力の「見つかりません」というのは、依存先のクラスが格納されたライブラリが見つからないことを示しています。 下記のように、外部 .jar ファイルに対してクラスパスを通してやれば、依存している .jar ファイルの名前も出力されるようになります（下記では、libs_ext というディレクトリに Shared library としての .jar ファイルが格納されているとします）。 # Windows の場合 $ jdeps -cp libs_ext/*;%ANDROID_HOME%/platforms/android-23/* app.jar # Linux の場合 $ jdeps -cp libs_ext/*:$ANDROID_HOME/platforms/android-23/* app.jar Android や Java のコアライブラリが提供しているクラスへの依存情報は不要だという場合は、下記のように -f オプションで必要のない依存情報をフィルタすることができます。 $ jdeps -f &#34;java.*|android.*|dalvik.*&#34; app.jar APK ファイルのメソッドレベルの依存関係を調べる 昔は Android の dexdeps というツールでメソッドレベルの依存関係を調べることができたのですが、このツールは multidex 構成の APK には対応していません（APK 内の１つの DEX ファイルしか解析対象にならない）。 Yasuenag さんの cfa というツールを使用すれば、.class ファイルを解析してメソッドレベルの依存関係を調べることができますので、こちらを利用するのがよいかもしれません。 クラスやメソッドの依存関係を調べる ─ まくまく Java ノート"},{url:"/p/negnqwf/",title:"Gradle プラグインを作成する (1) Plugin クラスの基本",date:"2016-08-16T00:00:00+09:00",body:"Gradle プラグインを作成する (1) Plugin クラスの基本 Gradle プラグイン作成の初歩 独自の Gradle プラグインを作成すると、下記のように各プロジェクトでプラグインを適用するだけで、そのプラグインが提供しているタスクを使えるようになります。 apply plugin: MyPlugin プラグインの実体は org.gradle.api.Plugin インタフェースを実装したクラスです。 上記のようにプラグインを適用すると、Plugin#apply() メソッドが呼び出されるため、例えば、その中でタスクを動的に追加するといった実装を行います。 下記の例では、MyPlugin というプラグイン実装を行っており、プラグインを適用したプロジェクトに対して動的に hello というタスクを追加しています。 単純化のためにプラグインの実装と、それ使用するコード (apply plugin: MyPlugin) を同じビルドスクリプト内に記述しています。 build.gradle // 独自プラグインの適用 apply plugin: MyPlugin // 独自プラグイン MyPlugin の実装 class MyPlugin implements Plugin&lt;Project&gt; { // プラグインを適用した時に呼び出される void apply(Project project) { println &#39;MyPlugin has been applied!&#39; // プラグインを適用したプロジェクトに hello タスクを追加 project.task(&#39;hello&#39;) &lt;&lt; { println &#39;Hello MyPlugin!&#39; } } } プラグインによって自動的に追加された hello タスクを実行してみます。 実行例 $ gradle -q hello MyPlugin has been applied! Hello MyPlugin! Gradle プラグインの実装を別ディレクトリで行う (buildSrc) Gradle には、buildSrc というディレクトリ以下に配置されたソースコード（から生成されたクラス）に対して、自動的にクラスパスを通してくれるという機能があります。 これを利用して、プラグインの実装クラスを buildSrc に配置すれば、プロジェクトのメインとなるビルドスクリプトと、プラグインのコードを分けて配置することができます。 buildSrc ディレクトリを使用する場合のディレクトリ構成は下記のようになります。 Sample +-- build.gradle +-- buildSrc/src/main/groovy/com/sample/MyPlugin.groovy メインのビルドスクリプトは、プラグインの実装が消えた分だけ非常にシンプルになります。 build.gradle apply plugin: com.sample.MyPlugin buildSrc ディレクトリでは、通常の Groovy スクリプトとしてプラグインのクラス実装を行います。 buildSrc/src/main/groovy/com/sample/MyPlugin.groovy package com.sample import org.gradle.api.Plugin import org.gradle.api.Project class MyPlugin implements Plugin&lt;Project&gt; { void apply(Project project) { project.task(&#39;hello&#39;) &lt;&lt; { println &#39;Hello MyPlugin!&#39; } } } 実行例 $ gradle -q hello Hello MyPlugin! ☝️ コラム buildSrc ディレクトリに置かれたソースコードに対しては、内部的には下記のような設定がデフォルトで適用されています。 なので、Groovy スクリプトがビルドできるし、その中で org.gradle.api パッケージなどにアクセスできるようになっています。 apply plugin: &#39;groovy&#39; dependencies { compile gradleApi() // org.gradle.api へアクセスできるようにする compile localGroovy() // Groovy SDK を使えるようにする }"},{url:"/p/pneeb8x/",title:"Android Gradleメモ: APK ファイル名のサフィックスにバージョンを追加する",date:"2016-08-15T00:00:00+09:00",body:"Android Gradleメモ: APK ファイル名のサフィックスにバージョンを追加する Android の Application プロジェクトの build.gradle で、下記のように設定しておくと、build/outputs/apk 以下に生成される APK ファイルにバージョン番号を付けてくれるようになります（例: app-debug-1.0.0.apk）。 build.gradle apply plugin: &#39;com.android.application&#39; android { ... applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; def file = output.outputFile output.outputFile = new File(file.parent, file.name.replace(&#39;.apk&#39;, &#34;-${variant.versionName}.apk&#34;)) } } }"},{url:"/p/dpvyxy8/",title:"Linuxメモ: 実行中のシェルスクリプトがあるディレクトリに移動する",date:"2016-08-12T00:00:00+09:00",body:"Linuxメモ: 実行中のシェルスクリプトがあるディレクトリに移動する シェルスクリプト内の処理が、シェルスクリプト自体が置いてあるディレクトリをカレントディレクトリとすることを前提として記述されていると、他のディレクトリにいるときにそのスクリプトを実行することができなくなってしまいます。 そのような場合は、スクリプトの先頭で、そのスクリプトがあるディレクトリに移動するようにしておくと、どのディレクトリからでも実行できるスクリプトにすることができます。 下記は、dirname コマンドを利用してカレントディレクトリを移動する例です。 sample.sh #!/bin/bash cd `dirname $0` # スクリプトのあるディレクトリへ移動 # あとは好きな処理を記述していく chmod -R +r build/ シェルスクリプトは通常新しく起動したシェル内で実行されるため、このスクリプトを起動したシェルのカレントディレクトリが移動してしまうことはありません（source コマンドで起動した場合は例外）。"},{url:"/p/cf7eoyo/",title:"Node.jsメモ: Node.js がどのバージョンの V8 エンジンで動作しているか調べる",date:"2016-08-08T00:00:00+09:00",body:"Node.jsメモ: Node.js がどのバージョンの V8 エンジンで動作しているか調べる node コマンドを実行したときにどのバージョンの V8 エンジンで動作するかを調べるには下記のようにします。 $ node -p process.versions.v8 5.0.71.52"},{url:"/p/9giv5yz/",title:"Android Gradleメモ: 外部から提供された AAR ファイルを利用する",date:"2016-08-04T00:00:00+09:00",body:"Android Gradleメモ: 外部から提供された AAR ファイルを利用する Android のライブラリプロジェクトをビルドすると、build/output/aar ディレクトリに AAR ファイルが作成されます。 この AAR ファイルを配布すれば、複数のアプリケーションからライブラリとして再利用することができます。 配布された AAR ファイルを利用してプロジェクトをビルドするためには、build.gradle に下記のように記述しておきます。 ここでは、aars ディレクトリに配布された mylib.aar ファイルを格納していると仮定します。 build.gradle repositories { flatDir { dir &#39;aars&#39; } } dependencies { compile(name: &#39;mylib&#39;, ext: &#39;aar&#39;) }"},{url:"/p/tmkh8p6/",title:"Gradle で独自の Maven リポジトリを使用する",date:"2016-08-03T00:00:00+09:00",body:"Gradle で独自の Maven リポジトリを使用する Maven リポジトリの指定方法の基本 Gradle はライブラリの依存関係などを処理するために、インターネット上の Maven リポジトリである JCenter や Maven Central などを簡単に利用できるようになっています。 どのリポジトリを使用するかは repositories ブロックで下記のように指定します。 build.gradle repositories { jcenter() // Maven リポジトリとして JCenter を使用する mavenCentral() // Maven リポジトリとして Maven Central を使用する } ローカルリポジトリを指定する ローカルディレクトリに Maven リポジトリを作成して、ビルド時にそこからライブラリを引っ張ってくるようにすることもできます。 ローカルの Maven リポジトリを参照するためには、repository ブロックで mavenLocal() を実行します。 build.gradle repositories { jcenter() // Maven リポジトリとして JCenter を使用する mavenLocal() // Maven リポジトリとしてローカルディレクトリを使用する } デフォルトでは、下記のディレクトリがローカルの Maven リポジトリとして参照されます。 Linux/MacOSX の場合: $HOME/.m2 Windows の場合: %UserProfile%\\.m2 リポジトリとするディレクトリを変更したい場合は、下記のように設定します。 repositories { maven { url &#39;../maven_repo&#39; } } リモートリポジトリを指定する 独自で立ち上げた Maven サーバを利用するように設定することもできます。 build.gradle repositories { maven { url &#39;http://example.com/repo&#39; credentials { username &#39;yourname&#39; password &#39;sd$49aYd&#39; } } } Maven サーバにアクセスするためのユーザ名やパスワードは、上記のように credentials で設定できますが、ビルドスクリプト内にパスワードを記述するのは避けたほうがよいでしょう。 例えば、別ファイル（gradle.properties など）に定義しておき、ビルドスクリプトから参照するようにします。 gradle.properties mavenUsername = yourname mavenPassword = sd$49aYd build.gradle repositories { maven { url &#39;http://example.com/repo&#39; credentials { username mavenUsername password mavenPassword } } } 他にも、環境変数にユーザ名やパスワードを設定しておく方法もあります。"},{url:"/p/52e5rvv/",title:"Android Gradleメモ: サブモジュールで使用する SDK バージョンを統一する",date:"2016-08-02T00:00:00+09:00",body:"Android Gradleメモ: サブモジュールで使用する SDK バージョンを統一する 問題 Android の Gradle ビルドスクリプト内では、最低限下記のように compileSdkVersion と buildToolsVersion を指定しておく必要があります。 build.gradle apply plugin: &#39;com.android.application&#39; android { compileSdkVersion 23 buildToolsVersion &#39;23.0.2&#39; } 単一のプロジェクト構成であればこの定義は一か所だけで済むのですが、複数のライブラリプロジェクト（サブモジュール）を含んだマルチプロジェクト構成になると、上記のようなバージョン指定を各サブプロジェクト内の build.gradle で行わなければいけません。 バージョンの指定が複数ファイルに散らばっていると、使用する SDK のバージョンを更新する場合に複数のファイルを更新しなければいけません。 多くの場合は、バージョンを統一したいと思いますので、このようにバラバラにバージョンを指定する方法は避けたいところです。 方法 (1) トップレベルの build.gradle の拡張パラメータで定義する Gradle スクリプトの中で、ext ブロックを使用すると、カスタムフィールドを定義することができます。 簡単に言えば、プロジェクトに対して設定できるグローバル変数のようなものです。 例えば、トップレベルの build.gradle の中で下記のように定義することができます。 ext { COMPILE_SDK_VERSION = 23 BUILD_TOOLS_VERSION = &#39;23.0.2&#39; } そして、このプロパティを各サブプロジェクトの build.gradle から参照するようにします。 android { compileSdkVersion rootProject.ext.COMPILE_SDK_VERSION buildToolsVersion rootProject.ext.BUILD_TOOLS_VERSION } こうしておけば、トップレベルの build.gradle の中で SDK バージョンを更新すれば、すべてのサブプロジェクトに反映されます。 方法 (2) トップレベルの build.gradle の中でサブプロジェクトの設定を行う もう少しがんばれば、トップレベルの build.gradle の中から、すべてのサブプロジェクトで使用する SDK バージョンを指定してしまうこともできます。 こうすれば、サブプロジェクトの build.gradle の中では SDK バージョンを指定する必要がなくなります。 build.gradle（トップレベル） subprojects { afterEvaluate { project -&gt; if (project.hasProperty(&#39;android&#39;)) { project.android.compileSdkVersion 23 project.android.buildToolsVersion &#39;23.0.2&#39; } } } 上記の例では、すべてのサブプロジェクトをループで処理しながら、Android 関連のモジュールであると判断できたときに SDK バージョンを設定するようにしています。 Android 関連のモジュールだと判断する基準としては、そのサブプロジェクトが android ブロックを持っているかで判断しています。 そのプロジェクトがプラグインとして com.android.application あるいは com.android.library を適用していれば、android ブロックが自動的に定義されているはずなので、その有無を確認すれば Android 関連のプロジェクトだと判断できるわけです。 注意点としては、先にサブプロジェクトの build.gradle が処理されるようにするために、afterEvaluate のループでサブプロジェクトをループ処理しているところです。 下記のように、直接 android ブロックを参照しようとすると、サブプロジェクト側でまだ android が定義されていないというエラーになってしまいます。 Android のプラグインが適用される前に android ブロックを参照してしまうからです。 // 間違った方法 subprojects { android { compileSdkVersion 23 buildToolsVersion &#39;23.0.2&#39; } }"},{url:"/p/ams6xga/",title:"Android Gradleメモ: Android アプリ用の Gradle スクリプトの基本",date:"2016-08-01T00:00:00+09:00",body:"Android Gradleメモ: Android アプリ用の Gradle スクリプトの基本 Android アプリケーションのビルドには Gradle が採用されています（2016 年現在、Ant によるビルドはサポート外となりました）。 Google が Gradle 用の Android プラグインを提供しており、このプラグインを各 Android プロジェクトの Gradle スクリプトから利用することで Android モジュールのビルドを行えるようになります。 Android アプリのディレクトリ構造 Android プロジェクトのディレクトリ構成は、およそ下記のような感じになります。 Android Studio によって新規作成する場合も、このようなディレクトリ構成で自動生成されます（正確には library1 や library2 といったサブプロジェクトのディレクトリは生成されませんが、ここではマルチプロジェクト構成の説明のために追加しています）。 MyApp/ +-- build.gradle（トップレベルのビルドスクリプト） +-- settings.gradle（ビルドすべきサブプロジェクトの一覧） +-- app/ （Application サブプロジェクト） | +-- build.gradle（サブプロジェクトのビルドスクリプト） | +-- build/（ビルド後の成果物） | +-- src/ | +-- main/（main ソースセット） | +-- AndroidManifest.xml | +-- java/ | +-- res/ +-- library1/（Library サブプロジェクト） | +-- build.gradle（サブプロジェクトのビルドスクリプト） +-- library2/（Library サブプロジェクト） +-- build.gradle（サブプロジェクトのビルドスクリプト） この例では、３つのサブプロジェクト (app, library1, library2) によって全体のビルドが構成されています。 トップレベルに配置するビルドスクリプト (build.gradle / settings.gradle) トップレベルのディレクトリには、build.gradle と settings.gradle を配置します。 build.gradle（トップレベル） // ビルドプロセス自体の設定 buildscript { repositories { jcenter() } dependencies { classpath &#39;com.android.tools.build:gradle:2.1.0&#39; } } トップレベルの build.gradle ファイルでは、Gradle によるビルドプロセス自体の環境設定や、サブプロジェクト全体に適用する設定などを行います。 まず、buildscript ブロックでは、ビルド環境の設定を行います。 ここでは、Maven リポジトリとしてメジャーな JCenter を使用することや、ビルド用にどのようなプラグインが必要であるかを指定します。 上記の例では、Android アプリケーションをビルドするために必要な Android プラグイン (for Gradle 2.1.0) を使用することを示しています。 // すべてのサブプロジェクトに適用する設定 allprojects { repositories { jcenter() } } さらに、上記のように allprojects ブロックを利用すると、すべてのプロジェクト（マルチプロジェクト構成の場合）に対して共通で適用する設定を記述しておくことができます。 ここまでは、Gradle にもともと備わっている機能を利用しているだけで、Android プラグインが提供している機能は一切利用していないことに注意してください。 Android プラグインが提供する機能は、各モジュール（サブプロジェクト）内の build.gradle で利用します（詳細は後述）。 settings.gradle（トップレベル） include &#39;:app&#39; include &#39;:library1&#39; include &#39;:library2&#39; Gradle はマルチプロジェクト構成のビルドをサポートしています。 全体がどのようなサブプロジェクトから構成されているかを Gradle に教えてあげるために記述するのが settings.gradle ファイルです。 上記のように記述しておくことで、Gradle はサブプロジェクトのビルドスクリプトとして app/build.gradle、library1/build.gradle、library2/build.gradle を読み込む必要があることを認識します。 サブプロジェクト内に配置するビルドスクリプト (build.gradle) ビルドスクリプト (build.gradle) はトップレベルにも１つ配置されていますが、各サブプロジェクト（モジュール）にも１つずつ配置する必要があります。 MyApp +-- build.gradle（トップレベル） +-- app/ | +-- build.gradle（サブプロジェクト用） +-- library1/ | +-- build.gradle（サブプロジェクト用） +-- library2/ +-- build.gradle（サブプロジェクト用） トップレベルの build.gradle では Gradle のビルド環境自体の設定を行っていましたが、各サブプロジェクト内の build.gradle では、Android の各モジュール（Application プロジェクトや Library プロジェクト）ごとのビルド設定を行います。 build.gradle（モジュールレベル） apply plugin: &#39;com.android.application&#39; // 通常のアプリプロジェクトの場合 apply plugin: &#39;com.android.library&#39; // ライブラリプロジェクトの場合 各サブプロジェクトにおけるビルドスクリプトの中では、Android プラグインを適用し、その機能を利用して Android モジュール用のビルド設定を行っていきます。 下記のように記述すると Android プラグインを適用できるのですが、Application プロジェクトの場合と Library プロジェクトの場合では指定方法が異なっているため、どちらか一方だけを指定する必要があります。 上記のいずれかの方法で Android プラグインを適用すると、内部で自動的に android ブロックが定義されるので、そのブロックの中で Android プロジェクト用のビルド設定を行っていきます。 最低限、下記のように、ビルドに使用する SDK バージョンなどを設定しておく必要があります。 apply plugin: &#39;com.android.application&#39; android { compileSdkVersion 23 buildToolsVersion &#34;23.0.2&#34; } compileSdkVersion Android モジュールをコンパイルするときに使用する API バージョンを指定します。 buildToolsVersion 使用する Android SDK（ビルドツール）のバージョンを指定します。ここで指定するバージョンの Android SDK を、SDK Manager を使ってあらかじめインストールしておく必要があります。通常は最新バージョンを指定すればよいですが、このバージョンを変更することによって Android Lint による警告方法が変わったり、Android ツールチェインの処理に微妙な変化が出てきます。 android ブロックには、これまで AndroidManifest.xml で指定していたアプリの基本情報を記述しておくこともできます。 build.gradle 側で記述することで、より柔軟な構成が可能になっています。 build.gradle ... android { ... defaultConfig { applicationId &#34;com.example.myapp&#34; minSdkVersion 22 targetSdkVersion 23 versionCode 1 versionName &#34;1.0.0&#34; testApplicationId &#34;com.example.myapp.test&#34; testInstrumentationRunner &#34;android.test.InstrumentationTestRunner&#34; } } applicationId Google Play などで配信するときの識別子となるアプリケーションのパッケージ名 (ID) です。 AndroidManifest.xml ではなく、build.gradle でパッケージ名を指定することによって、ビルド時に動的にパッケージ名を決定することができます。 例えば、アプリケーションの無料バージョンと有料バージョンを Google Play で分けて配信したいということがあるかもしれません。 そのような場合は、それぞれのアプリケーション (APK) に異なるパッケージ名を割り当てる必要があるのですが、Android プラグインの product flavor という仕組みを利用することで、異なるパッケージ名の APK（com.example.myapp.free など）を簡単に生成し分けることができます。 一方で、Java のソースコード（R.java など）からは、相変わらず AndroidManifest.xml の方で指定した package 名が参照されることに注意してください（実装コードの中では Java のパッケージ名がころころ変わっては困るからです）。 minSdkVersion / targetSdkVersion AndroidManifest.xml の &lt;uses-sdk&gt; 要素で指定していたものと同様です。 minSdkVersion は、最低限この API Level をサポートした Android デバイス上で動作することを意味します。 targetSdkVersion は、実際のテストをこの API Level で動作させて確認したことを意味します。 これらのパラメータを build.gradle 側で指定しておくことにより、AndroidManifest.xml 側で指定されている値よりも優先的に使用されるようになります（正確にはビルド時に内部的にその値に上書きされます）。build.gradle 側に指定されている項目については、AndroidManifest.xml 側に記述しておく必要はありませんが、パッケージ名だけは相変わらず AndroidManifest.xml の &lt;manifest&gt; 要素の package 属性で記述しておく必要があります。applicationId はあくまで APK 自体の識別情報として扱われるもので、実装時の Java パッケージ名とは関係がありません。 サブプロジェクト内の build.gradle の dependencies ブロックでは、そのモジュールをビルドするのに必要な依存モジュールを列挙します。 dependencies ブロックは、もともと Gradle が提供している機能のため、android ブロックの外で定義することに注意してください。 dependencies { compile &#39;com.android.support:multidex:1.0.1&#39; // Maven リポジトリからの取得 compile project(&#39;:library1&#39;) compile project(&#39;:library2&#39;) compile fileTree(dir: &#34;$rootDir/lib&#34;, include: [&#39;*.jar&#39;]) // Static JAR provided fileTree(dir: &#34;$rootDir/libs_ext&#34;, include: &#39;shared.jar&#39;) // Shared JAR } ここには、依存する Library プロジェクト（別のサブプロジェクト）や、外部から提供されている JAR ファイルへの依存情報を記述します。 ローカルに配置した JAR ファイルへの依存を指定することもできますし、Maven リポジトリで提供されている JAR ファイルへの依存を指定することもできます。 APK ファイルに組み込むモジュールは compile のパラメータで指定しますが、ビルド時に参照するだけでよい JAR ファイルは provided のパラメータで指定します（デバイス側で提供される Shared JAR ライブラリを使用する場合など）。 Android プラグインによって提供されるタスク Android プラグインは、APK をビルドするためのタスクや、テストを実行するためのタスクを提供しています。 例えば下記のようなタスクを利用することができます。 assembleDebug &hellip; デバッグビルドによって APK ファイルを作成 installDebug &hellip; 物理デバイスやエミュレータに APK をインストール check &hellip; 物理デバイスやエミュレータでテストを実行 build &hellip; assemble と check タスクの両方を実行 例えば、APK をデバッグビルドする場合は下記のように実行することになります。 $ gradle assembleDebug ビルド結果の APK は、app/build/outputs/apk/app-debug.apk として出力されます。"},{url:"/p/xtzsj3m/",title:"Android Gradleメモ: BuildConfig クラスでアプリの動作を切り替える",date:"2016-08-01T00:00:00+09:00",body:"Android Gradleメモ: BuildConfig クラスでアプリの動作を切り替える Android SDK のバージョン 17 以降では、ビルド時に自動的に BuildConfig というクラスが生成されるようになっています。 このクラスはビルド設定に応じた定数フィールドを提供しており、これを利用すると、ビルドタイプが debug のときのみデバッグログを出力するといったことが行えます 。 if (BuildConfig.DEBUG) { Log.d(TAG, &#34;Important data is missing!&#34;); } Gradle のビルドスクリプトで、この BuildConfig クラスに独自の定数フィールドを追加することも可能です。 下記の例では、ビルドタイプごとに BuildConfig.ACCESS_LOG 定数と、BuildConfig.WEBAPI_URL 定数を定義しています（ここではビルドタイプごとに設定していますが、Product Flavor を含むすべての Build Variants で自由に設定することができます）。 build.gradle android { ... buildTypes { debug { buildConfigField &#39;boolean&#39;, &#39;ACCESS_LOG&#39;, &#39;false&#39; buildConfigField &#39;String&#39;, &#39;WEBAPI_URL&#39;, &#39;&#34;http://dev.example.com/api/&#34;&#39; } release { buildConfigField &#39;boolean&#39;, &#39;ACCESS_LOG&#39;, &#39;true&#39; buildConfigField &#39;String&#39;, &#39;WEBAPI_URL&#39;, &#39;&#34;http://example.com/api/&#34;&#39; } } }"},{url:"/p/7vwoyht/",title:"モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし）",date:"2016-07-31T00:00:00+09:00",body:"モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし） モバイルファーストで Web サイトを作成するには、メディアクエリで max-width は使用せずに、min-width を使用するようにしましょう。 そうすると、デフォルトのスタイルが小さい画面用のスタイルとして適用されるため、モバイル画面でどのように表示されるかを先に考えることができます。 画面が広いときと狭い時のレイアウトを切り替える メディアクエリ (@media) を使用すると、画面幅に応じたレイアウトを行うことができます。 例えば、画面幅が広いとき（PC 画面など）のみ blockquote 要素の左マージンを大きくしたい場合は、次のような 2 通りの方法が考えられます。 ここでは、640px を切り替えの基準としています。 方法1. 広い画面をデフォルトのスタイルとする /* デフォルトのスタイル（画面が広いとき） */ blockquote { margin-left: 1em; } /* 639px 以下のスタイル（画面が狭いとき） */ @media (max-width: 639px) { blockquote { margin-left: 0; } } 方法2. 狭い画面をデフォルトのスタイルとする /* デフォルトのスタイル（画面が狭いとき） */ blockquote { margin-left: 0; } /* 640px 以上のスタイル（画面が広いとき） */ @media (min-width: 640px) { blockquote { margin-left: 1em; } } モバイルファーストで考えるのであれば、後者の min-width を使った指定方法をオススメ します。 メディアクエリ (@media) を使ったスタイル定義によって、デフォルトのスタイル定義を上書きするわけですが、デフォルトのスタイルの方を（画面が狭い）モバイルデバイス用に定義しておくことで、最初からモバイルデバイスでの表示を意識した CSS を構築していくことができます。 3 パターン以上の画面サイズに対応する場合 下記は、画面サイズを大・中・小の 3 パターンに分けてスタイル定義したい場合の例です。 ここでは、それぞれの横幅を次のように設定しています。 画面サイズ小: 599px 以下（デフォルト） 画面サイズ中: 600px 以上 画面サイズ大: 1200px 以上 /* デフォルトスタイル（画面サイズ小） */ blockquote { margin-left: 0; } /* 600px 以上のスタイル（画面サイズ中） */ @media (min-width: 600px) { blockquote { margin-left: 1em; background: blue; } } /* 1200px 以上のスタイル（画面サイズ大） */ @media (min-width: 1200px) { blockquote { margin-left: 2em; } } メディアクエリによるスタイル指定は排他的ではないため、複数のスタイル指定が組み合わされる可能性があることに注意してください。 例えば、現在のスクリーン幅が 1500px の場合は、min-width: 600px という条件も、min-width: 1200px という条件も満たすため、画面サイズ「小」「中」「大」のすべてのスタイル指定が適用されます。 ただし、同じプロパティ名が指定されている場合は、より後方で定義されたスタイルによって上書きされます。 上記の例の場合は、blockquote 要素に次のようなスタイルが適用されることになります。 margin-left: 2em; （画面サイズ大のスタイル定義が適用される） background: blue; （画面サイズ中のスタイル定義が適用される） 画面サイズ中 (600px ～ 1199px) のときのみ適用するスタイルを定義したい場合は、次のように、min-width と max-width を組み合わせて条件を設定します。 /* 600px 以上 1199px 以下のスタイル（画面サイズ中） */ @media (min-width: 600px) and (max-width: 1199px) { blockquote { background: blue; } } （おまけ）Sass の mixin によるメディアクエリの簡略化 通常の使い方でメディアクエリを使用すると、各要素のスタイル定義が散らばってしまって管理しにくくなってしまいます。 このような場合は、Sass の mixin 機能を使用すると、スタイル定義をまとめて記述できるようになります。 次の例では、スクリーンサイズ中と大の場合を示す mixin 定義を行っています（ここでは幅の単位に rem を使ってみました）。 sample.scss // スクリーンサイズ中 @mixin screen-size-medium { @media (min-width: 40rem) { @content; } } // スクリーンサイズ大 @mixin screen-size-large { @media (min-width: 60rem) { @content; } } これらの mixin を使用すると、blockquote の 3 種類のレイアウトを下記のようにまとめて記述できます。 blockquote { margin-left: 0; @include screen-size-medium { margin-left: 1em; } @include screen-size-large { margin-left: 2em; } }"},{url:"/p/yqpxbpa/",title:"Gradle のプロジェクトとタスクとアクションを理解する",date:"2016-07-29T00:00:00+09:00",body:"Gradle のプロジェクトとタスクとアクションを理解する Gradle によるビルドは、少なくとも 1 つ以上の 「プロジェクト」 から構成されます。 プロジェクトは 1 つ以上の 「タスク」 を含み、タスク単位でビルド処理を実行できるようになっています。 各プロジェクトには build.gradle というビルドスクリプトを配置し、その中でタスクを定義していきます。 ビルド構成 +-- Project (build.gradle) | +-- Task | | +-- Action | | +-- Action | +-- Task | +-- Action | +-- Action +-- Project (build.gradle) +-- Project (build.gradle) +-- ... Gradle にはプラグインの仕組みがあり、複数のプロジェクトで再利用可能なタスクをプラグインの形で配布することができるようになっています。 インターネット上で公開されているプラグインを利用すれば、自分のプロジェクトに便利なタスクを簡単に組み込んでいくことができます（静的解析用のタスクや、デプロイ用のタスクなどを簡単に追加できる）。 タスク間に依存関係 (Dependency) を設定しておくことで、あるタスクを実行する前に先行して実行しなければいけないタスクを自動的に実行するように制御できます。 各タスクは、実行ブロックの単位である 「アクション」 を 1 つ以上含んでいます。 タスクを実行すると、それらのアクションが順番に実行されていくことになります。 プロジェクト、タスク、アクションは、Gradle の処理系内部では、それぞれ Project オブジェクト、Task オブジェクト、Action オブジェクトとしてインスタンス化されます。 ビルドスクリプトを記述していく上で、このようなオブジェクトが作成されていることを意識することが必要になってきます。"},{url:"/p/9fapzbb/",title:"Node.jsメモ: Node.js 用モジュールの作り方（require でロード可能な Node モジュールを作成する）",date:"2016-07-19T00:00:00+09:00",body:"Node.jsメモ: Node.js 用モジュールの作り方（require でロード可能な Node モジュールを作成する） Node モジュール作成の基本 Node.js では、.js ファイルをモジュールとして扱うことができます（配布用に package.json が用意されたものは、特に「パッケージ」と呼ばれます）。 作成したモジュールは下記のように require() を使用して読み込むことができます。 var mod = require(&#39;./mymodule.js&#39;); // .js は省略可能 mod.foo(1, 2); Node モジュールで公開するプロパティや関数は、以下のいずれかの方法で設定します。 exports の各プロパティに設定する方法 module.exports 自体に任意のオブジェクトを代入する方法 (1) exports のプロパティとして公開プロパティを設定する方法 exportsオブジェクト（実際は module.exports のエイリアス）のプロパティとして設定したものが require したクライアント側からアクセスできるようになります。 逆に、exports のプロパティに設定されていない変数や関数は、ファイル内にスコープが限定されます。 下記の例では、exports のプロパティ経由で、name 変数、add 関数を公開しています。 mymodule.js（Node モジュール） // 公開される変数や関数 exports.name = &#39;magu&#39;; exports.add = function(a, b) { return privFunc(a, b); } // 非公開の変数や関数 var secret = 100; function privFunc(a, b) { return a + b + secret; } この Node モジュールは、以下のように require() 関数でロードして使用します。 同じディレクトリに置いたモジュールは、プレフィックスに ./ を付けた相対パスで指定します（拡張子の .js は省略可能です）。 main.js（Node モジュールを使用する） var mymodule = require(&#39;./mymodule&#39;); // mymodule.js のロード console.log(mymodule.name); //=&gt; &#39;magu&#39; console.log(mymodule.add(1, 2)); //=&gt; 103 (2) module.exports に公開オブジェクトを設定する方法 1つのオブジェクトを公開する module.exports にオブジェクトを代入すると、require 時にそのオブジェクト自体が返されるようになります。 mymodule.js module.exports = { name: &#39;magu&#39;, add: function(a, b) { return a + b; } }; main.js var mymodule = require(&#39;./mymodule&#39;); // mymodule.js のロード console.log(mymodule.name); //=&gt; &#39;magu&#39; console.log(mymodule.add(1, 2)); //=&gt; 3 exports が module.exports のエイリアスなのであれば、exports = myObj; としても myObj を公開できそうですが、この方法は上手くいきません。exports は module.exports を参照する単なる変数であり、module.exports 自体に値を代入するには、あくまで module.exports = myObj; とする必要があります。 関数オブジェクトを公開する JavaScript では関数もオブジェクト（関数オブジェクト）なので、module.exports に関数を代入することができます。 この場合、require 時に関数オブジェクト自体が返されることになります。 greet.js module.exports = function(name) { console.log(&#39;Hello &#39; + name); } main.js var greet = require(&#39;./greet&#39;); // greet.js のロード greet(&#39;Joe&#39;); //=&gt; &#39;Hello Joe&#39; クラスを公開する クラスのコンストラクタ（関数オブジェクト）を、module.exports に代入してやれば、require 時にコンストラクタが返されるようになるので、クラスライブラリとして使用できる Node モジュールとして使用できるようになります。 下記は、Counter クラスを提供するモジュール (counter.js) の実装例です。 counter.js function Counter() { this.val = 0; } Counter.prototype.increment = function () { this.val += 1; }; Counter.prototype.getCount = function () { return this.val; }; // Counter コンストラクタを公開 module.exports = Counter; main.js var Counter = require(&#39;./counter.js&#39;); // コンストラクタが返される var c = new Counter(); c.increment(); console.log(c.getCount()); //=&gt; 1 c.increment(); console.log(c.getCount()); //=&gt; 2 c.increment(); console.log(c.getCount()); //=&gt; 3 フレームワーク的な構成にし、複数のクラスを同時に読み込む 一連のクラスを同時に扱う必要があるフレームワークのような機能を提供したい場合は、下記のように一度の require() 呼び出しで複数のクラスを参照できるようにしておくと便利です。 main.js var animal = require(&#39;./animal&#39;); var cat = new animal.Cat(); var dog = new animal.Dog(); cat.greet(); dog.greet(); 下記のような書き方もよく見ますね。 var Cat = require(&#39;./animal&#39;).Cat; var Dog = require(&#39;./animal&#39;).Dog; var cat = new Cat(); var dog = new Dog(); これを実現する簡単な方法は、下記のように animal.js の中で複数のコンストラクタを定義する方法です。 animal.js module.exports = { Cat: function () { /* Cat コンストラクタ実装 */ }, Dog: function () { /* Dog コンストラクタ実装 */ }, }; ただ、1 ファイル (animal.js) だけでプログラムを記述していくと、ファイルが肥大化してメンテナンス性が悪くなってしまいます。 ここでは、クラスごとにファイルを分割し、それらのファイルを animal ディレクトリ内で管理する方法を説明します。 ディレクトリ構成は下記のようにします。 - main.js （エントリポイント） - animal/ +-- index.js （ここから下記のファイルをすべて読み込む） +-- cat.js （Cat クラス） +-- dog.js （Dog クラス） Node.js の require() 関数は柔軟なファイル検索を行ってくれるため、 var animal = require(&#39;./animal&#39;); のように拡張子を省略してモジュール名を指定すると、./animal/index.js を検索してくれます（ただし、./animal.js というファイルが存在していれば、そちらが優先的に使用されます）。 この animal/index.js ファイルの中で、関連するクラスファイルをさらに require() で読み込むようにすれば、各クラスごとに別ファイルで管理できるようになります。 animal/index.js（Cat クラスと Dog クラスを同時に読み込む） module.exports = { Cat: require(&#39;./cat.js&#39;), Dog: require(&#39;./dog.js&#39;), }; animal/cat.js（Cat クラス） function Cat() { this.value = &#39;Meow!&#39;; } Cat.prototype.greet = function() { console.log(this.value); }; module.exports = Cat; // コンストラクタを公開 animal/dog.js（Dog クラス） function Dog() { this.value = &#39;Bow wow!&#39;; } Dog.prototype.greet = function() { console.log(this.value); }; module.exports = Dog; // コンストラクタを公開 このように cat.js と dog.js をファイルに分割したことにより、副次的な作用として、下記のように単一のクラスだけを読み込むこともできるようになります。 // Cat クラスだけをロード var Cat = require(&#39;./animal/cat&#39;);"},{url:"/p/jfqtfyn/",title:"ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts)",date:"2016-07-15T00:00:00+09:00",body:"ADB で特定のブロードキャストインテントをレシーブするアプリを列挙する (dumpsys activity broadcasts) dumpsys コマンドの activity broadcast サブコマンドを実行すると、ブロードキャストインテントをハンドルするように登録しているレシーバーの一覧を確認することができます。 $ adb shell dumpsys activity broadcasts 実行結果（抜粋） ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts) Registered Receivers: ... * ReceiverList{82bcce 603 com.android.systemui/10019/u0 remote:83b3dc9} app=603:com.android.systemui/u0a19 pid=603 uid=10019 user=0 Filter #0: BroadcastFilter{28557ef} Action: &#34;android.intent.action.TIME_TICK&#34; Action: &#34;android.intent.action.TIME_SET&#34; Action: &#34;android.intent.action.BATTERY_CHANGED&#34; ... AutoVerify=false Filter #1: BroadcastFilter{56b72fc} Action: &#34;android.intent.action.BOOT_COMPLETED&#34; mPriority=1000, mHasPartialTypes=false AutoVerify=false ... Registered Receivers のセクションには、アプリごとにどのようなフィルタでインテントを監視しているかが表示されます。 上記の例では、com.android.systemui アプリが、android.intent.action.TIME_TICK インテントなどのブロードキャストを監視していること示しています。 さらに下の方を見ると、Receiver Resolver Table というセクションがあります。 Receiver Resolver Table: ... Non-Data Actions: ... android.intent.action.BOOT_COMPLETED: BroadcastFilter{10f199e u0 ReceiverList{b1ecbd9 493 system/1000/u0 local:28f4620}} BroadcastFilter{989a5ad u0 ReceiverList{ae0d2c4 493 system/1000/u0 local:48b9d7}} BroadcastFilter{213887b u0 ReceiverList{758680a 493 system/1000/u0 local:513e075}} BroadcastFilter{56b72fc u0 ReceiverList{82bcce 603 com.android.systemui/10019/u0 remote:83b3dc9}} ... こちらは逆に、あるインテント (Action) をどのモジュールが監視しているかのマッピングを示しています。 この例では、BOOT_COMPLETED インテントを監視しているモジュールの一覧を表示しています。"},{url:"/p/v5dcz6f/",title:"CSS で画面サイズによって全体のレイアウトを変更する",date:"2016-07-15T00:00:00+09:00",body:"CSS で画面サイズによって全体のレイアウトを変更する CSS3 のメディアクエリをうまく使うと、Web ブラウザのウィンドウサイズによって、動的にレイアウトを変更することができます。 全体のレイアウト構成 ここでは、画面の幅によって、下記のように変化するレイアウトを考えてみます。　1000px 超: 固定幅の 2 段組レイアウト 1000px 以下: 可変幅の 2 段組レイアウト（リキッドレイアウト） 700px 以下: シングルカラム 今このページを PC のブラウザで見ているのであれば、下記のデモページを表示して、画面幅を変更してみてください。 画面幅に応じてレイアウトが自動的に変更されるはずです。 （別ページで表示） HTML 要素は下記のようにヘッダー、コンテンツ、サイドバー、フッターと、4 つの部分に分かれています。 &lt;div id=&#34;page&#34;&gt; &lt;header id=&#34;header&#34;&gt;Header&lt;/header&gt; &lt;article id=&#34;content&#34;&gt; &lt;div&gt;Content&lt;/div&gt; &lt;div&gt;Content&lt;/div&gt; &lt;div&gt;Content&lt;/div&gt; &lt;/article&gt; &lt;aside id=&#34;sidebar&#34;&gt; &lt;div&gt;Sidebar&lt;/div&gt; &lt;div&gt;Sidebar&lt;/div&gt; &lt;/aside&gt; &lt;footer id=&#34;footer&#34;&gt;Footer&lt;/footer&gt; &lt;/div&gt; 固定幅の 2 段組レイアウト（画面幅が広いとき） 表示幅が大きいときは、サイズ固定でページを表示します。 分かりやすいように、このレイアウトのときは、周りに青色で枠を表示しています。 #page { width: 980px; margin: 0 auto; border: blue 5px solid; } #header { background-color: lightblue; } #content { width: 680px; float: left; background-color: lightpink; } #sidebar { width: 300px; float: right; background-color: lightgreen; } #footer { clear: both; background-color: lightblue; } 可変幅の 2 段組レイアウト（画面幅が中サイズのとき） 幅が 1000px 以下になると、コンテンツ部分と、サイドバー部分を動的にサイズ変更して画面内に収まるように調整します。 このレイアウトのときは、周りに黄色で枠を表示します。 @media screen and (max-width: 1000px) { #page { width: 98%; border-color: yellow; } #content { width: 70%; } #sidebar { width: 30%; } } シングルカラムレイアウト（画面幅が狭いとき） 幅が 700px 以下（モバイル端末含む）になると、サイドバーは表示しきれないので、画面の下の方に移動させます。 コンテンツとサイドバーの幅を 100% で表示することによって、シングルカラム表示にしています。 このレイアウトのときは、周りに赤色で枠を表示します。 @media screen and (max-width: 700px) { #page { border-color: red; } #content { width: 100%; } #sidebar { width: 100%; } }"},{url:"/p/gorux24/",title:"ADB からキー入力やテキスト入力を行う (input text, input keyevent)",date:"2016-07-14T00:00:00+09:00",body:"ADB からキー入力やテキスト入力を行う (input text, input keyevent) ADB shell 上で input コマンドを使用すると、任意のキー入力やテキスト入力をエミュレートすることができます。 キー入力の例 (input keyevent) input keyevent コマンドを使用することで、単一のキー入力をエミュレートできます。 $ adb shell input keyevent ENTER # Enter キー $ adb shell input keyevent DPAD_CENTER # D-pad 上の決定キー $ adb shell input keyevent DPAD_RIGHT # 右キー $ adb shell input keyevent POWER # 電源キー $ adb shell input keyevent A # キーボードの A キー $ adb shell input keyevent TV # TV キー（Android TV 用） $ adb shell input keyevent NUMBER_ENTRY # 10-key キー（Android TV 用） $ adb shell input keyevent TV_TERRESTRIAL_DIGITAL # 地デジキー（Android TV 用） パラメータに指定できるキー名は、android.view.KeyEvent クラスに定義されている KEYCODE_XXX という定数の、KEYCODE_ というプレフィックスを除いたものです（参考: KeyEvent クラスの定数一覧）。 長押し input keyevent コマンドの --longpress オプションを指定すると、キーの長押しをエミュレートできます。 次の例では、ENTER キーの長押しを再現しています（ちょっとだけ長押しして、すぐ離す、という操作と同じ振る舞いになります）。 $ adb shell input keyevent --longpress ENTER （応用）sendevent を使う方法 よりローレベルなキー入力を再現したい場合は、sendevent コマンドを使った方法があります。 例えば、「キーを 5 秒間押しっぱなしにする」といった細かい動きを再現したいケースでは input keyevent は使えないので、sendevent を使ったシェルスクリプトなどを作ることになります。 getevent/sendevent で入力デバイスへの入力情報を取得する／入力を行う テキスト入力の例 (input text) テキストエリアなどにフォーカスが当たっているときに、連続したキーボード入力を行ってテキスト入力したいときは、input keyevent の代わりに input text を使用すると便利です。 スペースキーを入力する場合は、%s と指定する必要があります。 $ adb shell input text ABC%sDEF # &#34;ABC DEF&#34; というキーボード入力 $ adb shell input text aAbBcCdD # 大文字と小文字の区別も可能 キーボードやリモコン上のキーシーケンスを送り込んでいるだけなので、マルチバイト文字（日本語など）を直接入力することはできないようです。"},{url:"/p/ycwfweu/",title:"Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd)",date:"2016-07-13T00:00:00+09:00",body:"Systrace をコマンド化して簡単に実行できるようにする (systrace.cmd) （追記） Android 10 (Q) 以降では、より洗練された Perfetto を使ってパフォーマンス解析できます。 systrace コマンドの基本 Android - Systrace Android - Analyzing UI Performance with Systrace Android SDK に付属している systrace.py スクリプトを使用すると、Android デバイス全体のプロセスに関するプロファイリングを行うことができます（I/O アクセスや UI スレッドの状況など）。 systrace は Python スクリプトとして提供されているため、実行するときは下記のような感じでパラメータを指定して実行します。 例: 10 秒間の systrace 実行する $ cd android-sdk/platform-tools/systrace $ python systrace.py --time=10 -o trace.html sched gfx view wm プロファイルの取得が完了すると、プロファイル結果を表示するための HTML ファイルがカレントディレクトリに作成されます。 Capturing trace......................................................Done. Downloading trace....Done. wrote file://C:\\trace.html この HTML を Web ブラウザで開いてボトルネックの分析を行うことができます。 Web ブラウザ上で ? キーを押すと、使用できるショートカットキーの一覧を確認できます。 バッチファイル化 systrace コマンドを実行するときに、同じようなパラメータを毎回指定するのは面倒ですし、Windows 環境ですと PATH を通したりするのも若干面倒ですので、下記のようなバッチファイルを作成しておくと便利です。 systrace.cmd @echo off setlocal REM ======================================== REM 下記のパスは環境に応じて変更してください REM ======================================== set PYTHON=C:\\app\\Python27\\python.exe set SYSTRACE=%ANDROID_SDK%\\platform-tools\\systrace\\systrace.py @echo on %PYTHON% %SYSTRACE% --time=10 -o trace.html sched gfx view wm ここでは、Android SDK のディレクトリパスが ANDROID_SDK 環境変数に設定されていると想定しています。 環境変数の設定が面倒であれば、バッチファイル内の SYSTRACE 変数の内容を直接いじってしまっても OK です。 このバッチファイルを PATH の通ったディレクトリに置いておけば、どのディレクトリからでも systrace と打つだけでプロファイルを取得できるようになります。 C:\\&gt; systrace Capturing trace..............................................Done. （応用）バッチファイルにパラメータを追加する 下記は上記のバッチファイルをちょっと応用して、計測時間（秒）と、出力ファイル名をパラメータで指定できるようにしたものです。 systrace.cmd (2) @echo off setlocal REM ======================================== REM 下記のパスは環境に応じて変更してください REM ======================================== set PYTHON=C:\\app\\Python27\\python.exe set SYSTRACE=%ANDROID_SDK%\\platform-tools\\systrace\\systrace.py REM 第1パラメータは計測時間（デフォルトは 3 秒） set DURATION=%~1 if &#34;%DURATION%&#34;==&#34;&#34; (set DURATION=3) REM 第2パラメータは出力ファイル名（デフォルトは trace.html） set OUT_FILE=%~2 if &#34;%OUT_FILE%&#34;==&#34;&#34; (set OUT_FILE=trace.html) @echo on %PYTHON% %SYSTRACE% --time=%DURATION% -o %OUT_FILE% sched gfx view wm 例えば、5 秒間計測して、output.html というファイル名で保存するには次のように実行します。 C:\\&gt; systrace 5 output.html パラメータを省略した場合は、計測時間は 3 秒間、出力ファイル名は trace.html になるようにしています。 ちなみに、Windows バッチファイルのコマンドライン引数の扱い方は、下記の記事で詳しく説明しています。 バッチファイルでコマンドライン引数を扱う｜まくまくWindowsノート"},{url:"/p/xx3mb8e/",title:"Androidメモ: ADB で WakeLock を強制的に外す",date:"2016-07-07T00:00:00+09:00",body:"Androidメモ: ADB で WakeLock を強制的に外す /sys/power/wake_unlock に対して WakeLock 名を書き込むことで、その WakeLock を強制キャンセルすることができます。 現在取得されている WakeLock（カーネル・ウェイクロック）の一覧は下記のようにして調べることができます。 $ adb shell cat /sys/power/wake_lock PowerManagerService PowerManagerService.Display PowerManagerService.WakeLocks 上記で表示された WakeLock 名を参考にして、下記のように wake_unlock に書き込みます。 $ adb shell &#34;echo PowerManagerService &gt; /sys/power/wake_unlock&#34;"},{url:"/p/w6vao2e/",title:"Ruby で adb コマンドの出力結果を処理する",date:"2016-07-06T00:00:00+09:00",body:"Ruby で adb コマンドの出力結果を処理する 下記は、Ruby スクリプトの中から adb shell コマンドを呼び出して、その出力をハンドルするサンプルです。 ここで定義している adb_shell メソッドは、受け取ったコマンド文字列を adb shell の後ろにくっつけた形のコマンドを実行します（adb_shell('pm list packages') とすると、adb shell pm list packages が実行される）。 sample.rb # Executes the command via &#39;adb shell&#39;. # Obtained result will be passed to the specified block line by line. def adb_shell(command) result = `adb shell #{command}` result.gsub!(&#34;\\n\\n&#34;, &#34;\\n&#34;) # for Windows result.lines { |line| yield line } end # Test if $0 == __FILE__ adb_shell(&#39;pm list packages&#39;) do |line| puts &#39;==&gt; &#39; + line end end 実行結果 $ ruby sample.rb ==&gt; package:android ==&gt; package:android.autoinstalls.config.google.fugu ==&gt; package:com.android.backupconfirm ==&gt; package:com.android.bluetooth ==&gt; package:com.android.certinstaller ==&gt; package:com.android.defcontainer ==&gt; package:com.android.dreams.basic ... 応用として、パッケージ名部分だけを取り出したいのであれば、下記のように正規表現でフィルタしてしまうこともできますね。 adb_shell(&#39;pm list package&#39;) do |line| if line =~ /package:((\\w|.)+)/ puts &#39;==&gt; &#39; + $1 end end 実行結果 $ ruby sample.rb ==&gt; android ==&gt; android.autoinstalls.config.google.fugu ==&gt; com.android.backupconfirm ==&gt; com.android.bluetooth ==&gt; com.android.certinstaller ==&gt; com.android.defcontainer ==&gt; com.android.dreams.basic ..."},{url:"/p/qcvotb4/",title:"IE 8 でも HTML5 の header や footer 要素を使えるようにする",date:"2016-07-01T00:00:00+09:00",body:"IE 8 でも HTML5 の header や footer 要素を使えるようにする IE 8 では HTML5 の header 要素や footer 要素に適用したスタイルが反映されません。 この問題を解決するには、下記のコードを head セクションに追加します。 &lt;!--[if lte IE 8]&gt; &lt;script src=&#34;http://html5shiv.googlecode.com/svn/trunk/html5.js&#34;&gt;&lt;/script&gt; &lt;![endif]--&gt; 新しい要素に対応していないブラウザでは、それらの要素をインライン要素として表示してしまうので、下記のようにブロック要素として定義しておかないといけないのですが、上記のスクリプトはこの設定も行ってくれます。 article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section { display: block; }"},{url:"/p/ghtgxgw/",title:"APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages)",date:"2016-06-27T00:00:00+09:00",body:"APK のパッケージ名から APK ファイルのパスを調べる (pm path, pm list packages) 指定したパッケージの APK のファイルパスを調べる Android デバイスに adb shell で接続し、pm path &lt;パッケージ名&gt; コマンドを実行すると、指定したパッケージ名の APK ファイルが、デバイス上のどのパスに置かれているかを調べることができます。 com.example.myapp パッケージがどの APK ファイルか調べる $ adb shell pm path com.example.myapp package:/system/app/MyApp/MyApp.apk インストールされているすべての APK のファイルパスとパッケージ名を調べる インストールされている APK パッケージの一覧は、pm list packages コマンドで調べることができます。 インストール済みパッケージの一覧を表示 $ adb shell pm list packages package:com.google.android.apps.mediashell package:com.google.android.katniss package:com.android.providers.calendar package:com.android.tv.settings package:com.android.providers.media ... さらに、-f オプションを指定して実行すると、すべての APK に関するファイルパスとパッケージ名の対応情報を調べることができます。 sort コマンドと組み合わせて使用すると見やすくなります。 APK 名とパッケージ名の対応リスト $ adb shell pm list packages -f | sort package:/system/app/Backdrop/Backdrop.apk=com.google.android.backdrop package:/system/app/BasicDreams/BasicDreams.apk=com.android.dreams.basic package:/system/app/Bluetooth/Bluetooth.apk=com.android.bluetooth package:/system/app/KeyChain/KeyChain.apk=com.android.keychain ... システムにプリインストールされているアプリケーションだけを列挙したい場合は、-s オプションも同時に指定します。 プリインアプリのみ表示 $ adb shell pm list packages -f -s 逆に、ユーザがインストールしたサードパーティ製のアプリだけを列挙したい場合は、-3 オプションを指定します（/data/app 以下に格納されているのが分かります）。 3rd パーティアプリのみ表示 $ adb shell pm list packages -f -3 package:/data/app/com.hulu.livingroomplus.jp-1/base.apk=com.hulu.livingroomplus.jp package:/data/app/com.ted.android.tv-1/base.apk=com.ted.android.tv package:/data/app/tv.pluto.android-1/base.apk=tv.pluto.android"},{url:"/p/qy4ft3i/",title:"ソフトウェアの静的品質と動的品質",date:"2016-06-24T00:00:00+09:00",body:"ソフトウェアの静的品質と動的品質 ソフトウェアの品質を語るときは、動的品質の前に静的品質を重視せよというお話です。 静的品質と動的品質 ソフトウェアの品質には、大きく分けて静的品質と動的品質があると言えます。 静的品質: ソースコードそのものの品質 ソースコードの可読性は高いか？第三者が読んでも理解できるようになっているか？ メンテナンス性の高い設計になっているか？ 不具合の入りにくい設計（入れることが困難なアーキテクチャ）になっているか？ ドキュメンテーションコメントは簡潔かつ明確に記述されているか？ 動的品質: 実行時の品質 要求された機能が正しく動作するか？ 実行時のパフォーマンスはよいか？ユーザビリティは高いか？ ユニットテストはパスしているか？ 一般的に、ソフトウェア品質というと動的品質の方ばかりが注目されがちです。 なぜなら、多くの場合、ソフトウェアベンダの評価やプログラマ自身の評価が、納品したソフトウェアを実際に動作させたときの動的品質に基いて行われることが多いからです（不具合発生件数の少なさなど）。 ソースコード自体のメンテナンス性（静的品質）が低いということで評価が下げられることはあまりないのではないでしょうか？ ひどいケースになると、一度納品したソフトウェアのメンテナンスは、別のチームが引き継ぐことに決まっているからという理由で、将来のメンテナンス性を放棄したコーディングが行われることがあります。 リリースするソフトウェアが正しく動作することを考えてコーディングするのは当然ですが、プロの職業プログラマ（プロプログラマ？）であれば、将来的なメンテナンス性を意識したコーディングを行えなければいけません。 会社の立場から言えば、最終的にビジネスインパクトが大きくなるのは静的品質の方です。 なぜならば、ソースコード自体の保守性が低いと、将来的に設計変更するときに莫大なコスト（人件費）がかかり、不具合が入り込む可能性も上がってくるからです。そして、これは関連プロジェクトが存続する限り、永遠に続くコストとして積みあがっていきます。 行く末は、誰もそのソースコードをメンテナンスできない状態になり、一からすべてを作り直すことになります。 直近のリリースでうまく動作することだけを考慮するのであれば、当期の人件費は下げられるかもしれません。 ぐちゃぐちゃなスパゲッティコードを組んで、とりあえず動くように継ぎはぎを繰り返すことで完成させればよいのですから。 でも、長期的な視点でビジネスを考えていくのであれば、本当はソースコード自体のメンテナンス性（静的品質）を向上させることにこそ力を入れるべきなのです。 緊急度と重要度のマトリックスに強引に当てはめると下記のようなイメージでしょうか。 緊急度 「高」 緊急度 「低」 重要度 「高」 静的品質 重要度 「低」 動的品質 直近のリリースの重要度ももちろん高いと思いますが、ここでの重要度とは、あくまで長期的な視点でのビジネスインパクトが大きいという意味で捉えてください。 静的品質を高めるには ソフトウェアの静的品質を高めていくには、現在作成されているソースコード自体の品質が高いかどうかを判断できなければいけません。 そのために活用できるのが静的解析 (static analysis) ツールに分類される下記のようなツールです。 PMD Checkstyle FindBugs 各言語用 Lint Coverity（有料） Fortify（有料） これらのツールはソースコード上の不適切な設計（可読性が悪い、保守性が悪い、効率が悪い、危険な設計など）をレポートしてくれますが、検出の得意・不得意がありますので、可能な限り多くのツールを使用して静的解析を実施しておくべきです。 これらの解析はソースコードを修正するたびに頻繁に実行する必要がありますので、１ステップで実行できるように自動化してください（Java であれば Gradle、Ruby であれば rake といったビルド自動化のためのツールを使用します）。 複数メンバで開発を行っている場合は、中央リポジトリにソースコードをコミットする前に、警告件数が増加していないかを必ず確認するようにルールを徹底します。 中央サーバにコミットされたソースコードに関しては、CI サーバ（Jenkins など）などで自動的に静的解析を実行するようにし、警告件数が増えた場合にはメールによる通知を行うようにしておきましょう。 静的解析ツールを導入するのは早ければ早いほどよいです。 プロジェクトの終盤で急に導入すると、何千件もの警告が一気に出て面食らってやる気がそがれる可能性があります。 できれば初期の段階から解析を実施するようにして、警告件数は常に 0 件近くをキープするようにしましょう。 特に下記のような複雑度やコードサイズに関する警告は、早い段階からつぶしておかないと、どんどん症状が悪化していきます。一度こういった複雑度に関する警告が出ている状態になってしまうと、それ以上に複雑度が上がった際に警告数の増加という形で気付くことができなくなってしまうからです。 １ファイル、１クラスあたりの行数に関する警告（例: ExcessiveClassLength） １メソッドあたりの行数に関する警告（例: PMD の ExcessiveMethodLength） コードの複雑度に関する警告（例: PMD の CyclomaticComplexity、NPathComplexity） クラスの責務割り当てに関する警告（例: PMD の GodClass） そして、会社などの組織でソフトウェアを開発している場合に最も重要なのは、こういった解析に基いて計算されたソフトウェアの静的品質によって報酬の額を決めるということです。 静的品質によるビジネスインパクトが大きいことを考えれば、これはまっとうな考え方です。 メンテナンス性の悪いコードをコミットすることは、工数的な負債だけを将来にまわして楽をするということですから、その時点で報酬を減額しなければつじつまが合いません。 間違っても、その負債を引き継いだメンバから報酬をカットするようなことがあってはいけません（その負債を解消するために工数を取られ、目に付く新しい機能を実装する時間がなくなってしまうため、まるで成果が出ていないかのように見えてしまうものです）。 ソフトウェアの動的品質は発生した不具合の数などで計測することができますが、その時点での静的品質に関しては、上記のような静的解析ツールを導入しないと計測しにくいものです。 ソフトウェアの品質を高めていくためにも、その品質を正当に評価するためにも、ソフトウェア開発に静的解析ツールを導入するのは必須です。 ソフトウェアの静的品質を上げることによって、開発の効率は上がります。そして、それは実行時の動的品質を上げることにもつながります。 ソフトウェアはソースコードから作られているということを思い出しましょう。ソースコードそのものの品質が重要です。 まとめ ソフトウェア開発の効率化を進め、ビジネスをうまく回していくには、動的品質よりも静的品質を高めるという意識を持つことが必要です。 下記を実施しましょう。 静的解析ツールをできるだけ早い段階で導入する 静的解析の自動実行によりコード品質を監視する（常に 0 件程度を維持することが望ましい） 静的解析などによって求められた静的品質に応じて成果報酬を決める（実行時の品質が高いというだけで高評価を与えないこと）"},{url:"/p/2vpskj3/",title:"Enterprise Architect の図をシンプルにして Power Point に貼り付ける",date:"2016-06-21T00:00:00+09:00",body:"Enterprise Architect の図をシンプルにして Power Point に貼り付ける （下記は Enterprise Architect バージョン 12.0.1215 で確認しています） Enterprise Architect の図を Power Point に貼り付ける Enterprise Architect で作成したダイアグラムなどは、Power Point などにドラッグ＆ドロップで簡単に貼り付けることができます。 あるいは、メニューから画像ファイルに出力することもできます。 ダイアグラム → イメージをファイルに保存 (Ctrl + T) Power Point などに張り付けるのであれば、ベクタ形式の EMF などで出力しておくと、拡大表示した時にもきれに表示されるようになります。 シンプルなダイアグラム表示にする グラデーションを Off にする Enterprise Architect で作成するクラス図などの各要素は、デフォルトでグラデーションが入ったり、シンプルではありません。 下記のようにすると、グラデーションを Off にすることができます。 ツール → ユーザのオプション → ダイアグラム → グラデーションと背景 「要素の背景色」の「グラデーションの向き」を ＜なし＞ に設定 あるいは、ダイアログのテーマとして、「モノクロ」などを選択する方法もあります。 ツール → ユーザのオプション → ダイアグラム → テーマ 「ダイアグラムのテーマ」で「モノクロ（印刷用）」を選択 ダイアグラムの外枠を Off にする クラス図の各要素を Power Point に貼り付けると、デフォルトではクラス図の外枠（ダイアグラムフレーム）まで表示されてしまいます。これを Off にしておけば、各クラス要素だけをシンプルに貼り付けることができるようになります。 ツール → ユーザのオプション → ダイアグラム 「ダイアグラムフレーム」のチェックを外す"},{url:"/p/6qqdsxw/",title:"Androidメモ: Android Studio の便利なショートカット (2) ブックマーク",date:"2016-06-20T00:00:00+09:00",body:"Androidメモ: Android Studio の便利なショートカット (2) ブックマーク Android Studio には、任意の行をブックマークしておく機能が備わっています。 巨大なプログラムを読む場合や、複数ファイルにまたがる編集を行う場合に、ブックマーク機能を使いこなすと効率的に作業できます。 キー操作 説明 F11 カーソル行をブックマークに追加／削除 Ctrl + F11 カーソル行をブックマークに追加／削除（任意のキーに割り当てる）※ Shift + F11 ブックマークの一覧を表示 ※カーソル行をブックマークに追加するときに、Ctrl + F11 を使用すると、任意の英数字キーにそのブックマークを割り当てることができます。 例えば数字キー (0～9) に割り当てておくと、Ctrl + 0～9 というキー入力でその行にジャンプできるようになります（Shift + F11 で一覧を表示する必要がありません）。"},{url:"/p/u3n5m3j/",title:"Systrace の画面が真っ白になるときの対応方法",date:"2016-06-08T00:00:00+09:00",body:"Systrace の画面が真っ白になるときの対応方法 追記 (2021-04): 現在は Systrace は deprecated になっており、Perfetto という新しいトレースツールを使うことができます（参考: Perfetto でシステム全体のパフォーマンスを計測する。 過去に systrace で取得したトレースファイルを開きたいときは、Perfetto UI のサイト上で Open with Legacy UI から開くことができます。 Android の DDMS などで利用可能な systrace を実行すると、trace.html ファイルが生成されますが、この中で非推奨になった JavaScript API(Object.observe) を使用しているため、最新の Chrome では表示できない問題が出ています。 参考: http://stackoverflow.com/questions/36865899/react-native-android-systrace-html-is-blank-in-ubuntu-14-04/37008945 上記サイトでの回避策としては、生成された HTML のヘッダに下記を追加することがあげられています。 &lt;script src=&#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js&#34;&gt;&lt;/script&gt; 生成される HTML ファイルを毎回修正するのが面倒な場合は、Android SDK のディレクトリにある下記のファイルを編集するという方法もあります。 このファイルに追記した内容は、生成される HTML にも反映されるようになります。 $ANDROID_SDK/platform-tools/systrace/prefix.html &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head i18n-values=&#34;dir:textdirection;&#34;&gt; &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt; &lt;meta charset=&#34;utf-8&#34;/&gt; &lt;script src=&#34;https://rawgit.com/MaxArt2501/object-observe/master/dist/object-observe.min.js&#34;&gt;&lt;/script&gt; ★これを追加"},{url:"/p/39cfimo/",title:"Android アプリのパフォーマンス改善に使用できるツール",date:"2016-06-07T00:00:00+09:00",body:"Android アプリのパフォーマンス改善に使用できるツール systrace / perfetto: システム全体の負荷状況などを調べる systrace を使用すると、カーネルレベルでの CPU 負荷状況などを調べられるため、システム全体で重くなっている場合などの一次分析に使用できます。 DDMS ツール (monitor.bat) から任意のタイミングでプロファイル取得できます。 （追記） Android 10 (Q) 以降は、より洗練された Perfetto を使用してください。 参考: Perfetto でシステム全体のパフォーマンスを計測する traceview: アプリ内のメソッド呼び出し数などを調べる traceview を使用すると、特定のアプリ内のメソッド単位のプロファイル情報を取得することができます。 メソッド呼び出し回数が想定よりも多くなっているとか、処理に時間がかかりすぎているメソッドなどを発見できます。 DDMS ツールから任意のタイミングでプロファイル取得できます。あるいは、コードに開始／終了タイミングを明示することで、ピンポイントで特定の区間のプロファイルを取得することもできます。 Show GPU overdraw: 同じ領域を何度も描画しないか調べる 開発者オプションで Show GPU overdraw の機能を有効にすると、画面上に重ねて描画される領域があったときに、その領域が描画回数に応じた色で矩形表示されるようになります。 例えば、赤色で矩形表示された場合は、その領域が 3 回以上重複して描画されていることを示しており、プログラム内の描画シーケンスを見直すべきだと分かります。 Show GPU overdraw の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Drawing → Show GPU overdraw)。 Profile GPU rendering: 60FPS で描画できている調べる 開発者オプションで Profile GPU rendering の機能を有効にすると、描画フレームごとに UI スレッドでかかった時間を画面上にバー表示することができます。 緑色のラインは 16.6ms を示しており、このラインを超えるということは 60 FPS で描画できていないということです。メインスレッド上で描画以外の処理を行っていないか見直す必要があります。 Profile GPU rendering の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Monitoring → Profile GPU rendering)。 StrictMode: メインスレッドでの I/O アクセスなどを検出する メインスレッドの処理時間は、UI レスポンスに直接影響を与えるため、I/O アクセスなどの短時間に完了することが保証されない処理はメインスレッド上で実行すべきではありません。 Android には、このようなメインスレッド上で実行すべきではない処理を検出するための StrictMode（厳格モード） が用意されています。 StrictMode の機能は、Android の開発者オプションから有効にできます (Settings → Developer options → Monitoring → Strict mode enabled)。 StrictMode は、このように Android の設定から有効にすることもできますし、アプリのコード上で有効にすることもできます。 コード上で StrictMode を有効にすることで、より柔軟な検出方法を設定することができます。 例えば、問題のある処理 (policy violation) が実行されたときに、LogCat のログ上にその呼び出し情報（コールスタックなど）を表示したりできます。 本格的にパフォーマンス改善を進めるときには、このログ出力を頼りにすれば、ぬるぬるサクサクなアプリケーションを作成することができます。"},{url:"/p/9yse3iz/",title:"ADB で指定したアプリを強制終了する (am force-stop)",date:"2016-06-06T00:00:00+09:00",body:"ADB で指定したアプリを強制終了する (am force-stop) Android 端末に ADB 接続された状態で adb shell am force-stop コマンドを実行すると、任意のアプリケーションを強制終了することができます。 $ adb shell am force-stop com.example.myapp adb shell 接続されている状態であれば、adb shell の部分は省略して実行します。 generic_x86:/ $ am force-stop com.example.myapp ちなみに、インストールされているアプリのパッケージ名一覧は adb shell pm list packages で調べることができます（こちらは am じゃなくて pm コマンドであることに注意してください）。 参考: ADB で Android 端末にインストールされているパッケージの一覧を取得する (pm list packages)"},{url:"/p/3tip9yp/",title:"CSS で画像と埋め込み動画のサイズを画面内に収める (max-width)",date:"2016-05-01T00:00:00+09:00",body:"CSS で画像と埋め込み動画のサイズを画面内に収める (max-width) 画像の最大幅を設定する (max-width) 画像や埋め込み動画を表示するときに、そのままのサイズで表示すると、画面サイズを縮めた場合に、画面内に収まらなくなってしまいます。 次のように max-width を指定しておくと、ブラウザのウィンドウサイズを変更したときや、モバイル端末のような小さな画面サイズで表示したときも、ちゃんと画面内に収まるように表示されます。 img, embed, iframe, object { max-width: 100%; } デモ（別ページで開く） 上記のフレームをブラウザだと思ってサイズを縮めてみてください。 表示領域のサイズ変更に連動して画像サイズも縮小されて表示されるはずです。 画面幅に応じて画像を拡大表示する 逆に、画面（ブラウザ）のサイズを広げた場合は、もともとの画像のサイズ以上の大きさでは表示されません。 画面（ブラウザ）のサイズを広げたときに、そのサイズに連動して拡大して表示したいのであれば、max-width プロパティではなく、単純に width プロパティに 100% 指定します。 img { width: 100%; /* 横幅いっぱいに画像を広げて表示 */ } 横幅いっぱいにまで広げてしまうとさすがに大きすぎるけれど、ある程度まで（例えば、横幅の 80% くらいまで）は広げたいという場合は、min-width を指定することで、「少なくともこのサイズまでは拡大して表示する」、という意味になります。 下記の例ではパーセンテージで横幅を指定していますが、px 単位でも指定することができます。 img { min-width: 80%; max-width: 100%; /* 下記は中央寄せ設定 */ display: block; margin-left: auto; margin-right: auto; } デモ（別ページで開く）"},{url:"/p/3vejawn/",title:"Androidメモ: Android Studio の便利なショートカット (1) コードの調査／メソッド間のジャンプ",date:"2016-04-12T00:00:00+09:00",body:"Androidメモ: Android Studio の便利なショートカット (1) コードの調査／メソッド間のジャンプ コード探索に便利なショートカットキー一覧 ショートカットキーの組み合わせはたくさんあってややこしいですが、B キー系のショートカットは定義へのジャンプ、F7 キー系のショートカットは参照箇所へのジャンプと覚えれば迷わずに使用できるようになります。 B キーに関しては、マウスの左クリックで置き換えられるようになっています。 ひとまず、下記を使いこなせばほとんどのケースはカバーできるはずです。 Ctrl-Alt-B &ndash; クラス実装、メソッド実装、変数定義へのジャンプ Ctrl-Shift-B &ndash; 変数の型（クラス）へのジャンプ Alt-F7 &ndash; 参照箇所へのジャンプ Ctrl-Alt-左 &ndash; ジャンプ元へ戻る 下記はコードを調査するときに便利なショートカットキーの一覧です。 特に使いこなしたいキーに関しては、★マークを付けてあります。 B キー系（実装、定義へのジャンプ） ショートカットキー説明 Ctrl-B Ctrl-クリック 中央ボタンクリック Declaration コンテキストに応じて振る舞いが変わる。例えばカーソルがメソッド定義にあるときは参照箇所へジャンプ、カーソルが参照箇所にあるときは定義へジャンプする。できればこれに頼らず、より用途のはっきりした別のショートカットを使うとよい（下記2つ）。 ★ Ctrl-Alt-B Ctrl-Alt-クリック Implementation(s) 子クラスやインタフェースの実装クラス、メソッド実装へジャンプ。インタフェース→具象クラス、メソッド参照→メソッド実装、というジャンプ。 ★ Ctrl-Shift-B Ctrl-Shift-クリック Type Declaration テキストカーソル下のオブジェクトの実装クラスへジャンプ。あるいは、テキストカーソル下のメソッドの戻り値のオブジェクトの実装クラスへジャンプ（戻り値が void の場合は何も起こらない）。オブジェクト→クラス、というジャンプ。 F7 キー系（参照箇所へのジャンプ） ショートカットキー説明 ★ Alt-F7 Find Usages メソッドや変数の参照箇所をツリー表示 Ctrl-Alt-F7 Show Usages メソッドや変数の参照箇所をリスト表示（1か所だけなら即ジャンプ） Ctrl-F7 Find Usages in File ファイル内の参照箇所へジャンプ。F3で次へ移動。 Ctrl-Shift-F7 Highlight Usages in File ファイル内の同じキーワードをハイライト、どんどん追加していける。Esc ですべてのハイライトをクリア。 Ctrl-Alt-Shift-F7 Find Usages Settings... F キー系（テキストサーチ） ショートカットキー説明 Ctrl-F Find... ファイル内をテキスト検索 ★ Ctrl-Shift-F Find in Path... プロジェクト内をテキスト検索 Ctrl-Alt-F Field... フィールドをテキスト検索 その他 ショートカットキー説明 ★ Ctrl-Alt-左/右 Back/Forward ジャンプ元へ戻る／進む ★ Ctrl-N Class... クラス名を指定してファイルオープン ★ Ctrl-H Type Hierarchy クラスやインタフェースの階層構造を表示 Ctrl-F12 File Structure クラス内のメンバ、フィールドをリスト表示 実装へジャンプする B キー系ショートカット Ctrl-B（Ctrl-クリック）はコンテキストによって異なる振る舞いをするため、可能であれば、このショートカットは使わずに、より用途が明確な Ctrl-Alt-B、Ctrl-Shift-B の方を使えるようになると、スムーズにコード調査を行えるようになります。 Ctrl-B (Declaration) &ndash; 振る舞いがころころ変わる Ctrl-Alt-B (Implementations) &ndash; クラス実装、メソッド実装、変数定義へのジャンプ Ctrl-Shift-B (Type Declaration) &ndash; 変数の型（クラス）へのジャンプ ここでは、テキストカーソルの位置によってどのように振る舞いが変わるかを具体的に見ていきましょう。 クラス／インタフェース定義にテキストカーソルがある場合 public class MyClass { ... } public interface MyInterface { ... } Ctrl-B &ndash; クラスの参照箇所へジャンプ（Ctrl-Alt-F7 と同様） Ctrl-Alt-B &ndash; 実装クラス（or子クラス）へジャンプ（Ctrl-H で継承ツリー表示した方がわかりやすい） Ctrl-Shift-B &ndash; 該当なし（オブジェクトじゃないため） 親クラス／インタフェースにテキストカーソルがある場合 public class Child extends Parent { ... } public class Concrete implements IInterface { ... } Ctrl-B &ndash; 親クラスの定義へジャンプ Ctrl-Alt-B &ndash; 実装クラスへジャンプ Ctrl-Shift-B &ndash; 該当なし（オブジェクトじゃないため） メソッドの定義にテキストカーソルがある場合 public class MyClass { void myMethod() { ... } } Ctrl-B &ndash; メソッドの参照箇所へジャンプ Ctrl-Alt-B &ndash; 該当なし（自分自身が実装のため） Ctrl-Shift-B &ndash; 該当なし（ただし、戻り値があればそのオブジェクトのクラスへジャンプ） メソッドの参照箇所にテキストカーソルがある場合 public class MyClass { void myMethod() { obj.method(); } } Ctrl-B &ndash; メソッドの実装へジャンプ Ctrl-Alt-B &ndash; メソッドの実装へジャンプ Ctrl-Shift-B &ndash; 該当なし（オブジェクトじゃないため） 変数定義にテキストカーソルがある場合 public class MyClass { private MyClass mField; ... private void method(MyClass param) { ... } } Ctrl-B &ndash; 変数の参照箇所へジャンプ（Ctrl+Alt+F7と同様） Ctrl-Alt-B &ndash; 該当なし（変数自体に実装はない） Ctrl-Shift-B &ndash; そのオブジェクトのクラスへジャンプ 変数の参照箇所にテキストカーソルがある場合 public class MyClass { private void method() { mMyField.method(); } private void method(MyClass param) { hoge(param); } } Ctrl-B &ndash; 変数の定義へジャンプ Ctrl-Alt-B &ndash; 同上 Ctrl-Shift-B &ndash; そのオブジェクトのクラスへジャンプ 参照箇所へジャンプする F7 キー系ショートカット 参照箇所へジャンプする F7 キー系のショートカットは、定義／実装へジャンプする B キー系のショートカットと違って振る舞いが一定しているため簡単に使いこなすことができます。 基本は、Alt-F7 で参照箇所をツリー表示してジャンプ、という使い方で OK です。 ツリー表示された状態で、Ctrl-Alt-上/下 を押すことで、参照箇所に順番にジャンプすることができます（行入れ替えの Ctrl-Shift-上/下 と間違えないように！）。 Ctrl+H （クラスやインタフェースの継承構造を表示） クラス名にカーソルがある状態で、Ctrl-H を押すと、そのクラスの継承構造がすべてツリー表示されます。 調査対象としているクラスが複雑な継承構造を持っているとき、やみくもにコードを読み進めても全体の振る舞いを理解しにくいことがあります。 まずは、調査したいクラスの継承構造を把握するのがよいでしょう。 インタフェース名にカーソルがある状態で Ctrl-H を押すと、そのインタフェースを実装するクラスをすべて把握することができます。 この操作は、クラス名、あるいは、インタフェース名にテキストカーソルが置かれている状態でしかうまく機能しないことに注意してください。 フィールドや、変数にテキストカーソルが置かれている状態で実行した場合は、そのフィールドを保持しているクラスに関しての情報が表示されます。"},{url:"/p/ewvaoe3/",title:"Git で他の人が作成したブランチ上で作業する",date:"2016-04-05T00:00:00+09:00",body:"Git で他の人が作成したブランチ上で作業する GitHub などの共有リポジトリを使用して複数のメンバーで開発を進めている場合、他のメンバーが作成したブランチ（git push されたブランチ）をチェックアウトして共同作業したいことがあります。 そのような場合は、下記のような手順でローカルブランチを作成して編集作業を進めます。 共有リポジトリに push されているブランチをフェッチする (git fetch) 作業用のローカルブランチを作成する (git branch) ローカルブランチをチェックアウトして編集作業を行う (git checkout, git commit) 変更内容を共有リポジトリに push する (git push) 共有リポジトリに push されているブランチをフェッチする まずは、他の人が共有リポジトリ上に作成したブランチをローカルに持ってくる必要があります（--prune オプションを付けると、共有リポジトリ側で削除されているブランチをローカルからも削除してくれます）。 $ git fetch --prune リモートトラッキングブランチの一覧を表示し、対象のブランチをうまく fetch してこれたかを確認しておきます。 $ git branch -r origin/HEAD -&gt; origin/main origin/change-date-format origin/fix-lint-warnings origin/main リモートトラッキングブランチ名は、&lt;リポジトリ&gt;/&lt;ブランチ&gt; という構成になっていますが、clone 元のリポジトリ名は origin というエイリアス名で指定できるようになっています。 作業用のローカルブランチを作成する リモートトラッキングブランチは、あくまでリモートリポジトリ側の内容を追跡するためのものなので、ここに直接修正を加えていくことはできません。 そこで、リモートトラッキングブランチをベースにして、ローカルブランチを作成する必要があります。 次の例では、リモートトラッキングブランチ origin/change-date-format と同名の change-date-format というローカルブランチを作成しています。 $ git branch change-date-format origin/change-date-format Branch &#39;change-date-format&#39; set up to track remote branch &#39;change-date-format&#39; from &#39;origin&#39;. 次のようにして、正しくローカルブランチが作成されていることを確認しておきます。 $ git branch change-date-format * main ローカルブランチをチェックアウトして編集作業を行う あとは、普段通りブランチをチェックアウトして編集作業を行い、コミットしていけば OK です。 $ git checkout change-date-format （編集…） $ git commit 変更内容を共有リポジトリに push する ローカルブランチでの変更作業が終了したら、共有リポジトリ（GitHub など）へ git push して、他のメンバーに編集内容を共有します。 $ git push origin change-date-format ちなみに、リモートトラッキングブランチから作成したブランチの内容を git push する場合は、-u (--set-upstream) オプションを指定してブランチ名を対応付ける必要はありません。 ブランチを作成した時点で、どのリモートブランチと対応付けるべきかが分かっているからです。"},{url:"/p/hv7we2a/",title:"Androidメモ: Android Studio で新規ファイル作成時に Copyright を自動挿入する",date:"2016-03-22T00:00:00+09:00",body:"Androidメモ: Android Studio で新規ファイル作成時に Copyright を自動挿入する Android Studio で下記のコピーライト設定を行っておくと、新規ファイルを作成したときに、ファイルの先頭に自動でコピーライト表記を挿入してくれるようになります。 Android Studio のメニューから [File] → [Settings] を選択 Settings ウィンドウから [Editor] → [Copyright] → [Copyright Profiles] を選択 [+] ボタンを押して任意のコピーライト設定を行う [Editor] → [Copyright] に戻り、上記で作成したコピーライト設定を選択する ステップ 3 での Copyright text の設定では、純粋にコピーライト表記用の文言だけを記入すれば OK です。 Copyright 2016 MakuMaku Corporation 上記のように記入しておけば、あとは作成するファイルの種類によって、自動的にコメント化されて挿入されるようになります。 /* * Copyright 2016 MakuMaku Corporation */"},{url:"/p/b5ivaja/",title:"Androidメモ: Android Studio に割り当てるメモリを増やす",date:"2016-03-22T00:00:00+09:00",body:"Androidメモ: Android Studio に割り当てるメモリを増やす Android Studio に割り当てられる VM のメモリ容量は、デフォルトで最大 750MB (-Xmx750m) に設定されています。 物理メモリに余裕のある PC で作業している場合は、この最大サイズを大きくしておくとよいでしょう。 VM に関する設定は、studio.exe.vmoptions あるいは studio64.exe.vmoptions というファイルを作成して変更することができますが、これらのファイルの具体的な置き場所は、プラットフォームごと、Android Studio のバージョンごとに異なっています（下記参照）。 Configuring Android Studio: IDE &amp; VM Options, JDK, etc - Android Tools Project Site 例えば、Windows で Android Studio Preview 2.0 (64bit) を使用している場合は、下記のようなファイルを作成します。 %USERPROFILE%\\.AndroidStudioPreview2.0\\studio64.exe.vmoptions Android Studio が使用可能なメモリ容量を増やす（ここでは 4GB に設定する）には、このファイルに下記のように記述しておきます。 studio64.exe.vmoptions -Xms1024m -Xmx4096m -Didea.platform.prefix=AndroidStudio -Didea.paths.selector=AndroidStudioPreview2.0 -Xms の方は最少メモリ容量、-Xmx の方には最大メモリ容量を指定します。 最後の 2 行の AndroidStudio に関する設定（環境によっては prefix の方だけで OK かも）を行っておかないと、studio64.exe を起動しようとしたときに素の IntelliJ が起動しちゃったりします。"},{url:"/p/xikzhtr/",title:"GitHub の Markdown でメールアドレスへのリンクを記述する",date:"2016-02-04T00:00:00+09:00",body:"GitHub の Markdown でメールアドレスへのリンクを記述する Markdown ファイルの中で、E メールアドレスのリンクを記述するには下記のようにします。 Markdown ファイル抜粋 [表示名](&lt;mailto:xxx@example.com&gt;) 上記のように &lt; と &gt; で囲んだメールアドレスは、出力される HTML の中では、下記のように実体参照による表現に変換されるため、スパムメールの対策にもなります。 変換後の HTML &lt;a href=&#34;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#120;&amp;#120;&amp;#120;&amp;#064;&amp;#101;&amp;#120;&amp;#097;&amp;#109;&amp;#112;&amp;#108;&amp;#101;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&#34;&gt;表示名&lt;/a&gt; 実際の表示結果は次のような感じになります。 表示名"},{url:"/p/tq3zi5j/",title:"CSS のフレキシブルボックスによるレスポンシブレイアウト",date:"2016-01-01T00:00:00+09:00",body:"CSS のフレキシブルボックスによるレスポンシブレイアウト CSS のフレキシブルボックスレイアウト機能を利用すると、下記の様な段組レイアウトを簡単に作成することができます。 図: 幅が広いときはサイドバーを表示 HTML &lt;div id=&#34;container&#34;&gt; &lt;div id=&#34;sidebar1&#34;&gt;Sidebar 1&lt;/div&gt; &lt;div id=&#34;main&#34;&gt;Main&lt;br&gt;Main&lt;br&gt;Main&lt;/div&gt; &lt;div id=&#34;sidebar2&#34;&gt;Sidebar 2&lt;/div&gt; &lt;/div&gt; CSS #container { /* フレキシブルボックスレイアウトによる段組 */ display: flex; } #sidebar1, #sidebar2 { width: 100px; background: pink; } #main { /* 画面幅が広い時はこの要素の横幅を拡張する */ flex-grow: 1; background: cyan; } 参考: （旧）フレキシブルボックスの旧式の定義方法 さらに、メディアクエリを利用して、画面幅が一定サイズ以下になったときに、このフレキシブルボックスレイアウトを解除することができます。 例えば、スマートフォンなどで表示する場合に、サイドバーを縦に並べたり、省略してもよいサイドバーを非表示にしたりできます。 下記の例では、画面幅が 400px 以下になった場合にフレキシブルボックスレイアウトを解除し、sidebar1 を横幅いっぱいで表示し、sidebar2 を非表示にしています。 図: 幅が狭いときは縦に並べる /* * レスポンシブデザイン対応。 * 幅が狭い場合は sidebar1 を横幅いっぱいに表示する。 * sidebar2 は非表示にする。 */ @media screen and (max-width: 400px) { #container { display: block; } #sidebar1 { width: auto; } #sidebar2 { display: none; } } JSFiddle で試す 上記の例では、サイドバーを表示するレイアウトをデフォルトのスタイルとして定義しましたが、モバイルファーストの考えを採用するのであれば、幅が狭い場合のレイアウト（縦に並べるレイアウト）をデフォルトのスタイルとして定義してください。 参考: モバイルファーストな CSS を作成するコツ（max-width ではなく min-width を使うべし）"},{url:"/p/eh73hkg/",title:"ゴッドクラス (God Class) とは",date:"2015-12-18T00:00:00+09:00",body:"ゴッドクラス (God Class) とは PMD などの静的解析ツールで、God Class（ゴッドクラス） という警告が出ることがあります。 Possible God class (WMC=52, ATFD=76, TCC=0.022058823529411766). God Class は、本来あまり関連性を持たせるべきではない多くのクラスを参照、結びつけてしまっているクラスであり、神のように全体を制御しているクラスを指します。 クラスの責務分割がうまくいっていない場合に、このような多くの責務を持つクラスができてしまうことがあります。 上記の警告が出た場合は、クラス内の処理を適切なまとまりで別のクラスに分割する、といったリファクタリングが必要であることを示唆しています。 あるクラスが God Class になっているかどうかを定量的に判断できるようにした WMC、ATFD、TCC というメトリクスが、Michele Lanza と Radu Marinescu の『Object-Oriented Metrics in Practice』 の中で紹介されています。 これらの値が、下記の条件をすべて満たすと、God Class とみなされます。 WMC ≧ VERY_HIGH (= 47) ATFD ＞ FEW (= 5) TCC ＜ 1/3 (= 0.333&hellip;) それぞれのメトリクスは、下記のような意味を持っています。 WMC: Weighted Method Count (Weighted Method per Class) WMC は、クラス内のメソッドの複雑度の合計値です。 WMC が高いということは、アプリケーションへの依存度が高く、再利用性、メンテナンス性の悪いクラスであることを示します。 逆に、WMC が低いということは、明示的な分岐などが少なく、オブジェクト指向における多態性（ポリモーフィズム）を活かした設計ができているクラスと言えます。 複雑度の計算方法は色々あるようです。 McCabe&rsquo;s Cyclomatic Complexity of the method Lines of Code in the method 1 for each method (unweighted WMC) PMD のコードを見る限り、1 番の Cyclomatic Complexity が採用されており、下記のような要素の合計値で求められるようです。 メソッド数 分岐やループなど、各種制御構造の数 (if、while、for、switch のラベル、catch、? など） OR (||) や AND (&amp;&amp;) の数 メソッド数や分岐の数が増えると、WMC の値も単純に 1 つずつ増加していくと考えればよさそうです。 ATFD: Access To Foreign Data 他のクラスのオブジェクトの属性を、直接参照している個所の数です。PMD では、get や is、set などで始まるメソッドを呼び出している箇所もカウントされるようです。 ATFD の値が大きいということは、他のオブジェクトの構造に強い依存があることを示しており、独立して変更することが難しいことを意味します。 オブジェクト間のコミュニケーションを、論理的なメソッド経由で行うようにすることで、別のクラスの構造に対する直接的な依存度を下げることができます。 TCC: Tight Class Cohesion TCC は 0 ～ 1 の範囲の数値で、メソッドの凝集度（メソッド同士の関連性がどの程度あるか）を表しています。 TCC が低いということは、関連性の低いメソッドが 1 つのクラスに入っており、複数の責務が混ざってしまっていることを示唆しています。 TCC は、visible なメソッド（private 以外のメソッド）に対して、下記のような計算を行うことで求められます。 直接接続されたメソッドの関連の数 ／ メソッドの関連の合計数 「直接接続されている (directly connected)」とは、2 つのメソッドにおいて、それぞれメソッド呼び出しを辿っていったときに、同じメンバ変数を参照していることを示します。 たとえば、メソッド A と、メソッド B が、同じメンバ変数を参照していれば、A と B は directly connected ということになり、上記の式における分子が +1 されます。メソッド A、B、C が同じメンバ変数を参照していれば、関連の数は 3 となります（A ⇔ B、B ⇔ C、C ⇔ A が directly connected な関連となる）。 一方で、分母の「関連の合計数」は、単純に visible なメソッドの関連の数であり、メソッド数を n として、n (n - 1) / 2 という計算で求められます。 このあたりの関連の説明に関しては、このサイトの説明がとてもわかりやすいです。 TCC が低すぎるということは、関連のない内部データにアクセスするメソッドが多いということを示しています。 それはすなわち、クラスを適切な責務ごとに分割すべきであることを示しています。"},{url:"/p/medwvff/",title:"アプリ内の名前空間（Java のパッケージ階層）に迷った時のヒント",date:"2015-12-15T00:00:00+09:00",body:"アプリ内の名前空間（Java のパッケージ階層）に迷った時のヒント あいまいなパッケージ分割 みなさんは、アプリケーション内の名前空間をどういったポリシーで分けていますか？ （ここでは Java プログラムのパッケージ分割について考えることにしましょう） パッケージの分割方法、命名方法は、ベテランのプログラマでも悩むところです。 例えば、MyApp (com.example.myapp) というアプリケーションのルートパッケージが、下記のように分割されていたとします。 com.example.myapp + optionmenu + view + ... このパッケージ分割方法には少々問題があるということにすぐに気付いた方は、普段から保守性を意識したコーディングを行えている人だと思います。 上記のパッケージ名からは、次のようなことを想像できます。 オプションメニューという機能を構成するクラスは optionmenu パッケージに格納すればよさそうだ。 UI 系のコンポーネントは view パッケージに格納するのだろう。でも、オプションメニューを構成する UI コンポーネントは optionmenu に入れるの？それとも view に入れるの？ ようするに、パッケージ分割のポリシーがあいまいだということです。 optionmenu というパッケージは、**「アプリ内の部分的な機能」という側面 (aspect) に注目して分割しており、一方で、view というパッケージは、「クラスが提供する機能の種類」**という側面で分割してしまっています。 そもそも、物事は複数の側面（アスペクト）から捉えられるのに、名前空間は階層構造という概念でしか分割できないというところに制約があります。 ブログなどのシステムでは、タグという機能によって、記事に対して横断的なラベルを付けらるのですが、プログラミングの名前空間の世界には、このような機能は今のところありません。 どのような側面によりパッケージ分割するかのポリシーを決めておかないと、先の例のようなあいまいなパッケージ分割が行われることになってしまいます。 重要なのは、新しいクラスを作成するときに、どのパッケージに格納すべきかが直感的に分かるようなパッケージ分割のポリシーを決めることです。 パッケージ分割のヒント ここでオススメするのは、**「アプリ内の部分的な機能」**を基準にパッケージ分割していくという方法です。 例えば、アプリケーションのルートパッケージを下記のように分割します。 com.example.myapp + feature（あるいは function など） + common + main（あるいは app など） + ... feature パッケージには、アプリケーションを構成する部分的な機能（フィーチャ）を提供するためのパッケージ、クラスを格納する（例: feature/opetionmenu）。 common パッケージには、上記の複数のフィーチャから共通で使用するユーティリティクラスなどを格納する。 main パッケージには、アプリケーションを動作させるのに必須なクラスを格納する（起動シーケンスに関わる部分など）。モジュール化を意識するのであれば、main パッケージはできるだけ小さく維持すること。 このように分割しておけば、例えば、オプションメニュー機能の UI を構成するクラスは feature/optionmenu パッケージ以下に格納すればいいんだな、とか、一方で共通で使用する UI モジュールは common/view パッケージ以下に格納すればいいんだな、と一発で分かるようになります。 この分割方法は、複数メンバから構成されるチームで 1 つのアプリケーションを作っていくときに威力を発揮します。 ある機能を担当するメンバは、feature 以下の機能用パッケージでの修正に集中し、必要に応じて common パッケージにある共通クラスを利用する、というように作業範囲を明確に絞り込めるようになります。 1 つのシステムは、複数のアプリケーションから構成されています。 これは、1 つのシステムがアプリケーションという「機能」単位に分割されていることにほかなりません。 この考え方を、アプリケーションの中の構造にも適用するということです。 例外は、ライブラリです。ライブラリ内のパッケージ構成は、「クラスの提供する機能の種類」で分割した方が利用者にとってわかりやすい構成となるでしょう。例えば、UI コンポーネントであれば、ui や view というパッケージにまとめて入れる、という具合です。"},{url:"/p/web92kb/",title:"Android Studio で静的解析プラグインを使用する (CheckStyle, FindBugs)",date:"2015-12-09T00:00:00+09:00",body:"Android Studio で静的解析プラグインを使用する (CheckStyle, FindBugs) Gradle で Checkstyle や FindBugs のタスクを実行するのもよいですが、Android Studio に Plugin を入れておくと、警告箇所を簡単に調べられるようになります。 CheckStyle 用のプラグイン (CheckStyle-IDEA) インストール Ctrl + Alt + S で Settings を開く Plugins の Browse repositories... ボタンを押す CheckStyle-IDEA をインストール Android Studio を再起動 設定（プロジェクト用の設定が必要な場合） Ctrl + Alt + S で Settings を開く Other tools の CheckStyle を開く プロジェクト用の設定ファイルを追加し、チェックボックスにチェックを入れる 実行 Ctrl + Shift + A で check と入力 カレントファイルをチェックする場合: Check Current File モジュール全体をチェックする場合: Check Module プロジェクト全体をチェックする場合: Check Project FindBugs 用のプラグイン (FindBugs-IDEA) インストール Ctrl + Alt + S で Settings を開く Plugins の Browse repositories... ボタンを押す FindBugs-IDEA をインストール Android Studio を再起動 設定（プロジェクト用の設定が必要な場合） Ctrl + Alt + S で Settings を開く Other tools の FindBugs-IDEA を開く Filters タブの Exclude filter files の Add ボタンを押し、排他設定ファイルを読み込み。などなど。 実行 Ctrl + Shift + A で findbugs と入力 カレントファイルをチェックする場合: Analyze Current File モジュール全体をチェックする場合: Analyze Module Files プロジェクト全体をチェックする場合: Analyze Project Files"},{url:"/p/bz3ga84/",title:"CSS で画像の下に隙間が空くのを防ぐ (vertical-align)",date:"2015-12-07T00:00:00+09:00",body:"CSS で画像の下に隙間が空くのを防ぐ (vertical-align) img 要素の下にくっつけて別の要素を配置しようとしても、デフォルトではどうしても隙間が空いてしまいます。 HTML 抜粋 &lt;img src=&#34;tree.png&#34;&gt;&lt;br&gt; &lt;img src=&#34;tree.png&#34;&gt;&lt;br&gt; &lt;img src=&#34;tree.png&#34;&gt; 図: 画像の下に隙間ができてしまう例（別ページで開く） これは、img 要素はテキストと同様にベースラインを意識した配置が行われるからです。 下記のように vertical-align プロパティを bottom に設定しておけば、隙間をなくすことができます。 CSS img { vertical-align: bottom; } 図: 画像の下の隙間をなくした例（別ページで開く） この問題が発生しない場合は、プロジェクトで使用しているリセット系の CSS に、すでに上記のような定義が含まれている可能性が高いです。"},{url:"/p/4zogpen/",title:"Android Gradleメモ: リソース名に正しくプレフィックスが付いているか確認する (resourcePrefix)",date:"2015-11-30T00:00:00+09:00",body:"Android Gradleメモ: リソース名に正しくプレフィックスが付いているか確認する (resourcePrefix) マルチプロジェクト構成な Android プロジェクトでは、サブプロジェクトによるリソース名の重複を意識しなければいけません。 リソース名の重複を防ぐには、例えば、サブプロジェクト内で使用するリソース名にプレフィックス名を付けたりします。 build.gradle で下記のように resourcePrefix を指定しておくと、リソース名のプレフィックスが正しく付けられているかチェックしてくれるようになります。 この設定は、Android Studio 0.5.8 以降で使用可能です。 android { resourcePrefix &#39;mylib_&#39; } 指定したプレフィックスが付いていないリソース名が見つかると、Android Lint による警告が発生します。"},{url:"/p/5zj72ei/",title:"Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve)",date:"2015-11-19T00:00:00+09:00",body:"Python の ulrlib による HTTP 通信 (3) ファイルをダウンロードする (urllib.request.urlretrieve) urllib.request によるファイルのダウンロード urllib.request.urlretrieve を使用すると、簡単に Web 上のファイルをダウンロードしてローカルファイルとして保存することができます。 urllib.request.urlretrieve 関数 下記の download_file 関数は、指定した URL のファイルをカレントディレクトリにダウンロードします。 import urllib.request import os.path def download_file(url): filename = os.path.basename(url) or &#39;index.html&#39; urllib.request.urlretrieve(url, filename) if __name__ == &#39;__main__&#39;: download_file(&#39;https://example.com/&#39;) ローカルに作成されるファイル名は、os.path.basename を使用して、URL の末尾から切り出しています。 URL の末尾にファイル名らしきものが見つからない場合は、デフォルトファイル名として index.html で保存するようにしています。 テンポラリファイルとしてダウンロードする urllib.request.urlretrieve の 2 番目のパラメータ (filename) を省略すると、テンポラリディレクトリに適当なファイル名で保存されます。 このファイルパスは、戻り値で返されるタプルの先頭に格納されています。 path, headers = urllib.request.urlretrieve(&#39;http://example.com/sample.png&#39;) print(path) #=&gt; c:\\users\\maku\\appdata\\local\\temp\\tmpgujizj urlretrieve により作成された一時ファイルを確実に削除するには、下記のように後始末しておきます。 urllib.request.urlcleanup() このファイルはテンポラリディレクトリに作成されるファイルなので、それほど厳密に削除する必要はないかと思いますが、大量のテンポラリファイルが作られるような場合は実行しておいた方がよいでしょう。 ダウンロード時の HTTP レスポンスヘッダの取得 urllib.request.urlretrieve により、ファイルをダウンロードした際に、ついでに HTTP レスポンスヘッダを取得したい場合 は、下記のように 戻り値のタプルの 2 番目の要素 から取得できます。 path, headers = urllib.request.urlretrieve(&#39;https://www.google.co.jp/images/nav_logo242_hr.png&#39;) for key, val in headers.items(): print(&#39;{0} ===&gt; {1}&#39;.format(key, val)) 実行結果 Content-Type ===&gt; image/png Date ===&gt; Thu, 19 Nov 2015 04:41:09 GMT Expires ===&gt; Thu, 19 Nov 2015 04:41:09 GMT Cache-Control ===&gt; private, max-age=31536000 Last-Modified ===&gt; Thu, 22 Oct 2015 17:33:49 GMT X-Content-Type-Options ===&gt; nosniff Server ===&gt; sffe Content-Length ===&gt; 39373 X-XSS-Protection ===&gt; 1; mode=block Alternate-Protocol ===&gt; 443:quic,p=1 Alt-Svc ===&gt; quic=&#34;www.google.com:443&#34;; p=&#34;1&#34;; ma=600,quic=&#34;:443&#34;; p=&#34;1&#34;; ma=600 Connection ===&gt; close"},{url:"/p/4yiygwe/",title:"Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler)",date:"2015-11-19T00:00:00+09:00",body:"Python の urllib による HTTP 通信 (4) Basic 認証 (urllib.request.HTTPBasicAuthHandler) urllib.request モジュールを使って Basic 認証の設定された Web サイトにアクセスすると、デフォルトでは下記のようなエラーが発生します。 Basic 認証エラー urllib.error.HTTPError: HTTP Error 401: Authorization Required HTTPBasicAuthHandler を使用すると、各 Web サイトにアクセスするときのユーザ名と、パスワード情報を設定することができます。 具体的には、Basic 認証のかかった Web サイトにアクセスした場合に Web サーバから返される realm 情報 と、ベースとなる URI 情報 に対して、使用するユーザ名とパスワードを関連付けます。 下記のサンプルでは、http://example.com/secret/ 以下にアクセスする際に、Basic 認証のユーザ名、パスワードとして、user1、pass1 を利用するように設定しています。 ここでは、realm 情報は無視し、URI 情報だけに関連付けるようにするため、HTTPPassswordMgrWithDefaultRealm を使用しています。 Basic 認証の付いたサイトにアクセスする import urllib.request import os.path def setup_basic_auth(base_uri, user, password): password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_mgr.add_password( realm=None, uri=base_uri, user=user, passwd=password) auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr) opener = urllib.request.build_opener(auth_handler) urllib.request.install_opener(opener) def download_file(url): filename = os.path.basename(url) or &#39;index.html&#39; print(&#39;Downloading ... {0} as {1}&#39;.format(url, filename)) urllib.request.urlretrieve(url, filename) if __name__ == &#39;__main__&#39;: setup_basic_auth(&#39;http://example.com/secret/&#39;, &#39;user1&#39;, &#39;pass1&#39;) download_file(&#39;http://example.com/secret/sample.zip&#39;)"},{url:"/p/3m9f8yv/",title:"Androidメモ: AAR 形式のファイルを作成する/使用する",date:"2015-11-16T00:00:00+09:00",body:"Androidメモ: AAR 形式のファイルを作成する/使用する AAR とは Android Studio では、従来の JAR 形式のライブラリファイルに加え、AAR (Android Archive) 形式のライブラリ を作成することができます。 JAR ライブラリとは違い、AAR ライブラリは Android 固有のアセット、リソース、AndroidManifest.xml などを含めることができます。 AAR ライブラリには AndroidManifest.xml を含めることができるので、uses-library 宣言をライブラリ内で完結させるといったことが可能になります。 AAR ライブラリを作成する 通常のアプリプロジェクトの下に AAR ライブラリ用のサブプロジェクトを作成する方法 現状の Android Studio (version 1.5) では、AAR ライブラリ専用の新規プロジェクトを作成することができません（後述の方法で、ごにょごにょすれば AAR 専用のプロジェクトとして扱うことはできます）。 なので、通常はアプリケーションプロジェクトの下に、サブプロジェクトとして AAR ライブラリのプロジェクトを作成することになります。 AAR ライブラリを作成する場合は、その使用例などを示すサンプルプロジェクトなども用意する必要がありますから、この構成で作成しておいても特に問題ないでしょう。 まずは下記のように親プロジェクトとなるアプリプロジェクトを作成します。 Android Phone 用の UI ライブラリを作るつもりであれば、それを前提とした構成で作成しておけばよいでしょう。 メニューから File =&gt; New =&gt; New Project... を選択 次に、そのサブプロジェクトとして、AAR ライブラリ作成用のプロジェクトを作成します。 メニューから File =&gt; New =&gt; New Module... を選択 Android Library を選択し、Module name に AAR ライブラリのファイル名、Package name にライブラリの Java パッケージ名を入力 AAR ライブラリ用のサブプロジェクトが作成されたら、そこに Java のクラスやリソース、AndroidManifest.xml などを追加していきます。 最後に、メニューから Build =&gt; Make Module としてビルドすれば、下記のディレクトリに AAR ライブラリが生成されます。 &lt;AARサブプロジェクト名&gt;/build/outputs/aar AAR ライブラリ専用のプロジェクトを作成する方法 Android Studio 1.5 の時点では、ウィザードから AAR ライブラリ専用のプロジェクトを作成することができません。 どうしても作りたいのであれば、まずは空のアプリプロジェクトとして作成しておき、それをライブラリプロジェクトに書き換えるという方法で実現できます。 メニューから File =&gt; New =&gt; New Project... を選択 UI 構成の選択画面で、Add No Activity を選択 空のアプリプロジェクトを作成したら、アプリモジュール内の build.gradle を下記のように変更します。 apply plugin: の後ろを、com.android.application から com.android.library に変更 defaultConfig のコンフィギュレーションブロックの applicationId を削除 あとは、メニューから Build =&gt; Make module とすれば、AAR ファイルが生成されます。 AAR ライブラリを使用する 配布された AAR ライブラリを、別のアプリプロジェクトから使用するには以下のようにします。 PC 内のどこかに AAR ファイルを置いておく（下記の手順でアプリプロジェクトにコピーされるので、アプリプロジェクト以下のディレクトリに AAR ファイルを置いておく必要はありません） メニューから File =&gt; New =&gt; New Module... を選択（Import Module... ではないことに注意） Import .JAR/.AAR Package を選択し、上記の AAR ファイルを指定 上記の手順を行うと、AAR ライブラリだけを含んだサブプロジェクト（ここでは mylib-release とします）が生成されます。 プロジェクトの settings.gradle には、自動的に下記のようにサブプロジェクトへの参照情報が追記されます。 settings.gradle include &#39;:app&#39;, &#39;:mylib-release&#39; あとは、このライブラリを使用したい app プロジェクトから依存関係を設定すれば OK です。 app/build.gradle dependencies { compile project(&#39;:mylib-release&#39;) ... } これで、AAR ライブラリで定義した Java のクラスファイルなどを参照できるようになります。"},{url:"/p/8f3pcke/",title:"Android Gradleメモ: Android の Gradle 関連ファイルまとめ",date:"2015-11-12T00:00:00+09:00",body:"Android Gradleメモ: Android の Gradle 関連ファイルまとめ Android Studio を使ったり、Gradle でマルチプロジェクトを扱っていたりすると、Gradle 関連のプロパティファイル (.properties) やビルドスクリプト (.gradle) が増えてきます。 混乱しやすいのでまとめておきます。 ファイル名 自動生成される？ Gitにコミットする？ 説明 build.gradle 手動で編集 する プロジェクトごとのビルドスクリプト settings.gradle 手動で編集 する マルチプロジェクト構成のプロジェクトにおいて、サブプロジェクトなどのリストを管理 gradle.properties Android Studio が自動生成 しない Gradle 実行のプロキシ設定やメモリ容量設定 local.properties Android Studio が自動生成 しない Android SDK のパスなど、個人環境に依存する設定が格納される その他.properties 手動で編集 する 独自に作成したプロパティファイル（ビルドスクリプト内で読み込んだりしているはず）"},{url:"/p/quhymp7/",title:"Gradle でプロパティファイル (.properties) を読み込む",date:"2015-11-12T00:00:00+09:00",body:"Gradle でプロパティファイル (.properties) を読み込む 独自のプロパティファイルを参照する Gradle ビルドスクリプトで Properties クラスを利用すると、任意の .properties ファイルを簡単に読み込むことができます。 例えば、次のような sample.properties をプロジェクトのルートディレクトに置いて、これを読み込んでみます。 sample.properties key1=value1 key2=value2 下記ビルドスクリプトの loadProperties メソッドでは、指定した .properties ファイルを読み込んでオブジェクトとして返しています。 build.gradle /** * Reads properties from the specified .properties file. */ def loadProperties(filename) { def props = new Properties() file(filename).withInputStream { props.load(it) } return props } task hello &lt;&lt; { def props = loadProperties(&#34;$rootDir/sample.properties&#34;) println &#34;props.key1 = ${props.key1}&#34; println &#34;props.key2 = ${props.key2}&#34; } 実行結果 $ gradle -q hello props.key1 = value1 props.key2 = value2 読み込んだプロパティ設定を、プロジェクト全体から参照できるようにしたいときは、次のようにプロジェクトの ext プロパティに設定してしまえば OK です。 def loadProperties(filename) { def props = new Properties() file(filename).withInputStream { props.load(it) } ext.props = props // ★プロジェクト全体から見えるようにする } task hello &lt;&lt; { loadProperties(&#34;$rootDir/sample.properties&#34;) println &#34;props.key1 = ${props.key1}&#34; println &#34;props.key2 = ${props.key2}&#34; } gradle.properties を参照する プロジェクトのディレクトリに配置した gradle.properties に記述した設定内容は、自動的に project オブジェクトのプロパティとして参照できるようになります。 gradle.properties key1=value1 key2=value2 build.gradle task hello &lt;&lt; { println &#34;project.key1 = ${project.key1}&#34; // project は省略可能 println &#34;project.key2 = ${project.key2}&#34; } 実行結果 $ gradle -q hello project.key1 = value1 project.key2 = value2 ただし、ユーザディレクトリに配置した ~/.gradle/gradle.properties ファイルに、同じキーのプロパティが定義されていると、そちらの値が優先されるので注意しましょう。 ~/.gradle/gradle.properties key2=value2 (overridden) 実行結果 $ gradle -q hello project.key1 = value1 project.key2 = value2 (overridden) いずれにしても、gradle.properties はビルド環境に関する設定を記述するためのファイルです。 プロジェクト特有のリソースや設定値などをビルドスクリプトの外で管理したい場合は、独自のプロパティファイルとして作成してしまう方が安全です。 ☝️ ワンポイント gradle.properties ファイル内で定義するプロパティのキー名に、ドットやハイフンが含まれている場合は、${xxx.yyy.zzz} の形ではなく、getProperty('xxx.yyy.zzz') のように参照する必要があります。 参考 The Build Environment - Gradle User Guide"},{url:"/p/6vpyp4z/",title:"Python で指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob)",date:"2015-10-30T00:00:00+09:00",body:`Python で指定した拡張子や名前のファイルを列挙する (glob.iglob, glob.glob) 指定した拡張子を持つファイルを列挙する ここでは、Python でカレントディレクトリ以下の .java ファイルを列挙する例を示します。 glob を使用する方法（オススメ） glob.iglob 関数や glob.glob 関数を使用すると、いわゆるグロブ（シェルのワイルドカード）によるパターン指定でファイルを列挙することができます。 glob.iglob はジェネレーターで、glob.glob は通常の関数です。 つまり、glob.iglob は for ループでイテレート処理したいとき、glob.glob はリストで取得したいときに使います。 glob.iglob でファイル列挙 import glob for name in glob.iglob(&#34;*.java&#34;): print(name) Python 3.5 以降では、ディレクトリを再帰的にたどるための ** も使用できます。 この場合は recursive パラメータを True に設定します。 glob.iglob で再帰的なファイル列挙 import glob for name in glob.iglob(&#34;**/*.java&#34;, recursive=True): print(name) 実はオブジェクト指向的な方法でファイルパスを扱うための pathlib.Path クラス にも glob メソッドが用意されていて、同様の方法でファイルパスを列挙できます。 この glob メソッドは glob.glob 関数とは異なり、再帰的にディレクトリをたどるようにデフォルトで設定されており、ジェネレーターを返すようになっています。 ややこしいですね。 Path#glob メソッドで再帰的なファイル列挙 from pathlib import Path for name in Path(&#34;.&#34;).glob(&#34;**/*.java&#34;): print(name) os.walk を使用する方法 glob を使用せずに、os.walk などを使用して自力でファイルを検索することもできます。 ここでは、os.walk ですべてのファイルを再帰的に列挙しつつ、fnmatch.fnmatch を使って指定した拡張子に一致するかを調べています。 os.walk で再帰的に .java ファイルを列挙 import fnmatch import os for dirpath, dirs, files in os.walk(&#34;.&#34;): for name in files: if fnmatch.fnmatch(name, &#34;*.java&#34;): print(os.path.join(dirpath, name)) 実は、glob.iglob の実装もこのように os.walk や fnmatch を組み合わせて実装されています。 指定した名前に完全に一致するファイルを検索する ファイル名が完全に一致するファイルを検索したい場合も、glob.iglob を使って検索することができます。 ファイルを１つだけ見つけたい場合は、下記のようにループを break で抜けてしまえばよいでしょう。 カレントディレクトリ以下から指定した名前のファイルを検索 import glob for name in glob.iglob(&#34;**/SampleApp.java&#34;, recursive=True): print(name) break 応用例: 指定した拡張子を持つファイルを grep する 下記の Python スクリプトは、カレントディレクトリ以下のすべての .java ファイルの内容を読み込み、import で始まる行を抽出して出力します。 extract_imports.py（.java ファイル内の import 行を抽出） import glob for filename in glob.iglob(&#34;**/*.java&#34;, recursive=True): with open(filename, encoding=&#34;utf-8&#34;) as f: for i, line in enumerate(f, start=1): if line.startswith(&#34;import &#34;): print(&#34;{} [{}]: {}&#34;.format(filename, i, line.rstrip(&#34;\\r\\n&#34;))) 実行結果 $ python extract_imports.py com/example/myapp/Main.java [1]: import java.util.concurrent.Callable; com/example/myapp/Main.java [2]: import java.util.concurrent.ExecutionException; com/example/myapp/Main.java [3]: import java.util.concurrent.FutureTask; com/example/myapp/Db.java [1]: import java.sql.Connection; com/example/myapp/Db.java [2]: import java.sql.PreparedStatement; ...`},{url:"/p/prbp2g2/",title:"CSS のフローティングボックス (float) を利用したレイアウトを理解する",date:"2015-10-25T00:00:00+09:00",body:"CSS のフローティングボックス (float) を利用したレイアウトを理解する float プロパティにより後続要素を回りこませる CSS の float プロパティには次のような値を指定することができます。 float: none; /* デフォルト */ float: left; /* フローティングボックスを構成して左端に配置 */ float: right; /* フローティングボックスを構成して右端に配置 */ float プロパティに left を設定すると、その要素は左端に表示され、後続の要素はその反対側（この場合は右側）に回り込んで表示されるようになります。 float を指定しない場合 float: none; デフォルトでは、ブロック要素の後続の要素は別の段落に表示さます。 float: left を指定した場合 float: left; float プロパティに left や right を指定すると、後続の要素は、 回り込んで表示されるようになります。 フローティングボックスの形成 float プロパティに left や right を設定した場合、その要素は フローティングボックス を形成します。 後続の要素は、フローティングボックスが存在しないとして配置されるので、横幅いっぱいのサイズが確保されます。 下記の例は、後続要素に青色の背景色を付けたサンプルです。 float: left; フローティングボックスは 後続要素から見ると あたかもそこには存在しない かのように配置されます。 後続要素の横幅は、フローティングボックスに重なる形で画面いっぱいのサイズになっていることが分かります。 この場合でも、実際に表示されるテキストは重ならないように考慮して描画されることになっています。 フローティングボックスの回りこみの解除 (clear) フローティングボックスの後続の要素は、フローティングボックスに対して回りこむように配置されていきます。 その回りこみを解除して、新しい段落に表示したい場合は、clear プロパティを指定します。 clear: none; /* 回りこみを解除しない（デフォルト） */ clear: left; /* 左側のフローティングボックスへの回りこみを解除 */ clear: right; /* 右側のフローティングボックスへの回りこみを解除 */ clear: both; /* 全てのフローティングボックスへの回りこみを解除 */ clear を指定しない場合 float: left; 後続の 1 つ目の要素 後続の 2 つ目の要素 clear: left; を指定した場合 float: left; 後続の 1 つ目の要素 後続の 2 つ目の要素 (clear: left;) CSS の float プロパティは、この clear 指定を後続の要素に対して指定する必要があるため、レイアウトが難しくなってしまうという欠点があります。 段組を構成したい場合は、CSS3 のグリッドレイアウトやマルチカラムの仕組みを使うことで、よりシンプルにレイアウトを作成することができます。 連続するフローティングボックス float:left を連続して配置 float: left; を設定した要素を連続して配置すると、それら全てのフローティングボックスを回りこむように後続の要素が配置されます。 float: left; float: left; 連続するフローティングボックス が配置されていると、 後続の要素は、 それらすべてを回りこむように配置されます。 float:left と float:right を配置 float プロパティを left に設定した要素と、right に設定した要素を連続して配置すると、それぞれ左側と右側にフローティングボックスが配置されます。 float: left; float: right; 左右にそれぞれフローティングボックスを配置することもできます。 この構成は、昔はサイトヘッダーやサイドバーの表示のためによく使われましたが、現在では代わりにフレックスボックスレイアウトが使われることが多くなっています。"},{url:"/p/xwxdv6y/",title:"Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当）",date:"2015-10-21T00:00:00+09:00",body:"Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当） Git はファイルの所有者情報なのどメタ情報を管理しませんが、ファイルの実行可能ビットだけは記録する ようになっています（Linux の chmod +x で付加するビット）。 例えば、Windows 上で Linux のシェルスクリプトを作成していて、Git リポジトリにコミットするときは、次のように git update-index コマンドで実行可能ビットを付加してからコミットしなければいけません。 シェルスクリプトに実行可能ビットを付ける $ git update-index --add --chmod=+x &lt;filename&gt; $ git commit Linux 上で作業する場合は、chmod +x で付加した情報が反映されるので、通常通り git add でファイルを追加するだけで OK です。"},{url:"/p/xi5nrtd/",title:"Linuxメモ: シェルスクリプト: シェル変数/環境変数がセットされているか調べる",date:"2015-10-16T00:00:00+09:00",body:"Linuxメモ: シェルスクリプト: シェル変数/環境変数がセットされているか調べる 変数がセットされていることを調べる 下記の例では、変数 NAME がセットされているかどうか調べています。 sample.sh #!/bin/bash if [ -n &#34;$NAME&#34; ]; then echo $NAME fi 実行例 $ ./sample.sh $ NAME=maku ./sample.sh maku 変数がセットされていないことを調べる 下記の例では、変数 NAME がセットされていないことを調べています。 sample.sh #!/bin/bash if [ -z &#34;$NAME&#34; ]; then echo &#39;NAME is not set&#39; fi 実行例 $ ./sample.sh NAME is not set $ NAME=maku ./sample.sh 仕組みの解説 test や [ ... ] 構造で使用できる演算子に下記のようなものがあります。 -z 文字列 - 文字列の長さが 0 の場合に真 -n 文字列 - 文字列の長さが 0 でない場合に真 変数の値を &quot;$NAME&quot; という構文で確実に文字列になるように展開し、上記の演算子でその文字列の長さをチェックすることにより、変数がセットされている（あるいはセットされていない）ことを調べることができます。"},{url:"/p/8k5m4k2/",title:"ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk)",date:"2015-10-09T00:00:00+09:00",body:"ダウンロード可能な Android SDK コンポーネントの一覧を取得する (android list sdk) Android SDK に付属している android コマンドの list sdk サブコマンドを使用すると、追加でインストール可能な SDK コンポーネントの一覧を取得することができます。 インストール可能な SDK コンポーネント $ android list sdk --no-ui --all --extended ... ---------- id: 157 or &#34;extra-google-usb_driver&#34; Type: Extra Desc: Google USB Driver, revision 11 By Google Inc. USB Driver for Windows, revision 11 Install path: extras\\google\\usb_driver ---------- id: 158 or &#34;extra-google-webdriver&#34; Type: Extra Desc: Google Web Driver, revision 2 By Google Inc. WebDriver Install path: extras\\google\\webdriver ---------- id: 159 or &#34;extra-intel-Hardware_Accelerated_Execution_Manager&#34; Type: Extra Desc: Intel x86 Emulator Accelerator (HAXM installer), revision 5.5 By Intel Corporation Emulation speedup using Intel? VT processor technology. Read more at www.intel.com/software/android Install path: extras\\intel\\Hardware_Accelerated_Execution_Manager 例えば、以下のようなコンポーネントがリストアップされます。 実行結果の抜粋 id: 4 or &#34;build-tools-23.0.1&#34; id: 25 or &#34;android-23&#34; id: 64 or &#34;sys-img-armeabi-v7a-android-tv-23&#34; id: 100 or &#34;addon-google_apis-google-23&#34; id: 133 or &#34;source-23&#34; id: 143 or &#34;extra-Sony-DeviceProfiles&#34; id: 145 or &#34;extra-android-support&#34; id: 157 or &#34;extra-google-usb_driver&#34;"},{url:"/p/494ernf/",title:"GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する",date:"2015-10-01T00:00:00+09:00",body:"GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する GitHub の Organization アカウントの新しいパーミッションモデルが公開されました。 参考: New organization permissions now available - The GitHub Blog チームメンテナの設定が可能 チーム内のメンバーに対して、team maintainer という役割を設定できるようになりました（念願！）。 これまでは、各チームに対するメンバー追加を行うときは、Organization の Owners メンバーが追加作業を行う必要がありましたが、この機能によって、チーム内のメンバー管理は、そのチームの代表者 に任せることができるようになります。 チーム内のメンバーを team maintainer に割り当てるには次のようにします。 Organization のトップページから Teams を選択 対象のチームを選択 チームメンテナに設定したいメンバーを選択し、&ldquo;Change role&hellip;&rdquo; → &ldquo;Maintainer&rdquo; を選択 チームメンテナとなったメンバーは、自分の管理するチームに対して、自由にメンバーを参加させたり外したりできます。 チーム名の変更や、チーム内メンバーのチームメンテナへの昇格も自由に行えるようになるため、ある程度責任のあるリーダクラスの人をチームメンテナとして設定すべきです。 参考: Giving &ldquo;team maintainer&rdquo; permissions to an organization member Organization 内のリポジトリに対するデフォルトパーミッションを設定可能 デフォルトパーミッションとして Read/Write 権限を付加しておくことで、Organization 内のメンバー全員に対して、すべてのプロジェクト（リポジトリ）の参照権限、コミット権限を付けることができます。 例えば、直接コミットできるメンバーはプロジェクトごとに限定したいけれど、コードの参照や PullRequest くらいは全メンバーに許可したい、ということが簡単に実現できます（これまでは、プロジェクトに対する参照権限を与えるために、対象のユーザを Read 権限のあるチームに追加させ、そのチームをプロジェクトに登録する、という分かりにくい作業が必要でした）。 メンバー全員に全リポジトリの参照権限を付けるには以下のようにします。 Organization のトップページから Settings を選択 Member privileges を選択 Base permissions の項目を No permission から Read に変更 全メンバーが全プロジェクトの開発に関わっているような Organization では、デフォルトのパーミッションとして Write を設定しておけば、アクセス権限管理のためにチームを作成する必要がなくなります。 チームをまたいだコラボレーションが可能 Organization 内の別のチームのメンバーに対しても自由にコメントできるようになりました（推奨設定: ON）。 PullRequest や Issue などで議論する際に、別のチームのメンバーに対しても @name の形式で通知 できます。 従来のチームの Visible 設定は Secret になっているので、チーム間のコラボレーションを可能にするために、Visible 設定を Visible に変更する必要があります。 Organization のトップページから Teams を選択 対象のチームを選択 Settings ボタンをクリック Team visibility 設定を Visible に変更 メンバーごとのアクセス権を確認可能 各メンバーが、それぞれのリポジトリに対してどのようなアクセス権限（Admin/Write/Read) を持っているかを、一覧で確認することができるようになりました。 Organization のトップページから People を選択 対象のユーザの設定ボタン → Manage を選択 参考: Managing an individual&rsquo;s access to an organization repository Organization 内のリポジトリの作成権限を追加 Owners メンバーでなくても、Organization 内にプロジェクトを自由に作成することができるようになりました。 Organization のトップページから Settings を選択 Member privileges を選択 Repository creation で必要に応じて下記にチェックを入れる Public &hellip; パブリックなリポジトリの作成を許可する Private &hellip; プライベートなリポジトリの作成を許可する Billing information などの管理はさせたくないけれど、プロジェクト作成くらいは各メンバーに自由にさせたいような場合に有効です。 Organization 外のメンバーをプロジェクトメンバーに追加することが可能 今までは、Organization 内のリポジトリ（プロジェクト）に対するアクセス権限は、Organization 内のチーム単位で与える仕組みでしたが、個人単位、かつ、Organization 外のユーザに対しても権限を与えることができるようになりました。 Organization のトップページから Repositories を選択し、対象のリポジトリをクリック プロジェクトの Settings を選択 Collaborators and teams を選択 Collaborators に GitHub のアカウント名やメールアドレスを指定して追加 この機能を使用すると、Private なリポジトリに対しても外部のユーザからのアクセスを許可できてしまうので、Confidential な情報を扱っている場合は注意して設定する必要があります。 ちなみに、Organization 外のメンバーとして誰が登録されているかは、People 一覧のページの Outside collaborators というところから確認できます。"},{url:"/p/tesecus/",title:"Gradle で JUnit のカバレッジレポートを生成する (JaCoCo)",date:"2015-09-25T00:00:00+09:00",body:"Gradle で JUnit のカバレッジレポートを生成する (JaCoCo) JaCoCo Plugin を使用すると、JUnit などによるユニットテスト結果のカバレッジレポートを生成することができます。 カバレッジレポートは、そのままブラウザで見ることのできる HTML 形式や、Jenkins などの CI サーバで扱う exec データなどの形式で出力できます。 Gradle JaCoCo Plugin 図: HTML 形式の JaCoCo カバレッジレポートの例 下記は jacoco というタスクを定義する例です。 build.gradle apply plugin: &#39;java&#39; apply plugin: &#39;jacoco&#39; repositories { mavenCentral() } dependencies { testCompile &#39;junit:junit:4.+&#39; } jacoco { toolVersion = &#34;0.7.+&#34; // reportsDir = file(&#34;$buildDir/reports/jacoco&#34;) } task jacoco(type: JacocoReport, dependsOn: &#39;test&#39;) { sourceSets sourceSets.main executionData = files(tasks.jacocoTestReport.executionData) reports { html.enabled = true xml.enabled = true csv.enabled = true } } カバレッジレポートを生成するには、ユニットテストの結果が必要なので、jacoco タスクは test タスクに依存するように定義しています。 テストカバレッジを生成するには、下記のように実行します。 $ gradle jacoco :compileJava :processResources UP-TO-DATE :classes :compileTestJava :processTestResources UP-TO-DATE :testClasses :test :jacoco BUILD SUCCESSFUL Total time: 8.697 secs タスクの実行に成功すると、下記のようなファイルが生成されます。 build/jacoco/test.exec &hellip; Jenkins の JaCoCo プラグインなどで使用 build/reports/jacoco/jacoco/html/index.html &hellip; ブラウザ表示用のレポート build/reports/jacoco/jacoco/jacoco.csv &hellip; CSV 形式のレポート build/reports/jacoco/jacoco/jacoco.xml &hellip; XML 形式のレポート ちなみに、Jenkins の JaCoCo プラグインなどでカバレッジレポートを生成する場合は、上記のタスクで生成した exec ファイルのフォーマットと、Jenkins のプラグインが想定するフォーマットのバージョンが合っていないとうまくカバレッジレポートが生成されない（0% になってしまう）ので、Jenkins と連携させる場合は、下記のように明確にバージョン指定しておいた方がよいです。 jacoco 0.7.4 と 0.7.5 ではフォーマットが変わっていてハマりました。 jacoco { toolVersion = &#39;0.7.4.201502262128&#39; } おまけ: Android の場合 通常の Java プロジェクトではなく、Android プロジェクトのユニットテスト結果に対するレポートを作成するには、例えば以下のような感じで定義します。 java プラグインの代わりに com.android.application プラグインを読み込んでいるところ、test タスクの代わりに testDebug タスクに依存するようにするところなどが異なります。 build.gradle（Android アプリの場合） apply plugin: &#39;com.android.application&#39; apply plugin: &#39;jacoco&#39; android { /* 省略 */ } jacoco { toolVersion = &#34;0.7.+&#34; } task jacoco(type: JacocoReport, dependsOn: &#39;testDebug&#39;) { reports { xml.enabled = true html.enabled = true } classDirectories = fileTree( dir: &#39;./build/intermediates/classes/debug&#39;, excludes: [&#39;**/R.class&#39;, &#39;**/R$*.class&#39;, &#39;**/BuildConfig.class&#39;, ]) sourceDirectories = files(&#39;src/main/java&#39;) executionData = files(&#39;build/jacoco/testDebug.exec&#39;) }"},{url:"/p/x6f9r2o/",title:"Gradle で JUnit によるユニットテストを実行する",date:"2015-09-24T00:00:00+09:00",body:"Gradle で JUnit によるユニットテストを実行する JUnit の設定とテストコードの作成 Java プロジェクトにおいて JUnit を使ったユニットテストコードを記述するには、build.gradle スクリプトに下記のように JUnit 用の設定を行っておきます。 build.gradle apply plugin: &#39;java&#39; repositories { mavenCentral() } dependencies { testCompile &#39;junit:junit:4.+&#39; } テスト対象のプロダクトコードとそのテストコードは、下記のようなディレクトリ構成で配置します。 src/main/java/com/example/Sample.java &hellip; プロダクトコード src/test/java/com/example/SampleTest.java &hellip; テストコード Sample.java（実装例） package com.example; public class Sample { public static int add(int a, int b) { return a + b; } } SampleTest.java（実装例） package com.example; import org.junit.Test; import static org.junit.Assert.*; public class SampleTest { @Test public void testAdd() { assertEquals(3, Sample.add(1, 2)); } } ちなみに、JUnit 4.x 系では上記のようにアノテーションを使って記述しますが、JUnit 3.x までは下記のように TestCase クラスを継承する形で記述していました。 後方互換性のため、JUnit 4.x を使っている場合でも、下記のように記述することができます。 package com.example; import junit.framework.TestCase; public class SampleTest extends TestCase { public void testAdd() { assertEquals(3, Sample.add(1, 2)); } } テストの実行 テストコードのビルド＆実行は、test タスクにより実行することができます。 $ gradle test :compileJava :processResources UP-TO-DATE :classes :compileTestJava :processTestResources UP-TO-DATE :testClasses :test BUILD SUCCESSFUL Total time: 6.226 secs もちろん、テストに失敗すればエラーが表示されます。 $ gradle -q test 1 test completed, 1 failed FAILURE: Build failed with an exception. ... 実行結果からも分かるように、test タスクを実行すると、テストの実行に先立って、プロダクトコードのコンパイル (classes) とテストコードのコンパイル (testClasses) が実行されます。 テストが完了すると、下記のようなディレクトリにファイルが出力されます。 build/classes/test/ &hellip; コンパイルされたテストクラス build/test-results/ &hellip; XML 形式のテスト結果（Jenkins などで使用） build/reports/tests/ &hellip; HTML 形式のテスト結果（ブラウザでの確認用） Gradle は HTML 形式で見やすいレポートを出力してくれます。 build/reports/tests/index.html をブラウザで開けば、詳細なレポートを確認できます。 図: HTML によるテストレポート出力 実行されるテスト test タスクを実行したときに実行されるテストは下記のようなものです。 @Test でアノテートされたメソッド（JUnit と TestNG のどちらも認識する） @RunWith でアノテートされたクラス junit.framework.TestCase や groovy.util.GroovyTestCase を継承したクラス (JUnit 3.x) 特定のテストクラスだけを実行することもできます。 test.single というシステムプロパティで、クラス名のパターンを指定して test タスクを実行することにより、パターンに一致したテストクラスだけが実行されます。 下記の例では、クラス名が LargeTest で終わるテストクラスだけを実行しています。 $ gradle -Dtest.single=**/*LargeTest test"},{url:"/p/8ot95rq/",title:"Gradle でユニットテストの結果をコンソールに詳しく表示する",date:"2015-09-24T00:00:00+09:00",body:"Gradle でユニットテストの結果をコンソールに詳しく表示する Gradle でのユニットテストの実行結果が失敗の場合、デフォルトでは下記のようなそっけない表示しかしてくれません。 $ gradle test ... com.example.LargeTest &gt; testAdd FAILED java.lang.AssertionError at SampleTest.java:9 2 tests completed, 1 failed build/reports/tests 以下に生成されるテストレポートを見れば、その内容を確認できますが、コンソール上でもう少し詳しい結果を確認したい場合は、-i オプションを指定してログレベルを INFO に設定して test タスクを実行します。 $ gradle test -i ... com.example.SampleTest &gt; testAdd FAILED java.lang.AssertionError: expected:&lt;4&gt; but was:&lt;3&gt; at org.junit.Assert.fail(Assert.java:88) at org.junit.Assert.failNotEquals(Assert.java:834) at org.junit.Assert.assertEquals(Assert.java:645) at org.junit.Assert.assertEquals(Assert.java:631) at com.example.SampleTest.testAdd(SampleTest.java:9) 1 test completed, 1 failed ... ただし、INFO レベルでログを出力すると、余計な出力が多く出てしまって見づらくなります。 build.gradle スクリプトの中で、下記のように exceptionFormat を指定しておくと、上記のような例外部分だけを詳しく表示してくれるようになります（この場合 -i オプションを付けて test タスクを実行する必要はありません）。 test { testLogging { exceptionFormat &#39;full&#39; } } デフォルトではメソッドごとのテスト経過は表示されませんが、テスト経過をコンソール上で詳しく確認したい場合は、下記のように events 設定を行います。 test { testLogging { events &#39;started&#39;, &#39;skipped&#39;, &#39;passed&#39;, &#39;failed&#39; } } この状態で test タスクを実行すると、それぞれのメソッドごとにテストの経過を確認できるようになります。FAILED や PASSED などのイベント名は実際には分かりやすく色付きで表示されます。 $ gradle test ... com.example.LargeTest &gt; testAdd STARTED com.example.LargeTest &gt; testAdd FAILED java.lang.AssertionError at LargeTest.java:9 com.example.SampleTest &gt; testAdd STARTED com.example.SampleTest &gt; testAdd PASSED 2 tests completed, 1 failed"},{url:"/p/pxkr6wv/",title:"Gradle でユニットテストを並列実行する (test.forkEvery, test.maxParallelForks)",date:"2015-09-24T00:00:00+09:00",body:"Gradle でユニットテストを並列実行する (test.forkEvery, test.maxParallelForks) Gradle によるユニットテスト実行は、デフォルトではシーケンシャルに 1 つずつ行われていきます。 テストクラス数が多くなった場合は、並列実行することによって全体のテストにかかる時間を減らすことができます。 test.forkEvery と test.maxParallelForks でテスト実行用のプロセスをどう fork するかを制御することができます。 test.forkEvery &hellip; 何個のクラスごとにテストプロセスを fork するか（どのくらい積極的に並列化するか） test.maxParallelForks &hellip; 最大何個のテストプロセスを fork するか（最大並列実行数） 下記の例では、「CPU数−1」個まで同時実行することと、クラス 4 つごとにプロセスを fork することを指定しています。 例えば、クラスが 10 個あれば、3 つのプロセスが作成されます（1 つのプロセスで 4 クラスまで担当するから）。 build.gradle test { int cpus = Runtime.runtime.availableProcessors() maxParallelForks = cpus &gt; 1 ? cpus - 1 : 1 forkEvery = 4 }"},{url:"/p/84xtqff/",title:"JUnit の代わりに TestNG を使ってユニットテストを実行する",date:"2015-09-24T00:00:00+09:00",body:"JUnit の代わりに TestNG を使ってユニットテストを実行する JUnit の代わりに TestNG（テスティング） を使ってユニットテストを記述したい場合は、build.gradle スクリプトを下記のように書き換えます。 build.gradle apply plugin: &#39;java&#39; repositories { mavenCentral() } dependencies { testCompile &#39;org.testng:testng:6.+&#39; } test.useTestNG() ディレクトリ構成や、test タスクで実行できるところは JUnit を使う場合と変わりありません。 最後に test.useTestNG() の呼び出しが必要なことに注意してください。"},{url:"/p/y4ezh5u/",title:"テストピラミッドを意識してテストの自動化を進める",date:"2015-09-24T00:00:00+09:00",body:"テストピラミッドを意識してテストの自動化を進める Mike Cohn が『Succeeding with Agile』で紹介した test automation pyramid というものがあります。 テストの自動化を進めるときは、このような比率になるように構築していくと、効率のよいテストを行えるようになります。 一言でいうと、UI のテストと比べ、ユニットテストの方が費用対効果 (ROI: Return on Investment) が高いということです。 ヒューリスティックな要素が入り込む End-to-End のテストは、頑張って自動化しても、思ったほどの効果が得られないことが多くなります。 テスト記述にかかるコスト、メンテナンスにかかるコストなどを総合的に判断すると、ユニットテストの比率を最も大きくし、その次に統合テスト、最後に End-to-End (UI) テストの順になるようにテスト配分を考えるべきです。 Google も下記のような比率で考えるとよいといっています。 10%: UI test (end-to-end test) 20%: Integration test (components and services) 70%: Unit test ごく当たり前のように感じる構成ですが、開発の現場でよく見られるのは、テスト専門チームによるテストに頼ってしまう逆ピラミッド型 (inverted pyramid/ice cream cone) の構成です。 70%: UI test (end-to-end test) 20%: Integration test (components and services) 10%: Unit test リファクタリングの技術、ユニットテストの技術を向上させ、理想的なピラミッド型のテスト配分に近づけていくことで、ソフトウェアの品質は上がっていきます。"},{url:"/p/ta2kimu/",title:"Viewport とメディアクエリによるレスポンシブ Web デザインの基本",date:"2015-09-22T00:00:00+09:00",body:"Viewport とメディアクエリによるレスポンシブ Web デザインの基本 Web サイトのレイアウトは、様々な端末、画面サイズで表示されることを想定して作成しなければいけません。 スマホやタブレット、テレビのように物理的に画面サイズが異なることもありますし、PC 上の Web ブラウザのように、ウィンドウサイズがユーザによって自由に変更されることもあります。 スマホやタブレットに備えられている Viewport の機能や、CSS3 の メディアクエリ の仕組みを利用すると、こういった様々な条件での表示に、柔軟に対応することができます。 Viewport の設定 Viewport はスマホなどの物理的に画面が小さいモバイル端末に備えられている機能で、Web ページを部分的に表示するための仮想画面を提供する機能です。 Viewport 設定は、head セクション内に配置する meta 要素で行います。 基本的な viewport 設定 &lt;head&gt; &lt;!-- 省略 --&gt; &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1&#34;&gt; &lt;/head&gt; content 属性内で width=device-width と設定しておくことにより、デバイスごとに設定された仮想的な横幅 (device-width) が、Viewport の幅として設定されます。 つまり、デバイスの画面サイズに合わせてコンテンツを表示します。 デバイスの幅に合わせることで、ユーザーがズーム操作をせずにコンテンツを見ることができるようになります。 スマホの場合は、device-width は、320 〜 360px 程度に設定されていることが多いようです（参考サイト）。 この横幅は、後述するメディアクエリの width 判定にも影響します。 initial-scale はページが最初に読み込まれたときのズームレベルで、0 〜 10 の間で指定します。 initial-scale=1 は、通常のズームレベルでページを表示することを意味します。 これにより、ユーザーがページを開いたときにズームアウトまたはズームインする必要がなくなります。 メディアクエリの設定 CSS3 のメディアクエリの仕組みを使用すると、画面の表示サイズに応じて CSS を切り替えることができます。 CSS /* デフォルトのスタイル（300px 未満） */ body { background: pink; } /* 画面幅が 300px 以上の場合のスタイル */ @media screen and (min-width: 300px) { body { background: lightblue; } } /* 画面幅が 600px 以上の場合のスタイル */ @media screen and (min-width: 600px) { body { background: lightgreen; } } （別ページで開く） 上記の例では、画面の幅が 300px 以上になったとき、600px 以上になったときに背景色を変更しています。 1px ～ 299px &hellip; 赤 (pink) 300px ～ 599px &hellip; 青 (lightblue) 600px ～ &hellip; 緑 (lightgreen) この仕組みを使って、画面サイズが変更されたときにレイアウトを変更することで、レスポンシブ Web デザインを実現できます。 CSS 内の @import ディレクティブでもメディアタイプを指定することができます。 TV 上での表示あるいは印刷時の CSS を指定 @import url(&#34;tv_and_print.css&#34;) tv, print; link 要素で外部の CSS ファイルを読み込む場合も、メディアクエリで CSS を切り替えることができます。 /* 画面表示用 or 印刷用 */ &lt;link rel=&#34;stylesheet&#34; media=&#34;screen&#34; href=&#34;screen.css&#34;&gt; &lt;link rel=&#34;stylesheet&#34; media=&#34;print&#34; href=&#34;print.css&#34;&gt; /* 横幅別 */ &lt;link rel=&#34;stylesheet&#34; media=&#34;(max-width: 960px)&#34; href=&#34;max960px.css&#34;&gt; &lt;link rel=&#34;stylesheet&#34; media=&#34;(max-width: 320px)&#34; href=&#34;max320px.css&#34;&gt; &lt;link rel=&#34;stylesheet&#34; media=&#34;screen and (max-width: 480px)&#34; href=&#34;mobile.css&#34; /&gt; /* 縦表示 or 横表示 */ &lt;link rel=&#34;stylesheet&#34; media=&#34;(orientation: portrait)&#34; href=&#34;portrait.css&#34;&gt; &lt;link rel=&#34;stylesheet&#34; media=&#34;(orientation: landscape)&#34; href=&#34;landscape.css&#34;&gt; /* カラー or 白黒 */ &lt;link rel=&#34;stylesheet&#34; media=&#34;screen and (color)&#34; href=&#34;color.css&#34; /&gt; &lt;link rel=&#34;stylesheet&#34; media=&#34;screen and (monochrome)&#34; href=&#34;mono.css&#34; /&gt; 参考リンク: Media Queries - W3C"},{url:"/p/euk9dzr/",title:"プロジェクト内での null の扱い方をルール化する",date:"2015-09-16T00:00:00+09:00",body:"プロジェクト内での null の扱い方をルール化する Java のような null を簡単に扱える言語では、プロジェクト内で null の扱い方を統一しておかないと、NullPointerException のような不具合が多発します（これが Java の大きな欠点ともいえます）。 一方で、C++ などには「参照」という NULL でないことを保証する仕組みが言語的に備えられています。 コード内に null チェックが多いとコードの見通しが悪くなるだけでなく、実行パフォーマンスも悪くなります。 言語として Java などを採用するプロジェクトでは、下記のように null の扱い方に関するルールを定めておきましょう。 パフォーマンスに問題がない場合は null フリーなコードを目指すことをお勧めします。 null の扱いに関するルールの例 API ドキュメントに特に記載がない場合は 「パラメータには null を渡せない」 こととする null を渡せる場合は明確にドキュメントに記載し、どんな作用があるのか分かるようにすること メソッドの内部で不要なパラメータの null チェックをしないこと API ドキュメントに特に記載がない場合は 「null を返すのは禁止」 とする どうしても null を返さなければいけない場合は、必ずドキュメントやアノテーションで記載すること（null を返さない場合でも、アノテーションなどで表現しておくのが望ましい） リストや配列を返すメソッドは「null を返さずにサイズ 0 のオブジェクトを返す」こと（空リストを返すのか null を返すのかはドキュメントで明示すること） リスト以外のオブジェクトを返すメソッドでは「不用意に null を返さず Null Object を返す」ことを検討すること null を返さないことが分かっているメソッドの戻り値に対して、不要な null チェックをしないこと アノテーションを利用する 例えば、Android では、@NonNull や @Nullable といったアノテーションが用意されており、パラメータの null の扱い、戻り値の null の扱いを明確に示すことができます。 アノテーションによるコード検査の改善 | Android Studio | Android Developers"},{url:"/p/pz9gz3h/",title:"Gradle で PMD による静的解析を実行する",date:"2015-09-14T00:00:00+09:00",body:"Gradle で PMD による静的解析を実行する PMD プラグインの基本 Gradle には標準の静的解析プラグインとして、PMD が組み込まれています。 PMD でソースコードを解析すると、潜在的な不具合や、複雑度が高く将来的に負債になりそうなコードを検出することができます。 よい設計やコーディングができているかが一目瞭然になりますので、すべての Java プロジェクトに採用したいところです。 Gradle - PMD Plugin PMD PMD と似たような静的解析ツールに FindBugs がありますが、FindBugs がコンパイル後のクラスコードに対する解析であるのに対し、PMD はコンパイル前のソースコードを解析します。 無駄なコードはコンパイルの段階で最適化されて削除されてしまうことがあるため、このような無駄なコードを発見するためには、PMD で解析することが必要になります。 また、本家の PMD はコードクローンの発見などの機能 (CPD: Copy/Paste Detector) も備えていますが、Gradle の PMD プラグインはまだ CPD の直接サポートはされていないようです (2015-09-14)。 PMD の設定 PMD による静的解析を実施するには、下記のような感じで pmd プラグインを読み込んで設定します。 build.gradle apply plugin: &#39;java&#39; apply plugin: &#39;pmd&#39; repositories { mavenCentral() } // PMD のコンフィギュレーション pmd { toolVersion &#39;5.3.3&#39; // 使用する PMD のバージョン ignoreFailures = true // PMD で警告が出てもビルドエラーにしない consoleOutput = true // コンソールにも解析結果を出力 ruleSets = [ // 適用する PMD ルール（プロジェクトごとに要調整） &#39;java-basic&#39;, // good practices which should be followed &#39;java-braces&#39;, // regarding the use and placement of braces &#39;java-clone&#39;, // questionable usages of the clone() method &#39;java-codesize&#39;, // problems related to code size or complexity &#39;java-design&#39;, // flag suboptimal code implementations &#39;java-empty&#39;, // empty statements of any kind &#39;java-finalizers&#39;, // problems that can occur with finalizers &#39;java-imports&#39;, // problems that can occur with import statements &#39;java-strictexception&#39;, // strict guidelines about throwing and catching exceptions &#39;java-strings&#39;, // manipulation of the String, StringBuffer, or StringBuilder instances &#39;java-sunsecure&#39;, // check the security guidelines from Sun &#39;java-typeresolution&#39;, // rules which resolve java Class files for comparison &#39;java-unnecessary&#39;, // find useless or unnecessary code &#39;java-unusedcode&#39; // find unused or ineffective code ] } PMD プラグインによって、pmdMain や pmdTest などのタスクが定義されます。 これらのタスクは、check タスクに依存するタスクとして定義されるので、check タスクを定義する java プラグインも読み込んでおく必要があります。 pmdMain タスク（製品コード src/java/main に対する解析） pmdTest タスク（テストコード src/java/test に対する解析） PMD による解析の実行 PMD による静的解析を行うには、pmdMain あるいは check タスクを実行します。 $ gradle pmdMain :pmdMain 11 PMD rule violations were found. See the report at: /home/maku/myapp/build/reports/pmd/main.html BUILD SUCCESSFUL PMD による解析結果は、下記のようなパスに出力されます。 build/reports/pmd/main.html &hellip; Web ブラウザで確認できる HTML 形式レポート build/reports/pmd/main.xml &hellip; Jenkins など CI サーバで統計を取るための XML データ マルチプロジェクトで PMD を使用する マルチプロジェクト構成のプロジェクトでは、サブプロジェクト内で共通の PMD 設定を参照できると便利です。 ここでは、共通の PMD 設定を pmd.gradle というファイルで定義し、すべてのサブプロジェクトに適用してみます。 gradle/pmd.gradle apply plugin: &#39;pmd&#39; pmd { toolVersion &#39;5.3.3&#39; ignoreFailures = true ruleSets = [ &#39;java-basic&#39;, // good practices which everyone should follow &#39;java-braces&#39;, // braces rules &#39;java-clone&#39;, // questionable usages of the clone() method &#39;java-codesize&#39;, // find code size, complexity problems &#39;java-design&#39;, // questionable designs ... ] } ルートプロジェクトのビルドスクリプト (build.gradle) 内で、下記のように subproject を使ってすべてのサブプロジェクトに適用します。 build.gradle subprojects { apply plugin: &#39;java&#39; apply from: &#34;$rootDir/gradle/pmd.gradle&#34; repositories { mavenCentral() } } PMD ルールセットいろいろ PMD で設定できるルールセットは、他にもいろいろ定義されています。 必要に応じて有効にしたいルール java-android （Android related best practice） java-j2ee （J2EE アプリ用） java-junit （JUnit のコード用） java-logging-jakarta-commons （Logger 用） java-logging-java （Logger 用） あまり使わなさそうなルール java-controversial （異論のあるルールが多い） java-naming （命名規則が厳しすぎ） java-optimizations （final を強制しすぎ） PMD のルールを XML ファイルで定義する PMD のルールセットは、XML 形式の別ファイルに定義しておくことができます。 複数のプロジェクトで使用するルールセットを定義する場合は、このように設定ファイルとして作成して共有するのがよいでしょう。 ここでは、プロジェクトのルートディレクトリに config/pmd-settings.xml として配置することにします。 ルールセットファイルのサンプル (config/pmd-settings.xml) Gradle スクリプトの中では、下記のように ruleSetFiles でルールセットの XML ファイルを指定します。 gradle/pmd.gradle apply plugin: &#39;pmd&#39; pmd { toolVersion &#39;5.3.3&#39; ignoreFailures = true consoleOutput = true ruleSetFiles = files(&#34;$rootDir/config/pmd-settings.xml&#34;) ruleSets = [] // To apply only the custom rules } ポイントは、ruleSets の方を空っぽにしておくことです。 この指定を忘れると、XML ファイルで定義したルールと、デフォルトのルールの両方が有効になってしまいます（少なくとも上記で使用している ver 5.3.3 では）。 XML ファイルの中で、何らかのルールを無効 (exclude) にしている場合は、忘れずに ruleSets を空にしておかないと、ルールの無効化がうまくいかなかったりします。"},{url:"/p/em3rtg6/",title:"Gradle で Checkstyle による静的解析を実行する",date:"2015-08-10T00:00:00+09:00",body:"Gradle で Checkstyle による静的解析を実行する Checkstyle プラグインの基本 Gradle には標準の静的解析プラグインとして、Checkstyle、PMD、CodeNarc、FindBugs、JDepend などが組み込まれています。 Gradle - Checkstyle Plugin Checkstyle による静的解析を実施するには、下記のように checkstyle プラグインを読み込みます。 build.gradle apply plugin: &#39;java&#39; apply plugin: &#39;checkstyle&#39; repositories { mavenCentral() } checkstyle { toolVersion &#39;6.7&#39; } checkstyle プラグインを適用することによって、checkstyleMain や checkstyleTest などのタスクが定義されます。 これらのタスクは、check タスクに依存するタスクとして定義されるので、check タスクを定義する java プラグインも読み込んでおく必要があります。 また、Checkstyle はバージョンアップごとに微妙に互換性がなくなるので、上記のように checkstyle コンフィギュレーションで、使用する Checkstyle のバージョンを指定しておくのがよいでしょう。 Checkstyle プラグインは、デフォルトで Checkstyle の設定ファイルとして ${projectDir}/config/checkstyle/checkstyle.xml を読み込むので、まずはここにプロジェクトで使用する Checkstyle の設定を置いておく必要があります。 デフォルトの構成に従うと、こんな感じのディレクトリ構成になります。 +-- build.gradle +-- config/ | +-- checkstyle/ | +-- checkstyle.xml （Checkstyle の設定ファイル） +-- src/ +-- main/ +-- java/ +-- com/ +-- example/ +-- Main.java （静的解析対象のソースコード） checkstyleMain あるいは check タスクを実行すると、Checkstyle による静的解析が実行されます。 $ gradle -q check [ant:checkstyle] D:\\sample\\src\\main\\java\\com\\example\\Main.java:0: warning: Missing package-info.java file. ... Checkstyle による解析結果は、下記のようなパスに出力されます。 build/reports/checkstyle/main.html &hellip; Web ブラウザで確認できる HTML 形式レポート build/reports/checkstyle/main.xml &hellip; Jenkins など CI サーバで統計を取るための XML データ Checkstyle の設定メモ Checkstyle 設定ファイルを指定する Checkstyle プラグインは、デフォルトで config/checkstyle/checkstyle.xml を読み込みますが、下記のようにして使用する設定ファイルを変更することができます。 checkstyle { configFile file(&#34;$rootDir/config/my-checkstyle.xml&#34;) ... } Checkstyle による警告が出た場合もビルドを継続する checkstyle { ignoreFailures true // continue build if there are warnings ... } マルチプロジェクトで Checkstyle を使用する マルチプロジェクト構成のプロジェクトでは、サブプロジェクト内で共通の Checkstyle 設定を使用できると便利です。 ここでは、共通の Checkstyle 設定を下記のように定義し、すべてのサブプロジェクトに適用してみます。 gradle/checkstyle.gradle apply plugin: &#39;checkstyle&#39; checkstyle { toolVersion &#39;6.7&#39; configFile file(&#34;$rootDir/config/checkstyle.xml&#34;) ignoreFailures true } そして、ルートプロジェクトのビルドスクリプト内で、下記のようにロードすれば OK です。 build.gradle subprojects { apply plugin: &#39;java&#39; apply from: &#34;$rootDir/gradle/checkstyle.gradle&#34; repositories { mavenCentral() } }"},{url:"/p/hg9n9wd/",title:"Gradle のマルチプロジェクトで依存関係を扱う (dependencies, compile)",date:"2015-08-04T00:00:00+09:00",body:"Gradle のマルチプロジェクトで依存関係を扱う (dependencies, compile) マルチプロジェクトビルドにおいて、別のサブプロジェクトが生成するクラスへの依存があることを示したい場合は、dependencies ブロックで依存先のプロジェクトを指定します。 例えば、下記のように、2 つのサブプロジェクト (myapp と mylib) で構成されているとします。 プロジェクト構成 root/ +-- build.gradle +-- settings.gradle +-- myapp/ | +-- src/main/java/Main.java +-- mylib/ +-- src/main/java/MyLib.java settings.gradle include &#39;myapp&#39; include &#39;mylib&#39; プロジェクト myapp は、プロジェクト mylib が提供するクラスを参照して実装されています。 myapp/src/main/java/Main.java public class Main { public static void main(String... args) { System.out.println(MyLib.add(100, 200)); } } mylib/src/main/java/MyLib.java public class MyLib { public static int add(int a, int b) { return a + b; } } このように Java のビルドにプロジェクト間の依存関係がある場合は、dependencies ブロック内の compile コンフィギュレーションに対して依存先のプロジェクトを指定します。 build.gradle project(&#39;:myapp&#39;) { apply plugin: &#39;java&#39; dependencies { compile project(&#39;:mylib&#39;) } } project(&#39;:mylib&#39;) { apply plugin: &#39;java&#39; } これで、自動的に myapp プロジェクトから mylib プロジェクトへのクラスパスが設定され、ビルドが通るようになります。 $ gradle -q build ちなみに、上記のようにすべてのサブプロジェクト内で同じコンフィギュレーションを行う部分がある場合は、subprojects メソッドに、共通処理のクロージャとして渡しておくことができます。 ルートプロジェクトを含む共通処理を記述したい場合は、subprojects の代わりに allprojects を使用します。 build.gradle（subprojects で共通処理をまとめる例） subprojects { apply plugin: &#39;java&#39; } project(&#39;:myapp&#39;) { dependencies { compile project(&#39;:mylib&#39;) } } project(&#39;:mylib&#39;) { }"},{url:"/p/8x8qmy3/",title:"protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions)",date:"2015-08-04T00:00:00+09:00",body:"protection レベルが dangerous なパーミッションの一覧を表示する (pm list permissions) pm list permissions コマンドに -d オプションを付けて実行すると、protectionLevel が dangerous に設定されたパーミッションのみを一覧表示してくれます。 Android M からは、dangerous なパーミッションはユーザが個別に On/Off することができるようになったため、どのようなパーミッションが存在しているのかを把握することがより重要になりました。 shell@xxx:/ $ pm list permissions -d Dangerous Permissions: permission:com.android.providers.tv.permission.READ_EPG_DATA permission:com.android.providers.tv.permission.WRITE_EPG_DATA adb shell で接続する前に実行する場合は、上記のコマンドの先頭に adb shell を付けて実行してください。"},{url:"/p/viry8fo/",title:"パーミッショングループの一覧を表示する (pm list permission-groups)",date:"2015-08-04T00:00:00+09:00",body:"パーミッショングループの一覧を表示する (pm list permission-groups) パーミッショングループの一覧 Android 端末内にどのようなパーミッショングループが存在しているかを調べるには、adb shell で接続した後に pm list permission-groups コマンドを使用します。 shell@xxx:/ $ pm list permission-groups permission group:android.permission-group.PHONE_CALLS permission group:android.permission-group.WALLPAPER permission group:android.permission-group.MESSAGES permission group:android.permission-group.USER_DICTIONARY permission group:android.permission-group.CALENDAR permission group:android.permission-group.BLUETOOTH_NETWORK ... adb shell で接続前に実行したい場合は、下記のように adb shell に続けてコマンド入力しても OK です。 ホスト側の PC で出力を sort したい場合などはこちらの方が便利かもしれません。 $ adb shell pm list permission-groups | sort permission group:android.permission-group.ACCESSIBILITY_FEATURES permission group:android.permission-group.ACCOUNTS permission group:android.permission-group.AFFECTS_BATTERY permission group:android.permission-group.APP_INFO permission group:android.permission-group.AUDIO_SETTINGS permission group:android.permission-group.BLUETOOTH_NETWORK ... パーミッショングループに属するパーミッションの一覧 それぞれのパーミッショングループが、どのようなパーミッションから構成されているかを調べるには、pm list permissions -g コマンドを使用します。 shell@xxx:/ $ pm list permissions -g All Permissions: group:android.permission-group.PHONE_CALLS permission:android.permission.BIND_INCALL_SERVICE permission:android.permission.READ_PRECISE_PHONE_STATE permission:android.permission.BIND_CONNECTION_SERVICE ... group:android.permission-group.WALLPAPER permission:android.permission.SET_WALLPAPER permission:android.permission.SET_WALLPAPER_HINTS ..."},{url:"/p/sj6sc4d/",title:"Gradle で Javadoc API ドキュメントを出力する",date:"2015-08-03T00:00:00+09:00",body:"Gradle で Javadoc API ドキュメントを出力する javadoc タスクを使えるようにする Gradle で java プラグインをロードすると、自動的に javadoc タスクが定義されます。 build.gradle apply plugin: &#39;java&#39; 下記のように実行すると、src/main/java 以下の Java ソースコードに記述された Javadoc コメントを元に、build/docs/javadocs に API ドキュメントが生成されます。 $ gradle javadoc javadoc タスクをカスタマイズする javadoc タスクをプロジェクトに合わせてカスタマイズしたい場合は、下記のように Javadoc 型の新しいタスクを定義します。 build.gradle apply plugin: &#39;java&#39; task myJavadoc(type: Javadoc) { group = &#39;Sample&#39; description = &#39;Generates API documents.&#39; source = sourceSets.main.allJava } タスク定義時に type: Javadoc と指定することで、Configuration クロージャの中で参照されるオブジェクト（Closure delegate）が、Task オブジェクトから Javadoc オブジェクトに変わります。 Configuration クロージャ内で Javadoc オブジェクトのメソッドを呼び出すことで、タスクをカスタマイズできるようになっています。 source プロパティの指定は必須であることに注意してください（指定しないと何も生成されません）。 Javadoc 用に新しいタスクを定義するのではなく、既存の javadoc タスクを上書きしてしまいたい場合は、下記のように overwrite オプションを指定します。 task javadoc(type: Javadoc, overwrite: true) { group = &#39;Sample&#39; description = &#39;Generates API documents.&#39; source = sourceSets.main.allJava } Javadoc タスクオブジェクトに他にどのようなプロパティがあるかは、下記の DSL ドキュメントで確認できます。 Javadoc task"},{url:"/p/3g9gimf/",title:"Gradle によるマルチプロジェクトの基本 (settings.gradle)",date:"2015-07-27T00:00:00+09:00",body:"Gradle によるマルチプロジェクトの基本 (settings.gradle) マルチプロジェクトを構成する Gradle では複数のサブプロジェクトを作成し、それらを連携させてビルドすることができます。 サブプロジェクトの構成は、settings.gradle ファイルで記述します。 例えば、下記の設定では、2 つのサブプロジェクト (subproject1, subproject2) から構成されることを示しています。 ここでサブプロジェクトを include する順番は、タスクの実行順序には何も影響を与えません。 settings.gradle rootProject.name = &#39;rootproject&#39; include &#39;subproject1&#39; include &#39;subproject2&#39; Gradle にデフォルトで用意されている projects タスクを実行することで、現在のプロジェクト構成を調べることができます。 $ gradle -q projects ------------------------------------------------------------ Root project ------------------------------------------------------------ Root project &#39;rootproject&#39; +--- Project &#39;:subproject1&#39; \\--- Project &#39;:subproject2&#39; ... サブプロジェクトごとに build.gradle を持つ構成 settings.gradle の include メソッドで指定したサブプロジェクト名は、サブプロジェクトを格納するディレクトリ名に対応しています。 サブプロジェクトの各ディレクトリには、そのプロジェクト用のビルドスクリプト (build.gradle) を格納しておくことができます。 マルチプロジェクトのディレクトリ構成 root/ +-- build.gradle +-- settings.gradle +-- subprojects1/ | +-- build.gradle +-- subprojects2/ +-- build.gradle build.gradle（ルート） task hello &lt;&lt; { println &#39;Hello&#39; } subprojects1/build.gradle task hello1 &lt;&lt; { println &#39;Hello1&#39; } subprojects2/build.gradle task hello2 &lt;&lt; { println &#39;Hello2&#39; } settings.gradle ファイルに記述されたサブプロジェクトは Initialization フェーズで認識され、それぞれのディレクトリ内のビルドスクリプトが読み込まれるようになります。 下記のようにすると、サブプロジェクト内で定義されたタスクもすべて認識されていることが分かります。 $ gradle -q tasks --all ... Other tasks ----------- hello subproject1:hello1 subproject2:hello2 gradle コマンドを実行するとき、settings.gradle ファイルは上位のディレクトリに向かって検索してくれるため、サブプロジェクトのディレクトリにいる場合でも各プロジェクト内のタスクを参照することができます。 ルートプロジェクトのタスクや、別のサブプロジェクト内のタスクを実行したい場合は、下記のように : プレフィックスを付けてどのプロジェクトのタスクなのかを明示的に示す必要があります。 $ cd subproject1 $ gradle -q :hello # ルートプロジェクトのタスクを実行 Hello $ gradle -q :subproject2:hello2 # 別のサブプロジェクトのタスクを実行 Hello2 1 つの build.gradle ファイルでマルチプロジェクトを構成する これまでの例では、各サブプロジェクトのディレクトリに build.gradle スクリプトを格納していましたが、ルートプロジェクトの build.gradle の中で、サブプロジェクトのビルド内容を記述してしまうこともできます。 サブプロジェクトのビルド内容は、project メソッドに渡すクロージャ内で定義します。 build.gradle task hello &lt;&lt; { println &#39;Hello&#39; } project(&#39;:subproject1&#39;) { task(&#39;hello1&#39;) &lt;&lt; { println &#39;Hello1&#39; } } project(&#39;:subproject2&#39;) { task(&#39;hello2&#39;) &lt;&lt; { println &#39;Hello2&#39; } } このような 1 ファイルでの構成をした場合に、サブプロジェクト内にも build.gradle スクリプトが存在する場合、両方のスクリプトが読み込まれます。 よって、同じ名前のタスクを定義したりするとエラーになります。"},{url:"/p/kgwpdtz/",title:"Gradle のタスクに説明を付け、グルーピングする",date:"2015-07-13T00:00:00+09:00",body:"Gradle のタスクに説明を付け、グルーピングする Gradle のタスクを定義するときに group パラメータを指定すると、複数のタスクをグルーピングすることができます。 また、description パラメータを指定すると、タスクに説明文を設定することができます。 これらの設定を行うことで、gradle tasks でタスクを一覧表示したときに、グルーピングされたタスクと説明が表示されるようになります。 下記の例では、hello1 タスクと hello2 タスクを MyGroup にグルーピングし、それぞれのタスクに説明文を設定しています。 build.gradle task hello1(group: &#39;MyGroup&#39;, description: &#39;Description for hello1.&#39;) { doLast { println &#39;Hello 1&#39; } } task hello2(group: &#39;MyGroup&#39;, description: &#39;Description for hello2.&#39;) { doLast { println &#39;Hello 2&#39; } } タスクの Configuration クロージャ内で Task オブジェクトのメソッド (group, description) を呼び出すことでも設定できます。 task hello1 { group &#39;MyGroup&#39; description &#39;Description for hello1.&#39; doLast { println &#39;Hello 1&#39; } } task hello2 { group &#39;MyGroup&#39; description &#39;Description for hello2.&#39; doLast { println &#39;Hello 2&#39; } } Gradle の tasks タスクを実行することで、それぞれのタスクがグルーピングされて表示されることが分かります。 $ gradle -q tasks ... MyGroup tasks ------------- hello1 - Description for hello1 hello2 - Description for hello2 ..."},{url:"/p/6q9wkjm/",title:"既存の Gradle タスクにアクションを追加する (doLast, doFirst)",date:"2015-07-13T00:00:00+09:00",body:"既存の Gradle タスクにアクションを追加する (doLast, doFirst) Gradle の既存のタスクには、自由にアクションを追加していくことができます。 この仕組みにより、サードパーティ製のタスクに対して、前処理や後処理を追加することができます。 タスク内のアクションは、内部的にアクションリストとして保持されており、Task#doLast メソッドや Task#doFirst メソッドを使用して、先頭、あるいは末尾にアクションを追加できます。 アクションを末尾に追加する (doLast) 下記の例では、既存タスク hello のアクションリストの末尾にアクションを追加しています。 build.gradle // タスクの定義 task hello { doLast { println &#39;Hello!&#39; } } // アクションリストの末尾にアクションを追加 hello.doLast { println &#39;Added to last 1&#39; } hello.doLast { println &#39;Added to last 2&#39; } 実行結果 $ gradle -q hello Hello! Added to last 1 Added to last 2 アクションを先頭に追加する (doFirst) 下記の例では、既存タスクのアクションリストの先頭にアクションを追加しています。 build.gradle // タスクの定義 task hello { doLast { println &#39;Hello!&#39; } } // アクションリストの先頭にアクションを追加 hello.doFirst { println &#39;Added to first 1&#39; } hello.doFirst { println &#39;Added to first 2&#39; } 実行結果 $ gradle -q hello Added to first 2 Added to first 1 Hello! doFirst メソッドを呼び出すたびに、その時点でのアクションリストの先頭にアクションが追加されていくので、最後に追加したアクションが最初に実行されていることに注意してください。"},{url:"/p/m7u5dgp/",title:"Gradle Wrapper スクリプト (gradlew) を作成する",date:"2015-07-10T00:00:00+09:00",body:"Gradle Wrapper スクリプト (gradlew) を作成する Gradle Wrapper とは Gradle Wrapper スクリプト (gradlew) を作成しておくと、Gradle の実行環境をインストールしていない環境でも gradle コマンドを実行するのと同様のビルドを行えるようになります。 Gradle Wrapper は、実際には下記のようなスクリプトファイルです。 gradlew &hellip; Linux 用のシェルスクリプト gradlew.bat &hellip; Windows 用のバッチファイル プロジェクトに gradlew が用意されている場合は、gradle コマンドの代わりにそちらを使えば OK です。例えば、build タスクを実行したい場合は、下記のように実行します。 gradle コマンドの代わりに gradlew コマンドを使用 $ gradlew build 仕組みは単純で、Gradle がインストールされていない環境で gradlew コマンドを実行すると、最初に Gradle の実行環境がインストールされてビルドが実行されるようになっています。 Gradle の実行環境の実体は ~/.gradle/wrapper/dists/gradle-1.12-bin といったディレクトリにインストールされ、次回の gradlew コマンド実行時には、そこにあるファイルが使用されるようになります（この動きを特に意識する必要はありません）。 Gradle Wrapper の作成 Gradle Wrapper のスクリプトファイル、およびその実行に必要なライブラリ群は、下記のコマンドで生成することができます。 $ gradle wrapper これだけでも十分なのですが、下記のように wrapper タスクのコンフィギュレーションを定義しておくことで、どのバージョンの Gradle 相当の Gradle Wrapper を作成するかを指定することができます（他にもいろいろな設定を行うことができます。詳しくは Wrapper の DSL ドキュメント を参照してください）。 build.gradle wrapper { gradleVersion = &#39;5.0&#39; } 上記のようなバージョン指定を行わない場合は、Gradle Wrapper 作成時に使用した gradle コマンドのバージョンに相当する Gradle Wrapper が作成されます。 ビルド環境をより明確にするためにも、上記のタスクは定義しておいた方がよいでしょう。 ☝️ コラム (2019-04-25) 昔は下記のように wrapper タスクを定義する方法が用いられていました。 task wrapper(type: Wrapper) { gradleVersion = &#39;1.12&#39; } ただし、Gradle 4.4 以降で上記のようなタスク定義を行うと、Cannot add task 'wrapper' as a task with that name already exists. というタスクの重複定義エラーが発生するので、コンフィギュレーションブロックの定義の形に修正する必要があります。 Gradle Wrapper の生成に成功すると、次のようなファイル群が生成されます。 ＜Project＞ +-- gradle | +-- wrapper | +-- gradle-wrapper.jar | +-- gradle-wrapper.properties +-- gradlew （Linux 用のコマンド） +-- gradlew.bat （Windows 用のコマンド） Git などのコードリポジトリには、上記のファイル群をすべてコミット するようにします。 そうすれば、他の開発メンバは提供されている gradlew コマンドを実行するだけで、プロジェクトのビルドを行えるようになります。 Gradle Wrapper のバージョンアップ Gradle の最新バージョンは こちら で確認できます。 プロジェクトで使用している Gradle Wrapper のバージョンを変更したい場合は、下記のように wrapper タスクのバージョン情報を更新し、 build.gradle wrapper { gradleVersion = &#39;5.4&#39; } この wrapper タスクを実行します。 $ gradlew wrapper 一度目の実行は、現在の Gradle Wrapper のバージョンで実行され、下記のような設定ファイルが更新されます。 gradle/wrapper/gradle-wrapper.properties 上記には、Gradle Wrapper 実行時に取得する Gradle のバージョンが記述されており、次回からの gradlew コマンドは新しい Gradle バージョンで実行されるようになります。 Gradle の実体である jar ファイルが実際に取得されるのは、もう一度 gradlew コマンドを実行したとき のようなので、もう一回同じコマンドを実行しておきます。 $ gradlew wrapper これで、一連の Gradle Wrapper 関連ファイルが更新されるので、Git でコミットすれば Gradle Wrapper のバージョン更新作業は完了です。 $ git add build.gradle $ git add gradle/wrapper $ git add gradlew $ git add gradlew.bat $ git commit トラブルシューティング (IllegalCharsetNameException) Windows で Gradle 5.4 の gradlew.bat を実行すると、下記のようにコケる現象が発生しました（Ver 5.0 でも同様）。 D:\\myproj\\&gt; gradlew --version Error occurred during initialization of VM java.lang.ExceptionInInitializerError at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1451) at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1436) Caused by: java.nio.charset.IllegalCharsetNameException: UTF-8&#34;-Xmx64m ... どうも、バッチファイルの記述がおかしくなっているようです。 gradlew.bat（L.33 あたり） set GRADLE_OPTS=&#34;-Dfile.encoding=UTF-8&#34;&#34;-Xmx64m&#34; &#34;-Xms64m&#34; を下記のように修正します（パラメータ間のスペースが足りないので追加）。 set GRADLE_OPTS=&#34;-Dfile.encoding=UTF-8&#34; &#34;-Xmx64m&#34; &#34;-Xms64m&#34; これでエラーなしで実行できるようになります。"},{url:"/p/szhzejv/",title:"Gradle デーモンを使って gradle コマンドを高速化する (org.gradle.daemon)",date:"2015-07-10T00:00:00+09:00",body:"Gradle デーモンを使って gradle コマンドを高速化する (org.gradle.daemon) Gradle デーモンの立ち上げ gradle コマンドを実行すると、デフォルトでは毎回 Java のバーチャルマシンを起動するため、下記のような簡単なタスクを実行するだけでも 2、3 秒の実行時間がかかってしまいます。 build.gradle task hello &lt;&lt; { println &#39;Hello&#39; } 実行結果 $ gradle hello :hello Hello BUILD SUCCESSFUL Total time: 2.353 secs gradle コマンドを実行するときに、--daemon オプションを付けるようにすると、Gradle のプロセスを常駐させ（デーモン化）、そのプロセスを毎回のビルドで使いまわすようになります。 初回はデーモンの立ち上げのために時間がかかりますが、2 度目からのビルドは高速に実行することができます。 下記の実行例を見ると、1 秒以内に処理できていることがわかります。 実行結果（--daemonオプションあり） $ gradle --daemon hello :hello Hello BUILD SUCCESSFUL Total time: 0.905 secs ちなみに、常駐している Gradle のプロセスは、3 時間使用されないと自動的に終了します。 下記のように明示的に停止することもできます。 $ gradle --stop Stopping daemon(s). Gradle daemon stopped. Gradle デーモンをデフォルトで有効にする gradle コマンドに毎回 --daemon オプションを付けるのが面倒な場合は、Gradle の設定ファイル (gradle.properties) でデーモンを常に有効にすることができます。 設定は下記のいずれかのファイルで行います。 &lt;Project&gt;/gradle.properties &hellip; プロジェクトごとの設定 $HOME/.gradle/gradle.properties &hellip; ユーザごとの設定 - macOS/Linux の場合 %USERPROFILE%/.gradle/gradle.properties &hellip; ユーザごとの設定 - Windows の場合 gradle.properties org.gradle.daemon=true"},{url:"/p/5iacmi7/",title:"Gradle で実行可能な JAR ファイルを作成する",date:"2015-07-10T00:00:00+09:00",body:"Gradle で実行可能な JAR ファイルを作成する Gradle の java プラグインを使用して、実行可能な JAR ファイルを作成してみます。 ここでは、下記のような簡単な Hello World アプリケーションをビルドします。 src/main/java/com/example/Main.java package com.example; public class Main { public static void main(String... args) { System.out.println(&#34;Hello&#34;); } } JAR ファイルを特別なパラメータなしで実行できるようにするには、JAR ファイルにアーカイブする Manifest ファイルでエントリポイントとなる Main クラスを指定しておく必要があります。 ビルドスクリプト内で下記のように記述しておくと、com.example.Main をエントリポイントとするような Manifest ファイルを生成してくれるようになります。 build.gradle apply plugin: &#39;java&#39; version = 1.0 jar { manifest { attributes &#39;Main-Class&#39;: &#39;com.example.Main&#39; } } ビルドします。 $ gradle build ... BUILD SUCCESSFUL Total time: 1.063 secs 作成された JAR ファイルは、下記のように実行できるようになっているはずです。 $ java -jar build/libs/sample-1.0.jar Hello 上記のファイル名からもわかるように、プロジェクトのプロパティ (version) に設定したバージョン情報が、自動的に JAR ファイル名のプレフィックスとして設定されます。"},{url:"/p/sifxuig/",title:"Gradle でタスクの依存関係を表現する",date:"2015-07-09T00:00:00+09:00",body:"Gradle でタスクの依存関係を表現する タスク間に依存関係を設定する org.gradle.api.Task オブジェクトの dependsOn メソッド を使用することで、タスク間に依存関係を持たせることができます。 方法1）タスク定義時の引数で依存定義する タスク定義時の dependsOn 引数（厳密にはマップキー）でタスク間の依存関係を設定することができます。 次の例では、hello1 タスクに依存する hello2 タスクを定義しています。 build.gradle task hello1 { doLast { println &#39;Hello 1&#39; } } task hello2(dependsOn: hello1) { doLast { println &#39;Hello 2&#39; } } hello2 タスクを実行するときに、先に hello1 タスクが実行されるようになります。 $ gradle -q hello2 Hello 1 Hello 2 方法2）Configure クロージャ内で依存定義する タスク定義時の Configure クロージャ内で dependsOn メソッドを呼び出して依存関係を指定することができます。 task hello1 { doLast { println &#39;Hello 1&#39; } } task hello2 { dependsOn hello1 doLast { println &#39;Hello 2&#39; } } 方法3）タスク定義後に依存を追加する すでに定義済みのタスク（Task オブジェクト）の dependsOn メソッドを呼び出すことで、後付けで依存関係を追加することができます。 task hello1 { doLast { println &#39;Hello 1&#39; } } task hello2 { doLast { println &#39;Hello 2&#39; } } hello2.dependsOn hello1 まだ定義されていないタスクを依存関係に追加する hello2.dependsOn hello1 のように依存関係を追加するときに、hello1 というオブジェクト名で参照できているのは、hello1 タスクがすでに定義済みで、Project オブジェクトの hello1 プロパティとして参照可能になっているからです（Configuration フェーズでは上から順番に処理されていくので、hello1 タスクの定義が上に記述されている必要があります）。 まだ定義されていないタスクを依存先に設定するには、その タスク名を文字列で指定 します。 次の例では、hello1 タスクの依存先として、まだ定義されていない hello2 タスクを指定しています。 task hello1 { dependsOn &#39;hello2&#39; doLast { println &#39;Hello 1&#39; } } task hello2 { doLast { println &#39;Hello 2&#39; } } 複数のタスクに依存するタスクを定義する 複数タスクへの依存 複数のタスクに依存するタスクを定義することもできます。 下記の例では、hello1 タスクと hello2 タスクの両方に依存する hello3 タスクを定義しています。 build.gradle task hello1 { doLast { println &#39;Hello 1&#39; }} task hello2 { doLast { println &#39;Hello 2&#39; }} task hello3 { doLast { println &#39;Hello 3&#39; }} hello3.dependsOn hello1, hello2 Task#dependsOn メソッドは、依存関係を 追加する ためのメソッドなので、次のように別々に依存関係を追加しても同様です。 hello3.dependsOn hello1 hello3.dependsOn hello2 また、次のように同じ依存関係を何度追加しても、依存するタスクが呼び出されるのは 1 回だけです。 hello3.dependsOn hello1 hello3.dependsOn hello1 hello3.dependsOn hello1 タスク定義時の dependsOn パラメータでも複数の依存関係を指定することができます。 task hello1 { doLast { println &#39;Hello 1&#39; }} task hello2 { doLast { println &#39;Hello 2&#39; }} task hello3(dependsOn: [hello1, hello2]) { doLast { println &#39;Hello 3&#39; } } 上記のように依存関係を定義することで、hello3 タスクの実行前に hello1 タスクと hello2 タスクが実行されることが保証されます。 実行結果 $ gradle hello3 Hello 1 Hello 2 Hello 3 タスクの実行順序の制御 上記のように Task#dependsOn メソッドで、2 つ以上のタスク（hello1 と hello2）に依存する hello3 タスクを定義することができました。 しかし、この指定だけでは hello1 タスクと hello2 タスクの実行順序までは保証されない ということに注意してください。 こういった緩い制約になっていることで、Groovy のタスクの多くは並列実行することが可能になっています。 仮に、必ず hello1 → hello2 → hello3 の順番で実行しないといけないのであれば、次のように hello1 と hello2 の依存関係を定義するという方法があります。 task hello1 { doLast { println &#39;Hello 1&#39; }} task hello2(dependsOn: hello1) { doLast { println &#39;Hello 2&#39; }} task hello3(dependsOn: hello2) { doLast { println &#39;Hello 3&#39; }} ただし、こうすると、hello2 タスクの実行時にも必ず hello1 タスクが実行されることになってしまいます。 $ gradle -q hello2 Hello 1 Hello 2 $ gradle -q hello3 Hello 1 Hello 2 Hello 3 hello3 タスクの実行にのみ、hello1 → hello2 → hello3 の順番で実行するには、次のように Task#mustRunAfter メソッドを使います。 task hello1 { doLast { println &#39;Hello 1&#39; }} task hello2 { doLast { println &#39;Hello 2&#39; }} task hello3 { doLast { println &#39;Hello 3&#39; }} hello2.mustRunAfter hello1 hello3.dependsOn hello1, hello2 これで、hello2 タスクの単独実行時には hello1 タスクを実行しないで済みます。 $ gradle -q hello2 Hello 2 $ gradle -q hello3 Hello 1 Hello 2 Hello 3"},{url:"/p/odjj8e7/",title:"Gradle で Java プロジェクトをビルドするときのディレクトリ構成を変更する (sourceSets, buildDir)",date:"2015-07-08T00:00:00+09:00",body:"Gradle で Java プロジェクトをビルドするときのディレクトリ構成を変更する (sourceSets, buildDir) java プラグインは、プロジェクトのディレクトリ構成が次のようになっていると想定しています。 これは、Gradle のソースセットの設定（インプットファイルの置き場所の設定）がデフォルトでこのようになっているからです。 Java ソースコード: src/main/java および src/test/java 出力先のディレクトリ: build このソースセットの設定を変更するとこで、プロジェクトの都合に合わせたディレクトリ構成に変更できます。 例えば、製品用の Java ソースコードを src ディレクトリ、テスト用の Java ソースコードを test ディレクトリ、出力先を out ディレクトリに変更するには以下のように設定します。 build.gradle apply plugin: &#39;java&#39; sourceSets { main { java { srcDirs = [&#39;src&#39;] } } test { java { srcDirs = [&#39;test&#39;] } } } buildDir = &#39;out&#39; こう書くこともできます。 apply plugin: &#39;java&#39; sourceSets.main.java.srcDirs = [&#39;src&#39;] sourceSets.test.java.srcDirs = [&#39;test&#39;] buildDir = &#39;out&#39; この設定により、下記のようなパスに置かれた Java ソースコードがコンパイルされるようになります。 src/com/example/Main.java 正確には、srcDirs メソッドは、ディレクトリを変更するのではなく追加 します。 なので、もともとの src/main/java ディレクトリ以下に置かれている Java ソースコードは、相変わらずコンパイルの対象になります。 ちなみに、出力先ディレクトリ (buildDir) を変更した場合、gradle clean コマンドでクリーンナップされるディレクトリも変更されます。"},{url:"/p/j5bvcq9/",title:"Groovy でクラスを定義する",date:"2015-07-08T00:00:00+09:00",body:"Groovy でクラスを定義する クラスを定義する Groovy では、クラスやメソッドの可視性はデフォルトで public になります。 下記の Book クラスは title と authors フィールドを持っており、両方とも外部から参照できます。 sample.groovy class Book { def title def authors = [] def getLabel() { title + &#39;, &#39; + authors } String toString() { getLabel() } } def book = new Book() book.title = &#39;Title1&#39; book.authors &lt;&lt; &#39;Author1&#39; &lt;&lt; &#39;Author2&#39; &lt;&lt; &#39;Author3&#39; println book 実行例 $ groovy sample.groovy Title1, [Author1, Author2, Author3] 上記の例では、book.title というプロパティに直接アクセスしているかのように見えますが、内部的には、自動的に生成された book.getTitle() という getter メソッドが呼び出されています。 同様に、book.setTitle() という setter メソッドも自動的に生成されています。 つまり、下記の 2 つのコードは同じ動作をします。 book.title = &#39;Title1&#39; println book.title book.setTitle(&#39;Title1&#39;) println book.getTitle() 名前付きパラメータによるコンストラクタ呼び出し コンストラクタを呼び出すときに、名前付きパラメータを指定することで、任意のプロパティを初期化することができます。 class Book { def title def authors } def book = new Book(title:&#39;Title1&#39;, authors:[&#39;Author1&#39;, &#39;Author2&#39;]) println book.authors"},{url:"/p/ohhdpvf/",title:"Groovy でマップ (Map) を扱う",date:"2015-07-08T00:00:00+09:00",body:"Groovy でマップ (Map) を扱う Groovy の Map の基本 Groovy の Map インスタンスは、List インスタンスと同様に [ と ] を使用して定義することができます。 ただし、各要素はコロン (:) で区切って、キーと値を指定します。 内部的には、java.util.LinkedHashMap インスタンスが生成されています。 def map = [xxx:100, yyy:200, zzz:300] assert map.getClass() == java.util.LinkedHashMap assert map.size() == 3 assert map.xxx == 100 assert map[&#39;xxx&#39;] == 100 Map の要素を列挙する Map の要素は、List の要素と同様に each メソッドを使ってイテレートすることができます。 map.each { key, val -&gt; println key + &#39;:&#39; + val } 空の Map インスタンスを生成する 空の Map インスタンスを生成するときは、ちょっと特殊ですが下記のように記述する必要があります。 def map = [:] // 空の Map 真ん中のコロン : を省略してしまうと、List オブジェクトの生成とみなされてしまいます。 def list = [] // 空の List ちなみに、Ruby や Python におけるハッシュの生成では、リストの生成とは異なる {} という記号を使用することで、生成すべきオブジェクトがハッシュなのかリストなのかを区別するようになっています。 Groovy ではハッシュとリストの生成に同じ記号 [] を用いる仕様なので、上記のような細かい制約が出てくるんですね。"},{url:"/p/6qzzzry/",title:"Groovy でメソッドを定義する",date:"2015-07-08T00:00:00+09:00",body:"Groovy でメソッドを定義する 下記のサンプルでは、2 つの変数を足し合わせる add メソッドを定義しています。 sample.groovy // メソッドの定義 def add(a, b) { a + b } // メソッドの呼び出し def val = add(100, 200) println val Groovy では、他の多くのスクリプト言語と同様に、メソッド内で最後に評価された式の値がそのまま戻り値となるので、return キーワードを省略することができます。 また、パラメータの型や、戻り値の型も明示する必要はありません（最初に def とだけ書けばよい）。 次のように型を明示することもできます。 int add(int a, int b) { a + b } 戻り値がないことを明示したいのであれば、Java と同様に void と定義することもできます。 戻り値の型が void のメソッドの戻り値を強引に取得しようとすると、null が返されます。 void greet(String name) { println &#39;Hello, &#39; + name } def val = greet(&#39;Jack&#39;) println val //=&gt; null メソッド呼び出し時のパラメータを囲む括弧は、次のように省略することができます。 def val = add 100, 200 ただし、パラメータを 1 つも持たない場合は、呼び出し時の括弧を省略することはできません。 void greet() { println &#39;Hello&#39; } greet() // 括弧は省略できない"},{url:"/p/z9qmfd4/",title:"Groovy でリスト (List) を扱う",date:"2015-07-08T00:00:00+09:00",body:"Groovy でリスト (List) を扱う Groovy のリストの基本 Groovy では、[1, 2, 3] といった構文を使用して、簡単に List インスタンスを生成することができます。 内部的には java.util.ArrayList のインスタンスが生成されます。 下記の例では、3 つの要素を持つ List インスタンスを生成しています。 def list = [100, &#39;AAA&#39;, 0.25] assert list.getClass() == java.util.ArrayList assert list.size() == 3 assert list[0] == 100 リストへの要素の追加 リストの末尾に要素を追加する場合、&lt;&lt; というショートカット記法を使用することができます。 def list = [] list &lt;&lt; 100 list &lt;&lt; 200 list &lt;&lt; 300 println list //=&gt; [100, 200, 300] これは、下記のように add メソッドを呼び出すのと同等の動作をします。 def list = [] list.add 100 list.add 200 list.add 300 println list //=&gt; [100, 200, 300] あまり違いはないように見えますが、&lt;&lt; を使った方が可読性は若干上がるようです。 また、&lt;&lt; を使うことにより、下記のように連続して要素を追加することが可能です。 def list = [] list &lt;&lt; 100 &lt;&lt; 200 &lt;&lt; 300 println list リストの要素を列挙する リスト内の要素をループ処理したいときは、下記のように each メソッドを使用します。 def list = [100, &#39;AAA&#39;, 0.25] list.each { elem -&gt; println elem } 上記の例では、イテレート用の変数を明示していますが、下記のようにデフォルトの it 変数を使用することもできます。 list.each { println it } 負のインデックス、範囲外インデックスの扱い 負のインデックスを指定することで、末尾から数えた位置の要素を取得することができます。 def list = [100, 200, 300] assert list[-1] == 300 存在しない位置のインデックスを指定した場合は、Java のように ArrayIndexOutOfBoundsException 例外が発生することはなく、単純に null が返されます。 def list = [100, 200, 300] assert list[3] == null"},{url:"/p/v8m6rme/",title:"Groovy で文字列リテラルを扱う",date:"2015-07-08T00:00:00+09:00",body:"Groovy で文字列リテラルを扱う 文字列リテラルと GStrings Groovy の文字列リテラルは、シングルクォート (') あるいは、ダブルクォート (&quot;) で囲んで表現します。 ダブルクォートで囲んだ文字列リテラルは、$ で始まる変数が展開されます。 このような変数を含む文字列を GStrings (Groovy Strings) と呼びます。 sample.groovy def name = &#39;Britney&#39; println &#39;Hello $name&#39; println &#34;Hello $name&#34; 実行結果 Hello $name Hello Britney 文字列の中の式 ${式} という構文を使用すると、文字列の中で任意の式を実行することができます。 sample.groovy def name = &#39;mickey&#39; println &#34;Hello ${name.capitalize()}&#34; 実行結果 Hello Mickey ヒアドキュメント 3 連続のクォーテーションマーク（''' あるいは &quot;&quot;&quot;）で文字列を囲むことによって、複数行にまたがる文字列リテラル（ヒアドキュメント）を定義することができます。 通常の文字列リテラルと同様に、ダブルクォート (&quot;) で囲んだ場合だけ、$ で始まる変数が展開されます。 def html = &#34;&#34;&#34;&lt;html&gt; &lt;head&gt; &lt;title&gt;$title&lt;/title&gt; &lt;head&gt; &lt;body&gt; $body &lt;/body&gt; &lt;/html&gt;&#34;&#34;&#34;"},{url:"/p/m9veity/",title:"Groovy で assert を使用する",date:"2015-07-07T00:00:00+09:00",body:"Groovy で assert を使用する Groovy では、デフォルトで assert が使用できるようになっています。 sample.groovy def num = 100 assert num.getClass() == java.lang.Integer def str = &#39;Hello&#39; assert str.getClass() == java.lang.Integer 上記のスクリプトを実行すると、2 つ目の assert で fail して、下記のように詳細な情報が表示されます。 分かりやすいですね！ $ groovy sample.groovy Assertion failed: assert str.getClass() == java.lang.Integer | | | | | false | class java.lang.String Hello at sample.run(sample.groovy:5)"},{url:"/p/som2e4k/",title:"Groovy と Java の違い",date:"2015-07-07T00:00:00+09:00",body:"Groovy と Java の違い Groovy は Java と異なり、下記のような特徴を持っています。 行末のセミコロンは省略できる クラス、コンストラクタ、メソッドはデフォルトで public となる return の記述は省略できる（最後に評価された式が戻り値となる） getter/setter メソッドが自動的に作られる（obj.prop のようにアクセスすれば obj.getProp や setProp が呼び出される） == によるオブジェクトの比較は、自動的に equals による比較となる（しかも null チェックの必要はない） assert は常に有効（Java の場合は -ea または --enable-assertion オプションの指定が必要） 変数の型や、メソッドの戻り値の型は def としておけば、自動で判別してくれる コレクション（List や Map）の扱いがシンプルで、Python や Ruby に近い構文で記述できる"},{url:"/p/q6ducqz/",title:"Gradle でファイルをコピー、リネームするためのタスクを作成する (type: Copy)",date:"2015-06-30T00:00:00+09:00",body:"Gradle でファイルをコピー、リネームするためのタスクを作成する (type: Copy) Gradle のビルドスクリプトで Copy 型のタスクを定義すると、ファイルのコピーや移動を簡単に行うことができます。 ファイルコピーの基本 次の hello タスクは、ディレクトリ from/dir 以下のファイルを再帰的にコピーします。 from/dir 以下のディレクトリ階層は保たれます。 コピー先のディレクトリ to/dir が存在しない場合は、自動的に作成されます。 task hello(type: Copy) { from &#39;from/dir&#39; into &#39;to/dir&#39; } コピーする対象を絞り込む Copy タスクにおいて、include や exclude でファイル名のパターンを指定することで、コピーするファイルを絞り込むことができます。 拡張子が .txt のファイルをすべてコピー task hello(type: Copy) { from &#39;from/dir&#39; into &#39;to/dir&#39; include &#39;**/*.txt&#39; } 拡張子が .bk ではないファイルをすべてコピー task hello(type: Copy) { from &#39;from/dir&#39; into &#39;to/dir&#39; exclude &#39;**/*.bk&#39; } 複数のディレクトリからファイルをコピーする コピー元のディレクトリを複数指定して、一つのディレクトリにコピーすることもできます。 下記の例では、from1 ディレクトリと from2 ディレクトリ内のファイルを to ディレクトリにコピーしています。 task hello(type: Copy) { from &#39;from1&#39; from &#39;from2&#39; into &#39;to&#39; } ただし、この方法だと、複数のコピー元に同じファイル名のファイルがあると、ファイルが上書きコピーされてしまいます（ツリー構造が異なれば大丈夫です）。 下記のようにすると、コピー先にディレクトリを作って、その中にファイルをコピーすることができます。 from のパラメータを括弧で囲むことに注意してください。 task hello(type: Copy) { from(&#39;from1&#39;) { into &#39;f1&#39; } from(&#39;from2&#39;) { into &#39;f2&#39; } into &#39;to&#39; } このようにすると、from1 ディレクトリ内のファイルは to/f1 に、from2 ディレクトリ内のファイルは to/f2 に、それぞれコピーされるようになります。 ファイルをリネームする Copy 型のタスクでファイルをコピーする際に、rename メソッドを使用するとファイル名を変更することができます。 例: 拡張子 .txt を .html にリネームしてコピー task hello(type: Copy) { from &#39;from&#39; into &#39;to&#39; rename(/(.+)\\.txt$/, &#39;$1.html&#39;) } 拡張子として .txt を持たないファイルに関しては、元のファイル名のままコピーされます。 上記では rename メソッド呼び出しのパラメータとして置換パターンを指定していますが、クロージャの形で置換処理を記述することもできます。 task hello(type: Copy) { from &#39;from&#39; into &#39;to&#39; rename { it - ~/\\.txt$/ + &#39;.html&#39; } } 上記の例では、それぞれのファイル名に対して、末尾から .txt を削除し、.html を付加するという処理を行っています。 末尾に .txt がないファイルに対しても、.html を付加してしまうことに注意してください。"},{url:"/p/ijynhet/",title:"Gradle のテンプレート機能を使ってファイルを生成する",date:"2015-06-30T00:00:00+09:00",body:"Gradle のテンプレート機能を使ってファイルを生成する Groovy の SimpleTemplateEngine クラスの機能を使用することで、ファイルコピー時にファイル内の文字列を置換することができます。 例えば、入力ファイルとして、下記のようなテンプレートファイルを用意しておきます。 input/build.properties version=${version} buildDate=${buildDate.format(&#34;yyyyMMdd&#39;T&#39;HHmmss&#34;)} ${string} という部分が動的に置換される部分です。 そこにどんな値を格納するかは、Copy 型タスクの expand() メソッドで指定します。 build.gradle task hello(type: Copy) { from &#39;input&#39; include &#39;build.properties&#39; into &#39;output&#39; expand([ version: &#39;1.0.0&#39;, buildDate: new Date() ]) } 上記のタスクを実行すると、下記のようなファイルが出力されます。 output/build.properties version=1.0.0 buildDate=20150630T224515"},{url:"/p/84n7rxj/",title:"単位を明確にする",date:"2015-06-25T00:00:00+09:00",body:"単位を明確にする 時刻や距離、重さなど、その単位が重要な場合は、名前から単位が分かるように命名しましょう。 パラメータに関しては、ドキュメンテーションコメントで説明しておくこともできますが、コメントではなくてシンボル名から単位を読み取れるのが理想的です。 long duration; // NG long durationInMillis; // Good public int convertTimeToPixel(long time); // NG public int convertMillisToPixel(long millis); // Good"},{url:"/p/tdmxx2s/",title:"時制や単数形・複数形を考慮して命名する",date:"2015-06-25T00:00:00+09:00",body:"時制や単数形・複数形を考慮して命名する 関数名や、変数名は、英語の文法と同様に、時制と単数形・複数形にも気を配るようにしましょう。 複数のオブジェクトを含む配列なのに変数名が単数形になっていたり、真偽値を返すメソッドだからといって、すべて isXxx のような名前にしていたのでは、読みやすいコードにはなりません。 例: 複数の要素を持つ可能性があるのであれば複数形、あるいは xxxList のような命名をする Bitmap[] thumbnails; // Good Bitmap[] thumbnail; // NG 例: 真偽値は isXxx という形にこだわらず、意図の分かる命名をする boolean canShowTitle; // Good（タイトルを表示可能な状態だということが分かる） boolean shouldShowTitle; // Good（タイトルを表示すべきということが分かる） boolean isTitleEnabled; // OK（何が可能なのか分かりにくい） boolean isShowTitle; // NG（表示すべきということ？表示されていること？） 例: 時制を意識した命名をする bool areAllColorsLoaded; // Good（現在の状態を表している） bool wasNameDeletedBeforeExit; // Good（過去の変化を表している） bool isDisplayAddress; // NG（状態なのか、可能性なのか、何を表しているのか分からない。そもそも文法がおかしい）"},{url:"/p/gosywwh/",title:"肯定形で表現する",date:"2015-06-23T00:00:00+09:00",body:"肯定形で表現する 真偽値を表すのであれば、否定形よりも肯定形で統一しましょう。 例えば、disabled ではなく enabled を、hidden/invisible ではなく shown を使用します。 boolean isInvisible(); // NG（isVisible とすればよい） boolean isHidden(); // NG（同上） setHideFlag(boolean shouldHide) // NG（単純に show とすればよい） boolean isNotDisplayed; // NG（反転させなくてよい） setVisibility(boolean visible); // OK（show() と hide() を用意するのも OK） show() / hide() // OK"},{url:"/p/74qmru8/",title:"静的チェックのレベルはプロジェクト初期に厳しくする",date:"2015-06-16T00:00:00+09:00",body:"静的チェックのレベルはプロジェクト初期に厳しくする 大規模な開発チームや、スキルレベルの異なるメンバが含まれる開発チームでは、コード品質を一定以上に保つために Checkstyle や FindBugs などの静的解析ツールを導入するのはほぼ必須といえます。 こういった静的解析ツールは、プロジェクト開始時から導入しておくべきです。 開発の途中で静的解析のチェックレベルを厳しくしても、対応が容易ではないことがあります。 例えば、1 ファイルあたりの行数が何千行にも膨れ上がってしまってから、行数の制約を加えても、すぐには修正ができません。 長期的な開発の過程でメンテナンス性を損なわないようにするためのチェック項目は、コードが健全なうちにチェックレベルを上げて有効にしておきましょう。 例えば、下記の Checkstyle 定義では、ファイルあたりの行数が 1000 行を超えるとエラーになるように定義しています。 checkstyle.xml &lt;module name=&#34;Checker&#34;&gt; ... &lt;module name=&#34;FileLength&#34;&gt; &lt;property name=&#34;severity&#34; value=&#34;error&#34;/&gt; &lt;property name=&#34;max&#34; value=&#34;1000&#34;/&gt; &lt;/module&gt; ... 静的解析の段階でエラーにすることで、メンテナンス性を下げるコードがコミットされることを防ぐことができます。"},{url:"/p/6ybc6rp/",title:"無駄な汎用性ではなくシンプルな設計を (YAGNI)",date:"2015-06-15T00:00:00+09:00",body:"無駄な汎用性ではなくシンプルな設計を (YAGNI) YAGNI (You ain&rsquo;t gonna need it) (You aren&rsquo;t going to need it) というのは、将来のためにあらかじめ入れておいた実装が、結局は使われないことを言っています。 オブジェクト指向設計が登場した頃は、継承やポリモーフィズムといった仕組みを活かして、汎用的な設計をすることを美とする傾向がありました。 しかし、現在のソフトウェア開発では、短いサイクルでのリリースや、頻繁な仕様変更に対応しながら開発を進める必要があり、将来を予測して汎用的な実装を行っておくことは困難になってきています。 アジャイルな開発では、使うかどうか分からない機能や、無駄な汎用性を持たせた実装を行うことを良しとしません。 今必要な実装をシンプルに、確実に実装することに集中します。 シンプルで分かりやすい設計になっていれば、将来修正が必要になった場合でも比較的容易に変更を行うことができ、トータルのコストも少なくなるというわけです。 参考: YAGNI - Wikipedia"},{url:"/p/f3m87vq/",title:"可変オブジェクトのメンバ参照を返さない",date:"2015-05-27T00:00:00+09:00",body:"可変オブジェクトのメンバ参照を返さない メンバ変数として可変オブジェクト (mutable object) を持っているクラスが、getter メソッドでその参照をそのまま返してしまうと、クラス外部からオブジェクトの内容を変更されてしまいます。 プライベートなメンバを外部から守るためにカプセル化しているはずなのに、これでは実際には何も守られておらず、外部からそのクラスの振る舞いを壊されてしまいます。 例えば、下記の Program クラスは、メンバ変数として Date オブジェクトを持ち、getter メソッドでその参照を返しています。 import java.util.Date; public class Program { private final Date startTime = new Date(); public Date getStartTime() { return startTime; } } Java の Date オブジェクトには、setTime() メソッドが存在するため、可変オブジェクトです。 可変オブジェクトの参照を外部から取得できるようにすると、その参照を通して値を変更されてしまいます。 Program program = new Program(); System.out.println(program.getStartTime()); // Wed Jan 1 01:11:54 JST 2014 // メンバ変数への参照を取得し、値を書き換える Date date = program.getStartTime(); date.setTime(date.getTime() + 1000000); System.out.println(program.getStartTime()); // Wed Jan 1 01:28:34 JST 2014（破壊された） このような外部からのオブジェクト破壊を防ぐには、プリミティブな値、あるいは不変オブジェクト (immutable object) の参照を返すようにします。 public long getStartTime() { return startTime.getTime(); } ちなみに、Java の String は不変オブジェクトなので return しても問題ありません。 Java には、任意のコレクションを変更できないようにするためのユーティリティが用意されています。 例えば、オブジェクト内部の List オブジェクトを getter で返さないといけない場合は、下記のようにすることで外部からの破壊を防ぐことができます。 public List&lt;Book&gt; getRecommendedBookList() { return Collections.unmodifiableList(recommendedBooks); }"},{url:"/p/wiy8w8n/",title:"不具合修正に対する向き合い方",date:"2015-05-26T00:00:00+09:00",body:"不具合修正に対する向き合い方 不具合そのものではなく、不具合混入の根本原因を突き止める ソフトウェアの実装に不具合が見つかった時、正しく動作するように修正するだけでは不十分です。 継続的に設計を改善していくためには、どうしてそのような不具合となるコーディングを行ってしまったのか、その根本的な原因を突き止め、その原因を取り除いていく必要があります。 表面的な不具合の修正を繰り返しているだけでは、不具合を生みやすい構造が改善されないため、ソフトウェアの品質はいつまでたっても上がらず、不具合修正の工数だけが増えていきます。 不具合を分析するときは、表面化した不具合（結果）にだけ注目するのではなく、不具合混入の根本原因を探りましょう。 下記は、典型的な不具合のパターンと、それぞれどのような根本原因が潜んでいるかの例です。 パターン１: API の使い方を間違えて不具合が入った 大きなプロジェクトでは、他のメンバが作成した API を使用することが多くなるため、このパターンによる不具合は多く発生します。 実装者が API の使用方法をまったく調べずに使ってしまったということも考えられますが、突き詰めていくと、下記のような原因が見えてきます。 変数名やメソッド名から実際の振る舞いが想像できなかった API ドキュメントの記載があいまいで正しい呼び出し方がわからなかった パラメータの型が汎用的すぎて（int 型など）、想定外の値を渡してしまった このような原因が考えられる場合は、不具合そのもののコードを修正するだけでなく、根本原因となった既存のコードを改善するようにしましょう。それが本当の品質改善です。 変数やメソッドに誤解を招くような名前が付けられているのであれば、意図が正しく伝わるような名前に変更しましょう。 ドキュメンテーションコメントが不十分であれば、誰が読んでも正しく解釈できるように説明文を変更します。 メソッドにテストコードがなければ追加し、メソッドの振舞いをより明確にします。 パラメータが int や String といったプリミティブ型で定義されている場合は、列挙型に変更することで、誤った使われ方を防ぐことができるでしょう。 パターン２: 不具合を修正したら別の不具合を埋め込んでしまった いわゆるエンバグというものです。 複雑なメソッドを修正する場合にはエンバグのリスクは付き物です。 エンバグしてしまった原因としては下記のようなことが考えられます。 修正を入れたことにより、あるメソッドの戻り値が想定外の値になっていることに気付かなかった ある定数値を変更したときに、連動して変えなければいけないコードがあることに気付かなかった 修正部分の周囲のコードの意味が分からず、そこに与える影響に気付かなかった エンバグの特徴としては、不具合の原因がもともとのコードにあることが多いことが挙げられます。 もともとのコードのメンテナンス性が悪ければ、修正時に別の不具合が入ってしまうことは避けられません。 既存のメソッドに副作用が出てしまうことを気付けなかったのは、そのメソッドにテストコードがなかったからです。 テストコードを追加し、間違った修正をしてしまった場合に、その場で気が付けるようにしましょう。 DRY 原則に基けば、同一の値を持つ定数値を、複数個所で管理しなければいけないような設計は改めるべきです。 とはいえ、設計プロセスやアーキテクチャ上の都合で、重複した記述を防げないこともあります（ファイルを分散して置かなければいけないとか）。 そのような場合は、連動して変更しなければいけないコードすべてに、相互のポインタを記述しておくとか、コードを自動生成するなどの仕組みを考えます。 既存コードの設計が複雑で、皆が容易に理解できないようであれば、そのコードは優先的にリファクタリングを進めるべきです。 メソッドが巨大すぎるのであれば分割し、ドキュメンテーションコメントを分かりやすく記述します。 第三者が読んだときにすぐに理解できるようなコードになるまで改善しておかなければいけません。 そうすることで、将来的にそのコードを編集するときにエンバグしてしまうリスクを低減できます。 パターン３: 要求通りの機能になっていなかった これは実装者がちゃんと要求や仕様を理解できているかの問題になります。 ソフトウェア設計は、ある仕様に基いて進めていくことになりますが、その仕様に対する理解度に差が出てしまう原因はいろいろ考えられます。 仕様書を読んでいない 仕様書を読んで理解したつもりになっていたけれど解釈が間違っていた 仕様書を読んでも理解できないので想像で実装していた 仕様書がない そもそも仕様書を読まずに実装していたとなると、「ちゃんと読め！」と、頭ごなしに実装者を攻めてしまうことがありますが、まずはなぜ仕様書を読まなかったのかにフォーカスするのがよいでしょう。 仕様書が簡単にアクセスできるところにアップロードされていないのではないか？ 仕様書を読み込むための工数が確保されていないのではないか？ 仕様書内でローカルな専門用語を使いすぎていて読んでも理解できないのではないか？ 仕様書が読みにくいのではないか？ などなど、より上位に問題が潜んでいるかもしれません。 仕様書をじっくりと読んだにもかかわらず認識の齟齬が出てしまう場合は、仕様書自体に問題があることが多いです。 仕様書の記載方法に関する研修を受けたり、チーム内で仕様書の記載に関する改善ブレストなどをするとよいでしょう。 仕様が複雑な場合は、コード内に仕様書へのリンクを埋め込んだり、詳しいドキュメンテーションコメントを記述しておかなければいけません。 将来的にそのコードをメンテナンスする人のことを考えれば、それがどれだけ重要なことか分かるはずです。 そのコードを実装するときに特定の資料が必須であったのであれば、その資料がアップロードされているサーバの URL を記載しておきましょう。 また、その複雑な仕様が、ユーザにとっても複雑なものになっているのであれば、仕様自体をシンプルにできないか見直すべきです。 仕様書側に改善できるポイントが見つかった場合は、不具合修正（コード修正）と同じタイミングで仕様書の修正も行ってしまいましょう。 あいまいな記述がなくならない限り、将来にわたって不具合は発生し続けます。 できれば、その仕様に関わる部分のテストコードを記述し、その振舞いが要求を満たしているかを確認しましょう。 テストコードを記述する過程で、仕様定義のあいまいさに気付けることもあります。 仕様書を書かない、もしくは、ごく簡単な仕様記述しか行わないという文化を持つところもあると思います（常に全員が一か所で作業するベンチャー企業など）。 そいうったケースでは、口頭での意思疎通によって仕様を理解することになります。 十分に要求を理解できない状態で実装を進めてしまうようであれば、実装者の仕事に対する向き合い方に問題があります。 仕様に関して質問をしにくい環境なのであれば、その環境を改めるべきです。 要求を十分に理解したと思って実装を進めたにもかかわらず、できあがったものが想定外のものになってしまうということであれば、もともとの仕様が不自然であった可能性があります（少なくともその実装者の中の常識とは異なる仕様になっている）。 仕様自体を考え直すきっかけになるでしょう。 不具合に対する向き合い方と、不具合の管理方法 経験を積んだプログラマは、その場の修正が楽だからという理由だけで不具合の修正方法を決めたりはしません。 不具合の根本原因となっているコードや環境をそのままにしておくと、将来的にも同じような不具合を生み出し、何度も苦労することになることを知っているからです。 誰かが間違えてしまった部分は、他の人も間違える可能性が高いのです（それは将来のあなたかもしれません）。 同じ過ちを繰り返さないように導いてください。 企業内のプロジェクトであれば、何らかの不具合管理ツールを導入しているはずです。 可能であれば、「不具合混入の根本原因」、「今後の不具合混入の防止策」という項目をテンプレート化して、コード品質を改善するための作業を習慣づけましょう。 その場しのぎの不具合修正を繰り返しているとつらいだけです。 分かりにくいコードをそのままにしておくのは精神的にもよくありません。 不具合を見つけたときは、設計を改善するためのよい機会だと思いましょう。 修正箇所にテストコードが存在しないのであれば、テストコードを追加するチャンスです。 上司が普段のリファクタリング作業に反対しているのであれば、不具合修正時がリファクタリングを行うチャンスです。 不具合修正というと大変なイメージがあるかもしれませんが、自分は設計の改善を行っているのだと考えられるようになれば、プログラマとして成長した証です。"},{url:"/p/28izof5/",title:"設定値の伝搬タイミングを意識する",date:"2015-05-21T00:00:00+09:00",body:"設定値の伝搬タイミングを意識する 設定値によって複数のオブジェクトの振る舞いを変える可能性のあるアプリケーションは、その設定値を各オブジェクトが参照するタイミング、振る舞いへと反映するタイミングに整合性を持たせることを意識して設計する必要があります。 反映タイミングを意識しないといけないものには、下記のようなものがあります。 現在時刻の更新 言語設定 (Locale) の変更 ウィンドウサイズ、フォントサイズの変更 例えば、現在時刻の変化によってリアルタイムに表示を変えるようなアプリケーションは、各 View コンポーネントがそれぞれの現在時刻情報を持ってしまうと、あるコンポーネントは現在時刻の情報を表示しているのに、他のコンポーネントは一分前の情報を表示している、といった不整合が起こります。 このような、アプリケーション全体に同時に反映すべき情報は、その設定値の変化をコールバックで直ちに知る仕組み、あるいは、メッセージ（Android なら Intent など）による通知の仕組みを導入することで、一貫性を崩すことなく伝搬することができます。"},{url:"/p/nqz8fnu/",title:"Python で HTML をパースする (HTMLParser)",date:"2015-05-18T00:00:00+09:00",body:"Python で HTML をパースする (HTMLParser) HTMLParser で HTML を処理する Python に標準搭載されている HTML パーサである html.parser.HTMLParser は、イベントドリブンな HTML パーサです。 HTMLParser クラスを継承して独自のパーサを作成し、feed メソッドに HTML テキストを渡すことによってパースを開始します。 下記のサンプルコードでは、開始タグ、終了タグ、テキストデータ、コメントが見つかったときに、それぞれ内容を出力しています。 sample.py from html.parser import HTMLParser # HTMLParser を継承してパーサクラスを作成する class MyParser(HTMLParser): def handle_starttag(self, tag, attrs): print(&#34;START :&#34;, tag, attrs) def handle_endtag(self, tag): print(&#34;END :&#34;, tag) def handle_data(self, data): print(&#34;DATA :&#34;, data) def handle_comment(self, comment): print(&#34;COMMENT:&#34;, comment) # パーサのインスタンスを生成してパースを実行 parser = MyParser() parser.feed(&#39;&lt;html&gt;&lt;body&gt;&#39; &#39;&lt;div class=&#34;class1&#34; id=&#34;id1&#34;&gt;Hello World&lt;/div&gt;&#39; &#39;&lt;!-- I am a comment --&gt;&#39; &#39;&lt;/body&gt;&lt;/html&gt;&#39;) 実行結果 START : html [] START : body [] START : div [(&#39;class&#39;, &#39;class1&#39;), (&#39;id&#39;, &#39;id1&#39;)] DATA : Hello World END : div COMMENT: I am a comment END : body END : html HTMLParser は、単純に HTML 要素を前から順番に処理していくだけなので、現在の要素がどのようなコンテキストで記述されているかは、パーサクラス内で判断していくように実装する必要があります。 ローカルの HTML ファイル、Web 上の HTML ファイルを扱う場合 ローカルファイルの内容は、Python 標準の open 関数で読み込むことができます。 ローカルの HTML ファイル text = open(&#39;input.html&#39;).read() Web 上の HTML ファイルの内容も、requests モジュールなどで簡単に読み込めます。 Web 上の HTML ファイル import requests text = requests.get(&#39;http://example.com/&#39;).text あとは、取得した HTML テキストを HTMLParser#feed() に渡してやれば OK です。"},{url:"/p/r7q8q7o/",title:"Python の requests パッケージによる HTTP リクエストの例",date:"2015-05-18T00:00:00+09:00",body:"Python の requests パッケージによる HTTP リクエストの例 参考: requests パッケージのチートシート requests パッケージのインストール オープンソースの requests パッケージ を使用すると、Python 3 標準の urllib.request よりも簡単に HTTP リクエストを扱うことができます。 例えば、以下のような処理をシンプルなコードで扱うことができます。 Basic 認証、ダイジェスト認証 ファイルのアップロード クッキー SSL 検証 エンコーディング形式の自動判別 コンテンンツが圧縮されていた場合の自動展開 requests パッケージは、pip コマンドで簡単にインストールできます。 request パッケージのインストール $ pip install requests requests モジュールによる HTTP GET リクエスト requests.get 関数を使うと、HTTP GET リクエストでインターネット上のコンテンツをダウンロードすることができます。 requests.get は、戻り値として requests.models.Response オブジェクトを返します。 Web コンテンツのダウンロード import requests res = requests.get(&#39;http://google.com/&#39;) type(res) #=&gt; &lt;class &#39;requests.models.Response&#39;&gt; Response オブジェクトから、ステータスコードや、取得したコンテンツの内容を取得することができます。 requests.get のレスポンスを詳しく見る import requests res = requests.get(&#39;http://google.com/&#39;) print(res.status_code) #=&gt; 200 print(res.status_code == requests.codes.ok) #=&gt; True print(res.ok) #=&gt; True content = res.content #=&gt; コンテンツをバイトデータ (bytes) で取得 text = res.text #=&gt; コンテンツをテキスト (str) で取得 Response#text を使って Unicode のテキストデータを取得することができます。 ダウンロードされたコンテンツからの変換に使われるエンコーディング形式は、HTTP のヘッダ、あるいは HTML 内のヘッダから判断されます。 どちらのヘッダにも指定がない場合は、コンテンツ内の文字列からそれらしきエンコーディング形式が決定されます。 requests モジュールによる HTTP POST リクエスト POST リクエストを送るには、requests.get の代わりに requests.post を使用するだけです。 HTTP の POST リクエストを送る data = {&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;} res = requests.post(&#39;http://example.com/&#39;, data) print(res.text)"},{url:"/p/r4m4k2i/",title:"Python で HTML をパースする (Beautiful Soup)",date:"2015-05-17T00:00:00+09:00",body:"Python で HTML をパースする (Beautiful Soup) Beautiful Soup とは Python 標準の html.parser モジュールは、SAX 形式のイベントドリブンなパーサなため、若干扱いにくいところがあります。 Beautiful Soup ライブラリを使用することで、HTML の要素に簡単にアクセスすることができるようになります。 Beautiful Soap Documentation Beautiful Soup パッケージは次のようにインストールできます。 $ pip install beautifulsoup4 HTML をパースする 最初に、HTML 文字列や HTML ファイルから bs4.BeautifulSoup オブジェクトを生成する必要があります。 HTML 文字列から soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(&#34;&lt;html&gt;Hello&lt;/html&gt;&#34;, features=&#34;html.parser&#34;) HTML ファイルから soup を作成 from bs4 import BeautifulSoup soup = BeautifulSoup(open(&#34;input.html&#34;), features=&#34;html.parser&#34;) Beautiful Soup 自体には Web 上のリソースをダウンロードする機能は備わっていないので、そのようなケースでは、requests モジュールなどで HTML リソースをダウンロードしておいて、BeautifulSoup コンストラクタに渡してやります。 Web 上の HTML リソースから soup を作成（requests モジュールを使用） from bs4 import BeautifulSoup import requests res = requests.get(&#34;https://example.com/&#34;) if res.status_code != requests.codes.ok: print(&#34;Failed to fetch data&#34;) exit(1) soup = BeautifulSoup(res.text, features=&#34;html.parser&#34;) 最初に登場する要素を見つける BeautifulSoup オブジェクトを生成したら、各要素の検索を行えるようになります。 一番簡単なのは、BeautifulSoup オブジェクトのプロパティで HTML 要素のタグ名を指定する方法です。 次の例では、最初に登場する p 要素（bs4.element.Tag オブジェクト）を取得しています。 from bs4 import BeautifulSoup html_doc = &#34;&#34;&#34;&lt;html&gt;&lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p class=&#34;foo&#34;&gt;This is &lt;b&gt;bold&lt;/b&gt; text.&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; &#34;&#34;&#34; soup = BeautifulSoup(html_doc, features=&#34;html.parser&#34;) print(type(soup.p)) # =&gt; &lt;class &#39;bs4.element.Tag&#39;&gt; HTML 要素の Tag オブジェクトを取得できたら、次のように直感的にその内容を参照できます。 print(soup.p) # =&gt; &lt;p class=&#34;foo&#34;&gt;This is &lt;b&gt;bold&lt;/b&gt; text.&lt;/p&gt; print(soup.p.name) # =&gt; &#39;p&#39; print(soup.p.text) # =&gt; &#39;This is bold text.&#39; print(soup.p[&#34;class&#34;]) # =&gt; [&#39;foo&#39;] print(soup.p.get(&#34;class&#34;)) # =&gt; [&#39;foo&#39;] 属性値の取得方法には [] を使う方法と、get() 使う方法があることに注意してください。 指定した属性値が存在しない場合、[] が KeyError を発生させるのに対し、get() は None を返します。 いろいろな条件で要素を見つける 前述の例では、p 要素を参照するときに soup.p のように記述していました。 その代わりに find メソッドを使用すると、いろいろな条件で HTML 要素を検索することができます。 # 最初の p 要素 elem = soup.find(&#34;p&#34;) # id 属性が sidebar である要素 elem = soup.find(id=&#34;sidebar&#34;) # class 属性に comment を含む要素 elem = soup.find(class_=re.compile(&#34;comment&#34;)) # href 属性に特定のドメイン名を含む a 要素 elem = soup.find(&#34;a&#34;, href=re.compile(&#34;^https://example.com/&#34;)) class キーワードは Python の予約語のため、HTML 要素の class 属性値を検索するには、末尾に _ の付いた class_ というパラメータ名を使用することに注意してください。 すでに find メソッドによって見つけた要素がある場合は、その要素を基準にして子要素を検索することができます。 title = soup.find(&#34;head&#34;).find(&#34;title&#34;) 要素が見つからない場合、find メソッドは None を返します。 特定の条件に一致する要素をすべて見つける 指定したタグ名の要素をすべて取得するには、find_all メソッドを使用します。 戻り値は、bs4.element.ResultSet オブジェクトで、for ループを使って見つかった要素を順番に処理できます。 次の例では、すべての a 要素を取得しています。 a 要素をすべて取得する from bs4 import BeautifulSoup html_doc = &#39;&#39;&#39;&lt;html&gt;&lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;a href=&#34;https://google.com/&#34;&gt;Google&lt;/a&gt; &lt;a href=&#34;https://yahoo.com/&#34;&gt;Yahoo&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;&#39;&#39;&#39; soup = BeautifulSoup(html_doc, features=&#34;html.parser&#34;) links = soup.find_all(&#34;a&#34;) for link in links: print(link.text) 実行結果 Google Yahoo 見つかった要素の属性は、attrs プロパティで参照できます。 次の例では、HTML 内のすべての a 要素を検索し、その href 属性を出力しています。 links = soup.find_all(&#34;a&#34;) for link in links: if &#34;href&#34; in link.attrs: print(link.text, &#34;:&#34;, link.attrs[&#34;href&#34;]) 実行結果 Google : http://google.com/ Yahoo : http://yahoo.com/ CSS セレクタによる要素の検索 find_all の代わりに、select メソッドを使用すると、CSS セレクタによる要素の検索を行えます。 elems = soup.select(&#34;a&#34;) # すべての a 要素 elems = soup.select(&#34;table tr&#34;) # table 要素以下の tr 要素 elems = soup.select(&#34;.hoge&#34;) # class 属性に hoge を含む要素 elems = soup.select(&#34;table.hoge&#34;) # class 属性に hoge を含む table 要素 elems = soup.select(&#34;#nav&#34;) # id 属性が nav である要素 elems = soup.select(&#34;#nav a&#34;) # id 属性が nav である要素以下の a 要素"},{url:"/p/k5p4axo/",title:"Python で HTTP を扱う方法いろいろ",date:"2015-05-17T00:00:00+09:00",body:"Python で HTTP を扱う方法いろいろ Python3 の標準 HTTP ライブラリ Python3 には HTTP を扱う、下記のような標準ライブラリが用意されています。 http.client HTTP (RFC 2616) を実装する 低レベルライブラリ。 urllib.request 上記を利用した 高レベルライブラリ。認証やリダイレクトをサポートしています。 オープンソースの HTTP ライブラリ Python に標準で付属している urllib.request パッケージは、比較的低レベルな処理を行うように設計されているため、手っ取り早く HTTP リクエストでデータを取得したい場合は、オープンソースの requests パッケージ を使うとよいでしょう。 requests パッケージは、Python の公式サイトでも推奨されています。 requests パッケージ"},{url:"/p/7o9q8p6/",title:"Python のパッケージ管理ツール (pip) の使い方",date:"2015-05-17T00:00:00+09:00",body:"Python のパッケージ管理ツール (pip) の使い方 pip とは Python のパッケージ管理ツールである pip コマンドは、従来の setuptools で提供されていた easy_install コマンドを置き換えるものです。 pip コマンドは、主に Python Package Index からパッケージをダウンロードしてインストールします。 pip のインストール Python 3.4 以降の Python インストーラを使用すると、pip コマンドは標準でインストールされます。 下記のいずれかの方法ですでにインストールされているか確認しましょう。 $ pip --version $ python -m pip --version $ python3 -m pip --version 単体でインストールする必要がある場合は、基本的には下記のサイトに従ってインストールします。 Installation - pip documentation pip 1.5.1 までは、setuptools の easy_install コマンドを使用してインストールしていましたが、現在は get-pip.py スクリプトを使ってどの OS 環境でも統一された方法で簡単にインストールすることができます。 pip コマンドのインストール $ curl -kL https://bootstrap.pypa.io/get-pip.py | python3 プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。 pip によるパッケージのインストール、アンインストール $ pip install &lt;package&gt; $ pip install -U &lt;package&gt; # パッケージを最新版にアップグレード $ pip install -I &lt;package&gt; # パッケージをインストールしなおす $ pip uninstall &lt;package&gt; # パッケージのアンインストール プロキシ環境で使用する場合は、--proxy=proxy.example.com:8080 のようにオプション指定します。 pip コマンドのアップデート pip コマンド自身のバージョン更新は、pip コマンドを使って行うことができます。 $ pip install -U pip"},{url:"/p/deia4to/",title:"よいツールの条件",date:"2015-05-17T00:00:00+09:00",body:"よいツールの条件 まくが考えるよいツールの条件は下記を満たすものです。 インストールが簡単 ユーザインタフェースがシンプル 拡張・カスタマイズが容易 ドキュメントにアクセスしやすい ドキュメントがわかりやすく包括的 ソースコードがわかりやすい 自分でツールを作るときは、常にこういったことを忘れないように気をつけるとよいです。"},{url:"/p/x7hr9z7/",title:"GitHub の Organization を構成したときのチームの権限について理解する",date:"2015-05-07T00:00:00+09:00",body:"GitHub の Organization を構成したときのチームの権限について理解する GitHub の Organization の 4 種類のチーム GitHub で Organization を作成すると、その下に作成したリポジトリは、Organization 内に作成したチーム単位でアクセス権限を設定することになります。 GitHub のサイト にざっと説明がありますが、分かりにくいのでここで補足します。 チーム区分としては、 Owners Admin Write Read に分かれていて、それぞれ異なる権限を持ちます。 Owners チームとその権限 Owners はその名の通り organization 自体の管理者チームであり、デフォルトで存在しているものです。 残りの 3 つ（Admin、Write、Read）とは性質が異なり、削除したり、Owners という名前を変更することはできません。 organization を作成した人が、Owners の最初のメンバになります。 Owners 権限 デフォルトで存在するチームで、その organization に関してすべての権限を持つ Owners に属するメンバは、支払い情報を管理し、クレジットカードなどの登録を行う Owners には必ず 1 人以上が所属している必要がある organization へのメンバ追加が可能 リポジトリを作成可能 チームを作成可能 残りの Admin、Write、Read というのは、後付で作成したチームに対して割り当てる権限を意味しています。 Owners チームは organization 内でひとつしか存在しませんが、Admin、Write、Read 権限を持つチームは複数作ることが可能です。 チームを作成できるのは Owners のメンバだけです。 各リポジトリへのアクセス権限は、このチーム単位で参加者 (contributors) を割り当てることで行います。 例えば、my-project というリポジトリの contributors として、team1 (Write 権限)、team2 (Read 権限) を参加させた場合、team1 に参加しているメンバだけが、my-project へのコミット権限を持つことになります。 リポジトリに対してチームを割り当てることができるのは Owners のメンバだけです。 Admin チームとその権限 チームの作成やリポジトリへの登録は Owners のメンバしか行えませんが、Admin チームに属していれば、リポジトリの作成を行うことができます。 さらに、Admin チームに属するメンバは、その Admin チーム自体へのメンバ追加が可能です。 Admin 権限 リポジトリを作成可能。 organization へのメンバ追加が可能。 Admin チームへのメンバ追加が可能（Admin 以外のチームへのメンバ追加は行えない） リポジトリに Admin チームを登録すると、Admin チームメンバはそのリポジトリの設定変更可能。 Admin チームに属しているけれど、Owner チームには属していないメンバがリポジトリを作成すると、そのリポジトリの contributor に自動的に Admin チームが追加されてしまうようです。 このとき、複数の Admin チームに属していた場合は、その中のいずれかのチームが contributor として登録されます。 Admin チームは扱いにくいですね・・・。 Write / Read チームとその権限 Write 権限、Read 権限については分かりやすく、リポジトリへの push が可能かどうかを示しています。 コードを Read only で見るだけでよいのであれば、そのユーザを Read 権限だけ付いたチームに登録し、そのチームを対象のリポジトリの contributor として登録します。 運用例 例えば、下記のようなルールで運用すると、各リポジトリごとに細かくメンバのアクセス権限を制御することができます。 Owners メンバがリポジトリ（例: rep1）の作成を行う。 Owners メンバがそのリポジトリ用の Write 権限のチーム（例: team-rep1）、Read 権限のチーム（例: team-rep1-ro）を作成し、リポジトリに登録する。 リポジトリ rep1 の開発メンバは team-rep1 に所属させる。 リポジトリ rep1 をリードオンリーで参照させたいメンバは team-rep1-ro に所属させる。 そのリポジトリの設定を Owners メンバ以外に任せたくなったら、そのリポジトリ用の Admin 権限のチーム（例 team-rep1-admin）を作成し、リポジトリに登録する。"},{url:"/p/rtrb95n/",title:"ぐちゃぐちゃなコードしかないチーム／プロジェクトに配属された場合のポジティブ思考",date:"2015-04-26T00:00:00+09:00",body:"ぐちゃぐちゃなコードしかないチーム／プロジェクトに配属された場合のポジティブ思考 どうしようもないコードがたくさんある、読んでも意図がわからないコードがいっぱい、というプロジェクトに配属されると気が滅入りそうになります。 でも嘆いているだけでは何も改善しません。 そんなときこそポジティブシンキングです。 リファクタリングの技術を磨くことができる！ レガシーコードをテスト可能にする技術を磨くことができる！ ダメなところ（メンテナンス性、速度、メモリ、潜在不具合）を見つけるソフトを使いこなせるようになる！ 構造を見直して高速化する技術を磨くことができる！ 分かりにくいコードをデバッグする技術を磨くことができる！ と考えれば、ダメダメなコードも自分の成長のための題材なんだと捉えられるようになります。 現在の環境の中でいかに成長できるのかを考えましょう。"},{url:"/p/s8i5cr9/",title:"ESLint で JavaScript コードの静的解析を行う",date:"2015-04-07T00:00:00+09:00",body:"ESLint で JavaScript コードの静的解析を行う eslint コマンドのインストール ESLint のインストールは、Node.js の npm コマンドで簡単に行うことができます。 eslint のインストール $ npm install -g eslint インストールできたか確認します。 $ eslint --version v0.18.0 次のように .js ファイルを指定することで静的解析を実行できます。 sample.js の静的解析 $ eslint sample.js ESLint の設定ファイル ESLint の設定は、JSON 形式あるいは YAML 形式の .eslintrc ファイルで行います。 以下のような構成で、前提とする実行環境、参照可能なグローバルオブジェクト、適用する Lint ルールの設定、を記述していきます。 .eslintrc ファイルの構成 { &#34;env&#34;: { (1) 実行環境 }, &#34;globals&#34;: { (2) 参照するグローバルオブジェクト }, &#34;rules&#34;: { (3) Lint ルールの設定 } } Node モジュールとして作成する JS ファイルに対しては、package.json の中に ESLint の設定を記述してしまうことができます。 その場合は、下記のように、eslintConfig プロパティの中に同様の設定を記述します。 package.json { &#34;name&#34;: &#34;myapp&#34;, &#34;version&#34;: &#34;0.0.1&#34;, &#34;eslintConfig&#34;: { &#34;env&#34;: { &#34;browser&#34;: true, &#34;node&#34;: true } } } それでは、各項目の順番に設定方法を見ていきます。 (1) Environments - 実行環境の指定 このセクションでは、その JS ファイルがどのような環境で実行されるかを指定します。 例えば、「ブラウザ」上で実行する、「AMD モジュール」として作る、「Node モジュール」として作る、といった前提環境を指定します。 ここで環境を指定することにより、その環境に合わせたグローバルオブジェクトの参照許可や、Lint ルールなどが自動的に設定されます。 指定できる環境の一覧は、 https://eslint.org/docs/user-guide/configuring の Specifying Environments の節に、次のように列挙されています。 browser - browser global variables. node - Node.js global variables and Node.js-specific rules. amd - defines require() and define() as global variables as per the amd spec. mocha - adds all of the Mocha testing global variables. jasmine - adds all of the Jasmine testing global variables for version 1.3 and 2.0. phantomjs - phantomjs global variables. jquery - jquery global variables. prototypejs - prototypejs global variables. shelljs - shelljs global variables. es6 - enable all ECMAScript 6 features except for modules. 例えば、ブラウザ上で実行する JavaScript コードであり、その中で jQuery と RequireJS を使用したいのであれば、下記のように定義します。 .eslintrc（抜粋） { &#34;env&#34;: { &#34;amd&#34;: true, // Refer to define() and require() as AMD modules &#34;browser&#34;: true, // Refer to document object etc. as web browser &#34;jquery&#34;: true // Refer to $ object to use jQuery library }, &#34;globals&#34;: { ... }, &#34;rules&#34;: { ... } } このように環境設定しておくことで、jQuery オブジェクト ($) などのグローバルオブジェクトにアクセスしても、未定義エラーとして検出されないようにすることができます。 (2) Globals - 参照するグローバルオブジェクト このセクションでは、参照可能なグローバル変数を、ひとつずつ明示的に設定することが可能です。 環境設定セクションに &quot;amd&quot;: true と書いてあれば、define() と require() はアクセス可能になるのですが、下記のように明示的に指定することも可能です。 .eslintrc（抜粋） { &#34;env&#34;: { ... }, &#34;globals&#34;: { &#34;define&#34;: true, &#34;require&#34;: true }, &#34;rules&#34;: { ... } } JSLint と同様に、ソースコードの中で、参照可能なグローバルオブジェクトを定義しておくこともできます（変数名の後ろの false は、このファイルで代入を行わないということを示します）。 .js ファイルの中で /*global var1:false, var2:false*/ (3) Rules - 適用する Lint ルールの設定 ルールのセクションでは、実際に適用する Lint ルールの設定を行います（ここが設定が重要）。 各ルールに対しての設定を、下記のようなプロパティの形でひとつずつ指定していきます。 &#34;ルール名&#34;: 適用方法, 適用方法の部分には、そのルールをどう反映するかを表す、0、1、2 のいずれかの値を指定します。 適用方法 0 - off（ルールを無効にする） 1 - warning（警告として検出する） 2 - error（エラーとして検出する） ルール設定には、追加のパラメータを持つものもあり、その場合は配列の形で設定値を記述します。 配列の 1 番目の値として、上記と同様に 0、1、2 のいずれかの適用方法を指定します。 &#34;ルール名&#34;: [適用方法, 追加パラメータ1, 追加パラメータ2] .eslintrc（抜粋） { &#34;env&#34;: { ... }, &#34;globals&#34;: { ... }, &#34;rules&#34;: { /* * Possible Errors */ &#34;valid-jsdoc&#34;: 2, // Ensure JSDoc comments are valid &#34;no-duplicate-case&#34;: 2, // Disallow a duplicate case label &#34;no-empty&#34;: 2, // Disallow empty statements &#34;no-irregular-whitespace&#34;: 2, // Disallow irregular whitespace &#34;no-unreachable&#34;: 2, // Disallow unreachable statements &#34;use-isnan&#34;: 2, // Disallow comparisons with the value NaN /* * Stylistic Issues */ &#34;camelcase&#34;: 1, // Require camel case names &#34;indent&#34;: [1, 2], // An indent should be two spaces &#34;quotes&#34;: [1, &#34;single&#34;, &#34;avoid-escape&#34;], // Surround a string with single quotation /* * Legacy */ &#34;max-len&#34;: [1, 80, 2], // The maximum length of a line } } デフォルトで有効になっているルールに関しては、適用方法として 2（エラーとして検出）が設定されます。 組み込みで用意されているルールの一覧は、下記のサイトで確認することができます。 ESLint - Rules"},{url:"/p/ufcmoxr/",title:"JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint)",date:"2015-04-07T00:00:00+09:00",body:"JavaScript の静的解析ツールの比較 (JSLint, JSHint, ESLint) 各ツールのトレンド 2015 年時点では JSHint が一番メジャーですが、これからは ESLint が主流になりそうです。 JSLint は使われなくなりつつあります。 図: JavaScript の静的解析ツールのトレンド それぞれのツールの特徴 JSLint https://jslint.com 初期リリースは 2007 年頃。 作者は Douglas Crockford で、著書に JavaScript Good Parts があり、JSON RFC4627 の仕様策定などを行っている人です。 後出の JSHint に比べると、デフォルトのチェックが厳しいです。 この厳しさは好き嫌いが分かれるところで、逆にチェックの緩い JSHint の方が好まれる理由にもなっています。 JSHint https://jshint.com 初期リリースは 2011 年頃。 作者は Anton Kovalyov（アントン・コバリャノフ）で、JSLint の fork として作られました。 ベースとなった JSLint は便利である一方で、作者 Douglas Crockford の頑固な設定（var 宣言は 1 つにまとめないと必ずエラーなど）が強制されるため、開発者から敬遠される部分が多くありました。 そこで、Anton は、より柔軟な設定を行える JSLint となることを目指して 2011 年に JSHint の開発を始めました。 JSLint と比べると、デフォルト設定におけるチェックが甘いため、有効活用するためには適切な設定を行う必要があります。 設定は JSON 形式のファイル (.jshintrc) で行えます。 JSHint は、インデントのスペース数などのコーディングスタイルに関するチェックを行うことは対象外とすることを決め、そういったチェックは JSCS を使ってくださいということになりました（そこまでやるのなら ESLint を使った方が楽かも）。 ESLint https://eslint.org 初期リリースは 2013 年頃。 作者は Nicholas C. Zakas です。 ルールの拡張を自由に行えることが特徴で、これを Pluggable と読んでいます。 JSLint/JSHint 互換のルールも、デフォルトで Pluggable なルールとして用意されています。 実装的には、Esprima でパースした結果の AST (Abstract Syntax Tree) をそれぞれの Lint ルールに渡すようになっているため、ESLint の本体はクリーンな実装がキープされるようになっています（1-pass で実行されないため若干遅いところが欠点）。 それぞれのルールはルール名で区別され、個別に ON/OFF することができます（0:無効、1:警告として検出、2:エラーとして検出）。 JSLint や JSHint よりも、ドキュメントがしっかりと書かれていて好感が持てます。 JSHint よりも設定を分かりやすく柔軟に記述することができます。 設定ファイルは JSON あるいは Yaml 形式の .eslintrc で記述します。 Node.js アプリでは、package.json 内の eslintConfig フィールドに設定を書くことができます（こちらはもちろん JSON 形式で記述します）。 出力結果もデフォルトで色付けされていたり、エラーメッセージとともにルール ID などが表示されるので、細かいところに手が届いている感じがします。 どのようなコードを検出してくれるか？ ここでは、参考までに、JSLint と JSHint がどのようなコードに対して、どういった警告表示を行ってくれるかを示します。 JSLint と JSHint 共通の検出項目（デフォルト設定時） 関数外で &lsquo;use strict&rsquo; しているときに警告 JSLint: Use the function form of 'use strict'. JSHint: Use the function form of &quot;use strict&quot;. 未定義の変数、関数アクセスの警告 JSLint: 'xxx' was used before it was defined. JSHint: 'xxx' is not defined. 未使用の変数、関数の検出 JSLint: Unused 'xxx'. JSHint: unused variable 'xxx'. eval は使用禁止 JSLint: eval is evil. JSHint: eval can be harmful. 行末にセミコロンがない JSLint: Expected ';' and instead saw 'xxx'. JSHint: Missing semicolon. case が break や return、throw で終わっていない JSLint: Missing 'break' after 'case'. JSHint: Expected a 'break' statement before 'case'. コンストラクタ（new をつけて呼んだ関数）が大文字で始まっていない JSLint: A constructor name 'xxx' should start with an uppercase letter. JSHint: A constructor name should start with an uppercase letter. new Object() の代わりに {} を使う JSLint: Use the object literal notation {} or Object.create(null). JSHint: The object literal notation {} is preferable. JSLint 独自の検出項目（デフォルト設定時） &lsquo;use strict&rsquo;; がない場合に警告 Missing 'use strict' statement. 比較は == や != を使用せずに、=== や !== で行う Expected '===' and instead saw '=='. おかしな条件の検出（switch (1) など） Weired condition. ++ によるインクリメント、&ndash; によるデクリメントはデフォルトで禁止 Unexpected '++'. インデントのスペース数 Expected 'var' at column 3, not column 5. 無名関数の function と () の間にスペースがないことを検出 Expected exactly one space between 'function' and '('. 一行の最大文字数 Line too long. if や for ステートメントは、必ず {} ブロックで囲む Expected '{' and instead saw 'xxx'. 変数定義は関数の先頭でまとめて 1 つの var で行う Move 'var' declarations to the top of the function. Don't declare variables in a loop. Combine this with the previous 'var' statement. JSHint 独自の検出項目（デフォルト設定時） JSHint はデフォルトではほとんどチェックしてくれません。 変数と 0 の比較は &lsquo;===&rsquo; で行う Use '===' to compare with '0'. 使い方 それぞれのツールの使い方は下記を参照してください。 JSLint で JavaScript コードの静的解析を行う JSHint で JavaScript コードの静的解析を行う ESLint で JavaScript コードの静的解析を行う"},{url:"/p/y7o9g7a/",title:"JSHint で JavaScript コードの静的解析を行う",date:"2015-04-07T00:00:00+09:00",body:"JSHint で JavaScript コードの静的解析を行う JSHint は JavaScript の静的解析ツールのひとつです。 JSLint を元に作成されていますが、より柔軟な設定ができるようになっています。 JSHint のインストール JSHint は JSHint の Web サイト 上に直接コードを記述して実行することもできますが、通常は Node.js によるコマンドライン版（jshint コマンド）を使用します。 Node.js がインストールされている環境であれば、npm (Node Package Manager) コマンドを使用して簡単にインストールすることができます。 jshint のインストール $ npm install -g jshint Windows 7 の場合、上記のようにインストールしたパッケージは、以下のディレクトリに保存されるようなので、このディレクトリに PATH が通っていない場合はコントロールパネルから PATH に追記しておくようにします。 C:\\Users\\&lt;UserName&gt;\\AppData\\Roaming\\npm\\ インストールが終わったら、jshint コマンドが実行できるようになっているはずです。 jshint コマンドの実行 $ jshint --version jshint v2.6.3 JSHint の実行方法 実際に解析を行う場合は、以下のように .js ファイルを指定して実行します。 sample.js を jshint で解析 $ jshint sample.js sample.js: line 8, col 6, Missing semicolon. 1 error 問題が見つからなかった場合は、何も表示されません。 ファイル名の代わりにディレクトリ名を指定すれば、そのディレクトリ以下のすべての .js ファイルに対して実行することもできます。 カレントディレクトリ以下の .js ファイルを解析 $ jshint . JSHint の設定 JSHint はデフォルトの設定では緩いチェックしか行ってくれないので、本格的に使用するには、適切な設定ファイルを用意する必要があります。 JSHint のオプション一覧は下記のサイトで確認することができます。 JSHint Options JavaScript コードのあるディレクトリ内に、JSON 形式の .jshintrc ファイルを置いておくと、jshint コマンドを実行したときにその設定が使われるようになります。 .jshintrc ファイルが見つからない場合は、上位のディレクトリを見つかるまで上りながら探索してくれます。 つまり、プロジェクトの最上位のディレクトリに .jshintrc を置いておけば、下位のディレクトリからその設定を利用して jshint を実行できるということです。 .jshintrc の記述例 { // Enforcing options &#34;camelcase&#34; : true, // 変数名は camelCase で &#34;curly&#34; : true, // if や for の後ろのブロックを表す括弧 {} を強制する &#34;forin&#34;: true, // オブジェクトの for-in では hasOwnProperty でフィルタ &#34;indent&#34; : 2, // インデントはスペース 2 文字 &#34;loopfunc&#34;: true, // ループの中で関数の定義禁止 &#34;maxdepth&#34;: 4, // 関数内の最大ネスト数 &#34;strict&#34; : true, // &#39;use strict&#39;; の強制 &#34;trailing&#34;: true, // 行末の無駄なスペース禁止 &#34;undef&#34;: true, // 未定義のオブジェクトへのアクセスを禁止 &#34;unused&#34;: true, // 未使用のオブジェクトが見つかったら警告 // Environments &#34;browser&#34; : true, // ブラウザ用の変数参照を許可 (例: document オブジェクト) &#34;devel&#34; : true, // alert、console へのアクセスは許す &#34;jquery&#34; : true, // jQuery のグローバルは許す &#34;prototypejs&#34; : true // prototypejs のグローバルは許す } 別の名前の設定ファイルを使いたい場合は、--config オプションでファイル名を指定することができます。 $ jshint --config config.json main.js コードの一部分だけ JSHint のチェックを無効にする ファイル内の一部のコードだけ、JSHint によるチェックを無効にするには、以下のようなコメントでコードを囲みます。 /* jshint ignore:start */ ...ここに記述したコードは JSHint によるチェックの対象外となる... /* jshint ignore:end */ 行末コメントにより、一行だけチェックを無効にすることもできます。 ignoreThis(); // jshint ignore:line"},{url:"/p/os3jvi6/",title:"JSLint で JavaScript コードの静的解析を行う",date:"2015-04-07T00:00:00+09:00",body:"JSLint で JavaScript コードの静的解析を行う jslist コマンドのインストール JSLint は Web サイト上 (https://jslint.com) でコードを張り付けて実行することができますが、普段の開発では jslint コマンドとして実行できるようにしておいた方が便利です。 多くのスクリプトエンジンによるラッパ実装がありますが、ここでは手軽な Node.js 版の node-jslist をインストールしてみます（あらかじめ Node.js をインストールして、npm コマンドを使えるようにしておく必要があります）。 jslint のインストール $ npm install -g jslint インストールが終わったら、動作確認します。 $ jslint --version node-jslint version: 0.9.0-pre006 JSLint edition 2013-08-26 使い方は簡単で、以下のように解析対象の .js ファイルを指定するだけです。 $ jslint sample.js $ jslint **/*.js # カレントディレクトリ以下の全ての JS ファイルに対して実行 グローバルな変数や関数を参照するときのエラーを抑制する jQuery の $ や、console、document などのグローバル変数（別のファイルで定義されている変数）を参照しようとすると、JSLint は未定義エラーと認識してしまいます。 グローバル変数を参照してもエラーにならないようにするには、global ディレクティブを使用します。 下記の例では、$ と console を参照できるようにしています。 /*global $: false, jQuery: false, console: false */ $(function () { &#39;use strict&#39;; console.log(&#39;hello&#39;); }); global というキーワードの前に、スペースを入れてはいけないことに注意してください。 各変数の後ろの、false という値は、そのグローバル変数に対して、このファイルからは代入を行っていないということを示しています。 複数の JavaScript ファイルからグローバル変数の値を変更することは、メンテナンス性を著しく下げることになるため、通常は上記のように false にしておくのがよいでしょう。"},{url:"/p/ao8p7n4/",title:"Android ビルド環境を構築するための Dockerfile",date:"2015-04-02T00:00:00+09:00",body:"Android ビルド環境を構築するための Dockerfile 下記の Dockerfile を使うと、Ubuntu 14.04 あるいは、Ubuntu 12.04 をベースにした Android ビルド用の Docker イメージを作成することができます。 Dockerfile (Ubuntu 14.04) FROM ubuntu:14.04 # Set the proxies if needed. # ENV http_proxy http://proxy.example.com:10080/ # ENV https_proxy http://proxy.example.com:10080/ # Suppress errors on interactive installer ENV DEBIAN_FRONTEND noninteractive # To install i386 packages such as zlib1g-dev:i386 RUN dpkg --add-architecture i386 # The following is based on http://source.android.com/source/initializing.html # For installing openjdk-7-jdk, --no-install-recommends option has to be added # not to struggle with &#39;colord&#39; and &#39;sgml-base&#39; errors. RUN apt-get -qq update RUN apt-get install -y openjdk-7-jdk --no-install-recommends RUN apt-get install -y bison g++-multilib git gperf libxml2-utils make zlib1g-dev:i386 zip --no-install-recommends # For the repo command RUN apt-get install -y curl python --no-install-recommends Dockerfile (Ubuntu 12.04) FROM ubuntu:12.04 # Set the proxies if needed. # ENV http_proxy http://proxy.examle.com:10080/ # ENV https_proxy http://proxy.example.com:10080/ # Suppress errors on interactive installer ENV DEBIAN_FRONTEND noninteractive # The following is based on http://source.android.com/source/initializing.html RUN apt-get -qq update RUN apt-get install -y openjdk-7-jdk --no-install-recommends RUN apt-get install -y git gnupg flex bison gperf build-essential zip curl libc6-dev libncurses5-dev:i386 x11proto-core-dev libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-glx:i386 libgl1-mesa-dev g++-multilib mingw32 tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 --no-install-recommends やっていることは、ほぼ下記に記述されている通りです。 http://source.android.com/source/initializing.html ただ、いくつかポイントがあり、下記のような設定を行っています。 インストール時の readline 系エラーの抑制 (ENV DEBIAN_FRONTEND noninteractive) 無駄なパッケージのインストールによるエラー抑制 (apt-get install -y openjdk-7-jdk --no-install-recommends) Ubuntu 14.04 の場合は、i386 系パッケージのインストール設定 (RUN dpkg --add-architecture i386) Ubuntu 14.04 の場合は、repo コマンドのダウンロード＆実行のために curl、python (2.7) を追加インストール 実際に Docker イメージを作成するには、この Dockerfile がカレントディレクトリにある状態で、下記のように実行します。 $ sudo docker build android_ubuntu14 ./ これで、android_ubuntu14 というイメージが作成されるので、あとは、Docker コンテナとして起動できます。 $ sudo docker run -it android_ubuntu14 /bin/bash この Docker イメージは、あくまでビルド環境の構築までしか行っていないため、実際にビルドをする前には、repo を使ったソースコードのダウンロードなどを行う必要があります。 http://source.android.com/source/downloading.html 上記の Android 公式サイトでは、ホームディレクトリの ~/bin に repo コマンドをインストールしていますが、Docker コンテナ上での実行時には、適宜 /opt/bin などに読み替えるとよいでしょう。"},{url:"/p/p4o6m3i/",title:"Docker チートシート／Docker コマンドの一覧",date:"2015-04-02T00:00:00+09:00",body:"Docker チートシート／Docker コマンドの一覧 Registry / Repository / Image / Tag の概念 図: Docker のコンテナレジストリ／リポジトリ／イメージ／タグの関係 DockerHub などのレジストリ上では、複数のリポジトリが管理されている。 Top-level リポジトリでは、ubuntu や devian といった有名どころなものが管理されている。 Top-level リポジトリ以外に、ユーザリポジトリがあり、こちらは &lt;user&gt;/ というプレフィックスが付く。 各リポジトリ内には複数のイメージがあり、イメージ ID やタグで指定できる。 1 つのイメージに対しては唯一の ID が付けられるが、タグは複数付けられていることがある。 docker image（イメージ関連のコマンド） コマンド 旧コマンド 説明 docker image build docker build Dockerfile からイメージをビルドする Build an image from a Dockerfile docker image history docker history イメージのレイヤ構造を表示する Show the history of an image docker image import docker import tar ファイルからファイルシステムイメージを作成する Import the contents from a tarball to create a filesystem image docker image inspect docker inspect イメージの詳細を表示する Display detailed information on one or more images docker image load docker load tar ファイルや標準入力からイメージをロードする Load an image from a tar archive or STDIN docker image ls docker images イメージの一覧を表示する List images docker image prune なし 使用していないイメージを削除する Remove unused images docker image pull docker pull レジストリからイメージを取得する Pull an image or a repository from a registry docker image push docker push イメージをリポジトリにプッシュする Push an image or a repository to a registry docker image rm docker rmi イメージを削除する Remove one or more images docker image save docker save tar ファイルにイメージを保存する Save one or more images to a tar archive (streamed to STDOUT by default) docker image tag docker tag イメージにタグを付ける Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE docker container（コンテナ関連のコマンド） コマンド 旧コマンド 説明 docker container attach docker attach 動作中のコンテナに標準入力や標準出力を接続する Attach local standard input, output, and error streams to a running container docker container commit docker commit コンテナの変更内容から新しいイメージを作成する Create a new image from a container&rsquo;s changes docker container cp docker cp コンテナとホスト間でファイルをコピーする Copy files/folders between a container and the local filesystem docker container create docker create 新しいコンテナを作成する Create a new container docker container diff docker diff Inspect changes to files or directories on a container&rsquo;s filesystem docker container exec docker exec 動作中のコンテナで新しいプロセスを起動する Run a command in a running container docker container export docker export Export a container&rsquo;s filesystem as a tar archive docker container inspect docker inspect コンテナの詳細情報を表示する Display detailed information on one or more containers docker container kill docker kill Kill one or more running containers docker container logs docker logs Fetch the logs of a container docker container ls docker container list docker container pm docker ps コンテナの一覧を表示する List containers docker container pause docker pause Pause all processes within one or more containers docker container port docker port コンテナとホスト PC のポートマッピング情報を表示する List port mappings or a specific mapping for the container docker container prune なし Remove all stopped containers docker container rename docker rename Rename a container docker container restart docker restart Restart one or more containers docker container rm docker rm Remove one or more containers docker container run docker run 「イメージの取得」「コンテナの作成」「コンテナの起動」を連続して行う Run a command in a new container docker container start docker start 作成済みのコンテナを起動する Start one or more stopped containers docker container stats docker stats Display a live stream of container(s) resource usage statistics docker container stop docker stop Stop one or more running containers docker container top docker top Display the running processes of a container docker container unpause docker unpause Unpause all processes within one or more containers docker container update docker update Update configuration of one or more containers docker container wait docker wait Block until one or more containers stop, then print their exit codes docker network（ネットワーク関連のコマンド） コマンド 説明 docker network connect コンテナをネットワークに接続する (Connect a container to a network) docker network create ネットワークを作成する (Create a network) docker network disconnect コンテナをネットワークから切り離す (Disconnect a container from a network) docker network inspect ネットワークの詳細情報を表示する (Display detailed information on one or more networks) docker network ls ネットワークの一覧を表示する (List networks) docker network prune 未使用のネットワークをすべて削除する (Remove all unused networks) docker network rm ネットワークを削除する (Remove one or more networks) docker volume（ボリューム関連のコマンド） コマンド 説明 docker volume create ボリュームを作成する (Create a volume) docker volume inspect ボリュームの詳細情報を表示する (Display detailed information on one or more volumes) docker volume ls ボリュームの一覧を表示する (List volumes) docker volume prune 使用していないボリュームを削除する (Remove all unused local volumes) docker volume rm ボリュームを削除する (Remove one or more volumes) docker compose（複数コンテナのコントロール） コマンド 説明 docker compose build Build or rebuild services docker compose config Validate and view the Compose file docker compose convert Converts the compose file to platform&rsquo;s canonical format docker compose cp Copy files/folders between a service container and the local filesystem docker compose create Creates containers for a service docker compose down Stop and remove containers, networks docker compose events Receive real time events from containers docker compose exec Execute a command in a running container docker compose images List images used by the created containers docker compose kill Force stop service containers docker compose logs View output from containers docker compose ls List running compose projects docker compose pause Pause services docker compose port Print the public port for a port binding docker compose ps List containers docker compose pull Pull service images docker compose push Push service images docker compose restart Restart containers docker compose rm Removes stopped service containers docker compose run Run a one-off command on a service docker compose start Start services docker compose stop Stop services docker compose top Display the running processes docker compose unpause Unpause services docker compose up Create and start containers docker compose version Show the Docker Compose version information docker context（Docker コンテキストの切り替え） コマンド 説明 docker context create コンテキストを作成する (Create new context) docker context export コンテキストをエクスポートする (Export a context to a tar or kubeconfig file) docker context import コンテキストをインポートする (Import a context from a tar or zip file) docker context inspect コンテキストの詳細情報を表示する (Display detailed information on one or more contexts) docker context list コンテキストの一覧を表示する (List available contexts) docker context rm コンテキストを削除する (Remove one or more contexts) docker context show 現在のコンテキストを表示する (Print the current context) docker context update 既存のコンテキストの設定を変更する (Update a context) docker context use カレントコンテキストを切り替える (Set the default context) その他のコマンド コマンド 説明 docker search Docker Hub 上のイメージを検索する (Search the Docker Hub for images) docker system df Show docker disk usage docker system events Get real time events from the server docker system info Display system-wide information docker system prune 使用していないデータをまとめて削除 (Remove unused data) docker builder prune ビルドキャッシュを削除する (Remove build cache) Docker ファイルの命令 命令 内容 # &lt;comment&gt; # で始まる行はコメント ADD ファイルをイメージ上にコピーする（URL 指定でのダウンロードや、tar ファイルの展開を行う） CMD ENTRYPOINT が未指定、かつ docker container run で何も指定されなかったときに実行するコマンド COPY ファイルをイメージ上にコピーする ENTRYPOINT docker container run 時に実行するコマンド ENV &lt;name&gt; &lt;value&gt; 環境変数を設定する 例: ENV http_proxy http://proxy.example.com:8888/ 例: ENV PATH $PATH:/foo/bar EXPOSE &lt;port&gt; ポートを公開する FROM &lt;repo&gt;:&lt;tag&gt; ベースイメージを指定する LABEL イメージのメタデータとしてラベルを追加する MAINTAINER &lt;name&gt; &quot;&lt;email&gt;&quot; イメージのメタデータとしてメンテナ名を追加する（非推奨） RUN &lt;command&gt; コマンドを実行する（/bin/sh -c による実行） RUN [&quot;&lt;arg1&gt;&quot;, &quot;&lt;arg2&gt;&quot;, &quot;&lt;arg3&gt;&quot;] コマンドを実行する（シェルを使わない） USER RUN、CMD、ENTRYPOINT のコマンドを実行するユーザー VOLUME 共有可能ボリュームをマウントする WORKDIR &lt;path&gt; 作業ディレクトリを設定する。RUN、CMD、ENTRYPOINT、ADD、COPY 実行時のベースディレクトリとなる。RUN cd では次の命令に引き継がれないので注意"},{url:"/p/3i2iygw/",title:"Docker で apt-get install するときに TERM 系のエラーが出る",date:"2015-04-02T00:00:00+09:00",body:"Docker で apt-get install するときに TERM 系のエラーが出る docker image build などで apt-get install を実行中に、下記のようなエラーが出ることがあります。 debconf: unable to initialize frontend: Dialog debconf: (TERM is not set, so the dialog frontend is not usable.) debconf: falling back to frontend: Readline debconf: unable to initialize frontend: Readline このような場合、Dockerfile で下記のように環境変数を設定してから apt-get するとエラーが出なくなります。 ENV DEBIAN_FRONTEND noninteractive あるいは、apt-get 実行時に下記のようにプレフィックスで設定することもできます。 DEBIAN_FRONTEND=noninteractive apt-get install -y ... DEBIAN_FRONTEND というのは、Debian Installer が使うフロントエンド (UI) を指定するもので、noninteractive にすることで、ユーザの入力を受け付けないインストールが可能になります。 参考: http://www.debian.org/releases/sarge/s390/ch05s02.html.ja"},{url:"/p/6g3j2iz/",title:"Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき",date:"2015-04-02T00:00:00+09:00",body:"Dockerfile からの apt-get install で zlib1g-dev:i386 がインストールできないとき ubuntu:14.04 などのベースイメージに対して、zlib1g-dev:i386 などの i386 系のパッケージをインストールしようとしたときに下記のようなエラーがでることがあります。 E: Unable to locate package zlib1g-dev これを防ぐには、Dockerfile で下記のように実行するようにしておきます。 RUN dpkg --add-architecture i386"},{url:"/p/oziyhxf/",title:"リポジトリ名のついていない Docker イメージをすべて削除する",date:"2015-04-02T00:00:00+09:00",body:"リポジトリ名のついていない Docker イメージをすべて削除する 普通に Docker コンテナ上で編集作業などを行っていると、Docker イメージのキャッシュがどんどん増えていってしまいます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE &lt;none&gt; &lt;none&gt; 8a15692b92ea About an hour ago 1.077 GB &lt;none&gt; &lt;none&gt; 0bcfd9025fab About an hour ago 1.077 GB &lt;none&gt; &lt;none&gt; 4a0a98efbd7e About an hour ago 802.8 MB ... docker image ls コマンドの出力で、REPOSITORY 名が &lt;none&gt; になっているイメージをすべて削除するには、例えば以下のようにします。 $ sudo docker rmi $(docker images | awk &#39;/^&lt;none&gt;/ {print $3}&#39;) 参考: Docker のコンテナイメージを削除する (docker image rm/prune)"},{url:"/p/kp3ubcu/",title:"Androidメモ: ADB 経由でスクリーンキャプチャを取得する (screencap)",date:"2015-04-01T00:00:00+09:00",body:"Androidメモ: ADB 経由でスクリーンキャプチャを取得する (screencap) Android デバイス上で screencap コマンドを使うと、スクリーンキャプチャを取得できます。 ADB 接続ができている状態であれば、下記のように実行することで PC 側のカレントディレクトリに capture.png ファイルを取得できます。 $ adb shell screencap -p /sdcard/capture.png $ adb pull /sdcard/capture.png $ adb shell rm /sdcard/capture.png"},{url:"/p/3yk3j2i/",title:"APK ファイルに署名する (keytool, jarsigner)",date:"2015-03-19T00:00:00+09:00",body:"APK ファイルに署名する (keytool, jarsigner) APK に署名する方法は、従来の Java で行われていた JAR ファイルへの署名方法と同様です。 下記の JAR ファイルへの署名方法を参考にしてください。 参考: JAR ファイルの署名について - まくまく Java ノート (1) keystore ファイルを作成する ここでは下記の条件でキーを作成します。 作成するキーストアファイル名: MyKeyStore.jks エイリアス名: android 有効期限: 10000日 $ keytool -genkey -v -keystore MyKeyStore.jks -alias android -keyalg RSA -keysize 2048 -validity 10000 Enter keystore password:（キーストアのパスワードを入力） （名前や組織名などを聞かれるので順番に入力していく） (2) keystore ファイルを使って APK に署名する 上記のように作成した keystore ファイルには、非公開鍵と、それに関連付けられた X.509 証明書が含まれており、このファイルを使用して APK に署名を行うことができます。 ここでは、MyApp.apk に署名を行います。 $ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore MyKeyStore.jks MyApp.apk android （キーストアのパスワードを入力）（キーエイリアスのパスワードを入力） (3) APK の署名を確認する $ jarsigner -verify -verbose -certs MyApp.apk 参考: APK ファイルの署名を確認する (4) メモリ使用量を最適化するためのバイトアライメントを実行する $ zipalign -v 4 input.apk output.apk"},{url:"/p/y2biqx6/",title:"Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run)",date:"2015-03-15T00:00:00+09:00",body:"Docker でイメージを取得してコンテナを起動する (docker image pull, docker container run) コンテナイメージをダウンロードする (docker image pull) Docker でコンテナを作成するためには、ベースとなるイメージが必要です。 多くのイメージが Docker Hub に用意されているので、通常はここからベースとなるイメージを取得します。 ここでは、Ubuntu 20.04 のイメージをダウンロードしてみます。 docker image pull（旧: docker pull）コマンドに、ダウンロードしたいイメージ名 ubuntu と、バージョンを表すタグ 20.04 を指定してダウンロードします。 省略するとデフォルトタグとして、最新バージョンを表す lastest が使用されます。 イメージを取得する $ docker image pull ubuntu:20.04 20.04: Pulling from library/ubuntu Digest: sha256:669e010b58baf5beb2836b253c1fd5768333f0d1dbcb834f7c07a4dc93f474be Status: Downloaded newer image for ubuntu:20.04 docker.io/library/ubuntu:20.04 ダウンロード済みのイメージの一覧は docker image ls コマンド（旧: docker images）で確認できます。 イメージの一覧を表示する $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 20.04 54c9d81cbb44 2 weeks ago 72.8MB Docker イメージを削除したくなったときは、次のように docker image rm コマンド（旧: docker rmi ）で削除できます。 イメージを削除する $ docker image rm ubuntu:20.04 参考: Docker イメージを削除する (docker image rm) Docker コンテナを起動する (docker container run) docker container run (docker run) コマンドを使うと、指定した Docker イメージからコンテナを起動し、任意のコマンドを実行することができます。 例えば、Ubuntu 20.04 の Docker イメージ上で、echo コマンドを実行するには、以下のようにします。 コンテナを起動する $ docker container run ubuntu:20.04 echo Hello World! Hello World! docker container run コマンドにより、Docker コンテナが起動され、その中で echo が実行されます。 echo コマンドの実行が終わり次第、Docker コンテナはすぐに停止します。 docker container run コマンドで指定したイメージがまだローカルに存在しない場合は、そのイメージを公開レジストリである Docker Hub からダウンロードしてくれます。 なので、実は docker image pull であらかじめイメージを取得しておかなくても、上記の docker container run を直接実行することができます。"},{url:"/p/e6fmtba/",title:"Androidメモ: ScrollView を一番下までスクロールさせる (fullScroll)",date:"2015-03-14T00:00:00+09:00",body:"Androidメモ: ScrollView を一番下までスクロールさせる (fullScroll) Android の ScrollView を一番下までスクロールさせるには、ScrollView#fullScroll() メソッドを使用します。 // final ScrollView scrollView = ((ScrollView) findViewById(R.id.scrollView)); scrollView.post(new Runnable() { @Override public void run() { scrollView.fullScroll(View.FOCUS_DOWN); } }); fullScroll() はメインスレッドから呼び出す必要があるため、post() メソッドを使用して UI スレッドで実行されるようにします。 fullScroll() を呼び出した後は、その ScrollView にフォーカスが当たった状態になります。"},{url:"/p/fnjj2c7/",title:"Androidメモ: 任意の View をフォーカスする (requestFocus)",date:"2015-03-14T00:00:00+09:00",body:"Androidメモ: 任意の View をフォーカスする (requestFocus) View#requestFocus() によって、任意のビューにフォーカスを当てることができます。 メインスレッドから呼び出す必要があることに注意してください。 // Button mButton; mButton.post(new Runnable() { @Override public void run() { mButton.requestFocus(); } }"},{url:"/p/rwco2dp/",title:"Docker イメージを Docker Hub に登録する (docker image push)",date:"2015-03-12T00:00:00+09:00",body:"Docker イメージを Docker Hub に登録する (docker image push) 作成した Docker イメージを Docker Hub リポジトリに登録すると、世界中のユーザがそのイメージを使えるようになります（プライベートにすることもできます）。 まずは、下記のサイトで、Docker Hub リポジトリのアカウントを作成しておく必要があります。 https://hub.docker.com アップロード予定の Docker イメージは、下記のように作成済みであるとします。 ローカルのイメージの一覧を確認 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/sample v1 8a6608d7d353 7 minutes ago 188.3 MB Docker イメージのアップロードには、docker image push コマンドを使用します。 レジストリにイメージをデプロイ $ docker image push maku77/sample:v1 ... （Docker Hub のログインパスワードなどを入力） ... Pushing tag for rev [8a6608d7d353] on {https://cdn-registry-1.docker.io/v1/repositories/maku77/sample/tags/v1} Docker Hub で公開されているイメージは、docker search コマンドで検索することができるので、たった今登録したイメージを検索してみます。 レジストリ上のイメージを検索 $ docker search maku77 NAME DESCRIPTION STARS OFFICIAL AUTOMATED maku77/sample 0 これで、任意の Docker ホストからこのイメージをダウンロードして使えるようになりました。 レジストリからイメージを取得 $ docker pull maku77/sample:v1"},{url:"/p/y8cfimp/",title:"Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach)",date:"2015-03-12T00:00:00+09:00",body:"Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach) 何をするか？ ここでは、Ubuntu の Docker イメージを使ってコンテナを起動し、その上で実行した bash シェルに接続して自由にコマンドを実行できるようにします。 docker container run、start、attach、exec など似たようなコマンドがたくさんありますが、用途はそれぞれ違うのでここでひととおり理解しておきましょう。 コマンド 意味 docker container run 「イメージの取得」「コンテナの作成」「コンテナの起動」を連続して行う docker container start 作成済みのコンテナを「起動」する docker container attach 動作しているコンテナに「接続」する docker container exec 動作しているコンテナで「プロセスを起動」する docker container run はコンテナの「作成」と「起動」 docker container run（旧: docker run）は、もっとも頻繁に紹介されているコマンドですが、内部で複数のことを行うので 一番分かりにくいコマンド かもしれません。 docker container run は次のようなことを一度に実行します。 指定したイメージがなければダウンロード (docker image pull) Docker コンテナを作成する (docker container create) Docker コンテナを起動する (docker container start) 例えば、次のコマンドを実行すると、Docker イメージ (ubuntu:20.04) のダウンロード、Docker コンテナ (mycon) の作成、そのコンテナの起動までを一気に実行します。 $ docker container run --name mycon -it ubuntu:20.04 /bin/bash 各オプションは次のような意味を持っています。 --name mycon … 作成するコンテナに mycon という名前を付ける（省略するとランダムに単語を組み合わせた名前が付けられます。例: cool_blackwell） -i … 標準入力を有効にしたままにする（ようするに現在の端末上からキーボード入力できるようにする） -t … 起動するコマンドに対して TTY 端末を割り当てる（ようするに現在の端末上に bash のプロンプトを表示する） オプションで -i と -t を指定しないと、一瞬で Docker コンテナが終了してしまうので、シェル接続する場合はこれらのオプションを指定する必要があります。 -it というオプション指定は、コンテナ起動してシェル接続する場合のおまじないと考えておけばよいです。 さて、ここで Docker を始めたばかりの人がハマるのが、次のようにコンテナ停止後にふたたび docker container run した場合です。 # 次のようにシェルを終了すると、Docker コンテナが停止する root@65da3272d493:/# exit # 再び run しようとするとエラー！ どうして！？ $ docker container run --name mycon -it ubuntu:20.04 /bin/bash docker: Error response from daemon: Conflict. The container name &#34;/mycon&#34; is already in use by container &#34;65da3272d493c77c2034f58d9a6e0c80f302db3c058e8345e170dc72d67811f4&#34;. You have to remove (or rename) that container to be able to reuse that name. See &#39;docker run --help&#39;. これは、すでに存在する mycon という名前のコンテナをもう一度作成しようとしているからです。 docker container run コマンドが、docker container create を兼ねていることを思い出してください。 コンテナで動作している bash シェルを終了すると Docker コンテナも「停止」するのですが、停止状態のコンテナは残ったままです。 停止状態のコンテナ一覧は、次のようにして確認できます（-a オプションを付けないと、動作中のコンテナしか表示されません）。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65da3272d493 ubuntu:20.04 &#34;/bin/bash&#34; 12 minutes ago Exited (0) 4 minutes ago mycon 停止状態のコンテナがすでに存在するときに、コンテナの起動＆シェルへの接続だけを行うには、次のように docker container start（後述）を使用します。 $ docker container start -ai mycon root@65da3272d493:/# 別の方法として、docker container run の --rm オプションを指定するという方法もあります。 このオプションを指定すると、コンテナが停止したときに、自動的にコンテナが削除されます。 $ docker container run --rm --name mycon -it ubuntu:20.04 /bin/bash 今回の例の場合、シェルから exit すると、mycon コンテナが停止してさらに削除まで行われます。 よって、その後もう一度 docker container run を実行しようとすると、mycon コンテナの作成からやり直しになるので結果的にうまく動作します。 つまり、1 コマンドだけ実行するための使い捨てのコンテナということですね。 すぐに破棄されるので、--name mycon オプションでコンテナに名前を付ける必要はあまりないかもしれません。 docker container start は存在するコンテナを起動する すでに上記で使いましたが、docker container start コマンド（旧: docker start）は「停止状態のコンテナ」を起動するためのコマンドです。 docker container run とは異なり、コンテナの作成は行わないので、存在しないコンテナを起動しようとするとエラーになります。 $ docker container start mycon Error response from daemon: No such container: mycon コンテナを起動するには、あらかじめ docker container create でコンテナを作成しておく必要があります。 過去に docker container run で作成したコンテナでも大丈夫です。 $ docker container create -it --name mycon ubuntu:20.04 /bin/bash 327ad0cfd0047eb90a1ae4ec63769d0680697c48b074d640ed83b793c5d19beb docker container create で作成したコンテナは、次のように停止状態のコンテナの一覧に表示されます。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 327ad0cfd004 ubuntu:20.04 &#34;/bin/bash&#34; 23 seconds ago Created mycon あとは、docker container start でこのコンテナを起動できます。 起動と同時にシェルプロセスに接続するには、-ai オプションを付けます。 $ docker container start -ai mycon root@327ad0cfd004:/# docker container attach は動作しているコンテナに接続する docker container attach コマンド（例: docker attach）は、ローカルの標準入出力をコンテナのプロセス (PID=1) にアタッチします。 この振る舞いを調べるために、まずコンテナを起動してシェルに接続しておきます。 $ docker container create -it --name mycon ubuntu:20.04 /bin/bash $ docker container start -ai mycon root@9bf22d6b0a5c:/# ここで起動した bash シェルのプロセス ID (PID) は 1 になっています。 root@9bf22d6b0a5c:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 10 pts/0 00:00:00 ps 別のローカル端末を起動して、次のように docker container attach すると、上記の PID=1 の bash プロセスの標準入出力に接続されます。 $ docker container attach mycon root@9bf22d6b0a5c:/# 2 つの端末で bash シェルを表示している状態になりますが、どちらも PID=1 の同じプロセスに接続しているため、一方で入力したコマンドの結果がもう一方にも表示されます。 どちらかで exit すると、もう一方のシェルも閉じて Docker コンテナが終了します。 一方の接続だけを切りたい場合は、Ctrl + P Ctrl + Q と入力します。 こうすれば、もう一方のシェルプロセスは残ったままになり、コンテナも終了しません。 docker container exec は動作しているコンテナでプロセスを起動する docker container exec コマンド（旧: docker exec）を使うと、動作しているコンテナ上で新しいプロセスを起動することができます。 これを使うと、1 つのコンテナ上で 2 つのシェルを起動して接続する ということができます。 停止状態のコンテナを指定するとエラーになるので、まずはコンテナを起動してシェル接続しておきます。 この bash シェルの PID は前述のように 1 です。 $ docker container create -it --name mycon ubuntu:20.04 /bin/bash $ docker container start -ai mycon root@e3d9f66349d4:/# ps PID TTY TIME CMD 1 pts/0 00:00:00 bash 10 pts/0 00:00:00 ps この状態で別の端末を起動して、docker container exec で新しい bash シェルを起動して接続します。 この bash シェルは新しいプロセスとして起動するので、別の PID が割り当てられます。 $ docker container exec -it mycon /bin/bash root@e3d9f66349d4:/# ps PID TTY TIME CMD 11 pts/1 00:00:00 bash 20 pts/1 00:00:00 ps これで、1 つのコンテナに 2 つのシェルを起動して接続できました。 一方のシェルを exit で終了しても、もう一方のシェル（およびコンテナ）は実行されたままです。 ここで docker container attach を使うと、同じプロセス (PID=1) に接続されてしまうので、docker container exec の方を使って新しいシェルのプロセスを作るのがポイントです。"},{url:"/p/ow258be/",title:"Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port)",date:"2015-03-12T00:00:00+09:00",body:"Docker コンテナ側の公開ポートがホスト側のどのポートにマッピングされているか調べる (docker container port) docker container port コマンドの使い方 docker container port（あるいは docker port）コマンドを使用すると、Docker コンテナの中で公開されているポート番号 (private port) が、ホスト側のどのポート番号にマッピングされているかを調べることができます。 $ docker container port &lt;コンテナ名&gt; [コンテナ側ポート番号] 例えば、my-nginx コンテナの中で Web サーバーが動作しているとして、それがホスト側から見てどのポート番号にマッピングされているかを調べるには以下のようにします。 $ docker container port my-nginx 80/tcp -&gt; 0.0.0.0:8000 80/tcp -&gt; :::8000 この例では、コンテナ側の 80 番ポートが、ホスト側の 8000 番ポートにマッピングされていることがわかります。 つまり、コンテナの Web サーバーには、http://localhost:8000 といったアドレスでアクセスできます。 特定の（コンテナ側の）ポート番号に関してだけ調べることもできます。 次の例では、コンテナ側の 80 番ポートに対して、ホスト側のどのポートがマッピングされているかを調べています。 $ docker container port my-nginx 80 0.0.0.0:8000 :::8000 （おまけ）nginx サーバーを立ち上げて実際に試してみる Alpine Linux をベースにした nginx サーバーのイメージ (nginx:alpine) はとても軽量（20MB くらい）なので、これを利用して、上記の docker container port コマンドを試してみます。 コンテナで nginx サーバーを起動するには次のように実行します。 ここでは、コンテナ名を my-nginx とし、ホスト側の 8000 番ポートとコンテナ側の 80 番ポートを結びつけています。 $ docker container run -d -p 8000:80 --name my-nginx nginx:alpine コンテナが起動したら、ホスト PC 側で http://localhost:8000 にアクセスすると Web ページを表示できます。 この状態で、次のようにポート番号のマッピング情報を確認できます。 $ docker container port my-nginx 80/tcp -&gt; 0.0.0.0:8000 80/tcp -&gt; :::8000 試し終わったら、my-nginx コンテナを削除しておきましょう。 $ docker container rm -f my-nginx"},{url:"/p/5j4k3iy/",title:"Docker のコンテナイメージを作成する (docker image build, docker container commit)",date:"2015-03-12T00:00:00+09:00",body:"Docker のコンテナイメージを作成する (docker image build, docker container commit) 2 つのイメージ作成方法 Docker イメージの作成方法には、大きく下記の 2 つの方法があります。 Dockerfile にイメージの作成手順を記載しておき、docker image build で作成 OS イメージをインタラクティブモードで起動し、各種設定を行った後に docker container commit で作成 再現性、ポータビリティといった観点から、Dockerfile を扱うアプローチが推奨されています。 docker image build アプローチ Dockerfile という、Docker イメージ作成のための手順書を作成しておくと、docker image build（あるいは docker build）コマンドを使って自動的にイメージを作成することができます。 下記は、Debian のイメージをベースにして、Python 3 をインストールしたイメージを作成する場合の Dockerfile の例です。 Dockerfile # Debian (Wheezy) のイメージをベースにする FROM debian:wheezy # コンテナ構築のためのコマンド実行 RUN apt-get -qq update &amp;&amp; apt-get -y install python3 この Dockerfile を元に Docker イメージを作成するには、下記のように docker image build を実行します。 コンテナイメージのビルド $ docker image build -t &lt;イメージ名&gt; &lt;Dockerfileのあるディレクトリ&gt; -t の後ろに指定するイメージ名は &lt;user&gt;/&lt;repo&gt;:&lt;tag&gt; という構成で指定します。 末尾のタグ名 (:&lt;tag&gt;) を省略すると、自動的に latest というタグが付けられます。 カレントディレクトリに Dockerfile ファイルがある場合は次のような感じでイメージをビルドします。 $ docker build -t maku77/python3:v1 . debian:wheezy のイメージファイルが既に docker pull コマンドなどでローカルにキャッシュされている場合は、そのイメージが利用されるため、イメージ構築はより早く終わります。 docker image ls（あるいは docker images）コマンドで、作成された Docker イメージを確認することができます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/python3 v1 c3d5556730a9 4 minutes ago 93.88 MB debian wheezy d5570ef1464a 4 days ago 84.98 MB ... 作成された Docker イメージ (maku77/python3:v1) からコンテナを起動し、python3 コマンドを実行してみます。 $ docker container run -it maku77/python3:v1 python3 Python 3.2.3 (default, Feb 20 2013, 14:44:27) [GCC 4.7.2] on linux2 Type &#34;help&#34;, &#34;copyright&#34;, &#34;credits&#34; or &#34;license&#34; for more information. &gt;&gt;&gt; （おまけ）GitHub 上の Dockerfile からイメージを作成する docker image build コマンドで Dockerfile のあるディレクトリを指定するときに、GitHub のリポジトリを指定することができます。 $ docker mage build -t maku77/sample:v1 git@github.com:maku77/sample docker container commit アプローチ docker container commit（あるいは docker commit）コマンドによるアプローチでは、Docker のコンテナイメージをインタラクティブに作成していくことができます。 コンテナ上でソフトウェアのインストールなどを行い、最後に docker container commit コマンドを実行することにより、コンテナイメージを作成します。 まずは、ベースとなるイメージを指定して Docker コンテナを起動します。 $ docker container run -it ubuntu:14.04 /bin/bash コンテナ上の bash プロンプトが表示されたら、その中で apt-get やファイルの作成などを行い、コンテナイメージの構築作業を進めていきます。 下記の例では、Hello と表示するだけのシェルスクリプト (/greet) を作成しています。 root@c338a2f4c60e:/# cat &gt; greet #!/bin/bash echo Hello （ここで Ctrl-D で終了） root@c338a2f4c60e:/# chmod +x greet root@c338a2f4c60e:/# exit 起動元のシェルに戻ってきたら、docker ps コマンドで、最新のコンテナ ID（あるいは名前）を確認します。 $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c338a2f4c60e ubuntu:14.04 /bin/bash 3 minutes ago Exited (0) About a minute ago loving_torvalds これで、先ほどインタラクティブに構成した Docker コンテナの ID が c338a2、名前が loving_torvalds だということが分かるので、docker container commit コマンドを実行して、コンテナからイメージを生成します。 docker container commit コマンドのフォーマットは下記のようになっています。 docker container commit -a &lt;作者&gt; -c &lt;コメント&gt; &lt;コンテナ&gt; &lt;リポジトリ名&gt;:&lt;タグ名&gt; &lt;コンテナ&gt; には、docker ps コマンドで確認したコンテナ ID か名前を指定します。 リポジトリ名は、Docker Hub の流儀に合わせて、&lt;アカウント名&gt;/&lt;イメージ名&gt; という形で指定します。 例えば、Docker Hub アカウントが maku77 で、sample という名前のイメージを作成する場合は次のようにします。 $ docker commit -a &#39;Maku &lt;maku77@example.com&gt;&#39; -m &#39;First commit&#39; c338a2 maku77/sample:v1 8a6608d7d353d966f5cdc044b48b89158943c2dc9fd08b7a4832b43a21b5df41 コンテナイメージの作成に成功すると、上記のように作成されたイメージの ID が表示されます。 docker image ls コマンドで、実際に新しくイメージが作成されたことを確認できます。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE maku77/sample v1 8a6608d7d353 7 minutes ago 188.3 MB ubuntu 14.04 2103b00b3fdf 43 hours ago 188.3 MB ... この Docker イメージを使って、先ほど作成した /greet コマンドを実行してみます。 $ docker container run maku77/sample:v1 /greet Hello"},{url:"/p/6ehmpsv/",title:"すべての Docker コンテナを停止／削除する (docker container stop/rm)",date:"2015-03-12T00:00:00+09:00",body:"すべての Docker コンテナを停止／削除する (docker container stop/rm) 全コンテナを停止する すべての Docker コンテナをまとめて停止するには次のようにします。 これは、docker container ps -a -q コマンドですべてのコンテナ ID を取得できることを利用しているため、Linux や macOS 上でしか実行できません（Windows のコマンドプロンプトでは実行できません）。 すべての Docker コンテナを停止する $ docker container stop $(docker container ps -a -q) 全コンテナを削除する 同様に、次のようにすればすべての Docker コンテナを削除することができます。 すべての Docker コンテナを削除する $ docker container rm $(docker container ps -a -q) 動作中のコンテナも含めてすべて削除したいときは、docker contaier rm に -f オプションを付けて実行する必要があります。 ただし、これはとても危険なので注意して実行してください。"},{url:"/p/47hs3ck/",title:"Docker コンテナの詳細情報を表示する (docker container inspect)",date:"2015-03-11T00:00:00+09:00",body:"Docker コンテナの詳細情報を表示する (docker container inspect) docker container inspect（あるいは docker inspect）コマンドを使用すると、Docker コンテナの詳細情報を表示することができます。 その Docker コンテナがどのイメージをもとに作成されているのか、環境変数の設定はどうなっているのかなどを JSON 形式で出力してくれます。 $ docker container inspect my-container [ { &#34;Id&#34;: &#34;ac2dc4e539f1bc7c273beb71d03536e83393d7f673d7ba67994569c75173b2a2&#34;, &#34;Created&#34;: &#34;2022-02-25T05:28:16.4553051Z&#34;, &#34;Path&#34;: &#34;/bin/bash&#34;, &#34;Args&#34;: [], &#34;State&#34;: { &#34;Status&#34;: &#34;exited&#34;, &#34;Running&#34;: false, &#34;Paused&#34;: false, &#34;Restarting&#34;: false, &#34;OOMKilled&#34;: false, &#34;Dead&#34;: false, &#34;Pid&#34;: 0, &#34;ExitCode&#34;: 0, &#34;Error&#34;: &#34;&#34;, &#34;StartedAt&#34;: &#34;2022-02-25T05:29:17.5120196Z&#34;, &#34;FinishedAt&#34;: &#34;2022-02-25T05:29:22.1845301Z&#34; }, &#34;Image&#34;: &#34;sha256:54c9d81cbb440897908abdcaa98674db83444636c300170cfd211e40a66f704f&#34;, ... } ]"},{url:"/p/dmpsvz3/",title:"Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs)",date:"2015-03-11T00:00:00+09:00",body:"Docker コンテナをデーモンとして動作させる (docker container run -d, docker container logs) コンテナのバックグラウンド起動 (docker container run -d) Docker コンテナ内でプログラムが動作している状態をキープするには、何らかの終了しないプログラムを動かす必要があります（典型的には何らかのサーバープログラムです）。 ここでは、5 秒おきに HELLO と表示するプログラムを動かしてみます。 次のような簡単な bash プログラムです。 /bin/bash -c &#39;while true; do echo HELLO; sleep 5; done&#39; 上記のようなプログラムを、docker run コマンドで単純に Docker コンテナ内で動かすと、起動元の端末（の標準出力）に HELLO と表示され続けてしまいます。 そうではなくて、Docker コンテナ内に閉じて出力するには、docker run コマンドに -d (--detach) オプションを付けて実行します。 $ docker container run --rm -d --name mycon ubuntu:22.04 /bin/bash -c &#39;while true; do echo HELLO; sleep 5; done&#39; 57bf2e3edddf8dcc786ee42e9b2b5a1f50786d80bd45525afa21debcf108613b 引数の意味: --rm … コンテナ停止時にコンテナを自動で削除します。 -d (--detach) … コンテナをバックグラウンドで動作させます。 --name mycon … コンテナに mycon という名前を付けます。 ubuntu:22.04 … イメージとして Ubuntu 22.04 を使用します。 すると、docker container run コマンドを実行した側には HELLO と表示されず、プログラムを実行中の コンテナ ID のみが表示されます。 実行中の Docker コンテナの一覧は、以下のように docker container ps コマンドで確認できます。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 57bf2e3edddf ubuntu:22.04 &#34;/bin/bash -c &#39;while…&#34; 5 seconds ago Up 5 seconds mycon このリストでは、動作中のコンテナのコンテナ ID や、その ID の代わりに使用できる名前（上記では mycon) などを確認できます。 コンテナ内のデーモンの出力内容を確認する (docker container logs) Docker コンテナ内の標準出力に対して出力されている内容を調べるには、docker container logs コマンドを使用します。 $ docker container logs mycon HELLO HELLO HELLO ...（省略）... デフォルトでは、その時点で出力済みの標準出力の内容をすべて出力して docker container logs コマンドは終了します。 Linux の tail -f コマンドのように、標準出力への出力を監視して継続的に出力したい場合は -f オプションを付けます。 $ docker logs -f mycon HELLO HELLO HELLO ...（出力を待機）... 動作中の Docker コンテナを外から停止するには、docker container stop コマンドを使用します。 $ docker container stop mycon mycon $ docker container ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ...（空になっている）... bash に仮想端末を割り当てて終了しないようにする方法 docker container run でコンテナを起動するときに、-t (--tty) オプションで仮想端末 (pseudo-TTY) を割り当てて bash を起動することでも、コンテナを起動したままにできます（Ubuntu イメージはデフォルトで bash を起動するので、末尾の bash は省略できます）。 $ docker container run --rm -dt --name mycon ubuntu:22.04 bash 52ac8c76e47ed495e2698676530c662531782f500504b03daa87da6c634c9fba この状態はちょっと分かりにくいですが、内部的に仮想端末が割り当てられ、そこに繋がった bash がバックグラウンドで動き続けているというイメージです。 -d (--detach) オプションを付けて実行しているので、bash のプロンプトは見えなくなっています。 次のようにすると、確かにコンテナ上で bash が動作し続けていることを確認できます。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 52ac8c76e47e ubuntu:22.04 &#34;bash&#34; 3 minutes ago Up 3 minutes mycon このコンテナ上で新しく bash を起動して何か操作したいときは次のようにします。 $ docker container exec -it mycon bash root@52ac8c76e47e:/# docker container exec コマンドの詳細は下記記事を参照してください。 Docker コンテナで起動したシェルに接続する (docker container run/start/exec/attach)"},{url:"/p/s3m4jyg/",title:"Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top)",date:"2015-03-11T00:00:00+09:00",body:"Docker コンテナ内で動作しているプロセスの一覧を表示する (docker container top) docker container top &lt;コンテナ名&gt; コマンドを実行すると、指定した Docker コンテナ内で現在動作しているプロセスを確認することができます（互換性維持のため、docker top コマンドも残されています）。 $ docker container top my-container PID USER COMMAND 854 root python app.py 855 root sleep 1 末尾に ps コマンドのオプションを指定して、出力内容をカスタマイズできます。 次の例では、-o pid,command と指定することで、出力するフィールドを PID と COMMAND のみにしています。 $ docker container top my-container -o pid,command PID COMMAND 2007 /usr/bin/qemu-x86_64 /usr/sbin/mysqld mysqld"},{url:"/p/w69cfim/",title:"Docker のプロキシ設定",date:"2015-03-10T00:00:00+09:00",body:"Docker のプロキシ設定 Docker ホスト側のプロキシ設定 docker pull などで、Docker Hub リポジトリからイメージを取得するときにプロキシ接続が必要な場合は、Docker コンテナーではなく、Docker ホスト側のプロキシ設定を行う必要があります。 実際には、docker pull コマンドは、docker デーモンに対して命令を送っているだけなので、docker デーモンの方がプロキシ設定を認識する必要があります。 docker デーモンのプロキシ設定は、/etc/default/docker ファイルで行います。 /etc/default/docker（あるいは docker.io） export http_proxy=&#34;http://proxy.example.com:3128/&#34; 設定変更後は、docker デーモンを再起動すれば OK です。 $ sudo service docker.io restart これで、無事にプロキシ経由で docker pull できるようになります。 Docker コンテナ内で使用するプロキシ設定 Docker コンテナの中で、apt-get や curl などを使ったインターネットアクセスを行う場合は、Docker コンテナ側でプロキシの設定を行う必要があります。 docker run で Docker コンテナを起動するときに、-e オプションで http_proxy 環境変数 を渡して起動することができます。 $ sudo docker run -e http_proxy=http://proxy.example.com:8888/ -it debian:wheezy もちろん、Docker コンテナを起動したあとで、コンテナ上のシェルから環境変数を設定することもできます。 $ sudo docker run -it debian:wheezy root@7cb147891556:/# export http_proxy=http://proxy.example.com:8888/ root@7cb147891556:/# Docker イメージとして、必ず特定のプロキシを使うことが決まっているのであれば、Docker イメージを作成する際の Dockerfile にプロキシ設定を埋め込んでしまうこともできます。 このプロキシ設定は、Docker イメージを構築する際の、RUN コマンド (apt-get) にも効いてきます。 Dockerfile FROM debian:wheezy ENV http_proxy http://proxy.example.com:8888/ ENV https_proxy http://proxy.example.com:8888/ RUN apt-get update &amp;&amp; apt-get install python3"},{url:"/p/an7o5m3/",title:"一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録）",date:"2015-03-10T00:00:00+09:00",body:"一般ユーザから docker コマンドを実行できるようにする（docker グループへの登録） docker コマンドは、内部で socket を使って通信を行っており、一般ユーザからコマンドを実行すると、permission denied で怒られることがあります。 $ docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a 2015/03/10 22:50:19 Get http:///var/run/docker.sock/v1.12/version: dial unix //var/run/docker.sock: permission denied 上記の出力を見ると、var/run/docker.sock ファイルへのアクセス権限がないことが分かります。 このような場合は、次のいずれかの方法で docker コマンドを実行できるようになります。 sudo を付けて実行する ユーザーを docker グループに追加する sudo を付けて実行する方法 sudo をつけてスーパーユーザー権限で docker コマンドを実行する方法です。 $ sudo docker version Client version: 1.0.1 Client API version: 1.12 Go version (client): go1.2.1 Git commit (client): 990021a Server version: 1.0.1 Server API version: 1.12 Go version (server): go1.2.1 Git commit (server): 990021a ユーザーを docker グループに追加する方法 Docker が使用している socket ファイル (/var/run/docker.sock) は、docker グループ からのアクセスを許可しています。 $ ls -l /var/run/docker.sock srw-rw---- 1 root docker 0 3月 10 00:02 /var/run/docker.sock 必要なユーザを、docker グループに追加することで、自由に docker コマンドを実行できるようになります。 $ sudo gpasswd -a maku docker # ユーザ maku を docker グループに追加 $ sudo gpasswd -d maku docker # ユーザ maku を docker グループから外す 上記の設定を反映させるには、一度 Ubuntu などからログアウトする必要があります。"},{url:"/p/96o6n4j/",title:"Docker をインストールする (Docker Desktop / Docker Engine)",date:"2015-03-09T00:00:00+09:00",body:"Docker をインストールする (Docker Desktop / Docker Engine) Docker 実行環境のインストール Docker の実行環境（docker コマンド）をインストールするには、下記の公式マニュアルの手順に従ってください。 基本的に、Windows や macOS では Docker Desktop、Linux では Docker Engine をインストールすることになります。 https://docs.docker.com/get-docker/ 例: Windows の場合 (Docker Desktop) 例: macOS の場合 (Docker Desktop) 例: Ubuntu の場合 (Docker Engine) 例: Debian の場合 (Docker Engine) 例えば、Linux 環境では次のような感じで Docker Engine をインストールできます（詳細は上記の公式ページを参照してください）。 # インストール $ curl -sSL get.docker.com -o install.sh $ sh install.sh # Docker サービスを systemd で自動起動する設定 $ systemctl enable docker # Docker サービスを直ちに起動 $ systemctl start docker インストール手順を実行後、docker コマンドが使えるようになっていれば準備 OK です。 $ docker system info Docker Desktop について Docker コンテナを動作させるためのコアになる Docker Engine は、Linux OS 上で動作させることを前提としているため、そのままでは Windows や macOS 上で動かすことができません。 Windows や macOS で Docker を動かすには、まず、Linux VM（仮想環境）を立ち上げ、その上で Docker Engine を動作させる、といった複雑な手順が必要です。 とはいえ、それでは手間がかかるので、Windows や macOS には Docker Desktop というソフトウェアが提供されており、これをインストールすると、Linux VM + Docker の実行環境を一度に整えられます（Windows では内部的に WSL2（Windows 標準の仮想環境）が利用されます）。 さらに、Docker Desktop は次のような GUI フロントエンドを備えており、ここから Docker イメージの管理、コンテナの管理、ボリュームの管理などを行えるため非常に便利です。 図: Docker Desktop の画面 Docker Desktop をインストールすると、Docker Engine だけでなく、下記がまとめて使えるようになります。 Docker Engine Docker CLI client Docker Build/BuildKit Docker Compose Docker Content Trust Kubernetes Docker Scan Credential Helper Docker Desktop は Linux VM として、BusyBox ベースの軽量な Alpine Linux を使用しているため、高速に起動することができます。 下手に自分で Linux VM 環境を用意するより快適に使用できます。 2022年2月からは、Docker Desktop を巨大企業（250人以上 or 1,000万ドル以上の収益）で使用する場合は有償 になるため注意してください。 個人利用では引き続き無料（Personal プラン）で使用できます。"},{url:"/p/66q7m2j/",title:"Windows のバッチファイルの実行を途中で終了する (exit /b)",date:"2015-02-09T00:00:00+09:00",body:"Windows のバッチファイルの実行を途中で終了する (exit /b) バッチファイルの実行を途中で終了したい場合は、次のコマンドを実行します。 EXIT /B バッチファイルの中で単純に exit コマンドを実行すると、バッチファイルを実行していたコマンドプロンプト（コマンドシェル）ごと終了してしまいますが、/B オプション付きで実行すると、コマンドプロンプト自体は終了せずに、バッチファイルの実行だけを終了 してくれます。 sample.cmd @echo off echo AAA exit /b echo BBB 例えば、上記の sample.cmd を実行すると、echo BBB は実行せずに終了します。 実行結果 C:\\&gt; sample AAA"},{url:"/p/6idyjje/",title:"Vim で空行（改行だけの行）を削除する",date:"2015-01-20T00:00:00+09:00",body:`Vim で空行（改行だけの行）を削除する 編集中のファイル全体の空行を削除する ノーマルモードで下記の ex コマンドを実行すれば、現在編集中のファイル内の、改行のみの行をすべて削除することができます。 :%s/^\\n// 指定した範囲の空行を削除する Shift-V でビジュアルモードに入る j および k キーで行の範囲を指定 :s/^\\n// と入力して Enter`},{url:"/p/xhyhzfv/",title:"Python で JSON 形式のテキストファイルを読み書きする (json.load, json.dump)",date:"2014-11-28T00:00:00+09:00",body:`Python で JSON 形式のテキストファイルを読み書きする (json.load, json.dump) JSON ファイルを読み込む (json.load) Python に付属している json ライブラリが提供する json.load 関数を使用すると、JSON 形式のテキストファイルを読み込んで、Python のオブジェクトを生成することができます。 json.load 関数のパラメーターには、ファイル名ではなく、ファイルオブジェクト（read 関数を持つオブジェクト）を渡すことに注意してください。 入力ファイル (input.json) { &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;ccc&#34;: 300 } sample.py import json def load_json(filename): &#34;&#34;&#34;JSON ファイルを読み込んで Python オブジェクトとして返します。&#34;&#34;&#34; with open(filename, encoding=&#39;utf-8&#39;) as f: return json.load(f) # テスト obj = load_json(&#34;input.json&#34;) print(obj[&#39;aaa&#39;]) #=&gt; 100 print(obj[&#39;bbb&#39;]) #=&gt; 200 print(obj[&#39;ccc&#39;]) #=&gt; 300 JSON ファイル内の各要素は、次のような対応付けで Python オブジェクトに変換されます。 JSON の型 Python の型 object dict array list string str number int / float true / false True / False null None JSON ファイルではなく、JSON 形式の文字列を読み込みたいときは、json.load の代わりに json.loads 関数を使用します。 参考: JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps) JSON ファイルに書き出す (json.dump) 基本 Python のオブジェクトを JSON 形式のテキストファイルに書き出すには、json.dump 関数 を使用します。 こちらも、パラメーターとしてはファイル名ではなく、ファイルオブジェクト（write 関数を持つオブジェクト）を渡すことに注意してください。 sample.py import json def save_json(filename, obj): &#34;&#34;&#34;Python オブジェクトの内容を JSON ファイルに保存します。&#34;&#34;&#34; with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) as fp: json.dump(obj, fp) # テスト obj = { &#39;ccc&#39;: 300, &#39;aaa&#39;: 100, &#39;bbb&#39;: 200, &#39;data&#39;: [1, 2, 3] } save_json(&#39;output.json&#39;, obj) 出力結果 (output.json) {&#34;ccc&#34;: 300, &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;data&#34;: [1, 2, 3]} 出力形式をカスタマイズする (indent, sort_keys) デフォルトでは、上記のように改行なしのコンパクトな出力になります。 改行やインデントを入れて出力したい場合は、json.dump 関数の引数で、indent=2 のようにインデントサイズを指定します。 また、Python 3.7 以降は辞書オブジェクト (dict) のキーは、挿入された順に出力されるようになっています（デフォルトで collections.OrderedDict 相当の動きになりました）。 アルファベット順に出力したい場合は、sort_keys=True を指定します。 sample.py（修正箇所のみ抜粋） json.dump(obj, fp, indent=2, sort_keys=True) 出力結果 (output.json) { &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;ccc&#34;: 300, &#34;data&#34;: [ 1, 2, 3 ] } 辞書オブジェクトのキーが追加順に出力されるのは地味に便利で、例えば、id プロパティを先頭に出力したい場合は、単純にプログラム内で id を最初に追加するだけで済みます。 book1 = {&#39;id&#39;: 1, &#39;author&#39;: &#39;Author-1&#39;, &#39;title&#39;: &#39;Title-1&#39;} book2 = {&#39;id&#39;: 2, &#39;author&#39;: &#39;Author-2&#39;, &#39;title&#39;: &#39;Title-2&#39;} book3 = {&#39;id&#39;: 3, &#39;author&#39;: &#39;Author-3&#39;, &#39;title&#39;: &#39;Title-3&#39;} books = [ book1, book2, book3 ] save_json(&#39;books.json&#39;, books) 要素の順序をもっと細かく制御する方法は、下記の記事を参考にしてください。 dictionary の内部的な要素順序を変更する 日本語をそのまま出力する (ensure_ascii) json.dump 関数は、デフォルトで日本語を Unicode エスケープして出力しようとします（例えば、あ は \\u3042 になります）。 この振る舞いを抑制して、日本語のまま出力するには、引数で ensure_ascii=False を指定します。 import json def save_json(filename, obj): with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=&#39;\\n&#39;) as fp: json.dump(obj, fp, ensure_ascii=False) obj = {&#39;a&#39;: &#39;あいう&#39;} save_json(&#39;output.json&#39;, obj) JSON 文字列に変換する JSON ファイルに出力するのではなく、JSON 形式の文字列を取得したいときは、json.dump の代わりに json.dumps 関数を使用します。 参考: JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps)`},{url:"/p/cp9q7n5/",title:"Python で XML をパースする (ElementTree)",date:"2014-11-28T00:00:00+09:00",body:"Python で XML をパースする (ElementTree) ElementTree XML API Python 2.5 以降には、XML を扱うための標準 API として、ElementTree XML API が用意されています。 The ElementTree XML API ElementTree では、パースした XML を DOM オブジェクトとしてメモリ上に保持するため、XML データを読み込んだあとは、各 XML 要素へ柔軟にアクセスすることができます。 XML ファイルをパースする ElementTree モジュールが提供している ElementTree.parse 関数を使って、XML ファイルを読み込むことができます。 ElementTree.parse 関数は、読み込んだ XML をパースして ElementTree オブジェクトとして返します。 ElementTree オブジェクトは、XML ツリー全体を表現するオブジェクトです。 XML ツリーの先頭要素を表す Element オブジェクトは、ElementTree#getroot() メソッドで取得することができます。 input.xml（テスト用の XML ファイル） &lt;tree name=&#34;hello&#34;&gt; &lt;trunk&gt;...&lt;/trunk&gt; &lt;/tree&gt; main.py from xml.etree import ElementTree # XML ファイルから ElementTree オブジェクトを生成 tree = ElementTree.parse(&#39;input.xml&#39;) # 先頭要素を表す Element オブジェクトを取得 elem = tree.getroot() print(type(elem)) # =&gt; &lt;class &#39;xml.etree.ElementTree.Element&#39;&gt; print(elem) # =&gt; &lt;Element &#39;tree&#39; at 0x105499c60&gt; print(elem.tag) # =&gt; tree print(elem.attrib) # =&gt; {&#39;name&#39;: &#39;hello&#39;} XML 形式の文字列をパースする XML ファイルではなく、XML 形式のテキストをパースしたいときは、ElementTree.fromstring(str) 関数を使用します。 戻り値は、先頭要素を表す Element オブジェクトになります。 main.py from xml.etree import ElementTree # XML 文字列をパースして Element オブジェクトを生成 elem = ElementTree.fromstring(&#39;&lt;tree name=&#34;hello&#34;&gt;&lt;trunk&gt;...&lt;/trunk&gt;&lt;/tree&gt;&#39;) print(elem.tag) #=&gt; tree print(elem.attrib) #=&gt; {&#39;name&#39;: &#39;hello&#39;} Element オブジェクトから要素の情報を取得する Element オブジェクトは 1 つの XML 要素を表現しており、下記のようなプロパティやメソッドが用意されています。 要素に含まれるテキストノードや属性を表すためのオブジェクトは存在せず、Element オブジェクトに付随する情報として管理されていることに注意してください。 属性 説明 Element#tag タグ名を取得 Element#text その要素の先頭にあるテキストノードを取得（&lt;b&gt;これ&lt;/b&gt;） Element#tail その要素の直後にあるテキストノードを取得（&lt;b&gt;...&lt;/b&gt;これ） Element#attrib dictionary 形式で属性をすべて取得 Element#get(key, default=None) 指定したキーの属性を取得 Element#items() (name, value) のペアで属性をすべて取得 Element#keys() 属性のキーをすべて取得 下記の例では、各要素のタグ名や、属性、テキストノードを再帰的に出力しています。 子要素を取得するには、Element 要素自身を for-in ループでイテレートします。 books.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;books&gt; &lt;book id=&#34;001&#34;&gt; &lt;title&gt;Title 1&lt;/title&gt; &lt;author&gt;Author 1&lt;/author&gt; &lt;/book&gt; &lt;book id=&#34;002&#34;&gt; &lt;title&gt;Title 2&lt;/title&gt; &lt;author&gt;Author 2&lt;/author&gt; &lt;/book&gt; &lt;/books&gt; parse_books.py from xml.etree import ElementTree def dump_node(node, indent=0): print(&#34;{}{} {} {}&#34;.format(&#39; &#39; * indent, node.tag, node.attrib, node.text.strip())) for child in node: dump_node(child, indent + 1) if __name__ == &#39;__main__&#39;: tree = ElementTree.parse(&#39;books.xml&#39;) dump_node(tree.getroot()) 実行結果 $ python parse_books.py books {} book {&#39;id&#39;: &#39;001&#39;} title {} Title 1 author {} Author 1 book {&#39;id&#39;: &#39;002&#39;} title {} Title 2 author {} Author 2"},{url:"/p/pt6fpx8/",title:"Python で XML を扱う方法いろいろ",date:"2014-11-28T00:00:00+09:00",body:"Python で XML を扱う方法いろいろ Python には下記のように、標準の XML パーサが複数搭載されています。 xml.etree.ElementTree &hellip; The ElementTree XML API xml.dom &hellip; The Document Object Model API xml.dom.minidom &hellip; Minimal DOM implementation xml.sax &hellip; Support for SAX2 parsers 通常はシンプルな xml.etree.ElementTree を使い、DOM 標準の API を使いたい場合は xml.dom を使用すればよいでしょう。 巨大な XML ファイルを効率的に読み込みたい場合は、SAX API を提供する xml.sax を選択できます。 参考: 20. Structured Markup Processing Tools Beautiful Soup などの 3rd パーティライブラリでも XML を扱うことはできますが、Beautiful Soup はどちらかというと HTML のパースに向いています。 XML のパースは、ほとんどの場合 Python 標準の ElementTree で十分です。"},{url:"/p/fufwevc/",title:"Python で XPath を使って XML 要素を参照する (ElementTree)",date:"2014-11-28T00:00:00+09:00",body:"Python で XPath を使って XML 要素を参照する (ElementTree) Python 2.5 以降に搭載されている ElementTree XML API は、XPath による要素アクセスをサポートしています。 The Element Tree XML API - XPath support 次の例では、country という名前の要素をすべて取得し、再帰的に子要素を表示しています。 countries.xml（入力ファイル） &lt;?xml version=&#34;1.0&#34;?&gt; &lt;data&gt; &lt;country name=&#34;Liechtenstein&#34;&gt; &lt;rank&gt;1&lt;/rank&gt; &lt;year&gt;2008&lt;/year&gt; &lt;gdppc&gt;141100&lt;/gdppc&gt; &lt;neighbor name=&#34;Austria&#34; direction=&#34;E&#34;/&gt; &lt;neighbor name=&#34;Switzerland&#34; direction=&#34;W&#34;/&gt; &lt;/country&gt; &lt;country name=&#34;Singapore&#34;&gt; &lt;rank&gt;4&lt;/rank&gt; &lt;year&gt;2011&lt;/year&gt; &lt;gdppc&gt;59900&lt;/gdppc&gt; &lt;neighbor name=&#34;Malaysia&#34; direction=&#34;N&#34;/&gt; &lt;/country&gt; &lt;country name=&#34;Panama&#34;&gt; &lt;rank&gt;68&lt;/rank&gt; &lt;year&gt;2011&lt;/year&gt; &lt;gdppc&gt;13600&lt;/gdppc&gt; &lt;neighbor name=&#34;Costa Rica&#34; direction=&#34;W&#34;/&gt; &lt;neighbor name=&#34;Colombia&#34; direction=&#34;E&#34;/&gt; &lt;/country&gt; &lt;/data&gt; sample.py from xml.etree import ElementTree def dump_node(node, indent=0): print(&#39; &#39; * indent, node.tag, node.attrib) for child in node.getchildren(): dump_node(child, indent + 1) if __name__ == &#39;__main__&#39;: tree = ElementTree.parse(&#39;countries.xml&#39;) root = tree.getroot() for node in root.findall(&#39;./country&#39;): print(&#39;-&#39; * 60) dump_node(node) 実行結果 $ python sample.py ------------------------------------------------------------ country {&#39;name&#39;: &#39;Liechtenstein&#39;} rank {} year {} gdppc {} neighbor {&#39;name&#39;: &#39;Austria&#39;, &#39;direction&#39;: &#39;E&#39;} neighbor {&#39;name&#39;: &#39;Switzerland&#39;, &#39;direction&#39;: &#39;W&#39;} ------------------------------------------------------------ country {&#39;name&#39;: &#39;Singapore&#39;} rank {} year {} gdppc {} neighbor {&#39;name&#39;: &#39;Malaysia&#39;, &#39;direction&#39;: &#39;N&#39;} ------------------------------------------------------------ country {&#39;name&#39;: &#39;Panama&#39;} rank {} year {} gdppc {} neighbor {&#39;name&#39;: &#39;Costa Rica&#39;, &#39;direction&#39;: &#39;W&#39;} neighbor {&#39;name&#39;: &#39;Colombia&#39;, &#39;direction&#39;: &#39;E&#39;} パスの指定を ./country から、. に変更すると、ルート要素からすべての要素を出力できます。"},{url:"/p/o2e43ct/",title:"Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen)",date:"2014-11-28T00:00:00+09:00",body:"Python の urllib による HTTP リクエスト (1) GET/POST リクエスト (urllib.request.urlopen) ここでは、Python の組み込みモジュールである urllib.request を使った HTTP アクセスの例を示します。 urlopen による GET/POST リクエストの基本 urllib.request.urlopen 関数は、http.client.HTTPResponse オブジェクトを返します。 HTTPResponse オブジェクトの read メソッドを呼ぶことで、HTTP レスポンスを取得することができます。 https://example.com のコンテンツ (HTML) を取得する from urllib.request import urlopen with urlopen(&#39;https://example.com/&#39;) as res: text = res.read().decode(&#39;utf-8&#39;) print(text) read メソッドが返すデータはバイナリデータ (bytes) なので、テキストとして扱う場合は、エンコーディング形式（utf-8 など）を指定してデコードする必要があります。 urlopen 関数で取得した HTTPResponse オブジェクトは、リソース解放のために明示的に close() することが推奨されているのですが、上記のように Python 3 の with 文を使用すると、close() 処理を自動化できます。 urlopen の引数に、URL 文字列ではなく、urllib.request.Request オブジェクトを渡すこともできます。 Request オブジェクトを使うと、HTTP ヘッダー情報やプロキシ、HTTP メソッド（GET や POST）の指定などを行えます。 HTTP ヘッダーやプロキシを指定したリクエスト import urllib.request URL = &#39;http://example.com/&#39; req = urllib.request.Request(URL, method=&#39;POST&#39;) req.add_header(&#39;Authorization&#39;, &#39;token %s&#39; % &#39;DUMMY_KEY&#39;) req.set_proxy(&#39;proxy.example.com:8080&#39;, &#39;http&#39;) with urllib.request.urlopen(req) as res: text = res.read().decode(&#39;utf-8&#39;) print(text) 参考: urllib による HTTP リクエスト (2) プロキシ経由でアクセスする 参考: urllib による HTTP 通信 (5) ヘッダを付けてリクエストする データ付きの GET/POST リクエスト GET リクエストにクエリ文字列を付加する https://example.com/?name=まく&amp;age=14 のように、URL 末尾のクエリ文字列の形でデータを送るときは、単純に URL をそのように加工します。 ただし、日本語などの値は URL エンコードされている必要があるため、先に urllib.parse.urlencode を使ってデータをエンコードしてから付加します。 import urllib.parse data = { &#39;name&#39;: &#39;まく&#39;, &#39;age&#39;: 14 } url = &#39;https://example.com/?%s&#39; % urllib.parse.urlencode(data) with urllib.request.urlopen(url) as res: text = res.read().decode(&#39;utf-8&#39;) print(text) POST リクエストで JSON データを送る POST リクエストの Body でデータを送るには、urllib.request.Request のコンストラクタの data パラメータに、送りたいデータをセットします（オブジェクト生成後に data プロパティでセットすることもできます）。 data パラメータがセットされると、method パラメータは自動的に POST が指定されたものとして動作します。 次の例では、POST メソッドで JSON データを送信しています。 import json import urllib.parse import urllib.request url = &#39;http://example.com/&#39; data = { &#39;name&#39;: &#39;まく&#39;, &#39;age&#39;: 14 } headers = { &#39;Content-Type&#39;: &#39;application/json&#39; } req = urllib.request.Request( url=url, data=json.dumps(data).encode(&#39;utf-8&#39;), headers=headers) with urllib.request.urlopen(req) as res: text = res.read().decode(&#39;utf-8&#39;) print(text) urlopen のエラーハンドル urlopen 関数は次のようなエラーをスローすることがあります。 urllib.error.URLError &hellip; 指定した URL で Web サーバーと通信できなかった場合にスローされます。例えば、ドメイン名が間違っていたり、プロキシサーバーのアドレスが間違っていると発生します。 urllib.error.HTTPError &hellip; 404 Not Found や、500 Internal Server Error など、Web サーバーから HTTP エラーが返された場合にスローされます。 HTTPError は URLError のサブクラスなので、先にハンドルするようにしてください。 import sys import urllib.request # ... try: with urllib.request.urlopen(req) as res: text = res.read().decode(&#39;utf-8&#39;) print(text) except urllib.error.HTTPError as err: print(&#39;Could not access: %s&#39; % req.full_url, file=sys.stderr) print(err, file=sys.stderr) # HTTP Error 404: Not Found print(err.code, file=sys.stderr) # 404 print(err.reason, file=sys.stderr) # Not Found sys.exit(1) except urllib.error.URLError as err: print(&#39;Could not access: %s&#39; % req.full_url, file=sys.stderr) print(err.reason, file=sys.stderr) sys.exit(1) 例えば、上記のコードで 404 Not Found の HTTPError が発生した場合は次のように出力されます。 最初の 2 行くらいを出力しておけばエラー表示としては十分かと思います。 Could not access: http://example.com/DUMMY HTTP Error 404: Not Found 404 Not Found もう一方のエラーである URLError は、ドメイン名などの間違いで、サーバーと通信できなかった場合に発生します（HTTPError の親クラスなので、正確には HTTPError 発生時にも発生しています）。 Could not access: http://MY-FAKE-DOMAIN.com/ [Errno 8] nodename nor servname provided, or not known HTTPError#code などで HTTP ステータスコードを個別に取得する必要がないのであれば、親クラスの URLError だけでまとめてエラーハンドルしてしまっても OK です。 try: with urllib.request.urlopen(req) as res: text = res.read().decode(&#39;utf-8&#39;) print(text) except urllib.error.URLError as err: print(&#39;Could not access: %s&#39; % req.full_url, file=sys.stderr) print(err, file=sys.stderr) sys.exit(1) Could not access: http://example.com/DUMMY HTTP Error 404: Not Found"},{url:"/p/ogq5hdy/",title:"Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする",date:"2014-11-28T00:00:00+09:00",body:"Python の urllib による HTTP リクエスト (2) プロキシ経由でアクセスする urllib.request を使用した HTTP アクセスは、デフォルトでシステムに設定されたプロキシ設定（http_proxy、https_proxy、ftp_proxy 環境変数など）でアクセスが行われます。 これらのプロキシ設定をそのまま使用してもよいし、Python のコード内で明示的にプロキシを設定することもできます。 現在のプロキシ設定を確認する (getproxies) 現在、システムにどのようなプロキシ設定が反映されているかを調べるには、urllib.request.getproxies 関数を使用します。 import urllib.request print(urllib.request.getproxies()) 実行結果 {&#39;http&#39;: &#39;http://proxy.example.com:8080&#39;, &#39;https&#39;: &#39;https://proxy.example.com:8080&#39;, &#39;ftp&#39;: &#39;ftp://proxy.example.com:8080&#39;} リクエストごとにプロキシを設定する (Request) HTTP リクエストごとに使用するプロキシを明示的に指定したい場合は、Request オブジェクトを作成し、set_proxy メソッドでプロキシを指定します。 あとは、その Request オブジェクトを urllib.request.urlopen() に渡して HTTP リクエストを送信します。 リクエスト単位でのプロキシ設定 import urllib.request req = urllib.request.Request(&#39;https://example.com/&#39;) req.set_proxy(&#39;proxy.example.com:8080&#39;, &#39;http&#39;) req.set_proxy(&#39;proxy.example.com:8080&#39;, &#39;https&#39;) with urllib.request.urlopen(req) as res: html = res.read().decode(&#39;utf-8&#39;) print(html) Request#set_proxy() でプロキシサーバーを指定するときは、http:// や https:// といったスキーム名は省略することに注意してください。 スキーム名を記述してしまうと、プロキシがうまく認識されず、次のような DNS エラーになったりします。 urlopen error [Errno 11001] getaddrinfo failed Request オブジェクトは生成時に URL を指定する必要があるため、アクセス先が変わるごとに生成する必要があることに注意してください。 すべてのリクエストに共通のプロキシを設定する (OpenerDirector + ProxyHandler) OpenDirector を使用すると、異なる URL に対して HTTP リクエストを送信するときに、設定情報を使いまわすことができます。 プロキシの情報を設定したい場合は、下記のように ProxyHandler を作成して OpenDirector オブジェクトのハンドラとして追加します。 OpenDirector オブジェクトは、urllib.request.build_opener 関数で生成することができます。 共通のプロキシ設定 import urllib.request PROXIES = { &#39;http&#39;: &#39;http://proxy.example.com:8080&#39;, &#39;https&#39;: &#39;https://proxy.example.com:8080&#39;, &#39;ftp&#39;: &#39;ftp://proxy.example.com:8080&#39; } proxy_handler = urllib.request.ProxyHandler(PROXIES) opener = urllib.request.build_opener(proxy_handler) with opener.open(&#39;https://example.com/&#39;) as res: html = res.read().decode(&#39;utf-8&#39;) print(html) 上記の例では、OpenerDirector#open() メソッドを使うことで、プロキシ経由の HTTP アクセスを行っています。 別の方法として、あらかじめ urllib.request.install_opener() を使って OpenerDirector をインストールしておく方法があります。 このようにすると、その後のすべての urllib.request.urlopen() によるアクセスをプロキシ経由にすることができます（OpenDirector オブジェクトを使ってアクセスする必要がなくなります）。 import urllib.request PROXIES = { &#39;http&#39;: &#39;http://proxy.example.com:8080&#39;, &#39;https&#39;: &#39;https://proxy.example.com:8080&#39;, &#39;ftp&#39;: &#39;ftp://proxy.example.com:8080&#39; } def setup_proxy(): proxy = urllib.request.ProxyHandler(PROXIES) opener = urllib.request.build_opener(proxy) urllib.request.install_opener(opener) if __name__ == &#39;__main__&#39;: setup_proxy() with urllib.request.urlopen(&#39;https://example.com/&#39;) as res: html = res.read().decode(&#39;utf-8&#39;) print(html)"},{url:"/p/an8o6m4/",title:"Python のワンライナーコマンドで JSON ファイルを整形する (json.tool)",date:"2014-11-28T00:00:00+09:00",body:"Python のワンライナーコマンドで JSON ファイルを整形する (json.tool) json.tool の基本 Python 2.6 以降には json モジュールが標準搭載されていて、これはコマンドラインからも便利に利用することができます。 下記は、json.tool モジュール を使って JSON 形式のテキスト出力を、きれいに整形しなおして出力するワンライナーの例です。 $ python -mjson.tool input.json # あるいは $ cat input.json | python -mjson.tool ここでは、次のような JSON ファイルを使って試してみます。 スペースはわざとぐちゃぐちゃに入れています。 input.json（入力ファイル） {&#34;ccc&#34; : 300, &#34;aaa&#34;:100, &#34;bbb&#34;:200, &#34;data&#34;: [1,2,3]} 実行例 $ python -mjson.tool input.json { &#34;ccc&#34;: 300, &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;data&#34;: [ 1, 2, 3 ] } キー名でソートして出力する (&ndash;sort-keys) Python 3.7 以降で、キーの順序は入力ファイルのものが保持されるようになりました（内部的に辞書オブジェクト (dict) のキー挿入順序が保持されるようになりました）。 キー順序をアルファベット順にソートして出力したいときは、--sort-keys オプションを指定します。 キー順にソートする $ python -mjson.tool --sort-keys input.json { &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;ccc&#34;: 300, &#34;data&#34;: [ 1, 2, 3 ] } インデントサイズを指定する (&ndash;indent=N) バージョン 3.9 以降では、--indent オプションで、インデントサイズの調整などもできるようになっています。 インデントサイズを 2 にする $ python -mjson.tool --indent=2 input.json { &#34;ccc&#34;: 300, &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;data&#34;: [ 1, 2, 3 ] } インデントや改行なしで出力する (&ndash;compact) 余計なスペースや改行を取り除いて、1 行でコンパクトに出力するには、--compact オプションを使用します。 プログラムへの入力にしか使わない JSON データは、このように圧縮されていると効率的です。 コンパクトに出力する $ python -mjson.tool --compact input.json {&#34;ccc&#34;:300,&#34;aaa&#34;:100,&#34;bbb&#34;:200,&#34;data&#34;:[1,2,3]}"},{url:"/p/ybvwp6b/",title:"Vim で行をソートして重複行を削除する (:sort u)",date:"2014-11-21T00:00:00+09:00",body:"Vim で行をソートして重複行を削除する (:sort u) ビジュアルモード (SHIFT-V) で対象範囲を選択し、下記のように実行すれば、指定した範囲の行をソートすることができます。 :sort &#34;アルファベット順ソート :sort n &#34;10進数とみなしてソート さらに、sort を実行するときに u オプション（unique の略）を付けることで、重複している行を一行にまとめることができます。 :sort u ファイル全体に対して実行したい場合は、下記のように % でファイル全体の行を指定すれば OK です。 :%sort u"},{url:"/p/iin6vwz/",title:"Vim で大文字と小文字を変換する",date:"2014-11-18T00:00:00+09:00",body:"Vim で大文字と小文字を変換する Vim では U や u と入力するだけで、テキストの大文字と小文字を変換することができます。 ビジュアルモードでの操作 U &hellip; 選択した範囲を大文字に変換 u &hellip; 選択した範囲を小文字に変換 ~ &hellip; 選択した範囲の大文字と小文字を入れ替え 例えば、Shift-V で、行を選択しておいて U と入力すれば、その行全体のアルファベットを大文字にすることができます。 ノーマルモードでの操作 gUU / guu &hellip; カーソル行すべての文字を大文字／小文字に変換する gUiw / guiw &hellip; カーソル位置の単語を大文字／小文字に変換 ~ &hellip; カーソル位置の一文字の大文字／小文字を反転させる g~~ &hellip; カーソル行すべての文字の大文字／小文字を反転させる 若干難しい組み合わせのように見えますが、ノーマルモードでは、gU や gu の後に置換範囲を入力することで、その範囲を大文字、小文字に変換することができます。 例えば、置換範囲として iw を入力すると (guiw)、カーソル下の単語を変換対象とすることができます。 置換範囲として移動コマンドを入力することもできるため、例えば gu$ と入力すれば、カーソル位置から行末 ($) までを小文字に変換することができます。 ただし、どちらかというと、大文字と小文字の置換は、ビジュアルモードで範囲選択を行ってから u や U と入力する方がわかりやすいです（しかもタイプ数はほぼ同じ）。 例えば、カーソル下の単語を大文字に変換するには、viw で単語選択してから、U と入力すれば OK です。"},{url:"/p/huevdub/",title:"Dex 形式の Shared library (JAR) を作成する (dx)",date:"2014-10-30T00:00:00+09:00",body:"Dex 形式の Shared library (JAR) を作成する (dx) Android デバイスの /system/framework に以下に格納して使用する Shared JAR ライブラリは、DEX 形式にコンパイルされたクラスを含んでいる必要があります。Eclipse などで単純に JAR ファイルを生成すると、PC 用の JAR ライブラリができてしまうので、DEX 形式に変換してから /system/framework にインストールする必要があります。 $ dx --dex --output=output.jar input.jar"},{url:"/p/6u8xexa/",title:"Node.jsメモ: npm でインストール可能なパッケージのバージョンを調べる",date:"2014-09-23T00:00:00+09:00",body:"Node.jsメモ: npm でインストール可能なパッケージのバージョンを調べる npm info コマンドを使用すると、NPM リポジトリで管理されているパッケージの情報を調べることができます。 例: 最新の Express のバージョンを表示する $ npm info express version 4.9.4 例: インストール可能な Express のバージョンのリストを表示する $ npm info express versions [ &#39;0.14.0&#39;, &#39;0.14.1&#39;, ... &#39;4.9.3&#39;, &#39;4.9.4&#39; ] 最後のパラメータを変更することで、パッケージに関するいろいろな情報を表示することができます。 コマンド 説明 npm info &lt;pkg&gt; version 最新のバージョン番号を表示する npm info &lt;pkg&gt; versions 有効なバージョン番号の一覧を表示する npm info &lt;pkg&gt; homepage ホームページの URL を表示する npm info &lt;pkg&gt; repository ソースコードのリポジトリの URL を表示する npm info &lt;pkg&gt; author 作者の情報を表示する npm info &lt;pkg&gt; contributors コントリビューターの一覧を表示する npm info &lt;pkg&gt; すべての情報を表示する"},{url:"/p/ysmmmia/",title:"Node.jsメモ: Node.js が require() で検索するパスのまとめ",date:"2014-09-22T00:00:00+09:00",body:"Node.jsメモ: Node.js が require() で検索するパスのまとめ require() によって Node.js がどのようにロードするモジュールを検索するかは、Node.js の Modules のドキュメント に詳しく説明されていますが、若干複雑なのでここでまとめておきます。 require の使い分け require でモジュールをロードするとき、多くは下記の 3 パターンのロード方法に分類できます。 // コアモジュール、あるいは node_modules にインストールしたパッケージのロード const crypto = require(&#39;crypto&#39;); // ローカルモジュールのロード const myLocalModule = require(&#39;./path/to/myLocalModule&#39;); // JSON ファイルのロード const jsonData = require(&#39;./path/to/data.json&#39;); 簡単にまとめると、 組み込みモジュールや、外部パッケージを使うときは名前そのものを指定する。 自分で作成したローカルモジュールや JSON ファイルは ./ で始まるパスで指定する。 と理解しておけばよいでしょう。 require がどのようにモジュールを検索するか？ require によってどのパスに置かれたファイルがロードされるかは、下記のようなアルゴリズムで決められます。 require(&rsquo;name&rsquo;) としたとき require のパラメータでモジュール名そのもの（express など）を指定した場合は、下記のようなアルゴリズムでロードするモジュールが決められます。 name というコアモジュールを探す。 同じディレクトリの node_modules/name というパッケージを探す。 より上位のディレクトリの node_modules/name というパッケージを探していく。 見つからなければ not found エラーを投げる。 例えば、/aaa/bbb/main.js 内で require('express') とすると、下記のように検索されていきます。 コアモジュール（Node の組み込みモジュール）の express /aaa/bbb/node_modules/express /aaa/node_modules/express /node_modules/express ちなみに、name というモジュール名の部分に、path/to/name のようにディレクトリパスが含まれていれば、そのような階層でインストールされた name モジュールがロードされます（node_modules/path/to/name などが検索される）。 上記の検索順序から分かるように、モジュール名を指定して require を呼び出した場合は、何よりも先にコアモジュールが検索されます。つまり、express という名前のコアモジュールが提供されるようになったら、npm install でインストールされた express の方は参照されなくなるということですね。格差社会。。。 require(&rsquo;./name&rsquo;) としたとき require のパラメータが './name'、'../name'、'/name' というように、./ や / で始まるパスで指定された場合は、そのファイルが置かれたディレクトリからの相対パス (あるいは絶対パス) で、下記のようにファイルが検索されます。 name という名前のファイルを探す。 name.js という名前のファイルを探す。 name.json という名前のファイルを探す（JSON ファイルとしてロード）。 name.node という名前のファイルを探す（バイナリ addon として dlopen でロード）。 name/package.json というファイルがあれば、その main フィールドを見て、name/&lt;mainフィールドの値&gt; というパスを使用して 1 からやり直し。main フィールドの記載がなければ、下記のステップへ続く。 name/index.js という名前のファイルを探す。 name/index.json という名前のファイルを探す（JSON ファイルとしてロード）。 name/index.node という名前のファイルを探す（バイナリ addon として dlopen でロード）。 グローバルフォルダから検索する（後述）。 見つからなければ not found エラーを投げる 例えば、/aaa/bbb/main.js 内で require('./mylib') とすると、下記のように検索されていきます。 /aaa/bbb/mylib という JavaScript ファイル /aaa/bbb/mylib.js という JavaScript ファイル /aaa/bbb/mylib.json という JSON ファイル /aaa/bbb/mylib.node というバイナリ addon ファイル /aaa/bbb/mylib/package.json に main フィールドがあれば、mylib/&lt;mainフィールドの値&gt; が指定されたものとして同様に検索 /aaa/bbb/mylib/index.js という JavaScript ファイル /aaa/bbb/mylib/index.json という JSON ファイル /aaa/bbb/mylib/index.node というバイナリ addon ファイル 各グローバルフォルダ以下から同様に検索 ちなみに、require に渡す名前に ./sample.js のように、拡張子まで含めて指定した場合も、上記のアルゴリズムはそのまま実行されます。 .js という拡張子を持つファイルだけが検索されるわけではありません。 つまり、sample.js というファイルが見つからなければ、sample.js.js や sample.js.json のようなファイル名で検索が行われます。 グローバルフォルダからのモジュールロード（非推奨） Node は上記で説明したパスからだけでなく、下記のようなディレクトリからもモジュールを検索します（参考: Loading from the global folders） 。 NODE_PATH 環境変数に列挙されたディレクトリ（Linux はコロン区切り、Windows はセミコロン区切りで列挙） $HOME/.node_modules $HOME/.node_libraries $PREFIX/lib/node ただし、これらの仕組みは現在のような高度なモジュール検索アルゴリズムが導入される前に作られたもので、互換性のために残されています。 環境毎の設定の違いにより、アプリケーションの振る舞いが大きく変わってしまう可能性があるので、できるだけグローバルフォルダの仕組みは使わないようにしましょう。 （コラム） require によりロードしたモジュールは指定した名前でキャッシュされる Node.js は、require による同一モジュールの読み込みを効率化するため、読み込んだモジュールをキャッシュしています。 主にメモリ効率や速度向上のための仕組みですが、副次的な作用として、モジュールインスタンスが複数のクライアントモジュール間で共有されることに注意してください。 次のサンプルコードの動作を見るとわかりやすいです。 mylib.js exports.value = 100; stranger.js const mylib = require(&#39;./mylib&#39;); mylib.value = 200; main.js（エントリポイント） const mylib = require(&#39;./mylib&#39;); console.log(mylib.value); const stranger = require(&#39;./stranger&#39;); console.log(mylib.value); 実行結果 $ node main.js 100 200 ★mylib.value の値が書き換わっている mylib モジュールは、value 変数を公開しています。 mylib.value の値は最初 100 ですが、stranger.js の中で間接的に 200 に書き換えられています。 stranger.js から読み込んだ mylib モジュールインスタンスは、main.js が参照しているインスタンスと同じものなので、stranger.js で mylib インスタンスの内容を書き換えると、その影響が main.js 側の mylib インスタンスにも及ぶことになります（stranger.js をロードするだけで mylib.value の値が 100 から 200 に変わってしまう）。 このキャッシュの仕組みを、モジュール間の値のやりとりに利用できそうだと思うかもしれませんが、そのような用途で使うのは避けるべきです。 なぜなら、同一だと思われるモジュールでも別のキャッシュインスタンスが生成されることがあるからです。 Node.js は、キャッシュされたモジュールの識別子として、require のパラメータで指定された名前を使用しています。 ロードするモジュールの相対的なパスが変わったり、ファイル名の指定方法が変わるだけで別のインスタンスが生成される可能性があります。 例えば、Windows のファイルシステムは大文字と小文字を区別しませんが、Node.js がモジュールインスタンスをキャッシュするときは、大文字と小文字が区別された名前を識別子として使用します。 Windows 環境において、mylib.js と MYLIB.js は同一のファイルを示しますが、Node.js で require('./mylib') とした場合と、require('./MYLIB') とした場合は別々のモジュールインスタンスとしてキャッシュされることになります。 下記の例を見てください。 前述の main.js をちょっとだけ書き換えて、require パラメータで指定するモジュールのパスを大文字に変更しています。 main.js const mylib = require(&#39;./MYLIB&#39;); // 大文字で指定 console.log(mylib.value); const stranger = require(&#39;./stranger&#39;); console.log(mylib.value); 実行結果 $ node main.js 100 100 ★stranger.js の中の変更は main.js に影響しない このようにすると、main.js の中の mylib インスタンスと、stranger.js の中の mylib インスタンスは別々のインスタンスとして扱われるため、stranger.js の中での mylib インスタンスの変更は main.js 側に影響しません。"},{url:"/p/o2m2ft7/",title:"Git でブランチやタグの作者を調べる (git for-each-ref)",date:"2014-09-18T00:00:00+09:00",body:"Git でブランチやタグの作者を調べる (git for-each-ref) トピックブランチを使った開発手法を適用していると、トピックブランチの削除忘れなどにより、ブランチが散乱してくることがあります。 このような場合は、誰が作成したブランチが放置されているのか調べる必要があります。 下記は、手っ取り早くブランチの作者を調べる方法です。 まずは、GitHub（中央リポジトリ）上で削除済みのブランチは、ローカルのリモートトラッキングブランチからも削除しておきます。 不要なリモートトラッキングブランチを削除 $ git fetch --prune あとは、次のようにすれば、ブランチやタグ (refs) の作者を調べることができます。 ブランチやタグの作者を調べる $ git for-each-ref --format=%(authorname)%09%09%(refname) | sort maku refs/heads/main maku refs/heads/my-branch john refs/remotes/origin/apply-eslint ripper refs/remotes/origin/gh-pages maku refs/remotes/origin/HEAD maku refs/remotes/origin/main"},{url:"/p/2x9it3c/",title:"APK ファイルの署名を確認する (jarsigner, openssl)",date:"2014-08-22T00:00:00+09:00",body:"APK ファイルの署名を確認する (jarsigner, openssl) 署名情報を確認する方法 JDK に付属している jarsigner コマンドを使用して、APK ファイルの署名情報を確認することができます。 MyApp.apk の署名を確認する $ jarsigner -verify -certs -verbose MyApp.apk ... sm 21632 Mon Sep 01 17:08:16 JST 2014 lib/libhoge.so X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] s 36381 Fri Oct 03 14:10:34 JST 2014 META-INF/MANIFEST.MF X.509, CN=Android Debug, O=Android, C=US [certificate is valid from 12/08/27 17:19 to 42/08/20 17:19] [CertPath not validated: Path does not chain with any of the trust anchors] 36434 Fri Oct 03 14:10:34 JST 2014 META-INF/CERT.SF 1203 Fri Oct 03 14:10:34 JST 2014 META-INF/CERT.RSA s = signature was verified m = entry is listed in manifest k = at least one certificate was found in keystore i = at least one certificate was found in identity scope jar verified. 証明書の公開鍵 (Subject Public Key Info) を確認する方法 APK 内の証明書から、公開鍵情報を抽出するには、openssl ツールを使用して下記のように実行します。 $ jar xvf MyApp.apk META-INF # APK内の証明書を抽出 $ openssl pkcs7 -inform DER -in META-INF/CERT.RSA -noout -print_certs -text Certificate: Data: Version: 3 (0x2) Serial Number: 553438828 (0x20fcce6c) Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=Android, CN=Android Debug Validity Not Before: Aug 27 08:19:20 2012 GMT Not After : Aug 20 08:19:20 2042 GMT Subject: C=US, O=Android, CN=Android Debug Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (2048 bit) Modulus: 00:bb:40:43:86:b6:9e:84:5a:8b:b3:b3:c0:bc:08: f0:8f:28:92:7c:7a:3d:02:44:da:17:4b:d0:a0:c5: 86:eb:f8:b4:2e:3e:3d:10:60:bc:dd:fe:5e:a9:17: c8:ba:eb:bb:fc:96:ff:a2:02:39:77:42:ab:db:0b: d1:9b:09:34:f3:3b:20:89:27:8c:d2:99:0d:2b:e1: 4a:34:49:5a:4a:76:ad:b4:a4:9d:4c:6a:42:fa:07: 0f:b3:ae:90:d3:19:7f:74:78:5d:73:27:f3:52:0b: 82:64:2c:d6:64:e0:c9:56:97:c8:c4:53:e7:35:e5: b6:25:c5:58:cd:85:bd:64:f6:94:da:d1:0e:72:1d: 8f:ad:f8:b8:f7:ae:37:18:70:a2:b7:01:f4:42:c1: 04:bc:3b:b6:a0:85:29:95:5f:e7:c8:82:4b:b0:01: db:1b:5b:06:c2:c1:e1:8d:e6:35:bf:f4:5f:ef:20: b0:7f:f8:b8:36:fa:8d:48:7b:4b:35:c1:6a:a1:42: 1a:e7:df:b2:af:a9:8d:d3:9b:0d:6a:bf:c8:fc:94: 3d:99:61:1c:94:a6:40:1b:94:ac:e6:8e:07:20:77: 39:87:3e:86:38:a6:9e:c1:75:9a:13:99:06:73:b9: d3:22:66:30:2f:e1:ea:4a:01:6e:8d:7d:ed:82:b2: 79:f7 Exponent: 65537 (0x10001) X509v3 extensions: X509v3 Subject Key Identifier: 8D:5D:22:F1:D1:23:18:0D:B2:6A:B0:2E:71:BE:83:3F:BF:C6:F1:D0 Signature Algorithm: sha256WithRSAEncryption 47:97:ba:aa:e6:c0:52:83:d3:52:0b:be:4f:b9:7b:bd:06:a3: 06:d3:ee:62:89:35:e4:a7:02:fc:99:53:b6:97:23:10:c9:17: 94:c3:e8:4a:70:79:05:5b:1b:d7:6b:f9:45:09:33:8f:a1:ac: cb:60:54:65:13:b4:61:ce:39:0c:40:65:08:6d:d8:ab:03:15: 84:96:55:2e:bd:3f:c1:bb:d5:85:9d:91:91:27:e8:83:e9:17: 0e:31:3d:f3:a4:33:ac:a0:1d:65:65:42:d8:90:e3:3b:e7:04: 42:81:d5:51:b2:0d:cc:b1:d7:64:f1:f7:aa:c8:56:09:ea:7c: af:7b:b4:f0:48:49:b7:7b:1a:c1:1a:a1:8e:1b:46:c5:50:54: e0:a9:c0:63:0e:d4:8d:58:70:77:91:ce:d0:d6:5d:ba:38:f6: ab:2d:16:23:f9:de:61:b1:c0:af:ed:a9:3e:85:f8:ed:da:47: fe:04:58:31:1a:eb:54:8f:fe:1f:a1:68:12:1f:bf:83:31:05: fa:d3:30:d3:52:59:2b:4a:fb:9b:0a:aa:0e:02:b6:b3:39:75: f9:c0:5f:b4:0e:09:f8:f5:80:e3:54:49:c0:33:e4:36:88:42: 34:fa:01:50:03:58:ca:20:0e:44:a1:eb:c2:c2:6e:e6:11:30: ec:77:71:b2"},{url:"/p/coekmmp/",title:"msysGit で terminal is not fully functional と怒られる場合の対策",date:"2014-08-19T00:00:00+09:00",body:"msysGit で terminal is not fully functional と怒られる場合の対策 Windows の Git クライアントとして msysGit を使っていると、git log や git diff を実行したときに以下のような警告が出ることがあります。 C:\\&gt; git log WARNING: terminal is not fully functional これを防ぐには、TERM 環境変数を設定します。 set TERM=msys"},{url:"/p/xx9qovn/",title:"Androidメモ: ValueAnimator でアニメーション処理に使用する値を計算する",date:"2014-08-13T00:00:00+09:00",body:"Androidメモ: ValueAnimator でアニメーション処理に使用する値を計算する Android の ValueAnimator クラスを使用すると、ある数値からある数値まで、指定した時間で変化する値を取得することができます。 例えば、次の animator は、1000 ミリ秒の間に 0 から 360 まで変化する値を生成します。 ValueAnimator animator = ValueAnimator.ofFloat(0, 360).setDuration(1000); AnimatorUpdateListener をセットして ValueAnimator#start() を呼び出すと、値の変化を検出したときにコールバックされます。 その時点での変化中の値は、getAnimatedValue() で取得できます。 次の Java サンプルコードでは、ある View を 1 秒間かけて 360°回転させます。 // final View view = findViewById(...); ValueAnimator animator = ValueAnimator.ofFloat(0, 360).setDuration(1000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator anim) { view.setRotation((float) anim.getAnimatedValue()); } }); animator.start(); ValueAnimator では、数値の変化方法を柔軟に設定することができます。 例えば、次の例では、数値が 0 → 100 → 0 → 200 のように変化します（4 段階ではなく、滑らかに変化します）。 ValueAnimator animator = ValueAnimator.ofFloat(0, 100, 0, 200); animator.addUpdateListener(...); animator.setDuration(1000).start(); また、ValueAnimator.setInterpolator() で補間アルゴリズムを設定することで、数値がどのような割合で変化していくかを指定することができます。 デフォルトでは、AccelerateDecelerateInterpolator が設定されているため、最初に加速し、最後に減速するという値の変化をします。 animator.setInterpolator(...);"},{url:"/p/8wsrauw/",title:"Androidメモ: Canvas への描画時にアンチエイリアスを有効にする (Paint#setAntiAlias)",date:"2014-08-11T00:00:00+09:00",body:"Androidメモ: Canvas への描画時にアンチエイリアスを有効にする (Paint#setAntiAlias) Android の Canvas への描画時に使用する Paint オブジェクトで、setAntiAlias(true) することで、アンチエイリアスを有効にした描画を行うことができます。 public class MyCustomView extends View { private final Paint mBackgroundPaint = new Paint(); // ... private void init() { mBackgroundPaint.setColor(Color.BLUE); mBackgroundPaint.setAntiAlias(true); // ★アンチエイリアス有効化 } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); int w = canvas.getWidth(); int h = canvas.getHeight(); int radius = w &lt; h ? w/2 : h/2; canvas.drawCircle(w / 2, h / 2, radius, mBackgroundPaint); // アンチエイリアス有効にした円を描画 } }"},{url:"/p/nfguckx/",title:"Androidメモ: カスタムビューでソフトウェア D-Pad を表示する",date:"2014-08-11T00:00:00+09:00",body:"Androidメモ: カスタムビューでソフトウェア D-Pad を表示する D-Pad（十字キー）をカスタムビューとして実装するサンプルコードです。 上下左右キーのタッチ入力は、DPadListener を使って監視できます。 カスタムビューの実装例 DPadListener.java DPadView.java DPadEvent.java 使用例 res/layout/activity_main.xml（抜粋） &lt;io.github.maku77.widget.DPadView android:id=&#34;@+id/dpad&#34; android:layout_width=&#34;200dp&#34; android:layout_height=&#34;200dp&#34; /&gt; MainActivity.java public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); DPadView dpad = (DPadView) findViewById(R.id.dpad); dpad.setDPadListener(new DPadListener() { @Override public void onCursor(DPadEvent event) { Log.d(&#34;DEBUG&#34;, event.toString()); } }); } }"},{url:"/p/4c5st3s/",title:"Androidメモ: カスタムビューを作成する",date:"2014-08-11T00:00:00+09:00",body:"Androidメモ: カスタムビューを作成する onDraw で自力で描画するカスタムビューを作る Android では、android.view.View を継承したビュークラスを作成することで、簡単にカスタムビューを作成することができます。 ここでは、com.example.myapp.MyCustomView という、丸を描画するだけのカスタムビューを作成します。 描画処理は onDraw() メソッドをオーバーライドして記述します。 MyCustomView.java package com.example.myapp; import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.util.AttributeSet; import android.view.View; public class MyCustomView extends View { private final Paint mBackgroundPaint = new Paint() { { setColor(Color.YELLOW); setAntiAlias(true); } }; public MyCustomView(Context context) { super(context); } public MyCustomView(Context context, AttributeSet attrs) { super(context, attrs); } public MyCustomView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onDraw(Canvas canvas) { int w = canvas.getWidth(); int h = canvas.getHeight(); int radius = w &lt; h ? w/2 : h/2; canvas.drawCircle(w / 2, h / 2, radius, mBackgroundPaint); } } ちなみに、Kotlin では次のように少しだけシンプルに記述できます。 MyCustomView.kt package com.example.myapp import android.content.Context import android.graphics.Canvas import android.graphics.Color import android.graphics.Paint import android.util.AttributeSet import android.view.View class MyCustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : View(context, attrs, defStyleAttr) { private val backgroundPaint = Paint().apply { color = Color.YELLOW isAntiAlias = true } override fun onDraw(canvas: Canvas) { val w = canvas.width.toFloat() val h = canvas.height.toFloat() val radius = if (w &lt; h) w / 2 else h / 2 canvas.drawCircle(w / 2, h / 2, radius, backgroundPaint) } } 作成したカスタムビューは、任意のレイアウト XML ファイルから次のように使用することができます。 activity_main.xml（抜粋） &lt;com.example.myapp.MyCustomView android:layout_width=&#34;200dp&#34; android:layout_height=&#34;100dp&#34; android:layout_marginVertical=&#34;20dp&#34; /&gt; 既存のビューを組み合わせてカスタムビューを作る 既存のボタンウィジェットなどを組み合わせて、ひとつのカスタムビューを作成することができます。 意味のある単位でカスタムビューの形でカプセル化しておくと、コードの見通しがよくなります。 ここでは、ボタンを横方向に２つ並べただけの、MyButtonsView クラスを作成します。 まずは、カスタムビュー用のレイアウトファイルを作成します（もちろん、XML ファイルを使わずに、Java コードの中で動的に配置することもできます）。 res/layout/my_buttons_view.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;LinearLayout xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34; android:orientation=&#34;horizontal&#34;&gt; &lt;Button android:id=&#34;@+id/button1&#34; android:text=&#34;1&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;match_parent&#34;/&gt; &lt;Button android:id=&#34;@+id/button2&#34; android:text=&#34;2&#34; android:layout_width=&#34;wrap_content&#34; android:layout_height=&#34;match_parent&#34;/&gt; &lt;/LinearLayout&gt; 次に、MyButtonsView クラスの実装を行います。 レイアウトとして LinearLayout を採用したので、View クラスではなく、LinearLayout を継承して作成します。 MyButtonsView.java package com.example.myapp; import android.content.Context; import android.util.AttributeSet; import android.view.LayoutInflater; import android.view.View; import android.widget.Button; import android.widget.LinearLayout; import android.widget.Toast; public class MyButtonsView extends LinearLayout { public MyButtonsView(Context context) { super(context); init(context); } public MyButtonsView(Context context, AttributeSet attrs) { super(context, attrs); init(context); } public MyButtonsView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context); } private void init(Context context) { // 第 2 引数で this を指定することで、Layout XML を自分自身に inflate する View layout = LayoutInflater.from(context).inflate(R.layout.my_buttons_view, this); ((Button) layout.findViewById(R.id.button1)).setOnClickListener(mListener); ((Button) layout.findViewById(R.id.button2)).setOnClickListener(mListener); } private final View.OnClickListener mListener = new View.OnClickListener() { @Override public void onClick(View view) { Button button = (Button) view; Toast.makeText(view.getContext(), button.getText(), Toast.LENGTH_SHORT).show(); } }; } ちなみに、Kotlin だと次のようにもう少し簡潔に書けます。 MyButtonsView.kt package com.example.myapp import android.content.Context import android.util.AttributeSet import android.view.LayoutInflater import android.widget.Button import android.widget.LinearLayout import android.widget.Toast import kotlinx.android.synthetic.main.my_buttons_view.view.* class MyButtonsView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : LinearLayout(context, attrs, defStyleAttr) { private val clickListener = OnClickListener { view -&gt; val btn = view as Button Toast.makeText(context, btn.text, Toast.LENGTH_LONG).show() } init { LayoutInflater.from(context).inflate(R.layout.my_buttons_view, this) button1.setOnClickListener(clickListener) button2.setOnClickListener(clickListener) } } このカスタムビューを使用するときは、他の View クラスと同様に、任意のレイアウト XML ファイル内で以下のように使用できます。 もちろん、コード内から動的に View を生成することもできます。 &lt;com.example.myapp.MyButtonsView android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;wrap_content&#34;/&gt;"},{url:"/p/35cr5fp/",title:"Androidメモ: タッチイベントをハンドルする",date:"2014-07-29T00:00:00+09:00",body:"Androidメモ: タッチイベントをハンドルする onTouchEvent/OnTouchListener で基本情報を取得する Android の Activity 実装内で onTouchEvent(MotionEvent event) メソッドをオーバライドすると、その Activity 上で発生したタッチイベントをハンドルすることができます。 public class MainActivity extends Activity { ... @Override public boolean onTouchEvent(MotionEvent event) { ... return super.onTouchEvent(event); } } あるいは、View#setOnTouchListener() を使って、タッチイベントをハンドルするためのリスナを設定することもできます。 view.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { ... return true; } }); 上記のようなメソッドで渡される MotionEvent オブジェクトを参照すると、どのような内容のイベントが発生したかを調べることができます。 例えば、MotionEvent#getAction() では、どのような操作を行ったかを取得できます。 MotionEvent.ACTION_DOWN (0) &hellip; タッチ開始（指で触れた） MotionEvent.ACTION_UP (1) &hellip; タッチ終了（指を離した） MotionEvent.ACTION_MOVE (2) &hellip; ドラッグ中 参考: MotionEvent - Android Developers MotionEvent#getX() や getY() では、タッチしている座標値を取得できます。 下記の例では、Activity 上でのタッチをハンドルし、座標値などを表示しています。 MainActivity.java public class MainActivity extends Activity { private static final String TAG = MainActivity.class.getSimpleName(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onTouchEvent(MotionEvent event) { StringBuilder msg = new StringBuilder(); msg.append(&#34;action=&#34;).append(event.getAction() &amp; MotionEvent.ACTION_MASK); msg.append(&#34;, x=&#34;).append(event.getX()); msg.append(&#34;, y=&#34;).append(event.getY()); Log.d(TAG, msg.toString()); return super.onTouchEvent(event); } } 出力例（一本指で少しドラッグした場合） 07-29 17:33:03.100: D/MainActivity(19400): action=0, x=797.0, y=468.0 07-29 17:33:03.110: D/MainActivity(19400): action=2, x=800.0, y=470.0 07-29 17:33:03.120: D/MainActivity(19400): action=2, x=804.0, y=473.0 07-29 17:33:03.140: D/MainActivity(19400): action=2, x=810.0, y=479.0 07-29 17:33:03.160: D/MainActivity(19400): action=2, x=817.0, y=486.0 07-29 17:33:03.170: D/MainActivity(19400): action=2, x=824.0, y=494.0 07-29 17:33:03.190: D/MainActivity(19400): action=2, x=831.0, y=502.0 07-29 17:33:03.210: D/MainActivity(19400): action=2, x=839.0, y=509.0 07-29 17:33:03.220: D/MainActivity(19400): action=2, x=848.0, y=517.0 07-29 17:33:03.230: D/MainActivity(19400): action=1, x=848.0, y=517.0 onTouchEvent() の戻り値に注意 onTouchEvent() の戻り値で false が返された場合は、MotionEvent.ACTION_DOWN しかイベントが発生しません。 Activity の場合は super.onTouchEvent() の結果を return するようにすれば大丈夫ですが、SurfaceView などのサブクラスでは、明示的に return true; としないと罠にハマります。 @Override public boolean onTouchEvent(MotionEvent event) { ... return true; // 明示的に true を返す } 複数指でのタッチ情報を取得する MotionEvent オブジェクトからは、複数指でのタッチ情報を別々に取得することもできます。 MotionEvent#getPointerCount() &hellip; 何本の指でタッチしているか MotionEvent#getX(int index) &hellip; 指定したインデックスの指の X 座標を取得 MotionEvent#getY(int index) &hellip; 指定したインデックスの指の Y 座標を取得 最初にタッチした指から順番に 0, 1, 2, 3 というインデックスが振られていきます。 下記のコードでは、2本指でピンチ Open/Close 処理しているときのそれぞれの指の座標値を表示しています。 @Override public boolean onTouchEvent(MotionEvent e) { StringBuilder msg = new StringBuilder(); if (e.getPointerCount() == 2 &amp;&amp; e.getAction() == MotionEvent.ACTION_MOVE) { msg.append(&#34; [&#34;).append(e.getX(0)).append(&#34;, &#34;).append(e.getY(0)).append(&#34;]&#34;); msg.append(&#34; [&#34;).append(e.getX(1)).append(&#34;, &#34;).append(e.getY(1)).append(&#34;]&#34;); } Log.d(TAG, msg.toString()); return super.onTouchEvent(e); } GestureDetector で詳しいタッチイベントを取得する 参考: Detecting Common Gestures - Android Developers android.view.GestureDetector を使用すると、Activity#onTouchEvent() や View.OnTouchListener#onTouch() で渡される MotionEvent 情報を解析し、より詳細なタッチイベントの形式でコールバックを受けることができます。 使い方は以下のような感じで、任意の Activity/View で受けたタッチイベントをそのまま GestureDetector インスタンスにフォワードしてやるだけです。 そうすると、GestureDetector インスタンスにセットした GestureDetector.OnGestureListener の各種コールバックが適切なタイミングで呼び出されます。 MainActivity.java public class MainActivity extends Activity implements GestureDetector.OnGestureListener { // private static final String TAG = MainActivity.class.getSimpleName(); private GestureDetector mGestureDetector; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mGestureDetector = new GestureDetector(this, new GestureDetector.OnGestureListener() {...}); } @Override public boolean onTouchEvent(MotionEvent e) { mGestureDetector.onTouchEvent(e); return true; } } GestureDetector.OnGestureListener インタフェースでは下記のようなイベントをハンドルします。 onDown() &hellip; Notified when a tap occurs with the down MotionEvent that triggered it. onFling() &hellip; Notified of a fling event when it occurs with the initial on down MotionEvent and the matching up MotionEvent. onLongPress() &hellip; Notified when a long press occurs with the initial on down MotionEvent that trigged it. onScroll() &hellip; Notified when a scroll occurs with the initial on down MotionEvent and the current move MotionEvent. onShowPress() &hellip; The user has performed a down MotionEvent and not performed a move or up yet. onSingleTapUp() &hellip; Notified when a tap occurs with the up MotionEvent that triggered it. さらに、GestureDetector#setOnDoubleTapListener() で、OnDoubleTapListener をセットすることで、ダブルタップを判別できるようになります。 OnDoubleTapListener インタフェースでは下記のイベントをハンドルします。 onDoubleTap() &hellip; Notified when a double-tap occurs. onDoubleTapEvent() &hellip; Notified when an event within a double-tap gesture occurs, including the down, move, and up events. onSingleTapConfirmed() &hellip; Notified when a single-tap occurs. 各種操作を行った場合のイベント いろいろなタイプのタッチ操作を行った場合、下記のような順序でイベントが発生します（テスト用プログラム: GestureDetectorActivity.java ）。 シングルタップ OnGestureListener#onDown OnGestureListener#onSingleTapUp OnDoubleTapListener#onSingleTapConfirmed ダブルタップ OnGestureListener#onDown OnGestureListener#onSingleTapUp OnDoubleTapListener#onDoubleTap OnDoubleTapListener#onDoubleTapEvent OnGestureListener#onDown OnDoubleTapListener#onDoubleTapEvent 長押し OnGestureListener#onDown OnGestureListener#onShowPress OnGestureListener#onLongPress フリック（左上から右下へ） OnGestureListener#onDown OnGestureListener#onScroll: -21.0, -25.0 OnGestureListener#onScroll: -30.0, -24.0 OnGestureListener#onScroll: -50.0, -45.0 OnGestureListener#onScroll: -84.0, -67.0 OnGestureListener#onScroll: -84.0, -70.0 OnGestureListener#onFling: 6211.229, 5071.926 必要なタッチイベントのみハンドルする 通常は、OnGestureListener インタフェースや、OnDoubleTapListener インタフェースをすべて実装するより、SimpleOnGestureListener クラスを継承したクラスを作ったほうが楽です。 SimpleOnGestureListener クラスは、2 つのインタフェースの空実装を提供するので、必要なメソッドだけをオーバライドするだけで使用できます。 例えば、onLongPress イベントだけハンドルしたい場合は下記のように実装します。 public class MainActivity extends Activity { private GestureDetector mGestureDetector; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Create a gesture detector and set a listener. mGestureDetector = new GestureDetector(this, mGestureListener); mGestureDetector.setOnDoubleTapListener(mGestureListener); } private GestureDetector.SimpleOnGestureListener mGestureListener = new GestureDetector.SimpleOnGestureListener() { @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float distX, float distY) { // ... return true; } }; @Override public boolean onTouchEvent(MotionEvent e) { mGestureDetector.onTouchEvent(e); return true; } } View の setOnTouchListener() を利用する Activity では onTouchEvent() をオーバライドすることによって GestureDetector へ渡す MotionEvent を取得していましたが、View では OnTouchEventListener インスタンスをセットすることでも MotionEvent を取得することができます。 public class MySurfaceView extends SurfaceView implements SurfaceHolder.Callback { private GestureDetector mGestureDetector; // ... private void init() { mGestureDetector = new GestureDetector(getContext(), mGestureListener); mGestureDetector.setOnDoubleTapListener(mGestureListener); this.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { mGestureDetector.onTouchEvent(event); return true; } }); } private GestureDetector.SimpleOnGestureListener mGestureListener = new GestureDetector.SimpleOnGestureListener() { @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float distX, float distY) { Log.d(&#34;LOG&#34;, distX + &#34;, &#34; + distY); return true; } }; ... }"},{url:"/p/t6wfxev/",title:"メモリの使用状況を確認する (dumpsys meminfo)",date:"2014-07-29T00:00:00+09:00",body:"メモリの使用状況を確認する (dumpsys meminfo) 各プロセスのメモリ使用状況を確認する dumpsys コマンドの meminfo セクションでは、各プロセスのメモリ使用状況を確認することができます。 $ adb shell dumpsys meminfo Applications Memory Usage (kB): Uptime: 169910958 Realtime: 170196415 Total PSS by process: 96302 kB: system (pid 728) 44547 kB: com.android.systemui (pid 965) 32601 kB: com.sonyericsson.android.pobox.imecore (pid 1042) 29610 kB: com.android.settings (pid 8006) 26500 kB: com.sonyericsson.home (pid 1321) 23027 kB: com.facebook.katana (pid 7371) 17963 kB: com.facebook.katana:dash (pid 7641) 13579 kB: com.google.android.gms (pid 5171) ... プロセスを指定してメモリ使用状況を確認する 上記で表示されたパッケージ名や pid を、dumpsys meminfo コマンドの後ろに続けて指定することで、そのプロセスにおける詳細なメモリ使用情報を調べられます。 $ adb shell dumpsys meminfo com.android.phone Applications Memory Usage (kB): Uptime: 170096486 Realtime: 170381943 ** MEMINFO in pid 1066 [com.android.phone] ** Shared Private Heap Heap Heap Pss Dirty Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ Native 20 8 20 2376 2323 48 Dalvik 3236 5256 3156 11108 3032 8076 Cursor 0 0 0 Ashmem 2 4 0 Other dev 4 48 0 .so mmap 564 2232 464 .jar mmap 6 0 0 .apk mmap 955 0 0 .ttf mmap 0 0 0 .dex mmap 0 0 0 Other mmap 2113 16 184 Unknown 1058 484 1056 TOTAL 7958 8048 4880 13484 5355 8124 Objects Views: 0 ViewRootImpl: 0 AppContexts: 13 Activities: 0 Assets: 7 AssetManagers: 7 Local Binders: 45 Proxy Binders: 25 Death Recipients: 5 OpenSSL Sockets: 0 SQL MEMORY_USED: 178 PAGECACHE_OVERFLOW: 32 MALLOC_SIZE: 62 DATABASES pgsz dbsz Lookaside(b) cache Dbname 4 16 22 131/19/2 /data/data/com.android.providers.telephony/databases/telephony.db 4 20 25 1/19/2 /data/data/com.android.phone/databases/rejectmsgs.db プログラムからメモリ使用状況を確認する Android プログラムの実装からメモリ情報を取得するには、android.os.Debug クラスを使用します。 // Native ヒープの使用可能最大サイズ long total = Debug.getNativeHeapSize(); // Native ヒープの残りサイズ long free = Debug.getNativeHeapFreeSize() // Native ヒープの割り当て済みサイズ long alloc = Debug.getNativeHeapAllocatedSize(); デバイス上で procrank が使用できる場合 Android デバイスを debug ビルドパッケージで開発しているときは、Linux の procrank コマンドを使用できるかもしれません。 adb shell で Android デバイスに接続して次のように実行します。 # procrank PID Vss Rss Pss Uss cmdline 890 84456K 48668K 25850K 21284K system_server 1231 50748K 39088K 17587K 13792K com.android.launcher2 947 34488K 28528K 10834K 9308K com.android.wallpaper 987 26964K 26956K 8751K 7308K com.google.process.gapps 954 24300K 24296K 6249K 4824K com.android.phone 948 23020K 23016K 5864K 4748K com.android.inputmethod.latin 888 25728K 25724K 5774K 3668K zygote 977 24100K 24096K 5667K 4340K android.process.acore ..."},{url:"/p/j7yysr5/",title:"Androidメモ: Canvas に複数行のテキストを描画する",date:"2014-07-28T00:00:00+09:00",body:"Androidメモ: Canvas に複数行のテキストを描画する Android の SurfaceView にテキストを描画するには、Canvas#drawText() を使用しますが、このメソッドでは一行のテキストのみ描画できます。 特定の幅でテキストを折り返して Canvas に描画するには、折り返し計算と複数行テキストの描画処理を自分で実装する必要があります。 TextDrawUtil.java 上記のユーティリティクラスを使用すると、特定の幅、高さに収まるように改行しながらテキストを描画できます。 // 座標 (0, 0) に、幅 80、高さ 100 に収まるようにテキスト描画 TextDrawUtil.drawMultilineText(canvas, text, 0, 0, 80, 100, mPaint); 同じテキストを繰り返し描画する場合は、描画内容を Bitmap インスタンスに保持して、Canvas#drawBitmap() で描画する方が効率的です。 上記のユーティリティには、テキストを描画した Bitmap インスタンスを生成するメソッドも用意しています。 Bitmap bitmap = TextDrawUtil.createTextBitmap(text, 80, 100, mPaint); // 作ったビットマップは以下のようにして描画 canvas.drawBitmap(bitmap, 0, 0, null); 以下は、全体的な構成のサンプルです。 MyView.java public class MyView extends View { // ... private final Paint mPaintRect = new Paint() { { setColor(Color.BLUE); } }; private final Paint mPaintText = new Paint() { { setColor(Color.WHITE); setTextSize(24); setAntiAlias(true); } }; private final RectF mRect = new RectF(50, 50, 130, 155); @Override protected void onDraw(Canvas canvas) { // Draw a background of the text. canvas.drawRect(mRect, mPaintRect); // Draw a multiline text. final String text = &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;; TextDrawUtil.drawMultilineText(canvas, text, mRect, mPaintText); } }"},{url:"/p/8nbd6ca/",title:"Androidメモ: キーイベント (KeyEvent) を見やすく出力する",date:"2014-07-28T00:00:00+09:00",body:"Androidメモ: キーイベント (KeyEvent) を見やすく出力する Android の View に対するキー入力は、View#dispatchKeyEvent(KeyEvent event) などでハンドルすることができます。 このとき渡される KeyEvent オブジェクトの詳しい内容は、toString() メソッドを使ってテキスト形式で取得することができます。 例えば、下記は Shift + A を入力したときに dispatchKeyEvent() に渡される KeyEvent オブジェクトの内容を toString() を利用して出力した例です。 KeyEvent: KeyEvent { action=ACTION_DOWN, keyCode=KEYCODE_SHIFT_LEFT, scanCode=0, metaState=META_SHIFT_ON|META_SHIFT_LEFT_ON, flags=0x0, repeatCount=0, eventTime=14731488, downTime=14731488, deviceId=-1, source=0x101 } KeyEvent { action=ACTION_DOWN, keyCode=KEYCODE_A, scanCode=0, metaState=META_SHIFT_ON|META_SHIFT_LEFT_ON, flags=0x0, repeatCount=0, eventTime=14731488, downTime=14731488, deviceId=-1, source=0x101 } KeyEvent { action=ACTION_UP, keyCode=KEYCODE_A, scanCode=0, metaState=META_SHIFT_ON|META_SHIFT_LEFT_ON, flags=0x0, repeatCount=0, eventTime=14731488, downTime=14731488, deviceId=-1, source=0x101 } KeyEvent { action=ACTION_UP, keyCode=KEYCODE_SHIFT_LEFT, scanCode=0, metaState=0, flags=0x0, repeatCount=0, eventTime=14731488, downTime=14731488, deviceId=-1, source=0x101 } 詳しい情報が出てくるのですが、ここまでの情報は必要ないことがほとんどです。 そのような場合、下記のようにシンプルに整形して出力するとデバッグがはかどります。 action=down |key=59|scan=0|meta=65|repeat=0 action=down |key=29|scan=0|meta=65|repeat=0 action=up |key=29|scan=0|meta=65|repeat=0 action=up |key=59|scan=0|meta=0|repeat=0 下記は、KeyEvent オブジェクトから上記のようなテキスト表現を生成するメソッドです。 public static String prettyKeyEvent(KeyEvent event) { StringBuilder sb = new StringBuilder(); switch (event.getAction()) { case KeyEvent.ACTION_DOWN: sb.append(&#34;action=&#34;).append(&#34;down &#34;); break; case KeyEvent.ACTION_UP: sb.append(&#34;action=&#34;).append(&#34;up &#34;); break; case KeyEvent.ACTION_MULTIPLE: sb.append(&#34;action=&#34;).append(&#34;multi&#34;); break; } sb.append(&#34;|key=&#34;).append(event.getKeyCode()); sb.append(&#34;|scan=&#34;).append(event.getScanCode()); sb.append(&#34;|meta=&#34;).append(event.getMetaState()); sb.append(&#34;|repeat=&#34;).append(event.getRepeatCount()); return sb.toString(); }"},{url:"/p/p4y55j2/",title:"Androidメモ: ソフトウェアキーボードを常に表示する (setSoftInputMode)",date:"2014-07-28T00:00:00+09:00",body:"Androidメモ: ソフトウェアキーボードを常に表示する (setSoftInputMode) Android アプリケーションでソフトウェアキーボードを常に表示したいときは次のように実装します。 方法 1) Activity の onCreate() で設定する public class MainActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE); } } 方法 2) Dialog 表示時に設定 final AlertDialog dialog = ...; dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);"},{url:"/p/yujway4/",title:"GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages)",date:"2014-07-14T00:00:00+09:00",body:"GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages) GitHub Pages という機能を使用すると、GitHub 上で Web サイトをホスティングできます。GitHub を開発用にだけ使うのであれば、リポジトリだけ公開しておけばよいのですが、作成したソフトウェアを配布したり、マニュアルを公開するのであれば、GitHub Pages 上で通常の Web サイトとして見えるようにしておくのがよいでしょう。 プロジェクトの Web サイトを作る 各プロジェクト用の GitHub Pages は非常に簡単に作成できます。 各リポジトリに gh-pages という名前のブランチを作り、そこに Web サイトのコンテンツ（index.html など）をコミットすれば、そのプロジェクト用の Web サイトとして見えるようになります。 https://&lt;username&gt;.github.io/&lt;repository&gt;/ Organization を作成している場合は、上記の &lt;username&gt; のところを、&lt;organization&gt; と読み替えてください。 ☝️ GitHub Pages の非公開化 プライベートリポジトリで GitHub Pages (gh-pages) を作ったとしても、Web サイトはインターネット上に公開されてしまうことに注意してください。 プライベートな情報提供サイトを作る場合は、リポジトリの README.md や Wiki を活用するか、独自で Web サーバを立ち上げる必要があります。 あるいは、GitHub Enterprise Cloud という高額なプランを導入すれば、非公開の GitHub Pages を作成することができます。 参考: Changing the visibility of your GitHub Pages site - GitHub Enterprise Cloud Docs ユーザ用、組織用の Web サイトを作る GitHub Pages では、リポジトリごとの Web サイトだけではなく、ユーザや組織用のトップサイトを作成することも可能です。 その場合は、&lt;username&gt;.github.io という名前のリポジトリを作成し、その main ブランチにコンテンツを格納してください（この場合はリポジトリが Web サイト専用になるので、gh-pages ブランチを作る必要がありません）。 下記のようなアドレスで参照できるようになります。 https://&lt;username&gt;.github.io/ GitHub Pages のコンテンツ生成の仕組み &ndash; Jekyll GitHub Pages は内部では Jekyll が動作しており、Markdown 形式で記事を記述したり、ブログのようなものも簡単に作成することができるようになっています。 Jekyll 用のフォーマット（先頭に YAML 形式のヘッダを付ける）で記述したファイルを作成するだけで、自動的に GitHub Pages 側で変換処理が行われ、Web サイトとして表示できるようになります。 Jekyll でどんなことができるかは、Jekyll 本家のサイトを参照しましょう。"},{url:"/p/4zwxw7q/",title:"Jenkins サーバの設定ファイルの場所",date:"2014-07-08T00:00:00+09:00",body:"Jenkins サーバの設定ファイルの場所 *.deb パッケージでインストールした場合 /etc/defasult/jenkins *.rpm パッケージでインストールした場合 /etc/sysconfig/jenkins Windows インストーラ（msi パッケージ）でインストールした場合 インストールディレクトリの jenkins.xml"},{url:"/p/iscaefa/",title:"お試しインスタンスとして Jenkins サーバを起動する (jenkins.war)",date:"2014-07-08T00:00:00+09:00",body:"お試しインスタンスとして Jenkins サーバを起動する (jenkins.war) 下記のように、JENKINS_HOME や HTTP ポート番号を指定して jenkins.war を起動することで、お試しの Jenkins サーバを起動することができます。 未知のプラグインのインストールを試してみるときや、設定を大きく変更してみたいときに便利です。 $ java -DJENKINS_HOME=/path/to/jenkins_home jenkins.war --httpPort=8081"},{url:"/p/q4n32h5/",title:"CPD でコードクローンを発見する",date:"2014-06-29T00:00:00+09:00",body:"CPD でコードクローンを発見する CPD とは PMD (A source code analyzer) という静的解析ツールのパッケージに含まれている cpd コマンド (Copy/Paste Detector) を使用すると、ソースコードに含まれているコードクローンを簡単に探し出すことができます。 プロジェクトの規模が数万行を超えてきたときに、リファクタリングすべき箇所を探すための強い味方になります。 下記のように、主要な言語はほとんど対応しています。 C++ C# Fortran Go Java JavaScript JSP PHP PL/SQL Ruby XML and XSL インストール PMD/CPD のダウンロード https://pmd.github.io/ からアーカイブ（pmd-bin-5.2.0.zip など）をダウンロードして、適当なディレクトリに展開します。 Windows の場合 Windows の場合は、展開したディレクトリにある bin ディレクトリにパスを通しておけば、どこからでも cpd コマンドを実行できるようになります。 Linux の場合 Linux の場合は、bin/run.sh という、統一された入口として使用するシェルスクリプトが用意されているので、デフォルトでは bin/run.sh cpd のように実行しなければいけません。cpd というコマンドとして alias 定義しておくのがよいでしょう。 .bash_profile alias cpd=&#39;/path/to/pmd-bin/bin/run.sh cpd&#39; 実行方法 下記のように実行すると、src_dir ディレクトリ以下のソースコードに関して、コードクローンの検出を行います。 C:\\&gt; cpd --minimum-tokens 50 --files src_dir &gt; results.txt オプションの --minimum-tokens の値を小さくすると、クローン検出の閾値が下がるので、より多くの箇所を検出するようになります。 変数名や定数名の違いなどを吸収して検出するためには、--ignore-identifiers オプションを指定します。"},{url:"/p/qoaky8w/",title:"Gradle タスクの一覧を表示する (gradle tasks)",date:"2014-06-17T00:00:00+09:00",body:"Gradle タスクの一覧を表示する (gradle tasks) Gradle で実行可能なタスクの一覧は tasks タスクを走らせることで確認できます。 $ gradle -q tasks ------------------------------------------------------------ All tasks runnable from root project ------------------------------------------------------------ Build Setup tasks ----------------- init - Initializes a new Gradle build. [incubating] wrapper - Generates Gradle wrapper files. [incubating] Help tasks ---------- dependencies - Displays all dependencies declared in root project &#39;gradle&#39;. dependencyInsight - Displays the insight into a specific dependency in root project &#39;gradle&#39;. help - Displays a help message projects - Displays the sub-projects of root project &#39;gradle&#39;. properties - Displays the properties of root project &#39;gradle&#39;. tasks - Displays the tasks runnable from root project &#39;gradle&#39;. To see all tasks and more detail, run with --all. もう少し詳細に表示したい場合は、--all オプションを付けて tasks タスクを実行します。 下記の例では、apply plugin: 'java' したときのタスク一覧を確認しています。 $ gradle -q tasks --all ------------------------------------------------------------ All tasks runnable from root project ------------------------------------------------------------ Build tasks ----------- assemble - Assembles the outputs of this project. [jar] build - Assembles and tests this project. [assemble, check] buildDependents - Assembles and tests this project and all projects that depend on it. [build] buildNeeded - Assembles and tests this project and all projects it depends on. [build] classes - Assembles classes &#39;main&#39;. compileJava - Compiles Java source &#39;main:java&#39;. processResources - Processes resources &#39;main:resources&#39;. clean - Deletes the build directory. jar - Assembles a jar archive containing the main classes. [classes] testClasses - Assembles classes &#39;test&#39;. [classes] compileTestJava - Compiles Java source &#39;test:java&#39;. processTestResources - Processes resources &#39;test:resources&#39;. Build Setup tasks ----------------- init - Initializes a new Gradle build. [incubating] wrapper - Generates Gradle wrapper files. [incubating] Documentation tasks ------------------- javadoc - Generates Javadoc API documentation for the main source code. [classes] Help tasks ---------- dependencies - Displays all dependencies declared in root project &#39;gradle&#39;. dependencyInsight - Displays the insight into a specific dependency in root project &#39;gradle&#39;. help - Displays a help message projects - Displays the sub-projects of root project &#39;gradle&#39;. properties - Displays the properties of root project &#39;gradle&#39;. tasks - Displays the tasks runnable from root project &#39;gradle&#39;. Verification tasks ------------------ check - Runs all checks. [test] test - Runs the unit tests. [classes, testClasses] Rules ----- Pattern: build&lt;ConfigurationName&gt;: Assembles the artifacts of a configuration. Pattern: upload&lt;ConfigurationName&gt;: Assembles and uploads the artifacts belonging to a configuration. Pattern: clean&lt;TaskName&gt;: Cleans the output files of a task."},{url:"/p/a88r2ua/",title:"Gradle のタスクを定義する",date:"2014-06-17T00:00:00+09:00",body:"Gradle のタスクを定義する gradle コマンドを実行すると、カレントディレクトリにある build.gradle ビルドスクリプト（レシピ）を読み込み、そこに定義されているタスクを実行します。 下記は、hello というタスクを定義する例で、Excecution フェーズで Hello World と表示するように指定しています。 build.gradle task hello { doLast { println &#39;Hello World&#39; } } 具体的には、hello という名前の Task オブジェクト を作成し、Task#doLast() メソッドでタスクのアクションリストの末尾にアクションを追加する、ということをしています。 このように定義したタスクを実行するには、gradle コマンドの引数でタスク名を指定します。 $ gradle hello :hello Hello World BUILD SUCCESSFUL Total time: 2.527 secs コロンから始まる :hello という行が、hello タスクを実行していることを示しています。 gradle コマンドを実行するときに、-q あるいは --quiet オプションを指定すると、エラー以外のログ出力を抑制できます。 $ gradle -q hello Hello World ☝️ （コラム）leftShift は deprecated Gradle 4.x までは、タスクの Configuration クロージャ内に doLast アクションを定義する代わりに、次のようなショートカット記法が使えました。 task hello &lt;&lt; { println &#39;Hello World&#39; } Gradle 5.x 以降はこのような記述方法は deprecated になっているため、次のようなエラーが出ます。 Could not find method leftShift() しょうがないので doLast を使いましょう。 task hello { doLast { println &#39;Hello World&#39; } }"},{url:"/p/bvinwfk/",title:"Gradle で Java プロジェクトをビルドする",date:"2014-06-08T00:00:00+09:00",body:"Gradle で Java プロジェクトをビルドする Java プラグインを適用すると、Java のプロジェクトをビルドするためのタスクが定義されます。 Java Plugin の説明 build.gradle apply plugin: &#39;java&#39; Java プロジェクトのディレクトリ構成 Java プラグインはデフォルトで、以下のようなディレクトリ構造でソースコードが格納されていることを期待して動作します。 src/main/java &hellip; 製品用の Java ソースコード src/main/resources &hellip; 製品用のリソースファイル src/test/java &hellip; ユニットテスト用の Java ソースコード src/test/resources &hellip; ユニットテスト用のリソースファイル 例えば、com.example.Main クラスのソースコードは下記のようなパスに格納します（build.gradle ファイルがあるディレクトリからの相対パスです）。 src/main/java/com/example/Main.java package com.example; public class Main { public static void main(String... args) { System.out.println(&#34;Hello&#34;); } } java プラグインを使ったビルドとプログラムの実行 Java プラグインが提供する build タスクを実行することにより、Java プロジェクトのビルドを行うことができます。 $ gradle build ... BUILD SUCCESSFUL ビルドが成功すると、build ディレクトリに生成物が出力されます。 例えば、クラスファイルは build/classes/main や build/classes/test ディレクトリ以下に出力されます。 このディレクトリにクラスパスを通せば、Java プログラムを実行することができます。 $ java -cp build/classes/main com.example.Main Hello World また、build/libs 以下には、クラスファイルをアーカイブした JAR ファイルが格納されます。 JAR ファイルの名前は、デフォルトで &lt;プロジェクトのディレクトリ名&gt;.jar となります。 例えば、ディレクトリ名が sample の場合は、下記のように実行できることになります。 $ java -cp build/libs/sample.jar com.example.Main Hello World ちなみに、出力先された build ディレクトリは、java プラグインが提供する clean タスクで削除することができます。 $ gradle clean"},{url:"/p/zfc37zt/",title:"Gradle でデフォルトタスクを指定する (defaultTasks)",date:"2014-06-08T00:00:00+09:00",body:"Gradle でデフォルトタスクを指定する (defaultTasks) gradle コマンドではパラメータとしてタスク名を指定するのですが、パラメータを省略した場合に実行する デフォルトタスク を指定しておくこともできます。 下記のサンプルでは、hello タスクをデフォルトタスクとして指定しています。 build.gradle defaultTasks &#39;hello&#39; task hello { doLast { println &#39;Hello World&#39; } } 実行結果 $ gradle -q # gradle -q hello と同じ結果になる Hello World デフォルトタスクはカンマで区切って、複数指定することができます。 デフォルトタスクを複数指定した場合、指定した順番に実行されます。 build.gradle defaultTasks &#39;hello1&#39;, &#39;hello2&#39; task hello1 { doLast { println &#39;Hello1&#39; } } task hello2 { doLast { println &#39;Hello2&#39; } } 実行結果 $ gradle -q # gradle -q hello1 hello2 と同じ結果になる Hello1 Hello2"},{url:"/p/o7yqmcx/",title:"Gradle 実行時の 3 つのフェーズ (initialization, configuration, execution)",date:"2014-06-08T00:00:00+09:00",body:"Gradle 実行時の 3 つのフェーズ (initialization, configuration, execution) 3 つのフェーズ Gradle によるビルドを実行するとき、内部では下記のような 3 つのフェーズに分けてビルドが実行されていきます。 Initialization フェーズ Configuration フェーズ Execution フェーズ (1) Initialization フェーズ マルチプロジェクトにおけるプロジェクトの依存関係が解決され、プロジェクトのビルド順序が決められるフェーズです。 サブプロジェクトの構成は、トップレベルのディレクトリに置かれる settings.gradle ファイルで定義されます（Gradle の内部では、このファイルを基に Settings オブジェクトが生成されています）。 settings.gradle include &#39;subproject1&#39; include &#39;subproject2&#39; また、プロジェクトごとに Gradle 内部で Project インスタンスが生成されています（マルチプロジェクトなビルド構成であれば、複数の Project インスタンスが生成されます）。 プロジェクトの依存関係は、各プロジェクトの dependencies ブロック内で定義されます。 dependencies { compile project(&#39;:subproject&#39;) ... } (2) Configuration フェーズ すべてのプロジェクトの build.gradle が処理され、すべてのタスクの依存関係を認識するフェーズです。 タスクの依存関係は、下記のように dependsOn プロパティで指定されます。 task task2(dependsOn: task1) &lt;&lt; { println &#39;Hello task2&#39; } 上記の例では依存タスクを task1 というオブジェクトで指定していますが、'task1' のように、文字列でタスク名を指定することもできます。 文字列でタスク名を指定することにより、その時点でまだ定義されていないタスクを指定することができます。 Configuration フェーズでは、すべてのタスク定義を走査するため、最終的にはすべての依存関係が問題なく解決されます（逆に、Configuration フェーズ終了時に未解決なタスクがあるとエラーになります）。 Gradle の処理系内部では、依存グラフ (dependency graph) が生成されています。 (3) Execution フェーズ 実際にどのタスクを実行すべきかを判断し、タスクの実行を行うフェーズです。 gradle コマンドに渡したタスク名や、実行時のカレントディレクトリによってどのタスクを実行するかが変化します。 振る舞いを調べてみる 次のようなビルドファイルを作成すると、3 つのフェーズがどのような順番で実行されていくかを確認することができます。 settings.gradle println &#39;Initialization&#39; build.gradle println &#39;Configuration 1&#39; task hello1 { println &#39;Configuration 2&#39; doLast { println &#39;Execution (hello1)&#39; } println &#39;Configuration 3&#39; } println &#39;Configuration 4&#39; task hello2 { println &#39;Configuration 5&#39; doLast { println &#39;Execution (hello2)&#39; } println &#39;Configuration 6&#39; } println &#39;Configuration 7&#39; hello2 タスクを実行してみます。 実行結果 $ gradle -q hello2 Initialization Configuration 1 Configuration 2 Configuration 3 Configuration 4 Configuration 5 Configuration 6 Configuration 7 Execution (hello2) Configuration フェーズの実行は、単純に上から実行されていくことが分かります。"},{url:"/p/rcwaz54/",title:"git config で設定すべき一般的な設定項目のまとめ",date:"2014-06-04T00:00:00+09:00",body:"git config で設定すべき一般的な設定項目のまとめ Git を使い始める前の初期設定としては、多くの場合は、下記のような設定を行っておけばよいでしょう。 改行コードに関する設定部分は、自動変換するかしないかで、どの設定を行うかを判断してください。 ### コミット時のログ設定 $ git config --global user.name &#34;Taro Yamada&#34; $ git config --global user.email &#34;taro@example.com&#34; ### 便利設定 $ git config --global color.ui auto # コマンド出力に色を付ける $ git config --global core.editor nvim # git commit 時のエディタ ### 文字化け防止 (git diff) $ git config --global core.pager &#34;LESSCHARSET=utf-8 less&#34; ### 文字化け防止 (git status) $ git config --global core.quotepath false ### 改行コードの自動変換なし $ git config --global core.autocrlf false ### 改行コードの自動変換あり（Windows の場合） $ git config --global core.autocrlf true # ローカルの改行コード CR+LF $ git config --global core.safecrlf true # 余計な改行コード変換を抑制 $ git config --global core.whitespace cr-at-eol # git diff 時の ^M を抑制 ### 改行コードの自動変換あり（Mac/Linux の場合） $ git config --global core.autocrlf input # ローカルの改行コード LF $ git config --global core.safecrlf true # 余計な改行コード変換を抑制 参考 コミット時に使用するユーザ名とメールアドレスを設定する (user.name, user.email) コミット、チェックアウト時に改行コードを自動変換する (core.autocrlf, core.safecrlf) コミット時にコメント記述に使用するエディタを設定する (core.editor) Git コマンドの出力をカラフルにする (color.ui)"},{url:"/p/uek4bb2/",title:"Windows の git diff で改行コードが ^M で表示される問題を解決する (core.whitespace)",date:"2014-06-04T00:00:00+09:00",body:"Windows の git diff で改行コードが ^M で表示される問題を解決する (core.whitespace) Windows のターミナル環境において、改行コードが CR+LF のファイルを編集している場合、 $ git config --global color.ui auto $ git config --system color.diff auto のように、git diff の出力がカラフルに表示されるようになっていると、行末の CR がうまく処理できず、^M と表示されてしまうことがあります。 このような場合は、次のように core.whitespace 設定を行っておくと ^M の表示を抑制できます。 $ git config --global core.whitespace cr-at-eol"},{url:"/p/rcaip63/",title:"Python の関数で可変長引数を扱う (*args, **kwargs)",date:"2014-06-02T00:00:00+09:00",body:"Python の関数で可変長引数を扱う (*args, **kwargs) 可変長引数 関数に任意の数の引数を渡せるようにするには、パラメーター名の前にアスタリスク (*) を付けます。 下記の print_lines 関数には、任意の数（0 個以上）の文字列を渡すことができます。 def print_lines(*lines: str) -&gt; None: for line in lines: print(line) # 使用例 print_lines(&#34;Hello&#34;, &#34;World&#34;, &#34;Python&#34;) 実行結果 Hello World Python 関数内では、lines パラメーターは文字列型 (str) のタプルとして参照できます。 任意のキーワード引数を渡せるようにする パラメーター名の前に 2 つのアスタリスク (**) を付けると、任意のキーワード引数を受け取れる関数になります。 パラメーター名には慣例としてよく kwargs が使われます（keyword arguments の略）。 def process_data(**kwargs) -&gt; None: for key, value in kwargs.items(): print(f&#34;{key}: {value}&#34;) # 使用例 process_data(name=&#34;John&#34;, age=30, city=&#34;New York&#34;) process_data(subject=&#34;Python&#34;, level=&#34;Intermediate&#34;, duration=5) 実行結果 name: John age: 30 city: New York subject: Python level: Intermediate duration: 5 関数内では、kwargs パラメーターは辞書オブジェクトとして参照できます。 その他 可変長引数の伝播 可変長引数として受け取ったタプルや辞書オブジェクトを、可変長引数を受け取る別の関数に渡すときは、一度展開して渡す必要があります。 変数名の前に * や ** をつけると展開できます。 def foo(*args, **kwargs): print(args, kwargs) def bar(*args, **kwargs): foo(*args, **kwargs) # タプルや辞書オブジェクトは展開して渡す 各種引数の組み合わせ 次のように、各種引数を組み合わせて定義することもできます。 ただし、可変長引数の後ろにある引数は、キーワード引数の形で指定して呼び出す必要があります。 これは、位置引数の終わり（下記例では &quot;Alias-2&quot;）が可変長引数に渡す引数の終わりと判断されるからです。 def show_book_info(title: str, *aliases: str, note: str, **kwargs) -&gt; None: print(f&#34;Title: {title}&#34;) for alias in aliases: print(f&#34;Alias: {alias}&#34;) print(f&#34;Note: {note}&#34;) for key, value in kwargs.items(): print(f&#34;{key}: {value}&#34;) # 使用例 show_book_info(&#34;Title&#34;, &#34;Alias-1&#34;, &#34;Alias-2&#34;, note=&#34;Note&#34;, tag1=&#34;A&#34;, tag2=&#34;B&#34;) 実行結果 Title: Title Alias: Alias-1 Alias: Alias-2 Note: Note tag1: A tag2: B 参考 Python の関数をキーワード引数を使って呼び出す"},{url:"/p/5x6qgkx/",title:"Gradle のプロキシを設定する (gradle.properties)",date:"2014-06-01T00:00:00+09:00",body:"Gradle のプロキシを設定する (gradle.properties) gradle コマンド実行時に Maven リポジトリにアクセスしたり、Gradle Wrapper をインストールするためのアーカイブをダウンロードしたりする際にネットワークアクセスが発生します。 これらのアクセスをプロキシ経由で行う必要がある場合は、gradle.properties ファイルにプロキシの設定を記述します。 用途 設定ファイル プロジェクトごとの設定 &lt;project&gt;/gradle.properties ユーザごとの設定 (macOS/Linux) $HOME/.gradle/gradle.properties ユーザごとの設定 (Windows) %USERPROFILE%/.gradle/gradle.properties 以下のように設定します。 gradle.properties systemProp.http.proxyHost=&lt;ホスト&gt; systemProp.http.proxyPort=&lt;ポート番号&gt; systemProp.http.proxyUser=&lt;ユーザ&gt; systemProp.http.proxyPassword=&lt;パスワード&gt; systemProp.https.proxyHost=&lt;ホスト&gt; systemProp.https.proxyPort=&lt;ポート番号&gt; systemProp.https.proxyUser=&lt;ユーザ&gt; systemProp.https.proxyPassword=&lt;パスワード&gt; 設定例 systemProp.http.proxyHost=proxy.example.com systemProp.http.proxyPort=8080 systemProp.https.proxyHost=proxy.example.com systemProp.https.proxyPort=8080"},{url:"/p/6qdfg4d/",title:"Gradle をインストールする (macOS/Windows)",date:"2014-06-01T00:00:00+09:00",body:"Gradle をインストールする (macOS/Windows) macOS への Gradle インストール ここでは、GVM (Groovy enVironment Manager) を使って gradle コマンドをインストールします。 GVM を使うと、複数バージョンの Gradle を管理することができます。 GVM のインストール $ curl -s get.gvmtool.net | bash GVM で gradle のインストール $ gvm install gradle 動作確認 $ gradle --version Windows への Gradle インストール https://gradle.org/install/ から gradle-1.12-bin.zip などをダウンロードして、適当なディレクトリに配置します。 gradle コマンドを実行するには、java コマンドを実行できるようになっている必要があります。 任意のバージョンの java コマンドを使用するには、JAVA_HOME 環境変数を設定しておきます。 C:\\&gt; set JAVA_HOME=C:\\Program Files\\Java\\jdk1.8.0_05 （binまでは含めないことに注意） gradle コマンドを任意のディレクトリから実行できるように、PATH を通しておきます。 C:\\&gt; set PATH=%PATH%;C:\\app\\gradle-1.12\\bin 実行テスト C:\\&gt; gradle -v ------------------------------------------------------------ Gradle 1.12 ------------------------------------------------------------ Build time: 2014-04-29 09:24:31 UTC Build number: none Revision: a831fa866d46cbee94e61a09af15f9dd95987421 Groovy: 1.8.6 Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013 Ivy: 2.2.0 JVM: 1.8.0_05 (Oracle Corporation 25.5-b02) OS: Windows 7 6.1 amd64"},{url:"/p/6qdfg4d/",title:"Gradle をインストールする (macOS/Windows)",date:"2014-06-01T00:00:00+09:00",body:"Gradle をインストールする (macOS/Windows) macOS への Gradle インストール ここでは、GVM (Groovy enVironment Manager) を使って gradle コマンドをインストールします。 GVM を使うと、複数バージョンの Gradle を管理することができます。 GVM のインストール $ curl -s get.gvmtool.net | bash GVM で gradle のインストール $ gvm install gradle 動作確認 $ gradle --version Windows への Gradle インストール https://www.gradle.org/downloads から gradle-1.12-bin.zip などをダウンロードして、適当なディレクトリに配置します。 gradle コマンドを実行するには、java コマンドを実行できるようになっている必要があります。 任意のバージョンの java コマンドを使用するには、JAVA_HOME 環境変数を設定しておきます。 C:\\&gt; set JAVA_HOME=C:\\Program Files\\Java\\jdk1.8.0_05 （binまでは含めないことに注意） gradle コマンドを任意のディレクトリから実行できるように、PATH を通しておきます。 C:\\&gt; set PATH=%PATH%;C:\\app\\gradle-1.12\\bin 実行テスト C:\\&gt; gradle -v ------------------------------------------------------------ Gradle 1.12 ------------------------------------------------------------ Build time: 2014-04-29 09:24:31 UTC Build number: none Revision: a831fa866d46cbee94e61a09af15f9dd95987421 Groovy: 1.8.6 Ant: Apache Ant(TM) version 1.9.3 compiled on December 23 2013 Ivy: 2.2.0 JVM: 1.8.0_05 (Oracle Corporation 25.5-b02) OS: Windows 7 6.1 amd64"},{url:"/p/eq3tw6z/",title:"Androidメモ: Xperia Tablet Z に adb 接続する",date:"2014-05-30T00:00:00+09:00",body:"Androidメモ: Xperia Tablet Z に adb 接続する まずは、下記と同様に「開発者向けオプション」を有効にし、「USB デバッグ」を有効にしておきます。 Nexus7 (2013) に adb 接続する Windows への ADB ドライバのインストール Xperia には、端末側に &ldquo;PC Companion software&rdquo; というものが入っていて、USB 経由で PC 側にインストールすることができます。 同時に ADB ドライバもインストールされます。 Xperia の「Settings =&gt; Xperia =&gt; USB Connectivity =&gt; Install PC Companion」にチェックを入れておく。 USB で PC と接続すると、Xperia 側にインストール確認のダイアログが表示されるので、&ldquo;Install&rdquo; を選択。 PC 側でインストール用のドライブが開くのでアイコンからインストーラを起動 (Startme.exe)。 最初に ADB 接続するときは、端末を MTP (Media transfer mode) から、MSC (Mass storage mode) に変えておかないと adb devices で認識しないことがあるみたいです。 Xperia の「Settings =&gt; Xperia =&gt; USB Connectivity =&gt; USB connection mode」を選択。 MSC (Mass storage mode) を選択。 あとは、以下のように接続を確認できます。 $ adb kill-server $ adb start-server $ adb devices"},{url:"/p/af7q7n3/",title:"Git 設定のスコープ (local/global/system) を理解する",date:"2014-05-25T00:00:00+09:00",body:"Git 設定のスコープ (local/global/system) を理解する Git 設定の 3 つのスコープ git config による設定のスコープは 3 種類あり、スコープが狭くなるほど参照時の優先度は高くなります。 下記はそれぞれのスコープでの設定方法を、優先度の高い順に示しています。 カッコの中のファイル名は、コマンドを実行したときの設定値の保存先です。 $ git config --local ... # 各リポジトリごとの設定 (&lt;repo&gt;/.git/config)（優先度:高） $ git config --global ... # 現在のユーザの共通設定 (~/.gitconfig) $ git config --system ... # システム内の共通設定 (/etc/gitconfig など)（優先度:低） 例えば、global 設定で user.name が Ichiro になっていても、local 設定が Jiro になっていれば、Jiro の方が優先的に使用されます。 プロジェクト（リポジトリ）ごとに固有の設定をする場合は、local なスコープで設定を行うとよいでしょう。 この場合、プロジェクトの作業ツリーのルートにある .git/config ファイルに設定が保存されます。 例えば、次のようにして local 設定の user.name と user.email を変更することができます。 $ git config --local user.name maku77 $ git config --local user.email maku77@example.com 上記コマンドを実行した後で、&lt;リポジトリ&gt;/.git/config ファイルを開くと次のように設定情報が保存されていることが分かります。 &lt;リポジトリ&gt;/.git/config（抜粋） [user] name = maku77 email = maku77@example.com 参考: Git の設定値がどのファイルで設定されているか調べる (config --show-origin) それぞれの設定ファイルをコマンドで開く (git config --edit) 各スコープの設定ファイルは、git config --edit コマンドで開くことができます。 $ git config --edit # リポジトリの設定ファイルを開く（local 設定） $ git config --edit --local # （同上） $ git config --edit --global # ユーザーの設定ファイルを開く（global 設定） $ git config --edit --system # システムの設定ファイルを開く（system 設定） 使用するエディタは、core.editor 設定や、GIT_EDITOR 環境変数などで指定できます。 参考: コミット時にコメント記述に使用するエディタを設定する (core.editor) Windows の場合のホームディレクトリ (USERPROFILE, HOME) global スコープの設定は、ユーザのホームディレクトリの .gitconfig ファイルに設定値が保存されますが、Windows の場合のホームディレクトリは、デフォルトで USERPROFILE 環境変数で取得できるディレクトリ（通常は C:\\Users\\&lt;ユーザー名&gt;）が使用されます。 C:\\&gt; echo %USERPROFILE% C:\\Users\\maku 例えば、上記の場合は C:\\Users\\maku が Git のホームディレクトリとして使用されるので、global スコープの設定は、C:\\Users\\maku\\.gitconfig に保存されます。 ただし、HOME 環境変数が設定されている場合は、そちらのディレクトリがホームディレクトリとして使用されます。"},{url:"/p/g3cj5mi/",title:"パッケージ管理ツールいろいろ",date:"2014-05-25T00:00:00+09:00",body:"パッケージ管理ツールいろいろ Mac OSX 用のパッケージ管理 ツール名 コマンド パッケージインストール先 メモ MacPorts port /opt/usr システムにインストールされているコマンドに依存しないようにパッケージ管理するため、依存関係が多いとインストールに時間がかかる。パッケージインストールには管理者権限が必要 (sudo)。 Homebrew brew /usr/local システムにインストールされているコマンドをなるべく使用するように動く。一般ユーザ権限でパッケージインストール可能。Ruby で実装されている。 Fink fink /sw Debian の apt をベースにしている。 Gentoo Prefix emerge ~/Gentoo Gentoo の portage をベースにしている。Mac OSX 専用ではない。管理者権限不要。 各言語のバージョン切り替え ツール名 コマンド 環境インストール先 メモ GVM (Groovy enVironment Manager) gvm ~/.gvm 複数バージョンの Groovy を切り替えて使用するためのツール（Gaiden/Groovy/Grails/Griffon/Gradle などの切り替えもサポート）。その名の通り、RVM にインスパイアされて作られた。 RVM (Ruby Version Manager) rvm ~/.rvm 複数バージョンの Ruby を切り替えて使用するためのツール。 各言語のモジュール（パッケージ）管理 ツール名 コマンド パッケージインストール先 メモ NPM (Node Package Manager) npm ./node_modules Node.js で使用するパッケージの管理ツール。Node をインストールすると一緒にインストールされる。 Python Package Index pip site-packages setuptools の easy_install を置き換えるもの。アンインストールなど簡単にできる。"},{url:"/p/x63is5h/",title:"（旧）GitHub のプランと GitHub ライクなツールの比較など（GitHub と GitLab の比較）",date:"2014-05-14T00:00:00+09:00",body:"（旧）GitHub のプランと GitHub ライクなツールの比較など（GitHub と GitLab の比較） GitHub Public repository と Private repository プラン GitHub は公開リポジトリのみであれば無料で使用できるが、非公開にするには有料。 10 repos で $25/month 20 repos で $50/month GitHub Enterprise（社内サーバ用） GitHub 社が提供している、GitHub の機能をまるごと含めた VM。 サーバは別途用意する必要あり。 社内で GitHub の機能を使ってコード管理したい場合などに有用。 若干高い。20 person で $5,000/year GitLab 特徴 一番メジャーなオープンソースの GitHub クローン 実装は Ruby on Rails. (+ PostgreSQL, Redis, Nginx, Unicorn, etc.) インストールは比較的容易。 Pull Request もどき有り (Merge Request)。ブランチ間のマージも可能。 LDAP 連携。ActiveDirectory 連携。 GitHub より便利なところ ユーザに対して Master 権限と Developer 権限を分けて設定することで、master ブランチへマージできる人を制限できる。これにより、チーム内開発において、トピックブランチを使用した開発を強制できるようになる（GitHub フローなど）。 MergeRequest のコメントで各ユーザが +1 と記述しておくと、MergeRequest のページにその合計数が表示される。これを利用して、「+3 溜まったらトピックブランチをマージしてよい」といった運用を行うことができる。 Gitorious 特徴 若干独自路線気味の GitHub クローン 実装は Ruby on Rails. インストール、サーバ管理に難あり（モジュール依存が多い）。 Pull Request もどき有り (Merge Request)。ブランチ間のマージ機能がないので、GitHub Flow のような開発方法は行えない（2014-05-14 現在）。 権限＆Roll制御。ユーザごとに push 可能なリポジトリを制御可能。"},{url:"/p/ubtbs9p/",title:"Python コードの実行時間を計測する (datetime.now)",date:"2014-05-01T00:00:00+09:00",body:"Python コードの実行時間を計測する (datetime.now) 下記は datetime モジュールを使って、Python コードの一部の実行時間を計測する例です。 main.py from datetime import datetime start = datetime.now() # ここに実行時間を計測したい処理を記述する print(datetime.now() - start) 実行結果 $ python3 main.py 00:00:01.547393"},{url:"/p/ijepy8e/",title:"Windows でパーミッションの違いで git diff が表示されてしまうのを防ぐ (core.filemode)",date:"2014-04-22T00:00:00+09:00",body:"Windows でパーミッションの違いで git diff が表示されてしまうのを防ぐ (core.filemode) Linux と Windows ではファイルのパーミッションの扱いが異なるので、Linux で作成したスクリプトファイル（パーミッション: 0755）を、Windows で git diff すると、パーミッションが 0644 に変わっているという結果が出てしまったりします。 これを防ぐには、Windows 側の git config で、core.filemode を false に設定します。 C:\\&gt; git config --global core.filemode false うまくいかない場合は、ローカルスコープの設定（リポジトリごとの設定）で core.filemode が true になっている可能性があります。 以下のように一度設定をクリアしてから行うとうまくいくはずです。 C:\\&gt; git config --local --unset core.filemode 参考: core.fileMode の説明 core.fileMode If false, the executable bit differences between the index and the working copy are ignored; useful on broken filesystems like FAT. See git-update-index(1). True by default."},{url:"/p/492mmkw/",title:"Androidメモ: TCP/IP で adb 接続する",date:"2014-04-08T00:00:00+09:00",body:"Androidメモ: TCP/IP で adb 接続する ADB を TCP/IP 接続に切り替える Android アプリ開発時に、ADB 接続を USB 経由ではなく LAN 経由での接続 (TCP/IP プロトコル）で行うようにする手順です。 Android 端末側の ADB デーモンを TCP/IP モードに切り替えないといけないので、この設定自体は USB 接続された状態で行う必要があります。 一度設定してしまえば、次回からは USB ケーブルは必要なくなります。 Android 端末側の「開発者向けオプション」を有効にして USB 接続する [設定] &gt; [デバイス情報] に移動して、[ビルド番号] を 7 回タップすると「開発者向けオプション」が有効になります。 （USB 接続された状態で）Android 端末側の ADB デーモンを TCP/IP 接続モードにする adb tcpip 5555 Android 端末の LAN 内の IP アドレスを確認しておく adb shell &quot;ip addr | grep inet&quot; （この時点で USB ケーブルは外して OK） PC から Android 端末のアドレスとポート番号を指定して TCP/IP で接続 adb connect 192.168.11.6:5555 USB 接続に戻したいときは、adb usb コマンドを実行します。 トラブルシューティング 以下のように offline といわれて接続できない場合は、 $ adb devices List of devices attached 192.168.11.6:5555 offline 端末側の USB デバッグモードを Off/On してみるとうまくいったりします。 端末の設定から、「開発者向けオプション」を開く 「USB デバッグ」のチェックを OFF =&gt; ON する adb コマンド郡を最初から実行し直す 参考 https://developer.android.com/guide/topics/connectivity/usb"},{url:"/p/sznjxob/",title:"Vim でXML/HTML の編集に便利なコマンド",date:"2014-03-31T00:00:00+09:00",body:"Vim でXML/HTML の編集に便利なコマンド XML や HTML ファイルを編集しているときは、c（置換）や、d（削除）コマンドの後ろに編集範囲を表す it や at を指定することで、素早い編集が可能になります。 下記は、置換コマンド c を実行するときに、様々な修正範囲を指定する例です。 コマンド 操作内容 修正前 修正後 cit 要素の内側を置換 &lt;b&gt;XXX&lt;/b&gt; &lt;b&gt;編集箇所&lt;/b&gt; cat 要素の全体を置換 &lt;b&gt;XXX&lt;/b&gt; 編集箇所 ci&lt; タグの内側を置換 &lt;b&gt;XXX&lt;/b&gt; &lt;編集箇所&gt;XXX&lt;/b&gt; ca&lt; タグの全体を置換 &lt;b&gt;XXX&lt;/b&gt; 編集箇所XXX&lt;/b&gt; ci&quot; 属性の内側を置換 &lt;div style=&quot;XXX&quot;&gt; &lt;div style=&quot;編集箇所&quot;&gt; ca&quot; 属性の全体を置換 &lt;div style=&quot;XXX&quot;&gt; &lt;div style=編集箇所&gt; 上記は部分的な置換を行いたい場合の例ですが、c というところを d に変えれば、指定した範囲を削除することができます。 これらのコマンドは、ファイルタイプが XML や HTML でない場合も動作します。"},{url:"/p/efmfnuy/",title:"Git でコミット、チェックアウト時に改行コードを自動変換する (core.autocrlf, core.safecrlf)",date:"2014-03-21T00:00:00+09:00",body:"Git でコミット、チェックアウト時に改行コードを自動変換する (core.autocrlf, core.safecrlf) Git の設定 (git config) で、core.autocrlf や core.safecrlf を設定しておくと、コミットやチェックアウト時に改行コードを自動変換することができます。 変換設定として、下記のような設定を行うことができます。 core.autocrlf false: コミット時、チェックアウト時に改行コードの変換を行わない true: コミット時に CRLF→LF の変換を行い、チェックアウト時に LF→CRLF の返還を行う。 input: コミット時に CRLF→LF の変換を行い、チェックアウト時には変換を行わない。 core.safecrlf true: ファイル内に複数の改行コードが混じっている場合に自動変換を行わない。 おすすめの設定は以下の通りです。 このように設定しておくと、Git サーバー側では LF で統一して管理され、チェックアウト後は各 OS の標準的な改行コード（Windows は CRLF、macOS は LF）でファイルを扱えます。 Windows の場合 $ git config --global core.autocrlf true # コミット時: CRLF=&gt;LF チェックアウト時: LF=&gt;CRLF $ git config --global core.safecrlf true # ファイル内に複数の改行コードが混じっている場合に自動変換をしない $ git config --global core.whitespace cr-at-eol # git diff 時の ^M を抑制 macOS/Linux の場合 $ git config --global core.autocrlf input # コミット時: CRLF=&gt;LF チェックアウト時: 変換なし $ git config --global core.safecrlf true # ファイル内に複数の改行コードが混じっている場合に自動変換をしない 改行コード関連の変換を一切行ってほしくない場合は、単純に core.autocrlf を false に設定します。 複雑な構成管理を行っている環境では、結局この設定が一番安全だったりします。 改行変換を一切行わない設定 $ git config --global core.autocrlf false # 改行コードの自動変換をしない"},{url:"/p/9m96xqi/",title:"Node.jsメモ: package.json による依存パッケージの管理方法まとめ",date:"2014-03-18T00:00:00+09:00",body:"Node.jsメモ: package.json による依存パッケージの管理方法まとめ Node.js アプリケーションが使用する依存パッケージの情報は、package.json というファイルに記述します。 package.json ファイルのひな型を生成する (npm init) 下記のコマンドを実行すると、対話形式で package.json ファイルを作成することができます。 $ npm init 何も入力せずに Enter を連打していくと、以下のようなファイルが生成されます。 package.json { &#34;name&#34;: &#34;sample&#34;, &#34;version&#34;: &#34;0.0.0&#34;, &#34;description&#34;: &#34;&#34;, &#34;main&#34;: &#34;index.js&#34;, &#34;scripts&#34;: { &#34;test&#34;: &#34;echo \\&#34;Error: no test specified\\&#34; &amp;&amp; exit 1&#34; }, &#34;repository&#34;: &#34;&#34;, &#34;author&#34;: &#34;&#34;, &#34;license&#34;: &#34;BSD&#34; } すでにカレントディレクトリに package.json がある場合でも、npm init は、単純な上書きはしないで、足りないプロパティだけ補ってくれます。 副次的な作用として、フォーマットの整形にも使えます。 最小限の package.json Node.js アプリケーションのマニフェストファイルである package.json には、最低限以下のような情報を記述しておきます。 package.json { &#34;name&#34;: &#34;my-app&#34;, &#34;version&#34;: &#34;0.0.1&#34;, &#34;private&#34;: true, &#34;dependencies&#34;: { &#34;express&#34;: &#34;3.2.x&#34;, &#34;jade&#34;: &#34;*&#34; } } アプリの名前 (name)、バージョン (version)、npm registry に公開しないこと (&quot;private&quot;: true)、依存するモジュール (dependencies) などを記載しています。 依存パッケージは dependencies プロパティで指定する package.json ファイルの dependencies プロパティには、現在開発中の Node パッケージ（アプリケーション）が依存するパッケージを列挙しておくことができます。 下記の例では、このパッケージ（アプリ）を使用するには、request パッケージと request-promise パッケージが必要であることを示しています（バージョンの指定方法は後述）。 package.json { &#34;name&#34;: &#34;myapp&#34;, // ... &#34;dependencies&#34;: { &#34;request&#34;: &#34;^2.88.0&#34;, &#34;request-promise&#34;: &#34;^4.2.2&#34; } } カレントディレクトリにこの package.json ファイルがある状態で、下記のように実行すると、dependencies プロパティに列挙された依存パッケージが node_modules ディレクトリに自動的にインストールされます。 $ npm install 正確には、devDependencies プロパティに列挙された依存パッケージも一緒にインストールされます（詳細は後述）。 バージョンの指定方法 バージョンの指定方法にはいろいろありますが、よく使われるのは下記のような指定方法です。 1.2.3 指定したバージョンをインストールします。 &gt;=1.2.3 &lt;1.3.0 指定した範囲のうち最新のものをインストールします。 1.2.x x の位置以下のレベルのバージョンは問わずにインストールします。 1.2.x → &gt;=1.2.0 &lt; 1.3.0 1.x → &gt;=1.0.0 &lt;2.0.0 ^1.2.3 後方互換性のある（だろうと思われる）バージョンのうち、最新のバージョンをインストールします。 オススメの指定方法です。 npm install --save &lt;pkg&gt; でパッケージをインストールした場合、このバージョン指定方法で package.json の dependencies プロパティの値が更新されます。 major、minor、patch レベルのバージョンを左から見て、最初に 0 じゃない数値がみつかったらそこのバージョンを固定し、それより下のレベルのバージョンが更新されます。 ^1.2.3 → &gt;=1.2.3 &lt;2.0.0 ^0.2.3 → &gt;=0.2.3 &lt;0.3.0 ^0.0.3 → &gt;=0.0.3 &lt;0.0.4 ^1.2.3-beta.2 → &gt;=1.2.3-beta.2 &lt;2.0.0 （1.2.3 も含む） ^0.0.3-beta → &gt;=0.0.3-beta &lt;0.0.4 （0.0.3 も含む） ^1.2.x → &gt;=1.2.0 &lt;2.0.0 ^0.0.x → &gt;=0.0.0 &lt;0.1.0 ^0.0 → &gt;=0.0.0 &lt;0.1.0 ^1.x → &gt;=1.0.0 &lt;2.0.0 ^0.x → &gt;=0.0.0 &lt;1.0.0 ちなみに大文字の X でも OK。 ~1.2.3 1.2.3 とバージョン固定で指定する方法に似ていますが、下位レベルの更新だけを受け入れます。 つまり、軽微な変更だけを許可する指定方法です。 minor レベルのバージョンが指定されている場合は、patch レベルのバージョン更新のみを許可します。 ~1.2.3 → &gt;=1.2.3 &lt;1.3.0 ~0.2.3 → &gt;=0.2.3 &lt;0.3.0 ~1.2 → &gt;=1.2.0 &lt;1.3.0 （1.2.x と同じ） ~0.2 → &gt;=0.2.0 &lt;0.3.0 （0.2.x と同じ） ~1.2.3-beta.2 → &gt;=1.2.3-beta.2 &lt;1.3.0 （1.2.3 も含む） major レベルのバージョンしか指定されていない場合は、minor レベル以下のバージョン更新を許可します。 ~1 → &gt;=1.0.0 &lt;2.0.0 （1.x と同じ） ~0 → &gt;=0.0.0 &lt;1.0.0 （0.x と同じ） * or &quot;&quot; どのバージョンでも OK。 ようするに必ず最新バージョンのパッケージをインストールするという指定です。 dependencies プロパティと devDependencies プロパティ 開発時（テスト時）のみ使用するパッケージの依存関係は、dependencies プロパティではなく、devDependencies プロパティに記述します。 dependencies プロパティの方には、そのパッケージ（やアプリ）を使用するユーザ環境で必要なパッケージのみを列挙してください。 パッケージそのものの開発者は、ローカルディレクトリに package.json ファイルがある状態で、次のようなコマンドを実行して依存パッケージを一括インストールするはずです。 この場合は、dependencies プロパティに書かれた依存モジュールに加え、devDependencies プロパティに書かれた依存モジュールも一緒にインストールされます。 dependencies と devDependencies に書かれた依存パッケージがインストールされる $ npm install dependencies プロパティに列挙された依存モジュールのみをインストールしたい場合は、下記のように --production オプションを使用します。 dependencies に書かれた依存パッケージのみがインストールされる $ npm install --production パッケージのインストール時に package.json を更新する npm install コマンドを使ってパッケージをインストールするときに、--save オプションを付加すると、package.json の dependencies プロパティの記述も更新することができます。 package.json の dependencies プロパティに追加 $ npm install --save &lt;pkg&gt; 開発のみに使用するパッケージの依存情報 (devDependencies) を追加するときは、--save オプションの代わりに --save-dev オプション を使用します。 package.json の devDependencies プロパティに追加 $ npm install --save-dev &lt;pkg&gt; ☝️ --save は省略可能 npm 5.0.0 以降では --save オプションがデフォルトで有効になっているため、省略しても同じ効果があります。 --save-dev オプションは引き続き明示的な指定が必要です。 package.json の書式、説明を確認する (npm help json) Node パッケージに関する情報（モジュールの名前や説明、依存パッケージなどの情報）は、package.json というファイルに記述します。 以下のコマンドで、package.json の書き方のヘルプを見ることができます（Web ブラウザ上で表示されます）。 $ npm help json 表示される内容は、下記のサイトのものと同様です。 https://docs.npmjs.com/files/package.json 参考 package.json - dependencies package.json ファイルの dependencies プロパティに関する説明。 npm-semver - The semantic versioner for npm npm コマンドは、この semver というモジュールを使って、バージョン情報をパースしています。"},{url:"/p/6qsndck/",title:"Androidベンダー向けメモ: libhardware.so が hardware サポートライブラリをロードする仕組み",date:"2014-01-29T00:00:00+09:00",body:"Androidベンダー向けメモ: libhardware.so が hardware サポートライブラリをロードする仕組み Android の hardware/libhardware/hardware.c で定義されている、hw_get_modules() の仕組みの説明です。 hw_get_module() が呼び出されると、以下のパスの .so ファイルを探してロードしようとします。 /vendor/lib/hw/&lt;ライブラリ名&gt;.&lt;プロパティ値&gt;.so /system/lib/hw/&lt;ライブラリ名&gt;.&lt;プロパティ値&gt;.so &lt;ライブラリ名&gt; は hw_get_module() で指定した名前です。 &lt;プロパティ値&gt; は以下のシステムプロパティ値が順番にセットされます（コメントの例は Nexus7 (2013) の場合）。 ro.hardware # 例: &#34;flo&#34; ro.product.board # 例: &#34;flo&#34; ro.board.platform # 例: &#34;msm8960&#34; ro.arch # 例: &#34;&#34; 例えば、Nexus7(2013) で、hw_get_module(&quot;power&quot;, ...) とすると、/system/lib/hw/power.msm8960.so がロードされます（内部で dlopen() される）。 どのシステムプロパティ値との組み合わせでもライブラリを見つけられない場合は、以下のデフォルトファイルがロードされます。 /system/lib/hw/&lt;ライブラリ名&gt;.default.so デフォルトファイルも見つからない場合は、hw_get_module() は単純に -ENOENT を返して終了します。"},{url:"/p/nw89tw2/",title:"Vim で編集中のファイルを印刷する (hardcopy)",date:"2014-01-27T00:00:00+09:00",body:"Vim で編集中のファイルを印刷する (hardcopy) Vim で印刷する 以下のように実行すると、OS の印刷機能を使って現在開いているファイルを印刷することができます。 :hardcopy 印刷する範囲を指定したい場合は、ビジュアルモード (Shift-v) で行選択してから上記を実行します。 Vim の印刷設定 Vim のオプション設定で、印刷時のヘッダー出力などの設定を行うことができます。 詳しくは、下記のようにしてヘルプを参照してみてください。 :help printdevice :help printencoding :help printheader :help printfont :help printoptions printoptions は、次のようにいろいろな設定を組み合わせて指定します。 例: 長い行を折り返し、行番号付き、横向きで印刷 :set printoptions=wrap:y,number:y,portrait:n 例: B5 サイズで、縦向き、両面印刷（長辺閉じ） :set printoptions=paper:B5,portrait:y,duplex:long 例: A3 サイズで、横向き、両面印刷（短辺閉じ） :set printoptions=paper:A3,portrait:n,duplex:short"},{url:"/p/8xk6jnw/",title:"Vim のキーマップ例: ショートカットキーで日時を挿入する",date:"2014-01-27T00:00:00+09:00",body:"Vim のキーマップ例: ショートカットキーで日時を挿入する ショートカットキーで strftime 関数を実行する Vim で以下の設定をしておくと、ショートカットキーで 2014-01-27 のような本日の日付を挿入することができます。 ここでは、Ctrl-D → Ctrl-D というキーコンビネーションに割り当てていますが、任意の組み合わせに変更することができます。 ~/.vimrc（Ctrl-D Ctrl-D で日付を挿入） imap &lt;silent&gt; &lt;C-D&gt;&lt;C-D&gt; &lt;C-R&gt;=strftime(&#34;%Y-%m-%d&#34;)&lt;CR&gt; nmap &lt;silent&gt; &lt;C-D&gt;&lt;C-D&gt; &lt;ESC&gt;i&lt;C-R&gt;=strftime(&#34;%Y-%m-%d&#34;)&lt;CR&gt;&lt;CR&gt;&lt;ESC&gt; imap と nmap の両方で定義しているので、挿入モードのときも、ノーマルモードのときも、ショートカットキーを入力して日付の挿入を行うことができます。 &lt;silent&gt; を入れることで、コマンドラインのエコーを防いでいます。 &lt;C-R&gt;= というのは、その後ろに記述した式を実行して展開するためのイディオムです（= は Expression register を示しており、詳細は :help i_Ctrl-R で確認できます）。 日付の挿入を頻繁に実行するのであれば、F1 キーのような単独キーに割り当てるようにすれば、さらに手軽に実行できるようになります。 ~/.vimrc（F1 キーで日付を挿入、F2 キーで日付＋曜日を挿入） imap &lt;silent&gt; &lt;F1&gt; &lt;C-R&gt;=strftime(&#34;%Y-%m-%d&#34;)&lt;CR&gt; imap &lt;silent&gt; &lt;F2&gt; &lt;C-R&gt;=strftime(&#34;%Y-%m-%d (%a)&#34;)&lt;CR&gt; ちなみに、F1 キーはデフォルトではヘルプの起動 (:help) のショートカットキーとして設定されているため、上記のように設定すると、F1 キーでヘルプを起動することはできなくなります（まったく問題ないと思いますが）。 また、キーシーケンスの都合で、Ctrl-1 といった Ctrl キーと数字キーの組み合わせはうまく動作しません。 strftime 関数のフォーマット一覧 Vim の strftime のフォーマット文字列で使用できる記号 (%Yなど）は、C 言語の strftime 関数と同様のものです。 なので、Linux 環境や macOS 環境であれば、下記のようにして C 言語の man ページで詳細を確認できます。 C 言語の strftime のドキュメントを表示 $ man 3 strftime 下記はフォーマット文字列と、その出力の例です。 呼び出し方 実行結果 strftime(&quot;%Y-%m-%d&quot;) 2018-10-28 strftime(&quot;%Y-%m-%d (%a)&quot;) 2018-10-28 (日) strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) 2018-10-28 20:46:18 strftime(&quot;%c&quot;) 日 10/28 20:52:24 2018 strftime(&quot;%Y %b %d %X&quot;) 2018 10 28 20時53分37秒 年 %Y: 4桁の年 (例: 2018） %y: 2桁の年（例: 18） 月 %m: 2桁の月（01〜12） %B: 月の名前（米国では December、日本では 12月 など） %b: 月の略称（米国では Dec、日本では 12 など） 日 %d: 2桁の日付 (例: 28) 曜日 %A &ndash; 曜日の名前（米国では Sunday、日本では 日曜日 など） %a &ndash; 曜日の略称（米国では Sun、日本では 日 などになる） 時 %H &ndash; 24時間表示の時（00〜23） その他 %X &ndash; 時刻の標準的な表示（米国では 20:53:37、日本では 20時53分37秒 など） %c &ndash; 日付＋時刻の標準的な表示（米国では Sun Oct 28 20:52:24 2018、日本では 日 10/28 20:52:24 2018 など） 簡単に strftime の出力を確認してみたいときは、:echo コマンドを使うのが便利です。 :echo strftime(&#34;%c&#34;) あるいは、インサートモードで Ctrl-R → =strftime(&quot;%c&quot;) と入力して、カーソル位置に実行結果を挿入することもできます。"},{url:"/p/wcfbnqj/",title:"Vim/Neovim で構文強調（シンタックスハイライト）を有効にする (syntax)",date:"2014-01-27T00:00:00+09:00",body:"Vim/Neovim で構文強調（シンタックスハイライト）を有効にする (syntax) Vim で構文強調（シンタックスハイライト）の機能を有効にしておくと、プログラムのソースコードをなどを編集しているときに、各種キーワードをカラフルに表示してくれるようになります。 :syntax on &#34;構文強調を有効にする（:syntax enable でも OK） :syntax off &#34;構文強調を無効にする 起動時に有効にしておきたい場合は、~/.vimrc に以下のように記述しておきます。 syntax on"},{url:"/p/r5fcfgk/",title:"Vim/Neovim のキーマップ例: ショートカットキーで設定ファイル (.vimrc, init.lua) を開く",date:"2014-01-27T00:00:00+09:00",body:"Vim/Neovim のキーマップ例: ショートカットキーで設定ファイル (.vimrc, init.lua) を開く Vim の場合 Vim の設定ファイルで下記のようにキーマッピング設定をしておくと、F1 キーを押すだけで簡単に ~/.vimrc ファイルを開くことができます。 Neovim の設定ファイルとして ~/.config/nvim/init.vim を使用している場合も同様に開くことができます。 Vim の .vimrc あるいは Neovim の init.vim を開く &#34; ノーマルモード時に F1 キーで設定ファイルを開く nnoremap &lt;silent&gt; &lt;F1&gt; :tabnew $MYVIMRC&lt;CR&gt; ここでは、:tabnew コマンドを使って、新しいタブで設定ファイルを開くようにしています。 オプションとして &lt;silent&gt; を指定すると、F1 キーを押したときにコマンドライン領域に :tabnew $MYVIMRC と表示されるのを抑制できます。 Neovim (init.lua) の場合 Neovim の Lua 版の設定ファイル (~/.config/nvim/init.lua) を使う場合は、次のように設定します。 Neovim の init.lua を開く -- ノーマルモード時に F1 キーで設定ファイルを開く vim.keymap.set(&#34;n&#34;, &#34;&lt;F1&gt;&#34;, &#34;:tabnew $MYVIMRC&lt;CR&gt;&#34;, { silent = true }) -- $MYVIMRC を使わずに Lua ファイルのパスを指定する方法 -- vim.keymap.set(&#34;n&#34;, &#34;&lt;F1&gt;&#34;, -- &#34;:tabnew &#34; .. vim.fn.stdpath(&#34;config&#34;) .. &#34;/init.lua&lt;CR&gt;&#34;, -- { silent = true } -- ) 上記のようにオプションとして silent = true を指定すると、F1 キーを押したときにコマンドライン領域に :tabnew $MYVIMRC と表示されるのを抑制できます。 参考 Vim/Neovim の設定ファイルのパスを確認する ($MYVIMRC) Vim/Neovim で設定ファイル (.vimrc, init.lua) を開く、リロードする"},{url:"/p/bcmfu3e/",title:"Androidメモ: SpeechRecognizer で音声入力を実現する",date:"2014-01-23T00:00:00+09:00",body:"Androidメモ: SpeechRecognizer で音声入力を実現する SpeechRecognizer の基本 Android 2.2 Froyo (API Level 8) で追加された SpeechRecognizer を使うと、UI を表示せずにバックグラウンドで音声認識を行えます。 以下のような手順で使用します。 SpeechRecognizer.createSpeechRecognizer() を使ってインスタンス作成。 SpeechRecognizer#setRecognitionListener() を使って RecognitionListner を登録。 SpeechRecognizer#startListening() で音声入力の開始。 あとは RecognitionListener のコールバックを適宜処理。 SpeechRecognizer#cancel() で音声入力を終了。 SpeechRecognizer の基本的な使い方 // import android.speech.RecognitionListener; // import android.speech.SpeechRecognizer; private SpeechRecognizer mRecognizer; private RecognitionListener mRecognitionListener = new RecognitionListener() { //... }; private void startSpeechRecognition() { mRecognizer = SpeechRecognizer.createSpeechRecognizer(this); mRecognizer.setRecognitionListener(mRecognitionListener); mRecognizer.startListening(new Intent()); } SpeechRecognizer を利用するには、RECORD_AUDIO パーミッションを付加しておく必要があります。 パーミッションが付加されていない場合、SpeechRecognizer#startListening() 実行時に、RecognitionListener#onError(int error) で、SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS (9) が報告されます。 AndroidManifest.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;manifest ...&gt; &lt;uses-permission android:name=&#34;android.permission.RECORD_AUDIO&#34; /&gt; ... &lt;/manifest&gt; RecognitionListener によるイベント処理 SpeechRecognizer#startListening() を実行すると、以下のようなイベントを捕捉できるようになります。 onReadyForSpeech &hellip; SpeechRecognizer#startListening() すると呼び出される onBeginningOfSpeech &hellip; マイクに向かってしゃべり始めると呼び出される onEndOfSpeech &hellip; しゃべり終わると呼び出される onResults &hellip; 音声認識の結果が渡される RecognitionListener#onResults() で渡される Bundle オブジェクトから、音声認識の結果を取得することができます。 private RecognitionListener mRecognitionListener = new RecognitionListener() { @Override public void onResults(Bundle results) { ArrayList&lt;String&gt; values = results.getStringArrayList( SpeechRecognizer.RESULTS_RECOGNITION); for (String val : values) { Log.d(TAG, val); } } ... }; 音声認識に使用する言語を指定する SpeechRecognizer#startListening() を実行するときに指定する Intent をカスタマイズすることで、音声認識に使用する言語を設定することができます。 例: アメリカ英語で音声認識する // private SpeechRecognizer mRecognizer; // private RecognitionListener mRecognitionListener = new RecognitionListener() {...}; private void startRecognition() { mRecognizer = SpeechRecognizer.createSpeechRecognizer(this); mRecognizer.setRecognitionListener(mRecognitionListener); // 英語で音声入力 Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH); String lang = &#34;en_US&#34;; intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, lang); intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE, lang); intent.putExtra(RecognizerIntent.EXTRA_ONLY_RETURN_LANGUAGE_PREFERENCE, lang); mRecognizer.startListening(intent); } 音声認識で取得する結果の数を設定する SpeechRecognizer での音声認識の結果は、デフォルトでは複数の候補が得られるようになっています。 取得する結果の数を変更するには、以下のように SpeechRecognizer#startListening() で渡す Intent でカスタマイズします。 例: 音声認識の結果を 1 つにする // private SpeechRecognizer mRecognizer; // private RecognitionListener mRecognitionListener = new RecognitionListener() {...}; private void startRecognition() { mRecognizer = SpeechRecognizer.createSpeechRecognizer(this); mRecognizer.setRecognitionListener(mRecognitionListener); // 候補数を 1 つに設定 Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH); intent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1); mRecognizer.startListening(intent); } EXTRA_MAX_RESULTS で設定した数が反映されるかどうかは、Android のバージョンにも依存するようです。 いずれにしても、結果を 1 つだけ取得したいのであれば、RecognitionListener#onResult() で取得した認識結果の最初だけを取得すればよいでしょう。 private RecognitionListener mRecognitionListener = new RecognitionListener() { @Override public void onResults(Bundle results) { ArrayList&lt;String&gt; values = results.getStringArrayList( SpeechRecognizer.RESULTS_RECOGNITION); String val = values.get(0); Log.d(TAG, &#34;認識結果: &#34; + val); } ... } 音声認識のエラーコードをテキストに変換する SpeechRecognizer で音声入力をするときにエラーが発生すると、RecognitionListener#onError() が呼び出されます。 このとき、引数でエラーコードが渡されるのですが、分かりやすいテキストに変換したいところです。 現時点でテキストに変換する方法は提供されていないようなので、ここでは、適当なユーティリティを作って対応します。 SpeechRecognizerUtil.java package com.example.myfirstapp; import android.speech.SpeechRecognizer; public class RecognizerUtil { public static String getErrorMessage(int errorCode) { switch (errorCode) { case SpeechRecognizer.ERROR_AUDIO: return &#34;Audio recording error&#34;; case SpeechRecognizer.ERROR_CLIENT: return &#34;Other client side errors&#34;; case SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS: return &#34;Insufficient permissions&#34;; case SpeechRecognizer.ERROR_NETWORK: return &#34;Network related errors&#34;; case SpeechRecognizer.ERROR_NETWORK_TIMEOUT: return &#34;Network operation timed out&#34;; case SpeechRecognizer.ERROR_NO_MATCH: return &#34;No recognition result matched&#34;; case SpeechRecognizer.ERROR_RECOGNIZER_BUSY: return &#34;RecognitionService busy&#34;; case SpeechRecognizer.ERROR_SERVER: return &#34;Server sends error status&#34;; case SpeechRecognizer.ERROR_SPEECH_TIMEOUT: return &#34;No speech input&#34;; } return &#34;Unknown error&#34;; } } RecognitionListener#onError() での使用例 private RecognitionListener mRecognitionListener = new RecognitionListener() { @Override public void onError(int error) { Log.e(TAG, &#34;onError: &#34; + RecognizerUtil.getErrorMessage(error)); } ... } 音声認識を連続して実行する SpeechRecognizer#startListening() で開始した音声入力は、一度入力が完了すると終了します (API Level 19)。 連続して音声入力を行うには、以下のようにするとよいようです。 RecognitionListener#onResults() で結果を取得したら再び startListening() RecognitionListener#onError() で、ERROR_NO_MATCH あるいは ERROR_SPEECH_TIMEOUT が発生したら再び startListening() 二回目以降の startListening() を呼び出す前には、一度 SpeechRecognizer を destroy() して、再生成しないとうまくいかないことがあるようです（startListening() を読んでも実際には何も起こらない）。 SpeechRecognizer を連続実行するサンプルコード package com.example.myfirstapp; import java.util.ArrayList; import android.os.Bundle; import android.app.Activity; import android.content.Intent; import android.speech.RecognitionListener; import android.speech.RecognizerIntent; import android.speech.SpeechRecognizer; import android.util.Log; public class MainActivity extends Activity { private static String TAG = &#34;Sample&#34;; private SpeechRecognizer mRecognizer; private RecognitionListener mRecognitionListener = new RecognitionListener() { @Override public void onError(int error) { if ((error == SpeechRecognizer.ERROR_NO_MATCH) || (error == SpeechRecognizer.ERROR_SPEECH_TIMEOUT)) { startSpeechRecognition(); return; } Log.d(TAG, &#34;Recognition Error: &#34; + error); } @Override public void onResults(Bundle results) { ArrayList&lt;String&gt; values = results .getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION); String val = values.get(0); Log.d(TAG, &#34;認識結果: &#34; + val); startSpeechRecognition(); } @Override public void onBeginningOfSpeech() {} @Override public void onBufferReceived(byte[] arg0) {} @Override public void onEndOfSpeech() {} @Override public void onEvent(int arg0, Bundle arg1) {} @Override public void onPartialResults(Bundle arg0) {} @Override public void onReadyForSpeech(Bundle arg0) {} @Override public void onRmsChanged(float arg0) {} }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startSpeechRecognition(); } private void startSpeechRecognition() { // Need to destroy a recognizer to consecutive recognition? if (mRecognizer != null) { mRecognizer.destroy(); } // Create a recognizer. mRecognizer = SpeechRecognizer.createSpeechRecognizer(this); mRecognizer.setRecognitionListener(mRecognitionListener); // Start recognition. Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH); mRecognizer.startListening(intent); } }"},{url:"/p/ycrtvgk/",title:"Linuxメモ: Linux の各種 ID（プロセス ID やユーザ ID など）についてのメモ",date:"2014-01-02T00:00:00+09:00",body:"Linuxメモ: Linux の各種 ID（プロセス ID やユーザ ID など）についてのメモ プロセス ID (pid: Process ID) Unix システム上で動作しているプロセスには、0 ～ 30000 までのユニークな pid（プロセス ID）が割り当てられます。 プロセス ID が 1 のものは、最初に立ち上がる init プロセスです（例外として、終了した親プロセスの pid を子プロセスから参照すると 1 が返されます）。 プロセス・グループ ID (pgid: Process Group ID) プロセス・グループとは、1 つ以上のプロセスをまとめて扱う仕組みで、個々のプロセスに対してではなく、プロセス・グループに対してシグナルを送ったりすることができます。 プロセス・グループには 1 つのプロセス・グループ・リーダ（プロセス）が存在し、そのプロセス ID (pid) をプロセス・グループ ID (gpid) として使用します（つまり、プロセス・グループ・リーダの pid と gpid は等しくなります）。 プロセス・グループ・リーダではないプロセスをリーダにするには、setpgrp システムコールを使用します。 ターミナル・グループ (tty group) プロセス・グループ・リーダがあるターミナルと関連を持っている場合、そのプロセス・グループのすべてのプロセスは同じターミナル・グループに属します。 ターミナルとの接続が切れた場合、そのターミナル・グループ内のすべてのプロセスに SIGHUP シグナルが送られます。 リアル・ユーザ ID（実ユーザ ID）(ruid: Real User ID) ログイン名と 1 対 1 で対応付けられるユーザを識別するための ID です。 /etc/passwd を見ると、どのように対応付けられているかが分かります。 子プロセスを生成した場合は、親プロセスの ruid が引き継がれます。 リアル・グループ ID（実グループ ID）(rgid: Real Group ID) リアル・ユーザ ID のグループ版と考えれば OK です。 /etc/passwd を見ると、ログイン名と rgid の対応付けが分かります。 実効ユーザ ID／実効グループ ID ファイルにアクセスできるかどうかを決定するためのカギとなる ID です。 子プロセスは親プロセスの実効ユーザ ID、実効グループ ID を引き継ぎます。 実行した実行ファイルに set-user-id、set-group-id ビットが設定されている場合は、その実行ファイルの所有者のユーザ ID、グループ ID が実効ユーザ ID、および、実効グループ ID となります。"},{url:"/p/9kiba2c/",title:"Node.jsメモ: npm run で任意のコマンドを実行する (npm run/start)",date:"2013-12-28T00:00:00+09:00",body:"Node.jsメモ: npm run で任意のコマンドを実行する (npm run/start) npm run-script とは package.json の scripts プロパティでスクリプトを定義しておくと、npm run &lt;スクリプト名&gt; でそのスクリプトを実行できるようになります。 run は run-script の省略形であり、下記は同じ意味を持ちます。 $ npm run hello $ npm run-script hello 参考: npm-run | npm Docs npm run で Hello World 下記は、簡単な echo コマンドを実行するスクリプトの定義例です。 スクリプト名は hello にしています。 package.json { &#34;scripts&#34;: { &#34;hello&#34;: &#34;echo Hello!&#34; } } npm run に続けてスクリプト名を指定すると、そのスクリプトを実行できます。 実行例 C:\\&gt; npm run hello &gt; node@1.0.0 hello C: &gt; echo Hello! Hello! 途中でコマンド実行の過程が表示されていますが、出力をスクリプトの実行結果だけに絞りたいときは、--silent オプションを付けて実行します。 C:\\&gt; npm run hello --silent Hello! 予約スクリプト名 (start / stop / restart) packages プロパティで定義した各スクリプトは、通常 npm run &lt;スクリプト名&gt; のように実行しますが、start、stop、restart といった予約されたスクリプト名を使うと、npm start、npm stop、npm restart といった省略形のコマンドで実行できるようになります。 package.json { &#34;scripts&#34;: { &#34;start&#34;: &#34;echo START&#34;, &#34;stop&#34;: &#34;echo STOP&#34; } } 実行例 $ npm start --silent START $ npm stop --silent STOP $ npm restart --silent STOP START npm restart を実行すると、stop スクリプト → start スクリプトの順番に呼び出されていることが分かります。 このあたりの、スクリプトの呼び出しルールに関しては、下記のマニュアルに詳しく記載されています。 いろいろなトリガ（イベント）で、いろいろな名前のスクリプトが呼び出されるようになっているので、活用できるものがないか一度目を通しておくとよいでしょう。 npm-scripts｜npm Documentation 例えば、次のように restart スクリプトを定義しておくと、npm restart を実行した場合に、stop と start スクリプトの代わりに restart スクリプトが呼び出されるようになります。 このような振る舞いも、上記のドキュメントを読むと分かります。 package.json { &#34;scripts&#34;: { &#34;start&#34;: &#34;echo START&#34;, &#34;stop&#34;: &#34;echo STOP&#34;, &#34;restart&#34;: &#34;echo RESTART&#34; } } 実行例 $ npm restart --silent RESTART 多くの Node.js アプリでは、この仕組みを利用して、npm start でメインスクリプトを起動するように定義しています。 package.json { &#34;scripts&#34;: { &#34;start&#34;: &#34;node index.js&#34; } } これくらいシンプルであれば、直接 node コマンドを実行すればよいのではと思うかもしれませんが、この定義があることで、ユーザーはエントリポイントとなる JS ファイルのパスを意識せずに、単純に下記のように入力するだけで Node.js アプリを起動できるようになります。 実行例 $ npm start npm run で使用できるコマンドの一覧を表示する npm run コマンドをパラメータなしで実行すると、実行可能なコマンドの一覧（scripts で定義されたプロパティの一覧）を確認することができます。 package.json { &#34;scripts&#34;: { &#34;start&#34;: &#34;node index.js&#34;, &#34;stop&#34;: &#34;echo Stop server&#34;, &#34;hello1&#34;: &#34;echo Hello1&#34;, &#34;hello2&#34;: &#34;echo Hello2&#34; } } 実行例 $ npm run Lifecycle scripts included in node: start node index.js stop echo Stop server available via `npm run-script`: hello1 echo Hello1 hello2 echo Hello2 前半に、npm start のように省略コマンドで起動できるスクリプト、後半に、npm run hello1 のように実行するスクリプトの一覧が表示されます。"},{url:"/p/ptactsj/",title:"Node.js スクリプトにシェバング (#!` を付けてコマンドとして起動できるようにする",date:"2013-11-19T00:00:00+09:00",body:"Node.js スクリプトにシェバング (#!` を付けてコマンドとして起動できるようにする 一般的なスクリプト言語と同様に、Node.js で動作させるアプリもシェバング (#!) で node コマンドを指定しておくことができます。 app.js #!/usr/bin/env node console.log(&#39;Hello&#39;); あとは、.js ファイルに実行権限を付けてやれば、コマンドとして扱うことができるようになります。 実行方法 $ chmod +x app.js $ ./app.js Hello"},{url:"/p/ks84q3k/",title:"Androidベンダー向けメモ: Android デバイスのパーティション構成概要",date:"2013-11-07T00:00:00+09:00",body:"Androidベンダー向けメモ: Android デバイスのパーティション構成概要 パーティション構成 Android のパーティション構成は、およそ下記のようになっています。 /boot &hellip; Android kernel と ramdisk /system &hellip; Android OS およびプリインアプリなど /recovery &hellip; リカバリ時に /boot パーティションの代わりに起動されるリカバリ OS /data &hellip; GooglePlay からインストールしたアプリやユーザデータ（書き込み可能） /cache &hellip; アプリ用キャッシュ（リカバリイメージのダウンロードもここに入る） Nexus7 (2013) の情報を見てみる マウント情報の表示 $ mount （あるいは cat /proc/mounts） rootfs / rootfs ro,relatime 0 0 tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0 devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0 proc /proc proc rw,relatime 0 0 sysfs /sys sysfs rw,seclabel,relatime 0 0 selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0 debugfs /sys/kernel/debug debugfs rw,relatime 0 0 none /acct cgroup rw,relatime,cpuacct 0 0 tmpfs /mnt/secure tmpfs rw,seclabel,relatime,mode=700 0 0 tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0 tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0 none /dev/cpuctl cgroup rw,relatime,cpu 0 0 /dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,noatime,nomblk_io_submit,errors=panic,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,noatime,nomblk_io_submit,errors=panic,data=ordered 0 0 /dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,nodelalloc,data=ordered 0 0 /dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 ファイルシステム情報の表示 $ df Filesystem Size Used Free Blksize /dev 911.4M 48.0K 911.3M 4096 /mnt/secure 911.4M 0.0K 911.4M 4096 /mnt/asec 911.4M 0.0K 911.4M 4096 /mnt/obb 911.4M 0.0K 911.4M 4096 /system 827.8M 589.1M 238.7M 4096 /cache 551.7M 9.8M 541.9M 4096 /data 26.1G 2.7G 23.4G 4096 /persist 14.5M 4.2M 10.2M 4096 /mnt/shell/emulated 26.1G 2.7G 23.4G 4096"},{url:"/p/5b6pmtc/",title:"Androidメモ: Nexus7 (2013) に adb 接続する",date:"2013-11-06T00:00:00+09:00",body:"Androidメモ: Nexus7 (2013) に adb 接続する Android タブレットの Nexus7 に、adb コマンドで接続するまでの手順です。 下記は Android 4.3 で確認しています。 Android の設定メニューに「開発者向けオプション」を表示 設定 =&gt; タブレット情報 (About tablet) 「ビルド番号 (Build number)」を 7 回タップ この操作で「デベロッパー」として認識され、設定メニューに「開発者向けオプション (Developer options)」の項目が表示されます。 開発者向けオプションでは、USB による adb 接続を行うために以下のチェックを入れておきます。 USBデバッグ この設定を行ってから USB Driver を更新する必要があります。 Windows 7 に USB Driver をインストール https://developer.android.com/sdk/win-usb.html の指示に従ってドライバのダウンロード、インストールをすれば OK です。 簡単に手順をまとめると、 Google USB Driver をダウンロードして展開しておく（SDK Manager で GUI からダウンロードも可能） 「開発者向けオプション/USBデバッグ」を ON にした状態で Nexus7 を USB で接続 デバイスマネージャを起動（&ldquo;Computer&rdquo; を右クリック =&gt; &ldquo;Manage&rdquo; =&gt; 左側のペーンから &ldquo;Device Manager&rdquo; を選択） &ldquo;Other devices/Nexus 7&rdquo; を右クリック =&gt; &ldquo;Update Driver Software&hellip;&rdquo; （&ldquo;Portable Devices/Nexus 7&rdquo; の方と間違えないように。&ldquo;Other devices&rdquo; の方が表示されない場合は、USBデバッグが ON になっていない可能性が高いです。） ドライバの入っているディレクトリを選択 SDK Manager でダウンロードした場合: &lt;android-sdk&gt;/extras/google/usb_driver 手動ダウンロードした場合: 展開してできた usb_driver ディレクトリを選択 ADB を最新版に更新 SDK Manager で以下を最新にアップデートしておく（これやらないと adb devices で認識しないことあり） Android SDK Platoform-tools（2013-11-06 時点で rev.19） コマンドラインから ADB 接続 $ adb kill-server $ adb devices ここで Nexus7 の画面に「USBデバッグを許可しますか？」のダイアログが出るので「OK」を選択。 これで Nexus7 に ADB 接続できるようになります。 $ adb shell shell@flo:/ $"},{url:"/p/6mdd9es/",title:"Windows でファイルを開くときに既存の GVim 内のタブで開く",date:"2013-10-25T00:00:00+09:00",body:"Windows でファイルを開くときに既存の GVim 内のタブで開く 以下のように設定しておくと、すでに gvim.exe のウィンドウが起動している状態で別のファイルを開いたときに、既存ウィンドウ内のタブとして開くことができます。 レジストリエディタ (regedit) を起動 /HKEY_CLASSES_ROOT/Applications/gvim.exe/shell/open/command の値を &quot;C:\\app\\vim73-kaoriya\\gvim.exe&quot; --remote-tab-silent &quot;%1&quot; のように変更 gvim.exe のパスは自分の環境に合わせてください。"},{url:"/p/ybxfwev/",title:"Python でコマンドライン引数を扱う (sys.argv)",date:"2013-10-20T00:00:00+09:00",body:"Python でコマンドライン引数を扱う (sys.argv) ここでは、sys.argv でコマンドライン引数を参照する初歩的な方法を説明しますが、ある程度複雑なコマンドライン引数を扱いたいときは、Python の標準ライブラリの argparse モジュールを使う ことをおすすめします。 コマンドライン引数を参照する Python スクリプト起動時にコマンドライン引数として渡された値は、sys.argv で文字列リストの形で参照することができます。 先頭の要素 sys.argv[0] には、python コマンドで指定したスクリプト自身の名前が格納されています。 コマンドライン引数を参照する (sample.py) import sys print(sys.argv) print(len(sys.argv)) 実行例 $ python sample.py aaa bbb ccc [&#39;sample.py&#39;, &#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;] 4 sys.argv の先頭にスクリプト自身の名前が入っているので、len(sys.argv) は少なくとも 1 以上の値になります。 コマンドライン引数が正しく指定されていないときに Usage 表示する 下記は、コマンドライン引数を 1 つも指定せずにスクリプトを実行した場合に使い方 (usage) を表示して終了するサンプルです。 コマンドライン引数が不正なときに終了する (hello.py) import sys import os if len(sys.argv) &lt; 2: # コマンドライン引数が指定されなかった場合は終了 print(f&#34;Usage: python {os.path.basename(sys.argv[0])} &lt;name&gt;&#34;) sys.exit(1) print(f&#34;Hello, {sys.argv[1]}!&#34;) 実行例 $ python hello.py Usage: python hello.py &lt;name&gt; $ python hello.py Maku Hello, Maku! スクリプト名を除いてコマンドライン引数を取得する sys.argv[0] には自身のスクリプトファイル名が含まれています。 純粋にコマンドライン引数だけを取り出したい場合は、sys.argv[1:] のようにインデックス 1 以降を取り出してしまうと分かりやすくなります。 コマンドライン引数がひとつも渡されなかった場合は、sys.argv[1:] は空リストになります。 コマンドライン引数のみを取り出す (sample.py) import sys args = sys.argv[1:] for x in args: print(x) 実行例 $ python sample.py 100 200 100 200 （おまけ）ハッカー流のコマンドライン引数の処理方法 下記は、高校生ハッカーが主人公のドラマ『ブラッディ・マンデイ』の中で、主人公であるファルコンが使ってた方法です。 なんらかの攻撃ツールを即席で実装してたシーン。 強引に sys.argv をスライスしてしまって、正しい数のパラメータを指定されていない場合に、ValueError 例外を発生させてしまうやり方です。 なるほどねー import sys try: host, frm, to = sys.argv[1:4] except ValueError: print(&#34;Usage: %s &lt;host&gt; &lt;from&gt; &lt;to&gt;&#34; % (sys.argv[0])) sys.exit(1)"},{url:"/p/nouqw33/",title:"RequireJS の使い方メモ",date:"2013-07-18T00:00:00+09:00",body:"RequireJS の使い方メモ RequireJS を使うと、JavaScript のコードで、C/C++ の include のようなことができるようになります。 しかも、非同期にロードされるので、パフォーマンス上の利点もあります。 RequireJS で Hello World RequireJS 本体 (require.js) は下記サイトからダウンロードできます。 https://requirejs.org/docs/download.html ここでは、以下のようなディレクトリ構成でファイルを配置することにします。 index.html js/main.js js/vendor/require.js require.js を script 要素でロードするときに、data-main 属性の値として、任意の JavaScript ファイルを指定しておくと、require.js がロードされた後にその JavaScript ファイルを自動的に実行してくれます。 つまり、data-main で指定した JavaScript ファイルが、アプリケーションのエントリポイントとなります。 index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;RequireJS Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello RequireJS&lt;/h1&gt; &lt;script data-main=&#34;js/main.js&#34; src=&#34;js/vendor/require.js&#34;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; js/main.js require([], function() { alert(&#39;Hello World&#39;); }); 上記の index.html をブラウザで開くと js/main.js が自動的にロードされ、Hello World と表示されます。 エントリポイントとなる JavaScript ファイルには、require() を使って main 関数となる function を定義しておきます。 require() の第 1 引数には依存するモジュールを配列で指定できますが、今回は依存するモジュールはないので空にしてあります。 RequireJS モジュールを定義する 簡単なユーティリティ・モジュールの作成 エントリポイントとなる JavaScript ファイルからロードする RequireJS モジュールを定義するには、define() 関数を使用します。 ここでは、足し算 (add)、引き算 (subtract) の関数を提供する util/MathUtil モジュールを作成してみます。 js/util/MathUtil.js define({ add: function(a, b) { return a + b; }, subtract: function(a, b) { return a - b; } }); 上記の util/MathUtil モジュールを使うには、エントリポイントとなる関数を設定する require() 関数の第 1 引数でそのモジュール名を指定します。 すると、util/MathUtil.js 内で define() 関数に渡したオブジェクトを、main 関数の引数として参照することができるようになります。 index.html &lt;script data-main=&#34;js/main.js&#34; src=&#34;js/vendor/require.js&#34;&gt;&lt;/script&gt; js/main.js require([&#39;util/MathUtil&#39;], function(MathUtil) { console.log(&#39;add: &#39; + MathUtil.add(100, 200)); console.log(&#39;sub: &#39; + MathUtil.subtract(100, 200)); }); 上記のモジュール名の指定方法 ('util/MathUtil') からも分かるように、ロードするモジュール名は、script タグの data-main 属性で渡したメイン JavaScript ファイルのディレクトリからの相対パスで指定します。 拡張子は必要ありません。 RequireJS モジュールから他のモジュールをロードする もちろん、RequireJS モジュールの中からも別の RequireJS モジュールをロードすることができます。 require() 関数でモジュールをロードするときと同様に、define() 関数の第 1 引数でロードしたいモジュールを指定します。 下記の例では、util/Util1 モジュールから、util/Util2 モジュールと util/Util3 モジュールを参照しています。 js/main.js // Entry point. require([&#39;util/Util1&#39;], function(Util1) { console.log(&#39;Util1 says: &#39; + Util1.message); }); js/util/Util1.js define([&#39;util/Util2&#39;, &#39;util/Util3&#39;], function(Util2, Util3) { console.log(&#39;Util2 says: &#39; + Util2.message); console.log(&#39;Util3 says: &#39; + Util3.message); return { message: &#39;I am Util1&#39; }; }); js/util/Util2.js define({message: &#39;I am Util2&#39;}); js/util/Util3.js define({message: &#39;I am Util3&#39;}); 実行すると、コンソールに以下のように表示されます。 Util2 says: I am Util2 Util3 says: I am Util3 Util1 says: I am Util1 クラスモジュールを作成する define() を使ってモジュールを定義するときに、コンストラクタとなる function オブジェクトを返すようにしておけば、クラスモジュールとして使えるようになります。 下記の例では、クラスモジュールとして Counter モジュールを定義しています。 js/main.js require([&#39;Counter&#39;], function(Counter) { var counter = new Counter(100); for (var i = 0; i &lt; 3; ++i) { console.log(counter.get()); } }); js/Counter.js define(function() { // Constructor var Counter = function(start) { this.count = start; }; // Methods Counter.prototype.get = function() { return this.count++; } return Counter; }); これを実行すると、以下のように表示されます。 100 101 102 RequireJS の r.js コマンドで JavaScript ファイルを圧縮する r.js コマンドを使用すると、単一、あるいは複数の JavaScript ファイルを圧縮してひとつのファイルにまとめることができます。 圧縮する各ファイルは、RequireJS (AMD) モジュール の形式でコーディングされている必要があります。 つまり、ファイル内のコードが以下のようになっている必要があります。 define(..., function(...) {...}); あるいは、 require(..., function(...) {...}); r.js のインストール r.js の実行環境としては Node.js を使うのが簡単です。 以下のように npm コマンドで requirejs パッケージをインストールすると、r.js コマンドも使用できるようになります。 $ npm install -g requirejs インストールが終わったら、以下のように実行できます。 $ r.js ほげほげ Windows 環境で .js ファイルがテキストエディタなどに関連付けられている場合は、以下のように .cmd 拡張子まで付けて実行します（r.js の実体は r.js.cmd です）。 これは、r.js というファイルをテキストエディタで開こうとしてしまうのを防ぐためです。 D:\\&gt; r.js.cmd ほげほげ r.js で 1 つの JavaScript ファイルを圧縮する カレントディレクトリにある main.js を圧縮して main.min.js として出力するには以下のようにします。 $ r.js -o name=main out=main.min.js baseUrl=. 複数の JavaScript ファイルを 1 つずつ圧縮することもできます。 以下のようにすると、js ディレクトリ内のファイルが 1 つずつ圧縮され、圧縮後のファイルが js-min ディレクトリに出力されます。 $ r.js -o baseUrl=./js dir=./js-min r.js で複数の JavaScript ファイルを圧縮して 1 ファイルにまとめる js/ +-- main.js # Entry point starting with &#39;require&#39; +-- Module1.js # Used from &#39;main.js&#39; +-- Module2.js # Used from &#39;Module1.js&#39; 上記のような 3 つの JavaScript ファイルを圧縮して 1 ファイルにする例です。 JavaScript の内容は以下のようになっているとします。 js/main.js require([&#39;Module1&#39;], function(Module1) { console.log(&#39;I am main&#39;); }); js/Module1.js define([&#39;Module2&#39;], function(Module2) { console.log(&#39;I am Module1&#39;); }); js/Module2.js define([&#39;Module2&#39;], function(Module2) { console.log(&#39;I am Module1&#39;); }); 次のように実行すると、全ての JavaScript ファイルが圧縮されて 1 ファイルにまとめられた main.min.js が出力されます。 $ r.js -o baseUrl=js name=main out=main.min.js できあがった main.min.js の内容は以下のようになっています。 main.min.js define(&#34;Module2&#34;,[],function(){console.log(&#34;I am Module2&#34;)}),define(&#34;Module1&#34;,[&#34;Module2&#34;],function(e){console.log(&#34;I am Module1&#34;)}),require([&#34;Module1&#34;],function(e){console.log(&#34;I am main&#34;)}),define(&#34;main&#34;,function(){}); コマンドラインで指定したオプションは、別ファイルに記述しておくこともできます。 以下の例では、build.js に設定を記述しています。 build.js（r.js 用設定ファイル） ({ baseUrl: &#34;js&#34;, name: &#34;main&#34;, out: &#34;main.min.js&#34; }) $ r.js -o build.js あとは、できあがった main.min.js を script タグで読み込むようにすれば OK です。 index.html &lt;script data-main=&#34;main.min&#34; src=&#34;js/vendor/require.js&#34;&gt;&lt;/script&gt; 3rd party ライブラリのライセンスコメントを残して圧縮する r.js による圧縮をかけると、デフォルトでは JavaScript コード内のコメントは全て削除されます。 ただ、オープンソースコードを使用する場合はライセンスのコメントが消えてしまっては困るので、これを防ぐためのコメント記述方法が用意されています。 /*! * ... */ あるいは、 /** * @license * ... */ という記述方法です。 どちらかの形でコメントを記述しておくと、r.js はそのコメントを残すようになります。 ただし、この方法で残されたコメントは全て 出力ファイルの先頭にまとまった形で出力されます。 どのモジュールのライセンスなのかが分かるように、コメントの先頭にモジュール名を記載しておくのがよいかもしれません。 下記の例では、圧縮する 3 ファイル中、2 つのファイルがライセンスコメントを含んでいます。 js/main.js /** * Normal comment. * This should be removed after minifying. */ require([&#39;Module1&#39;], function(Module1) { console.log(&#39;I am main&#39;); }); js/Module1.js /*!=== Module 1 === * License description for Module1. */ define([&#39;Module2&#39;], function(Module2) { console.log(&#39;I am Module1&#39;); }); js/Module2.js /*!=== Module2 === * License description for Module2. */ define(function() { console.log(&#39;I am Module2&#39;); }); 圧縮後のコードは以下のようになります。 main.min.js /*!=== Module2 === * License description for Module2. */ /*!=== Module 1 === * License description for Module1. */ define(&#34;Module2&#34;,[],function(){console.log(&#34;I am Module2&#34;)}),define(&#34;Module1&#34;,[&#34;Module2&#34;],function(e){console.log(&#34;I am Module1&#34;)}),require([&#34;Module1&#34;],function(e){console.log(&#34;I am main&#34;)}),define(&#34;main&#34;,function(){}); require.js も含めて 1 ファイルにまとめる ディレクトリ構成が次のようになっているとします。 js/main.js js/Module1.js js/Module2.js js/vendor/require.js r.js コマンドを実行するときに、次のようにインクルード指定することで、最終的に出力されるファイルに require.js のコードまで含めてしまうことができます。 $ r.js -o baseUrl=js paths.requireLib=vendor/require name=main include=requireLib out=main.min.js main.min.js に require.js が含まれていれば、HTML ファイルからのロードは以下のようにシンプルになります。 &lt;script src=&#34;main.min.js&#34;&gt;&lt;/script&gt; RequireJS の r.js でプロジェクト全体を圧縮する r.js コマンドは、単純に JavaScript ファイルを圧縮する機能の他に、CSS ファイルの連結や、プロジェクト全体のリリースファイルをまとめてディレクトリに出力する機能も持っています。 例えば、Web アプリの構成が以下のようになっているとします。 sample/ webapp/ ← HTML/CSS/JavaScript が含まれている build.js プロジェクト単位で圧縮＆リリースファイル生成を行うには、r.js の設定 (build.js) で、appDir（入力ディレクトリ） と dir（出力ディレクトリ） を指定します。 build.js ({ // Input directory appDir: &#39;./webapp&#39;, // Output directory dir: &#39;./release&#39;, // Use shim settings in the require.config() mainConfigFile: &#39;./webapp/js/main.js&#39;, // Application&#39;s entry point name: &#39;main&#39;, // Remove files from the output directory that were combined removeCombined: true, }) あとは、build.js ファイルがあるディレクトリで r.js コマンドを実行すれば、リリース用のファイル郡が含まれた release ディレクトリができあがります。 $ r.js -o build.js 出力される release ディレクトリには、必要な HTML/CSS ファイルがすべてコピーされ、JavaScript としては require.js と、圧縮された main.js ファイルの 2 ファイルだけが格納されます。 RequireJS の r.js の設定メモ (build.js) build.js ファイルの各設定の説明 https://github.com/requirejs/r.js/blob/master/build/example.build.js 各設定値がどこからの相対パスになるか？ appDir, mainConfigFile カレントディレクトリからの相対パス baseUri appDir がある場合はそこからの相対パス 何も指定がない場合はカレントディレクトリからの相対パス paths, packages baseUri からの相対パス name, include, exclude, excludeShallow, deps ファイルパスではなく、モジュール ID で指定 JavaScript を 1 ファイルに圧縮した場合にどのファイルのコードが結合されるか JavaScript ファイルを、name に指定したモジュールに結合する場合、基本的には define() や require() で定義されているモジュールはすべて含まれます。 逆に、RequireJS (AMD) 形式のモジュールじゃないライブラリ（例えば Backbone.js 1.0.0 や Underscore 1.5.1）はデフォルトでは圧縮後に結合されません。 これらの外部ライブラリも含めてしまいたい場合は、以下のような方法があります。 mainConfigFile で設定する JavaScript ファイルの require.config() の shim プロパティでモジュール名を指定する方法（これが推奨されている） build.js 内の shim プロパティでモジュール名を指定する方法（結局 main.js にも shim の設定しているなら、そちらを参照するように mainConfigFile を使ったほうがよい） include/exclude オプションで明示的にモジュール名を指定する方法 例えば、build.js で以下のように mainConfigFile を指定し、 build.js ({ appDir: &#39;./webapp&#39;, dir: &#39;./release&#39;, // output dir mainConfigFile: &#39;./webapp/js/main.js&#39;, // including require.config() name: &#39;main&#39;, // app entry point }) 指定した main.js が以下のような shim 設定を含んでいる場合、 webapp/js/main.js require.config({ baseUrl: &#39;js&#39;, paths: { backbone: &#39;vendor/backbone-1.0.0.min&#39;, jquery: &#39;vendor/jquery-2.0.3.min&#39;, underscore : &#39;vendor/underscore-1.5.1.min&#39; }, shim: { backbone: { deps: [&#39;jquery&#39;, &#39;underscore&#39;], exports: &#39;Backbone&#39; }, underscore: { exports: &#39;_&#39; } } }); require(..., function() {...main code...}); 最終的に結合された main.js に、Backbone.js や Underscore.js のコードも含まれるようになります。 mainConfigFile で参照している JavaScript ファイル内の paths 設定で、CDN から jQuery などのライブラリをロードするようにしているときは注意点が必要です。 この場合は、それらのファイルは結合せずに都度インターネット上から取得するようにしておきたいので、以下のようにして結合対象から外しておく必要があります。 build.js ({ ... paths: { jquery: &#34;empty:&#34; } }) 参考: empty: paths for network/CDN resources RequireJS モジュールとして jQuery、Backbone.js、Underscore.js を使う 以下のようなディレクトリ構成のときに、RequireJS 経由で Backbone.js を使用する例です。 Backbone.js は jQuery や Underscore.js に依存しているので、それらを使用する設定も必要です。 - index.html - js/ - main.js - vendor/ - backbone-min.js - jquery-2.0.3.min.js - require.js - underscore-min.js index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;r.js test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;index.html&lt;/h1&gt; &lt;script data-main=&#34;js/main.js&#34; src=&#34;js/vendor/require.js&#34;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; AMD モジュールのフォーマットに対応していない Backbone.js、Underscore.js を RequireJS で扱うには、以下のように require.config() の shim 設定をしておく必要があります（jQuery は AMD に既に対応しています）。 js/main.js require.config({ baseUrl: &#39;js&#39;, paths: { backbone: &#39;vendor/backbone-1.0.0.min&#39;, jquery: &#39;vendor/jquery-2.0.3.min&#39;, underscore : &#39;vendor/underscore-1.5.1.min&#39; }, shim: { backbone: { deps: [&#39;jquery&#39;, &#39;underscore&#39;], exports: &#39;Backbone&#39; }, underscore: { exports: &#39;_&#39; } } }); require([&#39;jquery&#39;, &#39;MyModel&#39;], function($, MyModel) { $(function() { console.log(&#39;DOM is ready!&#39;); var model = new MyModel(); alert(model.get(&#39;message&#39;)); }); }); js/MyModel.js define([&#39;backbone&#39;], function(Backbone) { var MyModel = Backbone.Model.extend({ defaults: { message: &#39;Hello, I am MyModel&#39; } }); return MyModel; });"},{url:"/p/nqqixxy/",title:"Vim のキーマップの基本 (map, noremap)",date:"2013-07-18T00:00:00+09:00",body:"Vim のキーマップの基本 (map, noremap) Vim のキーマップとは Vim の *map 系コマンドを使うと、キーマップ（キーバインド）を定義できます。 キーマップとは、特定のキー入力（キーシーケンス）を別のキー入力に変換する機能です。 例えば、&lt;F1&gt; キーを押すことで :help コマンドを実行するように設定することができます。 頻繁に使うコマンドを短いキーシーケンスに割り当てることで、効率的に作業できるようになります。 Vim では、ノーマルモード、インサートモード、ビジュアルモード、コマンドラインモードなど、それぞれのモードごとにキーマップを定義できます。 また、noremap 系コマンドを使うことで、マッピングの伝播を防ぐことができます。 キーマップのヘルプ Vim のキーマップに関するヘルプドキュメントは、以下のコマンドで表示することができます。 必要に応じて参照してください。 :help map.txt :help key-mapping map 系コマンドによるキーマッピング キーマップの設定を行うには、主に以下のようなコマンドを使用します。 コマンドを使い分けることによって、特定のモードでだけ有効なマッピングを定義できます。 map &hellip; ノーマルモード、ビジュアルモード用のキーマッピング nmap &hellip; ノーマルモード用のキーマッピング vmap &hellip; ビジュアルモード用のキーマッピング imap &hellip; インサートモード用のキーマッピング cmap &hellip; コマンドラインモード用のキーマッピング よく使用するのは、ノーマルモード用のマップ定義を行う nmap と、インサートモード用のマップ定義を行う imap です。 マッピングの定義は、以下のような形式で行います。 キーマップの基本的な書式 :nmap ＜入力するキーシーケンス＞ ＜実行するコマンド＞ :imap ＜入力するキーシーケンス＞ ＜実行するコマンド＞ 例えば、下記のように実行したあとで、インサートモードで Ctrl キーを押しながら F10 キーを 2 回押すと、カーソル位置に Hello World が挿入されます。 キーマップの例（インサートモード用） :imap &lt;C-F10&gt;&lt;C-F10&gt; Hello World ☝️ ワンポイント &lt;C-F10&gt; は Ctrl キーを押しながら F10 キーを押すことを表します。 このようなキー入力の表現方法は、:help key-notation で詳しく説明されています。 もっと単純に F10 キー 1 つに割り当ててもよかったのですが、ここではこんな複雑なキーシーケンスにもマッピングできるよという例を示しています。 同様のキーシーケンスをノーマルモード用に割り当てる場合は、下記のように先に i コマンドでインサートモードに入らないといけないことに注意してください。 最後には &lt;Esc&gt; でノーマルモードに戻ってあげると行儀が良いです。 キーマップの例（ノーマルモード用） :nmap &lt;C-F10&gt;&lt;C-F10&gt; iHello World&lt;Esc&gt; 下記はいろいろなキーマップ設定の例です。 キーマップ設定の例 (~/.vimrc) &#34; &#39;-&#39; キーでカーソル位置の単語を削除 nmap - diw &#34; &#39;F1&#39; キーで &#39;Hello&#39; を挿入 nmap &lt;F1&gt; iHello&lt;Esc&gt; &#34; Ctrl+Tab で次のバッファへ切り替え map &lt;C-Tab&gt; :bn&lt;CR&gt; &#34; Ctrl+Shift+Tab で前のバッファへ切り替え map &lt;C-S-Tab&gt; :bp&lt;CR&gt; noremap 系コマンドによるキーマッピング map 系コマンド（map, nmap, vmap, imap, cmap 等）によるマッピングは、右値に指定されたコマンドが既にマッピング定義されていると、そのマッピング値が使用されます。 つまり、マッピング定義が伝播します。 例えば、 :imap &lt;C-T&gt; Hello :imap &lt;F1&gt; &lt;C-T&gt; &#34; Hello という入力に置き換えられる と定義してあるときに、インサートモードで F1 キーを入力すると、F1 キーにマッピングされているコマンド Ctrl-T は既に Hello にマッピングされているので、Hello と入力されます。 このようなマッピングの伝播を防ぐには、map 系コマンドの代わりに、noremap 系コマンドを使用します。 :imap &lt;C-T&gt; Hello :inoremap &lt;F1&gt; &lt;C-T&gt; &#34; Ctrl-T の入力として扱われる 上記のように設定すると、F1 キーを入力したとき、Vim がデフォルトで Ctrl-T に割り当てている機能である「インデント」の振る舞いをします。 ☝️ i_CTRL-T インサートモードで Ctrl-T を入力したときの振る舞いは、:help i_CTRL-T で調べることができます。 デフォルトでは、現在の行に shiftwidth 分のインデントを挿入する機能に割り当てられています。 似たようなキー割り当ての一覧は、:help index で調べることができます。 map 系のコマンドと同様に、noremap 系のコマンドも各モード用にキーマップ定義を行うためのコマンドが用意されています。 noremap &hellip; ノーマルモード、ビジュアルモード用のキーマッピング（マッピング伝播なし） nnoremap &hellip; ノーマルモード用のキーマッピング（マッピング伝播なし） vnoremap &hellip; ビジュアルモード用のキーマッピング（マッピング伝播なし） inoremap &hellip; インサートモード用のキーマッピング（マッピング伝播なし） cnoremap &hellip; コマンドラインモード用のキーマッピング（マッピング伝播なし） 参考 map、noremap 系コマンドで使用できる特殊キーの一覧 (keycodes)"},{url:"/p/4ekh9ba/",title:"Vim で開いたファイルがあるディレクトリをカレントディレクトリにする",date:"2013-06-16T00:00:00+09:00",body:"Vim で開いたファイルがあるディレクトリをカレントディレクトリにする （追記） autochdir オプション が使える Vim であればそちらを使った方が簡単です。 Vim では、最初に Vim を起動するときに指定したファイルのあるディレクトリがカレントディレクトリとして使用されます。 このカレントディレクトリは、新しいバッファで別のディレクトリにあるファイルを開いた場合でも変更されません。 このため、編集中のファイルと同じディレクトリにあるファイルを :e . や :tabnew . コマンドで開く際に不便を感じることがあります（全然関係ないディレクトリが起点となってしまう）。 Vim の設定ファイル (~/.vimrc) で次のように設定しておくと、Vim 内で別のファイルを開いたときに、そのファイルの存在するディレクトリへ自動的に移動してくれるようになります。 ~/.vimrc &#34; 開いたファイルのあるディレクトリをカレントディレクトリにする au BufEnter * execute &#34;:lcd &#34; . expand(&#34;%:p:h&#34;)"},{url:"/p/bq6yzpr/",title:"Python で dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault)",date:"2013-06-15T00:00:00+09:00",body:"Python で dictionary にキーが存在しない場合のみ新しい値を格納する (setdefault) Python の dictionary に値をセットするときに、まだそのキーが存在しない場合だけ新しい値をセットしたい場合は、dict.setdefault() メソッドを使用します。 setdefault() メソッドは、既にキーが存在している場合は格納されている値、存在しない場合は第 2 引数で指定した値を返します。 val = d.setdefault(&#39;key&#39;, &#39;default_value&#39;) つまり、dict.setdefault() は、dict.get() を行いつつ、存在しないキーを指定した場合は、値のセットまで行う という振る舞いをします。 典型的な使用例として、dictionary 要素の値としてリストを格納するというユースケースがあります。 次のように、キーに対応するリストを取り出すときに setdefault() を使えば、キーがまだ存在しないときに自動的に空のリストを生成し、dictionary に登録してくれます。 d = {} l = d.setdefault(&#39;key&#39;, []) # このキーは存在しないので初期値として空リストを格納し、さらにその参照を返す l.append(100) # d[&#39;key&#39;] が [100] になる もう一度、同じキー key で参照しようとすると、今度はすでに dictionary に格納されているリストへの参照を取得することができます。 l = d.setdefault(&#39;key&#39;, []) # このキーは既に存在しているので、格納されているリスト [100] の参照を返す l.append(200) # d[&#39;key&#39;] は [100, 200] になる 上記のコードは、次のように get() メソッドでデフォルト値を指定しておく方法と似ています。 ただし、このようにした場合は、get() によって返された新規リストオブジェクトを忘れずに dictionary に格納しなければいけません。 setdefault() を使わないとちょっと面倒になる l = d.get(&#39;key&#39;, []) l.append(100) d[&#39;key&#39;] = l # デフォルト値が生成されたときのために dictionary に格納する必要がある"},{url:"/p/wwatzd9/",title:"Windows の右クリックメニューに「Vimで開く」を追加する",date:"2013-06-10T00:00:00+09:00",body:"Windows の右クリックメニューに「Vimで開く」を追加する （Windows Vista、Windows 7 で動作確認） 以下のようにレジストリエディタ (regedit) で設定しておくと、テキストファイルを右クリックしたときに、「Vim で開く」というメニュー項目が表示されるようになります。 Windows + R（ファイル名を指定して実行）から regedit と入力してレジストリエディタを起動する。 HKEY_CLASS_ROOT/*/shell を右クリックして Vim というキーを新規作成。 HKEY_CLASS_ROOT/*/shell/Vim の規定の REG_SZ の値を &amp;Vim で開く に修正。 HKEY_CLASS_ROOT/*/shell/Vim を右クリックして command というキーを新規作成。 HKEY_CLASS_ROOT/*/shell/Vim/command の規定の REG_SZ の値を C:\\vim\\gvim.exe &quot;%1&quot; などに修正（パラメータをダブルクォーテーションで囲んでおかないと、空白を含んだファイルを開けません）。"},{url:"/p/xqq89n2/",title:"Vim で挿入モード、コマンドモードでの貼り付け",date:"2013-05-26T00:00:00+09:00",body:"Vim で挿入モード、コマンドモードでの貼り付け ノーマルモードでのテキストのコピペは、y コマンドでコピー (yank) 、p コマンドで貼り付け (put) することができます。 一方、挿入モードやコマンドモードで貼り付けを行うには、下記のように入力する必要があります（挿入モードで y と入力すると、そのまま y というテキストが入力されてしまいます）。 Ctrl-R 0 これは、具体的には 「レジスタ 0」 に格納されているテキスト（直近でヤンクされたテキスト）を選択して貼り付けるコマンドです。 レジスタ 0 に格納されるテキストは、あくまで Vim 内部でヤンクされたテキストです。 外部のアプリケーションでコピーしたテキストを貼り付けたい場合は、レジスタ 0 の代わりに、レジスタ * を指定してください。 Ctrl-R * レジスタに保存されているテキストの一覧は、以下のように確認することができます。 :reg 参考 切り取り＆貼り付け操作、レジスタの扱いについて理解する 最後にヤンクしたテキストを確実に貼り付ける"},{url:"/p/7jkhjzf/",title:"Vim で最後にヤンクしたテキストを確実に貼り付ける",date:"2013-05-26T00:00:00+09:00",body:"Vim で最後にヤンクしたテキストを確実に貼り付ける ビジュアルモードで選択したテキストは、y コマンドでコピーし、p コマンドで貼り付けることができます。 このとき、貼り付けを実行する前に、x コマンドや d コマンドなどによる削除操作を行ってしまうと、y コマンドを実行したときに、その削除したテキストが貼り付けられてしまいます。 このようなケースでも、自分が明示的にヤンク (y) したテキストを確実に貼り付けたいときは、次のようにレジスタ 0 を指定してペーストコマンド (p) を実行します。 &#34;0p レジスタ 0 は、Vim 上で最後にヤンクしたテキストを保持しておくレジスタです。 上記はノーマルモードでレジスタ 0 の値を貼り付ける方法を示していますが、挿入モードやコマンドモードで同様にレジスタ 0 の値を貼り付けるには下記のようにします。 Ctrl-R 0 参考 切り取り＆貼り付け操作、レジスタの扱いについて理解する 挿入モード、コマンドモードでの貼り付け"},{url:"/p/hoihkfy/",title:"Vim/Neovim でビジュアルモード中に連続インデントできるようにする",date:"2013-05-26T00:00:00+09:00",body:"Vim/Neovim でビジュアルモード中に連続インデントできるようにする Vim/Neovim でビジュアルモードで複数行を選択してインデントするには、&gt;&gt; や &lt;&lt; を使いますが、このコマンドを入力すると、ビジュアルモードを抜けてしまうので、連続してインデントを行いたい場合にちょっと面倒です（何回インデントすればよいか分かっていれば 3&gt;&gt; のように回数を指定することはできますが）。 下記のような設定を入れておくと、ビジュアルモード中のインデントを、&gt; あるいは &lt; だけで行うことができるようになります。 さらに、このコマンドを入力した後も、ビジュアルモードを抜けずにキープしてくれるので、行選択したまま連続してインデントを行うことができます。 Vim (.vimrc, init.vim) の場合 &#34; Reselect visual block after indent/outdent vnoremap &lt; &lt;gv vnoremap &gt; &gt;gv Neovim/Lua (init.lua) の場合 -- Reselect visual block after indent/outdent vim.keymap.set(&#34;v&#34;, &#34;&lt;&#34;, &#34;&lt;gv&#34;) vim.keymap.set(&#34;v&#34;, &#34;&gt;&#34;, &#34;&gt;gv&#34;) 同様に、選択範囲の自動インデントを行う = コマンド にも適用できます。 Vim (.vimrc, init.vim) の場合 &#34; Stay visual mode after formatting code vnoremap = =gv Neovim/Lua (init.lua) の場合 -- Stay visual mode after formatting code vim.keymap.set(&#34;v&#34;, &#34;=&#34;, &#34;=gv&#34;) 参考 インデント用のスペースを入力する（シフトコマンド） (&gt;&gt;, &lt;&lt;, Ctrl-T, Ctrl-D)"},{url:"/p/ngz6n6i/",title:"Vim/Neovim で80文字目に縦線を表示する (colorcolumn)",date:"2013-05-25T00:00:00+09:00",body:"Vim/Neovim で80文字目に縦線を表示する (colorcolumn) 指定した位置に縦線を表示 Vim/Neovim で colorcolumn オプションを設定すると、指定したカラム位置の背景色が変化します。 結果的にその位置に縦線を入れたように見せることができます。 例えば、80文字目の背景色を灰色にするには、以下のように colorcolumn を設定します。 80カラム目に縦線を表示する :set colorcolumn=80 colorcolumn は上記のように絶対位置で指定することもできるし、textwidth が設定されている場合は、その値からの相対位置（+N や -N という形）で指定することもできます。 例えば、下記のようにすると、textwidth から +1 の位置、つまり 80 文字目の背景色が変わることになります。 textwidth&#43;1 の位置に縦線を表示 :set textwidth=79 :set colorcolumn=+1 ここでは colorcolumn に一つの値だけを設定していますが、カンマで区切って複数のカラムを指定することができます。 カンマの前後にスペースは入れてはいけません。 textwidth&#43;1 の位置、80カラム目、100カラム目に縦線を表示 :set colorcolumn=+1,80,100 縦線の色を変えたいときは、highlight コマンドで ColorColumn ハイライト・グループの設定を変更します。 縦線の色を変更する :highlight ColorColumn guibg=#202020 ctermbg=lightgray 設定例 Vim (.vimrc) / Neovim (init.vim) の場合 &#34; 指定したカラム位置に縦線を表示 set colorcolumn=80,100 highlight ColorColumn guibg=#333300 ctermbg=lightgray Neovim (init.lua) の場合 -- 指定したカラム位置に縦線を表示 vim.opt.colorcolumn = &#34;80,100&#34; vim.api.nvim_set_hl(0, &#34;ColorColumn&#34;, { bg = &#34;#333300&#34;, ctermbg = &#34;lightgray&#34; })"},{url:"/p/gwfweub/",title:"JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps)",date:"2013-05-22T00:00:00+09:00",body:"JSON 形式のテキストと Python オブジェクトの相互変換 (json.loads, json.dumps) Python には JSON フォーマットを扱うための json モジュールが標準搭載（Python 2.6 以降）されており、JSON 形式のテキストと、Python のオブジェクトを相互に変換することができます。 JSON 文字列 → Python オブジェクト (json.loads) JSON 形式の文字列データから、Python オブジェクトを作成するには json.loads 関数 を使用します。 import json data = json.loads(&#39;{&#34;key&#34;:&#34;value&#34;}&#39;) print(data[&#39;key&#39;]) #=&gt; &#39;value&#39; json.loads と似た関数に、json.load 関数がありますが、こちらは文字列ではなく JSON ファイルを読み込みます。 loads の末尾の s は、文字列を受け取ることを示しています。 参考: JSON 形式のテキストファイルを Python オブジェクトとして読み込む (json.load) Python オブジェクト → JSON 文字列 (json.dumps) 逆に、Python オブジェクトから JSON 形式のテキストを生成するには、json.dumps 関数 を使用します。 import json obj = {&#39;aaa&#39;:100, &#39;bbb&#39;:200} json_str = json.dumps(obj) print(json_str) 実行結果 {&#34;bbb&#34;: 200, &#34;aaa&#34;: 100} 整形して出力する (indent=2) 改行を入れた形で見やすく出力したい場合は、json.dumps() 関数の indent パラメータに、インデントのスペース数を指定します（Python 3.2 以降は、インデントに使用する文字列そのものを指定できるようになりました）。 obj = {&#39;aaa&#39;:100, &#39;bbb&#39;:200} json_str = json.dumps(obj, indent=2) print(json_str) 実行結果 { &#34;bbb&#34;: 200, &#34;aaa&#34;: 100 } キーでソートして出力する (sort_keys=True) デフォルトでは、json.dumps() は辞書オブジェクトの要素を追加順に出力します（Python 3.7 より前は不定でした）。 アルファベット順にキー名でソートして出力したい場合は、json.dumps() 関数の sort_keys パラメータを True に設定します。 print(json.dumps(obj, indent=2, sort_keys=True)) 実行結果 { &#34;aaa&#34;: 100, &#34;bbb&#34;: 200 } 日本語を Unicode エスケープしない (ensure_ascii=False) 日本語を含んだオブジェクトを json.dumps で文字列に変換すると、デフォルトで Unicode エスケープされます。 obj = {&#39;a&#39;: &#39;あいう&#39;} print(json.dumps(obj)) #=&gt; {&#34;a&#34;: &#34;\\u3042\\u3044\\u3046&#34;} これは、XSS などの脆弱性を防ぐためですが、使用用途が限られているのであれば、UTF-8 エンコーディングの日本語をそのまま出力してしまった方がわかりやすいです。 非 ASCII 文字の Unicode エンコーディングを停止するには、ensure_ascii=False オプションを指定します。 obj = {&#39;a&#39;: &#39;あいう&#39;} print(json.dumps(obj, ensure_ascii=False)) #=&gt; {&#34;a&#34;: &#34;あいう&#34;} （おまけ） JSON 文字列を整形する関数を作ってみる 次の pretty_json() 関数は、JSON 形式の文字列データを、きれいにインデントや改行を入れた形に整形します。 まず、json.loads で「JSON文字列→オブジェクト」の変換をしてから、json.dumps で「オブジェクト→JSONテキスト」と逆変換しています。 sample.py import json def pretty_json(json_text): &#34;&#34;&#34;JSON 文字列を読みやすく整形して返します。&#34;&#34;&#34; temp = json.loads(json_text) return json.dumps(temp, indent=2, sort_keys=True) s = &#39;{&#34;aaa&#34;:100, &#34;bbb&#34;:200, &#34;ccc&#34;:300}&#39; print(pretty_json(s)) 実行結果 { &#34;aaa&#34;: 100, &#34;bbb&#34;: 200, &#34;ccc&#34;: 300 } 次のステップとして、パラメーターに文字列ではない通常のオブジェクトを受け取った場合でも JSON 文字列に変換できるようにしてみます。 isinstance 関数を使うと、あるオブジェクトが文字列型 (str) かどうかを判別することができます。 下記の pretty_json() 関数は、JSON 文字列、あるいは任意の Python オブジェクトを受け取って、整形された JSON 文字列として返します。 import json def pretty_json(obj): temp = json.loads(obj) if isinstance(obj, str) else obj return json.dumps(temp, indent=2, sort_keys=True) json_str = &#39;{&#34;aaa&#34;:100, &#34;bbb&#34;:200, &#34;ccc&#34;:300}&#39; json_obj = {&#34;aaa&#34;:100, &#34;bbb&#34;:200, &#34;ccc&#34;:300} print(pretty_json(json_str)) # JSON 文字列も、 print(pretty_json(json_obj)) # オブジェクトもどちらも渡せる ちなみに、Python はコマンドラインで JSON テキストを整形するツール (json.tool) を提供 しているので、ローカルの JSON ファイルをササッと整形したいときにはこちらを使うと便利かもしれません。"},{url:"/p/tr3cmu5/",title:"Python でファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir)",date:"2013-05-08T00:00:00+09:00",body:"Python でファイル／ディレクトリの存在を確認する (os.path.exists, os.path.isfile, os.path.isdir) ファイルあるいはディレクトリが存在するかを調べる Python で、指定した名前のファイル、あるいはディレクトリが存在しているかを調べるには、os.path.exists 関数 を使用します。 シンボリックリンクに対して実行した場合、os.path.exists 関数は、リンク先のファイルの有無を調べます。 sample.txt という名前のファイルかディレクトリが存在するかを調べる import os if os.path.exists(&#39;sample.txt&#39;): print(&#39;Found!&#39;) ファイルの存在、ディレクトリの存在を調べる 前述の os.path.exists は、ファイルあるいはディレクトリの存在を調べますが、ファイルのみ、ディレクトリのみに絞って存在を調べたいときは、os.path.isfile 関数 や os.path.isdir 関数 を使用します。 import os if os.path.isfile(&#39;sample&#39;): print(&#39;sample というファイルが見つかりました&#39;) if os.path.isdir(&#39;sample&#39;): print(&#39;sample というディレクトリが見つかりました&#39;)"},{url:"/p/7pi429n/",title:"HTML 要素を中央寄せ／右寄せで表示する",date:"2013-05-01T00:00:00+09:00",body:"HTML 要素を中央寄せ／右寄せで表示する 水平方向の中央寄せ 幅 (width) の指定されたブロック要素に対して、margin-left、margin-right をともに auto に設定**すると、中央寄せで表示することができます。 あいうえお CSS div.center { display: block; /* div 要素はもともとブロック要素なので省略可 */ margin-left: auto; margin-right: auto; width: 100px height: 50px; background: blue; color: white; } HTML &lt;div class=&#34;center&#34;&gt;あいうえお&lt;/div&gt; img 要素などのインライン要素は、display: block でブロック要素として扱うことで、同様の方法で中央寄せできます。 HTML &lt;img style=&#34;display: block; margin: auto;&#34; src=&#34;sample.png&#34;&gt; 右寄せ ブロック要素を右寄せで表示するには、margin-left にだけ auto を指定します。 あいうえお .right { display: block; margin-left: auto; /* ...省略... */ } 縦方向の中央寄せ ある要素の display と vertical-align を下記のように設定しておくと、その子要素が縦方向に中央寄せされます。 外側のブロック要素の高さを height プロパティで指定する必要があることに注意してください。 上下の中央寄せ CSS div.center { display: table-cell; /* これと */ vertical-align: middle; /* これで子要素が中央寄せされる */ height: 100px; } div.center_item { text-align: center; background: pink; } HTML &lt;div class=&#34;center&#34;&gt; &lt;div class=&#34;center_item&#34;&gt;上下の中央寄せ&lt;/div&gt; &lt;/div&gt;"},{url:"/p/cqtwqgx/",title:"Python でリストを昇順ソート／降順ソートする (list.sort/sorted)",date:"2013-04-25T00:00:00+09:00",body:"Python でリストを昇順ソート／降順ソートする (list.sort/sorted) リストを昇順／降順ソートする (list.sort) 昇順ソート list オブジェクトの sort() メソッドを呼び出すと、要素が昇順ソートされます。 a = [3, 5, 2, 1, 4] a.sort() print(a) #=&gt; [1, 2, 3, 4, 5] sort() メソッドを使用すると、リスト自身の内容が変更されることに注意してください（破壊的メソッドです）。 なお、タプルは不変なので sort() メソッドは使えません（後述の sorted() 関数を使います）。 降順ソート sort() メソッドの reverse=True オプションを指定すると、降順ソートすることができます。 a = [3, 5, 2, 1, 4] a.sort(reverse=True) print(a) #=&gt; [5, 4, 3, 2, 1] ソート結果を新しいリストで取得する (sorted) list.sort メソッドの代わりに sorted 関数を使用すると、元のリストを変更せずに、ソートされた新しいリストを生成することができます。 &gt;&gt;&gt; a = [3, 5, 2, 1, 4] &gt;&gt;&gt; b = sorted(a) &gt;&gt;&gt; a [3, 5, 2, 1, 4] &gt;&gt;&gt; b [1, 2, 3, 4, 5] sorted 関数は、immutable なタプルに対しても適用することができます。 &gt;&gt;&gt; t = (3, 1, 2) &gt;&gt;&gt; sorted(t) [1, 2, 3] 独自クラスのオブジェクトのリストをソートする lt 演算子を定義する方法 独自クラスのオブジェクトのリストを list.sort メソッドや sorted 関数でソートできるようにするには、 __lt__ メソッドを実装します（Less Than (&lt;) の略です）。 次の Person クラスは、ソート時に age プロパティの値で大小比較するように実装しています。 ソート可能な Person クラス class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return(f&#34;{self.name}({self.age})&#34;) def __lt__(self, other): return self.age &lt; other.age if __name__ == &#34;__main__&#34;: p1 = Person(&#34;maku&#34;, 14) p2 = Person(&#34;chiko&#34;, 5) p3 = Person(&#34;ponyo&#34;, 8) persons = [p1, p2, p3] persons.sort() # __lt__ の実装に従ってソート for p in persons: print(p) 実行結果 chiko(5) ponyo(8) maku(14) 応用例として、age プロパティの値が等しい場合にさらに name プロパティの値で比較する、という実装は次のようになります（Python では文字列の大小比較も &lt; で行えます）。 def __lt__(self, other): if self.age == other.age: return self.name &lt; other.name return self.age &lt; other.age ソート実行時に reverse オプションを指定すれば、降順ソートに切り替えられます。 persons.sort(reverse=True) 定義済みの Person クラスに対して、後付けで比較メソッドを追加することもできます。 Person.__lt__ = lambda self, other: self.age &lt; other.age key パラメータを指定する方法 __lt__ メソッドを実装していないクラスのオブジェクトであっても、ソート時に key パラメータを指定すればソートが可能です。 次の例では、Person オブジェクトのリストを、age プロパティの値で昇順ソートするように指定しています。 persons.sort(key=lambda x: x.age) このようにプロパティの値をそのまま比較に使用する場合は、operator モジュールの attergetter を使用すると、より簡潔に記述できるようになります。 from operator import attrgetter persons.sort(key=attrgetter(&#39;age&#39;)) さらに次のようにすれば、age プロパティの値が等しい場合は、name プロパティの値で比較する、という指定が可能です。 persons.sort(key=attrgetter(&#39;age&#39;, &#39;name&#39;)) 参考 dictionary の要素をソートして出力する (sorted)"},{url:"/p/qqkggoz/",title:"Python で dictionary の要素をソートして出力する (sorted)",date:"2013-04-21T00:00:00+09:00",body:"Python で dictionary の要素をソートして出力する (sorted) キーでソートして出力 Python の dictionary の要素をキー順に取り出すには、dict.keys() メソッドで dictionary からキーの一覧を取り出し、それを sorted() 関数で昇順ソートしてループ処理します。 つまり、キーのリストをソートしているだけです。 キー名で昇順ソート &gt;&gt;&gt; d = {&#39;BBB&#39;: 200, &#39;AAA&#39;: 300, &#39;CCC&#39;: 100} &gt;&gt;&gt; for key in sorted(d.keys()): ... print(key, d[key]) AAA 300 BBB 200 CCC 100 キー名で降順ソートしたいときは、sorted() 関数に reverse=True パラメーターを指定します。 キー名で降順ソート &gt;&gt;&gt; d = {&#39;BBB&#39;: 200, &#39;AAA&#39;: 300, &#39;CCC&#39;: 100} &gt;&gt;&gt; for key in sorted(d.keys(), reverse=True): ... print(key, d[key]) CCC 100 BBB 200 AAA 300 値でソートして出力 sorted() 関数の key パラメーターをうまく使うと、dictionary の「値」によりソートされたキーを列挙できます。 次の例では、値の昇順 (100, 200, 300) でループ処理しています。 値で昇順ソート &gt;&gt;&gt; d = {&#39;BBB&#39;: 200, &#39;AAA&#39;: 300, &#39;CCC&#39;: 100} &gt;&gt;&gt; for key in sorted(d, key=lambda x:d[x]): ... print(key, d[key]) CCC 100 BBB 200 AAA 300 降順ソート (300, 200, 100) したいときは、sorted() 関数に reverse=True パラメーターを指定します。 値で昇順ソート &gt;&gt;&gt; d = {&#39;BBB&#39;: 200, &#39;AAA&#39;: 300, &#39;CCC&#39;: 100} &gt;&gt;&gt; for key in sorted(d, reverse=True, key=lambda x:d[x]): ... print(key, d[key]) AAA 300 BBB 200 CCC 100 参考 リストを昇順ソート／降順ソートする (list.sort, sorted) dictionary の内部的な要素順序を変更する (dict, OrderedDictionary) Python 3.7 以降は、dictionary への要素の追加順序が内部的に保持されるようになっています。"},{url:"/p/h3jqpp9/",title:"Python の set オブジェクトで集合演算を行う",date:"2013-04-21T00:00:00+09:00",body:"Python の set オブジェクトで集合演算を行う Python では、set オブジェクト同士を &amp; や | で演算することによって、簡単に集合演算を行うことができます。 a = {1, 2, 3, 4, 5} b = {3, 4, 5, 6, 7} # 両方に含まれるもの（積集合） s1 = a &amp; b # =&gt; {3, 4, 5} # いずれかに含まれるもの（和集合） s2 = a | b # =&gt; {1, 2, 3, 4, 5, 6, 7} # a にだけ含まれるもの s3 = a - b # =&gt; {1, 2} # b にだけ含まれるもの s4 = b - a # =&gt; {6, 7} # どちらか一方にだけ含まれるもの s5 = a ^ b # =&gt; {1, 2, 6, 7} 参考: 2 つのリストに重複する要素を抽出する（set と &amp;）"},{url:"/p/b85489c/",title:"Vundle をインストールして Vim のプラグイン環境を作る",date:"2013-04-07T00:00:00+09:00",body:"Vundle をインストールして Vim のプラグイン環境を作る Vundle とは Vundle をインストールすると、Vim のプラグインを :BundleInstall コマンドで簡単にインストールすることができるようになります。 Vundle のインストール 基本的には、以下のサイトの手順に従ってインストールするだけです。 https://github.com/VundleVim/Vundle.vim 下記のようにインストールすると、Vim のプラグインを ~/.vim/bundle ディレクトリ内で管理することができるようになります。 インストールしたプラグインを消す場合も、ディレクトリごと削除するだけなのでお手軽です。 Vundle のダウンロード $ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 本家サイトには、.vimrc に Vundle 用の設定を記述する方法が説明されていますが、個人的には、プラグイン関連の情報は別ファイル (~/vimrc_vundle.vim) で管理して ~/.vimrc から読み込むようにしています。 ~/.vimrc（Vundle 用の設定をインクルード） source ~/vundle_vimrc.vim ~/vundle_vimrc.vim（Vundle 用の設定） &#34;&#34;&#34; Enable vundle commands set nocompatible &#34; be iMproved, required filetype off &#34; required &#34; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() &#34; let Vundle manage Vundle, required Plugin &#39;VundleVim/Vundle.vim&#39; &#34; ★ &#34; ★ここにプラグインを追加していく &#34; ★ call vundle#end() &#34; required filetype plugin indent on &#34; required 上記のように設定して Vim を立ち上げ直すと、:BundleList、:BundleInstall、:BundleSearch、:BundleClean などのコマンドを実行できるようになります。 Vundle を使ったプラグインのインストール Vundle を使ってインストールしたいプラグインは、以下のように call vundle#begin() と call vundle#end() の間に Plugin コマンドで列挙していきます。 ここでは、モードラインを格好よく表示する、vim-powerline をインストールしてみます。 ~/vundle_vimrc.vim &#34;&#34;&#34; Enable vundle commands call vundle#begin() &#34; let Vundle manage Vundle, required Plugin &#39;VundleVim/Vundle.vim&#39; &#34; プラグインの追加 Plugin &#39;Lokaltog/vim-powerline&#39; call vundle#end() 上記のように列挙したプラグインを実際にインストールするには、もう一度 :BundleInstall コマンドを実行します。 逆に使わなくなったプラグインは :BundleClean コマンドで削除できます。 現在インストールされているプラグインを列挙するには、:BundleList コマンドを実行します。"},{url:"/p/r8vjhx2/",title:"XML の名前空間について",date:"2013-03-31T00:00:00+09:00",body:"XML の名前空間について 名前空間を宣言する XML の名前空間を宣言するには、任意の要素の開始タグで、 xmlns:&lt;NamespacePrefix&gt;=&#34;&lt;NamespaceName(URI)&gt;&#34; のような属性を指定します。この属性を指定した要素以下の要素でその名前空間を使用できるようになります。属性を宣言した要素自体でも使えるので、XML の root 要素で名前空間を宣言すれば、全ての要素でその名前空間が使えることになります。 &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;b:books xmlns:b=&#34;http://example.com/dtd/books&#34;&gt; &lt;b:book&gt; &lt;b:title&gt;Title 1&lt;/b:title&gt; &lt;b:author&gt;Author 1&lt;/b:author&gt; &lt;/b:book&gt; &lt;/b:books&gt; 上記の XML 文書の例では、Namespace prefix（名前空間接頭辞）は b で、Namespace Name (URI) は http://example.com/dtd/books が指定されています。 名前空間を使用する時は、例を見れば明らかですが、&lt;NamespacePrefix&gt;:&lt;LocalName&gt; のように要素名を指定します。 名前空間名の URI が指すリソースは存在しなくてよい 名前空間名として指定する URI は、あくまで一意な名前を指定するものであって、その URI が示す先に、何らかのリソースファイルが存在している必要はありません。 名前空間の接頭辞に使えない名前 要素名と同様に、名前空間の接頭辞 (Namespace prefix) にも、xml で始まる名前は付けられません。大文字にしてもダメです。例えば、以下のような Namespace prefix はすべて NG です。 名前空間プレフィックスの NG 例 xml_prefix xmlPrefix XmlPrefix XML_Prefix 名前空間の接頭辞の上書き 親要素で既に宣言されている Namespace prefix を子要素で宣言すると、その prefix は上書きされます。ただし、その子要素より上位の要素では、親要素の Namespace prefix の宣言が使用されます。 デフォルトの名前空間 名前空間を宣言するときに、接頭辞 (prefix) を省略して宣言すると、デフォルトの名前空間 (default namespace) の宣言になります。デフォルトの名前空間が宣言された要素以下の要素は、prefix を特に指定しなくても、その名前空間に属するとみなされます。 &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;note xmlns=&#34;http://example.com/dtd/note&#34;&gt; &lt;message&gt;Hello&lt;/message&gt; &lt;/note&gt; 上記の XML は、note 要素でデフォルトの名前空間が宣言されています。 以下のように記述したものと同じ意味を持ちます。 &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;n:note xmlns:n=&#34;http://example.com/dtd/note&#34;&gt; &lt;n:message&gt;Hello&lt;/n:message&gt; &lt;/n:note&gt; 属性の名前空間 名前空間接頭辞のない属性は、その要素に属するローカルな属性とみなされます。 ローカル属性の例 &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;n1:aaa xmlns:n1=&#34;http://example.com/n1&#34;&gt; &lt;n1:bbb attr=&#34;val&#34; /&gt; &lt;/n1:aaa&gt; 上記のように記述した場合、属性 attr は、n1:bbb 要素に属するローカルな属性とみなされます。特定の要素に属さない属性（グローバル属性）を指定したい場合は、属性名に Prefix を付ける必要があります。 グローバル属性の例 &lt;?xml version=&#34;1.0&#34; ?&gt; &lt;n1:aaa xmlns:n1=&#34;http://example.com/n1&#34; xmlns:n2=&#34;http://example.com/n2&#34;&gt; &lt;n1:bbb n2:attr=&#34;val&#34; /&gt; &lt;/n1:aaa&gt;"},{url:"/p/wobqnsc/",title:"Backbone.jsの使い方メモ",date:"2013-03-10T00:00:00+09:00",body:"Backbone.jsの使い方メモ Backbone.js の特徴 軽量（5KB くらい）な MVC ライブラリ。 MIT ライセンス。 DocumentClould の Jeremy Ashkenas 氏（CoffeeScript 作った人）によって作成。 Underscore.js が必須。他には jQuery などが必要（選択肢あり）。 SPI (Single Page Interface) の構築に最適。 使用実績: SoundCloud、DocumentCloud、Foursquare、LinkedIn Mobile、Pandora、Qiita。 js 使うための準備（backbone.js のロード） Backbone.js を使用するには、あらかじめ underscore.js や jQuery をロードしておく必要があります。 以下のサンプルでは、https://cdnjs.com から JS ファイルをロードしています。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;Backbone.js sample&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&#34;http://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.9.10/backbone-min.js&#34;&gt;&lt;/script&gt; &lt;script&gt; $(function() { &#39;use strict&#39;; var MyModel = Backbone.Model.extend({ defaults: { name: &#39;&#39; } }); var model = new MyModel(); model.set(&#39;name&#39;, &#39;Maku&#39;); alert(model.get(&#39;name&#39;)); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 必要な JavaScript ライブラリを、ローカルから読み込む場合は、以下のような感じ書いておけば大丈夫です。 ... &lt;script src=&#34;js/lib/jquery.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;js/lib/underscore.js&#34;&gt;&lt;/script&gt; &lt;script src=&#34;js/lib/backbone.js&#34;&gt;&lt;/script&gt; &lt;script&gt; ... &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Backbone.Router を実装する Backbone.Router の基本 Backbone.Router を使用すると、Ruby on Rails や CakePHP のように、URI をアクション（JavaScript の関数呼び出し）にマッピングすることができます。 URI のマッピングは、以下のような ハッシュフラグメント 部分をもとに行うため、画面遷移（Web サーバへのアクセス）を発生させずに内部状態管理ができるようになります。 https://example.com/index.html#users/12345/edit → editUser(12345) の呼び出し 独自の Router クラスは、下記のように Backbone.Router を継承することで定義します。 Backbone.Router.extend() に渡すオブジェクトの、routes プロパティで、URI マッピングを設定します。 var MyRouter = Backbone.Router.extend({ routes: { &#39;books&#39;: &#39;showAllBooks&#39;, // index.html#books &#39;books/:id&#39;: &#39;showBook&#39; // index.html#books/789 }, showAllBooks: function() { document.write(&#39;showAllBooks() was called&#39;); }, showBook: function(id) { document.write(&#39;showBook(&#39; + id + &#39;) was called&#39;); } }); URI の変更監視を開始するには以下のようにします。 new MyRouter(); Backbone.history.start(); routes プロパティで使用できるいろいろな記号 routes プロパティに設定するオブジェクトのキーには、ハッシュフラグメントとしてマッチさせる URI のパターンを指定しますが、ここには以下のような特殊な記号を使用できます。 URI パターンの論理的なセグメントの分割は、慣例としては / を使用します（部分的に別の記号を使うこともできますが、任意のパラメータを渡す場合に区切り文字が曖昧になって動かないケースもあるのでスラッシュを使っておくのが無難です）。 :param は、（スラッシュを含まない）任意の文字列にマッチし、ハンドラ関数のパラメータとして渡されます。 URI 中の任意の文字列は、正規表現として /w+ にマッチします（つまり、/ や - などの記号で終端します）。 routes: { &#39;users/:id&#39;: &#39;user&#39;, // &#39;#users/123abc&#39; で user(&#39;123abc&#39;) の呼び出し &#39;users/:id/edit&#39;: &#39;edit&#39;, // &#39;#users/123abc/edit&#39; で edit(&#39;123abc&#39;) の呼び出し &#39;AAA-:id-BBB&#39;: &#39;test&#39;, // &#39;#AAA-123-BBB&#39; で test(&#39;123&#39;) の呼び出し &#39;:def&#39;: &#39;def&#39; // &#39;#hello&#39; で def(&#39;hello&#39;) の呼び出し（&#39;#hello/123&#39; では呼ばれない） } *param は任意の文字列にマッチし、ハンドラ関数のパラメータとして渡されます。 :param との違いは、*param の場合は、スラッシュを含む任意の文字列にマッチするところです。 つまり、これは URI の最後の部分にしか指定できません。 routes: { &#39;download/*path&#39;: &#39;download&#39;, // &#39;#download/aa/bb/cc&#39; で download(&#39;aa/bb/cc&#39;) の呼び出し &#39;*path&#39;: &#39;defaultRoute&#39;, // &#39;#aa/bb/cc&#39; で defaultRoute(&#39;aa/bb/cc&#39;) の呼び出し } (optional) のように括弧で囲むと、その部分が省略された URI にも一致します。 URI でオプショナルなパラメータを指定できるようにしたい場合に使用できます。 var MyRouter = Backbone.Router.extend({ routes: { &#39;test(/aaa)&#39;: &#39;test&#39;, // &#39;#test&#39; あるいは &#39;#test/aaa&#39; で test() の呼び出し &#39;show(/:id)&#39;: &#39;show&#39; // &#39;#show&#39; で show()、&#39;#show/123&#39; で show(&#39;123&#39;) の呼び出し }, test: function() { console.log(&#39;test&#39;); }, show: function(id) { if (typeof id === &#39;undefined&#39;) { id = 0; // use the default ID } console.log(&#39;show: &#39; + id); } }); View 切り替え時に元の View のイベント処理を削除する Backbone の View を切り替えるときに、前に使用していた View のイベントハンドラ（events プロパティで指定したもの）を削除しないと、イベントハンドラが残っていて意図しない動作をすることがあります。 Router で View を切り替える前に、前の View に対して undelegateEvents() を呼び出してやることで、このような動作を抑制できます。 var currentView; var AppRouter = Backbone.Router.extend({ routes: { &#39;show/:id&#39;: &#39;showWord&#39;, &#39;edit/:id&#39;: &#39;editWord&#39;, }, showWord: function (id) { if (currentView) { currentView.undelegateEvents(); // 子要素も全て削除する場合 // currentView.$el.children().remove(); } currentView = new WordView({model: model}); }, editWord: function(id) { if (currentView) { currentView.undelegateEvents(); // 子要素も全て削除する場合 // currentView.$el.children().remove(); } currentView = new EditView({model: model}); }, }); Backbone.Model を実装する (1) Backbone.Model の基本 モデルオブジェクトには Backbone.Model を使う Backbone フレームワークにおけるモデルオブジェクトの作成には、Backbone.Model クラスを使用します。 var m1 = new Backbone.Model(); var m2 = new Backbone.Model({key1: &#39;value1&#39;, key2: &#39;value2&#39;}); // モデルの初期値を与えることも可能 Backbone.Model クラスは、内部的なモデルデータを指すプロパティ attributes（属性値）を持っています。 JavaScript の素のオブジェクトをモデルオブジェクトとして使うのとは異なり、Backbone.Model のインスタンスをモデルオブジェクトとして使用すると、以下のようなことを簡単に行えます。 属性値 (attributes) の取得、設定のための set()/get() の提供 属性値 (attributes) の変更通知（例えば、ビューが変更通知を受けて、再描画する） 属性値 (attributes) の永続化サポート サーバとのデータのやりとり モデルオブジェクトの属性値 は get()、set() で取得、設定する Backbone.Model のインスタンスは、内部的なモデルデータを指す attributes プロパティを持っていますが、通常はこのプロパティを参照してデータを操作するのではなく、get 関数、set 関数を使用して間接的に属性値を操作します。 var model = new Backbone.Model(); model.set(&#39;key1&#39;, &#39;value1&#39;); var name = model.get(&#39;key1&#39;); console.log(name); //=&gt; &#39;value1&#39; このように、間接的に属性値を変更することによって、変更時にイベント (change event) を発生させたり、validate 関数などを自動的に呼び出す仕組みになっています。 もちろん、現在の属性値を確認するために attributes オブジェクトを参照することは可能です。 var model = new Backbone.Model({key1: &#39;value1&#39;, key2: &#39;value2&#39;}); console.dir(model.attributes); // key1 value1 // key2 value2 Backbone.Model は、純粋なモデルオブジェクトとして使用できるように、ビューとは依存関係を持っていません。 一方で、イベント発生の仕組みを備えることによって、特定のビューとモデルを連携させることができるようになっています。 Backbone.Model を実装する (2) 独自モデルクラスの作成 Backbone.Model.extend() 関数を使うと、独自のモデルクラスを定義することができます。 // 最低限のモデルクラスの定義 var MyModel = Backbone.Model.extend(); // モデルのインスタンス化 var model = new MyModel({name: &#39;Maku&#39;}); console.log(model.get(&#39;name&#39;)); 独自のモデルクラスでは、データのデフォルト値（defaults プロパティ）や、モデルオブジェクト作成時の初期化関数（initialize プロパティ）などを定義することができます。 var MyModel = Backbone.Model.extend({ // デフォルト値 defaults: { // 下記に加え、コンストラクタで指定された key &amp; value ペアが // このモデルの属性値として保持される。 key1: &#39;default1&#39;, key2: &#39;default2&#39; }, // 初期化処理 initialize: function() { // initialize() が呼び出される時点で、デフォルト値は既に設定されているので、 // 下記はデフォルト値を上書きすることになる。 // コンストラクタで与えられた属性値に関しても同様。 this.set(&#39;key1&#39;, &#39;init1&#39;); } }); var model = new MyModel(); console.dir(model.attributes); // key1 =&gt; &#39;init1&#39; // key2 =&gt; &#39;value2&#39; もちろん、独自モデルクラスのコンストラクタ呼び出しにも、初期値を与えることができます。 var model = new MyModel({key3: &#39;value3&#39;, key4: &#39;value4&#39;}); Backbone.Model を実装する (3) モデルの変更イベントをハンドルする Backbone.Model オブジェクトに値をセットすると、Backbone フレームワーク内で change イベントが発生するようになっています。 参考: Backbone.js の 組み込みイベント一覧 Backbone.Model オブジェクトの change イベントに任意のコールバック関数をバインドすることで、モデルの変更を監視することができます。 var model = new Backbone.Model(); model.on(&#39;change&#39;, function(obj) { console.log(&#39;changed to &#39; + obj.get(&#39;x&#39;)); }); model.set({x:100}); //=&gt; &#39;change&#39; イベントが発生する 特定の属性値のみの変更を監視するには、以下のようにイベント名の後ろに属性名のプレフィックスを付けます。 下記の例では、属性 x のみの変更を監視しています。 model.on(&#39;change:x&#39;, function(obj, x) { console.log(&#39;changed to &#39; + x); }); model.set({x:100}); コールバック関数の第 2 引数に、指定した属性の変更後の値が渡されます。 Backbone.Collection を実装する コレクションクラスの定義 Backbone.Collection クラスを拡張 (extend) すると、複数のモデルオブジェクトを保持するコレクションクラスを定義することができます。 // Book モデルの定義 var Book = Backbone.Model.extend(); // BookCollection コレクションの定義 var BookCollection = Backbone.Collection.extend({ model: Book, }); 上記の例では、Book モデルを格納するための、BookCollection コレクションを定義しています。 Backbone.Collection の model プロパティには、そのコレクションが格納するモデルクラスを指定します。 コレクションクラスを使ってみる コレクションにモデルオブジェクトを追加するには、add メソッドに追加したいモデルオブジェクトを渡します。 配列で複数のモデルオブジェクトを追加することもできます。 var books = new BookCollection(); // モデルを 1 つ追加する books.add({title: &#39;Title A&#39;, author: &#39;Author A&#39;}); // 複数のモデルを追加する books.add([ {title: &#39;Title A&#39;, author: &#39;Author A&#39;}, {title: &#39;Title B&#39;, author: &#39;Author B&#39;}, {title: &#39;Title C&#39;, author: &#39;Author C&#39;} ]); コレクションに対してモデルを追加された場合のイベントをハンドルするには以下のようにします。 複数のモデルオブジェクトを、配列の形で add() メソッドで追加した場合は、追加したモデルオブジェクトの数だけ add イベントが発生します。 var books = new BookCollection(); books.on(&#39;add&#39;, function(book) { alert(book.get(&#39;title&#39;) + &#39; added&#39;); }); モデルオブジェクトは次のようにインデックス指定で取得できます。 var books = new BookCollection(); ... var book = books.at(0); コレクションの各要素をループで処理するには次のようにします。 collection.forEach(function(model) { console.log(model.get(&#39;name&#39;)); }); for (var i = 0; i &lt; collection.length; ++i) { var model = collection.at(i); console.log(model.get(&#39;name&#39;)); } Model/Collection の Web サーバとの同期: URL 決定の仕組み Backbone.Model/Collection には、Web サーバと通信してモデル情報をやりとりするための API が実装されています。 Backbone.Model fetch() &hellip; Web サーバからのモデル取得 (GET) save() &hellip; Web サーバへのモデル保存/更新/部分更新 (POST/PUT/PATCH) destory() &hellip; Web サーバ上のモデル削除 (DELETE) Backbone.Collection fetch() &hellip; Web サーバからのコレクション取得 (GET) create(model) &hellip; Web サーバへのモデル保存（同時にコレクションへモデル追加） (POST) Web サーバ側では、上記の HTTP メソッドに対応する JSON ベースの RESTful API を実装しておく必要があります。 モデルの同期系メソッドを呼び出した場合に、実際にどの URL に対して HTTP リクエストを送るかは、以下のようなアルゴリズムによって決定されます。 モデルクラスの url 属性が設定されている場合は、それが絶対パスとして使われる（関数でもよい）。 モデルクラスに urlRoot 属性が設定されている場合は、それがベースパスとなり、末尾に id 属性が付加された URL が使われる。 コレクションオブジェクトにモデルオブジェクトが所有されている場合は、コレクションクラスの url 属性がベースパスとなり、末尾に id 属性が付加された URL が使われる（「所有」というのは、collection.add(model) のように実行されていること） 上記のいずれにも当てはまらない場合はエラー。 コレクションの同期系メソッドを呼び出した場合は以下のように振る舞います。 コレクションクラスの url 属性が設定されている場合は、それが使われる（関数でもよい）。 url 属性が設定されていない場合はエラー発生。 ほとんどのケースでは、通常は以下のように定義しておけば問題ありません。 モデルクラスの定義: モデルクラスの urlRoot 属性 にベース URL を指定しておく（アクセス先は [model.urlRoot]/[model.id] となる）。 コレクションクラスの定義: コレクションクラスの url 属性 に URL を指定しておく（アクセス先は [collection.url] となる）。 各メソッドと、アクセス先 URL、HTTP メソッドの組み合わせは以下のような感じになります。 取得 model.fetch() &hellip; GET &lt;base_url&gt;/&lt;モデルの id 属性&gt; collection.fetch() &hellip; GET &lt;base_url&gt;/ 更新 model.save() &hellip; PUT &lt;base_url&gt;/&lt;モデルの id 属性&gt; 作成 model.save() &hellip; POST &lt;base_url&gt;/ collection.create(model) &hellip; POST &lt;base_url&gt;/ 部分更新 model.save() &hellip; PATCH &lt;base_url&gt;/ 破棄 model.destory() &hellip; DELETE &lt;base_url&gt;/&lt;モデルの id 属性&gt; &lt;base_url&gt; は一般的に コレクションクラスの url プロパティ です。 モデルオブジェクトからメソッド呼び出しした場合は、&lt;base_url&gt; として モデルクラスの urlRoot プロパティ を使用することもできます。 以下は、実際に GET リクエストでモデル情報を取得するサンプルです。 // Memo モデルの定義 var Memo = Backbone.Model.extend({ urlRoot: &#39;/api/memos&#39;, }); // Memo データの取得 var memo = new Memo({id: &#39;AAA&#39;}); memo.fetch(); 上記の fetch() 呼び出しにより、HTTP GET リクエストが /api/memos/AAA に対して発行されます。 現在のモデルがどの URL からデータを取得するかは、モデルの url() メソッドを使って確認できます。 console.log(memo.url()); //=&gt; /api/memos/AAA 参考になるコード（Backbone 1.1.0 の Backbone.Model.fetch() の抜粋） fetch: function(options) { ... return this.sync(&#39;read&#39;, this, options); }, モデルの fetch() を呼ぶと、最後に Backbone.Model.sync() が呼ばれます。 Backbone.Collection.fetch() の抜粋 fetch: function(options) { ... return this.sync(&#39;read&#39;, this, options); }, コレクションの fetch() を呼ぶと、最後に Backbone.Collection.sync() が呼ばれます。 Backbone.Model.sync() の抜粋 sync: function() { return Backbone.sync.apply(this, arguments); }, Backbone.Model.sync() も Backbone.Collection.sync() も、Backbone.sync() を呼び出すように実装されています。 Backbone.sync() の抜粋 Backbone.sync = function(method, model, options) { ... if (!options.url) { params.url = _.result(model, &#39;url&#39;) || urlError(); } ... HTTP リクエストで使われる URL は、上記の部分で決められています。 Underscore.js の result() メソッドにより、url() メソッドの結果、あるいは url プロパティの値そのものを最終的な URL として取得しています。 Backbone.Model.url() デフォルト実装 url: function() { var base = _.result(this, &#39;urlRoot&#39;) || _.result(this.collection, &#39;url&#39;) || urlError(); if (this.isNew()) return base; return base + (base.charAt(base.length - 1) === &#39;/&#39; ? &#39;&#39; : &#39;/&#39;) + encodeURIComponent(this.id); } Backbone.Model にはデフォルトの url() 実装があり、上記のように、モデルの urlRoot 属性、あるいはコレクションに所有されている場合は、コレクションの url 属性がベース URL として使用されます。 このロジックは、モデルオブジェクトの同期系メソッドを呼び出した際に実行されます。 Model/Collection の Web サーバとの同期: 取得 (1) model.fetch() で Web サーバからコレクションデータを取得する モデルオブジェクトの fetch() メソッドを使用すると、Web サーバから取得した情報を使って、モデルオブジェクトを初期化することができます。 通常、モデルオブジェクトに id 属性を指定した上で fetch() を呼び出すことにより、特定の ID を持つモデルの情報を取得します。 ここでは、id=AAA であるモデル情報を、http://localhost:3000/api/memos/AAA から取得することを考えます。 Web サーバは、以下のように JSON データを返すように準備されている必要があります。 $ curl http://localhost:3000/api/memos/AAA { &#34;id&#34;: &#34;AAA&#34;, &#34;title&#34;: &#34;タイトル1&#34;, &#34;content&#34;: &#34;本文1&#34;, &#34;created&#34;: &#34;2014-01-12T10:03:00.009Z&#34; } モデル情報取得のためのコードは以下のようになります。 // Memo モデルの定義 var Memo = Backbone.Model.extend({ urlRoot: &#39;http://localhost:3000/api/memos&#39;, }); // Memo データの取得 var memo = new Memo({id: &#39;AAA&#39;}); memo.fetch({ success: function(memo) { console.log(memo.get(&#39;id&#39;)); //=&gt; &#39;AAA&#39; console.log(memo.get(&#39;title&#39;)); //=&gt; &#39;タイトル1&#39; } }); collection.fetch() で Web サーバからコレクションデータを取得する コレクションオブジェクトの fetch() を呼び出すことで、複数のモデル情報を Web サーバから取得して、コレクションに格納することができます。 ここでは、複数のモデル情報を http://localhost:3000/api/memos/ から取得することを考えます。 Web サーバは、下記のような配列の JSON データを返すように準備されている必要があります。 配列の各要素は、モデルオブジェクトを構成する情報を含んでいます。 $ curl http://localhost:3000/api/memos/ [ { &#34;id&#34;: &#34;AAA&#34;, &#34;title&#34;: &#34;Title1&#34;, &#34;content&#34;: &#34;Content1&#34;, &#34;created&#34;: &#34;2014-01-13T12:31:42.144Z&#34; }, { &#34;id&#34;: &#34;BBB&#34;, &#34;title&#34;: &#34;Title2&#34;, &#34;content&#34;: &#34;Content2&#34;, &#34;created&#34;: &#34;2014-01-13T12:31:42.144Z&#34; }, { &#34;id&#34;: &#34;CCC&#34;, &#34;title&#34;: &#34;Title3&#34;, &#34;content&#34;: &#34;Content3&#34;, &#34;created&#34;: &#34;2014-01-13T12:31:42.144Z&#34; } ] コレクション情報取得のためのコードは以下のようになります。 // Memo モデルクラスの定義 var Memo = Backbone.Model.extend(); // MemoCollection コレクションクラスの定義 var MemoCollection = Backbone.Collection.extend({ model: Memo, url: &#39;http://localhost:3000/api/memos&#39;, }); // コレクションの取得 var collection = new MemoCollection(); collection.fetch({ success: function(col) { console.log(col.toJSON()); } }); model.fetch() 時の処理の流れ あるモデルの fetch() を呼び出してサーバ上のデータと同期しようとするとき、以下のような流れで処理が進みます。 モデルオブジェクトの fetch() を呼び出す。 Model.sync() が呼び出され、model.url() が返す URL に対して GET リクエストを発行する。 Model.sync() のデフォルト実装は Backbone.sync() 呼び出しへのプロキシとなっていて、このとき CRUD 操作を表すパラメータである method に 'read' が指定されるため、それとマッピングされている HTTP GET リクエストが発行されることになる。 取得に成功した場合 モデルクラスの parse() が呼び出される。必要ならばここでサーバからのレスポンスを加工したうえでモデルにセットできる。 parse() の戻り値が model.set() でセットされる。内容が変更される場合は、モデルの 'change' イベントが発生する。 model.fetch() の呼び出し時に success 関数を指定している場合は、それが呼び出される。 モデルの 'sync' イベントが発生する。 取得に失敗した場合 model.fetch() の呼び出し時に error 関数を指定している場合は、それが呼び出される。 モデルの 'error' イベントが発生する。 model.fetch() の流れを追ってみる // Backbone.sync() でログ出力する var orgSync = Backbone.sync; Backbone.sync = function(method, model, options) { console.log(&#39;Backbone.sync() method=&#39; + method); orgSync(method, model, options); // デフォルト実装を呼び出し }; // Memo モデルクラスの定義 var Memo = Backbone.Model.extend({ urlRoot: &#39;http://localhost:3000/api/memos&#39;, parse: function (resp, options) { console.log(&#39;parse&#39;); return resp; } }); // Memo データの取得 var memo = new Memo({id: &#39;AAA&#39;}); memo.fetch({ success: function(model, resp, options) { console.log(&#39;success&#39;); }, error: function(model, resp, options) { console.log(&#39;error&#39;); } }); // モデルのイベントハンドラ memo.on(&#39;change&#39;, function() { console.log(&#39;EVENT(change)&#39;); }); memo.on(&#39;sync&#39;, function() { console.log(&#39;EVENT(sync)&#39;); }); memo.on(&#39;error&#39;, function() { console.log(&#39;EVENT(error)&#39;); }); 実行結果 // model.fetch() に成功した場合 Backbone.sync() method=read parse EVENT(change) success EVENT(sync) // model.fetch() に失敗した場合 Backbone.sync() method=read error EVENT(error) collection.fetch() 時の処理の流れ コレクションオブジェクトの fetch() を呼び出して、サーバ上のデータと同期しようとするときも、モデルオブジェクトの fetch() と同様の流れで処理が進みます。 collection.fetch() の流れを追ってみる // Backbone.sync() でログ出力する var orgSync = Backbone.sync; Backbone.sync = function(method, model, options) { console.log(&#39;Backbone.sync() method=&#39; + method); orgSync(method, model, options); // デフォルト実装を呼び出し }; // Memo モデルクラスの定義 var Memo = Backbone.Model.extend({ parse: function (resp, options) { console.log(&#39;parse&#39;); return resp; } }); // MemoCollection コレクションクラスの定義 var MemoCollection = Backbone.Collection.extend({ model: Memo, url: &#39;http://localhost:3000/api/memos&#39;, }); // コレクションの取得 var collection = new MemoCollection(); collection.fetch({ success: function() { console.log(&#39;success&#39;); }, error: function() { console.log(&#39;error&#39;); } }); // コレクションのイベントハンドラ collection.on(&#39;all&#39;, function(e) { console.log(&#39;EVENT &#39; + e); }); 実行結果 // collection.fetch() に成功した場合 Backbone.sync() method=read parse parse parse EVENT add EVENT add EVENT add EVENT sort success EVENT sync // collection.fetch() に失敗した場合 Backbone.sync() method=read error EVENT error ここでは、コレクションデータとして 3 つ分のモデルデータを受信しているため、モデルクラスの parse() メソッドや、コレクションへの追加イベント (add) が 3 回ずつ発生しています。 Model/Collection の Web サーバとの同期: 取得 (2) JSON ファイルをロード Backbone.Model や Backbone.Collection の fetch() メソッドは、単純な JSON ファイルからデータを取得することもできます。 モデルに対して POST/PUT/DELETE メソッドなどに対応した RESTful な操作の必要がない場合は、単純なデータを JSON ファイルにしてしまうのもひとつの手です。 やり方は、モデルまたはコレクションの fetch() によって GET しにいく URL に、JSON 形式のファイルを置いておくだけです。 例: Word モデルに data/word1.json ファイルの内容をロードする data/word1.json { &#34;jp&#34;: &#34;りんご&#34;, &#34;en&#34;: &#34;apple&#34; } // Word モデルクラスの定義 var Word = Backbone.Model.extend({ urlRoot: &#39;./data&#39; }); // data/word1.json の読み込み var word = new Word({id: &#39;word1.json&#39;}); word.fetch({ success: function(word) { console.log(word.get(&#39;jp&#39;), word.get(&#39;en&#39;)); }, error: function() { console.log(&#39;Load error&#39;); } }); 例: WordCollection コレクションに data/words.json ファイルの内容をロードする 配列データの入った JSON ファイルを用意しておけば、コレクションにそのままロードできます。 data/words.json [ { &#34;jp&#34;: &#34;りんご&#34;, &#34;en&#34;: &#34;apple&#34; }, { &#34;jp&#34;: &#34;バナナ&#34;, &#34;en&#34;: &#34;banana&#34; } ] // Word モデルクラス、WordCollection クラスの定義 var Word = Backbone.Model.extend({}); var WordCollection = Backbone.Collection.extend({ model: Word, url: &#39;data/words.json&#39; }); // data/words.json の読み込み var words = new WordCollection(); words.fetch({ success: function(col) { col.forEach(function(w) { console.log(w.get(&#39;jp&#39;), w.get(&#39;en&#39;)); }); }, error: function() { console.log(&#39;Fetch error&#39;); } }); Model/Collection の Web サーバとの同期: 取得 (3) モデルのランダム取得機能を作る 下記のサンプルでは、単語データを表す Word モデルを定義しています。 urlRoot がセットされているので、Word#fetch() を呼び出すことで api/words/[id] という URL から GET リクエストでデータを取得できます。 var Word = Backbone.Model.extend({ urlRoot: &#39;api/words/&#39; }); var word = new Word({id: &#39;apple&#39;}); word.fetch({ //=&gt; GET api/words/apple success: function(w) { console.log(w.jp + &#39; &#39; + w.en); } }); 明示的に取得するデータの id を指定できる場合はこれでよいのですが、ここでは id を指定せずに、ランダムに単語データを取得する randomFetch() メソッドを追加してみます。 サーバ側に、あらかじめランダムな単語データを返す RESTful API が定義されていると仮定します（URL は api/random とします）。 Word.prototype.randomFetch = function(options) { options.url = &#39;api/random&#39;; this.fetch(options); }; var word = new Word(); word.randomFetch({ //=&gt; GET api/random success: function(w) { console.log(w.jp + &#39; &#39; + w.en); } }); もともと、Model#fetch() メソッドには、オプションパラメータとしてアクセス先の URL を指定できる機能があります。 これを指定すると、urlRoot で指定した URL よりも優先されて使用されます。 上記では、その URL を api/random に設定して fetch() メソッドを呼び出すようにしています。 Model/Collection の 永続化処理のカスタマイズ モデルオブジェクトの fetch() や、save()、destory() メソッドを呼び出すと、Backbone.sync() メソッドが呼び出されるようになっており、この中で、RESTful な Web API を想定した通信が行われます。 Backbone.sync に任意の関数を設定すれば、永続化処理をカスタマイズすることができます。 例えば、RESTful API 呼び出しではなく、sessionStorage にモデル情報を保存するようなことができます。 また、sync() メソッドはプロトタイプチェインの仕組みに従って呼び出されるため、モデルクラスごとに永続化処理をカスタマイズすることもできます。 // Backbone 全体の永続化処理をカスタマイズ Backbone.sync = function(method, model, options) { ... }; // モデルクラス、コレクションクラスごとに永続化処理をカスタマイズ YourModel.prototype.sync = function(method, model, options) { ... }; YourCollection.prototype.sync = function(method, model, options) { ... }; Backbone.View を実装する (1) 独自ビュークラスの作成 Backbone.View は、ある DOM 要素の描画内容を定義する役割を果たします。 独自の View クラスを作成するには、Backbone.View.extend() を使って Backbone.View を継承します（Model や Router の継承方法と同様です）。 var MyView = Backbone.View.extend({ el: &#39;#output&#39; }); Backbone.View オブジェクトは、必ず 1 つの el プロパティを持ち、描画ターゲットとなる DOM 要素を参照します。 上記の例では、#output という ID を持つ要素を描画対象としています。 el プロパティは、View オブジェクトを生成するときに指定することもできます。 var view = new MyView({el: &#39;#output&#39;}); View で実際にどのように描画を行うか（どう HTML 要素を組み立てるか）は、render() メソッドで定義します。 el プロパティで参照設定した要素は、$el プロパティで jQuery オブジェクトとして参照できるようになっているため、render() メソッドは $el を使って実装するのがお手軽です。 var MyView = Backbone.View.extend({ el: &#39;#output&#39;, render: function() { this.$el.html(&#39;&lt;h1&gt;Hello&lt;/h1&gt;&#39;); return this; } }); var view = new MyView(); view.render(); 上記の例では、明示的に View オブジェクトの render() メソッドを呼び出すことにより、対象の要素に Hello というメッセージを表示しています。 View オブジェクトを生成したときに、自動的に render() メソッドを呼び出すようにするには、以下のように initialize() メソッドを定義します。 var MyView = Backbone.View.extend({ ... initialize: function() { this.render(); } ... }); var view = new MyView(); // 自動的に描画される Backbone.View を実装する (2) el プロパティの設定方法いろいろ Backbone.View オブジェクトの el プロパティは、以下のいずれかの方法で指定し、既存の DOM 要素を参照するように設定します。 CSS セレクタで指定するのが一般的です。 el: '#elem' &hellip; CSS のセレクタ文字列で指定 el: $('#elem') &hellip; jQuery オブジェクトで指定 el: document.getElementById('elem') &hellip; DOM 要素への参照を直接指定 el プロパティを設定しただけで、$el プロパティとして jQuery オブジェクトを参照できるようになるのは、内部的に呼び出される Backbone.View.setElement() の中で以下のように設定されているからです。 Backbone.View.setElement() 抜粋 this.$el = element instanceof Backbone.$ ? element : Backbone.$(element); this.el = this.$el[0]; 要するに、el プロパティに設定した要素は、どんな指定方法をした場合でも、 this.$el で jQuery オブジェクトとして参照できる this.el で先頭の DOM 要素を参照できる ということになります。 Backbone.View を実装する (3) el 要素以下で発生するイベントをハンドルする Backbone.View オブジェクトの、events プロパティを設定しておくと、click/dblclick/submit/mouseover などのイベントを簡単にイベントハンドラに割り当てられます。 イベントのマッピングは、以下のようなキー＆バリューの形で定義します。 &#34;&lt;イベント名&gt; &lt;CSSセレクタ&gt;&#34;: &#34;&lt;ハンドラ名&gt;&#34; 下記の例では、$el 以下に生成した button 要素のクリックイベントをハンドルしています。 var MyView = Backbone.View.extend({ initialize: function() { this.render(); }, render: function() { this.$el.html(&#39;&lt;button&gt;Test&lt;/button&gt;&#39;); return this; }, events: { &#39;click button&#39;: &#39;onClicked&#39; }, onClicked: function(event) { alert(&#39;Hello&#39;); } }); var view = new MyView({el: &#39;#output&#39;}); view.render(); events プロパティによってマッピングすることのできるイベントは、el 要素以下の要素で発生するイベントであることに注意してください。 Backbone.View を実装する (4) Model の内容を View で描画する ビューにモデルを関連付ける モデルの内容を、ビューで描画するには、何らかの方法でモデルオブジェクトをビューに設定する必要があります。 以下の例では、ビューのコンストラクタでモデルオブジェクトを渡し、model プロパティとして設定しています。 // モデルの定義 var MyModel = Backbone.Model.extend({ defaults: { &#39;message&#39;: &#39;Hello&#39; } }); // ビューの定義 var MyView = Backbone.View.extend({ el: &#39;#output&#39;, initialize: function() { this.render(); }, render: function() { this.$el.text(this.model.get(&#39;message&#39;)); return this; } }); // インスタンス生成 var model = new MyModel(); var view = new MyView({model: model}); 上記の例からも分かるように、ビューオブジェクトを生成するときに指定した model プロパティは、ビュークラスの中で、this.model で参照できるようになっています。 モデルの変化時に自動的にビューを再描画する モデルの値が変化したとき（set メソッドを呼び出したとき）に、自動的にビューの render メソッドを呼び出すようにするには、Backbone.Model の change イベントに Backbone.View の render メソッドをバインドします。 下記の例では、MyView は最初に MyModel のデフォルト値である Hello を表示していますが、2 秒後に MyModel の値が World に変更され、それに連動して自動的に MyView の表示が切り替わるようになっています。 var MyModel = Backbone.Model.extend({ defaults: { &#39;message&#39;: &#39;Hello&#39; } }); var MyView = Backbone.View.extend({ el: &#39;#output&#39;, initialize: function() { // モデルの変化時に render() を呼ぶ this.model.on(&#39;change&#39;, this.render, this); this.render(); }, render: function() { this.$el.text(this.model.get(&#39;message&#39;)); return this; } }); var model = new MyModel(); var view = new MyView({model: model}); // 2 秒後にモデルの内容を変更 =&gt; 自動的にビューが再描画される setTimeout(function() { model.set({message: &#39;World&#39;}); }, 2000);"},{url:"/p/wai79fn/",title:"GENA と SSDP プロトコルを理解する",date:"2012-12-25T00:00:00+09:00",body:`GENA と SSDP プロトコルを理解する 概要 SSDP (Simple Service Discovery Protocol) は、LAN 内のデバイスが提供しているサービスを発見したり、サービスがネットワークに参加したことを通知したりするプロトコルです。 SSDP 自体はシンプルなプロトコルですが、DLNA などで使われている、機器発見プロトコルである UPnP の一部として利用されています。 SSDP は、以下のようなヘッダで始まる HTTP を拡張したような UDP ベースのプロトコルです。M-SEARCH メソッド は、ネットワーク内のサービスを SSDP クライアントが能動的に発見しにいくときに使用します。 SSDP メッセージのフォーマット M-SEARCH * HTTP/1.1 \\r\\n ヘッダ1: ... \\r\\n ヘッダ2: ... \\r\\n ヘッダ3: ... \\r\\n \\r\\n SSDP では、内部で GENA (General Event Notification Architecture) で定義されているメッセージフォーマットも使用しており、こちらは、 サービス（機器）がネットワークに参加した (ssdp:alive) サービス（機器）がネットワークから脱退した (ssdp:byebye) などの Notify をマルチキャストするために使用されます。 GENA メッセージのフォーマット NOTIFY * HTTP/1.1 \\r\\n ヘッダ1: ... \\r\\n ヘッダ2: ... \\r\\n ヘッダ3: ... \\r\\n \\r\\n SSDP では、以下のようなアドレス、ポート番号にメッセージを UDP でマルチキャストしましょうね、と決めています（ポート番号については、正式には UPnP の世界で決まっているのかも）。 239.255.255.250:1900 サービスの識別 SSDP で検出するサービスは、以下の情報で識別されます。 ユニークサービスネーム URI USN ヘッダで指定 サービスタイプ URI ssdp:discover リクエストの場合は ST ヘッダで指定 ssdp:alive、ssdp:byebye リクエストの場合は NT ヘッダで指定 「ユニークサービスネーム」はサービスを一意に特定する ID になっている必要があるため、通常は UUID を組み合わせて設定されます。 「サービスタイプ」はサービスのカテゴリのようなものであり、どのような形式の URI を入れるかは、SSDP では規定していません（DLNA の世界では、サービスタイプにどのような値を指定するかが規定されています）。 ☝️ コラム（ST ヘッダと NT ヘッダ） サービスタイプは、ssdp:discover リクエストの場合は ST ヘッダで指定しますが、ssdp:alive リクエスト、ssdp:byebye リクエストの場合は NT ヘッダで指定します。 これは、ssdp:alive、ssdp:byebye リクエストが GENA のメッセージフォーマットを採用しており、その中の必須で NT ヘッダをサービスタイプを指定するためのフィールドとして使い回しているからです。 分かりにくいですね。。。 本来ならば、SSDP は GENA と独立させて、スッキリと定義された方がよかったように思います。 まぁ、いろいろ事情があったんでしょう。 リクエストの種類 Discovery Requests (M-SEARCH method) ssdp:discover リクエスト &ndash; サービスの発見 ssdp:all リクエスト &ndash; 全てのサービスの発見 Presence Announcements (GENA&rsquo;s NOTIFY method) ssdp:alive リクエスト &ndash; サービスの参加を通知 ssdp:byebye リクエスト &ndash; サービスの脱退を通知 Presence Announcements に分類されている、ssdp:alive リクエストと、ssdp:byebye リクエストは、GENA の NOTIFY メソッドのフォーマットで送信されます。 ssdp:discover リクエスト／レスポンス ssdp:discover リクエストは、「～のサービスを提供するデバイスはいますかぁ？」というサービス発見のための要求です。 ssdp:discover（リクエスト）の例 M-SEARCH * HTTP/1.1 HOST: 239.255.255.250:1900 MAN: &#34;ssdp:discover&#34; ST: your:serviceType 1行目の Request URI には * を指定する。 MAN ヘッダには ssdp:discover を指定する。 ST (Service Type) ヘッダは必須で、検索したいサービスタイプを指定する。 ssdp:discover にはレスポンスがあります。ssdp:discover リクエストを受信したサービスは、指定されたサービスタイプが自分に一致する場合は、UDP ユニキャストで以下のようなレスポンスを返します。 ssdp:discover（レスポンス）の例 HTTP/1.1 200 OK USN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6 ST: your:serviceType LOCATION: http://192.168.1.101:53456/ CACHE-CONTROL: max-age = 3600 USN ヘッダは必須。 ST (Service Type) ヘッダは必須。 サービスのロケーションを表す、Location ヘッダか、AL ヘッダを含んでいる必要がある。 キャッシュの保持期間を示す、CACHE-CONTROL: max-age ヘッダか、Expires ヘッダを含むべき。どちらのヘッダも含まれていない場合は、SSDP クライアントはそのサービスの情報をキャッシュしない。 SSDP クライアントは、受信したサービスの情報をキャッシュに保存して使い回します。 キャッシュには以下のような情報を保持します。 サービス ID（USN ヘッダ） サービスタイプ（ST ヘッダ） サービスの場所 (Location or AL ヘッダ） キャッシュの有効期限（秒数）（Expire or Cache-Control: ヘッダ） ssdp:all リクエスト／レスポンス ssdp:all リクエストは、ssdp:discover リクエストの特殊版で、サービスタイプ（ST ヘッダ）として ssdp:all を指定したものです。 ssdp:all（リクエスト）の例 M-SEARCH * HTTP/1.1 HOST: 239.255.255.250:1900 MAN: &#34;ssdp:discover&#34; ST: ssdp:all ★ここだけ特殊 ssdp:all リクエストを受信したサービス提供機器は、必ずレスポンスを返します。 レスポンスの内容は、ssdp:discover リクエストのレスポンスと同様なので省略します。 ssdp:all リクエストは、主に Network analysis tool などが利用します。 ssdp:alive リクエスト ssdp:alive リクエストは、以下のような場合にマルチキャストされます。 自分（サービス）が新しくネットワークに参加したとき キャッシュして欲しい時間情報 (Expires) が変化したとき サービスのロケーション (Location) が変化したとき ssdp:alive リクエストのメッセージ形式は、GENA のフォーマットを利用しています。 GENA でオプショナルなヘッダとして定義されている NTS (Notification Sub-Type) ヘッダの値を ssdp:alive として設定したものが ssdp:alive リクエストとして用いられます。 ssdp:alive（リクエスト）の例 NOTIFY * HTTP/1.1 HOST: 239.255.255.250:1900 USN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6 NT: your:serviceType NTS: ssdp:alive CACHE-CONTROL: max-age = 7393 LOCATION: http://192.168.1.101:53456/ NT (Notification Type) ヘッダにはサービスタイプを設定します（形式は任意）。GENA で必須ヘッダとして定義されています。 NTS (Notification Sub-Type) ヘッダには ssdp:alive を指定します。 ssdp:alive リクエストを受信した SSDP クライアントは、その情報でキャッシュの内容を更新します。 更新するキャッシュは、USN が一致するものです。 ssdp:alive リクエストには、レスポンスはありません。 ssdp:byebye リクエスト ssdp:byebye リクエストは、以下のような場合にマルチキャストされます。 自分（サービス）がネットワークから離脱するとき ssdp:byebye リクエストのメッセージ形式も ssdp:alive と同様に、GENA のフォーマットを利用しています。 GENA でオプショナルなヘッダとして定義されている NTS (Notification Sub-Type) ヘッダの値を ssdp:byebye として設定したものが ssdp:byebye リクエストとして用いられます。 ssdp:byebye（リクエスト）の例 NOTIFY * HTTP/1.1 HOST: 239.255.255.250:1900 USN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6 NT: your:serviceType NTS: ssdp:byebye NT (Notification Type) ヘッダにはサービスタイプを設定します（形式は任意）。GENA で必須ヘッダとして定義されています。 NTS (Notification Sub-Type) ヘッダには ssdp:byebye を指定します。 ssdp:byebye リクエストには、レスポンスはありません。 NT ヘッダは GENA で必須ヘッダなので、サービスタイプを指定していますが、実際の実装では、USN の一致によりキャッシュクリアなどの判断をするため、通常は ssdp:byebye リクエストの NT ヘッダが参照されることはありません。 Internet Draft GENA (General Event Notification Architecture Base: Client to Arbiter) SSDP (Simple Service Discovery Protocol/1.0 Operating without an Arbiter)`},{url:"/p/9nom8yj/",title:"Windows (MinGW) で GLUT を使用する",date:"2012-12-21T00:00:00+09:00",body:"Windows (MinGW) で GLUT を使用する Windows の MinGW で GLUT を使用するには、freeglut を使用するのが簡単です。 https://www.transmissionzero.co.uk/software/freeglut-devel/ GLUT (freeglut) のインストール 「Download freeglut 2.8.0-1 for MinGW」といったところからアーカイブをダウンロードして展開すると、下記のようなファイル群が展開されます。 bin/ +-- freeglut.dll include/GL/ +-- freeglut.h +-- freeglut_ext.h +-- freeglut_std.h +-- glut.h lib/ +-- libfreeglut.a +-- libfreeglut_static.a それぞれ、以下のような位置にコピーすれば、インストール終了です。 DLL ファイル &ndash; パス (%PATH%) の通ったどこか ヘッダファイル &ndash; C:\\MinGW\\include\\GL ディレクトリ lib ファイル &ndash; C:\\MinGW\\lib ディレクトリ GLUT (freeglut) で HelloWorld GL/glut.h を使用したプログラムは、以下のようにビルドできます。 C:\\&gt; g++ main.cpp -lfreeglut -lopengl32 main.cpp #include &lt;GL/glut.h&gt; void display() { glClear(GL_COLOR_BUFFER_BIT); glBegin(GL_LINE_LOOP); glVertex2d(-0.5, -0.5); glVertex2d(0.5, -0.5); glVertex2d(0.5, 0.5); glVertex2d(-0.5, 0.5); glEnd(); glFlush(); } void init() { glClearColor(0.0, 1.0, 0.5, 1.0); } int main(int argc, char** argv) { glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGBA); glutCreateWindow(argv[0]); glutDisplayFunc(display); init(); glutMainLoop(); }"},{url:"/p/7ovg5nr/",title:"Linuxメモ: Bash の構文: 関数のデフォルト引数を定義する",date:"2012-12-09T00:00:00+09:00",body:"Linuxメモ: Bash の構文: 関数のデフォルト引数を定義する 以下の関数では、パラメータを何も指定しないで呼び出すと、par1 ローカル変数に ABC が入ります。 パラメータを指定すると、そちらが使用されます。 param-test.sh function param-test() { local par1=${1:-ABC}; echo &#34;param = $par1&#34; } 実行例 $ . param-test.sh $ param-test param = ABC $ param-test 10000 param = 10000"},{url:"/p/rr3cmu5/",title:"Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer)",date:"2012-12-09T00:00:00+09:00",body:"Python で簡易的な HTTP サーバを立てる (http.server, SimpleHTTPServer) Python がインストールされた環境であれば、コマンドラインから下記のように実行することで簡易 HTTP サーバを立てることができます。 （Python3 の場合）ポート 8000 で HTTP サーバーを起動 $ python3 -m http.server 8000 Serving HTTP on :: port 8000 (http://[::]:8000/) ... （Python2 の場合）ポート 8000 で HTTP サーバーを起動 $ python -m SimpleHTTPServer 8000 Serving HTTP on 0.0.0.0 port 8000 ... これで、http://localhost:8000/ にアクセスすれば、カレントディレクトリ内のファイルの一覧が表示されます。 開発環境での HTTP 開通テストや、LAN 内の一時的なファイル共有サーバとして使用することができます。"},{url:"/p/e44uun8/",title:"Node.jsメモ: 環境変数を参照する (process.env)",date:"2012-12-07T00:00:00+09:00",body:"Node.jsメモ: 環境変数を参照する (process.env) Node.js で環境変数を扱いたいときは、process.env オブジェクトを参照します。 process モジュールはデフォルトで参照できるようになっているので、require でモジュールを読み込む必要はありません。 指定した環境変数を取得する process.env.環境変数名 とすれば、任意の環境変数を参照できます。 $ node &gt; console.log(process.env.HOME); D:\\x\\home 下記は、環境変数 HTTP_PROXY の設定の有無に応じて処理を振り分ける例です。 if (process.env.HTTP_PROXY != undefined) { // Proxy 環境で動作している場合 } else { // Proxy 環境ではない場合 } 環境変数が指定されていない場合のデフォルト値 環境変数が設定されていない場合（undefined の場合）にデフォルト値を設定したいのであれば、下記のように ??（Null 合体演算子）を使います。 const port = process.env.MYSERVER_PORT ?? 50000; ?? 演算子は ES2020 で導入された Nullish Coalescing という仕組みで、ある変数の値を参照しつつ、その値が undefined あるいは null の場合に、右側に指定した値を代わりに返してくれます。 上の例の場合は、環境変数 MYSERVER_PORT が設定されていないときに、デフォルトのポート番号として 50000 が使用されます。 ?? 演算子が導入される前は、次のように undefined 判定を行う必要がありました。 let port = process.env.MYSERVER_PORT; if (typeof port === &#39;undefined&#39;) port = 50000; // 簡易的に if (port != undefined) でも OK これはちょっと冗長なので、次のように || 演算子を使う方法もよく使われていました。 const port = process.env.MYSERVER_PORT || 50000; ただ、このやり方ですと、環境変数 MYSERVER_PORT に 0 が指定された場合も偽値としてみなされてしまうという問題がありました。 ES2020 以降の環境では、Null 合体演算子 (??) を使えば万事解決です。 すべての環境変数を列挙する process.env オブジェクトにどのように環境変数が格納されているかは、下記のようにインタラクティブモードで出力すれば簡単に確認することができます。 $ node &gt; process.env { ... OS: &#39;Windows_NT&#39;, Path: &#39;...&#39;, PATHEXT: &#39;.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW&#39;, PROCESSOR_ARCHITECTURE: &#39;AMD64&#39;, PROCESSOR_IDENTIFIER: &#39;Intel64 Family 6 Model 60 Stepping 3, GenuineIntel&#39;, PROCESSOR_LEVEL: &#39;6&#39;, PROCESSOR_REVISION: &#39;3c03&#39;, ... } キーでソートして表示 Node.js 環境の全ての環境変数を、変数名でソートして列挙したいときは次のようにします。 Object.keys(process.env).sort().forEach(key =&gt; { console.log(`${key}: ${process.env[key]}`) }); 特定のプレフィックスで始まる環境変数を列挙 環境変数名の配列を filter 関数でフィルタしてやれば、注目している環境変数だけを列挙できます。 次の例では、NODE で始まる環境変数のみを列挙しています。 const keys = Object.keys(process.env).filter((v) =&gt; v.startsWith(&#39;NODE&#39;)); keys.sort().forEach(key =&gt; { console.log(`${key}: ${process.env[key]}`) }); 関連記事 環境変数の代わりに .env ファイルを使用する (dotenv)"},{url:"/p/ngf6w24/",title:"Vim で正規表現にマッチする行を削除する",date:"2012-12-06T00:00:00+09:00",body:"Vim で正規表現にマッチする行を削除する 正規表現に一致するテキストが見つかった行をすべて削除する 下記のように実行すると、正規表現に一致するテキストを含む行をまとめて削除することができます。 :g/正規表現/d 例えば、以下のようなファイルリストが書かれたテキストから、バックアップファイル（~ で終わる行）を削除するには、 src/main.h src/main.h~ src/main.cpp src/main.cpp~ 以下のようなコマンドを入力します。 :g/\\~$/d 正規表現に一致するテキストが「見つからない」行をすべて削除する 逆に、指定した正規表現に一致するテキストが 見つからない 行を削除するには、下記のように実行します。 :v/正規表現/d"},{url:"/p/2dua65s/",title:"Node.jsメモ: npm コマンドで Node.js のパッケージをインストール／アンインストールする (npm install, uninstall)",date:"2012-11-27T00:00:00+09:00",body:"Node.jsメモ: npm コマンドで Node.js のパッケージをインストール／アンインストールする (npm install, uninstall) npm による Node パッケージのインストール (npm install) Node.js の環境で追加パッケージをインストールするには、Node Package Manager（npm コマンド）を使用します。 下記のようなコマンドで、Node パッケージをインストールできます。 公開されている Node パッケージは、The NPM Registry というサイトで検索することができます。 $ npm install &lt;package_name&gt; 上記のようにインストールしたパッケージは、カレントディレクトリ以下の node_modules ディレクトリに格納されます。 例えば、socket.io パッケージをインストールした場合は、node_modeles/socket.io ディレクトリ内に関連ファイルが格納されます。 また、socket.io が依存しているパッケージがある場合は、自動的に node_modules/socket.io/node_modules 以下にインストールされます。 node_modules ディレクトリ以下にすべてが格納されるので、npm コマンドによってそれ以外のディレクトリが汚染されてしまう心配をする必要がありません。 また、別の記事で紹介している package.json というファイルに必要なパッケージを記述しておくことにより、1 コマンドで依存パッケージをインストールできるため、Node.js を使用したアプリケーションを配布するときは、node_modules ディレクトリ以下の外部パッケージを配布する必要はありません。 例: socket.io パッケージのインストール $ npm install socket.io ... socket.io@0.9.11 node_modules\\socket.io ├── policyfile@0.0.4 ├── redis@0.7.3 └── socket.io-client@0.9.11 (xmlhttprequest@1.4.2, uglify-js@1.2.5, active-x-obfuscator@0.0.1, ws@0.4.23) 例: restify パッケージのインストール $ npm install restify restify@1.4.4 node_modules\\restify ├── byline@2.0.2 ├── lru-cache@1.1.0 ├── semver@1.0.14 ├── mime@1.2.5 ├── retry@0.6.0 ├── async@0.1.22 ├── node-uuid@1.3.3 ├── qs@0.5.0 ├── formidable@1.0.11 ├── bunyan@0.10.0 └── http-signature@0.9.9 (asn1@0.1.11, ctype@0.5.0) バージョンを指定してインストールする パッケージ名の後ろに @4.16.4 という形でバージョンを指定すると、そのバージョンのパッケージをインストールすることができます。 例: express のバージョン 4.16.4 をインストール $ npm install express@4.16.4 また、@&quot;&gt;=4.0.0&quot; や @&quot;&gt;=4.0.0 &lt;=4.16.4&quot; という書き方で、インストールするパッケージのバージョンを絞り込むこともできます。 このように、大なり記号 (&gt;) や小なり記号 (&lt;) を使用してバージョンを絞り込む場合は、シェルがリダイレクト指定と認識してしまわないように、バージョン部分をダブルクォート (&quot;) で囲んで指定する必要があることに注意してください。 例: express のバージョン 4.0.0 以上をインストール $ npm install express@&#34;&gt;=4.0.0&#34; 例: express のバージョン 4.0.0 以上 4.16.4 以下をインストール $ npm install express@&#34;&gt;=4.0.0 &lt;=4.16.4&#34; グローバルモードで Node パッケージをインストールする npm install コマンドでは、デフォルトではカレントディレクトリの node_modules ディレクトリ内にパッケージをインストールします。これは、実行環境の変化をそのアプリケーションに閉じるという意味で合理的な振る舞いといえます。 一方で、すべての Node.js アプリケーションから共通で使用したいパッケージがある場合は、グローバルモードでインストールすることができます。 グローバルモードでパッケージをインストールするには、npm install コマンドに -g オプションを指定します。 $ npm install -g &lt;package_name&gt; グローバルモードでインストールしたパッケージは、デフォルトでは、以下のディレクトリにインストールされるようです。 Windows: %APPDATA%\\npm\\node_modules （%APPDATA% はユーザごとに異なる） Linux: /usr/local/lib/node_modules npm による Node パッケージのアンインストール (npm uninstall) パッケージをアンインストールするには、npm uninstall コマンドを使用します。 $ npm uninstall &lt;package_name&gt; # ローカルモードでインストールしたパッケージを削除 # npm uninstall -g &lt;package_name&gt; # グローバルモードでインストールしたパッケージを削除"},{url:"/p/45tu88x/",title:"Node.jsメモ: npm コマンド用に HTTP プロキシを設定する (npm config)",date:"2012-11-26T00:00:00+09:00",body:"Node.jsメモ: npm コマンド用に HTTP プロキシを設定する (npm config) プロキシ経由でインターネットに接続しなければいけない環境（企業内ネットワークなど）では、npm コマンドのプロキシ設定を行う必要があります。 これをやっておかないと、npm install コマンドによるネットワーク経由でのパッケージのインストールができません。 プロキシを設定する $ npm config set proxy http://proxy.example.com:8080/ プロキシ設定を削除する $ npm config delete proxy # 設定を削除する場合 現状のプロキシ設定を確認する $ npm config get proxy http://proxy.example.com:8080/"},{url:"/p/z5ap5bf/",title:"Node.js をインストールする",date:"2012-11-25T00:00:00+09:00",body:"Node.js をインストールする Node.js とは Node.js は、JavaScript によって記述されたプログラム（スクリプト）を実行するための実行環境です。 JavaScript は、元々は Web ブラウザ内のコンテキストで実行されるスクリプト言語として開発されたものですが、Node.js のランタイム (Windows の場合は node.exe) を使用すると、ネイティブな実行環境で、JavaScript のプログラムを実行することができます。 Python や Ruby のような実行環境が、JavaScript 言語にも提供されたと考えると分かりやすいです。 例えば、Python によるプログラムは以下のように実行しますが、 $ python sample.py 同様に JavaScript で記述したプログラムを、下記のように実行できます。 $ node sample.js Node.js は、内部的には下記のような構成要素で成り立っています。 V8 — Google 製の JavaScript 実行エンジン。 libuv — 非同期イベントライブラリ。Node.js の作者の Ryan Dahl によって作成された。 Node.js では、libuv をベースとする非同期 I/O の仕組みによって、シングルスレッドながらも多くの接続を処理することができるようになっており、サーバサイドのプログラミング言語としても注目を集めています。 Node.js のインストール 各 OS 用の Node.js インストーラが提供されています。 下記のサイトからダウンロードして実行するだけで簡単にインストールできます。 複数バージョンの Node.js 実行環境をインストールしたい場合は、nvm というコマンドラインツールを使って Node.js をインストール してください。 Node.js - https://nodejs.org/ Node.js の実行環境は、デフォルトで下記のようなディレクトリにインストールされます。 Windows の場合: C:\\Program Files\\nodejs\\ Mac OSX の場合: /usr/local/bin/node および /usr/local/bin/npm Node.js 0.6.0 以降は、Node.js 用のパッケージ管理ツールである npm (Node Package Manager) も一緒にインストールされます。 正しくインストールできたかどうかは、下記のようにして確認できます。 $ node -v v16.13.0 $ npm -v 8.1.3"},{url:"/p/pgw5j96/",title:"JavaScript のコーディングスタイル",date:"2012-11-19T00:00:00+09:00",body:"JavaScript のコーディングスタイル 一般的に採用されている JavaScript のコーディングスタイルのまとめです。 記述フォーマット 一行の最大文字数は 79 文字（改行を入れて 80 文字） インデントはスペース 2 つ（複数行にまたがる時は、スペース 4 つにするか、前の行のドット等に合わせる） ファイルのエンコーディング形式は UTF-8、改行コードは LF (0x0A) ドキュメンテーションコメント ドキュメンテーションコメントは JSDoc で記述します。 /** * Find a person who has a specified nickname. * * @param {String} nickname - The nickname to be searched * @return {Person} A person if found, null if not found */ function findPerson(nickname) { // ... return person; } 命名規則 クラス: ClassName メソッド (public/protected) : methodName メソッド (private) : methodName_ プロパティ (public/protected): propName プロパティ (private): propName_ 変数: varName 定数: CONSTANT_NAME 省略形は先頭文字だけ大文字にします。 Good: Pdf, Id, Xml, Http NG: PDF, ID, XML, HTTP 文字列リテラル 文字列リテラルの定義には、シングルクォーテーションを使います。 これは HTML タグを記述する際に相性がよいからです。 文字列内にシングルクォーテーションが含まれるような場合は、例外的に全体をダブルクォーテーションで囲みます。 クラスの定義方法 （2024 年追記: 現在は class キーワードを使ってクラス定義すればよいです） JavaScript でクラス（正確にはクラス風のオブジェクト）を定義する方法はいろいろありますが、基本は下記のような形式で定義します。 /** @constructor */ function Foo() { this.bar = value; } Foo.prototype.methodName = function() { ... }; プライベートなクラス、メソッド、プロパティは @private を付けて、アンダースコアで終えます。 /** * @private * @constructor */ function PrivateClass_() { /** @private */ this.privateProp_ = 2; } /** @private */ PrivateClass_.privateStaticMethod_ = function() { .. }; /** @private */ PrivateClass_.prototype.privateMethod_ = function() { .. }; その他 無名の関数オブジェクトで済ませられるような場所でも、デバッグしやすくするために、できるだけ関数には名前を付けておくようにします。 参考になるコーディングスタイル Google JavaScript Style Guide 一行原則 80 文字以内。 インデントはスペース 2 文字。 Node.js Style Guide 一行原則 80 文字以内。 インデントはスペース 2 文字。 jQuery のコーディングスタイル カッコ内のスペースの使い方などが、マイナーなのでちょっと嫌。 一行原則 80 文字以内。 インデントはスペース 4 つ（JavaScript の世界では少数派）。"},{url:"/p/qijsiy5/",title:"Linuxメモ: Windows で Linux 系のコマンドを使用できるようにする (Gow)",date:"2012-11-19T00:00:00+09:00",body:"Linuxメモ: Windows で Linux 系のコマンドを使用できるようにする (Gow) Gow のインストール Gow (Gnu On Windows) Gow をインストールすると、Windows で Linux の主なコマンド群をサクッと使うことができるようになります。 インストーラを実行するだけで数秒でインストールできるので、簡単なコマンドを使うために Cygwin のような大げさな環境をインストールしなくても済みます。 Gow で使えるようになる Linux 系コマンドの一覧 Gow - executables_list Gow がインストールされている環境であれば、以下のように確認することもできます。 Gow 0.7 で確認 C:\\&gt; gow -l Available executables: awk, basename, bash, bc, bison, bunzip2, bzip2, bzip2recover, cat, chgrp, chmod, chown, chroot, cksum, clear, cp, csplit, curl, cut, dc, dd, df, diff, diff3, dirname, dos2unix, du, egrep, env, expand, expr, factor, fgrep, flex, fmt, fold, gawk, gfind, gow, grep, gsar, gzip, head, hostid, hostname, id, indent, install, join, jwhois, less, lesskey, ln, ls, m4, make, md5sum, mkdir, mkfifo, mknod, mv, ncftp, nl, od, pageant, paste, patch, pathchk, plink, pr, printenv, printf, pscp, psftp, putty, puttygen, pwd, rm, rmdir, scp, sdiff, sed, seq, sftp, sha1sum, shar, sleep, sort, split, ssh, su, sum, sync, tac, tail, tar, tee, test, touch, tr, uname, unexpand, uniq, unix2dos, unlink, unrar, unshar, uudecode, uuencode, vim, wc, wget, whereis, which, whoami, xargs, yes, zip"},{url:"/p/bxrtpbp/",title:"JavaScript は Strict モードを有効にすべし (ECMAScript 5)",date:"2012-11-09T00:00:00+09:00",body:"JavaScript は Strict モードを有効にすべし (ECMAScript 5) Strict Mode を有効にする ECMAScript 5 では、文法チェックを厳しくするための Strict Mode という機能が導入されています。 JavaScript コードの先頭行に、以下のように記述しておくと、Strict Mode が有効になります。 仮に、Strict Mode が使えない環境でこの行が記述されていても、単純に無視されるだけなので、常に記述しておくことをお勧めします。 スクリプト全体を Strict Mode で動かす &#39;use strict&#39;; 関数の中の先頭行で &lsquo;use strict&rsquo; と記述すると、その関数のみが Strict Mode で実行されます。 関数だけを Strict Mode で動かす function hoge() { &#39;use strict&#39;; ... } Strict Mode を有効にすると、例えば、未定義の変数を参照したときに ReferenceError が発生するようになります。 &#39;use strict&#39;; var num1 = 100; print(num1); // OK print(num2); // ReferenceError! Strict Mode のエラーが発生しない分かりにくい例 以下の例では、print(num) の時点で num が定義されていないので、一見 ReferenceError が発生しそうですが、同じスコープの中で num を定義している箇所があればエラーは発生しません。 sample.js &#39;use strict&#39;; print(num); // エラーは発生しない var num = 100; ただし、num を参照した時点では、値がまだ代入されていないので、undefined という値として参照されることになります。 実行結果 $ jrunscript sample.js undefined 参考サイト Strict モード - JavaScript ｜ MDN"},{url:"/p/co9p7nj/",title:"Linuxシェルスクリプト: テキストファイルを 1 行ずつ読み込む (read)",date:"2012-11-05T00:00:00+09:00",body:"Linuxシェルスクリプト: テキストファイルを 1 行ずつ読み込む (read) テキストファイルを 1 行だけ読み込む read コマンドはユーザからの入力を 1 行取得するために使用できますが、ファイルからの入力を 1 行読み込むのにも使用できます。 sample.sh （input.txt の内容を 1 行だけ読み込む） #!/bin/bash read line &lt; input.txt echo &#34;$line&#34; input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 これだけだとあまり役に立たないので、通常は次のように while ループを組み合わせて、すべての行を読み出します。 テキストファイルから 1 行ずつ読み込む read コマンドと while ループを組み合わせると、テキストファイルのすべての行を 1 行ずつ処理できます。 sample.sh （input.txt の内容を 1 行ずつ読み込む） #!/bin/bash while read line; do echo &#34;$line&#34; done &lt; input.txt input.txt（入力データ） AAA 100 BBB 200 CCC 300 実行結果 $ ./sample.sh AAA 100 BBB 200 CCC 300 ☝️ ワンポイント echo のパラメータ &quot;$line&quot; をダブルクォートで囲んでいることに注意してください。 こうすることで、1 行分の文字列を、ひとつのパラメータとして渡すことができます。 ダブルクォートで囲まないと、echo AAA 100 のように、2 つのパラメータが渡されたかのように処理されてしまうため、連続するスペースが 1 つのスペースに置き換えられて出力されてしまいます。 参考: echo で出力した文字列の中の連続するスペースが 1 つのスペースになってしまうのを防ぐ 行頭のスペースが消えてしまうのを防ぐ 例えば、下記のように行頭がインデントされたテキストファイルを読み込むとします。 input.txt（入力データ） ・カテゴリA ・カテゴリA-1 ・カテゴリA-2 ・カテゴリB ・カテゴリB-1 ・カテゴリB-2 このファイルを次のように読み込むと、行頭のスペースが削除されてしまします。 sample.sh #!/bin/bash while read line; do echo &#34;$line&#34; done &lt; input.txt 実行結果 $ ./sample.sh ・カテゴリA ・カテゴリA-1 ・カテゴリA-2 ・カテゴリB ・カテゴリB-1 ・カテゴリB-2 行頭のスペースをそのまま表示したい場合は、次の例のように、組み込み変数 IFS を空文字にセットしてから処理するようにします。 変更した IFS の値は、最後に行儀よく元の値に戻してあげてください（source コマンドなどでスクリプトを読み込んだときに、呼び出し元シェルの IFS の値が変更されたままになってしまうのを防ぐため）。 sample.sh #!/bin/bash old_ifs=$IFS IFS=&#39;&#39; while read line; do echo &#34;$line&#34; done &lt; input.txt IFS=$old_ifs 実行結果 $ ./sample.sh ・カテゴリA ・カテゴリA-1 ・カテゴリA-2 ・カテゴリB ・カテゴリB-1 ・カテゴリB-2 IFS 特殊変数に関しての詳細は、man bash を参照してください。 IFS は内部的な文字列のセパレート処理に使われるキャラクター群を保持しています。"},{url:"/p/cjn9dbq/",title:"Linuxメモ: シェルスクリプト: 変数の基本",date:"2012-11-05T00:00:00+09:00",body:"Linuxメモ: シェルスクリプト: 変数の基本 変数の定義と参照 変数へ値を代入するときは $ を付けず、変数を参照するときは $ を付けます。 sample.sh #!/bin/sh name=Michael # 変数の定義 echo Hello $name # 変数の参照 echo &#34;Hello $name&#34; # ダブルクォーテーションは変数を展開する echo &#39;Hello $name&#39; # シングルクォーテーションは変数を展開しない 実行結果 $ ./sample.sh Hello Michael Hello Michael Hello $name 定義していない変数は空文字と同じ 未定義の変数を参照すると、空文字列と同様に扱われます。 エラーにはなりません。 sample.sh #!/bin/sh echo &#34;Hello $name !&#34; 実行結果 $ ./sample.sh Hello ! &ldquo;=&rdquo; の前後にスペースは入れちゃだめ！ 変数定義の = の前後にはスペースを入れてはいけません。 スペースを入れると、変数名の部分がシェル上で実行可能なコマンドとして認識されてしまいます。 例えば、以下のようにすると、value というコマンドを、引数 &quot;= hello&quot; で実行すると解釈されてしまいます。 間違った代入（その１） value = hello さらに、以下のように、&quot;=&quot; の後ろだけにスペースを入れると… 間違った代入（その２） value= hello これは、変数 value を空にした状態で、コマンド hello を呼び出すと解釈されてしまいます。"},{url:"/p/6m6n5k3/",title:"Linuxメモ: ユーザー入力を取得する (read)",date:"2012-11-05T00:00:00+09:00",body:"Linuxメモ: ユーザー入力を取得する (read) ユーザー入力の基本 bash スクリプトの中で、read 変数名 とすると、ユーザーがキーボードで入力したテキストを変数に取得することができます。 変数名 の部分には、$ プレフィックスを付けないことに注意してください（変数の内容を参照するときは $ が必要です）。 hello.sh #!/bin/sh echo -n &#34;Enter your name: &#34; read name echo &#34;Hello, $name&#34; 実行結果 $ ./hello.sh Enter your name: まくまく Hello, まくまく ☝️ echo の -n オプション echo コマンドの出力はデフォルトで末尾で改行されますが、-n オプションを使うとこの改行を抑制できます。 上記の例のように、プロンプト表示で利用できます。 ユーザーが y を入力したときだけ処理を継続する read コマンドの典型的な使用例として、ユーザーに y/n の選択肢を入力させるものがあります。 次の remove_all 関数は、何もかもを削除する前に、ユーザーに最終確認を行っています。 remove.sh #!/bin/bash function remove_all { echo -n &#39;Are you sure? (y/n): &#39; read input if [ &#34;$input&#34; = &#39;Y&#39; -o &#34;$input&#34; = &#39;y&#39; ]; then echo &#39;All things have been removed!&#39; fi } remove_all 実行例 $ ./remove.sh Are you sure? (y/n): y All things have been removed! if の中で $input の内容を確認するときに、ダブルクォーテーションで囲んでいるのは、ユーザーの入力がなかった場合に空文字 &quot;&quot; を取得するためです。 これがないと、ユーザーが何も入力せずにエンターした場合にエラーになってしまいます。 スペースで区切られたユーザー入力を別々の変数に取得する read コマンドの後ろに複数の変数を指定すると、スペースで区切られたユーザー入力を別々の変数に取得することができます。 sample.sh #!/bin/sh read aaa bbb ccc echo &#34;aaa = $aaa&#34; echo &#34;bbb = $bbb&#34; echo &#34;ccc = $ccc&#34; 実行例 $ ./sample.sh 100 200 300 aaa = 100 bbb = 200 ccc = 300 read に指定した変数の数よりも、入力が少ない場合は、変数が空になります。 $ ./sample.sh 100 200 aaa = 100 bbb = 200 ccc = 逆に、入力の方が多い場合は、read コマンドの最後に指定した変数にまとめて格納されます。 $ ./sample.sh 100 200 300 400 500 aaa = 100 bbb = 200 ccc = 300 400 500"},{url:"/p/wur8gmp/",title:"JavaScript の 6 つの型",date:"2012-10-28T00:00:00+09:00",body:"JavaScript の 6 つの型 JavaScript is a &ldquo;Loosely Typed Language&rdquo; JavaScript は弱い型付け言語 (A Loosely Typed Language) です。 変数の宣言時に、型を指定する必要はありませんが、内部的には型情報を保持しています。 const s = &#39;Hello World&#39;; // 型指定はしていないが、内部的に文字列型として保持される print(typeof s); // =&gt; string JavaScript の型は 6 種類 JavaScript の型には 5 つの基本型 (primitive value) と、プロパティを持つことができるオブジェクト型があります。 ようするに、全部で 6 つの型があります。 基本型 number（数値） &ndash; 64 bit 浮動小数点数 string（文字列） boolean（真偽値） &ndash; true or false null &ndash; null だけが存在する型 undefined &ndash; 未定義を表す オブジェクト型 5 つの基本型は、ECMAScript の仕様書では、primitive value と呼ばれています。 JavaScript には、C/C++ や Java 言語における char のような 1 文字を格納するための型は存在しないため、長さ 1 の string で代用することになります。 配列に関してはオブジェクト型（Array オブジェクト）に分類されています。 日付を表す Date などもすべてオブジェクト型です。 型情報を調べる (typeof) 変数が参照している値の型を調べるには、typeof を使用します。 リテラルの型を調べることもできます。 print(typeof 100); //=&gt; number print(typeof &#39;xyz&#39;); //=&gt; string print(typeof true); //=&gt; boolean print(typeof null); //=&gt; object print(typeof {}); //=&gt; object print(typeof undefined); //=&gt; undefined null の型が、なぜか object になることに注意が必要です。"},{url:"/p/fp2xk7y/",title:"Vim で■や※などの記号が重なって表示される問題の解決 (ambiwidth)",date:"2012-10-11T00:00:00+09:00",body:"Vim で■や※などの記号が重なって表示される問題の解決 (ambiwidth) 日本語の Vim 環境において、encoding オプションの値が utf-8 などに設定されている場合、■ や ※ などの記号を入力したときに、その次の文字が半角分重なって表示されてしまうことがあります。 このような記号を正しく全角文字の幅で表示するには、以下のように設定します。 set ambiwidth=double &#34;Display double-width symbols properly guifont を設定すると、ambiwidth の設定が auto に戻ってしまうようなので、guifont を設定している場合は、その後で ambiwidth を設定するとよいでしょう。 ~/_gvimrc（Windows の場合） &#34;Font settings for Windows if has(&#34;gui_win32&#34;) set guifont=ＭＳ_ゴシック:h10::cSHIFTJIS set printfont=ＭＳ_ゴシック:h22:cSHIFTJIS set ambiwidth=double &#34;Display double-width symbols properly endif"},{url:"/p/4hhc7ba/",title:"Androidメモ: SHARP IS03 に adb 接続する",date:"2012-10-09T00:00:00+09:00",body:"Androidメモ: SHARP IS03 に adb 接続する SHARP のスマホ IS03 を adb devices コマンドで認識させるまでの手順です。 Android SDK のインストールは済んでいて、adb コマンドは実行できる状態になっているとします。 IS03 用 USB ドライバをダウンロード＆インストール https://k-tai.sharp.co.jp/support/a/is03/download.html#usb_driver ドライバをインストールする前に USB でつないでいた場合は、正しく認識できなくなってしまうことがあるようです。 その場合は、「プログラムの追加と削除」から一度、「au IS03 USB Software」をアンインストールしてから、USB 接続を外した状態で、再度インストールします。 Sharp 共通の ADB USBドライバをダウンロード＆展開 https://sh-dev.sharp.co.jp/android/modules/driver/ 次の手順でインストールするドライバをダウンロードして、展開しておきます。 ADB USB ドライバをインストール Android 端末の USB デバッグを有効にし（設定 ＞ アプリケーション ＞ 開発）、USB 接続すると、ドライバのインストールダイアログがポップアップするので、手順 2 で展開した ADB USB ドライバのディレクトリを選択してインストールします。 ポップアップしない場合は、「高速転送モード」に切り替えると出たりします。 それでも出ない場合は、「Device Manager」から、Other devices/Android ADB Interface などを見つけられれば、再インストール可能です。 確認 インストールが完了すれば、以下のように adb から認識されれいるはずです。 C:\\&gt; adb devices List of devices attached SSHEV012345 device"},{url:"/p/ypihqom/",title:"Androidベンダー向けメモ: Android 4.0 でサポートされている Locale の一覧",date:"2012-09-18T00:00:00+09:00",body:"Androidベンダー向けメモ: Android 4.0 でサポートされている Locale の一覧 下記は、Android 4.0 においてサポートされている Locale の一覧です。 Android の UI 上の言語名は ICU のライブラリから取得した情報をもとに表示されるのですが、中国語に関しては例外的に、表示上の言語名が「繁体字」or「簡体字」のようになるように拡張されています。 これらの文言は android/packages/apps/Settings/res/values/arrays.xml 内で定義されています。 af_ZA: Afrikaans (South Africa) / アフリカーンス語 (南アフリカ) am_ET: Amharic (Ethiopia) / アムハラ語 (エチオピア) ar_EG: Arabic (Egypt) / アラビア語 (エジプト) bg_BG: Bulgarian (Bulgaria) / ブルガリア語 (ブルガリア) ca_ES: Catalan (Spain) / カタロニア語 (スペイン) cs_CZ: Czech (Czech Republic) / チェコ語 (チェコ) da_DK: Danish (Denmark) / デンマーク語 (デンマーク) de_DE: German (Germany) / ドイツ語 (ドイツ) el_GR: Greek (Greece) / ギリシア語 (ギリシア) en_GB: English (United Kingdom) / 英語 (イギリス) en_US: English (United States) / 英語 (アメリカ合衆国) es_ES: Spanish (Spain) / スペイン語 (スペイン) es_US: Spanish (United States) / スペイン語 (アメリカ合衆国) fa_IR: Persian (Iran) / ペルシア語 (イラン) fi_FI: Finnish (Finland) / フィンランド語 (フィンランド) fr_FR: French (France) / フランス語 (フランス) hi_IN: Hindi (India) / ヒンディー語 (インド) hi_IN: Hindi (India) / ヒンディー語 (インド) hr_HR: Croatian (Croatia) / クロアチア語 (クロアチア) hu_HU: Hungarian (Hungary) / ハンガリー語 (ハンガリー) in_ID: Indonesian (Indonesia) / インドネシア語 (インドネシア) it_IT: Italian (Italy) / イタリア語 (イタリア) iw_IL: Hebrew (Israel) / ヘブライ語 (イスラエル) ja_JP: Japanese (Japan) / 日本語 (日本) ko_KR: Korean (South Korea) / 韓国語 (大韓民国) lt_LT: Lithuanian (Lithuania) / リトアニア語 (リトアニア) lv_LV: Latvian (Latvia) / ラトビア語 (レット語) (ラトビア) ms_MY: Malay (Malaysia) / マライ語 (マレーシア) nb_NO: Norwegian Bokm?l (Norway) / ノルウェー語 (ボークモール) (ノルウェー) nl_NL: Dutch (Netherlands) / オランダ語 (オランダ) pl_PL: Polish (Poland) / ポーランド語 (ポーランド) pt_BR: Portuguese (Brazil) / ポルトガル語 (ブラジル) pt_PT: Portuguese (Portugal) / ポルトガル語 (ポルトガル) rm_CH: Raeto-Romance (Switzerland) / レト＝ロマン語 (スイス) ro_RO: Romanian (Romania) / ルーマニア語 (ルーマニア) ru_RU: Russian (Russia) / ロシア語 (ロシア) sk_SK: Slovak (Slovakia) / スロバキア語 (スロバキア) sl_SI: Slovenian (Slovenia) / スロベニア語 (スロベニア) sr_RS: Serbian (Serbia) / セルビア語 (セルビア) sv_SE: Swedish (Sweden) / スウェーデン語 (スウェーデン) sw_TZ: Swahili (Tanzania) / スワヒリ語 (タンザニア) th_TH: Thai (Thailand) / タイ語 (タイ) tl_PH: Tagalog (Philippines) / タガログ語 (フィリピン) tr_TR: Turkish (Turkey) / トルコ語 (トルコ) uk_UA: Ukrainian (Ukraine) / ウクライナ語 (ウクライナ) vi_VN: Vietnamese (Vietnam) / ベトナム語 (ベトナム) zh_CN: Chinese (China) / 中国語 (中華人民共和国) ★「簡体」 zh_TW: Chinese (Taiwan) / 中国語 (台湾) ★「繁体」 zu_ZA: Zulu (South Africa) / ズールー語 (南アフリカ) 上記の一覧は、通常の PC 上でロケールシンボル（en_US など）に対応する言語名、国名を出力したものです。 下記のようなコードを実行して出力しています。 Main.java import java.util.Arrays; import java.util.Locale; public class Main { // Copied from &#34;build/target/product/languages_full.mk&#34; private static String LOCALES = &#34;en_US fr_FR it_IT es_ES de_DE nl_NL cs_CZ pl_PL ja_JP zh_TW zh_CN ru_RU ko_KR nb_NO es_US da_DK el_GR tr_TR pt_PT pt_BR rm_CH sv_SE bg_BG ca_ES en_GB fi_FI hi_IN hr_HR hu_HU in_ID iw_IL lt_LT lv_LV ro_RO sk_SK sl_SI sr_RS uk_UA vi_VN tl_PH ar_EG fa_IR th_TH sw_TZ ms_MY af_ZA zu_ZA am_ET hi_IN&#34;; public static void main(String[] args) { String[] arr = LOCALES.trim().split(&#34;\\\\s+&#34;); Arrays.sort(arr); for (int i = 0; i &lt; arr.length; ++i) { Locale loc = createLocale(arr[i]); System.out.println(loc.toString() + &#34;: &#34; + loc.getDisplayName(Locale.ENGLISH) + &#34; / &#34; + loc.getDisplayName(Locale.JAPANESE)); } } private static Locale createLocale(String locale) { String[] splitted = locale.split(&#34;_&#34;); if (splitted.length == 1) { return new Locale(splitted[0]); } else { return new Locale(splitted[0], splitted[1]); } } }"},{url:"/p/pzyxbo7/",title:"Linuxメモ: dbus-python で D-Bus の P2P クライアントを実装する",date:"2012-09-05T00:00:00+09:00",body:"Linuxメモ: dbus-python で D-Bus の P2P クライアントを実装する python-dbus では、今のところ P2P 用のサーバを作成できないようです。 なので、ここでは P2P クライアントのサンプルだけを示します。 p2p-client.py P2P 通信を行うには、dbus.SessionBus オブジェクトを使ってバス名を指定するのではなく、dbus.connection.Connection オブジェクトを使って、アドレス指定で接続します。 con = dbus.connection.Connection(&#39;tcp:host=127.0.0.1,port=12300&#39;) Connection が確立できたら、あとは Object path を指定して、リモートオブジェクトを取得できます。 counter_object = con.get_object(object_path=OBJECT_PATH) counter_iface = dbus.Interface(counter_object, INTERFACE)"},{url:"/p/zkx7oe6/",title:"Linuxメモ: dbus-python で Session bus を使用するサーバ＆クライアントを実装する（シグナルの実装）",date:"2012-09-05T00:00:00+09:00",body:"Linuxメモ: dbus-python で Session bus を使用するサーバ＆クライアントを実装する（シグナルの実装） dbus-python のサーバ＆クライアント実装において、シグナルを使用するサンプルです。 シグナルを使用すると、サーバ側からクライアント側に任意のタイミングで通知を送ることができます。 以下のサンプルでは、SetCount() メソッドが呼ばれた場合に、CountChanged シグナルを発行しています。 サーバ側の実装 server-signal.py サーバ側に、シグナル発行用のメソッド CountChanged() を追加して、SetCount() メソッド内から呼び出すようにします。 シグナルを定義するには、@dbus.service.signal を付けてメソッドを定義します。 class CounterObject(dbus.service.Object): def __init__(self, bus, obj_path): dbus.service.Object.__init__(self, bus, obj_path) self.count = 0 @dbus.service.signal(INTERFACE, signature=&#34;i&#34;) def CountChanged(self, count): print(&#39;Emit signal: &#39; + str(count)) @dbus.service.method(INTERFACE, in_signature=&#34;i&#34;, out_signature=&#34;&#34;) def SetCount(self, count): print(&#39;SetCount called: &#39; + str(count)) self.count = count self.CountChanged(count) @dbus.service.method(INTERFACE, in_signature=&#34;&#34;, out_signature=&#34;i&#34;) def GetCount(self): print(&#39;GetCount called&#39;) return self.count クライアント側の実装 client-signal.py リモートオブジェクトを操作するためのインタフェースを取得したら、connect_to_signal() メソッドを呼ぶことで、シグナルハンドラを登録することができます。 下記の例では、CountChanged シグナルを、on_count_changed というシグナルハンドラで受信するように登録しています。 # Signal handler for &#34;CountChanged&#34; def on_count_changed(count): print(&#39;CountChanged: &#39; + str(count)) def main(): ... counter_iface.connect_to_signal(&#39;CountChanged&#39;, on_count_changed) シグナルは非同期に受信する必要があるので、クライアント側にもメインループを生成する必要があります（下記の loop.run() の部分）。 def on_timeout(counter_iface): val = counter_iface.GetCount() counter_iface.SetCount(val + 1) return True # continued def main(): ... # Call the SetCount method repeatedly gobject.timeout_add(1000, on_timeout, counter_iface) # Start the mainloop to receive signals loop = gobject.MainLoop() loop.run() ここでは、1 秒おきに SetCount するようにタイマーをしかけていますので、結果的に、1 秒おきに CountChanged シグナルが発生することになります。"},{url:"/p/app39n9/",title:"Linuxメモ: dbus-python で Session bus を使用するサーバ＆クライアントを実装する（単純なメソッドの実装）",date:"2012-09-05T00:00:00+09:00",body:"Linuxメモ: dbus-python で Session bus を使用するサーバ＆クライアントを実装する（単純なメソッドの実装） dbus-python を利用したサーバとクライアントの実装例です。 ここでは、SetCount() と GetCount() だけを行える Counter オブジェクトを提供するサービスと、クライアントを作成してみます。 インタフェース名などは以下のようにします。 Bus name: com.example.CounterService Object path: /com/example/CounterObject Interface: com.example.Counter Session bus を使用する Server を実装する server.py D-Bus server 側では、export するオブジェクトを dbus.service.Object を継承して作成します。 公開するメソッドには @dbus.service.method アノテーションを付けて、以下の設定を行います。 何という名前のインタフェース名で公開するか 入力パラメータの Type string (in_signature) 戻り値の Type string (out_signature) class CounterObject(dbus.service.Object): @dbus.service.method(INTERFACE, in_signature=&#34;i&#34;, out_signature=&#34;&#34;) def SetCount(self, count): self.count = count print(&#39;SetCount called: &#39; + str(count)) @dbus.service.method(INTERFACE, in_signature=&#34;&#34;, out_signature=&#34;i&#34;) def GetCount(self): print(&#39;GetCount called&#39;) return self.count 上記のように作成したオブジェクトは、以下のような手順で export します。 SessionBus オブジェクトの作成 session_bus = dbus.SessionBus() 1 の SessionBus に、バス名を関連付ける bus_name = dbus.service.BusName(BUS_NAME, session_bus) SessionBus 上で任意のオブジェクトを export（ここでは CounterObject インスタンス） counter_object = CounterObject(session_bus, OBJECT_PATH) MainLoop 開始 Session bus を使用する Client を実装する client.py D-Bus クライアント側は、以下のような手順でリモートオブジェクト、インタフェースを取得します。 SessionBus オブジェクトの作成 session_bus = dbus.SessionBus() リモートオブジェクトを取得 counter_object = session_bus.get_object(BUS_NAME, OBJECT_PATH) リモートオブジェクトを操作するためのインタフェースを取得 counter_iface = dbus.Interface(counter_object, INTERFACE) インタフェースを取得したら、後はローカルのオブジェクトのようにメソッドを呼び出せます。 counter_iface.SetCount(100) val = counter_iface.GetCount()"},{url:"/p/k2c9k5k/",title:"Linuxメモ: dbus-python の公式サンプルコード",date:"2012-09-04T00:00:00+09:00",body:"Linuxメモ: dbus-python の公式サンプルコード dbus-python のサンプルコード 下記は、dbus-python-1.1.1 に付属しているサンプルコードです。 単純なメソッドを実装したサーバー＆クライアント example-service.py example-client.py example-async-client.py シグナルを実装したサーバー＆クライアント example-signal-emitter.py その他 list-system-services.py python-dbus のインストール Python で import dbus の実行時にエラーが発生する場合は、python-dbus がインストールされていません。 以下のようにしてインストールしてください。 Ubuntu の場合 $ sudo apt-get install python-dbus"},{url:"/p/cht2cpg/",title:"意外と知られていない XML 記述のルール",date:"2012-08-24T00:00:00+09:00",body:"意外と知られていない XML 記述のルール XML 文書を記述するときの意外と知られていないルールとして、下記のような定義があります。 XML 宣言の encoding 属性は省略できる。省略すると、encoding=&quot;UTF-8&quot; として扱われる。 xml で始まる名前は使ってはいけない（NG 例: &lt;xmlRoot&gt;, &lt;XmlData&gt;）。要素名にも属性名にも使ってはいけない。大文字を混ぜてもダメ。 タグ名に全角数字、半角カタカナは使ってはいけない。 文字参照で使うコード番号は、正確には Unicode ではなく ISO/IEC 10646 である。ただし、BMP (Basic Multilingual Plane) 領域は Unicode と同じなので、基本的に Unicode コードポイントとみなして構わない。"},{url:"/p/soeouhu/",title:"単体テスト、結合テスト、システムテスト、受入テストの関係を理解する",date:"2012-08-15T00:00:00+09:00",body:"単体テスト、結合テスト、システムテスト、受入テストの関係を理解する ソフトウェアのテストの話をするときは、どの粒度、観点からのテストの話をしているのかを認識することが大切です。 ここでは、単体テスト、結合テスト、システムテスト、受入テストの関係と全体像を掴みましょう。 システムテストと受け入れテスト 赤色の枠は、システム全体を示しています。 「システムテスト」は、システム全体を開発者視点でテストします。 「受入テスト」は、「システムテスト」と同様に、システム全体がテスト対象であり、テスト項目も多少かぶる部分がありますが、システム全体の振る舞いをユーザ（発注者）視点でテストするところが異なります。 単体テストと結合テスト 青色の丸と、緑色の丸は、システム内の構成要素を捉えるときの粒度の違いを示しています。 例えば、 青丸 &ndash; クラス 緑丸 &ndash; 複数のクラスから構成されたコンポーネント だと思ってください。 青丸の粒度の世界での「単体テスト」「結合テスト」もあるし、緑丸の粒度の世界での「単体テスト」「結合テスト」もあります。 「単体テスト」では、テスト対象を１つの要素に限定するため、問題を発見したときの問題個所の絞り込みが容易です。 「結合テスト」だけでは、単一要素に含まれる不具合を発見できないことがあります。 潜在的な不具合を防ぐには、「単体テスト」が重要な役割を果たすといえます。 大規模なシステムになるほど「単体テスト」の重要性は増してきますが、各モジュールの依存関係をあらかじめ考慮した上で設計を進めないと、「単体テスト」が行えないコードができてしまいます。 そうならないためにも、実装を進める前に、 テスト仕様（インタフェース仕様） テストコード の作成を行い、テストファーストで実装していくのが効果的です。 特に、複数人で開発を進める場合、テストを作成することで、最終的に完成するもののイメージを共有するという目的もあります。 ただし、テスト対象となる要素が単純な演算ライブラリのようなものでない限り、いざ、「単体テスト」を行う場面になったときに、他の要素との依存関係に悩まされるでしょう。 「単体テスト」は、あくまで単一の要素の動作を検証しなければならないので、他の要素の実装の進捗によってテスト結果が変わるようなことがあってはいけません。 そんなときに、以下のようなダミーモジュールを作成し、他の要素の動作を切り離します。 ドライバ &ndash; テスト対象を起動、操作するためのモジュール スタブ &ndash; テスト対象内部で呼び出している下位のモジュール ドライバ、スタブモジュールの作成自体が困難だと思った場合は、そのモジュールに責務を詰め込みすぎていないか、設計を見直すべき合図でもあります。 システムの実装は、下位モジュールからボトムアップで完成していくものなので、テストが成功していく順番も、「単体テスト」→「結合テスト」の順になります。 とはいえ、最終的なシステム全体の振る舞いを表現しているのは、より上位のテストです。 テスト仕様は、トップダウンで作っていくのが望ましいでしょう。"},{url:"/p/ibpmg65/",title:"Vim の map、noremap 系コマンドで使用できる特殊キーの一覧 (key-notation, key-codes)",date:"2012-07-27T00:00:00+09:00",body:"Vim の map、noremap 系コマンドで使用できる特殊キーの一覧 (key-notation, key-codes) 参考: Vim のキーマップの基本 (map, noremap) キーマップに使えるキー名の一覧 Vim の map 系コマンド（nmap や imap）で、F1 キーや BackSpace キーなどの特殊キーを使用したマッピングを行う場合は、下記のヘルプページで表示されるキー表記を使用します。 キー表記のヘルプ :help key-notation 例えば、特殊キーを表すために次のような表記が使えることがわかります。 &lt;BS&gt; &hellip; Back Space キー &lt;Bslash&gt; &hellip; Back Slash キー (\\) &lt;CR&gt; or &lt;Enter&gt; &hellip; Enter キー（&lt;CR&gt; がよく使われている） &lt;Esc&gt; &hellip; Esc キー &lt;Space&gt; &hellip; スペースキー &lt;Tab&gt; &hellip; Tab キー &lt;Del&gt; &hellip; Delete キー &lt;Up&gt;/&lt;Down&gt;/&lt;Left&gt;/&lt;Right&gt; &hellip; 上下左右カーソルキー &lt;F1&gt; 〜 &lt;F12&gt; &hellip; ファンクションキー &lt;Help&gt; &hellip; Help キー &lt;Insert&gt; &hellip; Insert キー &lt;Home&gt; &hellip; Home キー &lt;End&gt; &hellip; End キー &lt;PageUp&gt; &hellip; Page Up キー &lt;PageDown&gt; &hellip; Page Down キー Shift キー、Control キー、Alt (Meta) キー、Command キー（macOS のみ）といったキーとの同時押しを表現するには、次のように記述します。 &lt;S-Up&gt; &hellip; Shift + カーソルキー上 &lt;C-F10&gt; &hellip; Control + F10 &lt;M-Space&gt; &hellip; Alt (Meta) + Space &lt;D-Right&gt; &hellip; Command (macOS) + カーソルキー右 &lt;C-S-F1&gt; &hellip; Control + Shift + F1 キーマッピングの設定例 例: インサートモードで Control &#43; Shift &#43; F1 キーを押したときに Hello を挿入 :inoremap &lt;C-S-F1&gt; Hello 例: ノーマルモードでスペースキーを押したときに画面スクロール :nnoremap &lt;Space&gt; &lt;PageDown&gt; ここで、nmap の代わりに nnoremap を使用しているのは、PageDown キーのデフォルトの振る舞いを割り当てるためです。 nmap を使用すると、PageDown キーにすでに別の機能が割り当てられている場合に、Space キーの機能としてその機能が割り当てられてしまいます。 例: インサートモードで Ctrl-D を 2 回押したときに &lt;Hello&gt; を挿入する :inoremap &lt;C-D&gt;&lt;C-D&gt; &lt;lt&gt;Hello&gt; ここまでの設定例を見ると分かるように、&lt; と &gt; は特殊キーの名前を囲むために使用されます。 &lt; という文字そのものを表したいときは、&lt;lt&gt; のように特殊な書き方をしなければいけません。 特殊キー名を素早く入力する方法 インサートモードやコマンドラインモードで、Ctrl-K（あるいは Ctrl-Q）に続けて特殊キーを入力すると、カーソル位置にそのキー名を挿入することができます。 例えば、Ctrl-K → Ctrl-Shift-BackSpace と入力すると、下記のような文字列が挿入されます。 &lt;C-S-BS&gt; この表記が、nmap や nnoremap コマンドで使用できるキー名となります。 この機能を使えばキー名を覚える必要がないように思えますが、Esc キーなどはうまく表示できかったりする（ノーマルモードに戻ってしまう）ので、やはり基本は :help key-notation の一覧表で確認するのがよいでしょう。"},{url:"/p/8qeuow8/",title:"Vim 上でディレクトリツリーを表示する (NERDTree)",date:"2012-07-22T00:00:00+09:00",body:"Vim 上でディレクトリツリーを表示する (NERDTree) NERDTree とは NERDTree を使うと、Vim の左端にエクスプローラバーのようなものを表示できます。 https://github.com/preservim/nerdtree NERDTree のインストール 公式サイトにはいくつかインストール方法が書かれていますが、ここでは Vundle を使ってインストールします。 ~/.vimrc call vundle#begin() Plugin &#39;preservim/nerdtree&#39; call vundle#end() 上記のように .vimrc などに記述しておけば、次のように実行するだけで簡単に NERDTree をインストールできます。 :PluginInstall NERDTree tabs のインストール NERDTree プラグインである NERDTree tabs をインストールしておくと、NERDTree とタブを組み合わせた操作がより直感的になります。 https://github.com/jistr/vim-nerdtree-tabs このプラグインをインストールすると、NERDTree が以下のような振る舞いをするようになります。 Vim 起動時に NERDTree を自動的に開く NERDTree 上で t キーを押してファイルをタブで開いたときに、NERDTree のウィンドウを開いたままにする NERDTree tabs プラグインも、NERDTree 本体と同様に、Vundle を使って簡単にインストールすることができます。 ~/.vimrc call vundle#begin() &#34; NERDTree 本体 Plugin &#39;preservim/nerdtree&#39; &#34; NERDTree tabs プラグイン Plugin &#39;jistr/vim-nerdtree-tabs&#39; call vundle#end() 上記のように .vimrc に記述しておき、以下のようにインストールします。 :BundleInstall NERDTree の使い方の基本 まずは、以下のコマンドでツリーを開きます。 :NERDTree 次のコマンドを使うと、ツリーをトグル開閉できます。 :NERDTreeToggle ツリーにカーソルがある状態で以下のような操作を行うことができます。 全般的な操作 q: NERDTree を終了 ?: Quick ヘルプを表示（もう一度押すとツリー表示に戻る） ファイルのオープン Enter or o: ファイルを開く s: 縦分割してファイルを開く i: 横分割してファイルを開く t: タブでファイルを開く &mdash; ディレクトリの展開、移動 Enter or o: ディレクトリを開く／閉じる O: ディレクトリを再帰的に開く x: 親ディレクトリを閉じる u: 表示上のルートを 1 つ上位へ移動 U: 表示上のルートを 1 つ上位へ移動（開いたディレクトリをキープしたまま） C: 表示上のルートをカーソルのあるディレクトリに移動 NERDTree を使用したファイル操作 NERDTree のウィンドウ上で、m を入力すると、ファイルやディレクトリを操作するためのメニューが表示されます。 NERDTree menu. Use j/k/enter and the shortcuts indicated ========================================================== &gt; (a)dd a child node (m)ove the current node (d)elete the current node (r)eveal in Finder the current node (o)pen the current node with system editor (q)uicklook the current node (c)opy the current node j キーや k キーで項目を選択するか、直接ショートカットキーを入力することで様々な操作を行うことができます。 よく使用するのは以下のコマンドです。 a: ファイル/ディレクトリを新規作成 m: ファイル/ディレクトリ移動 or ファイル名変更 d: ファイル/ディレクトリを削除 現在編集中のファイルを NERDTree でフォーカスする (NERDTreeFind) Vim で何らかのファイルを編集しているときに、新しく別のファイルを開くと、NERDTree で表示しているツリー階層とファイルの位置が一致しなくなることがあります。 そのような場合は、次のコマンドを実行することで、NERDTree 上で現在編集中のファイルをフォーカスできます。 :NERDTreeFind この NERDTreeFind コマンドはよく使うので、NERDTreeToggle コマンドと合わせて、キーマッピング定義しておくと便利です。 ~/.vimrc &#34; NERDTree 用のキーマップ nnoremap &lt;Leader&gt;nt :&lt;C-u&gt;NERDTreeToggle&lt;CR&gt; nnoremap &lt;Leader&gt;nf :&lt;C-u&gt;NERDTreeFind&lt;CR&gt; NERDTree のブックマーク機能を使用する NERDTree のブックマーク機能を使用すると、よく使用するディレクトリやファイルをすぐに開けるようになります。 NERDTree 上で B と入力すると、ブックマークの一覧を表示／非表示できます。 表示例 ----------Bookmarks---------- maku-sample &lt;box/maku-sample/ mongoose &lt;maku-test-mongoose/ ブックマークを追加するには、対象のノードを選択した状態で以下のように入力します。 プロジェクトの起点となるディレクトリを追加しておくと便利です。 :Bookmark: ブックマークを追加 :Bookmark &lt;名前&gt;: 指定した名前でブックマークを追加 ブックマークを削除するには、一覧上で D と入力します。 参考 ディレクトリエクスプローラー (Explore) を使用してファイルを開く"},{url:"/p/8uionzb/",title:"Linuxメモ: Bash の構文: 関数から戻り値を返す ($?)",date:"2012-07-09T00:00:00+09:00",body:"Linuxメモ: Bash の構文: 関数から戻り値を返す ($?) シェル関数が return で返すことのできる値は 数値 (0～255) だけ です。 return で返された戻り値を参照するには $? を使います。 function myfunc { return 1 } myfunc echo $? 関数の実行結果を文字列として受け取りたい場合は、関数内部で echo した結果を以下のようにバッククォート呼び出しして取得します。 function myfunc { echo &#39;Hello&#39; } val=`myfunc` echo $val"},{url:"/p/52i36fy/",title:"Linuxメモ: Bash の構文: 関数内でローカル変数を扱う (local)",date:"2012-07-09T00:00:00+09:00",body:"Linuxメモ: Bash の構文: 関数内でローカル変数を扱う (local) Bash は関数外と関数内で変数を共有します。 例えば、以下のように関数内で代入を行うと、関数外でセットした値を上書きしてしまいます。 function myfunc { a=200 } 実行例 $ a=100 $ myfunc $ echo $a 200 ★aの値が変わってる！ 関数内だけで有効なローカル変数を扱うには以下のように local キーワードを付けます。 function myfunc { local a=200 } 実行例 $ a=100 $ myfunc $ echo $a 100 ★aの値はそのまま"},{url:"/p/dvd889d/",title:"Linuxメモ: rsync コマンドでディレクトリを同期する",date:"2012-07-05T00:00:00+09:00",body:"Linuxメモ: rsync コマンドでディレクトリを同期する rsync コマンドを使用すると、簡単に 2 つのディレクトリを同期することができます。 下記の例では、src ディレクトリの中身を dst ディレクトリに同期しています。 $ rsync -av src/ dst src の後ろにスラッシュを付ける のを忘れないようにしてください。 このスラッシュを忘れると、dst ディレクトリの中に src ディレクトリができちゃいます。 オプションの -a は archive mode として動作させることを示しており、よく使うオプションをまとめて指定したのと同様の効果があります (例えば、ディレクトリを再帰的にコピー、属性をそのまま保つなど)。 rsync コマンドは更新されているファイルだけをコピーしてくれるので、大量のファイルが格納されていても、同期処理は短時間で完了します。 rsync は、ローカル PC 内のディレクトリの同期だけではなく、リモートホスト上のディレクトリとの同期にも対応しています。 詳しい rsync コマンドの使い方は下記を参照してください。 参考: Linuxコマンド: rsync コマンドで2つのディレクトリを同期する"},{url:"/p/fueucsa/",title:"Python でユニットテストを記述する (unittest)",date:"2012-07-03T00:00:00+09:00",body:"Python でユニットテストを記述する (unittest) Python でユニットテストを書くには、unittest モジュール を使用します。 unittest モジュールは、Python 2.1 以降に標準で搭載されています。 テストケースを作成するには、unittest.TestCase を継承したクラスを作成し、test で始まる名前のテストメソッドを記述するだけで OK です。 unittest.main 関数を呼び出すことにより、それらのテストメソッドが自動的に実行されます。 sample.py import unittest class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def decrement(self): self.count -= 1 def get_count(self): return self.count class CounterTest(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def test_increment(self): c = Counter() c.increment() self.assert_(c.get_count() == 1) c.increment() self.assert_(c.get_count() == 2) def test_decrement(self): c = Counter() c.decrement() self.assert_(c.get_count() == -1) c.decrement() self.assert_(c.get_count() == -2) if __name__ == &#39;__main__&#39;: unittest.main() 各テストの実行前と実行後には、setUp() と tearDown() がそれぞれ呼び出されるようになっているので、ここに各テストの共通コードを記述しておくことができます。 上記の例では、共通コードはないので pass とだけ記述しています。 実行結果 $ python3 sample.py .. -------------------------------------- Ran 2 tests in 0.000s OK"},{url:"/p/wnpquuy/",title:"Python で文字列を置換する (str.replace, re.sub, re.subn)",date:"2012-07-03T00:00:00+09:00",body:"Python で文字列を置換する (str.replace, re.sub, re.subn) Python の文字列オブジェクトの replace メソッドを使うと、その文字列の内容を置換することができます。 正規表現を使った高度な置換を行うには、re モジュールを使用します。 単純な置換 (str.replace) 例: すべての AA を xx に置換する s = &#39;AABBCCAABBCC&#39; s = s.replace(&#39;AA&#39;, &#39;xx&#39;) #=&gt; &#39;xxBBCCxxBBCC&#39; 置換した結果は戻り値として返されるので、元の文字列を変更したい場合は、自分自身に代入する必要があります。 デフォルトではパターンに一致した全ての文字列が置換されます。 例: 最初に見つかった AA を xx に置換 s = &#39;AABBCCAABBCC&#39; s = s.replace(&#39;AA&#39;, &#39;xx&#39;, 1) #=&gt; &#39;xxBBCCAABBCC&#39; 第 3 引数 (count) で、最大いくつまで置換するかを指定 することも可能です。 上記の例では、count=1 と設定することで、最初に一致した部分だけを置換しています。 正規表現を使った置換 (re.sub, re.subn) re モジュールを使うと、正規表現を使った高度な置換を行えるようになります。 正規表現を含む文字列リテラルを記述する場合は、r プレフィックス付けた raw string 記法 (r'...') を使用することで、記号類のエスケープ処理が不要になります。 例: &lsquo;&lt;&rsquo; と &lsquo;&gt;&rsquo; で囲まれた数値を &lsquo;#&rsquo; に置換 import re s = re.sub(r&#39;&lt;\\d+&gt;&#39;, &#39;#&#39;, &#39;aaa&lt;100&gt;bbb&lt;200&gt;ccc&#39;) print(s) # =&gt; &#39;aaa#bbb#ccc&#39; str.replace と同様に、第 3 引数 (count) を指定することで、最大いくつまで置換するかを指定できます。 s = re.sub(r&#39;&lt;\\d+&gt;&#39;, &#39;###&#39;, &#39;aaa&lt;100&gt;bbb&lt;200&gt;ccc&#39;, 1) #=&gt; &#39;aaa###bbb&lt;200&gt;ccc&#39; 正規表現を使って置換するときに、マッチした文字列を置換後の文字列に反映させることができます。 正規表現パターンを ( と ) で囲んでグルーピングしておくと、括弧で囲まれた部分に一致した文字列を \\1、\\2、\\3 などで参照できます（後方参照）。 この後方参照を利用するときは、文字列リテラルの前に r を付ける必要があります。 例: * で囲まれたテキストを &lt;b&gt; タグで囲まれたテキストに置換する import re s = re.sub(r&#39;\\*(.+)\\*&#39;, r&#39;&lt;b&gt;\\1&lt;/b&gt;&#39;, &#39;AAA *BBB* CCC&#39;) print(s) # =&gt; &#39;AAA &lt;b&gt;BBB&lt;/b&gt; CCC&#39; 実際にいくつ置換されたかを知る必要がある場合は、re.subn() を使用します。 import re result, num = re.subn(r&#39;(\\d+)&#39;, r&#39;&lt;\\1&gt;&#39;, &#39;aa11bb22cc&#39;) print(result) #=&gt; &#39;aa&lt;11&gt;bb&lt;22&gt;cc&#39; print(num) #=&gt; 2 正規表現パターンをコンパイルして高速化する いろいろなパターンで re.sub 関数による置換を繰り返し実行する場合は、あらかじめ正規表現パターンを re.compile 関数で正規表現オブジェクトにコンパイルしておくと高速に置換処理を行えるようになります（ただし、1 つのパターンのみを連続して使用する場合は、内部でキャッシュが効くため、re.compile 関数を使用する必要はありません）。 下記の例では、HTML ファイル内の日付、時刻と思われる部分を見つけて強調表示する（em タグで囲む）ように置換しています。 import re # 正規表現パターンをコンパイル DATE_PATTERN = re.compile(r&#39;(\\d{4}-\\d{2}-\\d{2})&#39;) TIME_PATTERN = re.compile(r&#39;(\\d\\d:\\d\\d:\\d\\d)&#39;) # 置換処理の実行 with open(&#39;input.html&#39;) as f: for line in f: line = line.rstrip(&#39;\\r\\n&#39;) line = DATE_PATTERN.sub(r&#39;&lt;em&gt;\\1&lt;/em&gt;&#39;, line) line = TIME_PATTERN.sub(r&#39;&lt;em&gt;\\1&lt;/em&gt;&#39;, line) print(line) このように、2 種類の正規表現オブジェクトを繰り返し使用する場合は、re.compile による事前コンパイルが有効です。 文字列中の 1 文字を変更する Python の文字列は Java や C# と同様に immutable（不変）なので、以下のように文字列内の 1 文字だけを置き換えるということはできません。 s = &#39;ABCDE&#39; s[2] = &#39;x&#39; #=&gt; TypeError: &#39;str&#39; object does not support item assignment 文字列中の 1 文字を変更したい場合は、以下のように新しい文字列を作成します。 s = &#39;ABCDE&#39; s = s[:2] + &#39;x&#39; + s[3:] #=&gt; &#39;ABxDE&#39; あるいは、bytearray オブジェクトを変更可能な文字列のように扱うこともできます。 s = bytearray(&#39;ABCDE&#39;.encode()) s[2] = ord(&#39;x&#39;) print(s.decode()) #=&gt; ABxDE 参考 Python サンプル: 複数ファイルの文字列をまとめて置換する (glob, re)"},{url:"/p/o5744xu/",title:"Linuxメモ: GDBus サーバから signal を発行する",date:"2012-06-25T00:00:00+09:00",body:"Linuxメモ: GDBus サーバから signal を発行する GDBus のサーバ実装側からシグナルを発行するには、gdbus-codegen で生成されたヘッダファイルに定義されている、xxx_emit_xxx という関数を呼び出します。 あるメソッドの実装の中からシグナルを発行するには、そのメソッドの xxx_complete_xxx 関数を呼び出す前に、xxx_emit_xxx 関数を呼び出す必要があります。 // Implementation of &#34;Add&#34; method. gboolean handleAdd(ComExampleMyAppCalc *object, GDBusMethodInvocation *invocation, gint val1, gint val2) { gint ret = val1 + val2; // ここでシグナル発行 com_example_my_app_calc_emit_hoge_hoge(object, &#34;data1&#34;, &#34;data2&#34;); com_example_my_app_calc_complete_add(object, invocation, ret); return TRUE; }"},{url:"/p/uznw8u8/",title:"Linuxメモ: D-Bus Java で P2P D-Bus サーバに接続してメソッドを呼び出すサンプル",date:"2012-06-22T00:00:00+09:00",body:"Linuxメモ: D-Bus Java で P2P D-Bus サーバに接続してメソッドを呼び出すサンプル Main.java import org.freedesktop.dbus.DBusSigHandler; import org.freedesktop.dbus.DirectConnection; import org.freedesktop.dbus.exceptions.DBusException; import com.example.MyApp.Calc; public class Main { private static final String SERVER_ADDR = &#34;unix:abstract=sample&#34;; private static final String OBJECT_PATH = &#34;/com/example/MyApp&#34;; public static void main(String[] args) { try { DirectConnection dc = new DirectConnection(SERVER_ADDR); Calc calc = dc.getRemoteObject(OBJECT_PATH, Calc.class); // ... int result = calc.Add(100, 200); // ... dc.disconnect(); } catch (DBusException e) { e.printStackTrace(); } ... } }"},{url:"/p/y7cx287/",title:"Linuxメモ: GDBus でバイナリデータ（バイト配列）を受け取る方法",date:"2012-06-22T00:00:00+09:00",body:`Linuxメモ: GDBus でバイナリデータ（バイト配列）を受け取る方法 D-Bus メソッド経由でバイト配列を送ろうとして、パラメータのタイプを ay と定義して、gdbus-codegen でコード生成すると、デフォルトでは gchar* 型の文字列データとしてパラメータが定義されてしまいます。 gchar* データとしてやりとりしようとすると、0 を含むデータを受け取れなくなってしまうので、GVariant* としてバイナリデータを受け取る必要があります。 そのためには、Introspection XML の arg 要素の子要素として、以下のように annotation 要素を追加します。 introspection.xml（抜粋） ... &lt;method name=&#34;PushBinaryData&#34;&gt; &lt;arg type=&#34;ay&#34; name=&#34;data&#34; direction=&#34;in&#34;&gt; &lt;annotation name=&#34;org.gtk.GDBus.C.ForceGVariant&#34; value=&#34;true&#34; /&gt; &lt;/arg&gt; &lt;/method&gt; ... すると、GDBus サーバ側のハンドラでは GVariant* 型のパラメータとしてデータを受信できるようになるので、以下のように内部のデータを取得できます。 データのサイズも、GVariant オブジェクトから取得することができます。 // GVariant* variant; const char* p = (const char*) g_variant_get_data(variant); gsize size = g_variant_get_size(variant); for (int i = 0; i &lt; size; ++i) { g_print(&#34;data[%d]=%d\\n&#34;, i, p[i]); }`},{url:"/p/4w6f4u5/",title:"Linuxメモ: glib の GVariant を使ってみる",date:"2012-06-20T00:00:00+09:00",body:`Linuxメモ: glib の GVariant を使ってみる GVariant 型とは 本家ドキュメント GVariantType — introduction to the GVariant type system GVariant — strongly typed value datatype GVariant Format Strings GDBus のライブラリを使って、array や dictionary などのデータをやりとりしようとすると、C の実装としては GVariant 型で扱うことになります。 GVariant オブジェクトが保持するデータの型は、type strings という文字列で表現されます。 例えば、GVariant オブジェクトの type strings が、 &#34;s&#34; と定義されている場合、その GVariant オブジェクトは 1 つの文字列データを保持しています。 以下のサンプルコードは、1 つの文字列データを保持する GVariant オブジェクトを作成し、そこから文字列データを取り出す例です。 Makefile CXX = clang++ MY_LIBS = glib-2.0 CPPFLAGS = $(shell pkg-config --cflags \${MY_LIBS}) LDLIBS = $(shell pkg-config --libs \${MY_LIBS}) sample: sample.cpp sample.cpp #include &lt;glib.h&gt; int main() { // Create a GVariant object. GVariant *variant = g_variant_new(&#34;s&#34;, &#34;Hello&#34;); // Obtain a value from a GVariant object. gchar *val; g_variant_get(variant, &#34;s&#34;, &amp;val); g_print(&#34;value = %s\\n&#34;, val); g_free(val); } 特に、GVariant オブジェクトが１つのデータだけを保持している場合は、専用の関数を使えば type strings の指定は必要なくなります。 例: GVariant オブジェクトに INT32 データを入れる // 作成 GVariant *variant = g_variant_new_int32(100); // 取得 gint32 val = g_variant_get_int32(variant); GVariant オブジェクトは、複数のデータを保持することができます。 例: GVariant に文字列 (s) と数値 (i) と真偽値 (b) を入れる // 作成 GVariant *variant = g_variant_new(&#34;(sib)&#34;, &#34;Hello&#34;, 100, TRUE); // 取得 gchar *valStr; gint32 valInt32; gboolean valBoolean; g_variant_get(variant, &#34;(sib)&#34;, &amp;valStr, &amp;valInt32, &amp;valBoolean); g_print(&#34;%s, %d, %d\\n&#34;, valStr, valInt32, valBoolean); g_free(valStr); GVariant オブジェクトに可変サイズの配列データを持たせる場合は、GVariantBuilder を使って動的にデータを詰めていくことができます。 逆に、GVariant オブジェクトから配列データを順に取り出すには、GVariantIter を使います。 例: バイナリデータ (byte[]) を GVariant で取得する Type string で、ay は byte 配列を表します。 このデータを GVariant で取得するには、g_variant_get() で指定する type string で、@ay のように頭に @ を付けます。 以下の例では、GVariant から「文字列、文字列、byte 配列」を取り出しています。 // 作成 GVariant *variant = ...; // 取得 const char* TYPE_STRING = &#34;(ss@ay)&#34;; gchar* str1 = NULL; gchar* str2 = NULL; GVariant* binary = NULL; g_variant_get(variant, TYPE_STRING, &amp;str1, &amp;str2, &amp;binary); // バイトデータへのポインタと、サイズを取得 gconstpointer dataAddr = g_variant_get_data(binary); gsize dataSize = g_variant_get_size(binary); // バッファ削除 g_free(str1); g_free(str2); g_variant_unref(binary); GVariant データを解放するときは、g_free() ではなく、g_variant_unref() を使うことに注意してください。 例: GVariant に配列データを入れる // 作成 GVariant *create_variant() { GVariantBuilder *builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); for (int i = 0; i &lt; 5; ++i) { g_variant_builder_add(builder, &#34;i&#34;, i); } return g_variant_builder_end(builder); } ... GVariant *variant = create_variant(); // 取得 gint32 val; GVariantIter it; g_variant_iter_init(&amp;it, variant); while (g_variant_iter_next(&amp;it, &#34;i&#34;, &amp;val)) { g_print(&#34;%d, &#34;, val); } dictionary データのループ処理にも、GVariantBuilder や GVariantIter を使うことができます。 // 作成 GVariant *create_variant() { GVariantBuilder *builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); for (int i = 0; i &lt; 5; ++i) { g_variant_builder_add(builder, &#34;{ii}&#34;, i, i*i); } return g_variant_builder_end(builder); } ... GVariant *variant = create_variant(); // 取得 gint32 val1, val2; GVariantIter it; g_variant_iter_init(&amp;it, variant); while (g_variant_iter_next(&amp;it, &#34;{ii}&#34;, &amp;val1, &amp;val2)) { g_print(&#34;%d, %d\\n&#34;, val1, val2); } GVariant オブジェクトに含まれている配列データは、GVariantIter を使わずに、インデックス指定によって取り出すこともできます。 // INT32 の配列 (&#34;ai&#34;) を作成 GVariant *create_variant() { GVariantBuilder *builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); for (int i = 0; i &lt; 5; ++i) { g_variant_builder_add(builder, &#34;i&#34;, i); } return g_variant_builder_end(builder); } int main() { // 作成 GVariant *variant = create_variant(); // 取得 gsize size = g_variant_n_children(variant); for (int i = 0; i &lt; size; ++i) { gint32 val; g_variant_get_child(variant, i, &#34;i&#34;, &amp;val); g_print(&#34;%d\\n&#34;, val); } } GVariant オブジェクトを入れ子にすれば、「INT32 配列の配列」なども作れます。 例: INT32 配列の配列を入れる GVariant *create_child() { GVariantBuilder *builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); g_variant_builder_add(builder, &#34;i&#34;, 111); g_variant_builder_add(builder, &#34;i&#34;, 222); g_variant_builder_add(builder, &#34;i&#34;, 333); return g_variant_builder_end(builder); } int main() { // 作成 &#34;aai&#34; GVariantBuilder *builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); for (int i = 0; i &lt; 3; ++i) { GVariant *child = create_variant(); g_variant_builder_add(builder, &#34;v&#34;, child); } GVariant* variant = g_variant_builder_end(builder); // 取得 gsize size1 = g_variant_n_children(variant); for (int i = 0; i &lt; size1; ++i) { GVariant *child; g_variant_get_child(variant, i, &#34;v&#34;, &amp;child); gsize size2 = g_variant_n_children(child); for (int j = 0; j &lt; size2; ++j) { gint32 val; g_variant_get_child(child, j, &#34;i&#34;, &amp;val); g_print(&#34;%d\\n&#34;, val); } } } 例: GVariant に連想配列の配列を入れる (&ldquo;aa{ss}&rdquo;) a{ss} という type string は、連想配列を表しています。 なので、aa{ss} は連想配列の配列ということになります。 以下のコードは aa{ss} のデータを含む GVariant オブジェクトを処理しています。 gsize num = g_variant_n_children(variant); for (int i = 0; i &lt; num; ++i) { GVariant* child = g_variant_get_child_value(variant, i); gsize mapSize = g_variant_n_children(child); for (int j = 0; j &lt; mapSize; ++j) { gchar* key; gchar* val; g_variant_get_child(child, j, &#34;{ss}&#34;, &amp;key, &amp;val); // ここで key, val を使用 g_free(key); g_free(val); } g_variant_unref(child); }`},{url:"/p/ce62z6o/",title:"Linuxメモ: GDBus で簡単な P2P（クライアント＆サーバ）アプリを実装する",date:"2012-06-11T00:00:00+09:00",body:"Linuxメモ: GDBus で簡単な P2P（クライアント＆サーバ）アプリを実装する GDBus 用のスタブを自動生成する gdbus-codegen コマンドを使用すると、以下のような introspection データからスタブとなるコードを作成することができます。 gdbus-codegen コマンドがインストールされていない場合は以下のようにインストールできます。 $ sudo apt-get install libglib2.0-dev $ sudo apt-get install libglib2.0-doc ここでは、足し算と引き算を行う com.example.MyApp.Calc インタフェースを考えてみます。 interface.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;node name=&#34;/com/example/MyApp&#34;&gt; &lt;interface name=&#34;com.example.MyApp.Calc&#34;&gt; &lt;method name=&#34;Add&#34;&gt; &lt;arg type=&#34;i&#34; name=&#34;val1&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;val2&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;ret_val&#34; direction=&#34;out&#34; /&gt; &lt;/method&gt; &lt;method name=&#34;Subtract&#34;&gt; &lt;arg type=&#34;i&#34; name=&#34;val1&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;val2&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;ret_val&#34; direction=&#34;out&#34; /&gt; &lt;/method&gt; &lt;/interface&gt; &lt;/node&gt; 以下のように実行すると、calc.h と calc.c が生成されます。 $ gdbus-codegen --generate-c-code=calc interface.xml calc.h calc.c GDBus プログラムをビルドするための Makefile を作成する GDBus を使ったコードをビルドのための Makefile を用意します。 ここでは、例として server.cpp というソースコードから、server というプログラムを生成することにします。 Makefile CXX = clang++ MY_LIBS = glib-2.0 gio-unix-2.0 CPPFLAGS = $(shell pkg-config --cflags ${MY_LIBS}) LDLIBS = $(shell pkg-config --libs ${MY_LIBS}) server: server.cpp calc.o client: client.cpp calc.o glib-2.0、gio-unix-2.0 のインクルードパスや、ライブラリ指定は、pkg-config コマンドを利用して生成しています。 glib-object.h で定義されている、g_type_init() などを呼び出すためには、gio-unix-2.0 というライブラリも必要です。 calc.o というのは、gdbus-codegen で自動生成した calc.c から生成されるものとします。 GDBus を使ったサーバとクライアントを実装する クライアントとサーバは、gdbus-codegen によって生成した、プロキシ、スケルトン用の関数を利用して実装します。 クライアント側の通信にはプロキシオブジェクトを使用し、サーバ側のメソッド実装にはスケルトンオブジェクトを使用します。 サーバ側の実装 server.cpp gdbus-codegen で生成したヘッダファイルを除くと、以下のような handle_XXX という関数ポインタをもつ構造体が定義されています。 Introspection XML で、Add メソッドと Subtract メソッドを定義したので、handle_add と handle_subtract という関数ポインタが生成されていることが分かります。 struct _ComExampleMyAppCalcIface { GTypeInterface parent_iface; gboolean (*handle_add) ( ComExampleMyAppCalc *object, GDBusMethodInvocation *invocation, gint arg_val1, gint arg_val2); gboolean (*handle_subtract) ( ComExampleMyAppCalc *object, GDBusMethodInvocation *invocation, gint arg_val1, gint arg_val2); }; この関数ポインタのシグネチャに合わせて、各メソッドを実装します。 各メソッドから値を返すには、それぞれのメソッド用に生成された complete_XXX 関数を呼び出します。 // Implementation of &#34;Add&#34; method. gboolean handleAdd(ComExampleMyAppCalc *object, GDBusMethodInvocation *invocation, gint val1, gint val2) { gint ret = val1 + val2; com_example_my_app_calc_complete_add(object, invocation, ret); return TRUE; } // Implementation of &#34;Subtract&#34; method. gboolean handleSubtract(ComExampleMyAppCalc *object, GDBusMethodInvocation *invocation, gint val1, gint val2) { gint ret = val1 - val2; com_example_my_app_calc_complete_subtract(object, invocation, ret); return TRUE; } 後は、クライアントからの接続時に毎回呼び出されるコネクションハンドラの中で、XXX_skeleton_new() を使ってサーバサイドの Skeleton オブジェクトを生成し、上記で実装した各関数のポインタをセットしたら、XXX_skeleton_export() すれば OK です。 // Called when the client connects to the server. void handleConnect(GDBusServer *server, GDBusConnection *conn, gpointer data) { ComExampleMyAppCalc *skel = com_example_my_app_calc_skeleton_new(); ComExampleMyAppCalcIface *iface = COM_EXAMPLE_MY_APP_CALC_GET_IFACE(skel); iface-&gt;handle_add = handleAdd; iface-&gt;handle_subtract = handleSubtract; GError *error = NULL; gboolean ret = g_dbus_interface_skeleton_export( G_DBUS_INTERFACE_SKELETON(skel), conn, OBJECT_PATH, &amp;error); if (!ret) { g_error(&#34;g_dbus_interface_skeleton_export() failed: %s&#34;, error-&gt;message); exit(-1); } } クライアント側の実装 client.cpp クライアントの実装でプロキシオブジェクトを生成するには、gdbus-codegen で自動生成された XXX_proxy_new_sync() などの関数を使用します。 プロキシオブジェクトを生成したら、各メソッドを呼び出せるようになります。 メソッドの呼び出しは、gdbus-codegen で生成された _call_XXX_sync() などの関数を使用します。 gint ret; com_example_my_app_calc_call_add_sync(proxy, 100, 200, &amp;ret, NULL, NULL);"},{url:"/p/m2k3jyg/",title:"Python で XML を構築する (minidom)",date:"2012-06-08T00:00:00+09:00",body:`Python で XML を構築する (minidom) 下記は、Python の minidom モジュールが提供する DOM インタフェースを使用して XML を構築し、XML ファイルとして保存するサンプルです。 sample.py import codecs from xml.dom import minidom def create_xmldoc(): doc = minidom.Document() tree = doc.createElement(&#39;tree&#39;) doc.appendChild(tree) branch = doc.createElement(&#39;branch&#39;) tree.appendChild(branch) leaf = doc.createElement(&#39;leaf&#39;) leaf.setAttribute(&#39;id&#39;, &#39;001&#39;) branch.appendChild(leaf) text = doc.createTextNode(&#39;This is a leaf&#39;) leaf.appendChild(text) return doc def save_xmldoc(xmldoc, filepath): f = codecs.open(filepath, &#39;wb&#39;, encoding=&#39;utf-8&#39;) # Text encoding xmldoc.writexml(f, &#39;&#39;, &#39; &#39;*2, &#39;\\n&#39;, encoding=&#39;UTF-8&#39;) # XML header&#39;s encoding f.close() if __name__ == &#39;__main__&#39;: doc = create_xmldoc() save_xmldoc(doc, &#39;output.xml&#39;) codecs.open() で指定する encoding パラメータは、出力するテキストファイル自体のエンコーディング形式を表しており、Document#writexml() で指定する encoding パラメータは、XML のヘッダに書き込まれるエンコーディング形式を表していることに注意してください。 実行結果 (output.xml) &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;tree&gt; &lt;branch&gt; &lt;leaf id=&#34;001&#34;&gt;This is a leaf&lt;/leaf&gt; &lt;/branch&gt; &lt;/tree&gt;`},{url:"/p/ru9mxam/",title:"Python のクラス定義の基本 (class)",date:"2012-06-07T00:00:00+09:00",body:"Python のクラス定義の基本 (class) class キーワードを使って、Python のクラスを定義することができます。 コンストラクタとインスタンスメソッド メソッドは通常の関数と同様に def キーワードで定義していくのですが、__init__ という名前のメソッドを定義すると、インスタンス生成時（クラス名()）に呼び出されるコンストラクタとして扱われます。 コンストラクタの中では、自分自身のインスタンスを参照するための self を使って、属性の初期化などを行います。 Person クラスを定義してみる class Person: &#34;&#34;&#34;クラスの説明をここに書く&#34;&#34;&#34; def __init__(self, name: str): &#34;&#34;&#34;コンストラクタの説明をここに書く&#34;&#34;&#34; self.name = name def hello(self): &#34;&#34;&#34;メソッドの説明をここに書く&#34;&#34;&#34; print(f&#34;Hello, {self.name}!&#34;) コンストラクタやメソッドの第 1 引数には、必ず自分自身のインスタンスを参照するための self 引数を配置します。 実際には、名前は何でもよいのですが、公式のスタイルガイドで self という名前を使うことが推奨されています（参考: PEP 8）。 上記のように定義したクラスは、次のように使用することができます。 person = Person(&#34;maku&#34;) # インスタンスを生成する person.hello() # メソッドを呼び出す 実行例 $ python main.py Hello, maku! クラス属性 (class attribute) クラス属性 は、インスタンスを生成せずにアクセスできる属性です。 次のクラスは、num というクラス属性を持っています。 クラス属性には、クラス名.クラス属性名 という形でアクセスできます。 クラス属性を定義する # クラス属性を持つクラス class Holder: num: int = 0 # クラス属性を参照する print(Holder.num) # =&gt; 0 Holder.num = 100 print(Holder.num) # =&gt; 100 クラス定数も同様に定義できます。 名前を大文字にするだけです。 クラス定数を定義する # クラス定数を持つクラス class Author: NAME: str = &#34;Maku&#34; AGE: int = 14 # クラス定数を参照する print(Author.NAME) # =&gt; Maku print(Author.AGE) # =&gt; 14 クラスメソッド (class method) クラスメソッド は、インスタンスを生成せずに呼び出せるメソッドで、@classmethod デコレーターを使って定義します。 クラスメソッドの第 1 引数には、自身のクラスメソッドを示す cls を配置します（この名前も、PEP 8 で推奨されています）。 クラスメソッドの中からは、cls.クラス属性名 という形で、クラス属性にアクセスできます。 クラスメソッドを定義する class Holder: num = 0 @classmethod def print(cls): print(cls.num) if __name__ == &#34;__main__&#34;: Holder.num = 1 Holder.print() # =&gt; 1 クラスメソッドは、ファクトリーメソッドの実装に使われることがあります。 次の mysterios_person メソッドは、特殊な Person インスタンスを生成するためのファクトリーメソッドです。 class Person: def __init__(self, name: str, age: int): self.name = name self.age = age @classmethod def mysterious_person(cls) -&gt; &#34;Person&#34;: return cls(name=&#34;John Doe&#34;, age=20) # 使用例: ファクトリーメソッドでインスタンス生成 person = Person.mysterious_person() 静的メソッド (static method) 静的メソッド は、インスタンスを生成せずに呼び出せるメソッドで、@staticmethod デコレーターを使って定義します。 静的メソッドはクラスメソッドと異なり、第 1 引数で cls を受け取りません。 単なる関数とほぼ同等ですが、クラス内で静的メソッドとして定義することにより、そのクラスに関連するユーティリティ関数であることが明確になります。 また、クラスをインポートするだけで静的メソッドにアクセスできるようになるなどの利点もあります。 class Formatter: # ... @staticmethod def make_indent(level: int) -&gt; str: return &#34; &#34; * 4 * level メソッドや属性を private にする クラス内のメソッドや属性を private 扱いにするには、メソッド名の前にアンダースコア _ を 1 つ付けます。 ただし、これは単なる慣習で、実際には外からアクセスできてしまいます。 class Person: def __init__(self, name: str, age: int): self._name = name self._age = age if __name__ == &#34;__main__&#34;: p = Person(&#34;Maku&#34;, 14) print(p._name) # 見えちゃう print(p._age) # 見えちゃう 外からアクセスできないようにするには、メソッド名の前にアンダースコアを 2 つ付けます。 class Person: def __init__(self, name: str, age: int): self.__name = name self.__age = age if __name__ == &#34;__main__&#34;: p = Person(&#34;Maku&#34;, 14) print(p.__name) # エラー！ print(p.__age) # エラー！ ☝️ Name Mangling アンダースコアを 2 つ付けたときに外から属性にアクセスできなくなるのは、Python の Name Mangling（名前修飾） という仕組みが働いているからです。 属性名がアンダースコア 2 つで始まっていると、Python は内部的にその属性名を _クラス名__属性名 という名前に置き換えます。 この仕組みにより、外部からの不用意なアクセスを避けるとともに、サブクラスで定義された属性の名前との衝突を防ぐ効果があります。"},{url:"/p/guducs9/",title:"Python で XML をパースする (minidom)",date:"2012-06-04T00:00:00+09:00",body:"Python で XML をパースする (minidom) Python 2.0 以降では、Document Object Model インタフェース (DOM API) の最小の実装として、xml.dom.minidom が搭載されています。 DOM 標準の API を使って操作する必要のない場合は、よりシンプルなインターフェースを提供している ElementTree モジュールを使用する のがよいでしょう。 Document オブジェクトを取得する minidom を使用して、XML の各要素にアクセスするためには、まずは DOM 全体を表現する xml.dom.minidom.Document オブジェクトを取得する必要があります。 データソースとしては、XML ファイル、XML 文字列、Web 上のリソースなどを利用できます。 XML ファイルを扱う場合 from xml.dom import minidom doc = minidom.parse(&#34;input.xml&#34;) print(doc.toxml()) XML 文字列を扱う場合 from xml.dom import minidom xml = &#34;&#34;&#34; &lt;tree&gt; &lt;branch&gt; &lt;leaf id=&#39;1&#39;&gt;Leaf 1&lt;/leaf&gt; &lt;leaf id=&#39;2&#39;&gt;Leaf 2&lt;/leaf&gt; &lt;leaf id=&#39;3&#39;&gt;Leaf 3&lt;/leaf&gt; &lt;/branch&gt; &lt;/tree&gt;&#34;&#34;&#34; doc = minidom.parseString(xml) print(doc.toxml()) Web 上の XML リソースを扱う場合 urllib モジュールを組み合わせて使えば、Web 上の XML も簡単にパースできます。 from urllib.request import urlopen from xml.dom import minidom with urlopen(&#34;https://example.com/test.xml&#34;) as res: doc = minidom.parse(res) print(doc.toxml()) DOM リソースの解放 使用し終わった Document オブジェクトは、ガーベジ・コレクションによって自動的に解放されますが、unlink メソッドで明示的に解放することもできます。 dom.unlink() Document オブジェクトを生成するときに with 構文を使用すれば、unlink 処理を自動化することができます。 with minidom.parse(&#34;input.xml&#34;) as doc: print(doc.toxml()) タグ名を指定して要素を取得する (getElementsByTagName) Document#getElementsByTagName メソッドを使うと、指定したタグ名の要素のリスト（NodeList オブジェクト）を取得することができます。 子ノードを再帰的に検索するので、同じタグ名を持つ要素はすべてリストに含まれます。 ノードが見つからない場合は、None が返されます。 books = doc.getElementsByTagName(&#34;book&#34;) 上記の例では、Document オブジェクトの getElementsByTagName メソッドを呼び出しているので、全てのノードが検索対象になりますが、特定のノード (Element) の getElementsByTagName メソッドを呼び出すと、そのノード以下のノードのみが検索対象となります。 authors = books[0].getElementsByTagName(&#34;author&#34;) sample.py（サンプルコード） from xml.dom import minidom xml = &#39;&#39;&#39; &lt;tree&gt; &lt;branch&gt; &lt;leaf id=&#39;1&#39;&gt;Leaf 1&lt;/leaf&gt; &lt;leaf id=&#39;2&#39;&gt;Leaf 2&lt;/leaf&gt; &lt;leaf id=&#39;3&#39;&gt;Leaf 3&lt;/leaf&gt; &lt;/branch&gt; &lt;/tree&gt;&#39;&#39;&#39; doc = minidom.parseString(xml) elems = doc.getElementsByTagName(&#34;leaf&#34;) for e in elems: print e.attributes[&#34;id&#34;].value print e.firstChild.data 実行結果 $ python3 sample.py 1 Leaf 1 2 Leaf 2 3 Leaf 3 テキストノードの値を取得する diary.xml &lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;diary&gt; &lt;entry&gt;ほげほげ&lt;empty/&gt;ぽにょぽにょ&lt;/entry&gt; &lt;/diary&gt; sample.py from xml.dom import minidom def getText(nodeList): text = &#34;&#34; for node in nodeList: if node.nodeType == node.TEXT_NODE: text += node.data return text doc = minidom.parse(&#34;sample.xml&#34;) nodeList = doc.getElementsByTagName(&#34;entry&#34;) print(getText(nodeList[0].childNodes)) 実行結果 ほげほげぽにょぽにょ 属性値を取得する sample.py from xml.dom import minidom doc = minidom.parseString(&#39;&lt;books&gt;&lt;book id=&#34;001&#34;/&gt;&lt;/books&gt;&#39;) elem = doc.getElementsByTagName(&#34;book&#34;)[0] print(elem.getAttributeNode(&#34;id&#34;).nodeValue) 実行結果 001 ノードの子ノードを全て取得する childNodes = node.childNodes ノード名（要素名）を取得する sample.py from xml.dom import minidom doc = minidom.parseString(&#39;&lt;books&gt;&lt;book&gt;&lt;author&gt;AAA&lt;/author&gt;&lt;/book&gt;&lt;/books&gt;&#39;) elem = doc.getElementsByTagName(&#39;book&#39;)[0] print(elem.nodeName) # =&gt; &#34;book&#34; 指定した要素をループで処理する 次の例では、book というタグ名の要素をすべて取得してループ処理しています。 books.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;books&gt; &lt;book id=&#34;100&#34;&gt;Book name1&lt;/book&gt; &lt;book id=&#34;200&#34;&gt;Book name2&lt;/book&gt; &lt;book id=&#34;300&#34;&gt;Book name3&lt;/book&gt; &lt;/books&gt; sample.py from xml.dom.minidom import parse # Parse a xml file. doc = parse(&#34;books.xml&#34;) # Get all book nodes nodeList = doc.getElementsByTagName(&#34;book&#34;) # Show text data. for node in nodeList: print &#34;Book ID =&#34;, node.getAttributeNode(&#34;id&#34;).nodeValue print &#34;Book Name =&#34;, node.childNodes[0].data 実行結果 Book ID = 100 Book Name = Book name1 Book ID = 200 Book Name = Book name2 Book ID = 300 Book Name = Book name3 子ノードをループで処理する 次の例では、books 以下の複数の子ノード (book) をループ処理しています。 books.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;books&gt; &lt;book&gt; &lt;name&gt;Book name1&lt;/name&gt; &lt;author&gt;Author 1&lt;/author&gt; &lt;author&gt;Author 2&lt;/author&gt; &lt;author&gt;Author 3&lt;/author&gt; &lt;/book&gt; &lt;book&gt; &lt;name&gt;Book name2&lt;/name&gt; &lt;author&gt;Author 1&lt;/author&gt; &lt;author&gt;Author 2&lt;/author&gt; &lt;/book&gt; &lt;/books&gt; sample.py from xml.dom.minidom import parse # Parse a xml file. doc = parse(&#34;books.xml&#34;) # Get all book nodes nodeList = doc.getElementsByTagName(&#34;book&#34;) # Process book nodes for node in nodeList: # Process book&#39;s child nodes for child in node.childNodes: if child.nodeName == &#34;name&#34;: print &#34;Book name:&#34;, child.childNodes[0].data elif child.nodeName == &#34;author&#34;: print &#34;Author:&#34;, child.childNodes[0].data 実行結果 Book name: Book name1 Author: Author 1 Author: Author 2 Author: Author 3 Book name: Book name2 Author: Author 1 ノードがテキストノードが調べる if node.nodeType == node.TEXT_NODE: print &#34;This is a text node&#34; ノードに属性を追加する／属性の値を変更する Element オブジェクトの setAttribute(self, attname, value) メソッドを使用して、任意のノードの属性を設定することができます。 id 属性の値を変更する from xml.dom import minidom doc = minidom.parseString(&#39;&lt;books&gt;&lt;book id=&#34;old&#34;/&gt;&lt;/books&gt;&#39;) nodeList = doc.getElementsByTagName(&#39;book&#39;) nodeList[0].setAttribute(&#39;id&#39;, &#39;002&#39;) print(doc.toxml()) 実行結果 &lt;?xml version=&#34;1.0&#34; ?&gt;&lt;books&gt;&lt;book id=&#34;new&#34;/&gt;&lt;/books&gt; テキストノードの値を変更する Element オブジェクトの nodeValue 属性の値を設定することで、テキストノードの値を変更することができます。 テキストノードの値を変更する from xml.dom import minidom doc = minidom.parseString(&#39;&lt;book&gt;Old text&lt;/book&gt;&#39;) nodeList = doc.getElementsByTagName(&#39;book&#39;) bookNode = nodeList[0] bookNode.childNodes[0].nodeValue = &#39;New text&#39; print(doc.toxml()) 実行結果 &lt;?xml version=&#34;1.0&#34; ?&gt;&lt;book&gt;New text&lt;/book&gt;"},{url:"/p/atszfrg/",title:"Linuxメモ: D-Bus Java で Session bus に接続してメソッドを呼び出す",date:"2012-05-15T00:00:00+09:00",body:"Linuxメモ: D-Bus Java で Session bus に接続してメソッドを呼び出す D-Bus Java の CreateInterface コマンドを使用すると、API インタフェースを定義した XML ファイル (introspection data) から、Java のインタフェースを作成することができます。 ここでは、以下のような XML ファイルからインタフェースを生成します（セッションバスなどで公開されているオブジェクトに接続して生成することもできます）。 interface.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;node name=&#34;/com/example/MyApp&#34;&gt; &lt;interface name=&#34;com.example.MyApp.Calc&#34;&gt; &lt;method name=&#34;Add&#34;&gt; &lt;arg type=&#34;i&#34; name=&#34;val1&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;val2&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;ret_val&#34; direction=&#34;out&#34; /&gt; &lt;/method&gt; &lt;method name=&#34;Subtract&#34;&gt; &lt;arg type=&#34;i&#34; name=&#34;val1&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;val2&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;ret_val&#34; direction=&#34;out&#34; /&gt; &lt;/method&gt; &lt;/interface&gt; &lt;/node&gt; 生成 $ CreateInterface interface.xml &gt; Calc.java 以下のようなファイルが生成されます。シンプル！ Calc.java /* File: com/example/MyApp/Calc.java */ package com.example.MyApp; import org.freedesktop.dbus.DBusInterface; public interface Calc extends DBusInterface { public int Add(int val1, int val2); public int Subtract(int val1, int val2); } 次に、これを使ってクライアントのコードを記述します。 GLib bindings を使った場合のコードと比べると、かなりシンプルです。 $ mkdir -p com/example/MyApp $ mv Calc.java com/example/MyApp Main.java import org.freedesktop.dbus.DBusConnection; import org.freedesktop.dbus.exceptions.DBusException; import com.example.MyApp.Calc; public class Main { public static void main(String[] args) { DBusConnection conn = null; Calc calc = null; try { conn = DBusConnection.getConnection(DBusConnection.SESSION); calc = (Calc) conn.getRemoteObject( &#34;com.example.MyApp&#34;, // Bus name &#34;/com/example/MyApp&#34;, // Object path Calc.class); // Interface } catch (DBusException ex) { System.err.println(&#34;Failed to obtain a remote object.&#34;); System.err.println(ex.getMessage()); System.exit(1); } try { int a = calc.Add(100, 200); int b = calc.Subtract(100, 200); System.out.println(a); System.out.println(b); } catch (RuntimeException ex) { System.err.println(&#34;Failed to invoke a remote method.&#34;); System.err.println(ex.getMessage()); } conn.disconnect(); // これがないとプログラム終了しない } } 実行結果 300 -100 ソースコード一式 dbus-java-session-bus.zip"},{url:"/p/y3w7mc2/",title:"Linuxメモ: D-Bus 関連用語",date:"2012-05-14T00:00:00+09:00",body:"Linuxメモ: D-Bus 関連用語 D-Bus 系のライブラリを使用するにあたって、知っておくべき用語を解説します。 Bus D-Bus の通信は、Bus を通して行われます。 Bus は、message bus という特殊なアプリケーション (daemon) が保持しており、以下のような種類があります。 system bus システム内で１つだけ存在する。カーネルレイヤの情報も収集し、USB 接続の検出などにも使われている。 session buses ユーザごとに存在する。一番よく使われるバス。Desktop bus とも呼ばれる。 private buses ２アプリが Peer-to-Peer で接続するためのバス。 Message Bus 経由で伝達する際の、データの１単位を表します。 プログラムで言うと１つのメソッド呼び出しのやり取りに相当します。 メッセージは内部的には非同期通信ですが、各ライブラリ (Bindings) の API として、同期メソッドが提供されています。 Namespace / Address Service name (Bus name) 個々のアプリケーションのバスへの &ldquo;Connection&rdquo; を示す名前。 ドキュメントによっては、&ldquo;bus names&rdquo; と読んでいるが、正確にはバスの名前ではなく、個々のバスへの &ldquo;接続&rdquo; を示す名前であることに注意。 （あくまで、バスの実体は system bus、session bus として存在していて、ここで言う &ldquo;bus name&rdquo;（接続を意味する）とは概念が異なる。） Service 名は、接続相手となるアプリの接続を指定するために使われるので、Java の package 名のように一意な名前をつける必要がある。 接続は一般的には１アプリで１つであり、例えば、mycompany.com というドメインを持つ会社が作成する MyApp というアプリの接続なら、com.mycompany.MyApp というようにドメイン名を逆順に使って名前を付ければよい。 同じアプリケーションが同時に複数起動するケースを考慮する場合は、それぞれのアプリの接続に別の Service 名を割り当てる必要がある。そのような場合は、例えば、Process ID を付加することで一意な Service 名を作り出す。 Object path それぞれの Service は複数の Object を公開することができ、それぞれの Object は複数の Interface を公開することができる。 Object 名は、Object path と呼ばれ、ディレクトリ構造のように / で区切った名前を定義する。 Object path は、必ず / で始めるため、最短でも &ldquo;/&rdquo; の一文字で構成される。 Object path は、一般的には Bus name と同様にドメイン名を使って、一意な Object path を付けることが多い（Object path の例: /com/mycompany/MyApp）。 実際には、アプリ要件ごとに柔軟に定義することができ、例えば、スプレッドシートアプリなら、1 つのセルを表す &ldquo;/cell/A/10&rdquo; のような Object path を定義することができる。 Interface Bus 経由で公開されるメソッド、シグナルの集まりのこと。メソッド名、パラメータ、戻り値などが定義される。 実際にプログラムで実装するメソッド名と合わせる必要はないが、通常は合わせる（Interface の例: org.freedesktop.DBus.Peer）。 Method &amp; Signal メソッド名は Interface 名に続く形で表現される（Interface名＋Method名の例: org.freedesktop.DBus.Peer.Ping）。 Method 名だけでメソッドを一意に識別できる場合は、Method 呼び出し時に Interface 名を省略することができる（別の Interface にも同名のメソッドがある場合は、どちらのメソッドが呼び出されるか分からない）。 シグナルも同じように表現されるが、メソッドと違って一方通行のブロードキャストメッセージなので、戻り値は存在しない（投げっぱなし）。"},{url:"/p/dqd9932/",title:"Linuxメモ: D-Bus Java をインストールする",date:"2012-05-11T00:00:00+09:00",body:"Linuxメモ: D-Bus Java をインストールする （Ubuntu 12.04 で確認） 必要なファイルのダウンロード 以下から、dbus-java-2.7.tar.gz などをダウンロードします。 http://www.freedesktop.org/wiki/Software/DBusBindings INSTALL ドキュメントを見ると、他にも Metthew さんのライブラリが必要のようなので、以下から libmatthew-java-0.8.tar.gz などをダウンロードします。 http://www.matthew.ath.cx/projects/java/ ライブラリ (*.jar *.so) ファイルのビルド libmatthew-java のビルド $ tar xzvf libmatthew-java-0.8.tar.gz $ cd libmatthew-java-0.8 $ make jni.h が見つからないと言われたら、Makefile を編集して、jni.h のディレクトリにパスを通してから make を実行します。 INCLUDE+= ....... -I/usr/lib/jvm/java-7-openjdk-amd64/include make install まで実行すると、システムに jar ファイルと so ファイルがインストールされるのですが、ここでは、Linux 環境の汚染を防ぐために、make install は行わないことにします（プロジェクトごとに jar ファイルのクラスパスを指定するようにします）。 dbus-java のビルド dbus-java-2.7 のビルドには JDK の version 1.6 が必要そうです (dbus-java のコードが Java の Generics 構文などに対応できていません)。 JDK 1.6 がインストールされていない場合は先にインストールします。 Ubuntu での例 $ sudo apt-get install openjdk-6-jdk $ sudo update-java-alternatives -s java-1.6.0-openjdk-amd64 また、msgfmt コマンドも必要なので、gettext パッケージをインストールします。 $ sudo apt-get install gettext dbus-java のビルドには、libmatthew-java の jar ライブラリ群が必要なので、カレントディレクトリにコピーします。 $ cp ../libmatthew-java-0.8/debug-disable-1.1.jar ./debug-disable.jar $ cp ../libmatthew-java-0.8/hexdump-0.2.jar ./hexdump.jar $ cp ../libmatthew-java-0.8/unix-0.5.jar ./unix.jar ビルド $ JAVAUNIXJARDIR=. make bin エラーは色々出ますが、何とか libdbus-java-2.7.jar は生成できます。 システムに jar ファイルや CreateInterface などのコマンドをインストールしてしまうには、sudo make install を実行します。 使ってみる D-Bus Java を使ったサンプルコードのビルド、実行を試してみます。 Main.java import org.freedesktop.dbus.DBusConnection; import org.freedesktop.dbus.exceptions.DBusException; public class Main { public static void main(String[] args) { System.out.println(&#34;Connect to the system bus&#34;); DBusConnection conn = null; try { conn = DBusConnection.getConnection(DBusConnection.SYSTEM); } catch (DBusException ex) { System.err.println(ex.getMessage()); System.exit(1); } System.out.println(&#34;Disconnect&#34;); conn.disconnect(); } } ビルドや実行のためには、libdbus-java 関連の jar ファイルや so ファイルが必要です。 $ cp ../dbus-java-2.7/libdbus-java-2.7.jar . $ cp ../libmatthew-java-0.8/debug-disable-1.1.jar . $ cp ../libmatthew-java-0.8/debug-enable-1.1.jar . $ cp ../libmatthew-java-0.8/hexdump-0.2.jar . $ cp ../libmatthew-java-0.8/unix-0.5.jar . $ cp ../libmatthew-java-0.8/libunix-java.so . サンプルプログラムのビルド $ javac -cp libdbus-java-2.7.jar Main.java サンプルプログラムの実行 $ CP=./debug-disable-1.1.jar:./debug-enable-1.1.jar:./hexdump-0.2.jar:libdbus-java-2.7.jar:./unix-0.5.jar:. $ java -cp $CP -Djava.library.path=. Main 何もエラーがなく実行されれば成功です。"},{url:"/p/rexgyo3/",title:"Linuxメモ: D-Bus 関連リンクと関連ツール",date:"2012-05-10T00:00:00+09:00",body:"Linuxメモ: D-Bus 関連リンクと関連ツール GDBus [本家] Highlevel D-Bus Support [本家] Lowlevel D-Bus Support GDBusServer (Peer-to-Peer の実装サンプル） gdbus-codegen ツールの使い方 D-Bus Java DBus-Java Documentation（Javadoc もあります） D-Bus low-level API や GLib bindings のコードを最初に見るよりも、先に Java bindings を使ってみるのが使い方のイメージを掴みやすいかも。 その他のリンク D-Bus GLib bindings - Reference Manual Development/Tutorials/D-Bus - KDE TechBase maemo.org - Plain_html: D. Source code for the GLib D-Bus synchronous example DBus low-level API を使ったサンプルコード D-Bus 関連ツール qdbusviewer (for Linux) GUI で、System Bus、Session Bus 上のサービスを一覧にし、そのサービスが公開しているオブジェクトと、メソッド＆シグナルも一覧にできるツール。メソッドの呼び出しと、その Reply の確認なども行えます。 qdbus (for Linux) qdbusviewer を CUI 版にしたようなツール。特に理由がなければ、qdbusviewer を使ったほうが便利です。"},{url:"/p/53cn789/",title:"Linuxメモ: dbus-glib で method call を実装する（クライアント側の実装）",date:"2012-05-10T00:00:00+09:00",body:"Linuxメモ: dbus-glib で method call を実装する（クライアント側の実装） dbus-binding-tool を使用すると、クライアント側の実装に使うヘッダーファイルとして、 以下のようなコードが自動生成されます。 client.h（抜粋） gboolean com_example_DBus_Test_Calc_add(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, gint* OUT_return_val, GError **error) { return dbus_g_proxy_call(proxy, &#34;add&#34;, error, G_TYPE_INT, IN_val1, G_TYPE_INT, IN_val2, G_TYPE_INVALID, G_TYPE_INT, OUT_return_val, G_TYPE_INVALID); } gboolean com_example_DBus_Test_Calc_subtract(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, gint* OUT_return_val, GError **error) { return dbus_g_proxy_call(proxy, &#34;subtract&#34;, error, G_TYPE_INT, IN_val1, G_TYPE_INT, IN_val2, G_TYPE_INVALID, G_TYPE_INT, OUT_return_val, G_TYPE_INVALID); } Async （非同期）版のコードも生成されていることが分かります。 DBusGProxyCall* com_example_DBus_Test_Calc_add_async(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, com_example_DBus_Test_Calc_add_reply callback, gpointer userdata) { // ... return dbus_g_proxy_begin_call(...); } DBusGProxyCall* com_example_DBus_Test_Calc_subtract_async(DBusGProxy *proxy, const gint IN_val1, const gint IN_val2, com_example_DBus_Test_Calc_subtract_reply callback, gpointer userdata) { // ... return dbus_g_proxy_begin_call(...); }"},{url:"/p/gqfnr2z/",title:"Linuxメモ: GDBus と dbus-glib",date:"2012-05-09T00:00:00+09:00",body:"Linuxメモ: GDBus と dbus-glib D-Bus の low-level API は libdbus というライブラリで提供されています。 通常、D-Bus アプリケーションを作成するときは、この low-level API だけ使用してコーディングするのではなく、D-Bus binding と呼ばれる、より上位のライブラリを使用します（というような記述が、D-Bus の API ドキュメントのトップに書いてあります）。 http://dbus.freedesktop.org/doc/api/html/index.html 例えば C 言語の場合は、dbus-glib や GDBus などがあります。 現在は dbus-glib は obsolete になっていて、GDBus が GIO ライブラリの一部として提供されているようです（glib-2.30.x 以降でサポート）。 とはいえ、現状は GDBus の情報はネット上にほとんどありません。 それぞれのライブラリで、API のプレフィックスが以下のように異なっているので、サンプルコードなどを読むときに、どのライブラリを使用しているかの判断基準になります。 Low-level API: dbus_XXX dbus-glib API: dbus_g_XXX GDBus API: g_dbus_XXX GDBus は dbus-glib と違い、内部で libdbus を使用していません。 GDBus は type system として GVariant をバリバリ使うので、GVariant についてマスターしている必要があります（はっきり言って、GVariant 使ったコードはあまり美しくないです）。 XML introspection データからグルーコード（Stub とか Proxy とか）を作成するツールがあるのですが、dbus-glib が dbus-binding-tool を使うのに対し、GDBus は gdbus-codegen というツールを使用します。"},{url:"/p/ed9gaii/",title:"Linuxメモ: dbus-glib で method call を実装する（サーバ側の実装）",date:"2012-05-08T00:00:00+09:00",body:"Linuxメモ: dbus-glib で method call を実装する（サーバ側の実装） 下記は dbus-glib によるサーバ実装のファイル一式です。 dbus-glib-server.zip 実行してから qdbusviewer アプリの表示を見ると、セッションバスに登録された com.example.MyApp サービスを確認することができます。 ちゃんと、com.example.MyApp.Calc インタフェースが公開されていることが分かります。"},{url:"/p/uzr93f8/",title:"Linuxメモ: dbus-glib で method call を実装する（ヘッダファイルの生成）",date:"2012-05-08T00:00:00+09:00",body:"Linuxメモ: dbus-glib で method call を実装する（ヘッダファイルの生成） ここでは、D-Bus (GLib bindings) を使って、リモートメソッド呼び出しを実現してみます。 名前は以下のように定義し、リモートでの足し算 (Add) と引き算 (Subtract) を実装します。 Bus name com.example.MyApp Object path /com/example/MyApp Interface com.example.MyApp.Calc Method Add(in INT32, in INT32, out INT32) Subtract(in INT32, in INT32, out INT32) dbus-binding-tool を使って、XML ファイルからサーバ、クライアント実装用のヘッダファイルを生成できます。 interface.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;node name=&#34;/com/example/MyApp&#34;&gt; &lt;interface name=&#34;com.example.MyApp.Calc&#34;&gt; &lt;method name=&#34;Add&#34;&gt; &lt;arg type=&#34;i&#34; name=&#34;val1&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;val2&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;ret_val&#34; direction=&#34;out&#34; /&gt; &lt;/method&gt; &lt;method name=&#34;Subtract&#34;&gt; &lt;arg type=&#34;i&#34; name=&#34;val1&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;val2&#34; direction=&#34;in&#34; /&gt; &lt;arg type=&#34;i&#34; name=&#34;ret_val&#34; direction=&#34;out&#34; /&gt; &lt;/method&gt; &lt;/interface&gt; &lt;/node&gt; ヘッダファイルの生成 $ dbus-binding-tool --mode=glib-server --prefix=ServerImpl interface.xml &gt; server_autogen.h $ dbus-binding-tool --mode=glib-client interface.xml &gt; client_autogen.h サーバ側のヘッダファイルを生成するときは、必ずプレフィックスを指定する必要があるようです。 これは、メソッド実装側のメソッド名のプレフィックスとして付きます。"},{url:"/p/sok5efu/",title:"Vim でカーソル位置の単語をファイル名としてファイルを開く (gf, Ctrl-w gf, Cgtrl-w f)",date:"2012-05-03T00:00:00+09:00",body:"Vim でカーソル位置の単語をファイル名としてファイルを開く (gf, Ctrl-w gf, Cgtrl-w f) ファイル名にカーソルを当ててファイルを開く Vim でファイル名っぽい文字列にカーソルを置いて、gf と入力すると、その名前のファイルを開くことができます（Goto File と覚えてください）。 同じウィンドウでファイルを開くため、その前に編集していたファイルの内容は一時的に見えなくなってしまうのですが、CTRL-o とすれば元のファイルに簡単に戻ってくることができます。 入力 説明 gf カーソルの下のファイルを開く CTRL-o 元のファイルに戻る 元のファイルに戻るときに、CTRL-o の代わりに CTRL-^ を使用することもできます。 CTRL-^ は直前のファイルに戻るという意味のコマンドで、続けて入力すると、2 つのファイルの間で行ったり来たりすることができます。 新しいタブで開く カーソル下のファイル名でファイルを開くときに gf を使用するとカレントバッファで開きますが、Ctrl-w を組み合わせることで、新しいタブや、ウィンドウ分割でファイルを開くことができます。 入力 説明 gf カレントバッファに開く Ctrl-w gf 新しいタブで開く （オススメ） Ctrl-w f ウィンドウを分割して開く 若干複雑な操作になりますが、このコマンドには慣れておくことをお勧めします。"},{url:"/p/pksy5or/",title:"Linuxメモ: dbus-glib 開発用ライブラリをインストールする",date:"2012-05-02T00:00:00+09:00",body:"Linuxメモ: dbus-glib 開発用ライブラリをインストールする （Ubuntu 12.04 で確認） dbus-glib ライブラリのインストール ここでは、D-Bus library (GLib bindings) をインストールして、C/C++ で D-Bus を使ったコードをコンパイルできるようにします。 $ sudo apt-get install libdbus-glib-1-dev ちなみに、apt-cache search 'libdbus' のように実行すると、それっぽいパッケージを検索することができます。 上記を実行すると、以下のようなヘッダファイルがインストールされます。 /usr/include/dbus-1.0/dbus/dbus.h /usr/include/dbus-1.0/dbus/dbus-glib.h ... /usr/include/glib-2.0/glib.h ... /usr/lib/x86_64-linux-gnu/glib-2.0/include （64 bit Linux の場合） D-Bus、GLib bindings のヘッダをインクルードするコードをビルドしてみる main.cpp #include &lt;dbus/dbus.h&gt; #include &lt;dbus/dbus-glib.h&gt; #include &lt;glib.h&gt; int main() { } ビルド $ clang++ main.cpp `pkg-config --cflags --libs dbus-glib-1` ここで使用している pkg-config コマンドは、指定したライブラリのインクルードパスなどのオプション文字列を生成してくれます。 単独で実行すると、例えば以下のような出力が得られます。 $ pkg-config --cflags --libs dbus-glib-1 -I/usr/include/dbus-1.0 -I/usr/lib/x86_64-linux-gnu/dbus-1.0/include -I/usr/include/glib-2.0 -I/usr/lib/x86_64-linux-gnu/glib-2.0/include -ldbus-glib-1 -ldbus-1 -lpthread -lrt -lgobject-2.0 -lglib-2.0"},{url:"/p/zh3w2tz/",title:"Androidトラブルシューティング: repo init でエラーが出る場合",date:"2012-02-21T00:00:00+09:00",body:"Androidトラブルシューティング: repo init でエラーが出る場合 Proxy 環境で、repo コマンド実行時に下記のようなエラーが出る場合、 $ repo init -u https://android.googlesource.com/platform/manifest ... Get https://android.googlesource.com/tools/repo fatal: branch &#39;stable&#39; has not been signed 以下のように http でアクセスするように変更すればうまくいくことがあります。 (1) repo ファイルの REPO_URL を https から http に変更 REPO_URL=&#39;https://android.googlesource.com/tools/repo&#39; ↓ REPO_URL=&#39;http://android.googlesource.com/tools/repo&#39; (2) プロキシ設定 （~/.bashrc とか） $ export http_proxy=http://example.com:8080/ (3) http のアドレスで repo init $ repo init -u http://android.googlesource.com/platform/manifest"},{url:"/p/m82nd2v/",title:"Linuxメモ: シェルスクリプトで配列を扱う",date:"2012-02-02T00:00:00+09:00",body:"Linuxメモ: シェルスクリプトで配列を扱う Bash シェルスクリプト内で配列を扱う方法です。 配列を作成する 下記の例では、配列変数 arr に 3 つの要素を格納しています。 インデックスを指定して1つずつ代入していく方法 arr[0]=AAA arr[1]=100 arr[2]=&#39;Hello world&#39; echo ${arr[0]} echo ${arr[1]} echo ${arr[2]} 実行結果 AAA 100 Hello world 配列の初期化時に要素をまとめて指定する方法 arr=(AAA BBB CCC) echo ${arr[0]} echo ${arr[1]} echo ${arr[2]} 実行結果 AAA BBB CCC 以下のように、複数行にまたいで値を記述することもできます。 arr=( AAA BBB CCC ) 配列をループ処理する 下記の例では、3 つの要素を持つ配列変数 arr を定義し、各要素をループで 1 つずつ処理しています。 配列要素の値にスペースが含まれる場合、下記の &quot;CCC DDD&quot; のようにダブルクォートで囲む必要があります。 arr=(AAA BBB &#34;CCC DDD&#34;) for x in &#34;${arr[@]}&#34;; do echo &#34;$x&#34; done 実行結果 AAA BBB CCC DDD ちなみに、上記のコードは、以下のようにすれば配列変数を定義しないで書けます。 for x in AAA BBB &#34;CCC DDD&#34;; do echo &#34;$x&#34; done 配列のサイズ（要素数）を調べる Bash で定義した配列変数のサイズを調べるには下記のようにします。 ここでは、配列変数 arr を定義して、そのサイズを調べています。 arr=(100 200 300) echo ${#arr[*]} 実行結果 3 配列に要素を追加する Bash の配列変数に要素を追加するには下記のようにします。 例: 配列 arr の末尾に要素を 3 つ追加する arr=(100 200 300) arr=(&#34;${arr[@]}&#34; XXX YYY ZZZ) echo ${arr[@]} 実行結果 100 200 300 XXX YYY ZZZ 同様にして、配列の先頭に要素を追加できます。 arr=(100 200 300) arr=(XXX YYY ZZZ &#34;${arr[@]}&#34;) echo ${arr[@]} 実行結果 XXX YYY ZZZ 100 200 300 配列と配列を結合する Bash の複数の配列を結合して、新しい配列を作成するには下記のようにします。 例: arr1 と arr2 を結合して new_arr を作成する arr1=(100 200 300) arr2=(400 500 600) new_arr=(&#34;${arr1[@]} ${arr2[@]}&#34;) echo &#34;${new_arr[@]}&#34; 実行結果 100 200 300 400 500 600 同様にして、3 つ以上の配列を結合することもできます。 例: arr1 と arr2 と arr3 を結合して new_arr を作成する arr1=(100 200 300) arr2=(400 500 600) arr3=(700 800 900) new_arr=(&#34;${arr1[@]} ${arr2[@]} ${arr3[@]}&#34;) echo &#34;${new_arr[@]}&#34; 実行結果 100 200 300 400 500 600 700 800 900"},{url:"/p/x9xhyhz/",title:"adb から Backup Manager を走らせる (bmgr backup, bmgr restore)",date:"2012-01-26T00:00:00+09:00",body:"adb から Backup Manager を走らせる (bmgr backup, bmgr restore) Android アプリケーションで BackupAgent を実装しておくと、設定値などを Google アカウントに紐づけてバックアップすることができます。 例えば、Android システム設定のバックアップは SettingsProvider (com.android.providers.settings) の SettingsBackupAgent クラスで実装されています。 アプリケーションの実装で、BackupManager.dataChanged() を読んでおくと、ダーティフラグがセットされて、Android が適切なタイミングで Google のサーバーにバックアップするのですが、adb shell から bmgr コマンドを使うことで、バックアップ、リストアを任意のタイミングで実行できます。 設定を Google サーバへバックアップ adb&gt; bmgr backup com.android.providers.settings adb&gt; bmgr run 設定を Google サーバからリストア adb&gt; bmgr restore com.android.providers.settings 参考: BackupAgent | Android Developers 参考: Android Backup Service を使用して Key-Value ペアをバックアップする"},{url:"/p/dpp4v8n/",title:"JavaScript で文字列をデリミタで分割する／1文字ずつに分割する (String#split)",date:"2012-01-20T00:00:00+09:00",body:"JavaScript で文字列をデリミタで分割する／1文字ずつに分割する (String#split) JavaScript の文字列を任意の区切り文字で分割するには、split() メソッドを使用します。 カンマで文字列を分割する const s = &#39; aaa, bbb, ccc &#39;; const arr = s.split(&#39;,&#39;); // =&gt; [&#34; aaa&#34;, &#34; bbb&#34;, &#34; ccc &#34;] 区切り文字列の前後の空白を削除したい場合は、以下のように正規表現で区切り文字を指定するとよいでしょう。 const s = &#39; aaa, bbb, ccc &#39;; const arr = s.split(/\\s*,\\s*/); // =&gt; [&#34; aaa&#34;, &#34;bbb&#34;, &#34;ccc &#34;] 元のテキストの先頭や末尾にある空白が残ってしまっていることに注意してください。 これらを削除するには、以下のように最初に trim() で消してしまうのが早いです。 const s = &#39; aaa, bbb, ccc &#39;; const arr = s.trim().split(/\\s*,\\s*/); // =&gt; [&#34;aaa&#34;, &#34;bbb&#34;, &#34;ccc&#34;] あるいは、以下のように分割した後の各文字列に対して trim() を実行するという方法もありますが、元の文字列に 1 回だけ trim() をかけた方が効率がよいでしょう。 const arr = s.split(&#39;,&#39;).map(function(val, i){ return val.trim() }); 文字列を一文字ずつに分割する split メソッドのパラメータに空文字列 ('') を指定すると、文字列を一文字ずつに分割することができます。 const s = &#39;ABCDE&#39;; const arr = s.split(&#39;&#39;); // =&gt; [&#34;A&#34;, &#34;B&#34;, &#34;C&#34;, &#34;D&#34;, &#34;E&#34;] for (let i = 0; i &lt; arr.length; ++i) { console.log(arr[i]); }"},{url:"/p/8pnuzk4/",title:"JavaScript で文字列を置換する (String#replace, String#replaceAll)",date:"2012-01-20T00:00:00+09:00",body:"JavaScript で文字列を置換する (String#replace, String#replaceAll) replace と replaceAll の基本 String#replace() メソッドを使用すると、String オブジェクト内のパターンに一致する文字列を置換することができます。 ABC を XXX に置換 const text = &#39;ABC 123 ABC 123&#39;; const s = text.replace(&#39;ABC&#39;, &#39;XXX&#39;); //=&gt; &#39;XXX 123 ABC 123&#39; replace() メソッドは、自分自身のオブジェクトの内容を変更しないため、置換結果は戻り値として受け取る必要があることに注意してください。 また、デフォルトでは上記のように、最初に見つかった文字列だけ が置換されます。 パターンが複数箇所に一致した場合に、すべて置換するには、次のように String#replaceAll() メソッドを使用します（後述の正規表現パターンを使用する方法もあります）。 すべての ABC を XXX に置換 const text = &#39;ABC 123 ABC 123&#39;; const s = text.replaceAll(&#39;ABC&#39;, &#39;XXX&#39;); //=&gt; &#39;XXX 123 ABC 123&#39; 正規表現パターンに一致する文字列を全て置換する String#replace() メソッドの第 1 引数には、正規表現パターンを渡すこともできます。 正規表現属性の g（グローバル検索）を付ければ、パターンに一致した部分すべてを一括置換することができます（replaceAll() ではなく、replace() ですべて置換できます）。 例: すべての ABC を XXX に置換 const text = &#39;ABC 123 ABC 123&#39;; const s = text.replace(/ABC/g, &#39;XXX&#39;); //=&gt; &#39;XXX 123 XXX 123&#39; 正規表現属性の i を付けると、大文字と小文字を区別せずに一致させることができます。 正規表現属性は複数組み合わせて使用することができます。 例: 大文字と小文字が混在するものを「JavaScript」という表現に統一 const text = `javascript is a versatile language, and understanding JaVaScRiPt is essential for modern web development.`; const s = text.replace(/javascript/gi, &#39;JavaScript&#39;); 正規表現パターンに一致した部分を置換後の文字列で使用する 正規表現を使用した置換が強力なのは、パターンに一致した実際の文字列を、置換後の文字列の中で参照することができることです。 正規表現パターンにマッチした部分全体は、$&amp; で参照することができます（$0 ではないことに注意）。 例: 数値を [ と ] で囲む const re = /\\d+/g; const text = &#39;ABC 123 DEF 456&#39;; const s = text.replace(re, &#39;[$&amp;]&#39;); //=&gt; &#39;ABC [123] DEF [456]&#39; 正規表現の中のパターンを ( と ) でグルーピングしておくと、その中で実際に一致した部分を $1、$2、$3 というキーワードを使って参照することができます（Perl と同様の記法です）。 例: 姓と名を入れ替える const re = /(\\w+)\\s(\\w+)/; const text = &#39;John Smith&#39;; const s = text.replace(re, &#39;$2, $1&#39;); //=&gt; &#39;Smith, John&#39;"},{url:"/p/jjk3jqs/",title:"HTML ファイルの雛形（テンプレート）",date:"2012-01-15T00:00:00+09:00",body:"HTML ファイルの雛形（テンプレート） ひな形（テンプレート） 最小限のテンプレート &lt;!DOCTYPE html&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;p&gt;Hello HTML5!&lt;/p&gt; HTML5 では、html、head、body タグの記述を省略できるので、上記のような簡潔な記述でも正しい HTML 文書となります。 CSS や JavaScript コードを追記したバージョン &lt;!DOCTYPE html&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;style.css&#34;&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;style&gt; body { background-color: khaki; } &lt;/style&gt; &lt;p&gt;Hello HTML5!&lt;/p&gt; &lt;script&gt; document.write(&#39;Goodbye!&#39;); &lt;/script&gt; style タグも、script タグも、基本は属性なしで記述できます。 あまり省略しないバージョン &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;style.css&#34;&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;style&gt; body { background-color: khaki; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello HTML5!&lt;/p&gt; &lt;script&gt; document.write(&#39;Goodbye!&#39;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; HTML5 の各要素の省略について HTML5 では、簡潔な記述が行えるように、様々な省略記法が用意されています。 DOCTYPE HTML5 では、DOCTYPE は以下のように簡単に記述できるようになりました。 &lt;!DOCTYPE html PUBLIC &#34;-//W3C//DTD XHTML 1.0 Strict//EN&#34; &#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&#34;&gt; ↓ &lt;!DOCTYPE html&gt; 本当は DOCTYPE 自体を削除することも検討されたのですが、Internet Explorer がうまくモード認識できないことがあるということで、最低限の宣言だけ残されています。 DTD は誰も使わないのでなくなりました。 html、head、body 要素の省略 html、head、body タグの記述は省略できます。 記述の省略はできますが、もちろん内部的には DOM ツリー上にこれらの要素は存在しています。 Charset Charset の定義は、以下のように簡単になりました。 &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html;charset=UTF-8&#34; /&gt; ↓ &lt;meta charset=&#34;UTF-8&#34;&gt; style 要素 style 要素の type 属性は省略できるようになりました。 また、media タイプは省略すると all として処理されます。 &lt;style type=&#34;text/css&#34; media=&#34;all&#34;&gt; ... &lt;/style&gt; ↓ &lt;style&gt; ... &lt;/style&gt; script 要素 JavaScript のコードを記述するとき、script 要素に type=&quot;text/javascript&quot; という属性が必要でしたが、省略するとデフォルトで text/javascript と判断されるようになりました。 &lt;script type=&#34;text/javascript&#34;&gt; ... &lt;/script&gt; ↓ &lt;script&gt; ... &lt;/script&gt; W3C の資料に下記のように記載があります。 The default, which is used if the attribute is absent, is &ldquo;text/javascript&rdquo;."},{url:"/p/g9cckyt/",title:"Vim で行を逆順にソートする (:sort!)",date:"2011-12-27T00:00:00+09:00",body:"Vim で行を逆順にソートする (:sort!) ex コマンドで実行できる sort は、デフォルトでは昇順に行ソートしますが、末尾に ! を付加することで逆順（降順）ソートすることが可能です。 行範囲を指定して逆順ソートを実行するには、例えば下記のようにします。 Shift + v でビジュアルモードに入り、行を選択 :sort! と入力して Enter"},{url:"/p/qbmdoef/",title:"Vim の文字の削除方法まとめ（テキストオブジェクト） (d, delete)",date:"2011-12-21T00:00:00+09:00",body:"Vim の文字の削除方法まとめ（テキストオブジェクト） (d, delete) Vim にはテキストを削除ための様々なキーコンビネーションが用意されています。 最初はたくさんあって面食らいますが、体系的な組み合わせになっているので意外と覚えやすいです。 これらのキーコンビネーションを使いこなすと、他のエディタでは決して真似できない爆速テキスト編集が可能になります。 ノーマルモードでの削除 削除の基本 入力 説明 x 1 文字削除（カーソル位置） X 1 文字削除（カーソルの前） dd 1 行削除（cc だとさらにインサートモードに移行） D 行末まで削除（C だとさらにインサートモードに移行） このキーマッピングだけは基本的な削除操作として覚える必要があります。 特に重要そうなものはハイライトしています。 削除系操作の詳細は、:help deleting で確認できます。 オペレーター + 移動コマンド d オペレーターに続けて、1 文字の 移動コマンド を指定することで、カーソル位置からその位置までのテキスト を削除することができます。 例えば、次の単語へジャンプする移動コマンド w と組み合わせて、dw と入力すると、カーソル位置から次の単語までのテキストを削除することができます。 下記は、d オペレーターと移動コマンドの組み合わせによるテキスト削除の例です。 入力 説明 d0 カーソル位置から行頭まで削除 d^ カーソル位置から行頭まで削除（インデントは残す） d$ カーソル位置から行末まで削除（D でも可） dw カーソル位置から単語の末尾まで削除（スペースも削除） de カーソル位置から単語の末尾まで削除（スペースは残す） db カーソル位置から単語の先頭まで削除 df{X} カーソル位置から文字 {X} まで削除 dF{X} カーソル位置から文字 {X} まで削除（前方検索） w、e、b といった単語単位の移動コマンドは、日本語文章では、連続する「漢字」「ひらがな」「カタカナ」を 1 つの単語とみなしてジャンプします。 日本語文章でもスペースを単語の区切りとしてジャンプするには、大文字の W、E、B を使用します。 参考: 「オペレーター」の詳細: :help operator 参考: 「移動コマンド」の詳細: :help motion オペレーター + テキストオブジェクト 移動コマンドの代わりに、a{X} や i{X} という 2 文字の形式で表現される テキストオブジェクト を使うと、カーソル位置を含む様々な範囲のテキスト を削除することができます。 前述の移動コマンドに比べ、カーソル位置が削除対象とするテキストのどこかにあればよいので、効率のよいテキスト削除が可能です。 例えば、iw というテキストオジェクトは、カーソル位置にある単語を示します。 a{X} の方が、i{X} よりも少し広い範囲を表現します。 下記は d オペレーターを使ったテキスト削除の例です。 入力 説明 daw カーソル位置の単語を削除 diw カーソル位置の単語を削除（後ろのスペースを残す） das カーソル位置の英文を削除 dis カーソル位置の英文を削除（後ろのスペースを残す） diW （日本語向け）カーソル位置のテキストをスペースを区切りとして削除 dap カーソル位置の段落を削除 dip カーソル位置の段落を削除（後ろのスペースを残す） da) () で囲まれたテキストを削除 di) () で囲まれたテキストを削除（括弧を残す） da] [] で囲まれたテキストを削除 di] [] で囲まれたテキストを削除（括弧を残す） da&gt; &lt;&gt; で囲まれたテキストを削除 di&gt; &lt;&gt; で囲まれたテキストを削除（括弧を残す） da} {} で囲まれたテキストを削除 di&gt; {} で囲まれたテキストを削除（括弧を残す） dat HTML/XML 要素を削除 dit HTML/XML 要素を削除（開始終了タグを残す） 参考: 「テキストオブジェクト」の詳細: :help text-objects テキストオブジェクトの範囲を確認してから削除する 慣れないうちは、移動コマンドやテキストオブジェクトの指定によって実際にどの範囲のテキストが削除されるのかが分からないと思います。 その場合は、v キーでビジュアル選択モードに入り、テキストオブジェクトなどの範囲を視覚的に確認してから削除コマンド (d) を実行するとよいです。 例えば、以下のようにすると、テキストオブジェクト as の範囲（1 文）をハイライト表示で確認してから削除できます。 vas で削除範囲を確認 d で実際に削除する（c ならさらにインサートモードに入る） インサートモードでの削除 i を入力した後のインサートモード（挿入モード）では、あまり高度な削除操作はできませんが、次のキー操作を覚えておくと便利です。 入力 説明 C-u カーソル位置から行頭まで削除 C-w カーソル位置から単語の先頭まで削除 正確には、どちらもインサートモードを開始した位置までが削除対象となります。 例えば、C-a で行末からインサートモードに入った場合は、C-u による削除範囲はその時点での行末までになります（もう一度 C-u を入力すれば行頭まで完全に削除されます）。 コマンドラインモードでの削除 行番号で指定した行 や 特定の文字列を含む行 を削除したい場合は、: キーで起動するコマンドラインモードで、行範囲指定と組み合わせて d (delete) コマンドを実行します。 コマンドラインモードでは最初に行範囲を指定することに注意してください。 これは置換コマンドの s の対象範囲を指定する場合も同様です。 行範囲を指定した削除 :行範囲 d 行範囲を指定しない場合は、カレント行のみが対象になります。 つまり、:d というコマンドは、dd と同様にカレント行のみを削除します。 入力 説明 :d カレント行を削除 :% d すべての行を削除 :1,10 d 1〜10 行目を削除 :g/temp/ d temp を含む行を削除 :g/^#/ d # で始まる行を削除 :g/^$/ d 空行をすべて削除 ノーマルモードでの削除操作と比べると、コマンドラインモードでの削除はあまり使わないかもしれません。"},{url:"/p/4ucsovh/",title:"Androidベンダー向けメモ: root ユーザで adb 接続する",date:"2011-12-14T00:00:00+09:00",body:"Androidベンダー向けメモ: root ユーザで adb 接続する （下記はデバイス開発者向けの解説であり、root を取得する権限があることを前提としています） Android 端末の /system 領域を rw で remount したのに、 $ adb push sample.apk /system/app が Permission denied でエラーになる場合は、ADB 接続が system ユーザで実行されている可能性があります。 以下のようすると root ユーザで ADB 接続できます。 # adb root # adb kill-server # adb start-server"},{url:"/p/afze7gn/",title:"Linuxメモ: Linux システムコールを使用して core dump を吐かないようにする (setrlimit)",date:"2011-10-11T00:00:00+09:00",body:"Linuxメモ: Linux システムコールを使用して core dump を吐かないようにする (setrlimit) Linux プロセスが異常終了した場合に吐き出される core dump ファイルはセキュリティホールになり得ます。 core dump ファイルを出力しないようにするには、各プロセスで以下のように Linux システムコールの setrlimit を実行します。 core dump を吐かないようにする (C&#43;&#43;) // #include &lt;sys/time.h&gt; // #include &lt;sys/resource.h&gt; rlimit rl; rl.rlim_cur = 0; // soft limit rl.rlim_max = 0; // hard limit if (setrlimit(RLIMIT_CORE, &amp;rl) != 0) { // setrlimit failed! exit process } このように実行しておけば、仮に root を奪取されて ulimit -c コマンドを実行されても core dump を吐かなくなります。"},{url:"/p/gg59gt5/",title:"Androidメモ: Sony Tablet S に adb 接続する",date:"2011-09-24T00:00:00+09:00",body:"Androidメモ: Sony Tablet S に adb 接続する 基本的には、以下の Sony 公式説明に従えば OK です。 https://www.sony.jp/support/tablet/products/info/sdk.html Android SDK のインストールは済んでいて、adb コマンドは実行できる状態になっていることを前提としています。 Mac OSX から接続する Tablet の設定画面で Debug モード有効にする Tablet と Mac を USB で接続 Mac に Vendor ID を登録する $ echo 0x054c &gt;&gt; $HOME/.android/adb_usb.ini ADB 接続 $ adb kill-server $ adb start-server 接続できたか確認 $ adb devices Windows から接続する Tablet の設定画面で Debug モード有効にする Tablet と Windows を USB で接続 Google USB Driver をインストール デバイスマネージャの Sony_Tablet を右クリックして、&ldquo;Update Driver Software&hellip;&rdquo; を選択。 ドライバのディレクトリは、Android SDK の &ldquo;extras/google/usb_driver&rdquo; ディレクトリを選択。 Windows に Vendor ID を登録する &lt;AndroidSDK&gt;/extras/google/usb_driver/android_winusb.inf ファイルの、[Google.NTx86] セクションと [Google.NTamd64] セクション内に以下を追加します。 ;SONY Sony Tablet P %CompositeAdbInterface% = USB_Install, USB\\VID_054C&amp;PID_04D2&amp;MI_01 ;SONY Sony Tablet S %CompositeAdbInterface% = USB_Install, USB\\VID_054C&amp;PID_05B4&amp;MI_01 ホームディレクトリの .android/adb_usb.ini に 0x54c を追記します。 C:\\&gt; echo 0x54c &gt;&gt; %HOMEPATH%\\.android\\adb_usb.ini 接続できたか確認 C:\\&gt; adb devices List of devices attached 272531700013441 device ちなみに、Vendor ID はデバイスマネージャから以下のように確認できます Sony_Tablet のプロパティを開く Details タブの &ldquo;Hardware Ids&rdquo; を選択 以下のように表示されたら Vendor ID は 054C であることが分かります USB\\VID_054C&amp;PID_05B4&amp;REV_0100&amp;MI_01"},{url:"/p/7e9mdcp/",title:"Androidメモ: 現在のスクリーンレイアウトサイズを取得する (Configuration)",date:"2011-09-14T00:00:00+09:00",body:"Androidメモ: 現在のスクリーンレイアウトサイズを取得する (Configuration) Android の現在のスクリーンサイズ (small, medium, large, xlarge) などの情報は Configuration オブジェクトに格納されています。 Activity の中から以下のように情報を取得できます。 // import android.content.res.Configuration; Configuration config = getResources().getConfiguration(); if ((config.screenLayout &amp; Configuration.SCREENLAYOUT_SIZE_MASK) == Configuration.SCREENLAYOUT_SIZE_LARGE) { // LARGE の場合 }"},{url:"/p/qqrxpjd/",title:"APK ファイルの情報を表示する (aapt)",date:"2011-09-11T00:00:00+09:00",body:"APK ファイルの情報を表示する (aapt) Android SDK に付属している aapt (Android Asset Packaging Tool) を使用すると、APK の情報を調べることができます。 主にリソースなどの Asset を対象としたツールですが、バージョン情報や、パーミッション情報なども調べることができます。 aapt コマンドは、昔は build-tools ディレクトリ直下にありましたが、現在は build-tools\\23.0.2 のようなバージョン名のディレクトリ以下にインストールされるようです。 具体的には下記のようなオプションを指定して APK の情報を確認できます（dump パラメータは d と省略できます）。 aapt d badging myapp.apk パッケージ名、アプリ名、バージョン、パーミッション情報、サポートする Locale の一覧などを確認 aapt d permissions myapp.apk 使用しているパーミッション (uses-permission) と、定義しているパーミッション (permission) の一覧 aapt d strings myapp.apk 文字列リソースの一覧 aapt d resources myapp.apk リソースの一覧（大量に出力されるので注意） aapt d xmltree myapp.apk res/animator/fadein.xml 指定した XML リソースのツリー情報 aapt list myapp.apk リソースファイル名の一覧 aapt コマンドのヘルプ パラメータなしで、aapt コマンドを実行すると、下記のようにヘルプが表示されます。 $ aapt Android Asset Packaging Tool Usage: aapt l[ist] [-v] [-a] file.{zip,jar,apk} List contents of Zip-compatible archive. aapt d[ump] [--values] [--include-meta-data] WHAT file.{apk} [asset [asset ...]] strings Print the contents of the resource table string pool in the APK. badging Print the label and icon for the app declared in APK. permissions Print the permissions from the APK. resources Print the resource table from the APK. configurations Print the configurations in the APK. xmltree Print the compiled xmls in the given assets. xmlstrings Print the strings of the given compiled xml assets. aapt p[ackage] [-d][-f][-m][-u][-v][-x][-z][-M AndroidManifest.xml] \\ [-0 extension [-0 extension ...]] [-g tolerance] [-j jarfile] \\ [--debug-mode] [--min-sdk-version VAL] [--target-sdk-version VAL] \\ [--app-version VAL] [--app-version-name TEXT] [--custom-package VAL] \\ [--rename-manifest-package PACKAGE] \\ [--rename-instrumentation-target-package PACKAGE] \\ [--utf16] [--auto-add-overlay] \\ [--max-res-version VAL] \\ [-I base-package [-I base-package ...]] \\ [-A asset-source-dir] [-G class-list-file] [-P public-definitions-file] \\ [-S resource-sources [-S resource-sources ...]] \\ [-F apk-file] [-J R-file-dir] \\ [--product product1,product2,...] \\ [-c CONFIGS] [--preferred-density DENSITY] \\ [--split CONFIGS [--split CONFIGS]] \\ [--feature-of package [--feature-after package]] \\ [raw-files-dir [raw-files-dir] ...] \\ [--output-text-symbols DIR] Package the android resources. It will read assets and resources that are supplied with the -M -A -S or raw-files-dir arguments. The -J -P -F and -R options control which files are output. aapt r[emove] [-v] file.{zip,jar,apk} file1 [file2 ...] Delete specified files from Zip-compatible archive. aapt a[dd] [-v] file.{zip,jar,apk} file1 [file2 ...] Add specified files to Zip-compatible archive. aapt c[runch] [-v] -S resource-sources ... -C output-folder ... Do PNG preprocessing on one or several resource folders and store the results in the output folder. aapt s[ingleCrunch] [-v] -i input-file -o outputfile Do PNG preprocessing on a single file. aapt v[ersion] Print program version. Modifiers: -a print Android-specific data (resources, manifest) when listing -c specify which configurations to include. The default is all configurations. The value of the parameter should be a comma separated list of configuration values. Locales should be specified as either a language or language-region pair. Some examples: en port,en port,land,en_US -d one or more device assets to include, separated by commas -f force overwrite of existing files -g specify a pixel tolerance to force images to grayscale, default 0 -j specify a jar or zip file containing classes to include -k junk path of file(s) added -m make package directories under location specified by -J -u update existing packages (add new, replace older, remove deleted files) -v verbose output -x create extending (non-application) resource IDs -z require localization of resource attributes marked with localization=&#34;suggested&#34; -A additional directory in which to find raw asset files -G A file to output proguard options into. -F specify the apk file to output -I add an existing package to base include set -J specify where to output R.java resource constant definitions -M specify full path to AndroidManifest.xml to include in zip -P specify where to output public resource definitions -S directory in which to find resources. Multiple directories will be scanned and the first match found (left to right) will take precedence. -0 specifies an additional extension for which such files will not be stored compressed in the .apk. An empty string means to not compress any files at all. --debug-mode inserts android:debuggable=&#34;true&#34; in to the application node of the manifest, making the application debuggable even on production devices. --include-meta-data when used with &#34;dump badging&#34; also includes meta-data tags. --pseudo-localize generate resources for pseudo-locales (en-XA and ar-XB). --min-sdk-version inserts android:minSdkVersion in to manifest. If the version is 7 or higher, the default encoding for resources will be in UTF-8. --target-sdk-version inserts android:targetSdkVersion in to manifest. --max-res-version ignores versioned resource directories above the given value. --values when used with &#34;dump resources&#34; also includes resource values. --version-code inserts android:versionCode in to manifest. --version-name inserts android:versionName in to manifest. --replace-version If --version-code and/or --version-name are specified, these values will replace any value already in the manifest. By default, nothing is changed if the manifest already defines these attributes. --custom-package generates R.java into a different package. --extra-packages generate R.java for libraries. Separate libraries with &#39;:&#39;. --generate-dependencies generate dependency files in the same directories for R.java and resource package --auto-add-overlay Automatically add resources that are only in overlays. --preferred-density Specifies a preference for a particular density. Resources that do not match this density and have variants that are a closer match are removed. --split Builds a separate split APK for the configurations listed. This can be loaded alongside the base APK at runtime. --feature-of Builds a split APK that is a feature of the apk specified here. Resources in the base APK can be referenced from the the feature APK. --feature-after An app can have multiple Feature Split APKs which must be totally ordered. If --feature-of is specified, this flag specifies which Feature Split APK comes before this one. The first Feature Split APK should not define anything here. --rename-manifest-package Rewrite the manifest so that its package name is the package name given here. Relative class names (for example .Foo) will be changed to absolute names with the old package so that the code does not need to change. --rename-instrumentation-target-package Rewrite the manifest so that all of its instrumentation components target the given package. Useful when used in conjunction with --rename-manifest-package to fix tests against a package that has been renamed. --product Specifies which variant to choose for strings that have product variants --utf16 changes default encoding for resources to UTF-16. Only useful when API level is set to 7 or higher where the default encoding is UTF-8. --non-constant-id Make the resources ID non constant. This is required to make an R java class that does not contain the final value but is used to make reusable compiled libraries that need to access resources. --shared-lib Make a shared library resource package that can be loaded by an application at runtime to access the libraries resources. Implies --non-constant-id. --error-on-failed-insert Forces aapt to return an error if it fails to insert values into the manifest with --debug-mode, --min-sdk-version, --target-sdk-version --version-code and --version-name. Insertion typically fails if the manifest already defines the attribute. --error-on-missing-config-entry Forces aapt to return an error if it fails to find an entry for a configuration. --output-text-symbols Generates a text file containing the resource symbols of the R class in the specified folder. --ignore-assets Assets to be ignored. Default pattern is: !.svn:!.git:!.ds_store:!*.scc:.*:&lt;dir&gt;_*:!CVS:!thumbs.db:!picasa.ini:!*~ --skip-symbols-without-default-localization Prevents symbols from being generated for strings that do not have a default localization --no-version-vectors Do not automatically generate versioned copies of vector XML resources. 上記の表示は、下記の aapt のバージョンのものです。 $ aapt v Android Asset Packaging Tool, v0.2-2355899"},{url:"/p/qmcauwd/",title:"Androidベンダー向けメモ: LowMemoryKiller の仕組み",date:"2011-09-07T00:00:00+09:00",body:"Androidベンダー向けメモ: LowMemoryKiller の仕組み LowMemoryKiller によるプロセス kill の優先順位の仕組み Android 独自の仕組みである Low Memory Killer は、空きメモリが一定以下になると、アプリプロセスを自動的に kill します。 実体は下記のカーネルに含まれているネイティブプログラムです。 kernel/drivers/staging/android/lowmemorykiller.c どのプロセスが kill されるかは、プロセスごとに設定された adj の値によって決まります。 この値が小さい方が優先度の高いプロセスであることを示し、Low Memory Killer によって殺されにくくなります。 メモリサイズと、adj の関連は、init.rc の中で以下のような感じで設定されます。 # Write value must be consistent with the above properties. write /sys/module/lowmemorykiller/parameters/adj 0,1,2,3,4,5,6,7,14,15 write /sys/module/lowmemorykiller/parameters/minfree 2048,4096,8192,8192,16384,20000,25000,30000,35000,40000 上記の設定では、空きメモリが 8192 page (= 8192 * 4K = 32768K) 以下になったときに、adj が 3 以上であるプロセスが kill されることを示しています。 adj の具体的な値として、以下のようなものがあらかじめ定義されています (Honeycomb)。 ActivityManagerService 内変数 System property Default Description SYSTEM_ADJ -16 The system process runs at the default adjustment. CORE_SERVER_ADJ -12 This is a process running a core server, such as telephony. Definitely don&rsquo;t want to kill it, but doing so is not completely fatal. FOREGROUND_APP_ADJ ro.FOREGROUND_APP_ADJ 0 Foreground app VISIBLE_APP_ADJ ro.VISIBLE_APP_ADJ 1 Visible app PERCEPTIBLE_APP_ADJ ro.PERCEPTIBLE_APP_ADJ 2 This is a process only hosting components that are perceptible to the user, and we really want to avoid killing them, but they are not immediately visible. An example is background music playback. HEAVY_WEIGHT_APP_ADJ ro.HEAVY_WEIGHT_APP_ADJ 3 This is a process with a heavy-weight application. It is in the background, but we want to try to avoid killing it. SECONDARY_SERVER_ADJ ro.SECONDARY_SERVER_ADJ 4 This is a process holding a secondary server &ndash; killing tit will not have much of an impact as far as the user is concerned. BACKUP_APP_ADJ ro.BACKUP_APP_ADJ 5 This is a process currently hosting a backup operation. Killing it is not entirely fatal but is generally a bad idea. HOME_APP_ADJ ro.HOME_APP_ADJ 6 This is a process holding the home application &ndash; we want to try avoiding killing it, even if it would normally be in the background, because the user interacts with it so much. HIDDEN_APP_MIN_ADJ ro.HIDDEN_APP_MIN_ADJ 7 This is a process only hosting activities that are not visible, so it can be killed without any disruption. ro.CONTENT_PROVIDER_ADJ 14 EMPTY_APP_ADJ ro.EMPTY_APP_ADJ 15 This is a process without anything currently running in it. Definitely the first to go! HIDDEN_APP_MAX_ADJ ro.EMPTY_APP_ADJ 15 (GTV) ro.CHROME_CRITICAL_OOM_ADJ 0 (GTV) ro.CHROME_HIGH_OOM_ADJ 5 (GTV) ro.CHROME_MEDIUM_OOM_ADJ 5 (GTV) ro.CHROME_LOW_OOM_ADJ 6 プログラム内で参照する adj に関するシステムプロパティは、init.rc で以下のような感じで設定されています。 on boot ... setprop ro.FOREGROUND_APP_ADJ 0 setprop ro.VISIBLE_APP_ADJ 1 setprop ro.PERCEPTIBLE_APP_ADJ 2 setprop ro.HEAVY_WEIGHT_APP_ADJ 3 setprop ro.SECONDARY_SERVER_ADJ 4 setprop ro.BACKUP_APP_ADJ 5 setprop ro.HOME_APP_ADJ 6 setprop ro.HIDDEN_APP_MIN_ADJ 7 setprop ro.CONTENT_PROVIDER_ADJ 14 setprop ro.EMPTY_APP_ADJ 15 ... 動作中のプロセスに対してどのような adj 値が割り当てられるかは、com.android.server.am.ActivityManagerService の computeOomAdjLocked() で計算されます。 このメソッドを呼び出した後に、パラメータで渡した ProcessRecord オブジェクトの内容（curAdj、adjType フィールドなど）をダンプすれば、そのプロセスがどのように評価されたかが分かります。 Log.i(&#34;HOGE&#34;, &#34;[&#34; + i + &#34;] &#34; + app.processName + &#34;(pid=&#34; + app.pid + &#34;, uid=&#34; + app.info.uid + &#34;)&#34;); Log.i(&#34;HOGE&#34;, &#34; curAdj=&#34; + app.curAdj + &#34;, adjType=&#34; + app.adjType + &#34;, hidden=&#34; + (app.hidden ? 1 : 0) + &#34;, keeping=&#34; + (app.keeping ? 1 : 0)); 出力結果 08-30 10:07:30.023 433 451 I HOGE : [25] com.android.inputmethod.latin(pid=553, uid=10046) 08-30 10:07:30.023 433 451 I HOGE : curAdj=1, adjType=service, hidden=0, keeping=1 08-30 10:07:30.023 433 451 I HOGE : [24] system(pid=433, uid=1000) 08-30 10:07:30.023 433 451 I HOGE : curAdj=-16, adjType=fixed, hidden=0, keeping=1 08-30 10:07:30.023 433 451 I HOGE : [23] com.google.tv.launcher(pid=547, uid=10014) 08-30 10:07:30.023 433 451 I HOGE : curAdj=0, adjType=top-activity, hidden=0, keeping=1 08-30 10:07:30.023 433 451 I HOGE : [22] com.google.tv.chrome(pid=1006, uid=1098) 08-30 10:07:30.023 433 451 I HOGE : curAdj=0, adjType=broadcast, hidden=0, keeping=1 LowMemoryKiller の too many background によるプロセス kill の仕組み&quot; ActivityManagerService.java の中の updateOomAdjLocked() は Android の動作中に頻繁に呼び出され、バックグラウンドで走っているプロセスが多くなるとプロセスを自動的に kill するようになっています。 hidden 状態のプロセスが MAX_HIDDEN_APPS (15) より多くなると、プロセスが kill される。 プロセスの adj 値が computeOomAdjLocked() によって計算され、HIDDEN_APP_MIN_ADJ (7) 以上の値になったプロセスが kill 候補になる（adj &gt;= 7 になる場合はそのプロセスは hidden 状態のはず）。 プロセスの使用履歴上で、古いものから順番に kill の対象になる。 引数なしの updateOomAdjLocked() の最後の方で、numHidden の値をダンプするようにすれば、その瞬間にいくつの hidden プロセスが存在するか調べられます。 基本的には動的に計算される adj の値は 0～15 の範囲になりますが、アプリケーションのフラグとして SYSTEM と PERSISTENT が設定されている場合は、CORE_SERVER_ADJ (-12) が採用されるようです。 final ProcessRecord appAppLocked(ApplicationInfo info) { ... if ((info.flags &amp; (ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PERSISTENT)) == (ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_PERSISTENT)) { app.persistent = true; app.maxAdj = CORE_SERVER_ADJ; // ★ } ... } 絶対に kill されてはいけない電源管理系のサービスなどは、このフラグを設定しておかなければいけません。 ApplicationInfo.FLAG_SYSTEM の方は、プリインストールアプリ (/system/app/*) の場合は自動で付加され、ApplicationInfo.FLAG_PERSISTENT の方は、AndroidManifest.xml の application 要素で以下のように設定するようです。 AndroidManifest.xml ... &lt;application ... android:persistent=&#34;true&#34;&gt; ..."},{url:"/p/o3hggfz/",title:"Androidメモ: AsyncTask による非同期処理と UI 更新処理",date:"2011-08-22T00:00:00+09:00",body:"Androidメモ: AsyncTask による非同期処理と UI 更新処理 AsyncTask とは android.os.AsyncTask クラスは、バックグラウンドで何か処理をしながら、逐次 UI を更新していくときに便利に使用できるユーティリティ・クラスです。 UI の更新処理はメインスレッドで行わなければいけないため、ワーカースレッドから UI 更新する場合は、通常は Handler オブジェクトを介して処理をメインスレッドに委譲しなければいけません。 AsyncTask を使用すると、このあたりの処理を隠ぺいすることができます。 AsyncTask で実装するメソッド AsyncTask のサブクラスで以下のようなメソッドをオーバーライドし、処理内容を記述します。 ワーカースレッドでの処理内容を doInBackground() 内に記述し、UI の更新処理を onProgressUpdate() で記述するようにします。 doInBackground(Params...) ワーカースレッドで行いたい処理を記述する。UI スレッドとは違うスレッドで実行される。 onProgressUpdate(Progress...) UI の更新処理を記述する。UI スレッドで実行される。doInBackground() 内から progressUpdate() をコールすることで、明示的に呼び出す。 doInBackground() の実行前と、実行後には、以下のようなメソッドが UI スレッドから呼び出されます。 このメソッドもオーバーライドして、UI の更新処理を記述することができます。 onPreExecute() onPostExecute(Result) AsyncTask のキャンセル処理について doInBackground() 内から cancel() を呼ぶと、その時点で onPostExecute() が実行され、その後も doInBackground() は継続されます。 AsyncTask の外から cancel() を呼ぶと、その時点で onCanceled() が実行され、その後も doInBackground() は継続されます。この場合は、onPostExecute() は呼び出されません。"},{url:"/p/yvit8zb/",title:"Androidメモ: StrictMode を有効にして望ましくない実装を検出する",date:"2011-08-10T00:00:00+09:00",body:"Androidメモ: StrictMode を有効にして望ましくない実装を検出する StrictMode とは StrictMode は Android Gingerbread から追加されたユーティリティで、以下のような望ましくない処理を検出して、ログなどに出力させることができるようになっています。 メインスレッドからのディスクアクセス メインスレッドからのネットワークアクセス SQLite 関連オブジェクトの close 忘れ ただし、JNI 実装内でのディスクアクセスやネットワークアクセスなどは検出されない可能性があるので過信は禁物です。 StrictMode によって何を検出したいかの設定（detect* 設定）や、検出した場合にどこに出力するかの設定（penalty* 設定）を以下のようにコード内で行います。 // すべてを検出し、見つかったものをログに出力する場合 StrictMode.ThreadPolicy policy = new StrictMode.ThreadPolicy.Builder() .detectAll() .penaltyLog() .build(); StrictMode.setThreadPolicy(policy); ここではスレッドに関連するポリシーである StrictMode.ThreadPolicy の設定を行っていますが、VM に対する StrictMode.VmPolicy の設定も同様に行うことができます。 参考リンク StrictMode ｜ Android Developers StrictMode.ThreadPolicy ｜ Android Developers StrictMode.VmPolicy ｜ Android Developers Android Developers Blog: New Gingerbread API: StrictMode Y.A.M の 雑記帳: Android　Android 2.3 - StrictMode StrictModeでパフォーマンスをチューニングする - Android(アンドロイド)情報-ブリリアントサービス StrictMode で検出されたバイオレーションログを検索する Logcat ログを StrictMode タグで絞り込んで、さらにパッケージ名で絞り込むと、StrictMode によって検出された問題個所を素早く見つけることができます。 $ logcat -s StrictMode:* | grep -e &#39;violation&#39; -e &#39;com.yourcompany&#39; &amp; 応用 StrictMode の違反メッセージを Toast で表示する (StrictModeToaster)"},{url:"/p/63w3r2r/",title:"Androidベンダー向けメモ: findmakefile コマンドで Android.mk のあるディレクトリを調べる",date:"2011-08-09T00:00:00+09:00",body:"Androidベンダー向けメモ: findmakefile コマンドで Android.mk のあるディレクトリを調べる build/envsetup.sh で定義されているシェル関数 findmakefile を使用すると、カレントディレクトリから上に Android.mk を探してそのパスを調べることができます。 $ findmakefile /home/maku/gitwork/android/packages/apps/Browser/Android.mk これを利用して、以下のように Vim で Android.mk を開くことができます。 $ vim `findmakefile`"},{url:"/p/4zpco9q/",title:"Androidメモ: Activity の起動モードと起動フラグ（タスクとアフィニティ）のまとめ",date:"2011-08-03T00:00:00+09:00",body:'Androidメモ: Activity の起動モードと起動フラグ（タスクとアフィニティ）のまとめ タスクとは Android のアプリは、「タスク」 に複数の Activity をスタックすることで実現されています。 デフォルトでは、新しい Activity を起動すると、その起動元の「タスク」に Activity がスタックされていきます。 戻るキーで戻った時に表示される Activity は、この「タスク」にどのように Activity がスタックされているかによります。 flowchart RL subgraph Task["タスク"] ActivityC["Activity C"] ActivityB["Activity B"] ActivityA["Activity A"] end ActivityC --> ActivityB ActivityB --> ActivityA ActivityA:::stoppedActivity ActivityB:::stoppedActivity ActivityC:::currentActivity classDef stoppedActivity fill:#f3e5f5,stroke:#4a148c,stroke-width:2px classDef currentActivity fill:#fff3e0,stroke:#e65100,stroke-width:3px アフィニティとは Activity がどのタスクに配置されるかは 「アフィニティ」 という情報で制御されています。affinity は「類似性」、「親和性」という意味です。 Activity とタスクはそれぞれ 1 つの「アフィニティ」を持ちます。 「アフィニティ」は次のようなルールで決定されます。 同じアプリ内の Activity は基本的に同じ「アフィニティ」を持ちます。 タスクの「アフィニティ」は、そのタスクを最初に起動した Activity のものになります。 Activity の配置先を決めるのに「アフィニティ」が使用されるのは、Activity の起動モードに singleTask を指定した場合か、起動フラグに Intent.FLAG_ACTIVITY_NEW_TASK を指定した場合です。 Activity の「アフィニティ」は、activity 要素の android:taskAffinity 属性で指定できます。 1 つの APK が複数のアプリを含んでいるように見せたいときは、各 Activity の「アフィニティ」をアプリ別に定義して設定します。 起動モードと起動フラグ Activity の起動モード（activity 要素の android:launchMode 属性）と、startActivity() の Intent にセットする起動フラグ (setFlag) によって、Activity が起動する条件や、どのタスクに配置されるかが決まります。 起動モードは、起動される Activity 側の設定として定義され、起動フラグは、呼び出し側の都合で指定することになります。 基本的に、呼び出し側で設定する Intent フラグの方が優先されます。 起動モード（android:launchMode 属性） launchMode startActivity()で新しいActivityを起動するか 新しくActivityが起動した場合どのタスクに配置されるか standard (default) 常に新しい Activity を起動する。 起動元のタスクにスタックされる。 singleTop 同じ Activity がタスクの先頭にいる場合は、Activity.onNewIntent() を呼び出す。同じ Activity がタスクの先頭にいない場合、新しい Activity を起動する（つまり、A-B-C-B のように、同じ Activity B が１つのタスク内に共存できる）。 起動元のタスクにスタックされる。 singleTask 同じ Activity がシステム内に存在する場合、そのタスクをフォアグラウンドにし、Activity.onNewIntent() を呼び出す。さらに、その上にある Activity をすべて破棄する。同じ Activity がシステム内に存在しない場合、新しい Activity を起動する。 同じアフィニティを持つタスクが存在する場合、そこにスタックする。同じアフィニティを持つタスクが存在しない場合、新しいタスクに配置する（FLAG_ACTIVITY_NEW_TASK を指定したのと同様）。 singleInstance 同じ Activity がシステム内に存在する場合、そのタスクをフォアグラウンドにし、Activity.onNewIntent() を呼び出す。システム内に存在しない場合、新しい Activity を起動する。 新しいタスクに配置する。 例外的に、singleInstance の Activity から、別の Activity を起動した場合は、必ず新しいタスクに配置されます。 これは、singleInstance の Activtity を含むタスクは、その Activity 専用のタスクになり、別の Activity をスタックすることができないからです。 起動フラグ（Intent.setFlag） Intent.FLAG_ACTIVITY_SINGLE_TOP このフラグを指定した場合、起動モード singleTop と同じ振る舞いをします。既存のタスクの先頭にその Activity が存在する場合は、新しい Activity を起動しません。 Intent.FLAG_ACTIVITY_NEW_TASK Activity の起動モードが standard、singleTop のときに、新しい Activity が起動する場合は、通常、起動元のタスクにスタックされますが、このフラグを指定した場合は、新しいタスクに配置されるようになります（同じアフィニティを持つタスクがあれば、そのタスクに配置されます）。つまり、起動モード singleTask と同じ振る舞いをします。 Activity の起動モードが singleTask、singleInstance のときは、このフラグは無視されます（もともと新しいタスク上に配置するなどの振る舞いをするから）。 ランチャーのようなアプリから、別のアプリを起動するようなときには、このフラグを指定して、既存の Activity をタスクの先頭に持ってくるか、新しいタスク上で Activity を起動するようにします。こうすることで、その Activity がそのアプリのエントリポイントのように見えるようになります（その Activity で戻るキーを押すとアプリが終了する）。 既に同じ Activity が存在している場合は、そのタスクがフォアグラウンドに表示され、Activity.onNewIntent() が呼び出されるだけで、新しいタスクは開始されません。この振る舞いは後述の ACTIVITY_FLAG_MULTIPLE_TASK で制御できます。 同じアフィニティのタスク上に Activity がスタックされるのを防ぎたい場合は、Activity のアフィニティを空文字（&quot;&quot;）にします。すると、Activity は常に新しいタスク上で起動するようになります。もちろんこれは新しい Activity が起動する場合の話で、既に同じ Activity が存在する場合は、新しいタスクは起動しません。 Activity の起動モードが singleTop のときに、新しい Activity が起動されない場合は、当然タスクも起動されません。 Intent.FLAG_ACTIVITY_MULTIPLE_TASK FLAG_ACTIVITY_NEW_TASK を指定した場合だけ、このフラグを同時に指定することができます。 FLAG_ACTIVITY_NEW_TASK と同時に指定することで、Activity がすでに存在している場合にも、新しいタスク上に Activity が起動されるようになります。 参考サイト Intent │ Android Developers Tasks and Back Stack │ Android Developers'},{url:"/p/36huwqe/",title:"Androidメモ: ADB でディレクトリ内のファイルをすべて取得する (adb pull)",date:"2011-07-29T00:00:00+09:00",body:"Androidメモ: ADB でディレクトリ内のファイルをすべて取得する (adb pull) Android SDK の adb pull コマンドは、単一のファイルだけではなく、ディレクトリごとファイルを取得するのにも使用できます。 下記の例では、Android デバイス上の /system/lib ディレクトリ内のファイルをすべて取得しています。 $ adb pull /system/lib pull: building file list... pull: /system/lib/libcutils.so -&gt; ./libcutils.so pull: /system/lib/libssl.so -&gt; ./libssl.so ... 245 files pulled. 0 files skipped. 1575 KB/s (97775523 bytes in 60.596s)"},{url:"/p/mbnw7gq/",title:"Activity の情報を表示する (dumpsys activity)",date:"2011-06-08T00:00:00+09:00",body:"Activity の情報を表示する (dumpsys activity) Android 端末に adb shell で接続後、dumpsys コマンドを実行すると Activity core サービスの情報を表示できます。 例えば、出力の Activity スタックを確認することで、最前面に表示されているアプリの正体を調べることができます。 dumpsys コマンドをパラメータなしで実行すると、大量のメッセージが表示されてしまうので、activity パラメータを指定して Activity に関する情報だけに絞り込むと見やすくなります。 端末上で実行する場合（adb shell でログイン後） # dumpsys activity adb 経由で実行する場合 $ adb shell dumpsys activity 例えば、以下のようにすれば、Stop 状態のアクティビティ含め、現在起動中のアクティビティの一覧を簡単に調べることができます（ここでは Windows の findstr コマンドを使用しています）。 C:\\&gt; adb shell dumpsys activity activities | findstr /c:&#34;* TaskRecord&#34; * TaskRecord{2758379e #1 A=com.google.android.leanbacklauncher U=0 sz=1} * TaskRecord{18c788c2 #7 A=com.example.myapp1 U=0 sz=1} * TaskRecord{3cffb420 #4 A=com.example.myapp2 U=0 sz=1}"},{url:"/p/f448waf/",title:"Vim でカーソル位置の単語を取得する (<cword>)",date:"2011-06-06T00:00:00+09:00",body:"Vim でカーソル位置の単語を取得する (<cword>) Vim 内で、カーソル位置の単語は &lt;cword&gt; で参照することができます。 例: カーソル位置の単語を表示 :!echo &lt;cword&gt; 例: F4 キーでカーソル位置の単語を検索できるようにする nnoremap &lt;F4&gt; :grep &lt;cword&gt; ./*"},{url:"/p/6bpmxey/",title:"Vim でカーソル位置の文字の文字コードを表示する (:ascii)",date:"2011-06-06T00:00:00+09:00",body:"Vim でカーソル位置の文字の文字コードを表示する (:ascii) Vim エディタのノーマルモードで、 ga と入力すると、カーソル位置の文字コード（10進数、16進数、8進数）を表示できます。 例えば、A という文字にカーソルを置いて ga と入力すると、以下のように表示されます。 &lt;A&gt; 65, Hex 11, Octal 101 コマンドモードから次のように入力することでも同様のことを行えます。 :ascii"},{url:"/p/xr3n5jk/",title:"APK ファイルを逆コンパイルする (apktool)",date:"2011-05-27T00:00:00+09:00",body:"APK ファイルを逆コンパイルする (apktool) Apktool を使用すると、APK ファイルを逆コンパイルして、内部のファイルの内容を確認することができます。 Apktool - A tool for reverse engineering Android apk files 使い方は簡単で、次のように解析対象の APK ファイルと、出力先のディレクトリを指定するだけです。 使い方 $ apktool d &lt;APKファイル名&gt; &lt;展開先ディレクトリ&gt;"},{url:"/p/dzocr3s/",title:"Androidベンダー向けメモ: Android の Locale を切り替える（Configuration 値の変更）",date:"2011-05-19T00:00:00+09:00",body:"Androidベンダー向けメモ: Android の Locale を切り替える（Configuration 値の変更） Android の Locale などの Configuration 値を切り替えるには、IActivityManager の updateConfiguration() メソッドを呼び出す必要があります。 ただし、ActivityManagerNative などは hide クラスとして定義されており、一般のアプリ開発者は以下のコードはビルドできません。 IActivityManaager am = ActivityManagerNative.getDefault(); try { Configuration config = am.getConfiguration(); config.XXXX = YYYY; am.updateConfiguration(config); } catch (RemoteException e) { e.printStackTrace(); } 以下のコードは、Locale を変更する方法を示しています。 IActivityManager am = ActivityManagerNative.getDefault(); Configuration config = am.getConfiguration(); config.locale = locale; config.userSetLocale = true; am.updateConfiguration(config);"},{url:"/p/928ca4t/",title:"Vim でディレクトリエクスプローラー (Explore) を使用してファイルを開く (:E, :Ve, :He)",date:"2011-05-19T00:00:00+09:00",body:"Vim でディレクトリエクスプローラー (Explore) を使用してファイルを開く (:E, :Ve, :He) Explore とは Vim にはデフォルトで、ファイルを操作するのディレクトリエクスプローラー機能 (Explore) が付属しています。 Explorer じゃなくて、Explore なので注意してください（最後の r がないです）。 カレントディレクトリを起点にして Explore を起動する :E[xplore] &#34; カレントバッファで開く（:vi . でも同様） :Ve[xplore] &#34; 左右に分割して開く :He[xplore] &#34; 上下に分割して開く 編集中のファイルのあるディレクトリを起点にして Explore を起動する :E %:h &#34; :vi %:h でも同様 :Ve %:h :He %:h Explore でブックマーク機能を使用する ディレクトリエクスプローラーを :Explore コマンドで起動した後で、以下のようにして各ディレクトリをブックマークすることができます。 mb &#34; カレントディレクトリを ブックマークする qb &#34; ブックマークの一覧を表示する gb &#34; 最後に ブックマークしたディレクトリへ移動 1gb &#34; 1番目の ブックマークへ移動 2gb &#34; 2番目の ブックマークへ移動 mB &#34; 最後の ブックマークを削除する 1mB &#34; 1番目の ブックマークを削除する 2mB &#34; 2番目の ブックマークを削除する qb コマンドで ブックマークの一覧を表示すると分かりますが、ブックマークは単純にアルファベット順にソートされて保存されます（追加した順番には並びません）。 上記のコマンドの中で指定する番号は、このソートされた順に並べられたブックマークの番号なので注意してください。 参考 Vim 上でディレクトリツリーを表示する (NERDTree)"},{url:"/p/oi67p5c/",title:"python コマンドでワンライナーを実行する (python -c)",date:"2011-05-13T00:00:00+09:00",body:"python コマンドでワンライナーを実行する (python -c) python コマンドを実行するときに -c オプションを指定すると、コマンドラインで指定した Python コードを直接実行することができます。 このように 1 行で記述したコードは、ワンライナーと呼ばれています。 python のワンライナー実行の例 # Hello World $ python -c &#34;print(&#39;Hello World&#39;)&#34; Hello World # 連番の表示 $ python -c &#34;print([x for x in range(5)])&#34; [0, 1, 2, 3, 4] # 現在時刻の表示 $ python -c &#34;import datetime; print(datetime.datetime.now())&#34; 2023-11-23 16:22:37.530499 # JSON ファイルの特定のキーの値を取得する $ python -c &#34;import json; print(json.load(open(&#39;file.json&#39;))[&#39;key&#39;])&#34; value # CSV ファイルの特定の列を表示する $ python -c &#34;import csv; print([row[&#39;col1&#39;] for row in csv.DictReader(open(&#39;file.csv&#39;))])&#34; [&#39;100&#39;, &#39;200&#39;, &#39;300&#39;]"},{url:"/p/fufwdub/",title:"Linuxメモ: echo で出力する文字の色を変える",date:"2011-05-11T00:00:00+09:00",body:"Linuxメモ: echo で出力する文字の色を変える Linux の echo コマンドで特殊なエスケープシーケンスを出力すると、テキストの文字を変更することができます。 次の Bash スクリプトでは、色を変更しつつ echo 出力する、error / warn / info 関数を定義しています。 sample.sh #!/bin/bash error() { echo -e &#34;\\033[31m$*\\033[00m&#34; &gt;&amp;2 } warn() { echo -e &#34;\\033[33m$*\\033[00m&#34; &gt;&amp;2 } info() { echo -e &#34;\\033[32m$*\\033[00m&#34; &gt;&amp;2 } error &#39;Error message&#39; warn &#39;Warning message&#39; info &#39;Information message&#39; このシェルスクリプトを実行すると、次のように色付きのメッセージが表示されます。 図: echo コマンドの出力色を変更 ちなみに、echo コマンドの末尾の &gt;&amp;2 は、標準エラー出力へ出力することを示しています。 参考: echo の結果を標準エラー出力 (stderr) に出力する (1&gt;&amp;2)"},{url:"/p/qn635m9/",title:"Android Nativeメモ: ServiceManager に登録されたサービスを列挙する",date:"2011-05-09T00:00:00+09:00",body:"Android Nativeメモ: ServiceManager に登録されたサービスを列挙する 下記は、デバイス上の ServiceManager に登録されたサービスを列挙するためのプログラムです。 Android の make でビルドすると、ListServices という実行ファイルが生成されます。 main.cpp #undef LOG_TAG #define LOG_TAG &#34;ListServices&#34; #include &lt;binder/IServiceManager.h&gt; #include &lt;utils/Log.h&gt; #include &lt;utils/RefBase.h&gt; #include &lt;utils/Vector.h&gt; #include &lt;utils/String16.h&gt; #include &lt;utils/String8.h&gt; using namespace android; static int compareServiceName(const String16* lhs, const String16* rhs) { return *lhs &gt; *rhs; } int main() { sp&lt;IServiceManager&gt; sm = defaultServiceManager(); Vector&lt;String16&gt; services = sm-&gt;listServices(); size_t n = services.size(); LOGI(&#34;%d services have found&#34;, n); services.sort(compareServiceName); for (size_t i = 0; i &lt; n; ++i) { LOGI(&#34;[%2d] %s&#34;, i + 1, String8(services[i]).string()); } } ListServices/Android.mk LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := ListServices LOCAL_MODULE_TAGS := optional LOCAL_SRC_FILES := main.cpp LOCAL_SHARED_LIBRARIES := libcutils include $(BUILD_EXECUTABLE) m コマンドなどで ListServices をビルドしたら、デバイスに転送してシェル上で実行します。 下記のように、ServiceManager に登録されたサービスが列挙されます。 # /system/bin/ListServices 04-28 16:38:47.108 1566 1566 I ListServices: 65 services have found 04-28 16:38:47.112 1566 1566 I ListServices: [ 1] SurfaceFlinger 04-28 16:38:47.112 1566 1566 I ListServices: [ 2] accessibility 04-28 16:38:47.112 1566 1566 I ListServices: [ 3] account 04-28 16:38:47.112 1566 1566 I ListServices: [ 4] activity 04-28 16:38:47.112 1566 1566 I ListServices: [ 5] alarm ..."},{url:"/p/33w8db9/",title:"Android Nativeメモ: ネイティブサービスの実装 (3) サービスのインタフェースを定義する",date:"2011-05-09T00:00:00+09:00",body:"Android Nativeメモ: ネイティブサービスの実装 (3) サービスのインタフェースを定義する クライアント側のコードをすっきりさせたい IBinder クラスの transact() インタフェースだけでサービスの機能にアクセスするのは分かりにくく、すべてのクライアントコードに本質的ではない Parcel オブジェクトの生成コードが表れてしまいます。 例: CalcService を利用する煩雑なクライアントコード sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(&#34;CalcService&#34;)); Parcel data; // Input Parcel reply; // Output data.writeInt32(100); data.writeInt32(50); binder-&gt;transact(0, data, &amp;reply); // Add function LEGI(&#34;CalcService returns: %d&#34;, reply.readInt32()); サービスのインタフェースを定義し、そのインタフェース経由で機能にアクセスできるようにすればクライアント側のコードがすっきりします。 Binder フレームワークには、このためのヘルパークラスなどが用意されていて、これらをうまく使用すると、以下のような感じで CalcService にアクセスできるようになります。 sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(&#34;CalcService&#34;)); sp&lt;ICalcService&gt; calc = interface_cast&lt;ICalcService&gt;(binder); int result = calc.add(100, 50); // すっきり！ 簡単に言ってしまえば、IBinder を直接使うのではなく、分かりやすいラッパークラスを用意してやりましょうということです。 interface_cast というテンプレート関数は、IInterface.h で定義されていて、上記のサンプルコードは以下のように展開されます。 sp&lt;ICalcService&gt; calc = interface_cast&lt;ICalcService&gt;(binder); ↓ sp&lt;ICalcService&gt; calc = ICalcService::asInterface(binder); 要するに、ICalcService には、IBinder オブジェクトから ICalcService オブジェクトを取得するための asInterface() メソッドが定義されていないといけません。 最終的にクライアントに公開されるファイルは、サービスインタフェースである ICalcService.h などのヘッダファイルと、その実装である ICalcService.so などになるでしょう。 クライアントに公開するサービスインタフェースの実装 サービスのインタフェースは、IInterface を継承して作成します。 例えば、サービスクラス CalcService にアクセスするためのインタフェースは、ICalcService という名前で作成し、ここに add() や subtract() などの分かりやすいアクセスメソッドを用意してやります。 IInterface.h に定義されているマクロが、プレフィックスとして I を付ける前提のコードになっているので、このように「I + サービス名」というネーミングをしなければいけません。 ICalcService.h class ICalcService : public IInterface { public: DECLARE_META_INTERFACE(CalcService); virtual int add(int a, int b) = 0; virtual int subtract(int a, int b) = 0; }; DECLARE_META_INTERFACE というマクロは以下のように展開されます。 この中で、IBinder オブジェクトから ICalcService オブジェクトを取得するための asInterface() も定義されます。 ICalcService.h static const android::String16 descriptor; static android::sp&lt;ICalcService&gt; asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj); virtual const android::String16&amp; getInterfaceDescriptor() const; ICalcService(); virtual ~ICalcService(); これらの実装を提供するための、IMPLEMENT_META_INTERFACE というマクロも用意されています。 例えば、 IMPLEMENT_META_INTERFACE(CalcService, &#34;sample.CalcService&#34;); と記述しておくと、以下のように展開されます。 ICalcService.cpp const android::String16 ICalcService::descriptor(&#34;sample.CalcService&#34;); const android::String16&amp; ICalcService::getInterfaceDescriptor() const { return ICalcService::descriptor; } android::sp&lt;ICalcService&gt; ICalcService::asInterface(const android::sp&lt;android::IBinder&gt;&amp; obj) { android::sp&lt;ICalcService&gt; intr; if (obj != NULL) { intr = static_cast&lt;ICalcService*&gt;(obj-&gt;queryLocalInterface(ICalcService::descriptor).get()); if (intr == NULL) { intr = new BpCalcService(obj); } } return intr; } ICalcService::ICalcService() {}; ICalcService::~ICalcService() {}; この中で、asInterface() で取得するオブジェクトとして、BpCalcService というオブジェクトを生成するように実装されます。 つまり、ICalcService というインタフェースを実装する BpCalcService クラスを作成する必要があります。 class BpCalcService : public android::BpInterface&lt;ICalcService) { public: BpCalcService(const android::sp&lt;android::IBinder&gt;&amp; obj) {}; virtual ~BpCalcService(); virtual int add(int a, int b); virtual int subtract(int a, int b); }; add() や subtract() メソッドの実装で IBinder オブジェクトへの参照が必要になるのですが、実は親クラスの BpInterface クラスのコンストラクタに IBinder オブジェクトを渡しておけば、いつでも remote() メソッドを使って参照できるようになります。 つまり、BpCalcService の実装で、IBinder オブジェクトを保持しておく必要はありません。 BpCalcService::BpCalcService(const sp&lt;IBinder&gt;&amp; obj) : BpInterface(ICalcService&gt;(obj) {} BpCalcService::~BpCalcService() {} int BpCalcService::add(int a, int b) { Parcel data, reply; data.writeInt32(a); data.writeInt32(b); remote()-&gt;transact(CODE_ADD, data, &amp;reply); return reply.readInt32(); } ... transact に渡す code は、次のように IBinder::FIRST_CALL_TRANSACTION (0) から割り当てていきます。 この数値は、もちろんサービス側の実装に合わせる必要があります。 enum { CODE_ADD = IBinder::FIRST_CALL_TRANSACTION, CODE_SUBTRACT, }; ICalcService.h をサービス側、クライアント側の両方から見える include ディレクトリに配置するのなら、ICalcService.h のクラス定義の中で protected に上記の enum 定義を入れてしまうのがよいかもしれません。 クライアントの実装 int main() { sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sp&lt;IBinder&gt; binder = sm-&gt;getService(String16(&#34;CalcService&#34;)); if (binder == 0) { LOGW(&#34;CalcService has not been published yet...&#34;); return 0; } sp&lt;ICalcService&gt; calc = interface_cast&lt;ICalcService&gt;(binder); int result = calc-&gt;subtract(100, 50); // Subtract function LOGI(&#34;CalcService returns: %d&#34;, result); } 完全なコードと実行テスト CalcClient2.zip CalcService2.zip ここでは、クライアントが使用する ICalcService.h とその実装を、クライアントプログラム (CalcClient) に埋め込んでしまっていますが、複数のプログラムから使用するインタフェースとして切り出したい場合は、 ICalcService.h &hellip; サービスインタフェース ICalcService.so &hellip; サービスインタフェースを実装した共有ライブラリ といったファイルとして切り出して、共有できるように配置します。 CalcClient と CalcService プログラムをデバイス上の /system/bin に転送したら、以下のように CalcService サービスを起動し、CalcClient プログラムを使ってサービスにアクセスします。 # CalcService &amp; 04-28 17:26:57.480 3178 3178 I CalcService: Add CalcService to ServiceManager # CalcClient 04-28 17:27:33.236 3196 3196 I CalcClient: CalcService returns: 50"},{url:"/p/ds6rhco/",title:"Android Nativeメモ: ネイティブサービスの実装 (1) Binder 関連のクラス",date:"2011-04-27T00:00:00+09:00",body:"Android Nativeメモ: ネイティブサービスの実装 (1) Binder 関連のクラス Binder 関連クラス Android のネイティブレイヤのサービスを実装するには、以下のような Binder 関連クラスを使用します。 継承構造 RefBase &hellip; 各種オブジェクトの生存期間を参照カウンタ IBinder &hellip; サービスの基底クラス。プロセス間通信の共通インタフェースとしても使われる。 BpBinder &hellip; クライアント側のプロキシクラス（ServiceManager が自動的にインスタンスを生成する） BBinder &hellip; サービスの基底クラス（基本的な実装を提供） BnInterface IInterface &hellip; クライアントに提供するサービスインタフェースの基底クラス BpRefBase BpInterface &hellip; クライアントに提供するサービスインタフェースの実装 ポイント (a) サービスクラスは BBinder をサブクラス化して作成する。 (b) サービスにアクセスするインタフェースは IInterface をサブクラス化して作成する。 (c) サービスにアクセスするインタフェースの実装は BpInterface をサブクラス化して作成する。 (a) さえ準備してサービスを立ち上げれば、クライアントは IBinder インタフェースでサービスにアクセスできるようになります。 (b)、(c) はまともなサービスインタフェースとしてクライアントに公開する場合に必要です。 ファイルのパス クラス定義 frameworks/base/include/binder/Binder.h (BBinder, BpRefBase) frameworks/base/include/binder/BpBinder.h (BpBinder) frameworks/base/include/binder/IBinder.h (IBinder) frameworks/base/include/binder/IInterface.h (IInterface, BnInterface, BpInterface) frameworks/base/include/utils/RefBase.h (RefBase) frameworks/base/include/utils/StrongPointer.h (sp) 実装 frameworks/base/libs/binder/BpBinder.cpp frameworks/base/libs/binder/IInterface.cpp frameworks/base/libs/utils/RefBase.cpp Binder 関連クラスをざっと眺めてみる RefBase RefBase クラスは、すべての Binder 関連クラスの基底クラスで、インスタンスの生存期間をリファレンスカウンタで管理しています。 IInteface IInterface クラスは、ユーザが定義するサービスのインタフェースのベースクラスになります。 class IInterface : public virtual RefBase { public: sp&lt;IBinder&gt; asBinder(); sp&lt;const IBinder&gt; asBinder() const; protected: virtual IBinder* onAsBinder() = 0; }; class IEchoService : public IInterface { public: virtual int add(int lhs, int rhs); }; IInterface クラスには、サービスへアクセスするための IBinder オブジェクトを取得するための asBinder() メソッドが実装されています。 この中で使用している onAsBinder() メソッドは、pure virtual メソッドなので、サービス側で実装する必要があります。 sp&lt;IBinder&gt; IInterface::asBinder() { return this ? onAsBinder() : NULL; } sp&lt;const IBinder&gt; IInterface::asBinder() const { return this ? const_cast&lt;IInterface*&gt;(this)-&gt;onAsBinder() : NULL; } asBinder() は、スマートポインタである sp クラスのインスタンスを返すため、IBinder オブジェクトは参照カウンタを使って自動的に生存期間が制御されます。 IBinder class IBinder : public virtual RefBase { public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; descriptor); virtual const String16&amp; getInterfaceDescriptor() const = 0; virtual bool isBinderAlive() const = 0; virtual status_t pingBinder() = 0; queryLocalInterface を使用して、名前指定で IInterface オブジェクトを取得できる。 queryLocalInterface は、テンプレートクラス BnInterface を継承したサブクラスを作成することで容易に実装できる。 BBinder BBinder クラスは IBinder を継承しており、BBinder::transact() の中で abstract method である onTransact() を呼び出すようになっています。 この onTransact() を実装するようにすれば OK です。 class BBinder : public IBinder { public: virtual const String16&amp; getInterfaceDescriptor() const; virutal bool isBinderAlive() const; virtual status_t pingBinder(); virtual status_t dump(int fd, const Vector&lt;String16&gt;&amp; args); virtual status_t transact(...); virtual status_t linkToDeath(...); virtual status_t unlinkToDeath(...); virtual void attachObject(...); virtual void* findObject(const void* objectID) const; virtual void detachObject(const void* objectID); virtual BBinder* localBinder(); protected: virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); ... }; BpInterface template&lt;typename INTERFACE&gt; class BpInterface : public INTERFACE, public BpRefBase { ... }; BnInterface template&lt;typename INTERFACE&gt; class BnInterface : public INTERFACE, public BBinder { ... }; こんな感じで使います。 class BnMyClass : public BnInterface&lt;IMyClass&gt; { public: virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); };"},{url:"/p/edjwtcr/",title:"Android Nativeメモ: ネイティブサービスの実装 (2) サービスの実装から利用まで",date:"2011-04-27T00:00:00+09:00",body:"Android Nativeメモ: ネイティブサービスの実装 (2) サービスの実装から利用まで サービスの実装 サービスとなるクラスは IBinder で定義されたインタフェースを実装する必要があります。 IBinder を直接実装しようとすると、多くの abstract メソッドを実装しないといけませんが、基本的な実装を提供している BBinder クラスを継承してサービスを作成すれば、最低限のインタフェースを実装するだけで済みます。 一番重要なメソッドは、サービスの機能を提供する onTransact() メソッドです。 例えば、計算を行うためのサービス CalcService を考えます。 CalcService.h #include &lt;binder/Binder.h&gt; class CalcService : public android::BBinder { public: virtual status_t onTransact( uint32_t code, // 処理内容分岐のための ID const android::Parcel&amp; data, // 入力値 android::Parcel* reply, // 戻り値 uint32_t flags // 戻り値が必要かどうかなどを示すフラグ ); virtual ~CalcService() {} }; クライアントからの入力値は data パラメータで受け取り、クライアントへの戻り値は reply パラメータに格納します。 この CalcService に複数の機能（足し算、引き算など）を持たせたい場合は、onTransact() メソッドの第一引数で渡される code（int 値）をもとに処理を分岐させます。 status_t CalcService::onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags) { switch (code) { case 0: // Add function { int a = data.readInt32(); int b = data.readInt32(); reply-&gt;writeInt32(a + b); } break; case 1: // Subtract function { int a = data.readInt32(); int b = data.readInt32(); reply-&gt;writeInt32(a - b); } break; default: return BBinder::onTransact(code, data, reply, flags); } return NO_ERROR; } 正確には IBinder::transact() メソッドがサービスクラスの実装すべき API なのですが、BBinder クラスの IBinder::transact() の実装の内部で onTransact() を呼び出すようになっているので、BBinder を継承してサービスを実装する場合は、onTransact() メソッドを実装すればよいことになります。 サービスの起動 サービスクラスを作成したら、実際にこのクラスのインスタンスを生成するための main 関数を持つ実行ファイルを作成します。 この実行ファイル内で、サービスのインスタンスに名前を付けて ServiceManager に登録することで、他のプロセスからサービスインスタンスを参照できるようになります。 int main() { sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); sm-&gt;addService(String16(&#34;CalcService&#34;), new CalcService()); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } ServiceManager の内部まで追っていくと、最終的に binder driver を介してプロセス間通信を行っています。 サービスを利用するクライアントの実装 他のプロセスからサービスを利用するには、ServiceManager から名前で IBinder オブジェクトを取得します。 ここで ServiceManager が返す IBinder オブジェクトは、プロセス間通信を実現するためのプロキシクラスである BpBinder オブジェクトです。 もちろん、サービスインスタンスが ServiceManager に登録されるまでは IBinder オブジェクトの取得には失敗します。 一度 IBinder オブジェクトを取得できてしまえば、あとは transact メソッドを呼び出してサービスの機能にアクセスできます。 int main() { sp&lt;IServiceManager&gt; sm = defaultServiceManager(); binder = sm-&gt;getService(String16(&#34;CalcService&#34;)); if (binder == 0) { LOGW(&#34;CalcService has not been published yet...&#34;); return 0; } Parcel data; // Input Parcel reply; // Output data.writeInt32(100); data.writeInt32(50); binder-&gt;transact(0, data, &amp;reply); // Add function LEGI(&#34;CalcService returns: %d&#34;, reply.readInt32()); } ここまでの例では、Android の提供している IBinder::transact() インタフェースだけを使用してプロセス間通信を行っているので、サービス側と、クライアント側で共通のヘッダファイルを用意することなく通信が行えています。 完全なコードと実行テスト CalcService.zip CalcClient.zip 実行ファイルをデバイスに転送したら、以下のように CalcService サービスを起動できます。 # CalcService &amp; 04-28 17:26:57.480 3178 3178 I CalcService: Add CalcService to ServiceManager サービスを起動している状態で CalcClient プログラムを起動すると、サービスにアクセスできていることが分かります。 # CalcClient 04-28 17:27:33.236 3196 3196 I CalcClient: CalcService returns: 150"},{url:"/p/c2ycgaj/",title:"Linuxメモ: 改行コードが原因の関数定義の syntax error",date:"2011-04-27T00:00:00+09:00",body:"Linuxメモ: 改行コードが原因の関数定義の syntax error 下記は簡単な関数を定義しているだけのシンプルなシェルスクリプトですが、 my_functions.sh function hello { echo &#39;Good morning!&#39; } このファイルを source コマンドで読み込んだときに以下のような syntax error が出ることがあります。 $ source my_functions.sh &#39;ash: my_functions.bash: line 1: syntax error near unexpected token `{ &#39;ash: my_functions.bash: line 1: `function hello { このようなエラーが出る場合は、テキストファイルの改行コードが Windows (CR+LF) で保存されている可能性があります。 改行コードを変更するには、例えば Vim エディタから以下のように実行します。 :set ff=unix :w"},{url:"/p/z2oqmoj/",title:"Androidメモ: サービスからコールバックできるようにする",date:"2011-04-25T00:00:00+09:00",body:"Androidメモ: サービスからコールバックできるようにする ここでは、別プロセスで動いているサービスにバインドし、そのサービスに対してコールバックを登録できるようにする方法を説明します。 サービスからのコールバックの仕組みを実現するには、以下のような実装が必要です。 サービス側にコールバックを登録する実装 サービス側からコールバックする実装 コールバックを登録するクライアント側の実装 コールバックされたときのクライアント側の実装 AIDL ファイルを作成する 2つの AIDL ファイルで以下のインタフェースを定義します。 IEchoServiceListener.aidl（コールバック用のインタフェース） IEchoService.aidl（サービスのコールバック登録用 API） AIDL ファイルから生成されるインタフェース（Java ファイル）は、クライアント側とサービス側の両方で共通のものを使用します。 IEchoServiceListener.aidl package com.example.hello; interface IEchoServiceListener { void onReceiveMessage(String message); } IEchoService.aidl package com.example.hello; import com.example.hello.IEchoServiceListener; interface IEchoService { void addListener(IEchoServiceListener listener); void removeListener(IEchoServiceListener listener); void hello(String name); } IEchoServiceListener は同じパッケージに定義されていますが、AIDL ファイル内では import 宣言が必要です。 サービス側を実装する サービス側で、コールバックを登録／解除するためのメソッドを実装します。 ここでは簡単のため、クライアント側から hello() メソッドを呼び出したときに、すぐにコールバックするように実装しています。 EchoService.java package com.example.hello; import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.os.RemoteCallbackList; import android.os.RemoteException; public class EchoService extends Service { private RemoteCallbackList&lt;IEchoServiceListener&gt; listeners = new RemoteCallbackList&lt;IEchoServiceListener&gt;(); private final IEchoService.Stub mBinder = new IEchoService.Stub() { @Override public void addListener(IEchoServiceListener listener) throws RemoteException { listeners.register(listener); } @Override public void removeListener(IEchoServiceListener listener) throws RemoteException { listeners.unregister(listener); } @Override public void hello(String name) throws RemoteException { int n = listeners.beginBroadcast(); for (int i = 0; i &lt; n; i++) { try { listeners.getBroadcastItem(i).onReceiveMessage(&#34;Hello, &#34; + name); } catch (RemoteException e) { // The RemoteCallbackList will take care of removing // the dead object for us. We can ignore this exception. } } listeners.finishBroadcast(); } }; @Override public IBinder onBind(Intent intent) { return mBinder; } } コールバックを管理するためのユーティリティクラスとして、android.os.RemoteCallbackList が用意されています。 サービス側から実際にコールバック処理を行う場合は、RemoteCallbackList クラスの次の3つのメソッドを利用します。 beginBroadcast() でコールバック区間の開始。 getBroadcastItem(index) でコールバック用のオブジェクトを取得し、コールバック実行。 finishBroadcast() でコールバック区間の終了。 クライアント側を実装する クライアント側では、以下の実装を行います。 サービスへのバインド処理。 サービスへコールバックを登録／解除する処理。 コールバック時の処理内容（IEchoServiceListener.Stub の実装）。 ここでは、サービスに対してコールバックを登録した直後に hello() メソッドを呼び出し、サービス側からの onReceiveMessage() を発火させています。 MainActivity.java package com.example.hello; import android.app.Activity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.util.Log; public class MainActivity extends Activity { private IEchoService mEchoService = null; private boolean mIsBound = false; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // Bind to EchoService. Intent intent = new Intent(IEchoService.class.getName()); bindService(intent, connection, Context.BIND_AUTO_CREATE); mIsBound = true; } @Override protected void onDestroy() { super.onDestroy(); if (mIsBound) { unbindService(connection); mIsBound = false; } } // コールバックされたときの処理 private IEchoServiceListener listener = new IEchoServiceListener.Stub() { @Override public void onReceiveMessage(String message) throws RemoteException { Log.i(&#34;Test&#34;, message); } }; // bind 時の処理 private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder binder) { mEchoService = IEchoService.Stub.asInterface(binder); try { mEchoService.addListener(listener); mEchoService.hello(&#34;Joe&#34;); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { if (mEchoService == null) { return; } try { mEchoService.removeListener(listener); } catch (RemoteException e) { // サービスが既に切断されている場合は無視 } mEchoService = null; } }; }"},{url:"/p/s596qii/",title:"Vim/Neovim で制御文字（改行、タブ文字、行末のスペースなど）を表示する (list, listchars)",date:"2011-04-24T00:00:00+09:00",body:"Vim/Neovim で制御文字（改行、タブ文字、行末のスペースなど）を表示する (list, listchars) list モードとは Vim/Neovim の list モードを有効にすると、テキストファイル内の制御文字や空白文字（タブや末尾のスペースなど）を視覚的に表示することができます。 例えば、プログラミング言語の Python などでコーディングを行っているときは、タブ文字と通常のスペースを意識して使い分けなければいけないので、このような非表示文字を目に見えるように設定しておくことには意味があります。 もちろん通常の文章を記述するときにも、行末の余計なスペースなどを簡単に見つけられるようになるので、この設定は常に有効にしておくことをオススメします。 list モードは、Vim でも Neovim でもデフォルトでは無効になっているため、明示的に有効化する必要があります。 :set list &#34;制御文字を表示 :set nolist &#34;制御文字を非表示 次のように行範囲（全ての行）を指定して list コマンドを実行すると、一時的に制御文字を確認することができます。 :% list 制御文字の表示方法の設定 (listchars) タブや改行などの制御文字をどのように表示するかは、listchars (lcs) オプションで設定します。 デフォルト設定 listchars のデフォルト値は Vim と Neovim で次のように異なっています。 &#34; Vim のデフォルト設定 set listchars=eol:$ &#34; Neovim のデフォルト設定 set listchars=tab:&gt;\\ ,trail:-,nbsp:+ Vim のデフォルト設定では、タブ文字が ^I 、改行が $ で表示されます。 Neovim のデフォルト設定では、タブ文字が &gt; 、行末のスペースが - で表示されます。 listchars の設定例 Vim (~/.vimrc) の場合 &#34; 制御文字の設定 set listchars=tab:&gt;.,trail:_,eol:$ set list Neovim (~/.config/nvim/init.lua) の場合 -- 制御文字の表示設定（方法 1）オススメ vim.opt.listchars = { tab = &#34;&gt;.&#34;, trail = &#34;_&#34;, eol = &#34;$&#34; } vim.opt.list = true -- 制御文字の表示設定（方法 2） vim.o.listchars = &#34;tab:&gt;.,trail:_,eol:$&#34; vim.opt.list = true 各設定の意味 tab:&gt;. では、タブの 1 文字目を &gt; で、2 文字目以降を . で表示するよう指示しています。 trail:_ では、行末の半角スペースを _ で表示するよう指示しています。 eol:$ では、行末に $ を表示するよう指示しています。 set list では、list モードを有効化して制御文字を表示するよう指示しています。 listchars オプションのヘルプ どんな非表示文字を表示できるかは、:help 'listchars' のヘルプで確認できます。 下記はヘルプ内容の抜粋です。 eol:c Character to show at the end of each line. When omitted, there is no extra character at the end of the line. 行末の表示に使われる文字。指定されないと、行末には何も表示されない。 tab:xy[z] Two or three characters to be used to show a tab. The third character is optional. タブ文字の表示に使われる文字。1 文字目は 1 回だけ使われる。2 文字目はタブが通常占めるだけの空白を埋めるまで繰り返し表示される。&ldquo;tab:&gt;-&rdquo; とすると、タブが 4 文字の設定では &ldquo;&gt;&mdash;&rdquo; となる。指定されないと、タブは ^I と表示される。 space:c Character to show for a space. When omitted, spaces are left blank. スペースの表示に使われる文字。指定されないと、スペースは空白のまま。 trail:c Character to show for trailing spaces. When omitted, trailing spaces are blank. Overrides the &ldquo;space&rdquo; and &ldquo;multispace&rdquo; settings for trailing spaces. 行末のスペースの表示に使われる文字。指定されないと、行末のスペースは空白のまま。行末のスペースでは &ldquo;space&rdquo; の設定を上書きする。 extends:c Character to show in the last column, when wrap is off and the line continues beyond the right of the screen. wrap がオフで、行が画面の右端よりも伸びているときに、最終列に表示される文字。 precedes:c Character to show in the first visible column of the physical line, when there is text preceding the character visible in the first column. wrap がオフで、最前列で表示されている最初の文字より前にテキストが存在するとき {訳注: 上の行の末尾が画面の右端より伸びているとき} に、最前列に表示される文字。 conceal:c Character to show in place of concealed text, when conceallevel is set to 1. A space when omitted. conceallevel が 1 のときに Conceal されたテキストの代わりに表示される文字。 nbsp:c Character to show for a non-breakable space character (0xA0 (160 decimal) and U+202F). Left blank when omitted. ノンブレークスペース文字 (0xA0 (10進数では160) や U+202F) の表示に使われる文字。指定されない場合は空白のまま。訳注: 0xA0はLatin1で改行なしスペースを表す。 表示文字として UTF-8 の文字を指定できますが、: と , は使えません。 表示文字は 1 文字幅の文字を指定する必要があります。 次のように表示文字に Unicode を指定することもできます（\\\\uXXXX あるいは \\\\UXXXXXXXX の形で指定します）。 タブを »... 行末を ↵ で表示 set listchars=tab:».,eol:↵ set listchars=tab:\\\\u00bb.,eol:\\\\u21b5 &#34;同上 set listchars=tab:\\\\U000000bb.,eol:\\\\U000021b5 &#34;同上 eol、extends、precedes には強調表示グループ NonText が使われます。 nbsp、space、tab、trail には強調表示グループ SpecialKey が使われます。 参考 全角スペースを見えるように表示する"},{url:"/p/qjc27rj/",title:"Androidメモ: 別プロセスのサービスへバインドする (Remote Bind)",date:"2011-04-21T00:00:00+09:00",body:"Androidメモ: 別プロセスのサービスへバインドする (Remote Bind) 別のプロセスで動いているサービスに対してバインドを実行するには、サービス側とクライアント側でプロセス間通信 (IPC) を行う必要があります。 参考: Service - Android Developers AIDL で IPC 用スタブを自動生成する プロセス間通信を実現するためのスタブクラスのひな型を自動生成するために、Android では AIDL という言語を使用します。 例えば、echo メソッドを提供する EchoService にアクセスするための AIDL は以下のようになります。 EchoService が公開するインタフェースを表しているので、頭文字に I をつけて、IEchoService というインタフェース名にしています。 クライアント側から見ると、サービス名は IEchoService として見えるようになります。 IEchoService.aidl package com.example.hello; interface IEchoService { String echo(String message); } ADT プラグインのインストールされた Eclipse を使っている場合は、この AIDL ファイルをソースファイルと同じディレクトリ入れると、自動的に Java ファイルが生成されます。 src/com/example/hello/IEchoService.aidl（手書きで作成する AIDL ファイル） gen/com/example/hello/IEchoService.java（自動生成される Java ファイル） 自動生成される IEchoService.java の内容は以下のようになっています。 IEchoService.java（自動生成） package com.example.hello; public interface IEchoService extends android.os.IInterface { public static abstract class Stub extends android.os.Binder implements com.example.hello.IEchoService { ... } ... } バインド先のサービスを実装する サービス本体の実装では、onBind メソッドで適切な IBinder オブジェクトを返す必要があります。 AIDL から自動生成された IEchoService.java ファイルで、IBinder オブジェクトのひな型となる Stub のサブクラスが定義されているので、この Stub クラスを実装するだけで、プロセス間通信に対応した Binder クラスが完成します。 実装しなければいけないメソッドは、AIDL で定義した公開 API です。 EchoService.java package com.example.hello; import android.app.Service; import android.content.Intent; import android.os.IBinder; import android.os.RemoteException; public class EchoService extends Service { private final IEchoService.Stub mBinder = new IEchoService.Stub() { @Override public String echo(String message) throws RemoteException { return &#34;EcoService: &#34; + message; } }; @Override public IBinder onBind(Intent intent) { return mBinder; } } 独自のサービスを作成したら、AndroidManifest.xml にエントリを忘れずに追加します。 Remote Bind の場合は、AIDL ファイルから自動生成されたクラス名を intent-filter で指定しておく必要があります。 これにより、IEchoService のクラス名を使ってクライアント側からバインドすることができるようになります。 &lt;service android:name=&#34;.EchoService&#34;&gt; &lt;intent-filter&gt; &lt;action android:name=&#34;com.example.hello.IEchoService&#34; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; プロセス間通信に対応したバインドを行えるようにしたので、以下のようにサービスを別プロセスで動かすように指定することもできます。 EchoService は別プロセスで動くようになり、プロセス名にサフィックスとして :remote が付くようになります。 &lt;service android:name=&#34;.EchoService&#34; android:process=&#34;:remote&#34;&gt; ... &lt;/service&gt; バインド元のクライアントを実装する サービスにバインドするクライアント側でも、IEchoService.aidl から自動生成された IEchoService.java を用意する必要があります。 つまり、サービスの実装側となるアプリと、クライアントになるアプリの両方に IEchoService.java が必要です。 もちろん同じアプリ内でサービスとクライアントを実装する場合は、IEchoService.java は 1 つだけになります。 サービスにバインドするまでの流れは以下のようになります。 クライアントがアクセスするときは、実際に Service クラスを実装している EchoService ではなく、IEchoService の名前を使ってサービス起動やバインド処理を記述するのがポイントです。 IEchoService のクラス名を使って bindService を実行。 バインドされると、bindService で指定した ServiceConnection オブジェクトの onServiceConneted が呼び出される。 onServiceConnected メソッドで渡される IBinder オブジェクトから IXxxService オブジェクトを取得する。 IXxxService オブジェクトを使ってサービスの API を呼び出す。 MainActivity.java package com.example.hello; import android.app.Activity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.os.RemoteException; import android.widget.Toast; public class MainActivity extends Activity { private IEchoService mEchoService = null; private boolean mIsBound = false; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // Bind to EchoService. Intent intent = new Intent(IEchoService.class.getName()); bindService(intent, connection, Context.BIND_AUTO_CREATE); mIsBound = true; } @Override protected void onDestroy() { super.onDestroy(); if (mIsBound) { unbindService(connection); mIsBound = false; } } private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder binder) { mEchoService = IEchoService.Stub.asInterface(binder); // あとは echoService の public メソッドを呼び出せば OK. try { String result = mEchoService.echo(&#34;Hello&#34;); Toast.makeText(MainActivity.this, result, Toast.LENGTH_SHORT).show(); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { mEchoService = null; } }; }"},{url:"/p/mavfgi7/",title:"Androidメモ: 同じプロセス内のサービスへバインドする (Local Bind)",date:"2011-04-21T00:00:00+09:00",body:"Androidメモ: 同じプロセス内のサービスへバインドする (Local Bind) Android で同じプロセス内（主に同じアプリ内）のサービスに対してバインドする場合は、bindService メソッドを使用して比較的簡単にバインドを実行することができます。 別プロセスで動作するサービスへのバインドとは異なり、AIDL を使った Binder のスタブ作成などは必要はありません。 参考 Service - Android Developers バインド先のサービスを実装する ここでは、EchoService というサービスを作成します。 EchoService は、文字列を返す簡単な echo API を提供します。 サービスにバインドできるようにするには、サービスの onBind メソッドで適切な IBinder オブジェクトを返す必要があります。 ローカルプロセス内のバインドでは、特にプロセス間通信などは必要ないので、ここでは、単純に Binder クラスを継承したクラス (LocalBinder) を作成しています。 クライアント側ではバインドが成功したときに、このオブジェクトを取得することになります。 package com.example.hello; import android.app.Service; import android.content.Intent; import android.os.Binder; import android.os.IBinder; public class EchoService extends Service { private final IBinder mBinder = new LocalBinder(); @Override public IBinder onBind(Intent intent) { return mBinder; } public String echo(String message) { return &#34;EchoService: &#34; + message; } /** * Class for clients to access. * Since we know this service always runs in the same process * as its clients, we don&#39;t need to deal with IPC. */ public class LocalBinder extends Binder { EchoService getService() { return EchoService.this; } } } 独自のサービスを作成したら、忘れずに AndroidManifest.xml にエントリを追加しておきます。 &lt;service android:name=&#34;.EchoService&#34; /&gt; バインド元のクライアントを実装する クライアント側でサービスに対してバインドして、API を参照できるようになるまでの流れは以下のような感じです。 バインド先のクラスを指定して bindService を実行。 バインドされると、bindService で指定した ServiceConnection オブジェクトの onServiceConnected が呼ばれる。 onServiceConnected メソッドで受け取った IBinder オブジェクトから、Service オブジェクトを取得。 取得した Service オブジェクトの API を利用する。 bindService をした場合は、最後に忘れずに unbindService するようにします。 package com.example.hello; import android.app.Activity; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.widget.Toast; public class MainActivity extends Activity { private EchoService mEchoService = null; private boolean mIsBound = false; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); // Bind to EchoService. Intent intent = new Intent(this, EchoService.class); bindService(intent, connection, Context.BIND_AUTO_CREATE); mIsBound = true; } @Override protected void onDestroy() { super.onDestroy(); if (mIsBound) { unbindService(connection); mIsBound = false; } } private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder binder) { mEchoService = ((EchoService.LocalBinder) binder).getService(); // あとは echoService の public メソッドを呼び出せば OK. String result = mEchoService.echo(&#34;Hello&#34;); Toast.makeText(MainActivity.this, result, Toast.LENGTH_SHORT).show(); } @Override public void onServiceDisconnected(ComponentName name) { mEchoService = null; } }; }"},{url:"/p/qkxss6a/",title:"Tera Term のマクロで特定の文字列を検出して処理を実行する",date:"2011-04-19T00:00:00+09:00",body:"Tera Term のマクロで特定の文字列を検出して処理を実行する Tera Term のマクロで、waitln 命令を使用すると、ターミナルに特定の文字列が出力されたことを検出することができます。 例えば、シリアル接続したデバイスなどからのメッセージを監視して、あるパターンに一致するメッセージを受信したときに任意の処理を行うことができます。 下記のサンプルマクロでは、シリアル接続された端末から system booted という文字列を受信したときに、Hello というメッセージを表示し、mycommand &amp; というコマンドを実行しています。 auto_hello.ttl do while 1 timeout = 0 ;Timeout never occurs waitln &#39;system booted&#39; pause 1 dispstr #$0A #$0A dispstr &#39;Hello&#39;#$0A dispstr #$0A #$0A sendln &#39;mycommand &amp;&#39; loop ところどころ出てくる #$0A というのは、改行することを表しています。"},{url:"/p/ecj6wbo/",title:"Linuxメモ: Bash の構文: 関数へパラメータを渡す",date:"2011-04-15T00:00:00+09:00",body:"Linuxメモ: Bash の構文: 関数へパラメータを渡す 関数に渡されたパラメータの処理方法は、シェルスクリプト実行時に渡されたコマンドラインパラメータの処理方法と同じです。 以下のコマンドラインパラメータの処理方法に関する記事も参考にしてください。 コマンドライン引数を取得する 関数へ渡されたパラメータの数を調べる ($#) 関数内で $# を参照すると、渡されたパラメータの数を調べることができます。 サンプルコード function foo { echo $# } 実行結果 $ foo 100 200 2 $ foo aaa bbb ccc 3 $ foo &#34;This is a pen&#34; 1 ☝️ ワンポイント 関数の外で $# を参照すると、シェルスクリプト実行時に渡されたコマンドラインパラメータの数を取得できます。 応用例: 関数へ渡されたパラメータが少なくとも 1 つ以上あるか調べる function foo { if [ $# -lt 1 ]; then echo &#39;Function &#34;foo&#34; needs at least one parameter&#39; &gt;&amp;2 exit -1 fi echo &#39;OK&#39; } 関数へ渡されたパラメータを順番に処理する サンプルコード function enum_params { while [ -n &#34;$1&#34; ]; do echo $1 shift done } [ -n &quot;$1&quot; ] の部分では、パラメーターが空文字ではないかどうかを調べています。 shift コマンドは、パラメータを左にシフトします。 つまり、$2 の値が $1 に、$3 の値が $2 に、というようにシフトされます。 これにより、すべてのパラメーターを $1 で順番に参照することができます。 実行結果 $ enum_params 1 2 3 1 2 3 パラメータをシングルクォーテーション、あるいはダブルクォーテーションで囲むと、1 つのパラメータとして処理されます。 $ enum_params &#34;1 2 3&#34; 1 2 3 関数のデフォルトパラメータを定義する パラメータを参照するときに、${1:-デフォルト値} という形で参照すると、1 つ目のパラメータが指定されなかった場合に デフォルト値 を使用することができます（これも、シェルスクリプト自体のコマンドラインパラメータの扱い方と同様です）。 サンプルコード function greet { name=${1:-everyone} echo &#34;Hello $name&#34; } 実行結果 $ greet Hello everyone $ greet Maku Hello Maku"},{url:"/p/458msi9/",title:"GoFのデザインパターン: Visitor パターン",date:"2011-04-10T00:00:00+09:00",body:"GoFのデザインパターン: Visitor パターン GoF のデザインパターンのひとつである Visitor パターンは、オブジェクトの構造を変更せずに、オブジェクトの集合に対して新しい操作を追加するためのパターンです。 Visitor パターンの特徴 インタフェースの異なるオブジェクトを巡回することができる。Visitor オブジェクトは、各種要素を巡回しながら目的のデータを構築する。 巡回対象のクラスのカプセル化が破られることがある。 若干複雑。 単純なポリモーフィズムによる巡回ができる場合は、このパターンを使う必要はない。 Visitor パターンを使わない場合 例えば、HTML のノードリストを順番に処理しながら HTML テキストを構築することを考えてみます。 各ノード（テキストノードやリンクノードなど）を表すクラスは、保持するデータやインタフェースが異なるため、深く考えずに実装してしまうと次のような instanceof とキャストの組み合わせコードができてしまいます。 public String extractHtmlText() { StringBuilder results = new StringBuilder(); Node node = null; while ((node = nodeList.next()) != null) { if (node instanceof StringNode) { StringNode n = (StringNode) node; results.append(&#34;&lt;P&gt;&#34;); results.append(n.getText()); results.append(&#34;&lt;/P&gt;&#34;); } else if (node instanceof LinkNode) { LinkNode n = (LinkNode) node; results.append(&#34;&lt;A href=&#39;&#34;&gt; + n.getUri() + &#34;&#39;&gt;&#34;); results.append(n.getLinkName()); results.append(&#34;&lt;/A&gt;&#34;); } else if (...) { ... } } return results.toString(); } 各種ノードに、以下のような HTML テキストを返すための共通のインタフェースを用意すれば、instanceof やキャストを行わずにポリモーフィックに Node を処理できると考えるかもしれません。 public interface Node { public String getHtmlText(); } しかし、Node インタフェースにこのような出力メソッドの実装を強要してしまうと、各 Node サブクラスが HTML 出力のための知識を持つことになってしまいます。 HTML 意外の出力形式、例えば Latex に対応したくなったらどうしましょう？ public interface Node { public String getHtmlText(); public String getLatexText(); } こういった追加があるごとに、全ての Node サブクラスを変更することになってしまいます。 Node クラスには、本来のデータ提供のための責務を果たすのに専念してもらうべきで、いろんなフォーマットに対応した出力の機能は持たせたくありません。 できれば HTML や Latex 出力のためのコードは、Node クラスから切り離された別のクラスで行いたいのです。 Visitor パターンを使う場合 Visitor クラスは、各要素を順番に処理し、任意のデータを構築します。 例えば、各種 Node サブクラスを処理することができる Visitor は以下のようなインタフェースで定義します。 各種 Node サブクラスごとに、その型に特化したメソッドを1つずつ用意します。 例えば、StringNode のために visitStringNode(...) を用意します。 public interface NodeVisitor { public void visitStringNode(StringNode node); public void visitLinkNode(LinkNode node); ... } visitStringNode() メソッドは、StringNode クラスから呼び出され、visitLinkNode() メソッドは、LinkNode クラスから呼び出されることになります。 Visitor パターンでは、各要素をポリモーフィックに処理できるようにするため、各要素が Visitor オブジェクトを受け取る共通の accept メソッドを実装します。 public interface Node { public void accept(NodeVisitor visitor); } そして、各要素の accept メソッドの実装の中で、自分自身を処理してもらうように Visitor クラスに処理を委譲します。 ここで、自分自身の型とマッチする Visitor クラスのメソッドを呼び出すようにするのがポイントです。 ここが Visitor パターンの肝です。 StringNode クラスは、自分自身の型が StringNode であると分かっているので、Node オブジェクトからの StringNode オブジェクトへのキャスト処理が必要なく、また、適切な visitStringNode() メソッドを呼び出すことができます。 public StringNode implements Node { ... @Override public void accept(NodeVisitor visitor) { visitor.visitStringNode(this); } } Visitor クラス側の実装では、すべての Node オブジェクトの accept メソッドを、自分自身をパラメータとして順番に呼び出していきます。 すると、各 Node オブジェクトから、visitStringNode や visitLinkNode などの具体的な型に依存したメソッドが呼び出されるので、この中で目的のデータを構築していきます。 public class HtmlTextExtractor implements NodeVisitor { private StringBuilder results; public String extractHtmlText() { results = new StringBuilder(); Node node = null; while ((node = nodeList.next()) != null) { node.accept(this); } return results.toString(); } @Override public void visitStringNode(StringNode node) { results.append(&#34;&lt;P&gt;&#34;); results.append(node.getText()); results.append(&#34;&lt;/P&gt;&#34;); } @Override public void visitLinkNode(LinkNode node) { results.append(&#34;&lt;A href=&#39;&#34;&gt; + node.getUri() + &#34;&#39;&gt;&#34;); results.append(node.getLinkName()); results.append(&#34;&lt;/A&gt;&#34;); } ... } Visitor クラスが各要素の accept メソッドを呼び出し、呼び出された各要素側の accept 内では、Visitor オブジェクトの適切なメソッドを呼び返しています。このように二段階で実際に呼び出されるメソッドが決定することを「ダブル・ディスパッチ」と呼びます。 上記は、HTML テキストを構築するための具象 Visitor クラスの実装になっていますが、もし、HTML 以外に Latex 形式でも出力したくなった場合は、 このような具象 Visitor クラスをもうひとつ用意するだけで済みます。 各 Node クラスに手をいれる必要はないのです。 参考文献 『Design Patterns: Elements of Reusable Object-Oriented Software』 『アジャイルソフトウェア開発の奥義』 『Agile Software Development, Principles, Patterns, and Practices』 『パターン思考リファクタリング入門』第10章 累積処理"},{url:"/p/7zgfhqz/",title:"Androidベンダー向けメモ: android/build/core 以下の *.mk ファイルで定義されている関数 (define) のリスト",date:"2011-04-08T00:00:00+09:00",body:"Androidベンダー向けメモ: android/build/core 以下の *.mk ファイルで定義されている関数 (define) のリスト 下記の bash スクリプトを android/build/core 以下で実行すると、Android の Makefile (.mk) 用に定義されている関数を一覧で取得できます。 Android が定義している関数はハイフンを単語区切りにしているみたいです。 list_defines.sh #!/bin/bash find -name &#39;*.mk&#39; -o -name &#39;Makefile&#39; | xargs grep &#39;^define &#39; | sed &#39;s/^\\(.\\+\\):\\(.\\+\\)/\\2 ... \\1/&#39; | sort | uniq 実行結果 $ cd android/build/core $ ./list_defines.sh define add-assets-to-package ... ./definitions.mk define _add-clean-step ... ./cleanbuild.mk define add-clean-step ... ./cleanbuild.mk define add-dependency ... ./definitions.mk define add-dex-to-package ... ./definitions.mk define add-java-resources-to-package ... ./definitions.mk define add-jni-shared-libs-to-package ... ./definitions.mk define add-prebuilt-file ... ./definitions.mk define add-prebuilt-files ... ./definitions.mk define add-radio-file ... ./definitions.mk define add-radio-file-internal ... ./definitions.mk define add-required-deps ... ./main.mk define align-package ... ./definitions.mk define all-c-files-under ... ./definitions.mk define all-Iaidl-files-under ... ./definitions.mk define all-java-files-under ... ./definitions.mk define all-makefiles-under ... ./definitions.mk define all-named-subdir-makefiles ... ./definitions.mk define all-proto-files-under ... ./definitions.mk define all-subdir-c-files ... ./definitions.mk define all-subdir-html-files ... ./definitions.mk define all-subdir-Iaidl-files ... ./definitions.mk define all-subdir-java-files ... ./definitions.mk define all-subdir-makefiles ... ./definitions.mk define append-path ... ./definitions.mk define assert-max-file-size ... ./definitions.mk define assert-max-image-size ... ./definitions.mk define auto-prebuilt-boilerplate ... ./multi_prebuilt.mk define build-systemimage-target ... ./Makefile define build-systemtarball-target ... ./Makefile define build-userdataimage-target ... ./Makefile define build-userdatatarball-target ... ./Makefile define check-all-products ... ./product.mk define check-api ... ./tasks/apicheck.mk define clear-var-list ... ./node_fns.mk define collapse-pairs ... ./definitions.mk define combine-notice-files ... ./Makefile define copy-file-to-new-target ... ./definitions.mk define copy-file-to-new-target-with-cp ... ./definitions.mk define copy-file-to-target ... ./definitions.mk define copy-file-to-target-strip-comments ... ./definitions.mk define copy-file-to-target-with-cp-and-permissions ... ./definitions.mk define copy-file-to-target-with-cp ... ./definitions.mk define copy-file-to-target-with-permissions ... ./definitions.mk define copy-file-to-target-with-zipalign ... ./definitions.mk define copy-one-dist-file ... ./distdir.mk define copy-one-file ... ./definitions.mk define copy-one-header ... ./definitions.mk define copy-testcase-apk ... ./tasks/cts.mk define copy-var-list ... ./node_fns.mk define create-empty-package ... ./definitions.mk define create-java-proto-rule ... ./definitions.mk define create-resource-java-files ... ./definitions.mk define default-locale-language ... ./Makefile define default-locale ... ./Makefile define default-locale-region ... ./Makefile define dist-for-goals ... ./distdir.mk define doc-timestamp-for ... ./definitions.mk define dump-device ... ./device.mk define dump-devices ... ./device.mk define dump-module-variables ... ./definitions.mk define dump-product ... ./product.mk define dump-products ... ./product.mk define dump-words-to-file ... ./definitions.mk define emit-line ... ./definitions.mk define _expand-inherited-values ... ./node_fns.mk define extract-and-include-whole-static-libs ... ./definitions.mk define _find-android-products-files ... ./product.mk define find-copy-subdir-files ... ./product_config.mk define find-other-html-files ... ./definitions.mk define find-other-java-files ... ./definitions.mk define find-parent-file ... ./definitions.mk define find-subdir-assets ... ./definitions.mk define find-subdir-files ... ./definitions.mk define find-subdir-subdir-files ... ./definitions.mk define first-makefiles-under ... ./definitions.mk define generate-core-test-description ... ./tasks/cts.mk define get-all-product-makefiles ... ./product.mk define get-file-size ... ./combo/darwin-x86.mk define get-file-size ... ./combo/linux-x86.mk define get-file-size ... ./combo/windows-x86.mk define get-inherited-nodes ... ./node_fns.mk define _get-package-overrides ... ./definitions.mk define get-package-overrides ... ./definitions.mk define get-tagged-modules ... ./definitions.mk define image-size-from-data-size ... ./definitions.mk define import-devices ... ./device.mk define _import-node ... ./node_fns.mk define _import-nodes-inner ... ./node_fns.mk define import-nodes ... ./node_fns.mk define import-products ... ./product.mk define include-path-for ... ./pathmap.mk define include-prebuilt ... ./definitions.mk define inherit-device ... ./device.mk define inherit-product ... ./product.mk define insert-liblog ... ./binary.mk define install-dex-debug ... ./definitions.mk define intermediates-dir-for ... ./definitions.mk define is-c-identifier ... ./product_config.mk define _java-lib-classes.jar ... ./definitions.mk define _java-lib-dep ... ./definitions.mk define java-lib-deps ... ./definitions.mk define _java-lib-dir ... ./definitions.mk define java-lib-files ... ./definitions.mk define _java-lib-full-classes.jar ... ./definitions.mk define _java-lib-full-dep ... ./definitions.mk define local-intermediates-dir ... ./definitions.mk define module-built-files ... ./definitions.mk define module-installed-files ... ./definitions.mk define module-names-for-tag-list ... ./definitions.mk define modules-for-tag-list ... ./definitions.mk define module-stubs-files ... ./definitions.mk define move-var-list ... ./node_fns.mk define my-dir ... ./definitions.mk define normalize-host-libraries ... ./definitions.mk define normalize-libraries ... ./definitions.mk define normalize-path-list ... ./definitions.mk define normalize-target-libraries ... ./definitions.mk define obfuscate-jar ... ./definitions.mk define package_files-copy-root ... ./Makefile define prepare-doc-source-list ... ./droiddoc.mk define pretty ... ./definitions.mk define print-vars ... ./definitions.mk define _resolve-short-device-name ... ./device.mk define resolve-short-device-name ... ./device.mk define _resolve-short-product-name ... ./product.mk define resolve-short-product-name ... ./product.mk define select-android-config-h ... ./config.mk define should-install-to-system ... ./main.mk define sign-package ... ./definitions.mk define sign-package-full ... ./definitions.mk define tranform-host-m-to-o ... ./definitions.mk define transform-aidl-to-java ... ./definitions.mk define transform-classes.jar-to-dex ... ./definitions.mk define transform-classes.jar-to-emma ... ./definitions.mk define transform-c-or-s-to-o-no-deps ... ./definitions.mk define transform-cpp-to-o ... ./definitions.mk define transform-c-to-o ... ./definitions.mk define transform-c-to-o-no-deps ... ./definitions.mk define transform-d-to-p ... ./definitions.mk define transform-generated-source ... ./definitions.mk define transform-host-c-or-s-to-o-no-deps ... ./definitions.mk define transform-host-cpp-to-o ... ./definitions.mk define transform-host-c-to-o ... ./definitions.mk define transform-host-c-to-o-no-deps ... ./definitions.mk define transform-host-java-to-package ... ./definitions.mk define transform-host-m-to-o-no-deps ... ./definitions.mk define transform-host-o-to-executable ... ./definitions.mk define transform-host-o-to-executable-inner ... ./combo/darwin-x86.mk define transform-host-o-to-executable-inner ... ./definitions.mk define transform-host-o-to-package ... ./definitions.mk define transform-host-o-to-shared-lib ... ./definitions.mk define transform-host-o-to-shared-lib-inner ... ./combo/darwin-x86.mk define transform-host-o-to-shared-lib-inner ... ./definitions.mk define transform-host-o-to-static-lib ... ./definitions.mk define transform-host-ranlib-copy-hack ... ./definitions.mk define transform-host-s-to-o ... ./definitions.mk define transform-host-s-to-o-no-deps ... ./definitions.mk define transform-java-to-classes.jar ... ./definitions.mk define transform-l-to-cpp ... ./definitions.mk define transform-m-to-o ... ./definitions.mk define transform-m-to-o-no-deps ... ./definitions.mk define transform-o-to-executable ... ./definitions.mk define transform-o-to-executable-inner ... ./combo/darwin-x86.mk define transform-o-to-executable-inner ... ./combo/linux-arm.mk define transform-o-to-executable-inner ... ./combo/target_linux-fishtank.mk define transform-o-to-executable-inner ... ./combo/target_linux-x86.mk define transform-o-to-executable-inner ... ./definitions.mk define transform-o-to-package ... ./definitions.mk define transform-o-to-shared-lib ... ./definitions.mk define transform-o-to-shared-lib-inner ... ./combo/darwin-x86.mk define transform-o-to-shared-lib-inner ... ./combo/linux-arm.mk define transform-o-to-shared-lib-inner ... ./combo/target_linux-fishtank.mk define transform-o-to-shared-lib-inner ... ./combo/target_linux-x86.mk define transform-o-to-shared-lib-inner ... ./definitions.mk define transform-o-to-static-executable ... ./definitions.mk define transform-o-to-static-executable-inner ... ./combo/darwin-x86.mk define transform-o-to-static-executable-inner ... ./combo/linux-arm.mk define transform-o-to-static-executable-inner ... ./combo/target_linux-fishtank.mk define transform-o-to-static-executable-inner ... ./combo/target_linux-x86.mk define transform-o-to-static-executable-inner ... ./definitions.mk define transform-o-to-static-lib ... ./definitions.mk define transform-prebuilt-to-target ... ./definitions.mk define transform-prebuilt-to-target-strip-comments ... ./definitions.mk define transform-prebuilt-to-target-with-zipalign ... ./definitions.mk define transform-proto-to-cpp ... ./definitions.mk define transform-ranlib-copy-hack ... ./definitions.mk define transform-s-to-o ... ./definitions.mk define transform-s-to-o-no-deps ... ./definitions.mk define transform-to-prelinked ... ./definitions.mk define transform-to-stripped ... ./definitions.mk define transform-variables ... ./definitions.mk define transform-y-to-cpp ... ./definitions.mk define true-or-empty ... ./definitions.mk define uniq-word ... ./node_fns.mk define unzip-jar-files ... ./definitions.mk define word-color ... ./definitions.mk"},{url:"/p/okshfzt/",title:"Androidベンダー向けメモ: インストールされた各 APK パッケージに割り当てられたユーザー ID を調べる (packages.xml)",date:"2011-04-05T00:00:00+09:00",body:"Androidベンダー向けメモ: インストールされた各 APK パッケージに割り当てられたユーザー ID を調べる (packages.xml) /data/system/packages.xml ファイルを見ると、各 APK に割り当てられているユーザー ID を調べることができます。 /data/system/packages.xml &lt;package name=&#34;com.example.history&#34; codePath=&#34;/system/app/History.apk&#34; system=&#34;true&#34; ts=&#34;1301918167000&#34; version=&#34;7&#34; userId=&#34;10006&#34;&gt; &lt;sigs count=&#34;1&#34;&gt; &lt;cert index=&#34;3&#34; /&gt; &lt;/sigs&gt; &lt;/package&gt;"},{url:"/p/9dzwawd/",title:"Android Nativeメモ: ネイティブライブラリ (.so) の展開先",date:"2011-03-31T00:00:00+09:00",body:"Android Nativeメモ: ネイティブライブラリ (.so) の展開先 Android 1.5 から JNI 呼び出しで用いる共有ライブラリ (.so) は、APK の作成時に自動的にパッケージングされるようになりました。 共有ライブラリはアプリ (.apk) をインストールするときに、自動的に /data/data/&lt;package&gt;/lib に展開される。 アプリ起動時に /data/data/&lt;package&gt;/lib の下の共有ライブラリ (.so) は動的にロードできるようパスが通される。 アプリのアンインストール時には共有ライブラリは自動的に削除される。"},{url:"/p/or3cmv6/",title:"Linuxシェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while)",date:"2011-02-06T00:00:00+09:00",body:"Linuxシェルスクリプト: ディレクトリ内のファイルを順に処理する (for, while) ワイルドカードを使用する方法 ワイルドカード (*) を使って、カレントディレクトリ内のファイルをループ処理することができます。 例: すべてのファイル（ドットファイルを除く）をループ処理 for x in *; do echo &#34;$x&#34; done 特定の拡張子を持つファイルのみを列挙するには次のようにします。 例: すべての PNG ファイルをループ処理 for x in *.png; do echo $x done 次のように一行で書くこともできます。 for x in *.png; do echo &#34;$x&#34;; done find コマンドの結果を使用する方法（再帰的にファイル探索） 下記の例では、find コマンドによって見つかったファイルを while ループで順番に処理しています。 深い階層にあるファイルも再帰的に処理されます。 find . -type f | while read x; do echo &#34;$x&#34; done 参考: 外部コマンドの実行結果を 1 行ずつ処理する (for, while, read)"},{url:"/p/w48omg6/",title:"Android Nativeメモ: C++ 実装用のスマートポインタ (RefBase, sp) を使用する",date:"2011-02-03T00:00:00+09:00",body:"Android Nativeメモ: C++ 実装用のスマートポインタ (RefBase, sp) を使用する Android フレームワークの android/frameworks/base/include/utils/RefBase.h にスマートポインタクラス sp が定義されてます。 使い方は、 sp&lt;Hoge&gt; hoge = new Hoge(); のような感じで、hoge がスコープを外れると自動的にデストラクタを呼んでくれます。 sp はリファレンスカウンタを持っているので、sp オブジェクト間で代入処理 (operator=) を行っても大丈夫です（代入した瞬間に delete されてしまうことはない）。 スマートポインタとして扱えるようにするクラスは、以下のように RefBase を継承して作成する必要があります。 これは、RefBase が参照カウンタなどを実装しているからです。 Hoge.h #include &lt;utils/RefBase.h&gt; class Hoge : public virtual RefBase { public: static sp&lt;Hoge&gt; self(); ... }; Hoge.cpp Hoge::Hoge() : RefBase() {} Android.mk では libutils.so を使用する指定をしておく必要があります。 Android.mk LOCAL_SHARED_LIBRARIES := \\ libutils"},{url:"/p/3wheif6/",title:"Linuxメモ: カーネルに渡されたパラメータを調べる (/proc/cmdline)",date:"2011-02-01T00:00:00+09:00",body:"Linuxメモ: カーネルに渡されたパラメータを調べる (/proc/cmdline) /proc/cmdline の内容を出力すると、カーネルへ渡されたコマンドラインパラメータを調べることができます。 $ cat /proc/cmdline BOOT_IMAGE=/boot/vmlinuz-2.6.32-28.generic root=UUID=37c279f8-9c77-78c5-c379-d01e2c480351 ro quiet splash 他にも、/proc 以下のファイルにアクセスしていろいろな情報を取得することができます。 例えば、cat /proc/cpuinfo とすると、CPU の情報を調べることができます。 どのような情報を取得できるか、man proc で確認してみてください。"},{url:"/p/2tumm9k/",title:"Linuxメモ: Linux のメモリ情報を調べるコマンド",date:"2011-01-20T00:00:00+09:00",body:"Linuxメモ: Linux のメモリ情報を調べるコマンド free コマンド free コマンドを使用して、Linux システム全体の空きメモリ容量 (KByte) を調べることができます。 内部的には、/proc/meminfo の内容を整形して表示しています。 実行例（Ubuntu 10.04 の場合） $ free total used free shared buffers cached Mem: 4057716 3110204 947512 0 255708 2091224 -/+ buffers/cache: 763272 3294444★ ←実質的な空き容量はここを見る Swap: 11884536 60600 11823936 Linux では、ディスクアクセスの負荷軽減のために、空きメモリをバッファ領域（ファイルのメタ情報などを保持）とキャッシュ領域（ファイルの内容そのものをキャッシュ）に割り当てています。 上記の Mem: の行の free 値 947512 は、空き容量からバッファ領域 (buffers) とキャッシュ領域 (cached) に割り当てた分を差し引いた値を示しているので、free の値はいつも小さくなります。 実質的な空き容量を求めるには、free の値に buffers と cached の分を足してやる必要があります。 その下の行の -/+ buffers/cache: というところがこの計算をした結果を示しており、一行目の free、buffers、cached をすべて足した、実質的な空き容量が表示されています。 3294444（実質 free） = 947512 (mem free) + 255708 (buffers) + 2091224 (cached) おまけ: free コマンドの help やオプション 下記は free コマンドのヘルプ説明です。 free - Display amount of free and used memory in the system free displays the total amount of free and used physical and swap memory in the system, as well as the buffers used by the kernel. The shared memory column should be ignored; it is obsolete. free コマンドは、下記のようなオプションを組み合わせて使用することが多いです。 $ free -m # KByte ではなく MByte 単位で表示 $ free -s 5 # 5 秒間隔でポーリングして表示 参考: Linuxトラブルシューティング探偵団　番外編（1）：減り続けるメモリ残量！ 果たしてその原因は!? (2/3) - ＠IT /proc/meminfo を直接見る free コマンドなどは、proc/meminfo の内容を整形して出力していますが、proc/meminfo を直接参照すると下記のような情報を取得することができます。 実行例（Ubuntu 10.04 の場合） $ cat /proc/meminfo MemTotal: 4057720 kB MemFree: 1622196 kB Buffers: 337768 kB Cached: 1236440 kB SwapCached: 1008 kB Active: 938236 kB Inactive: 861756 kB Active(anon): 26748 kB Inactive(anon): 205540 kB Active(file): 911488 kB Inactive(file): 656216 kB Unevictable: 0 kB Mlocked: 0 kB SwapTotal: 11884536 kB SwapFree: 11883456 kB Dirty: 0 kB Writeback: 0 kB AnonPages: 225056 kB Mapped: 76716 kB Shmem: 6504 kB Slab: 458988 kB SReclaimable: 435412 kB SUnreclaim: 23576 kB KernelStack: 2768 kB PageTables: 22020 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 13913396 kB Committed_AS: 630384 kB VmallocTotal: 34359738367 kB VmallocUsed: 336908 kB VmallocChunk: 34359395836 kB HardwareCorrupted: 0 kB HugePages_Total: 0 HugePages_Free: 0 HugePages_Rsvd: 0 HugePages_Surp: 0 Hugepagesize: 2048 kB DirectMap4k: 190436 kB DirectMap2M: 4001792 kB procrank コマンド procrank コマンドは、プロセスごとのメモリ使用状況を調べることができます。 下記の項目がよく参照されます。 PSS (Proportional Set Size) そのプロセスが実質的に使用しているメモリ容量です。複数のプロセスで共有しているメモリが比例分配されて計算されているため、すべてのプロセスの PSS を合計すれば、システム全体の使用量になります。 USS (Unique Set Size) そのプロセスのみが占有しているメモリ容量です。このサイズが時間とともに単調増加していくようですと、そのプロセスはメモリリークしているのだと判断できます。 vmstat コマンド vmstat コマンドは、仮想メモリに関する統計情報を表示します。 vmstat reports information about processes, memory, paging, block IO, traps, disks and cpu activity. The first report produced gives averages since the last reboot. Additional reports give information on a sampling period of length delay. The process and memory reports are instantaneous in either case. 実行例（Ubuntu 10.04 の場合） $ vmstat procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- r b swpd free buff cache si so bi bo in cs us sy id wa 0 0 1080 1621568 337804 1236444 0 0 3 4 21 33 0 0 100 0 下記のようなオプションを指定すると、MByte 単位で、５秒間隔でポーリングして表示できます。 $ vmstat -SM 5 procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- r b swpd free buff cache si so bi bo in cs us sy id wa 0 0 1 1583 329 1207 0 0 3 4 21 33 0 0 100 0 si、so はスワップイン、スワップアウトを示しており、これが頻発する場合は、スラッシング（仮想メモリとのやりとりに CPU 処理時間のほとんどを割いてしまう状況）が発生している可能性があります。 pmap コマンド pmap コマンドは、プロセスのメモリマップ情報を表示します。"},{url:"/p/2wgxfwd/",title:"Traceview でプロファイル情報を表示する",date:"2011-01-14T00:00:00+09:00",body:"Traceview でプロファイル情報を表示する 参考: Traceview - Android Developers プロファイリングデータを取得する アプリケーション内の特定のコード区間のプロファイリングを行うには、プロファイリンク期間を android.os.debug.Debug クラスの startMethodTracing() と stopMethodTracing() で囲みます。 Debug.startMethodTracing(); ... プロファイリング中 ... Debug.stopMethodTracing(); プロファイリング結果は、/sdcard/dmtrace.trace というバイナリファイルに出力されます。 端末に SD カードが挿入されていないとエラーになります。 startMethodTracing メソッドのパラメータでファイル名のベース名を指定すると、/sdcard/&lt;basename&gt;.trace というファイル名で出力されるようになります。 結局 SD カードに出力されることには変わりありません。 ドキュメントには、 These methods start and stop method tracing across the entire virtual machine. と記述されているので、Debug.startMethodTracing() を呼び出した時点から、アプリケーション全体（正確には Dalvik VM 全体）のプロファイリングが行われることになります。 Activity がそのアプリのエントリポイントとなっているのなら、onCreate(), onDestroy() でそれぞれ、startMethodTracing()、stopMethodTracing() を呼び出すようにすれば、そのアプリ全体のプロファイリングを行うことができます。 プロファイリングデータを表示する Android SDK に含まれている traceview コマンドを使用すると、プロファイリング結果をグラフィカルに表示することができます。 図: Traceview 上記の図では、タイムラインに main スレッドが一本だけ表示されていますが、複数のスレッドが存在すれば、main 以外のスレッドもその下に表示されます。 まずは、/sdcard/dmtrace.trace ファイルを PC に取得します。 C:\\&gt; adb pull /sdcard/dmtrace.trace あとは traceview コマンドのパラメータとして、dmtrace.trace のパスを渡すだけです。 Windows ではフルパスで指定する必要があります。 C:\\&gt; traceview D:\\z\\dmtrace.trace プロファイリングデータからメソッドの呼び出しグラフを作成する $ dmtracedump -g output.png dmtrace.trace ※ dmtracedump は Windows では動作しません。 プロファイリングデータを HTML で出力する $ dmtracedump -h dmtrace.trace &gt; output.html ※ dmtracedump は Windows では動作しません。"},{url:"/p/xkoyxnh/",title:"共通鍵暗号化方式と公開鍵暗号化方式",date:"2010-11-28T00:00:00+09:00",body:"共通鍵暗号化方式と公開鍵暗号化方式 共通鍵暗号化方式 用途 暗号化／複合化 &ndash; 暗号化と複合化を同じ共通鍵（秘密鍵 Secret Key）で行う。 実装 DES (Data Encryption Standard) &ndash; 1960年代。IBM。FIPS 46。暗号強度が低すぎる。鍵が 56 ビットなので、ブルートフォースアタックですぐに解読されてしまう。 3-DES (Triple DES) &ndash; 1999年。IBM。AES までの繋ぎ。 AES (Advanced Encryption Standard) &ndash; 2001年3月。米国商務省標準技術局(NIST)。FIPS 197 として公表。 公開鍵暗号化方式 用途 暗号化／複合化 &ndash; 送信者が受信者の公開鍵 (Public Key) で暗号化し、受信者は自分の非公開鍵 (Private Key) で複合化する。 署名 &ndash; 送信者が自分の非公開鍵で電子署名し、受信者が送信者の公開鍵で改変されていないことを確認する。公開鍵がそもそも偽造だと意味がないので、公開鍵を正しいものだと証明するための機関として、認証局 (CA) というものがある。 実装 RSA（Ronald Rivest, Adi Shamir, Leonard Adleman）&ndash; 1977年。 DSA (Digital Signature Algorithm) &ndash; 1991年8月。米国商務省標準技術局(NIST)。FIPS 186 として公表。1024 bits が一般的。 ECDSA (Elliptic Curve Digital Signature Algorithm) &ndash; 楕円曲線暗号版の DSA。RSA や DSA よりも短い鍵長で、強い強度を持つという特徴がある。 Ed25519 (Edwards-curve Digital Signature Algorithm) &ndash; エドワーズ曲線暗号。ECDSA よりも高速に処理できるという特徴がある。 「認証局 (CA)」は、鍵の所有者の情報と、その公開鍵を管理しており、公開鍵が偽造されていないことを「証明書 (Certificate)」を発行することで証明します。 「証明書」とは、ある公開鍵とその所有者情報を「認証局の非公開鍵で署名」したものです。 この署名により、認証局が発行している証明書がそもそも本物であるということを証明します。 ようするに、公開鍵暗号方式では、どこかの時点で公開鍵を無条件に信頼しなければいけなくて、その代表になるのが認証局ということです。 証明書の形式には X.509 というものが使われます（バージョンとして X.509 V1 や V3 がよく使用される）。 HTTPS、SSH、SFTP などで使用する SSL は、公開鍵暗号方式でまず共通鍵（秘密鍵）を交換しておいて、その後の暗号化は共通鍵暗号方式で行われます。 これは、暗号化に共通鍵を使うと速度的に有利という特徴があるからです。"},{url:"/p/xsdpj94/",title:"Androidベンダー向けメモ: make 後の生成イメージが格納されるディレクトリを調べる ($ANDROID_PRODUCT_OUT)",date:"2010-11-08T00:00:00+09:00",body:"Androidベンダー向けメモ: make 後の生成イメージが格納されるディレクトリを調べる ($ANDROID_PRODUCT_OUT) Android ビルド時に lunch コマンドでビルドターゲットを指定すると、ビルドイメージが作成される先のディレクトリ名を $ANDROID_PRODUCT_OUT 変数で参照できるようになります。 $ echo $ANDROID_PRODUCT_OUT /home/maku/work/android/out/target/product/your_product 上記の変数は、build/envsetup.sh の中で定義されるようになっています。 この変数を使用すれば、例えば、adb push で /system/app ディレクトリ内のファイルを端末に転送するための下記のような関数を定義することができます（/system 用のデバイスが /dev/sda5 になっている場合）。 ~/.bashrc function adb-push-all { adb shell &#39;mount -o remount -rw /dev/sda5 /system&#39; adb push $ANDROID_PRODUCT_OUT/system/app /system/app adb shell &#39;sync&#39; }"},{url:"/p/cfqazd7/",title:"Androidメモ: スリープモードに遷移する／スリープから抜ける",date:"2010-11-01T00:00:00+09:00",body:"Androidメモ: スリープモードに遷移する／スリープから抜ける ADB コマンドを使ってスリープモードに移行する／スリープから抜ける ADB コマンドでスリープ状態に入る $ adb shell &#34;echo mem &gt; /sys/power/state&#34; ADB コマンドでスリープ状態から抜ける $ adb shell &#34;echo on &gt; /sys/power/state&#34; コード内からスリープモードに移行する（ベンダー向け情報） プログラム内からスリープモードに移行するには、AndroidManifest.xml に DEVICE_POWER のパーミッション使用宣言を追加しておきます。 AndroidManifest.xml &lt;manifest ...&gt; &lt;uses-permission android:name=&#34;android.permission.DEVICE_POWER&#34; /&gt; &lt;/manifest&gt; 適切にパーミッションが割り当てられると、コード内から以下のようにスリープへ移行することができます。 PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); pm.goToSleep(SystemClock.uptimeMillis() + 1); このコードを実行するには、システム権限アプリとして動作している必要があります。 通常アプリから実行すると、以下のような SecurityException が発生します。 E/AndroidRuntime( 7118): java.lang.RuntimeException: Unable to create service com.example.sample.MyService: java.lang.SecurityException: Neither user 10052 nor current process has android.permission.DEVICE_POWER."},{url:"/p/fkn27wa/",title:"Androidメモ: 画面消灯 (SCREEN OFF) までの時間を取得・設定する",date:"2010-11-01T00:00:00+09:00",body:"Androidメモ: 画面消灯 (SCREEN OFF) までの時間を取得・設定する ユーザの無操作状態が「何ミリ秒」続いたときに画面を自動的に OFF にするか、というタイムアウト値 (SCREEN_OFF_TIMEOUT) を取得するには以下のようにします。 // import android.provider.Settings; // import static android.provider.Settings.System.SCREEN_OFF_TIMEOUT; int timeoutInMs = 0; try { timeoutInMs = Settings.System.getInt(getContentResolver(), SCREEN_OFF_TIMEOUT); } catch (SettingNotFoundException e) { e.printStackTrace(); } 例えば、1 時間に設定されている場合は、3600000（1時間＊60分＊60秒＊1000）という値が取得できます。 次のようにすれば、画面 OFF までのタイムアウト時間を「設定」することができます。 // 10 分でスクリーンオフ Settings.System.putInt(getContentResolver(), SCREEN_OFF_TIMEOUT, 10 * 60 * 1000);"},{url:"/p/2mb4a94/",title:"bash のプロンプトに Git のカレントブランチ名を表示する (PS1)",date:"2010-10-15T00:00:00+09:00",body:"bash のプロンプトに Git のカレントブランチ名を表示する (PS1) 下記のように bash のプロンプト設定 (PS1) を行っておくと、プロンプト表示に Git のカレントブランチ名を表示することができます。 ~/.bashrc parse_git_branch() { git branch 2&gt; /dev/null | sed -e &#39;/^[^*]/d&#39; -e &#39;s/* \\(.*\\)/ (\\1)/&#39; } PS1=&#34;\\w\\$(parse_git_branch) $ &#34; こんな感じで表示されます。 ~/gitwork/myapp (master) $ ちなみに、Git で現在チェックアウトしているブランチ名を取得するには、いろんな方法があります。 $ git name-rev HEAD 2&gt; /dev/null | awk &#34;{ print \\$2 }&#34; $ git branch 2&gt; /dev/null | cut -f2 -d\\* -s $ git branch 2&gt; /dev/null | grep -e ^* | tr -d \\*\\ ←半角スペース $ git branch 2&gt; /dev/null | sed -e &#39;/^[^*]/d&#39; -e &#39;s/* \\(.*\\)/\\1/&#39;"},{url:"/p/arxcjmp/",title:"Linuxメモ: カレントディレクトリや指定したファイルの絶対パスを取得する",date:"2010-10-15T00:00:00+09:00",body:"Linuxメモ: カレントディレクトリや指定したファイルの絶対パスを取得する カレントディレクトリの絶対パスを取得する 以下のどの方法でも、カレントディレクトリの絶対パスを取得できます。 current_dir=$(pwd) current_dir=&#34;$PWD&#34; current_dir=`pwd` 指定したファイルの絶対パスを取得する 相対パスで指定したファイルのパスを絶対パスに変換するには、下記のように dirname と basename を組み合わせて使用します。 $path には、カレントディレクトリからの相対パスでファイル名が格納されているとします。 abs_path=$(cd $(dirname $path); pwd)/$(basename $path) 内部で cd コマンドを実行しているため、ディレクトリ名を含むパスを指定したときは、実際にそのディレクトリが存在していないといけないことに注意してください。 下記のサンプルスクリプトは、コマンドラインパラメータとして渡された相対パスを絶対パスに変換します。 rel2abs.sh（渡されたファイルパスを絶対パスに変換する） #!/bin/bash abs_path=$(cd $(dirname $1); pwd)/$(basename $1) echo &#34;$abs_path&#34; 実行結果 $ cd /Users/maku/scripts $ ./rel2abs.sh aaa/bbb/ccc.txt /Users/maku/scripts/aaa/bbb/ccc.txt $ cd /Users/maku $ scripts/rel2abs.sh scripts/aaa/bbb/ccc.txt /Users/maku/scripts/aaa/bbb/ccc.txt 実行時のカレントディレクトリが異なっていても、正しく絶対パスを取得できていることがわかると思います。"},{url:"/p/c4q8amz/",title:"Vim 内で grep を実行して見つかったファイルへジャンプする (:vimgrep, :grep)",date:"2010-09-13T00:00:00+09:00",body:"Vim 内で grep を実行して見つかったファイルへジャンプする (:vimgrep, :grep) 内部 grep (internal grep) と外部 grep (external grep) Vim には自身に搭載されている検索機能を実行する 内部 grep と、外部の grep 系コマンドを実行する 外部 grep の機能が存在します。 内部 grep を起動するコマンド &hellip; :vim（:vimgrep の省略形） 外部 grep を起動するコマンド &hellip; :grep :vimgrep による検索（内部 grep） :vimgrep の概要 内部 grep（:vim あるいは :vimgrep）は、Vim に組み込まれた grep 機能を使用するため、どの OS 上でも共通の振る舞いの検索を実行することができます。 検索にヒットした行は Vim 内部の QuickFix List という配列データに追加され、そこから見つけた行にジャンプすることができます（参考: :help quickfix.txt）。 書式 :vim /{pattern}/[g][j] {file} ... g オプション &hellip; 同じ行の中にパターンに一致する部分が複数あった場合に、QuickFix List に別々に追加します。デフォルトでは、同じ行内で複数回検索にヒットしても、その行は 1 度だけ QuickFix List に追加されます。多くのケースでは、このオプションを指定する必要はないでしょう。 j オプション &hellip; デフォルトでは検索で最初にマッチした行にカーソルが移動します。j オプションを付けると、カーソルの位置は移動しません。 基本的な検索 例: 現在開いているファイルを grep :vim /hoge/ % % は現在開いているファイル名を表します。 例: *.txt ファイルを grep :vim /hoge/ *.txt 例: カレントディレクトリ以下のファイルをすべて grep :vim /hoge/ **/*.txt 大文字・小文字の区別 デフォルトではパターンの大文字・小文字を区別して検索しますが、オプション ignorecase がセットされている場合は、パターンの大文字・小文字を区別せずに検索します。 ignorecase の設定に関わらず、大文字・小文字を区別して検索したい場合は、パターンの中に \\C を含めます。 逆に、大文字・小文字を区別せずに検索したい場合は、パターンの中に \\c を含めます。 例: 大文字・小文字を区別して include という文字列を検索 :vim /\\Cinclude/ **/*.cpp QuickFix List のウィンドウを開く :vim (:vimgrep) による検索が終了したら、copen で QuickFix List のウィンドウ（QuickFix ウィンドウ）を開いて、見つけた行の一覧を確認することができます。 対象の行に移動して Enter キーを入力することで、その場所にジャンプすることができます。 QuickFix ウィンドウを開く :copen :vimgrep の実行と同時に QuickFix ウィンドウを開きたいときは、以下のように cw[indow] コマンドを続けて実行します。 検索と同時に QuickFix ウィンドウを開く :vim /hoge/ *.txt | cw 毎回 | cw と入力するのが面倒な場合は、.vimrc に以下のように設定しておきます。 :vimgrep 後に自動で copen する設定 au QuickfixCmdPost grep,grepadd,vimgrep,vimgrepadd copen この設定により、vimgrep を実行した後に、自動的に copen が実行されるようになります。 上記の例では、他にも grep、grepadd、vimgrepadd を実行した際も QuickFix ウィンドウを開くよう設定しています。 必要に応じて変更してください。 ☝️ ワンポイント :copen コマンドの C はおそらく &ldquo;Current List of Errors&rdquo; の C です。 :copen コマンドで開いたウィンドウの buftype は quickfix となり、全体で 1 つだけ表示できるようになっています。 すでに QuickFix ウィンドウが開いている状態で :vimgrep や :grep を実行した場合、そのウィンドウに検索結果が表示されます。 :grep による検索（外部 grep） :vimgrep コマンドの代わりに :grep コマンドを使用すると、grepprg オプションに設定されている外部の grep 系コマンドを実行することができます。 外部 grep の実行 :grep [arguments] grepprg オプションのデフォルト値は、Windows の場合は findstr /n、Linux の場合は grep -n $* /dev/null に設定されています。 grepprg オプションの値を確認 :set grepprg? &#34; grep -n $* /dev/null のように表示されます 通常は、以下のような感じで実行できるはずです。 外部 grep による検索 :grep hoge *.txt &#34; *.txt ファイルを grep :grep hoge % &#34; 編集中のファイルを grep :vimgrep コマンドと同様、:copen コマンドで QuickFix ウィンドウを開いて、検索にヒットした行にジャンプできます。 QuickFix ウィンドウを開く :copen おまけ :vimgrep (:vim) や :grep コマンドの代わりに、:vimgrepadd や :grepadd コマンドを使用すると、検索結果を既存の QuickFix List に追加することができます。 既存の QuickFix List に検索結果を追加する :vimgrepadd /AAA/ *.txt :grepadd AAA *.txt setqflist() 関数を呼び出すと、QuickFix List の内容を修正することができます。 次のように実行すると、QuickFix List がクリアされます（空配列 [] がセットされます）。 QuickFix List をクリアする :call setqflist([])"},{url:"/p/rm9ve9q/",title:"Androidメモ: ネットワーク情報を取得する (ConnectivityManager, NetworkInfo)",date:"2010-09-09T00:00:00+09:00",body:"Androidメモ: ネットワーク情報を取得する (ConnectivityManager, NetworkInfo) ネットワークの情報を取得する ネットワーク関連の情報は、ConnectivityManager の getActiveNetworkInfo() メソッドで取得できる NetworkInfo オブジェクトを使って参照できます。 NetworkInfo オブジェクトは以下のように取得します。 // import android.net.ConnectivityManager; // import android.net.NetworkInfo; ConnectivityManager manager = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE); if (manager == null) { return false; } NetworkInfo networkInfo = manager.getActiveNetworkInfo(); if (networkInfo == null) { return false; } NetworkInfo を取得するためには ACCESS_NETWORK_STATE パーミッションが必要なため、AndroidManifest.xml で以下のように宣言しておきます。 AndroidManifest.xml &lt;manifest ...&gt; &lt;uses-permission android:name=&#34;android.permission.ACCESS_NETWORK_STATE&#34; /&gt; ... &lt;/manifest&gt; 参考: ConnectivityManager｜Android Developers ネットワークの情報を一覧表示する NetworkInfo オブジェクトの toString() メソッドで、ネットワーク情報の文字列表現を取得できます。 System.out.println(networkInfo.toString()); 出力結果（実際は一行） NetworkInfo: type: ETHERNET[], state: CONNECTED/CONNECTED, reason: eth0 DHCP success, extra: (none), roaming: false, failover: false, isAvailable: false, iPaddress: 192.168.3.98 ネットワークに接続されているか調べる Android デバイスがネットワークに接続されているかどうかは、NetworkInfo オブジェクトの isConnected() メソッドで調べることができます。 if (networkInfo.isConnected()) { // ネットワークに接続されている } 下記のように getState() メソッドを使って調べることもできます。 if (networkInfo.getState() == NetworkInfo.State.CONNECTED) { // ネットワークに接続されている } どのタイプのネットワークがアクティブになっているか調べる 現在アクティブになっているネットワークが、WiFi なのか、Ethernet なのか、モバイルデータ通信なのかなどを調べるには、NetworkInfo オブジェクトの getType() メソッドを使います。 NetworkInfo networkInfo = manager.getActiveNetworkInfo(); switch (networkInfo.getType()) { case ConnectivityManager.TYPE_WIFI: // WiFi network break; case ConnectivityManager.TYPE_ETHERNET: // Ethernet break; default: // Unknown break; } 次のように、タイプ名を文字列で取得することもできます。 String typeName = networkInfo.getTypeName(); 戻り値として、&quot;WIFI&quot; や &quot;ETHERNET&quot; などの文字列が返されます。 IP アドレスを調べる 現在アクティブなネットワークの IP アドレスを調べるには、NetworkInfo オブジェクトの getIpAddress() メソッドを使います。 String ipAddr = networkInfo.getIpAddress(); if (ipAddr == null) { // No address }"},{url:"/p/dwsvs5j/",title:"Linuxメモ: シェルスクリプト: 定数を定義する (readonly)",date:"2010-09-07T00:00:00+09:00",body:"Linuxメモ: シェルスクリプト: 定数を定義する (readonly) Bash スクリプト内で定数を定義するには、readonly コマンドを使用します。 readonly を使うことで、変数や関数を読み取り専用に設定でき、誤って値を変更したり削除したりすることを防げます。 下記のように実行すると、指定した変数や関数に対する代入や unset ができなくなります。 readonly my_var # 変数 my_var を readonly に readonly -a my_arr # 配列 my_arr を readonly に readonly -f my_func # 関数 my_func を readonly に 変数の定義と同時に readonly 指定することも可能です。 readonly USERNAME=maku 下記の例では、変数 MAX_SIZE を値 100 で初期化し、その後 200 という値を代入しようとしています。 sample.sh #!/bin/bash readonly MAX_SCORE=100 MAX_SCORE=200 MAX_SCORE 変数は readonly 化されているので、代入を実行しようとしたときにエラーになります。 実行結果 $ ./sample.sh ./sample.sh: 行 4: MAX_SCORE: 読み取り専用の変数です"},{url:"/p/mco3pis/",title:"Androidベンダー向けメモ: Make 変数でビルド範囲を制御する",date:"2010-09-06T00:00:00+09:00",body:"Androidベンダー向けメモ: Make 変数でビルド範囲を制御する Android のワンショット make の仕組みでは、Android.mk に基づいてビルド処理が行われますが、下位ディレクトリにある Android.mk はデフォルトでは検索しないようになっています。 下位ディレクトリのモジュール（プロジェクト）までビルドするには、上位の Android.mk で include 処理を記述する必要がありますが、この include 処理を実行するかどうかを Make 変数で制御することにより、ビルド範囲の制御が可能です。 下記の例では、CONFIG_HOGE という Make 変数の値により、下位ディレクトリのモジュールのビルドを制御しています。 ifeq ($(CONFIG_HOGE),true) include $(call all-subdir-makefiles) endif"},{url:"/p/r2re7ux/",title:"リソースは finally ブロックで閉じる",date:"2010-08-28T00:00:00+09:00",body:"リソースは finally ブロックで閉じる データベース接続に限らず、I/O 処理にかかわるオブジェクトを使用し終わった後は、通常はリソース解放するための明示的な close 処理が必要です。 例外機構をもつ言語において、close 処理は finally ブロック内で実行するのがセオリーです。 そうしないと、例外発生時に close が実行されないケースが出てきてしまいます。 このあたりの具体例は、下記のサイトでまとめられています。 この記事では、セマフォの解放も finally ブロック内で行うべきと記述されています。 Javaの理論と実践: 良いハウスキーピング習慣を身につける 例えば、Java の JDBC では、オープンした Connection オブジェクト、Statement オブジェクトを明示的に閉じる必要があります。 JDBC を使ったプログラミングでは、これらのオブジェクトの閉じ忘れによる不具合が非常に多いようです。 JDBC ドライバの実装はベンダによって様々なので、ある実装ではコネクションの閉じ忘れによってリークが発生するのに、別の実装では発生しなかったりすることがあります。 こういった事情により、潜在的なリソースリークの不具合が含まれていることに気付かないことが多いのです。 幸いにも、最近の静的解析ツールでは、このような DB コネクションの閉じ忘れを検出してくれるようになっています。 具体的な例として、JDBC の Connection オブジェクト、Statement オブジェクトを閉じるコードは以下のような try ～ finally 構成になっていなければいけません。 ここでは SQLException をメソッドの呼び出し元に伝搬させていますが、もちろんメソッド内でハンドルしてしまっても構いません。 public void doSomething() throws SQLException { Connection con = getConnection(); Statement stmt = null; try { stmt = con.createStatement(); ResultSet resultSet = stmt.executeQuery(&#34;SELECT * FROM tbl&#34;); // ... Use resultSet here ... } finally { try { if (stmt != null) { stmt.close(); } } finally { con.close(); } } } 上記のサンプルコードでは、Connection のオープン自体に失敗した場合は、finally ブロックを実行する必要がないので、Connection のオープン処理は try ブロックの外で行っています。 ResultSet は Statement が閉じられるときに自動的に閉じられると Java API 仕様で明記されているので、それを信じて、上記では明示的に ResultSet のクローズ処理は行っていません。"},{url:"/p/ucp6uab/",title:".gitignore ファイルで Git にバージョン管理させないファイルを指定する",date:"2010-08-27T00:00:00+09:00",body:".gitignore ファイルで Git にバージョン管理させないファイルを指定する gitignore メカニズムが検索する設定ファイル 特定のファイルを Git のバージョン管理の対象から外すための仕組みとして、gitignore メカニズムが用意されています。 そのための設定ファイルは、下記のようなパスから検索され、最初に見つかったものが優先的に使用されます。 ワークツリー中のディレクトリに置かれた .gitignore ファイル リポジトリの .git/info/exclude ファイル 構成変数 core.exludesfile でパスを指定したファイル ワークツリー内に置く .gitignore ファイルは、どの階層のディレクトリにも置くことができ、より下位のディレクトリにある .gitignore ファイルによる設定が優先されます。 プロジェクト全体で設定を共有したい場合は、.gitignore に設定を記述し、これをコミットしてチームメンバと共有します。 特定のリポジトリで、自分用に設定を行いたい場合は .git/info/exclude に設定を記述します。 どのリポジトリにも共通した、自分専用の設定を用いたい場合は、例えば $HOME/myconf/git-excludes といったファイルに設定を記述しておき、git config で以下のように参照設定しておけばよいでしょう。 $ git config --global core.excludesfile &#34;$HOME&#34;/myconf/git-excludes 上記の例では、グローバルな設定値にしていますが、--global オプションを外せば、特定のリポジトリ用に設定することも可能です。 .gitignore ファイルの構文 # コメント行 aaa # aaa というファイル、あるいはディレクトリを無視。 bbb/ # bbb というディレクトリを無視。 /ccc # .gitignore ファイルのあるディレクトリからの相対パスで # ccc というファイル、あるいはディレクトリを無視。 # つまり、この場合は .gitignore ファイルと同じディレクトリ内にある # ccc というファイル、あるいはディレクトリを示す。 *.class # 名前が .class で終わるファイルを無視 *.[ao] # 名前が .a あるいは .o で終わるファイルを無視 !ddd.o # ただし、ddd.o というファイルは無視「しない」 !/eee.a # .gitignore ファイルと同じディレクトリの eee.a というファイルは無視「しない」 設定例 デフォルトでは、以下のような一時ファイルまで git status コマンドなどで認識されてしまうので、これらのファイルを版管理の対象からはずしておくとよいです。 ファイル名がチルダで終わるバックアップファイル hello.txt~ C/C++ プログラムビルドで作成される *.a や *.o ファイル Java プログラムビルドで作成される *.class ファイル Vim でファイル編集中に作成される .hello.txt.swp のようなファイル quilt の管理ディレクトリ .pc 例えば、次のように設定します。 .gitignore *~ *.[ao] *.class *.swp .pc/ プロジェクトによっては、コンパイル済みの *.a ファイルなどもコミットするかもしれないので、*.[ao] より *.o の方がよいかもしれません。 ignore 設定したファイルを git add する gitignore によってバージョン管理の対象外にされているファイルを、強制的に git add するには、次のように -f オプションをつけて git add します。 無視されたファイルを強制追加 $ git add -f vendor_library.so"},{url:"/p/cv5pi7a/",title:"Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)",date:"2010-08-23T00:00:00+09:00",body:"Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune) 参考: Git でブランチを削除する (git branch -d/-D) 必要のないリモートブランチを削除（リモートサーバー側） git branch -d コマンドを使ってローカルのブランチを削除しても、GitHub などに既に push されているブランチは削除されません（他のメンバーには、まだブランチが存在しているように見えます）。 GitHub 側のブランチを削除するには、ローカルブランチを削除するのとは別のコマンドを実行する必要があります。 まずは、リモートトラッキングブランチの一覧を確認しておきます。 $ git branch -r origin/HEAD -&gt; origin/main origin/main origin/mybranch1 origin/mybranch2 origin/mybranch3 例えば、この中の mybranch2 を削除したい場合は、以下のようにして origin サーバに削除要求を送ります。 削除したいブランチの名前の前にコロン (:) を付けるのがポイントです。 $ git push origin :mybranch2 git push の 2 番目のパラメータで指定するリファレンス名は、&lt;プッシュ元のブランチ名&gt;:&lt;プッシュ先のブランチ名&gt; という形式を取りますが、このコロンの左側の部分を空にすることで、プッシュ先のブランチを削除する（空にする）という意味になります。 ローカル側のリモートトラッキングブランチを削除する 中央リポジトリ (GitHub) 側のブランチを削除しても、ローカルに作られているリモートトラッキングブランチは削除されません。 以下のように必要のないリモートトラッキングブランチを削除する必要があります。 # フェッチと同時に必要のないリモートトラッキングブランチを削除する（オススメ） $ git fetch --prune # 必要のないリモートトラッキングブランチを削除する $ git remote prune origin あるいは、以下のように指定したリモートトラッキングブランチを削除することもできます。 $ git branch -r -d origin/mybranch 前者の場合は、中央リポジトリ上から実際に削除されたブランチを、ローカルのリモートトラッキングブランチから削除します。 後者の場合は、中央リポジトリは関係なしに、指定したローカルのリモートトラッキングブランチを削除します。"},{url:"/p/whv8ues/",title:"Git の detached HEAD 状態へのチェックアウトとは",date:"2010-08-23T00:00:00+09:00",body:"Git の detached HEAD 状態へのチェックアウトとは ある Git ブランチのコードをチェックアウトするには、 $ git switch &lt;ブランチ名&gt; のように実行しますが、そのブランチの最新コードではなく、ある特定のバージョン（コミット ID）のソースコードを少しだけ覗いてみたいということがあります。 そのような場合は、ブランチ名の代わりにコミット ID を指定してチェックアウトすることができます。 コミット名を指定して git checkout を実行すると、どのローカルブランチもチェックアウトしていない detached HEAD という状態になります（HEAD が detached されているということ）。 例えば、以下のように git checkout すると、この状態になります。 $ git checkout 0d3ce61 # コミット ID を指定 $ git checkout HEAD^0 # 最新のコミットを指定 $ git checkout HEAD^1 # １つ前のコミットを指定 $ git checkout v2.6.18 # タグで示されるコミットを指定 $ git checkout origin/main # リモートトラッキングブランチを指定 HEAD が detached された状態で git branch を実行すると、どのブランチにもいないことを示す (no branch) が表示されます。 $ git branch * (no branch) main mybranch detached HEAD 状態でも git commit などのコマンドを実行できますが、どのブランチにもいない状態なので、どのブランチの head も更新されません。 再びローカルブランチ名を指定してチェックアウトすると、detached HEAD で行っていた変更を破棄してブランチの最新状態に戻ることができます。"},{url:"/p/6g8n3jw/",title:"Git で他のブランチの最新ファイルを現在のブランチにコピーする (git checkout)",date:"2010-08-20T00:00:00+09:00",body:"Git で他のブランチの最新ファイルを現在のブランチにコピーする (git checkout) Git では、ファイル単位で他のブランチにコミットされているファイルをコピーしてくることができます。 例えば、現在 main ブランチをチェックアウトしているときに、別のブランチ mybranch の sample.txt の最新をコピーしてきたいときは次のように実行します。 $ git checkout mybranch sample.txt"},{url:"/p/m5z4fi3/",title:"Linuxメモ: シェルスクリプトのあるディレクトリの絶対パスを取得する",date:"2010-08-20T00:00:00+09:00",body:"Linuxメモ: シェルスクリプトのあるディレクトリの絶対パスを取得する スクリプト自身の格納されているディレクトリの絶対パスは下記のようにして得ることができます（内部的に cd を実行していますが、実行後のカレントディレクトリが変わってしまうことはありません）。 self_dir=$(cd $(dirname $0); pwd) ちなみに、シェルスクリプトと同じディレクトリにあるファイルの絶対パスは、上記で求めたディレクトリパスと組み合わせれば作れます。 echo ${self_dir}/sample.txt"},{url:"/p/be5zj9v/",title:"ANR の原因を突き止める",date:"2010-08-16T00:00:00+09:00",body:"ANR の原因を突き止める Android のメインスレッドを長期間ブロックするコードがあると、ANR (Application Not Responding) が発生してアプリケーションが強制終了されます。 端末の画面上で Not responding ダイアログが表示されたら [Force Close] ボタンを押すと、以下のようなログが出るので、kill されたプロセス ID を確認します。 I ActivityManager: Killing process com.example.player (pid=854) at user&#39;s request I Process : Sending signal. PID: 854 SIG: 9 この場合のプロセス ID は 854 です。 ANR の詳細は、/data/anr/traces.txt に出力されています。 このテキストファイルを見てそのプロセス ID に関するコールスタックを確認すると、具体的にどのメソッドでブロックしてしまっているかがわかります。 $ adb pull /data/anr/traces.txt $ vim traces.txt 例えば、以下のように出力されていれば、VideoView.java 258 行目の MediaPlayer.prepareAsync 呼び出しでブロックしていることが分かります。 ----- pid 854 at 2008-10-01 12:03:02 ----- Cmd line: com.example.player DALVIK THREADS: &#34;main&#34; prio=5 tid=3 NATIVE | group=&#34;main&#34; sCount=1 dsCount=0 s=N obj=0xb4c69e50 self=0x804d3f0 | sysTid=854 nice=0 sched=0/0 cgrp=unknown handle=-1224341824 at android.media.MediaPlayer.prepareAsync(Native Method) at android.widget.VideoView.openVideo(VideoView.java:258) at android.widget.VideoView.access$2000(VideoView.java:53) at android.widget.VideoView$6.surfaceCreated(VideoView.java:506) ..."},{url:"/p/7cf83cy/",title:"Git コマンドの長いオプション名を省略して入力する小技",date:"2010-08-15T00:00:00+09:00",body:"Git コマンドの長いオプション名を省略して入力する小技 Git のコマンドで -- で始まるオプションを指定する場合、そのオプション名を省略して指定することができます。 例えば、--dry-run オプションは通常次のように指定しますが、 $ git push --dry-run 次のように --dr と省略して実行することができます。 $ git push --dr --d だけだと、--delete なのか --dry-run なのか判別できないので、一意に決まる長さまでは入力する必要があります。 参考: Git コマンドのエイリアスを作成する (alias.xxx)"},{url:"/p/4zi9s4y/",title:"Linuxメモ: NTP でシステム時刻を設定する",date:"2010-07-22T00:00:00+09:00",body:"Linuxメモ: NTP でシステム時刻を設定する （Ubuntu 9.04 で確認） NTP による時刻設定を有効にする まず、ntp パッケージをインストールします。 $ sudo apt-get install ntp 使用する NTP サーバは、下記のファイルで指定します。 /etc/ntp.conf server ntp.ubuntu.com 上記のような行を編集して、任意の NTP サーバのアドレスを指定してください。 複数の NTP サーバを指定することもできます。 最後に NTP daemon を再起動すれば NTP による自動時刻設定が有効になります。 $ sudo /etc/init.d/ntp restart NTP の動作確認 $ sudo ntpq -p 上記のコマンドで、サーバ名が表示されれば OK です。 手動で NTP サーバの時刻を取得 ntpdate コマンドを使用して、明示的に OS のシステム時刻を NTP サーバの時刻に同期させることができます。 $ sudo ntpdate -u ntp.ubuntu.com"},{url:"/p/jsctar8/",title:"Bash の変数展開機能を活用する（文字列の置換、デフォルト値など）",date:"2010-07-20T00:00:00+09:00",body:"Bash の変数展開機能を活用する（文字列の置換、デフォルト値など） Bash の変数は通常 ${x} のような形で参照しますが、様々な変数展開機能を利用すると、変数の存在を確認したり、一部を置換したり、デフォルト値を設定したりすることができます。 下記にざっと紹介しますが、公式なドキュメントは man bash の Parameter Expansion のセクションで参照することができます。 パターン照合演算子 次のような変数展開の構文を使用すると、変数に格納された文字列の一部を置換した文字列を作成することができます。 構文 意味 ${変数/パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（１つだけ） ${変数//パターン/置換文字列} パターンに一致する部分を置換文字列に置き換える（すべて） ${変数#パターン} 先頭から最短一致でパターンに一致する部分を取り除く ${変数##パターン} 先頭から最長一致でパターンに一致する部分を取り除く ${変数%パターン} 末尾から最短一致でパターンに一致する部分を取り除く ${変数%%パターン} 末尾から最長一致でパターンに一致する部分を取り除く パターン部分では、ワイルドカード（*、?、[a-z] など）を使用できます。 例: 変数内の b を B に置換する $ x=aaabbbccc $ y=${x/b/B} $ echo $y aaaBbbccc 最初に見つかった文字列だけが置換されていることがわかります。 パターンに一致する文字列をすべて置換するには次のようにします（最初のスラッシュを2つにします）。 $ x=aaabbbccc $ y=${x//b/B} $ echo $y aaaBBBccc 以下のように sed コマンドを使ったのと同様の効果を bash の機能だけで実現できていることになります。 $ y=$(echo $x | sed -e &#39;s/bbb/BBB/g&#39;) 例: フルパスから basename を取り出す 下記の例では /aaa/bbb/ccc という絶対パスから、ベースネーム部分の ccc を抽出しています。 */ というパターンで先頭から最長一致させ、/aaa/bbb/ という部分を取り除いています。 $ x=/aaa/bbb/ccc $ y=${x##*/} $ echo $y ccc ちなみに、ベースネーム部分を取得したいのであれば、通常は basename コマンドを使って以下のようにした方が簡単です。 $ basename $x 例: フルパスから dirname を取り出す 下記の例では、/aaa/bbb/ccc という絶対パスから、ディレクトリ名部分の /aaa/bbb を抽出しています。 /* というパターンで末尾から最短一致させ、/ccc という部分を取り除いています。 $ x=/aaa/bbb/ccc $ y=${x%/*} $ echo $y /aaa/bbb ちなみに、ディレクトリ部分を取得したいのであれば、通常は dirname コマンドを使用して以下のようにした方が簡単です。 $ dirname $x 例: &lsquo;#&rsquo; 以降のコメントを削除する $ line=&#34;aaa bbb # This is a comment&#34; $ line=${line%%#*} $ echo $line aaa bbb line 変数の中を末尾から見て、#* という表現で最長一致する部分を削除してます。 デフォルト値など 構文 意味 ${変数:-word} 変数が未定義のとき word を返す ${変数:=word} 変数が未定義のとき word を代入して返す ${変数:?} ${変数:?word} 変数が未定義のときエラーを表示する ${変数:+word} 変数が定義されているとき word を返す ${param:-word} の使用例 下記は man bash の抜粋です。 Use Default Values. If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted. If parameter is unset or null, the expansion of word is substituted. Otherwise, the value of parameter is substituted. 例えば、 x=${count:-0} とすると、$x の値は $count が定義されていなければ 0 になります。 つまり、$count のデフォルト値を 0 とみなして参照していることになります。 この構文は、コマンドライン引数が省略されたときのデフォルト値を設定するために使用できます。 例えば、 filename=${1:-input.txt} とすると、変数 $filename の値は、第1パラメータで指定された値か、あるいはデフォルト値の input.txt になります。 ${param:=word} の使用例 下記は man bash の抜粋です。 Assign Default Values. If parameter is unset or null, the expansion of word is assigned to parameter. The value of parameter is then substituted. Positional parameters and special parameters may not be assigned to in this way. 例えば、 x=${count:=0} とすると、$x の値は $count が定義されていなければ 0 になります。 ここまでは、${count:-0} とした場合と同様ですが、${count:=0} とすると、$count にも 0 が代入されます（代入 = だと考えると分かりやすいですね）。 変数に代入しようとするため、コマンドラインパラメータや関数のパラメータの $1 を参照するときにこの方法は使用できません。 ${param:?word} の使用例 下記は man bash の抜粋です。 Display Error if Null or Unset. If parameter is null or unset, the expansion of word (or a message to that effect if word is not present) is written to the standard error and the shell, if it is not interactive, exits. Otherwise, the value of parameter is substituted. 例えば、下記のようにすると、$count 変数が定義されていないければエラーを出力して終了します。 $ echo ${count:?} -bash: count: パラメータが null または設定されていません ? の後ろに表示するメッセージを指定することもできます。 $ echo ${count:?パラメータが設定されていません} -bash: count: パラメータが設定されていません ${param:+word} の使用例 下記は man bash の抜粋です。 Use Alternate Value. If parameter is null or unset, nothing is substituted, otherwise the expansion of word is substituted. これはちょっと特殊で、変数 $param が定義されているときに、代わりに word の方の値が返されます。 例えば、${count:+1} は、$count が定義されていたら 1 と評価されます。 $ count=9999 $ echo ${count:+1} 1 $ unset count $ echo ${count:+1} 位置指定で部分文字列を抽出する 構文 意味 ${変数:offset} offset で指定した位置から末尾までの文字列を抽出する ${変数:offset:length} offset で指定した位置から length 分の文字列を抽出する $ hoge=ABCDEFGHIJ $ echo ${hoge:3} DEFGHIJ $ echo ${hoge:3:4} DEFG offset や length に負の値を指定して、末尾からの位置を示すこともできます。 ただし、その場合、offset の前に 1 つ以上のスペースが必要です（スペースを入れないと、${変数:-word} という形でデフォルト値が指定されたとみなされてしまいます）。 $ hoge=ABCDEFGHIJ $ echo ${hoge: -3} HIJ $ echo ${hoge: -5:-2} FGH"},{url:"/p/9w4ywr2/",title:"Linuxメモ: bash のバージョンを調べる ($BASH_VERSION)",date:"2010-07-20T00:00:00+09:00",body:"Linuxメモ: bash のバージョンを調べる ($BASH_VERSION) 現在使用している bash のバージョンは、$BASH_VERSION 環境変数で参照することができます。 CentOS 5.5 の場合 $ echo $BASH_VERSION 3.2.25(1)-release Ubuntu 12.04 の場合 $ echo $BASH_VERSION 4.2.24(1)-release"},{url:"/p/3qgbv7i/",title:"Linuxメモ: 絶対パスと相対パスの変換 (basename, dirname)",date:"2010-07-20T00:00:00+09:00",body:"Linuxメモ: 絶対パスと相対パスの変換 (basename, dirname) basename - ファイル名だけを抽出する Linux の basename コマンドを使うと、パスを表す文字列からファイル名だけを抽出できます。 $ basename /aaa/bbb/ccc ccc $ basename /aaa/bbb/ccc/ ccc $ basename aaa/bbb/ccc ccc dirname - ディレクトリ、ファイルが格納されているディレクトリのパスを抽出する Linux の dirname コマンドを使うと、ファイルやディレクトリが格納されているディレクトリのパスを抽出できます。 $ dirname /aaa/bbb/ccc /aaa/bbb $ dirname /aaa/bbb/ccc/ /aaa/bbb $ dirname aaa/bbb/ccc aaa/bbb"},{url:"/p/ivbss76/",title:"Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b)",date:"2010-07-19T00:00:00+09:00",body:"Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) git switch -c コマンドを使用すると、ブランチの作成と、そのブランチへの切り替え（チェックアウト）を同時に行うことができます（昔は同様の振る舞いをする git checkout -b コマンドが使っていました）。 ブランチの作成と切り替えを一度に行う $ git switch -c mybranch # ブランチ mybranch の作成＆チェックアウト Switched to a new branch &#39;mybranch&#39; $ git branch # 現在チェックアウトしているブランチの確認 main * mybranch git branch コマンドでのブランチ作成と同様、ブランチ元のブランチ名を指定することもできます。 $ git switch -c mybranch main"},{url:"/p/9bh2ody/",title:"Git でブランチ名を変更する (git branch -m)",date:"2010-07-19T00:00:00+09:00",body:"Git でブランチ名を変更する (git branch -m) Git のブランチ名を変更するには以下のように git branch -m コマンドを使用します。 ブランチ名を変更する $ git branch -m new # 現在チェックアウトしているブランチの名前を new に変更 $ git branch -m old new # old ブランチの名前を new に変更 GitHub などのリモートリポジトリに old リポジトリがすでに push されている場合は、次のようにして中央リポジトリ側のリポジトリ名も変更する必要があります。 GitHub 側のブランチ名を変更する $ git push origin new # 新しいブランチ new を push $ git push origin :old # 古いブランチ old を削除 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)"},{url:"/p/4pad93a/",title:"git config で設定を削除する (config --unset)",date:"2010-07-17T00:00:00+09:00",body:"git config で設定を削除する (config --unset) git config で設定した値を削除したい場合は、以下のように --unset オプションで設定項目を指定します。 例: user.email のローカル設定を削除する $ git config --local --unset user.email 設定のスコープを表すオプション (--local / --global / --system) も同時に指定するようにしてください。 スコープを省略するとデフォルトで local スコープの設定項目の削除になります。 参考: Git 設定のスコープ (local/global/system) を理解する"},{url:"/p/a59xkpd/",title:"Git コマンドのエイリアスを作成する (alias.xxx)",date:"2010-07-17T00:00:00+09:00",body:"Git コマンドのエイリアスを作成する (alias.xxx) 長くて覚えにくい Git コマンドや、頻繁に使用する Git コマンドには、独自のエイリアスを設定しておくと便利です。 例えば、git commit コマンドを git ci というコマンドとして実行できるようにするには、以下のようにエイリアスを登録します。 ci というエイリアスを登録する $ git config --global alias.ci &#34;commit&#34; 通常、エイリアスはグローバル設定 (--global) として設定すると思いますが、そのリポジトリ専用のローカル設定 (--local) として設定するのもありです。 参考: Git 設定のスコープ (local/global/system) を理解する エイリアスの使いすぎは禁物ですが、例えば、Git サブモジュールを扱うためのコマンドは長くなりがちなので、次のような感じでエイリアスを設定しておくと良いかもしれません。 Git サブモジュール用のエイリアス $ git config --global alias.sclone &#39;clone --recurse-submodules&#39; $ git config --global alias.supdate &#39;submodule update --remote --recursive --merge&#39; $ git config --global alias.sdiff &#39;!&#39;&#34;git diff &amp;&amp; git submodule foreach &#39;git diff&#39;&#34; $ git config --global alias.spush &#39;push --recurse-submodules=on-demand&#39; 上記の sclone、supdate、sdiff、spush エイリアスは、サブモジュールまでまとめて clone、update、diff、push するためのエイリアスです。 参考: Git サブモジュールで別リポジトリの内容を組み込む (git submodule)"},{url:"/p/odshtcs/",title:"Git コマンドの出力をカラフルにする (color.ui)",date:"2010-07-17T00:00:00+09:00",body:"Git コマンドの出力をカラフルにする (color.ui) Git コマンドの出力をカラフルにする $ git config --global color.ui &#34;auto&#34; この設定をしておくと、ターミナルから Git コマンド（git log や git diff）を実行したときの出力に色がつくようになります。 特に理由がない限りこの設定をしておくとよいです。 色の設定をより細かく指定する 以下のような感じで、各パートの色や装飾の方法を設定することができます。 $ git config --global color.diff.meta &#34;magenta reverse&#34; 色: normal, black, red, green, yellow, blue, magenta, cyan, white 装飾: bold, dim, ul, blink, reverse どのような項目があるかは、git config のヘルプサイト で確認できます。"},{url:"/p/gr3v7r8/",title:"Git でコミット時に使用するユーザ名とメールアドレスを設定する (user.name, user.email)",date:"2010-07-17T00:00:00+09:00",body:"Git でコミット時に使用するユーザ名とメールアドレスを設定する (user.name, user.email) Git を使い始めるときは、最初に、コミット時に使用されるユーザ名とメールアドレスを設定しておきます。 ユーザー名とメールアドレスの設定 $ git config --global user.name &#34;Your Name&#34; $ git config --global user.email &#34;YourName@example.org&#34; 上記のようにグローバルな設定値として設定した値は、~/.gitconfig に保存され、以下のコマンドで設定内容を確認できます。 グローバル設定の確認 $ git config --global --list user.name=Your Name user.email=YourName@example.org ☝️ 環境変数による設定 git help config によると、上記の 2 つの設定は、環境変数 GIT_AUTHOR_NAME、GIT_AUTHOR_EMAIL でも設定できるとされており、環境変数の値が優先されるようです。"},{url:"/p/6qp26ez/",title:"Git でファイルの変更をステージする（コミットの印をつける）",date:"2010-07-17T00:00:00+09:00",body:"Git でファイルの変更をステージする（コミットの印をつける） 変更をステージする（コミットの印を付ける）とは Git では、git commit を実行する前に、ローカルリポジトリにコミットするファイルを指定しておく必要があります。この作業を 「変更をステージする」 といいます。 変更の内容により、以下のようなコマンドを使い分けます。 git add: 新規ファイルを追加、あるいは、既存ファイルを変更する場合。 git rm: 既存のファイルを削除する場合。 git mv: 既存のファイルの名前を変更、場所を移動する場合。 git add で新規ファイルの追加、既存ファイルの変更をステージする Git では、リポジトリに新しいファイルを格納したい場合と、すでにリポジトリに格納されているファイルの変更を行いたい場合に、共通のコマンドとして git add を使用します。 実際にリポジトリに追加、変更を反映するには、その後で git commit を実行してコミットを行う必要があります。 $ git add aaa.txt $ git commit -m &#34;Add a sample file&#34; ちなみに、バージョン管理システムのひとつである Perforce では、編集用の通知には p4 edit、ファイル追加用の通知には p4 add と、コマンドが分かれています。 Perforce などの別の VCS に慣れている場合に注意しなければいけないのは、Git の変更管理単位はファイルではなく、もっと小さいハンク (Hunk) と呼ばれる変更部分単位だということです。 そして、それらのハンクがコミット対象として Git に伝わるのは git add コマンドを実行したタイミングです。 つまり、git add した後でそのファイルを変更してしまうと、その変更部分はステージされていないということになります。 結果として、そのファイルにはコミット対象の変更部分と、コミット対象ではない変更部分の両方が含まれる少しややこしい状態になります。 慣れないうちは、git add による変更のステージングは、git commit の直前に行うようにしてコミット漏れを防ぐとよいでしょう。 git rm でファイルの削除をステージする 次回のコミット時に、あるファイルをリポジトリから削除したい場合は、git rm コマンドでファイルを指定します。 このコマンドを実行した時点で、作業ツリーからは実際にファイルが削除されますが、git commit を実行するまではリポジトリには反映（コミット）されないことに注意してください。 $ git rm sample.txt $ git commit -m &#34;Remove unnecessary files&#34; git mv でファイルのリネームをステージする 次回のコミット時に、すでにコミットされているファイルの名前を変更したい場合は、git mv コマンドを使用します。 git mv コマンドを実行した時点で、作業ツリー内の実際のファイル名も変更されますが、その後でコミットすることを忘れないようにしてください。 $ git mv AAA.txt BBB.txt $ git commit -m &#34;Rename AAA and BBB&#34;"},{url:"/p/8cwbp3e/",title:"Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout)",date:"2010-07-17T00:00:00+09:00",body:"Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) 作業対象のブランチを切り替えるには、git switch コマンドで切り替え先のブランチ名を指定します（昔は git checkout コマンドが使われていましたが、現在は役割を明確にした git switch コマンドが使われています）。 ブランチを切り替える前に、 git branch コマンドを使用して、現在チェックアウトしているブランチと、切り替え先のブランチ名を確認しておくとよいです。 ブランチの一覧を確認 $ git branch * main my-branch 上記の出力で、現在の作業対象が main であることが分かります。 次のようにすると、作業対象を my-branch ブランチに切り替えることができます。 my-branch ブランチに切り替える $ git switch my-branch Switched to branch &#34;my-branch&#34; 切り替わっていることを確認する $ git branch main * my-branch これで、作業対象のブランチが my-branch に切り替わったので、これ以降の変更作業 (git commit) は、my-branch ブランチだけに反映され、main ブランチには反映されなくなります。"},{url:"/p/x9s8k2e/",title:"Git でブランチを作成する (git branch)",date:"2010-07-17T00:00:00+09:00",body:"Git でブランチを作成する (git branch) 現在チェックアウトしているブランチから、新しいブランチを作成するには次のコマンドを使用します。 $ git branch &lt;新しいブランチ名&gt; ブランチ元のブランチを指定して、新しいブランチを作成するには次のようにします。 $ git branch &lt;新しいブランチ名&gt; &lt;既存のブランチ名&gt; 例: main ブランチから REL-1.0 ブランチを作成する $ git branch REL-1.0 main git branch コマンドを引数なしで実行すると、ブランチの一覧を確認できます（git branch --list と同等）。 $ git branch REL-1.0 * master 上記の例では、今回作成された REL-1.0 と、デフォルトの master ブランチが存在することが分かります。master の前の * は、現在の作業対象（チェックアウトされているブランチ）が master ブランチであることを示しています。 作業対象を新しいブランチに切り替えるには、git switch コマンドを使用する必要があります。 参考: Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) 参考: Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) 参考: Git で他の人が作成したブランチ上で作業する ちなみに、ローカルで新しく作成したブランチの内容を GitHub などの中央リポジトリに git push するには、次のように実行します。 origin リポジトリへ新しいブランチ REL-1.0 を push $ git push origin REL-1.0 このとき、-u (--set-upstream) オプションを付けて実行すると、リモートブランチ名とローカルブランチ名が対応付けられて、次回からはパラメーターなしで git push できるようになります。 git push -u origin REL-1.0"},{url:"/p/stpfje9/",title:"Git でブランチを削除する (git branch -d/-D)",date:"2010-07-17T00:00:00+09:00",body:"Git でブランチを削除する (git branch -d/-D) 不要になったブランチを削除するには、git branch -d コマンドでブランチ名を指定します。 削除対象のブランチが作業対象になっていると削除できないので、先に git switch コマンドで別のブランチに切り替えてから削除を実行します。 mybranch ブランチを削除する $ git switch main $ git branch -d mybranch Deleted branch mybranch (was 1cc229d3) 削除しようとしているブランチの変更内容が、ブランチ元にマージされていない場合、以下のようなエラーが表示されます。 error: The branch &#39;mybranch&#39; is not an ancestor of your current HEAD. If you are sure you want to delete it, run &#39;git branch -D mybranch&#39; この場合は、先にブランチ元にマージを実行するか、あるいは、変更内容が完全に消えても構わない場合は -d オプションの代わりに -D オプションを指定して実行します。 マージされていないブランチを強制的に削除する $ git branch -D mybranch 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)"},{url:"/p/ez3knei/",title:"Git で変更をローカルリポジトリにコミットする",date:"2010-07-17T00:00:00+09:00",body:"Git で変更をローカルリポジトリにコミットする git commit で変更をローカルリポジトリにコミットする git add、git rm、git mv などのコマンドによってステージされたファイル（の変更箇所）は、git commit でローカルリポジトリにコミットされる対象になります。 コミットを行うときは、必ずコミットコメントを記述する必要があります。 コメントは、下記のように -m オプションで指定することができます。 コメントを付けてコミット $ git commit -m &#34;Correct typos&#34; 複数の段落にわたるコメントを付けたい場合は、-m オプションを複数指定します。 複数段落のコメントを付ける $ git commit -m &#34;First paragraph&#34; -m &#34;Long long description.&#34; $ git log commit c7617b4d92edd946ae2a3358c321a2c6c81240b8 Author: test &lt;test@example.org&gt; Date: Sat Jul 17 17:39:57 2010 +0900 First paragraph Long long description. git commit コマンドに -m オプションを指定しなかった場合は、コミットコメントを入力するためにエディタが起動します。 エディタを開いてコミットコメントを入力する $ git commit このとき -v オプションを指定すると、コミットされるファイルの変更差分 (diff) も同時にエディタ上に表示されます。 ただ、一般的には git commit の実行前に git diff --staged で差分確認します。 エディタ上で差分も表示 $ git commit -v git add コマンドなどで変更をステージされていないファイルも、すべてコミットしてしまうには、git commit のオプションで -a を指定します。 ただし、Git の管理下にない（追跡されていない）ファイルはステージの対象になりません。 変更されているファイルをすべてコミット $ git commit -a"},{url:"/p/cqjv7wv/",title:"Git のコミット時にコメント記述に使用するエディタを設定する (core.editor)",date:"2010-07-17T00:00:00+09:00",body:"Git のコミット時にコメント記述に使用するエディタを設定する (core.editor) git commit コマンド実行時に、-m オプションでコメントを入力しなかった場合は、コメント入力のためにエディタが起動します。 ここで起動するエディタは core.editor 設定で自由に変更できます。 操作に慣れた Vim エディタなどを指定しておけば、コミット前の編集画面で操作ミスしてしまうこともなくなるでしょう。 例: エディタを Neovim (nvim) に設定する $ git config --global core.editor nvim 上記の例では、core.editor 設定を使ってエディタの指定を行っていますが、エディタの指定方法はたくさんあり、Git は次の順番で使用するエディタを判断します。 環境変数 GIT_EDITOR Git の core.editor 設定（git config コマンド） 環境変数 VISUAL 環境変数 EDITOR vi（Debian、Ubuntu の場合は editor） どれで設定しても良いですけど、基本的には他の設定項目と一緒に git config コマンドで設定してしまうのがシンプルです。"},{url:"/p/muhmimi/",title:"Git の作業ツリーを作成する (git init, git clone)",date:"2010-07-17T00:00:00+09:00",body:"Git の作業ツリーを作成する (git init, git clone) Git の作業ツリーの作成方法は２つ Git の作業ツリーを作成するには、以下の 2 種類の方法があります。 git init &hellip; 新しくローカルリポジトリを作成します。 git clone &hellip; リモートの Git リポジトリをコピーしてきて、作業ディレクトリとローカルリポジトリを作成します。 git init で新しく作業ツリーを作成する 完全に新規の作業ツリーを作成する場合と、既存のファイル群を Git で管理する場合は、git init コマンドを使用して、あるディレクトリ以下を Git の管理下に置きます。 $ mkdir myproject $ cd myproject $ git init Initialized empty Git repository in /home/john/myproject/.git この git init コマンドにより、カレントディレクトリに .git という Git の管理ディレクトリが作成され、カレントディレクトリ以下が Git の管理対象に入ります。 この時点ではローカルリポジトリの中は空っぽなので、このディレクトリ（作業ツリー）内でファイルを作成し、git add や git commit コマンドなどを使用してリポジトリにファイルをコミットしていきます。 既にソースコードの入っているディレクトリを Git で管理する場合も、まずは上記と同様の手順でリポジトリ (.git) を作成します。 ただし、git init しただけでは、既存のファイルはリポジトリの管理下に入らないので、以下のように既存のファイル群をコミットしてやる必要があります。 $ cd myproject $ git init $ git add . $ git commit -m &#34;First commit.&#34; コミットの履歴は git log で確認できます。 git clone で別のマシンのリポジトリから作業ツリーを作成する（コードをコピーしてくる） 例: Android のコードを取得してみる $ cd ~/gitwork $ git clone git://android.git.kernel.org/platform/development.git Initialized empty Git repository in /home/john/gitwork/development/.git got 36a38df99cd7485db6a83c4f8c7b329c24b9b6e8 ... 上記のようにすると、カレントディレクトリに development ディレクトリがローカルにコピーされます。 development ディレクトリは作業ツリーであり、そのルートに更新履歴を示すリポジトリのコアとなる .git ディレクトリも入っています。 git clone を実行しようとして以下のようなエラーが出る場合、git プロトコルの代わりに http プロトコルを指定するとうまく取得できたりします。 Initialized empty Git repository in /home/john/gitwork/development/.git fatal: Unable to look up android.git.kernel.org (port 9418) (Name or service not known)"},{url:"/p/f844tkg/",title:"Git 用語集",date:"2010-07-17T00:00:00+09:00",body:"Git 用語集 作業ツリー、ワークツリー (work tree) Git の管理下に入ったローカルのディレクトリツリーを 作業ツリー (work tree) と呼びます。 リポジトリに記録された内容を作業ツリーに展開する操作を チェックアウト (checkout) と呼びます。 git init コマンドなどで作成される .git/ ディレクトリが存在するディレクトリが、作業ツリーのルートになります。 Subversion や CVS では「作業コピー」と呼んでいました。 リポジトリ (repository) 変更履歴などを管理するリポジトリで、Git では必ずローカルディレクトリに存在します。 他のマシン上にあるリポジトリも、ローカルにあるリポジトリも対等の関係にあり、各リポジトリにコミットされた変更内容を互いにやりとりすることでプロジェクト全体の変更の一貫性を保ちます。 一般的には、ある一つのマシンのリポジトリを中央リポジトリとし、そこから最終的なプロジェクトの成果物を生成します。 リポジトリの実体は、作業ツリーのルートにある .git/ ディレクトリです。 ステージする (stage) あるファイルを次回のコミット対象に含めることを、ファイルを ステージする (stage) といいます。 Perforce を使ったことがある人は、p4 edit などによる Perforce サーバへの変更通知と近い概念なので分かりやすいと思います。 Git では、git add や git rm コマンドでファイルを指定すると、その情報が Git のインデックス情報として登録され、次回のコミット対象となります。 ハンク (hunk) ファイル内の連続した変更箇所のこと。 1 つのファイル内に連続した変更箇所が複数あれば、ハンクも複数存在することになります。 Git ではファイル単位で変更を追跡するのではなく、もっと細かいハンク単位で追跡します。 つまり、ファイル内の変更の一部だけをコミットするという作業が行えます。 チェックアウト (checkout) リポジトリに格納されたあるリビジョンの内容を作業ツリーに展開し、ローカルファイルとして見えるようにすることを チェックアウトする (checkout) と言います。 また、チェックアウトされているブランチとは、現在の作業ツリーに反映されているブランチのことで、作業対象になっているブランチのことをいいます。 main ブランチ / master ブランチ git init した後の初期状態で何かファイルをコミットすると、デフォルトで main というブランチが作成され、チェックアウトされた状態になります。 昔は master という名前が使われていましたが、アメリカの BLM 運動をきっかけに差別的で不適切な用語とされ main という名前に置き換えられました。 オブジェクトデータベース (object database) Git プロジェクトのデータベース（オブジェクトデータベース）には、オブジェクト (object) という統一形式でデータが保存されています。 ファイルを表すブロブオブジェクト、ディレクトリを表すツリーオブジェクト、コミットを表すコミットオブジェクトなどが格納されます。 オブジェクトデータベースの実体は、作業ツリーにある .git/objects/ ディレクトリです。 ブロブオブジェクト (blob object) ブロブオブジェクト は、Git で 1 つのファイルの内容を表現するオブジェクトで、オブジェクトデータベースで管理されます。 ツリーオブジェクト (tree object) ツリーオブジェクト は、Git で 1 つのディレクトリの内容を表現するオブジェクトで、オブジェクトデータベースで管理されます。 ツリーオブジェクトには、ディレクトリ内のファイルやディレクトリのパス情報とオブジェクト ID が含まれています。 コミットオブジェクト (commit object) コミットオブジェクト は、Git で 1 つのコミットの内容を表現するためのオブジェクトで、オブジェクトデータベースで管理されます。 コミットオブジェクトには、author（著者）、committer（記録者）、タイムスタンプ、コメントなどの情報が含まれています。"},{url:"/p/z26xvc9/",title:"コミット対象になっているファイルを確認する (git status)",date:"2010-07-17T00:00:00+09:00",body:"コミット対象になっているファイルを確認する (git status) git status コマンドを使用すると、次回のコミットの対象になっているファイルや、コミットの対象にはなっていないけれど編集されているファイルなどを確認することができます。 出力は大体以下のような感じになります。 $ git status On branch main Your branch is up to date with &#39;origin/main&#39;. Changes to be committed: (use &#34;git restore --staged &lt;file&gt;...&#34; to unstage) new file: aaa.txt new file: bbb.txt modified: ccc.txt Changes not staged for commit: (use &#34;git add &lt;file&gt;...&#34; to update what will be committed) (use &#34;git restore &lt;file&gt;...&#34; to discard changes in working directory) modified: ddd.txt midified: eee.txt deleted: fff.txt Untracked files: (use &#34;git add &lt;file&gt;...&#34; to include in what will be committed) ggg.txt hhh.txt iii.txt 3 つのセクションに分けてファイルが表示されますが、それぞれ下記のような意味を持っています。 Changed to be committed 次回の git commit コマンドでローカルリポジトリにコミットされるファイルの一覧です。 新しくローカルリポジトリに追加されるファイル (new file)、変更されるファイル（modified)、削除されるファイル (deleted) などの情報も示されます。 カラー出力設定してある場合、ファイル名は緑色で表示されます。 Changed not staged for commit ローカルリポジトリの最新と比べてファイルが更新されているが、ステージ (git add) されておらず、コミットの対象になっていないファイルの一覧です。 git add することでコミットの対象になり、次回のコミットでローカルリポジトリに変更が反映されます。 カラー出力設定してある場合、ファイル名は赤色で表示されます。 Untracked files Git の管理対象になっていないファイルの一覧です。 例えば、新しく作成したファイルやディレクトリがここに表示されます。 git add することでコミットの対象になり、次回のコミットで new file としてローカルリポジトリに追加されます。 カラー出力設定してある場合、ファイル名は赤色で表示されます。"},{url:"/p/vjcad5m/",title:"Androidメモ: Androidの特殊ディレクトリの情報を取得する (android.os.Environment)",date:"2010-06-15T00:00:00+09:00",body:"Androidメモ: Androidの特殊ディレクトリの情報を取得する (android.os.Environment) Android の特殊ディレクトリの情報を取得するには、android.os.Environment クラスを使用します。 以下は、いくつかの主要なディレクトリのパスを取得する方法です。 java.io.File dataDir = android.os.Environment.getDataDirectory(); java.io.File downloadDir = android.os.Environment.getDownloadCacheDirectory(); java.io.File storageDir = android.os.Environment.getExternalStorageDirectory(); java.io.File rootDir = android.os.Environment.getRootDirectory(); Log.d(TAG, dataDir.getAbsolutePath()); // &#34;/data&#34; Log.d(TAG, downloadDir.getAbsolutePath()); // &#34;/cache&#34; Log.d(TAG, storageDir.getAbsolutePath()); // &#34;/sdcard&#34; Log.d(TAG, rootDir.getAbsolutePath()); // &#34;/system&#34;"},{url:"/p/xi5sjju/",title:"Linuxシェルスクリプト: ある外部コマンドが使用できるかチェックする",date:"2010-06-13T00:00:00+09:00",body:"Linuxシェルスクリプト: ある外部コマンドが使用できるかチェックする シェルスクリプトの中で特定の外部コマンドを使用する必要がある場合、先頭部分でその外部コマンドが使用できる状態かどうかを調べておくと親切です。 例えば、次のようにすれば、ruby コマンドが使用できるかを確認できます。 sample.sh if type -P ruby &gt; /dev/null; then echo &#39;ruby コマンドを使用できます&#39; else echo &#39;ruby コマンドが見つかりません&#39; fi ☝️ type -P コマンド type -P ruby コマンドは、パスの通ったディレクトリから ruby を検索してそのパスを取得するためのものですが、ここでは ruby コマンドが使用できる環境になっているかを確認するために利用しています。 単純に実行すると、検索結果のパスが出力されてしまうので、null デバイスへリダイレクトして出力を抑制しています。 特定のコマンドが使用できない場合にスクリプトを終了させるには、以下のように記述すればよいでしょう。 条件式を ! で反転させていることに注意してください。 if ! type -P ruby &gt; /dev/null; then echo &#39;This script requires Ruby. Please install Ruby first and try again.&#39; &gt;&amp;2 exit -1 fi # 処理を継続"},{url:"/p/r3myewb/",title:"Linuxシェルスクリプト: ある環境変数が定義されているかチェックする (test -z)",date:"2010-06-13T00:00:00+09:00",body:"Linuxシェルスクリプト: ある環境変数が定義されているかチェックする (test -z) 環境変数がセットされているかを確認する 下記の例では、SRC_ROOT という環境変数が設定されているかを調べ、設定されていない場合はメッセージを表示して終了しています。 sample.sh #!/bin/bash if [ -z &#34;$SRC_ROOT&#34; ]; then echo &#39;Please set the &#34;SRC_ROOT&#34; environment variable and try again.&#39; &gt;&amp;2 exit -1 fi echo &#39;Program continues...&#39; -z は、指定された変数の文字列長が 0 であるかを調べるオプションです。 SRC_ROOT 変数にスペースを含む文字列が設定されている場合に備えて、&quot;$SRC_ROOT&quot; のようにダブルクォートで囲むことをお勧めします。 ☝️ ワンポイント echo の出力を &gt;&amp;2 とリダイレクトすると標準エラー出力へ出力できます。 実行例 $ ./sample.sh Please set the &#34;SRC_ROOT&#34; environment variable and try again. $ SRC_ROOT=/Users/maku/src ./sample.sh Program continues... （おまけ）test コマンドについて if [ -z &#34;$SRC_ROOT&#34; ]; then という条件判定は、次のように test コマンドを使うのと同等です。 if test -z &#34;$SRC_ROOT&#34;; then test -z コマンドは、指定された変数値の文字列長が 0 かどうかを確認するコマンドです。 これを利用して、上記のように 特定の変数値がセットされていない ことを調べることができます。 ちなみに、[ は特殊な記号のように見えますが、実質は test コマンドのエイリアスなので、前後にスペースが必要なことに注意してください。"},{url:"/p/4tbzpyf/",title:"Linuxシェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#)",date:"2010-06-13T00:00:00+09:00",body:"Linuxシェルスクリプト: コマンドライン引数の数が正しいかチェックする ($#) 関連記事: Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*) コマンドライン引数が足りないときに Usage 出力して終了する シェルスクリプト起動時に渡されたコマンドライン引数の数は、$# 変数で取得することができます。 シェルスクリプトが最低 2 つのパラメーターを必要としている場合は、先頭部分で下記のようなチェックをするのがよいでしょう。 例: 2 つ以上のパラメーターが必要 #!/bin/bash if [ $# -lt 2 ]; then echo &#34;Usage: $(basename $0) &lt;file1&gt; &lt;file2&gt;&#34; &gt;&amp;2 exit -1 fi # 処理を継続 下記はバリエーションです。 例: 1 つ以上のパラメーターが必要 #!/bin/bash if [ ! &#34;$1&#34; ]; then echo &#34;Usage: $(basename $0) &lt;file&gt;&#34; &gt;&amp;2 exit -1 fi # 処理を継続 例: 1 つの引数が必要で、かつ、その名前のファイルが存在する #!/bin/bash if [ ! &#34;$1&#34; ]; then echo &#34;Usage: $(basename $0) &lt;file&gt;&#34; &gt;&amp;2 exit -1 fi if [ ! -f &#34;$1&#34; ]; then echo &#34;$1 is not found&#34; &gt;&amp;2 exit -1 fi # 処理を継続 コマンドライン引数が指定されていないときにデフォルト値を使用する 1 番目のコマンドライン引数を参照するときに ${1:-XXX} とすると、引数を省略したときに XXX というデフォルト値が返されます。 例えば、次の例では、コマンドライン引数で「出力先ディレクトリ」を指定できるようにしていますが、省略した場合のデフォルトとして out ディレクトリを使用するようにしています。 sample.sh #!/bin/bash out_dir=${1:-out} echo out_dir: $out_dir 実行例 $ ./sample.sh foo out_dir: foo $ ./sample.sh foo bar out_dir: foo $ ./sample.sh &#34;foo bar&#34; out_dir: foo bar $ ./sample.sh out_dir: out $ ./sample.sh &#34;&#34; out_dir: out"},{url:"/p/3cukwcu/",title:"Linuxメモ: シェルスクリプト: 数値変数を加算／減算する",date:"2010-06-13T00:00:00+09:00",body:"Linuxメモ: シェルスクリプト: 数値変数を加算／減算する 数値変数 val の値に対して加算／減算を行うには下記のようにします。 val=100 let val=$val+200 echo $val あるいは、下記のように記述することもできます。 val=100 val=$(($val+200)) echo $val 実行結果 300"},{url:"/p/5at33s8/",title:"Androidベンダー向けメモ: ART/Dalvik VM のバージョンを調べる (dalvikvm -showversion)",date:"2010-06-01T00:00:00+09:00",body:"Androidベンダー向けメモ: ART/Dalvik VM のバージョンを調べる (dalvikvm -showversion) Android デバイスの VM のバージョンは dalvikvm コマンドで調べることができます。 $ adb shell # dalvikvm -showversion DalvikVM version 1.1.0 ART を使用している場合は、下記のような感じで表示されます。 # dalvikvm -showversion ART version 2.1.0"},{url:"/p/odgqrwa/",title:"Linuxメモ: Linux カーネル／OS のバージョンを調べる",date:"2010-06-01T00:00:00+09:00",body:"Linuxメモ: Linux カーネル／OS のバージョンを調べる Linux カーネルのバージョンを調べる $ cat /proc/version $ uname -a Linux OS のバージョンを調べる Ubuntu の場合 $ cat /etc/lsb-release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=13.10 DISTRIB_CODENAME=saucy DISTRIB_DESCRIPTION=&#34;Ubuntu 13.10&#34; $ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 13.10 Release: 13.10 Codename: saucy Debian の場合 $ cat /etc/debian_version 5.0 CentOS（RedHat系）の場合 $ cat /etc/redhat-release CentOS release 5.5 (Final) Fedora の場合 $ cat /etc/fedora-release Fedora release 9 (Sulphur)"},{url:"/p/d7dho89/",title:"Androidメモ: SharedPreferences でアプリの設定値を保存する",date:"2010-05-29T00:00:00+09:00",body:"Androidメモ: SharedPreferences でアプリの設定値を保存する SharedPreferences とは SharedPreferences は、キー＆バリューの組み合わせをファイル（不揮発メモリ）に保存する仕組みで、アプリ内で使用する設定情報などを保存するのに使用できます。 設定値は XML ファイルの形で保存されるのですが、ファイル操作に関する処理は隠ぺいされているので、アプリの設計者はキー＆バリューの取り扱いのみに集中して実装することができます。 アプリ内のコンポーネント間で、キー＆バリューのデータをやりとりする場合にも使用できます。 SharedPreferences には下記のようなタイプの値を保存することができます。 boolean string int long float 逆にもっと複雑なデータを保存したいときは、SharedPreferences ではなく、別の方法（通常のファイル I/O など）で永続化する必要があります。 SharedPreferences による値を書き込む キー＆バリューのペアを扱う SharedPreferences オブジェクトを生成するには、以下のように Context#getSharedPreferences() メソッドを使用します。 このとき第 1 パラメータで指定した名前が XML ファイルの名前に使用されます（拡張子 .xml は省略して指定します）。 第 2 パラメータには、Android 7.0 (API level24) 以降では Context.MODE_PRIVATE しか指定できません。 SharedPreferences pref = context.getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE); SharedPreferences の値の編集を編集したいときは、edit() メソッドを使って SharedPreferences.Editor オブジェクトを取得する必要があります。 値の編集が終わったら、最後に Editor#commit() メソッドを呼び出すことで SharedPreferences に変更が反映されます。 このメソッドを呼び出し忘れると何も保存されないので注意してください。 commit() の呼び出しが面倒に感じるかもしれませんが、このような仕組みになっているおかげで、変更内容を一括で（アトミックに）反映することができ、効率的なファイルへの書き込みやイベント通知を行えるようになっています。 SharedPreferences に値を書き込む（Java） // import android.content.SharedPreferences; SharedPreferences pref = context.getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = pref.edit(); editor.putString(&#34;stringValue&#34;, &#34;ほげ&#34;); editor.putBoolean(&#34;booleanValue&#34;, true); editor.putInt(&#34;intValue&#34;, 100); editor.commit(); SharedPreferences に値を書き込む（Kotlin） getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE).edit().apply { putString(&#34;stringValue&#34;, &#34;ほげ&#34;) putBoolean(&#34;booleanValue&#34;, true) putInt(&#34;intValue&#34;, 100) commit() } アプリのパッケージ名が com.example.hello だとすると、上記のような SharedPreferences 設定は下記のようなファイルとして保存されます。 /data/data/com.example.hello/shared_prefs/my_settings.xml &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt; &lt;map&gt; &lt;string name=&#34;stringValue&#34;&gt;ほげ&lt;/string&gt; &lt;int name=&#34;intValue&#34; value=&#34;100&#34; /&gt; &lt;boolean name=&#34;booleanValue&#34; value=&#34;true&#34; /&gt; &lt;/map&gt; SharedPreferences から値を読み出す 保存された SharedPreferences の値を読み出すには次のようにします。 指定したキーが存在しない場合には、第 2 引数で指定したデフォルト値が返されます。 SharedPreferences から値を読み出す（Java） SharedPreferences pref = context.getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE); String stringValue = pref.getString(&#34;stringValue&#34;, &#34;&#34;); boolean booleanValue = pref.getBoolean(&#34;booleanValue&#34;, false); int intValue = pref.getInt(&#34;intValue&#34;, 0); SharedPreferences から値を読み出す（Kotlin） val pref = getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE) val stringValue = pref.getString(&#34;stringValue&#34;, &#34;&#34;) val booleanValue = pref.getBoolean(&#34;booleanValue&#34;, false) val intValue = pref.getInt(&#34;intValue&#34;, 0) 値の編集は行わないので、SharedPreferences.Editor オブジェクトを生成する必要はないところがポイントです。 SharedPreferences の値を削除する SharedPreferences にすでに保存されているキー＆バリューを削除するには、SharedPreferences.Editor の remove(key) メソッドを使用します。 この場合も、最後に commit() が必要なことに注意してください。 SharedPreferences の値を削除する（Java） SharedPreferences pref = context.getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = pref.edit(); editor.remove(&#34;stringValue&#34;); editor.remove(&#34;booleanValue&#34;); editor.remove(&#34;intValue&#34;); editor.commit(); SharedPreferences の値を削除する（Kotlin） getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE).edit().apply { remove(&#34;stringValue&#34;) remove(&#34;booleanValue&#34;) remove(&#34;intValue&#34;) commit() } キー名を指定せずに、すべてのキー＆バリューを削除するには、Editor#clear() メソッドを使用します。 getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE).edit().apply { clear() commit() } アプリ全体、Activity 単位で使用する SharedPreferences 上記では、Context#getSharedPreferences() メソッドを使って SharedPreferences オブジェクトを作成していましたが、他にも、アプリ全体用、Activity 用に SharedPreferences オブジェクトを作成するメソッドが用意されています。 それぞれ、作成される XML ファイルのパスが変わってきます。 ファイル名指定（解説済みのはこれ） API: Context#getSharedPreferences(&quot;sample&quot;, Context.MODE_PRIVATE) ファイルパス: /data/data/&lt;package名&gt;/shared_prefs/sample.xml 指定したファイル名の単位で SharedPreferences を作成します。用途別に設定ファイルを分けて管理することができます。 アプリ用（デフォルト SharedPreferences） API: PreferenceManager.getDefaultSharedPreferences(context) ファイルパス: /data/data/&lt;package名&gt;/shared_prefs/&lt;pacakge名&gt;_preferences.xml アプリ全体で使用する SharedPreferences を作成します。アプリ全体で 1 つのファイルが使用されます。Preference フレームワークを使って設定画面を作成 した場合も、このデフォルトの SharedPreferences ファイルが使用されます。 Activity 用 API: Activity#getPreferences(Context.MODE_PRIVATE) ファイルパス: /data/data/&lt;package名&gt;/shared_prefs/&lt;Activity名&gt;.xml Activity ごとに専用の SharedPreferences を作成します。その Activity の設定のために使用します。 ☝️ デフォルトの SharedPreferences ファイルだけで十分？ SharedPreferences の保存先 XML は、ファイル名を指定できる Context#getSharedPreferences(String, int) のバージョンを使用すれば切り替えることができますが、多くのアプリケーションでは PreferenceManager.getDefaultSharedPreferences(Context) によるデフォルトの SharedPreferences ファイルを使えば十分だったりします。 というのも、設定項目のキー名を工夫すればある程度の数の設定項目はうまく階層化して管理できるからです。 例えば、デバッグ用の設定項目を debug.notification のようなキー名にしておけば、他の重要な設定項目と混ざってしまうことはありません。 Google の Settings Design Guidelines では、同一の設定項目を、異なる設定画面で表示するというデザインパターンが提示されています。 In some cases, it may be helpful to duplicate an individual setting on two different screens. Different situations can trigger users to change a setting, so including the setting in multiple places will help users find this item. このようなケースにおいても、設定ファイルが分かれていない方が都合がよいです。 また、Android は 設定画面を作成する ために PreferenceFragmentCompat クラスを提供していますが、このクラスも内部では、デフォルトの SharedPreferences ファイルを使用することを前提にした作りになっています。 SharedPreferences オブジェクトの変更を監視する リスナーの登録 SharedPreferences オブジェクトに SharedPreferences.OnSharedPreferencesChangeListener を登録すると、値の変更を監視することができます。 まずは、値の変更を監視したい任意のクラスでこのリスナーを実装します。 class MainActivity : FragmentActivity(R.layout.activity_main), SharedPreferences.OnSharedPreferenceChangeListener { ... override fun onSharedPreferenceChanged(pref: SharedPreferences?, key: String?) { if (key == &#34;user_name&#34;) { val value = pref?.getString(key, &#34;&#34;) Toast.makeText(this, &#34;key &#39;$key&#39; is changed: $value&#34;, Toast.LENGTH_LONG).show() } } } あとは、SharedPreferences オブジェクトの registerOnSharedPreferenceChangeListener を使ってリスナーを登録するだけです。 val pref = getSharedPreferences(&#34;my_settings&#34;, Context.MODE_PRIVATE) pref.registerOnSharedPreferenceChangeListener(this) 設定画面での変更をまとめて受け取る onSharedPreferenceChanged は、設定画面でひとつの設定値を変更する度に呼び出されます。 設定画面を閉じてからまとめて変更値を取得したい場合は、設定画面の Activity を startActivityForResult() で開き、画面を閉じたタイミング (onActivityResult) で SharedPreferences から情報を取得するとよいでしょう。 とはいえ、世の中的には「設定変更は項目ごとに直ちに反映」が主流になっているようです。"},{url:"/p/mfcba2q/",title:"Vim/Neovim で大文字と小文字を区別しないで検索する (ignorecase)",date:"2010-05-18T00:00:00+09:00",body:"Vim/Neovim で大文字と小文字を区別しないで検索する (ignorecase) Vim で / や :vimgrep による検索を行うときに、大文字・小文字を区別するかどうかの設定は下記のように行います（デフォルトでは大文字・小文字を区別します）。 Vim (.vimrc) の場合 :set ignorecase &#34;大文字と小文字を区別しない （ic と省略可能） :set noignorecase &#34;大文字と小文字を区別する （noic と省略可能）（デフォルト） Neovim (init.lua) の場合 vim.opt.ignorecase = true -- 大文字と小文字を区別しない vim.opt.ignorecase = false -- 大文字と小文字を区別する（デフォルト） この設定にかかわらず、検索時に大文字・小文字を区別するかを指定するには、検索パターンの中に \\c や \\C を含めるようにします。 検索時に大文字・小文字を区別を指定 /\\cfoo &#34; 大文字、小文字を区別せずに foo を検索 /\\Cfoo &#34; 大文字、小文字を区別して foo を検索 検索パターン中の \\c と \\C は、先頭で指定する必要はなく、パターン内のどこにあっても構いません。 検索に関する設定方法の詳細は下記を参照してください。 参考: Vim の検索に関する設定 (ignorecase, smartcase, wrapscan, hlsearch, incsearch)"},{url:"/p/n8n3mwo/",title:"Androidベンダー向けメモ: 製品にパッケージングする APK を指定する (PRODUCT_PACKAGES)",date:"2010-05-17T00:00:00+09:00",body:"Androidベンダー向けメモ: 製品にパッケージングする APK を指定する (PRODUCT_PACKAGES) Android でプロダクトごとにインストールする APK パッケージは、$(TARGET_PRODUCT).mk の PRODUCT_PACKAGES 変数で指定します。 PRODUCT_PACKAGES := \\ AlarmClock \\ AlarmProvider \\ Bluetooth \\ ... 上記は、build/target/product/generic.mk から抜粋しています。"},{url:"/p/4yw4wwr/",title:"Androidベンダー向けメモ: システムプロパティのあれこれ",date:"2010-05-08T00:00:00+09:00",body:"Androidベンダー向けメモ: システムプロパティのあれこれ システムプロパティの定義方法 ビルド時に埋め込む方法 プロダクトごとの Makefile（your_product.mk など） に、以下のように記述しておくと、ビルド時に build.prop に追加されます。 PRODUCT_PROPERTY_OVERRIDES += \\ persist.sys.timezone = Asia/Tokyo イメージのビルド後にプロパティファイルをいじる方法 default.prop に以下のような感じで追加すると、デバイス起動時にシステムプロパティとして設定されます。 persist.sys.timezone=Asia/Tokyo システム起動時の init の中で設定する init.rc あるいは、プロダクトごとの init ファイルに、以下のような感じで追加しておくことができます。 setprop persist.sys.timezone Asia/Tokyo Android デバイス起動時にシステムプロパティが設定される流れ init process が以下からプロパティをロードする /default.prop /system/build.prop /system/default.prop /data/local.prop システムプロパティ情報を提供するための unix domain socket server が作成される。 socket のパスは /dev/socket/property_service で、サイズは環境変数の ANDROID_PROPERTY_WORKSPACE で取得する。 Bionic libc のライブラリ libcutils がこの shared memory に対してシステムプロパティを読み書きするインタフェースを提供する。 システムプロパティの get/set from C/C++ native code Bionic libc の libcutils をリンクし、cutils/properties.h を include して、以下の関数を使用します。 int property_get(const char *key, char *value, const char *default_value); int property_set(const char *key, const char *value); int property_list(void (*propfn)(const char *key, const char *value, void *cookie), void *cookie); 使い方はこんな感じ。 #include &#34;utils/properties.h&#34; char value[PROPERTY_VALUE_MAX]; if (property_get(&#34;ro.hardware&#34;, value, &#34;&#34;) &gt; 0) { if (strcmp(value, &#34;hoge&#34;) == 0) { // ... } } from Java code android.os.SystemProperties の下記のメソッドを使用します。 public static String get(String key, String def) public static int getInt(String key, int def) public static long getLong(String key, long def) public static boolean getBoolean(String key, boolean def) public static void set(String key, String val) これは Android platform で使われているプライベートなクラスなので、Android アプリからは通常使用しません（internal usage only とされていますが、internal usage が何のことを言っているのかが曖昧です）。 SystemProperties は JNI を使って、libcutils のネイティブコードを叩いています。 通常 get 操作はできますが、set 操作は UID が適切にセットされていないとできないっぽいです（2016-03-16 追記: 現状これらは hide API 扱いなので、いずれも通常のアプリケーションからは使用できません）。 似たようなものに、通常の J2SE アプリケーションで使用可能な java.lang.System クラスの getProperty() 系 API がありますが、この API で取得するプロパティは VM に関するプロパティであり、情報が異なります。 from shell (script) Bionic libc の libcutils に、コマンドラインツールとして以下のコマンドが用意されています。これらは shell スクリプトからも実行可能です。 getprop &hellip; 例: getprop com.example.key setprop &hellip; 例: setprop com.example.key value"},{url:"/p/asryvzc/",title:"Logcat のログ出力をフィルタする",date:"2010-04-19T00:00:00+09:00",body:"Logcat のログ出力をフィルタする Android の logcat ログの出力は、出力のレベルでフィルタリングしたり、Log.d() メソッドなどの第一引数で指定したタグでフィルタリングできるようになっています。 adb logcat コマンドでのフィルタ方法 logcat コマンドによるログのフィルタリングでは、priority として V/D/I/W/E/F/S のいずれかを指定できます 例えば、W を指定した場合は、Warning レベル以上のログ (W/E/F/S) のみが表示されるようになります。 $ adb logcat *:W # Warning 以上のログだけ表示 $ adb logcat -s Tag1:* # Tag1 タグのログだけを表示 $ adb logcat *:S Tag1:* # 同上 $ adb logcat -s Tag1:W Tag2:E # Tag1 と Tag2 のログだけを表示 $ adb logcat Tag1:S # Tag1 タグのログを非表示 タグ名でログを絞り込みたい場合は、-s オプションで全てタグのログをデフォルトでオフした上で、任意のタグを指定する必要があります。 そうしないと、指定していないタグに関しては、すべてのレベルのログが出てしまいます。 絞り込みに失敗する例 (Tag1 に関してしかレベル制御されない） $ adb logcat Tag1:W Linux を使っているなら、grep にパイプしまって適当にフィルタリングするのもありです。 正規表現も使えるし、こっちのが実は柔軟性は高いかもしれません。 ただ、このやり方は、ログ受信側でフィルタしているだけなので、Android のシステムがログの出力を抑制しているわけではないことに注意してください。 $ adb logcat | grep HogeHoge おまけ: よく使う方法 下記は私がよく使う方法です。まず、logcat -c でこれまでのログをクリアしておいて、自分のアプリのタグだけのログ表示に絞り込んでいます。 $ adb logcat -c &amp;&amp; adb logcat -s MyApp:* Eclipse の LogCat ウィンドウの場合 Warning 以上のレベルのログだけを表示するには、Eclipse の LogCat ウィンドウの &ldquo;W&rdquo; のボタンを押します。 タグ名でフィルタするには、LogCat ウィンドウの &ldquo;+&rdquo; ボタンを押して、タグ名のフィルタを追加します。"},{url:"/p/4ch6hjg/",title:"Androidメモ: Eclipse から Android SDK を使えるようにする (ADK)",date:"2010-04-11T00:00:00+09:00",body:"Androidメモ: Eclipse から Android SDK を使えるようにする (ADK) Android SDK がインストール済みであることを前提にしています。 Eclipse に Android Development Toolkit (ADK) をインストール Eclipse から Android SDK を使用するには、ADK というプラグインをインストールします。 Eclipse メニューから Help =&gt; Install New Software... と選択。 Work with: の欄に https://dl-ssl.google.com/android/eclipse/ と入力してインストール。 Android SDK のパスを設定 Eclipse のメニューから Window =&gt; Preferences を選択。 Android を選択し、SDK Location に SDK を展開したディレクトリのパスを入力。 （これをやっておかないと、New Android Project のダイアログで Android SDK has not been setup. と出てプロジェクトを作成できません） プロキシ設定 プロキシ環境にいる場合は、Window =&gt; Preferences =&gt; General =&gt; Network Connections から設定します。 プロキシを設定してもダメな場合は、以下のようなことを試すとうまくいくかもしれません。 アドレスを https:// から http:// に変える Eclipse のバージョンを最新にする Android SDK の Package のアップデート Eclipse のメニューから Window =&gt; Android SDK and ADV Manager。 Available Packages を選択し、URL を選択して、Install Selected をクリック。 SDK のアップデート中に fetching&hellip; から進まない場合 プロキシ設定を行う必要があるかもしれません。 Eclipse そのもののプロキシ設定ではなく、Android SDK and AVD Manager ウィンドウの Settings という項目で設定します。 設定例 HTTP Proxy Server: proxy.example.com HTTP Proxy Port: 10080 Eclipse &amp; Android SDK で Hello World Eclipse のメニューから File =&gt; New =&gt; Android Project。 New Android Project ダイアログが出るので適当に入力。 Project name: HelloAndroid Application name: Hello, Android Package name: org.example.hello Create Activity: Hello Run =&gt; Run でエミュレータを起動できる。 トラブルシューティング: An SDK Target must be specified. PC モニタの解像度が低いと、New Android Project の画面で Build Target の欄が選択できず、An SDK Target must be specified. と出て先に進めません。 このような場合は、以下のようにフォントサイズを小さくすればいけるらしいです。 Window / Preferences / General / Appearance / Colours and Fonts Change “Text Font” and “Dialog Font” to a smaller value, dropping from 10 to 8 helped me."},{url:"/p/i9y5wsd/",title:"Vim で Java や C/C++ のコメント記述に便利な formatoptions の設定",date:"2010-01-05T00:00:00+09:00",body:"Vim で Java や C/C++ のコメント記述に便利な formatoptions の設定 Vim で次のように設定しておくと、C 言語などのコメントを記述しているときに、改行を入力するだけで自動的にコメントの途中の記号を挿入してくれるようになります。 :set formatoptions=tcqro 下記、それぞれのオプションの意味です。 t &hellip; （textwidth の値を超える）長いテキスト行を入力した場合に自動で改行する。 c &hellip; （textwidth の値を超える）長いコメント行を入力した場合に自動で改行しコメントリーダーを挿入する。 q &hellip; gq コマンドで選択部分をコメント整形する。 r &hellip; Enter 入力時にコメントリーダーを挿入する。 o &hellip; o あるいは O で行を挿入した場合にコメントリーダーを挿入する。 例えば、Java のコメントを編集中に、 /** * This is a comment line. ここまで入力して改行すると、自動的に以下のように行の先頭にアスタリスクが挿入されます。 これは、formatoptions に r を指定した効果です。 /** * This is a comment line. *"},{url:"/p/3eofc3v/",title:"Linuxメモ: シェルスクリプトを実行したユーザの名前を調べる",date:"2009-12-16T00:00:00+09:00",body:"Linuxメモ: シェルスクリプトを実行したユーザの名前を調べる 下記の例では、シェルスクリプトを実行したユーザが root であるかどうかを調べています。 if [ &#34;$USER&#34; != &#34;root&#34; ]; then echo &#34;Must be executed by root.&#34; exit -1 fi"},{url:"/p/em67j5z/",title:"Linuxメモ: Bash の構文: 関数を定義する／削除する",date:"2009-12-15T00:00:00+09:00",body:"Linuxメモ: Bash の構文: 関数を定義する／削除する 関数定義の基本 Bash では以下のいずれかの構文を利用して、関数を定義することができます。 function funcname { &lt;shell commands...&gt; } funcname() { &lt;shell commands...&gt; } 開き括弧 ({) は、上記のように関数名と同じ行に記述してもよいし、次の行に単独で記述してもよいです。 関数を削除する 定義されている関数を削除するには以下のようにします。 unset -f funcname 現在のログインセッションでどんな関数が定義されているかを調べるには以下のようにします。 $ declare -F # 関数名のみ出力 $ declare -f # 関数の定義も出力 関数と環境変数 関数はスクリプトとは異なり、実行したシェルと同じプロセスで実行されます。 つまり、以下のように関数内で環境変数を設定すれば、関数を呼び出したシェルにも反映されます。 myfunc() { export AAA=100 } 空の関数は syntax error になる 中身が空の関数が定義されていると、構文エラーが発生するようです。 myfunc() { # syntax error } エラーの例 $ ./sample.sh ./sample.sh: 行 3: 予期しないトークン `}&#39; 周辺に構文エラーがあります ./sample.sh: 行 3: `}&#39;"},{url:"/p/w4qm7ok/",title:"Vim/Neovim ですでに入力されているタブをスペースに変換する (:retab)",date:"2009-12-07T00:00:00+09:00",body:"Vim/Neovim ですでに入力されているタブをスペースに変換する (:retab) expandtab オプションが設定されていると、TAB キーを押したときに、タブ文字の代わりに tabstop で設定した数のスペースが挿入されます。 すでに入力されているタブ文字を、スペースに変換するには、expandtab モードを有効にしたうえで、:retab コマンドを実行します。 例: タブ文字を 4 文字分のスペースに置換する :set expandtab :set tabstop=4 :retab 参考 タブ文字の設定 (tabstop, expandtab, softtabstop)"},{url:"/p/pxpgasg/",title:"Vim/Neovim で選択した範囲を自動インデントする (=)",date:"2009-12-07T00:00:00+09:00",body:"Vim/Neovim で選択した範囲を自動インデントする (=) 自動インデントの実行 ソースコードの一部分のインデントが崩れているような場合は、以下のように自動整形することができます。 対象となるコードをビジュアルモードで行選択（Shift-V + 行選択）。 = と入力 自動インデントを整形するときに使用するプログラムを指定する = コマンドで自動インデントを行う場合は、デフォルトでは Vim 内部の整形プログラムが使用されますが、任意のインデント用プログラムを使用するように設定することもできます。 :set equalprg=/usr/local/bin/indent 参考 自動インデントモードを有効にする (autoindent, smartindent, cindent)"},{url:"/p/39fajvt/",title:"Vimの設定: モードラインを使ってファイル単位で書式設定する (modeline)",date:"2009-12-07T00:00:00+09:00",body:"Vimの設定: モードラインを使ってファイル単位で書式設定する (modeline) モードラインとは テキストファイルの先頭か末尾に、モードライン (modeline) という特殊なコメントを埋め込んでおくと、そのファイルにだけ適用する Vim の設定を行うことができます。 複数人でフォーマットを揃えて１つのテキストファイルを編集したい場合などに便利です。 例えば C 言語のソースファイルなら以下のようなコメントを書いておくことで、そのファイルのインデント幅やタブ使用の有無を支持することができます。 /* vim: set shiftwidth=4:tabstop=4:expandtabs */ モードライン (modeline) の機能を有効にするには、以下のように設定しておく必要があります。 ~/.vimrc set modeline &#34;モードラインを有効にする set modelines=5 &#34;上端、下端から何行までをモードラインと認識するか ファイルの先頭や末尾に記述するモードラインは、下記のようなフォーマットで記述します。 &lt;任意のテキスト&gt;&lt;スペース&gt;vim: set ...:&lt;任意のテキスト&gt; 例えば、一行の文字数を 79 文字に制限して自動的に折り返すようにするには、テキストの最終行などに、以下のように記述しておきます。 # vim: set tw=79 fo=aM: 行頭と行末には任意のテキストを入れられるので、C++ のコメントとして以下のように記述することができます。 /* vim: set tw=79 fo=aM: */ モードラインの行末に任意のテキストを追加しなくてよい場合（行末までを Vim の設定値とみなしてよい場合）は、set の記載と、最後の : を省略することができます。 # vim: tw=79 fo=aM モードラインの設定例 例: 79 文字で自動的に折り返す # vim: tw=79 fo=aqwB ai 各オプションの意味は以下のようになっています。 tw=79 (textwidth) &ndash; 一行の文字数を 79 文字（＋改行）に制限 fo=aqwB (formatoptions) a &hellip; テキスト入力するごとに textwidth に設定した文字数で自動折り返し q &hellip; gq コマンドで、選択範囲をフォーマットする w &hellip; 行末にスペースがある場合のみ、自動で行連結しようとする B &hellip; 行を結合したときに日本語の間にはスペースを入れない ai (autoindent) &ndash; 改行するときに自動的に現在の行と同じだけインデントする formatoptions で、a と一緒に m を指定すると、文字挿入時に日本語などのマルチバイト文字でも自動改行するようになりますが、a オプションと相性がよくないので、m は指定しない方がよいです。 例えば、カーソルより後ろの日本語文章が自動改行されると、改行された後ろのテキストに余計なスペースが入ったり、1 文字ごとに改行されてしまったりします。 なので、日本語テキストを整形したい場合は、整形したい領域を選択し、gq で手動整形するのがよいです。 例: メールの下書き用の設定 # vim: tw=76 fo=aqwB ai ts=2 et sw=2 sr 下記は各オプションの概要です。 tw=76 (textwidth) &hellip; 一行の文字数 fo=aqwB (formatoptions) &hellip; 自動改行の設定 ai (autoindent) &hellip; 改行時のオートインデント ts=2 (tabstop) &hellip; タブの半角スペース数 et (expandtab) &hellip; タブを展開 sw=2 (shiftwidth) &hellip; シフト時のスペース数 sr (shiftround) &hellip; シフト時に丸める 日本語を自動整形する場合は、Shift-V で対象範囲を選択して gq と入力します。"},{url:"/p/tmm4zvz/",title:"Linuxメモ: Bash の構文: ループ内での複数の出力をまとめてリダイレクト、パイプ処理する",date:"2009-12-02T00:00:00+09:00",body:"Linuxメモ: Bash の構文: ループ内での複数の出力をまとめてリダイレクト、パイプ処理する コマンドのグルーピング Bash 上で任意のコマンドを実行するときに、 $ (command1; command2; command3) のようにコマンドを括弧 () で囲んでグルーピングすると、リダイレクトなどの効果が全てのコマンドに対して働くようになります。 $ (echo &#39;AAA&#39;; echo &#39;BBB&#39;; echo &#39;CCC&#39;) &gt; output.txt 上記は一行で記述していますが、次のように複数行に分けて記述することもできます。 この場合、各コマンドの末尾にセミコロン (;) は必要ありません。 ( echo &#39;AAA&#39; echo &#39;BBB&#39; echo &#39;CCC&#39; ) &gt; output.txt グルーピングしたコマンドの出力をパイプ処理でつなげていくこともできます。 ( echo &#39;foo&#39; echo &#39;bar&#39; echo &#39;yahoo&#39; echo &#39;foo&#39; ) | sort | uniq 括弧で囲まれたコマンドは子シェルで実行されるので、その中でカレントディレクトリや環境変数などを変更した場合は、コマンド終了時に元に戻ります。 一時的にカレントディレクトリを変更してコマンドを実行したい場合に便利です。 $ pwd /home $ (cd /etc; pwd) /etc $ pwd /home ループ内の出力をリダイレクトする for ループや while ループの中で echo 出力した結果は、done の後ろでリダイレクトするようにすれば、まとめてファイルに出力することができます。 for x in AAA BBB CCC; do echo &#34;$x&#34; echo &#34;......&#34; done &gt; output.txt 出力結果 (output.txt) AAA ...... BBB ...... CCC ...... 上記では &gt; を使用していますが、&gt;&gt; にすれば追記処理に変更することができます。 ループ内の出力をパイプで接続する ループ内の出力結果は、パイプ処理 (|) で別のコマンドにつなげることができます。 for x in CCC AAA DDD EEE BBB; do echo $x done | sort 実行結果 AAA BBB CCC DDD EEE"},{url:"/p/zdxfvct/",title:"Python でモジュールを import する方法のまとめ",date:"2009-11-19T00:00:00+09:00",body:"Python でモジュールを import する方法のまとめ Python でモジュールをインポートする際に使用される import 構文は、複数の指定方法があるため、初めはやや混乱するかもしれません。 以下に、import のさまざまな指定方法をまとめておきます。 Python のモジュールとパッケージの基本については下記の記事を参考にしてください。 Python でモジュールやパッケージを作成する モジュール単位でのインポート まずは基本から。 モジュール名でインポートする方法です。 この方法でモジュールをインポートした場合は、内部の関数などを参照するときは、モジュール名をプレフィックスとして付けます。 mymod モジュールをインポートする import mymod mymod.hello() パッケージ内のモジュールをインポートするときは、次のいずれかの方法で記述しますが、モジュール内のメンバーを参照するときのプレフィックスが変わってきます。 mypkg パッケージ内の mymod モジュールをインポートする # 方法1 import mypkg.mymod mypkg.mymod.hello() # 方法2 from mypkg import mymod mymod.hello() 2 階層以上のパッケージになっても同様です。 # 方法1 import mypkg.sub.mymod mypkg.sub.mymod.hello() # 方法2 from mypkg.sub import mymod mymod.hello() 特定のメンバーのみをインポート from モジュール名 import 関数名 という構文で、モジュール内の特定の関数だけインポートすれば、モジュール名を指定せずにその関数を直接呼び出せるようになります。 mymod モジュールの hello 関数のみをインポートする from mymod import hello hello() パッケージ内のモジュールに関しても同様です。 mypkg パッケージの mymod モジュールの hello 関数のみをインポートする from mypkg.mymod import hello hello() ワイルドカード (*) を使って、モジュール内のすべてのメンバーをインポートできます（ただし、アンダースコア (_) で始まるメンバーはインポートされません）。 mymod モジュールのすべてのメンバーをインポートする from mymod import * hello() 別名を付けてインポート (as) インポートしたモジュールや関数の名前が長すぎると感じたときは、as キーワードを使用して別名を付けることができます。 別名は、名前のコンフリクトを防ぐためにも使用することがあります。 ElementTree モジュールを ET という別名でインポート import xml.etree.ElementTree as ET tree = ET.parse(&#39;books.xml&#39;) いろいろなインポートのパターン 最後にいろいろなインポートの例を載せておきます。 全部理解できれば、たぶんインポートマスターです。 # モジュール mod をインポート import mod # モジュール mod をインポート（hoge で参照） import mod as hoge # モジュール mod1 と mod2 をインポート import mod1, mod2 # モジュール mod 内の関数 func をインポート from mod import func # モジュール mod 内の関数 func1 と func2 をインポート from mod import func1, func2 # モジュール mod 内の全メンバーをインポート from mod import * # パッケージ pkg 内のモジュール mod をインポート（参照時のプレフィックスは pkg.mod） import pkg.mod # パッケージ pkg 内のサブパッケージ sub 内のモジュール mod をインポート（参照時のプレフィックスは pkg.sub.mod） import pkg.sub.mod # パッケージ pkg 内のモジュール mod をインポート（参照時のプレフィックスは mod） from pkg import mod # パッケージ pkg 内のモジュール mod をインポート（参照時のプレフィックスは hoge） from pkg import mod as hoge # パッケージ pkg 内のモジュール mod 内の関数 func をインポート from pkg.mod import func # 相対パスで同じ階層のモジュール mod をインポート from . import mod # 相対パスで同じ階層のモジュール mod 内の関数 func をインポート from .mod import func # 相対パスで 1 つ上のパッケージ階層のモジュール mod をインポート from .. import mod # 相対パスで 1 つ上のパッケージ階層のモジュール mod 内の関数 func をインポート from ..mod import func"},{url:"/p/bfev6xf/",title:"Python でキーボードからのユーザ入力を取得する (input, getpass)",date:"2009-11-18T00:00:00+09:00",body:"Python でキーボードからのユーザ入力を取得する (input, getpass) input 関数と getpass 関数 Python 組み込み関数の input 関数を使用すると、画面上にプロンプトを表示して、キーボードからの入力を促すことができます。 name = input(&#34;Please input your name: &#34;) print(&#34;Hello,&#34;, name) パスワードを入力させるときなど、入力した文字を画面上に表示したくない場合は、input 関数の代わりに、getpass モジュールの getpass 関数を使用します。 from getpass import getpass password = getpass(&#34;Password: &#34;) 使用例: 処理を継続するかの確認 ファイルの削除など、危険なコマンドを実行する前に Are you sure? 的な確認メッセージを表示するサンプルコードです。 ユーザーが y あるいは Y 以外の文字を入力すると、そこで処理を打ち切ります。 confirm.py import sys answer = input(&#34;Are you sure? (y/n): &#34;) if (answer.lower() != &#34;y&#34;): sys.exit(0) print(&#34;処理を継続します&#34;) 実行例 $ python confirm.py Are you sure? (y/n): Y 処理を継続します 使用例: 入力したユーザー名とパスワードのチェック 下記のサンプルコードでは、ユーザに「ユーザ名」と「パスワード」のペアを入力させて、それらがあらかじめ登録されたペアと一致しているかをチェックしています。 password.py from getpass import getpass user_db = ( (&#34;user1&#34;, &#34;password1&#34;), (&#34;user2&#34;, &#34;password2&#34;), (&#34;user3&#34;, &#34;password3&#34;), ) user = input(&#34;User: &#34;) pw = getpass(&#34;Password: &#34;) if (user, pw) in user_db: print(&#34;Access granted&#34;) else: print(&#34;Access denied&#34;) 実行例 $ python password.py User: user1 Password:（password1 と入力） Access granted"},{url:"/p/sxouvi5/",title:"Vim で折りたたみ機能 (folding) を使用する",date:"2009-11-17T00:00:00+09:00",body:"Vim で折りたたみ機能 (folding) を使用する Vim の折りたたみ (folding) 機能を使用すると、特定の行を折りたたんで表示する（一時的に非表示にする）ことができます。 指定した範囲を折り畳む 折りたたみ機能によって、どのような範囲を折りたたむかは、foldmethod というオプションで制御されています。 :set foldmethod=manual （デフォルト） としておくと、任意の選択範囲を折りたたみ領域として扱うことができるようになります。 例: Visual mode で選択した部分を折り畳む 1. Visual mode (Shift-v) で領域選択 2. zf 例: カーソル位置から、指定した文字列が見つかるところまでを折り畳む zf /string 一度 zf コマンドによって折りたたんだ領域は、zo で展開、zc で折りたたみを行えるようになります。 インデント単位で折りたたむ 折りたたみの単位の設定を indent にすると、各種折りたたみコマンドの対象がインデント単位になります。 :set foldmethod=indent 折りたたみ機能に関するコマンド一覧 折りたたみと展開（カーソル位置の要素に対して） zc -- 折りたたみ (Close one fold under the cursor) zo -- 展開（一段階）(Open one fold under the cursor) zO -- 展開（すべて）(Open all folds under the cursor recursively) 折りたたみと展開（ファイル全体の要素に対して） zm -- 折りたたみ（一段階） (Fold more) zM -- 折りたたみ（すべて） (Close all folds) zr -- 展開（一段階） (Reduce folding) zR -- 展開（すべて） (Open all folds) 折りたたみ単位でジャンプ zj -- move to the next fold zk -- move to the previous fold 折りたたみ関連の設定 折りたたみ機能に関する設定は、foldXXXXX という名前のオプションを使って行います。 ~/.vimrc set foldmethod=indent &#34;折りたたみ範囲の判断基準（デフォルト: manual） set foldlevel=2 &#34;ファイルを開いたときにデフォルトで折りたたむレベル set foldcolumn=3 &#34;左端に折りたたみ状態を表示する領域を追加する 折りたたみ領域を決める foldmethod オプションには、下記のような値を設定することができます。 manual &ndash; 自分で範囲選択して折りたたみ indent &ndash; インデント範囲 marker &ndash; {{{ と }}} で囲まれた範囲 expr &ndash; foldexpr による折りたたみレベル指定 syntax &ndash; 現在の syntax に応じた折りたたみ 折りたたみ状態の保存／復帰 折りたたみ状態を保存しておくと、ファイルを閉じて、再度開いたときにその折りたたみ状態に復帰させることができます。 :mkview -- Fold 状態を保存する :loadview -- Fold 状態を復帰する ファイルを閉じるとき、開くときときに、自動的に折りたたみ状態を保存・復帰するには、~/.vimrc に以下のように設定しておきます。 au BufWinLeave * mkview au BufWinEnter * silent loadview 折りたたみ機能（floding 機能）のヘルプ :help fold.txt とすると、折りたたみ機能（Folding機能）についてのヘルプを参照することができます。"},{url:"/p/hk22h6b/",title:"Vim で挿入モード（インサートモード）のまま実行できる操作の一覧",date:"2009-11-11T00:00:00+09:00",body:"Vim で挿入モード（インサートモード）のまま実行できる操作の一覧 挿入モード（インサートモード）でのテキストを編集中は、下記のようなショートカットキーを使用することができます。 CTRL-U &hellip; 挿入モードでの入力をすべて削除 CTRL-W &hellip; カーソル直前の単語を削除 CTRL-V 数値 &hellip; 指定した文字コードの文字を入力（例: CTRL-V 123 → }） CTRL-V Tab &hellip; タブ文字を入力（Tab キーで半角スペースを入力する設定になっていてもタブ文字を入力できる） CTRL-Y &hellip; カーソルの上（上の行）にある 1 文字をコピーして入力 CTRL-E &hellip; カーソルの下（下の行）にある 1 文字をコピーして入力 CTRL-R レジスタ &hellip; 指定したレジスタ内のテキストを挿入（例: CTRL-R * → 直前にヤンクした内容を貼り付け） CTRL-[ &hellip; 挿入モードを抜ける CTRL-O コマンド &hellip; 通常モードのコマンドを一回だけ実行（例: CTRL-O $ → 挿入モードのままカーソルを行末へ移動） CTRL-P &hellip; 入力補完候補の表示（逆方向に選択） CTRL-N &hellip; 入力補完候補の表示（順方向に選択） 挿入モード中にカーソルを移動させるには、カーソルキーを使用します。"},{url:"/p/fweeaqx/",title:"Vim でスペルチェックを有効にする",date:"2009-09-14T00:00:00+09:00",body:"Vim でスペルチェックを有効にする Vim 7.0 からは、組み込みの辞書によるスペルチェッカーが搭載されています。 スペルチェッカーを有効にするには次のようにします。 :set spell スペルチェックに使用する言語を指定するには以下のように指定します。 デフォルトは en (English) です。 :set spelllang=en,da,de,it 複数の言語を指定したい場合は、上記のようにカンマで区切って指定します。 いずれかの言語の辞書に該当する単語が見つかれば、スペルエラーになりません。"},{url:"/p/osrx94g/",title:"Vim/Neovim でカーソル位置の行や列をハイライト表示する (cursorline, cursorcolumn)",date:"2009-09-09T00:00:00+09:00",body:"Vim/Neovim でカーソル位置の行や列をハイライト表示する (cursorline, cursorcolumn) カーソル行／カーソル列のハイライト表示 Vim/Neovim 内で cursorline / cursorcolumn オプションを有効化することで、カーソル行やカーソル列の背景色がハイライトされるようになります。 :set cursorline &#34;カーソル行をハイライト :set cursorcolumn &#34;カーソル列をハイライト 両方とも設定しておくと、ひと目でカーソル位置が分かるようになるのでオススメです。 特に、コーディングで Vim を使っているようなケースでは、列方向のハイライト (cursorcolumn) を有効にしておくと、インデントのずれなどを発見しやすくなります。 背景色を変更したい場合は highlight コマンドで CursorLine と CursorColumn というカラーグループの色を設定します。 :highlight CursorLine guibg=#0000A0 ctermbg=blue :highlight CursorColumn guibg=#0000A0 ctermbg=blue 設定例 Neovim (init.lua) の場合 -- カーソル行／カーソル列を強調表示 vim.opt.cursorline = true vim.opt.cursorcolumn = true -- カーソル行／カーソル列の背景色 vim.api.nvim_set_hl(0, &#34;CursorLine&#34;, { bg = &#34;#0044ee&#34;, ctermbg = &#34;blue&#34; }) vim.api.nvim_set_hl(0, &#34;CursorColumn&#34;, { bg = &#34;#002299&#34;, ctermbg = &#34;blue&#34; }) Vim (.vimrc) / Neovim (init.vim) の場合 &#34; カーソル行／カーソル列を強調表示 set cursorline set cursorcolumn &#34; カーソル行／カーソル列の背景色 highlight CursorLine guibg=#0044ee ctermbg=blue highlight CursorColumn guibg=#002299 ctermbg=blue"},{url:"/p/t8o6tum/",title:"Vim/Neovim で行番号を表示する (number)",date:"2009-09-09T00:00:00+09:00",body:"Vim/Neovim で行番号を表示する (number) 行番号の表示・非表示 Vim/Neovim で各行の行頭に行番号を表示するには、:set number を実行します。 逆に、行番号を非表示にするには、:set nonumber を実行します（デフォルト）。 行番号を表示する :set number &#34; 行番号を表示する :set nonumber &#34; 行番号を表示しない (default) 行番号の背景色や文字色を変更するには highlight (hi) コマンドで、LineNr ハイライト・グループを設定します。 カーソル行の行番号を別の色で表示したいときは、CursorLineNr ハイライト・グループも設定します。 行番号の背景色／文字色を変更する :hi LineNr guifg=#cc2244 guibg=#551100 ctermfg=black ctermbg=gray :hi CursorLineNr guifg=#dd3355 guibg=#771100 ctermfg=black ctermbg=gray 設定例 Vim (.vimrc) / Neovim (init.vim) の場合 &#34; 行番号を表示する set number &#34; 行番号の色 hi LineNr guifg=#cc2244 guibg=#551100 ctermfg=black ctermbg=gray hi CursorLineNr guifg=#dd3355 guibg=#772211 ctermfg=black ctermbg=gray Neovim (init.lua) の場合 -- 行番号を表示する vim.opt.number = true -- 行番号の色 vim.api.nvim_set_hl(0, &#34;LineNr&#34;, { fg = &#34;#cc2244&#34;, bg = &#34;#551100&#34;, ctermfg = &#34;black&#34;, ctermbg = &#34;gray&#34; }) vim.api.nvim_set_hl(0, &#34;CursorLineNr&#34;, { fg = &#34;#dd3355&#34;, bg = &#34;#772211&#34;, ctermfg = &#34;black&#34;, ctermbg = &#34;gray&#34; })"},{url:"/p/5m9eowc/",title:"コメント内で使える特殊キーワード（XXX、TODO など）を理解する",date:"2009-07-29T00:00:00+09:00",body:"コメント内で使える特殊キーワード（XXX、TODO など）を理解する FALLTHROUGH: 次の case へ処理を継続する /* FALLTHROUGH */ は case の終わりで意図的に break しないことを示します。 Lint ツールなどはこのキーワードを検出して、case 漏れ警告を抑制します。 switch (...) { case 1: ... /* FALLTHROUGH */ case 2: ... NOTREACHED: そこへは到達しない /* NOTREACHED */ は、関数の終わりなどに達しないことを示します。 void hoge() { while (...) { ... if (...) { return; } } /* NOTREACHED */ } XXX: 要確認 /* XXX */ は、正しいか分からないが、とりあえず動いていることを示します。 // XXX: このコードがあるとなぜか速度が上がる magic_function(100); FIXME: 修正の必要あり // FIXME: 過去の日付を入力しても落ちないように TODO: 将来拡張予定 // TODO: ヘッダに番組タイトルを表示する"},{url:"/p/j3w2dpc/",title:"Vim で編集中のファイルと拡張子だけが異なるファイルを開く（Hello.cpp を編集中に Hello.h を開く）",date:"2009-07-22T00:00:00+09:00",body:"Vim で編集中のファイルと拡張子だけが異なるファイルを開く（Hello.cpp を編集中に Hello.h を開く） 例えば、現在 Hello.cpp という名前のファイルを編集しているときに、:e[dit] コマンドで Hello.h という拡張子部分だけが異なるファイルを開きたくなったときは、以下のように開くことができます。 :e %&lt;.h %&lt; は、現在編集中の ファイルの名前から拡張子を除いた部分 に置換されます（ちなみに単純に % とすると、ファイル名全体になります）。 次のいずれかの方法で値を確認できます。 :!echo %&lt; :echo expand(&#39;%&lt;&#39;) Hello.cpp というファイルを編集中であれば、%&lt; は Hello となるため、下記 2 つは同じ結果になります。 :e %&lt;.h :e Hello.h この例のようにファイル名が短いときはあまり意味がないかもしれませんが、ファイル名が長いときには便利です。 ここでは :e[dit] コマンドの例を示しましたが、他のコマンドでも % や %&lt; を使ってファイル名を参照することができます。 例: 現在編集中のファイルのファイル名に .back をつけてバックアップ :w %.back"},{url:"/p/uatcsaq/",title:"Python のオブジェクトを print 関数で出力できるようにする (__str__)",date:"2009-06-06T00:00:00+09:00",body:"Python のオブジェクトを print 関数で出力できるようにする (__str__) クラスを定義するときに特殊メソッド __str__ を実装しておくと、print() や str() にそのオブジェクトを渡したときの出力をカスタマイズすることができます。 sample.py class Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return f&#34;Name={self.name}, Age={self.age}&#34; if __name__ == &#34;__main__&#34;: p = Person(&#34;Maku&#34;, 14) print(p) 実行結果 $ python sample.py name=Maku, age=14"},{url:"/p/46b5wxe/",title:"TFTP の使い方（TFTP によるファイル転送）",date:"2009-05-25T00:00:00+09:00",body:"TFTP の使い方（TFTP によるファイル転送） TFTP の特徴 Trivial File Transfer Protocol の略。 https://www.ietf.org/rfc/rfc1350.txt 非常に軽量なので、ブートストラップ用のプロトコルとしてよく使われる。 TFTP クライアントを使ったファイル転送の例 例: ファイル取得 $ tftp 192.168.0.1 get sample.txt Transfer successful: 234 bytes in 1 second, 234 bytes/s 例: ファイル送信 $ tftp 192.168.0.1 put sample.txt Transfer successful: 234 bytes in 1 second, 234 bytes/s 例: バイナリモードで転送したい場合は -i オプション $ tftp -i 192.168.0.1 get sample.data"},{url:"/p/oegfris/",title:"Vim/Neovim でステータスラインの表示内容を設定する (statusline, laststatus)",date:"2009-02-06T00:00:00+09:00",body:"Vim/Neovim でステータスラインの表示内容を設定する (statusline, laststatus) Vim 画面下部のステータスラインには、編集中のファイル名や、カーソル位置の情報などを表示することができます。 ステータスラインのヘルプを表示する :help &#39;statusline&#39; ☝️ ワンポイント オプションに関するヘルプを参照するときは、正式には上記のようにパラメータをシングルクォートで囲んで指定します。ただし、statusline に関してはシングルクォートで囲まなくても同じ項目が表示されます。 ステータスラインに表示する内容を設定する :set laststatus=2 &#34;常に Status Line を表示する :set statusline {format} laststatus オプション laststatus オプションでは、ステータスラインの表示条件を指定します。 laststatus の値: 0 &hellip; ステータスラインを表示しない 1 &hellip; ウィンドウを分割したときにのみステータスラインを表示する（Vimのデフォルト） 2 &hellip; 常にステータスラインを表示する（Neovim のデフォルト） 3 &hellip; 常にステータスラインを表示する。ウィンドウが分割されても 1 つのステータスラインを共有する（Neovim 専用） Neovim では laststatus の新しい設定値として 3（グローバルステータスライン）が追加されており、ウィンドウを分割した場合にもステータスラインが 1 つだけ表示されるようになります。 statusline オプション statusline オプションでは、ステータスラインに表示する内容を指定します。 例えば、下記のようなパラメーター入りの文字列を指定します。 %F%m%h%w\\ %&lt;[ENC=%{&amp;fenc!=&#39;&#39;?&amp;fenc:&amp;enc}]\\ [FMT=%{&amp;ff}]\\ [TYPE=%Y]\\ %=[CODE=0x%02B]\\ [POS=%l/%L(%02v)] % で始まる各パラメータは次のような値に置換されて表示されます（詳細は、Vim のヘルプ :help 'statusline' を参照してください）。 %F &hellip; ファイルのフルパス。 %m &hellip; 編集されているなら [+]。リードオンリーなら [-]。 %h &hellip; Help buffer なら [HELP] と表示。 %w &hellip; Preview window なら [PREVIEW] と表示。 %&lt; &hellip; ウィンドウの横幅が縮まってもここまでは表示することを保証。 %{...} &hellip; 式評価。中に Vimscript の式を記述できる。 %{&amp;fenc!=''?&amp;fecn:&amp;enc} fileencoding が設定されていればその値、設定されていなければ encoding を表示。 %{&amp;ff} fileformat の値を表示。%{&amp;fileformat} の省略形。(dos, unix, mac) %= &hellip; これ以降の内容を右寄せで表示。 %Y &hellip; filetype の値を表示。通常はこれに対応する syntax file が読み込まれているはず。 %02B &hellip; カーソル位置の文字コードを16進数で表示。 %l/%L &hellip; 現在行 / 総行数 %02v &hellip; カーソル位置の桁番号。 設定例 下記は、Vim/Neovim の設定ファイルでの具体的な設定例です。 Vim (.vimrc) / Neovim (init.vim) の場合 set laststatus=2 &#34; 常に Status Line を表示する set statusline=%F%m%h%w\\ %&lt;[ENC=%{&amp;fenc!=&#39;&#39;?&amp;fenc:&amp;enc}]\\ [FMT=%{&amp;ff}]\\ [TYPE=%Y]\\ %=[CODE=0x%02B]\\ [POS=%l/%L(%02v)] Neovim (init.lua) の場合 vim.opt.laststatus = 2 -- 常に Status Line を表示する vim.opt.statusline = [[%F%m%h%w %&lt;[ENC=%{&amp;fenc != &#39;&#39; ? &amp;fenc : &amp;enc}] [FMT=%{&amp;ff}] [TYPE=%Y] %=[CODE=0x%02B] [POS=%l/%L(%02v)]]]"},{url:"/p/preoa93/",title:"Vim/Neovim で全角スペースを見えるように表示する",date:"2009-02-03T00:00:00+09:00",body:"Vim/Neovim で全角スペースを見えるように表示する 全角スペースを表示するための設定 Vim の設定ファイルに下記のように記述しておくと、全角スペースに背景色が付いて判別できるようになります。 ここでは、GVim の場合に背景色として darkgray を指定していますが、好みの背景色に変更して適用してください。 Vim (~/.vimrc) の場合 &#34; Show double byte spaces hi DoubleByteSpace term=underline ctermbg=blue guibg=darkgray match DoubleByteSpace /　/ Neovim (~/.config/nvim/init.lua) の場合 -- Show double byte spaces vim.cmd[[ hi DoubleByteSpace term=underline ctermbg=blue guibg=darkgray match DoubleByteSpace /　/ ]] 参考 制御文字（改行、タブ文字、行末のスペースなど）を表示する (list, listchars)"},{url:"/p/ksmwhv8/",title:"Vim/Neovim のキーマップ例: ショートカットキーでタブを切り替える",date:"2009-02-03T00:00:00+09:00",body:"Vim/Neovim のキーマップ例: ショートカットキーでタブを切り替える Vim で :tabnew を使ってタブを開いた後は、タブの切り替えを :tabnext、:tabprevious を使って行いますが、いちいちこのコマンドを入力するのは面倒なので、ショートカットキーでタブの切り替えを行えるようにしてみます。 ここでは、Ctrl + J か Ctrl + H で前のタブへ移動、Ctrl + K か Ctrl + M で後ろのタブへ移動できるように設定しています。 ブラウザのタブ切り替えのように、Ctrl + TAB や Ctrl + Shift + TAB を割り当てることも可能ですが、これらのキーコンビネーションは端末によっては機能しないことがあります。 Vim の場合 ~/.vimrc &#34; Change the tab nmap &lt;C-Tab&gt; :tabnext&lt;CR&gt; nmap &lt;C-l&gt; :tabnext&lt;CR&gt; nmap &lt;C-k&gt; :tabnext&lt;CR&gt; nmap &lt;C-S-Tab&gt; :tabprevious&lt;CR&gt; nmap &lt;C-j&gt; :tabprevious&lt;CR&gt; nmap &lt;C-h&gt; :tabprevious&lt;CR&gt; ちなみに、nmap ではノーマルモード用のキーマップ設定を行います。 インサートモードでも同様にタブ切り替えを行えるようにするには、下記のように追加で imap でキーマップ定義を行います。 &#34; Change the tab (for insert mode) imap &lt;C-Tab&gt; &lt;ESC&gt;:tabnext&lt;CR&gt; imap &lt;C-l&gt; &lt;ESC&gt;:tabnext&lt;CR&gt; imap &lt;C-k&gt; &lt;ESC&gt;:tabnext&lt;CR&gt; imap &lt;C-S-Tab&gt; &lt;ESC&gt;:tabprevious&lt;CR&gt; imap &lt;C-j&gt; &lt;ESC&gt;:tabprevious&lt;CR&gt; imap &lt;C-h&gt; &lt;ESC&gt;:tabprevious&lt;CR&gt; ただし、インサートモードでは、Ctrl + H はデフォルトで BackSpace としてマッピングされているので、その機能を上書きしてまでキーマッピングを行うほどのものではないでしょう。 nmap を使ってノーマルモードのマッピングをしておくだけで十分便利です。 ☝️ ワンポイント タブ切り替え時に、コマンドライン部分に :tabnext や :tabprevious と表示と表示されるのを抑制したいときは、nmap の後ろに &lt;silent&gt; オプションを指定します。 nmap &lt;silent&gt; &lt;C-l&gt; :tabnext&lt;CR&gt; Neovim の場合 Neovim の設定ファイル (init.lua) でのキーマップ設定には vim.keymap.set を使用します。 ~/.config/nvim/init.lua -- タブの切り替え vim.keymap.set(&#34;n&#34;, &#34;&lt;Leader&gt;h&#34;, &#34;:tabprev&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;Leader&gt;l&#34;, &#34;:tabnext&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-l&gt;&#34;, &#34;:tabnext&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-k&gt;&#34;, &#34;:tabnext&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-j&gt;&#34;, &#34;:tabprevious&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-h&gt;&#34;, &#34;:tabprevious&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-Tab&gt;&#34;, &#34;:tabnext&lt;CR&gt;&#34;) vim.keymap.set(&#34;n&#34;, &#34;&lt;C-S-Tab&gt;&#34;, &#34;:tabprevious&lt;CR&gt;&#34;) ☝️ ワンポイント タブ切り替え時に、コマンドライン部分に :tabnext や :tabprevious と表示と表示されるのを抑制したいときは、4 番目のパラメーターで { silent = true } オプションを指定します。 vim.keymap.set(&#34;n&#34;, &#34;&lt;C-l&gt;&#34;, &#34;:tabnext&lt;CR&gt;&#34;, { silent = true })"},{url:"/p/v4cuc9g/",title:"Vim/Neovim の検索に関する設定 (ignorecase, smartcase, wrapscan, hlsearch, incsearch)",date:"2009-01-29T00:00:00+09:00",body:"Vim/Neovim の検索に関する設定 (ignorecase, smartcase, wrapscan, hlsearch, incsearch) 大文字・小文字の区別 (ignorecase) /{pattern} によるカレントファイル内の検索や、:vimgrep による grep 検索では、デフォルトでは大文字・小文字を区別 してパターンマッチングが行われます。 ignorecase オプションを設定すると、大文字・小文字を区別せずに検索できるようになります。 Vim (.vimrc) の場合 :set ignorecase &#34;大文字・小文字を区別しないで検索 :set noignorecase &#34;大文字・小文字を区別して検索 (default) Neovim (init.lua) の場合 vim.opt.ignorecase = true -- 大文字・小文字を区別しないで検索 vim.opt.ignorecase = false -- 大文字・小文字を区別して検索 (default) ignorecase に加えて smartcase オプションを設定すると、検索パターンに大文字を含むときだけ大文字・小文字を区別して検索できるようになります。オススメです。 Vim (.vimrc) の場合 :set ignorecase smartcase &#34; 検索パターンに大文字を含むときは大文字・小文字を区別して検索 Neovim (init.lua) の場合 vim.opt.ignorecase = true -- 大文字・小文字を区別しないで検索 vim.opt.smartcase = true -- 検索パターンに大文字を含むときは大文字・小文字を区別して検索 ファイル末尾まで検索したら先頭から検索 (wrapscan) n キーを連打して検索パターンにヒットした箇所に次々とジャンプしていくとき、デフォルトでは最後にヒットした文字列まで到達すると、次はファイルの先頭に戻って検索されます。 nowrapscan オプションを設定しておくと、ファイルの末尾でカーソルのジャンプが停止します（下まで検索しましたが該当箇所はありません と表示されます）。 Vim (.vimrc) の場合 :set wrapscan &#34;折り返し検索 ON (default) :set nowrapscan &#34;折り返し検索 OFF Neovim (init.lua) の場合 vim.opt.wrapscan = true -- 折り返し検索 ON (default) vim.opt.wrapscan = false -- 折り返し検索 OFF 検索結果のハイライト (hlsearch) hlsearch オプションがセットされた状態で検索を行うと、検索にヒットした部分がすべてハイライト表示されるようになります。 Neovim ではデフォルトで有効になっています。 Vim (.vimrc) の場合 :set hlsearch &#34;検索結果のハイライト ON :set nohlsearch &#34;検索結果のハイライト OFF (default) Neovim (init.lua) の場合 vim.opt.hlsearch = true -- 検索結果のハイライト ON (default) vim.opt.hlsearch = false -- 検索結果のハイライト OFF hlsearch オプションを設定していると、検索結果のハイライト表示が出っぱなしになって邪魔になることがあります。 その場合は、:nohl コマンドを実行してハイライト表示を消すことができます。 検索結果のハイライトをクリア :nohl &#34; :nohlsearch の省略形 オプション名とコマンド名が nohlsearch で同じなので混同しないようにしてください。 インクリメンタル・サーチを有効にする (incsearch) incsearch オプションがセットされた状態で検索を行うと、検索パターンを 1 文字入力するたびに検索結果がリアルタイムに表示されるようになります。 Neovim ではデフォルトで有効になっています。 Vim (.vimrc) の場合 :set incsearch &#34;インクリメンタル・サーチ ON :set noincsearch &#34;インクリメンタル・サーチ OFF (default) Neovim (init.lua) の場合 vim.opt.incsearch = true -- インクリメンタル・サーチ ON (default) vim.opt.incsearch = false -- インクリメンタル・サーチ OFF このインクリメンタル・サーチは便利ですが、パターン入力中にカーソル位置がジャンプしてしまうので、慣れるまで戸惑うことがあります。 インクリメンタル・サーチ中に CTRL-G や CTRL-T キーを入力すると、パターン入力を継続したまま、次（あるいは前）のヒット箇所にジャンプすることができます。 このキーマッピングは若干覚えにくいですが、QWERTY キーボードの場合、G キーは T キーの上にあるので、キーの位置関係で覚えるといいかもしれません。"},{url:"/p/thhwr4b/",title:"Python でディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob)",date:"2009-01-06T00:00:00+09:00",body:"Python でディレクトリ内のファイルを列挙する (os.listdir, os.walk, glob) ファイルを列挙する（再帰なし） Python の os.listdir 関数を使うと、指定したディレクトリ内のファイルやディレクトリのパスをリストで取得できます。 カレントディレクトリや親ディレクトリを表す . や .. は、列挙の対象に含まれません。 列挙されたパスが、ディレクトリかどうかを調べたいときは os.path.isdir(path)、ファイルかどうかを調べたいときは os.path.isfile(path) で確認できます。 カレントディレクトリ内のディレクトリとファイルを列挙（1 階層のみ） import os for x in os.listdir(&#39;.&#39;): if os.path.isdir(x): print(&#39;DIR:&#39;, x) else: print(&#39;FILE:&#39;, x) ファイルを列挙する（再帰あり） os.listdir で列挙する方法 os.listdir 関数で列挙した要素がディレクトリだった場合に、そのディレクトリに対しても os.listdir 関数を呼び出すようにすれば、ディレクトリ内のすべてのファイルを再帰的に列挙することができます。 import os def enum_files(dir): entries = os.listdir(dir) for x in entries: path = os.path.join(dir, x) if os.path.isdir(path): for _ in enum_files(path): yield _ else: yield path if __name__ == &#39;__main__&#39;: for path in enum_files(&#39;.&#39;): print(path) # print(os.path.abspath(path)) # 絶対パスで出力する場合 os.walk で列挙する方法 os.walk 関数 を使用すると、再帰的なファイル列挙をさらに簡単に記述できます。 下記は 1 つのループ処理で記述していますが、下位のディレクトリにあるファイルまですべて列挙してくれます。 os.walk はデフォルトで再帰的にディレクトリを辿ってくれる ということです。 カレントディレクトリ以下、全ディレクトリの内容を表示 import os for dirpath, dirs, files in os.walk(&#34;.&#34;): print(&#34;-&#34; * 60) print(f&#34;{dirpath} ディレクトリの情報:&#34;) print(f&#34;dirs = {dirs}&#34;) print(f&#34;files = {files}&#34;) os.walk によって取得されるタプル要素には、それぞれ以下のような情報が格納されています。 dirpath &hellip; 現在検索中のディレクトリパス dirs &hellip; dirpath のディレクトリに含まれているディレクトリのリスト files &hellip; dirpath のディレクトリに含まれているファイルのリスト つまり、ディレクトリごとに上記のタプルが返されながらループが進んでいきます。 カレントディレクトリ以下のすべてのファイルのパスだけを列挙するには次のように files（タプルの 3 番目の要素）の内容だけ出力すれば OK です。 起点となるディレクトリのパス (dirpath) と join してやれば、そこからの相対パスを構築できます。 カレントディレクトリ以下のすべてのファイルの相対パスを表示 import os for dirpath, dirs, files in os.walk(&#39;.&#39;): for f in files: print(os.path.join(dirpath, f)) 出力例 ./a.txt ./b.txt ./foo/c.txt ./foo/d.txt ./foo/bar/e.txt ./foo/bar/f.txt ./hoge/g.txt 特定の拡張子のファイルだけ列挙したい場合 は、ファイル名の末尾を str.endswith メソッドでチェックすればよいでしょう。 .png ファイルのみを列挙 for f in files: if f.lower().endswith(&#39;.png&#39;): print(os.path.join(dirpath, f)) endswith() にはタプルを渡せるので、複数の拡張子を OR 条件で列挙することもできます。 .png、.jpg、.svg ファイルを列挙 for f in files: if f.lower().endswith((&#39;.png&#39;, &#39;.jpg&#39;, &#39;.svg&#39;)): print(os.path.join(dirpath, f)) os.path.splitext() を使用すれば、ファイル名をベースネームと拡張子に分離することができますが、拡張子のチェックだけであれば、endswith() を使った方がシンプルです。 glob で列挙する方法 ディレクトリ内の、特定の拡張子を持つファイルをすべて列挙したいときは、glob モジュール の glob.glob 関数を使うのが一番簡単です。 次のようにすると、カレントディレクト以下の .png ファイルをすべて列挙できます。 .png 拡張子を持つファイルを列挙 import os import glob for x in glob.glob(&#39;**/*.png&#39;, recursive=True): print(x) ただし、グロブでは複数の拡張子をまとめて処理できない ので、複数の拡張子のファイルを列挙したい場合は、その数だけ glob.glob() を呼び出さなければいけません。 .png あるいは .jpg 拡張子を持つファイルを列挙 import os import glob PATTERNS = (&#39;**/*.png&#39;, &#39;**/*.jpg&#39;) def multi_glob(patterns): files = [] for p in PATTERNS: files.extend(glob.glob(p, recursive=True)) return files for f in multi_glob(PATTERNS): print(f) このような実装をするのであれば、os.walk を使って列挙した方が早いかもしれません。 参考: Python で指定した拡張子、名前のファイルを列挙する"},{url:"/p/rihibef/",title:"Vim のアンドゥ操作とリドゥ操作 (u, Ctrl-r, undolevels)",date:"2008-11-13T00:00:00+09:00",body:"Vim のアンドゥ操作とリドゥ操作 (u, Ctrl-r, undolevels) アンドゥ／リドゥの操作方法 Vim でアンドゥ (Undo) 操作、リドゥ (Redo) 操作を行うには、下記のコマンドを使用します。 u &hellip; アンドゥ Ctrl-r &hellip; リドゥ（アンドゥによって取り消された操作を復旧） アンドゥ回数の設定 アンドゥ操作のレベル（制限回数）を変更するには undolevels オプションを設定します。 :set undolevels=300 Linux や Windows では、undolevels の規定値は 1000 なので、通常は変更する必要はないでしょう。"},{url:"/p/in6mo7q/",title:"Vim でカーソル位置の数字をインクリメント／デクリメントする",date:"2008-11-12T00:00:00+09:00",body:"Vim でカーソル位置の数字をインクリメント／デクリメントする カーソル位置の数字をインクリメント／デクリメントする 数字を表すテキストにカーソルを合わせて CTRL-A と入力すると、その数値をインクリメントする（数字を1つ増やす）ことができます。 逆に CTRL-X でデクリメントする（数字を1つ減らす）ことができます。 CTRL-A: カーソル位置の数値をインクリメントする CTRL-X: カーソル位置の数値をデクリメントする 数値のプレフィックスに 0 が付いていれば 8 進数、0x や 0X が付いていれば 16 進数とみなしてインクリメント／デクリメントしてくれます。 例えば、10進数、8進数、16進数と思われる数値は、それぞれ下記のようにインクリメントされます。 17 → 18 017 → 020 0xFF → 0x100 CTRL-A、CTRL-X コマンドのプレフィックスとして数値を与える（先に数値を入力する）と、その数値分だけ足したり引いたりすることができます。 選択範囲の数字をまとめてインクリメント／デクリメントする SHIFT-V や CTRL-V のビジュアルモードで選択した範囲にある数値をまとめてインクリメントすることもできます。 下記のデモでは、SHIFT-V で複数行を選択してから、CTRL-A で複数の数値をまとめてインクリメントしています。 応用例として、CTRL-A と入力する前に g を入力しておくと、次のようにそれぞれの数値に足される数自体がインクリメントされていきます。 連番からなる数値の羅列を作りたいときに便利です。"},{url:"/p/c2kx7er/",title:"Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*)",date:"2008-10-29T00:00:00+09:00",body:"Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*) コマンドライン引数の基本 ($1 ~ $9) bash シェルスクリプト実行時にコマンドラインで渡した引数を参照するには、次のようなパラメーター参照用の特殊変数を使用します。 $1 &hellip; 第 1 パラメーター $2 &hellip; 第 2 パラメーター $3 &hellip; 第 3 パラメーター パラメーターの参照には、$1 〜 $9 が使用できます。 使用することは余りないと思いますが、10 番目以降のパラメータを参照したいときは、${10} のように数値を {} で囲めば参照できます。 sample.sh #!/bin/bash echo &#39;1 番目: &#39; &#34;$1&#34; echo &#39;2 番目: &#39; &#34;$2&#34; echo &#39;3 番目: &#39; &#34;$3&#34; 実行結果 $ ./sample.sh AAA BBB &#34;CCC DDD&#34; 1 番目: AAA 2 番目: BBB 3 番目: CCC DDD コマンドライン引数を指定しなかった場合は、対応する変数は空になります。 $ ./sample.sh AAA 1 番目: AAA 2 番目: 3 番目: ☝️ 変数はダブルクォートで囲む echo の引数として変数の値を渡すときは、&quot;$1&quot; のようにダブルクォートで囲む癖をつけましょう。 $1 のようにそのまま記述してしまうと、変数の値として連続するスペースが含まれていたときに 1 つのスペースにまとめられてしまいます。 ☝️ 引数とパラメーターの違い 正確には、引数 (arguments) という用語は、スクリプトや関数を呼び出す側が渡す値のことを示し、パラメーター (parameters) という用語は、呼び出される側のスクリプトや関数が、その値を参照するときに使う変数のことを示します。 ただ、どちらのケースでもパラメーターという用語を使っているドキュメントもよく見かけるので、あまり気にしない方がよさそうです。 コマンドライン引数にデフォルト値を指定する (${1:-XXX}) コマンドライン引数が指定されなかったときに使用する値として、デフォルト値を指定しておくこともできます。 デフォルト値は、パラメーター参照時に ${1:-デフォルト値} という形で指定します。 下記の例では、1 番目、2 番目、3 番目のコマンドラインパラメーターのデフォルト値を、それぞれ AAA、BBB、CCC に設定しています。 sample.sh #!/bin/bash echo &#39;1 番目: &#39; &#34;${1:-AAA}&#34; echo &#39;2 番目: &#39; &#34;${2:-BBB}&#34; echo &#39;3 番目: &#39; &#34;${3:-CCC}&#34; 実行結果（1 番目の引数のみ指定した場合） $ ./sample.sh 100 1 番目: 100 2 番目: BBB 3 番目: CCC 指定されたコマンドライン引数の数を取得する ($#) シェルスクリプト実行時に渡されたパラメータの数は、$# という特殊変数で取得することができます。 sample.sh #!/bin/bash echo 引数の数: $# 実行結果 $ ./sample.sh 引数の数: 0 $ ./sample.sh AAA 引数の数: 1 $ ./sample.sh AAA &#34;BBB CCC DDD&#34; 引数の数: 2 コマンドライン引数をループで順番に処理する ($@, $*) for ループを使う方法 シェルスクリプト実行時に渡されたコマンドライン引数は、特殊変数 $@ を使って参照することができます。 以下の例では、for in ループを使って、$@ の要素を 1 つずつ取り出して処理しています（おまけでカウンター変数 $count をインクリメントしながらループしてます）。 sample.sh #!/bin/bash count=0 for arg in &#34;$@&#34;; do let count=$count+1 echo &#34;$count: $arg&#34; done 実行結果 $ ./sample.sh AAA BBB &#34;CCC DDD&#34; 1: AAA 2: BBB 3: CCC DDD 実は、特殊変数の指定部分 in &quot;$@&quot; は省略して記述することができます。 sample.sh #!/bin/bash count=0 for arg; do let count=$count+1 echo &#34;$count: $arg&#34; done 明示的に in &quot;$@&quot; を記述する場合は、$@ の部分をダブルクォートで囲むことを忘れないようにしてください（詳しくは後述）。 while ループ + shift を使う方法 shift コマンドを実行することで、$1〜$9 に格納されたパラメータを 1 つずつ前にシフトすることができます。 shift コマンドを実行するたびに $1 に格納されていたパラメータは破棄され、パラメータ数を表す $# の値が 1 つずつ減っていきます。 下記の例では、パラメータ数 ($#) が 1 以上の間、処理を続ける while ループを定義しています。 $1 はコマンドラインパラメータの最初の要素を参照する変数ですが、直後の shift によってパラメータを 1 つずつシフトしているので、結果としてすべてのパラメータを順番に参照することができます。 sample.sh #!/bin/bash count=0 while [ &#34;$#&#34; -ge &#34;1&#34; ]; do let count=$count+1 echo &#34;$count: $1&#34; shift done 実行結果 $ ./sample.sh AAA BBB CCC 1: AAA 2: BBB 3: CCC 引数全体を 1 つの文字列として取得する ($*) $@ と似た特殊変数に $* があります。 どちらもパラメータ全体を表す特殊変数ですが、$@ が各パラメータを個別に保持しているのに対し、$* はすべてのパラメータを結合した 1 つの文字列 になっています。 それぞれ、ダブルクォートで囲んで参照した場合と、囲まずに参照した場合の展開方法も含めて理解しておきましょう。 下記のようなサンプルコードと、その振る舞いを対応付けて覚えてしまうのが手っ取り早いです。 sample.sh #!/bin/bash echo -e &#39;\\n=== &#34;$@&#34; の場合 ===&#39; for arg in &#34;$@&#34;; do echo &#34;$arg&#34; done echo -e &#39;\\n=== $@ の場合 ===&#39; for arg in $@; do echo &#34;$arg&#34; done echo -e &#39;\\n=== &#34;$*&#34; の場合 ===&#39; for arg in &#34;$*&#34;; do echo &#34;$arg&#34; done echo -e &#39;\\n=== $* の場合 ===&#39; for arg in $*; do echo &#34;$arg&#34; done 実行結果 $ ./sample.sh &#34;100 200&#34; &#34;CCC DDD&#34; === &#34;$@&#34; の場合 === 100 200 CCC DDD === $@ の場合 === 100 200 CCC DDD === &#34;$*&#34; の場合 === 100 200 CCC DDD === $* の場合 === 100 200 CCC DDD 1 番目の方法が、おそらく想定通りの振る舞いに近いと思います。 &quot;$@&quot; と指定することで、内部的には下記のようにそれぞれの要素をダブルクォート (&quot;) で囲んで指定されたものとみなされるため、正しく 2 つのパラメータとしてハンドルされます。 for arg in &#34;100 200&#34; &#34;AAA BBB&#34;; ... 2 番目の方法のように $@ をダブルクォートで囲まずに渡すと、下記のように各要素が展開して指定されたものとみなされます。 for ループはスペース区切りで各要素が渡されていると判断するため、結果的に 4 つの要素として処理されてしまいます。 for arg in 100 200 AAA BBB; ... 3 番目の方法のように &quot;$*&quot; と指定すると、下記のように全てのパラメータをスペースでつなげ、さらに全体をダブルクォート (&quot;) で囲んで指定されたものとして処理されます。 つまり、ループは &quot;100 200 AAA BBB&quot; という文字列 1 回分しか回りません。 for arg in &#34;100 200 AAA BBB&#34;; do 4 番目の方法のように $* と指定した場合は、2 番目の方法と同様に、すべての要素がスペース区切りで渡されたとみなされます（4 つの要素として処理されます）。 for arg in 100 200 AAA BBB; ... （コラム）$* が使用する IFS 変数について 前述のとおり、全てのパラメータは $* あるいは $@ で参照できます。 $* は環境変数 IFS に設定された最初のセパレータで区切られた単一の文字列として評価され（デフォルトはスペース）、$@ はスペースで区切られた複数の文字列として評価されます。 例えば、次のように実行した場合、 $ ./sample.sh aaa bbb ccc ddd それぞれの値は以下のようになります。 $* → &quot;aaa bbb ccc ddd&quot; $@ → &quot;aaa&quot; &quot;bbb&quot; &quot;ccc&quot; &quot;ddd&quot; $ ./sample.sh &#34;aaa bbb&#34; &#34;ccc ddd&#34; とした場合は、 $* → &quot;aaa bbb ccc ddd&quot; $@ → &quot;aaa bbb&quot; &quot;ccc ddd&quot; となります。 $* はこのような性質を持つため、2 つ目の例のように、スペースを含むパラメータが渡されたときに for ループでうまく扱うことができません。 sample.sh（おそらく間違った実装例） #!/bin/bash for x in $*; do echo &#34;$x&#34; done 実行結果（4つのパラメータとして扱われてしまう） $ ./sample.sh &#34;aaa bbb&#34; &#34;ccc ddd&#34; aaa bbb ccc ddd 実は、IFS 変数の値は変更できる ため、次のようにして改行 1 つ分に変更してやることで、for ループがうまく回るようになります。 sample.sh（推奨はしないがうまく動作する実装例） #!/bin/bash IFS=&#39; &#39; for x in $*; do echo &#34;$x&#34; done unset IFS # デフォルトに戻す（スペースで結合） 実行結果（ちゃんと 2 つのパラメータとして扱われる） $ ./sample.sh &#34;aaa bbb&#34; &#34;ccc ddd&#34; aaa bbb ccc ddd うまく動作するとはいえ、これはとてもトリッキーな方法なので、パラメータをループ処理するときは素直に &quot;$@&quot; を使って次のように書きましょう。 for arg in &#34;$@&#34;; do echo &#34;$arg&#34; done 関連記事 コマンドライン引数の数が正しいかチェックする ($#)"},{url:"/p/eimpfje/",title:"Linuxメモ: Bash の構文: for/while によるループ処理",date:"2008-10-28T00:00:00+09:00",body:"Linuxメモ: Bash の構文: for/while によるループ処理 スペースで区切られた単語（ワード）を順番に処理する 次の Bash スクリプトでは、ループ処理したいテキスト (aaa, bbb, ccc) を直接 for ループで指定しています。 ここでは、do を for と同じ行に記述するコーディングスタイルを採用しています。 例: aaa bbb ccc を順番に処理 for x in aaa bbb ccc; do echo $x done 実行結果 aaa bbb ccc 以下のように、スペースで区切られた文字列が格納された文字列変数を処理することもできます。 list=&#34;aaa bbb ccc&#34; for x in $list; do echo $x done スペースを含む文字列を1つの要素として扱う リスト内の各要素をダブルクォートで囲んでおくと、その単位でループ処理されるようになります。 #!/bin/bash for i in &#34;aaa bbb&#34; &#34;ccc ddd&#34; &#34;eee fff&#34;; do echo $i done 実行結果 aaa bbb ccc ddd eee fff 変数を使う場合もほぼ同様ですが、それぞれの変数をダブルクォートで囲む 必要があります（これを忘れると、それぞれの変数内の文字列がスペースで区切られてループ処理されてしまいます）。 x=&#34;aaa bbb&#34; y=&#34;ccc ddd&#34; z=&#34;eee fff&#34; for i in &#34;$x&#34; &#34;$y&#34; &#34;$z&#34;; do echo $i done 実行結果 aaa bbb ccc ddd eee fff ちなみに、下記のようにすべての変数をまとめてダブルクォートで囲むと、ひとつの要素として処理されます。 for i in &#34;$x $y $z&#34;; do echo $i done 実行結果 aaa bbb ccc ddd eee fff 応用: 複数の要素の組み合わせ 次のように for ループに渡す処理を { と } を使ってグルーピングすると、それぞれのグループ内の要素の組み合わせでループすることができます。 for x in {A,B,C}-{1,2}; do echo $x done 実行結果 A-1 A-2 B-1 B-2 C-1 C-2 応用: C/C++ のような for ループを記述する 次のように括弧を重ねて使用することで、C/C++ のようなフォーマットで for ループを記述することができます。 気持ち悪いのでオススメはしません。 for (( i=0 ; i&lt;3 ; ++i )); do echo $i done 実行結果 0 1 2 ちなみに、上記のような連番を生成したい場合は、seq コマンドを使うと柔軟に生成することができます。 for i in `seq 0 2`; do echo $i done 実行結果 0 1 2 seq コマンドでは、1ループごとのステップをマイナスにしたり、小数点数にしたりできます。 for i in `seq 1 -0.1 0.5`; do echo $i done 実行結果 1.0 0.9 0.8 0.7 0.6 0.5"},{url:"/p/ams75pd/",title:"Linuxメモ: あるファイルがテキストファイルかどうか調べる (file)",date:"2008-09-08T00:00:00+09:00",body:"Linuxメモ: あるファイルがテキストファイルかどうか調べる (file) テキストファイルを file コマンドにかけると、... text ... のような結果が出力されます。 それを grep することで、そのファイルがテキストファイルかどうか調べることができます。 $ file sample.txt | grep text"},{url:"/p/hudubr8/",title:"Linuxメモ: ファイルやディレクトリを検索する (find, grep)",date:"2008-09-08T00:00:00+09:00",body:"Linuxメモ: ファイルやディレクトリを検索する (find, grep) find と grep の基本 指定した拡張子のファイルを検索する (find) 次のようにすると、カレントディレクトリ (.) を起点にして、拡張子 .txt を持つファイルを検索して一覧表示することができます。 $ find . -name &#39;*.txt&#39; ファイル内の文字列を検索する (grep) 次のようにすると、指定したテキストファイル内の文字列を検索することができます。 $ grep &#39;検索文字列&#39; hello.txt find で見つけたファイルの中身を grep 検索する find で検索した結果のファイルそれぞれに対して、grep コマンドを実行するには、xargs を組み合わせて使用します。 例: 拡張子に txt を持つファイルを grep $ find . -type f -name &#39;*.txt&#39; | xargs grep &#39;検索文字列&#39; 拡張子などを絞り込まず、単純にそのディレクトリ以下のすべてのテキストファイルを検索するだけでよいのであれば、find を使わず、grep の再帰オプション (-r) を使った方が簡単です。 念のため、テキストファイルのみを grep 対象にするために -I オプション (--binary-files-without-match) も一緒に指定しておきます。 例: すべてのテキストファイルを grep $ grep -r -I &#39;検索文字列&#39; . grep で NOT、AND、OR 検索する NOT 検索 grep の -v オプションを指定すると、指定した 文字列を含まない 行だけを抽出できます。 例: TODO という文字列を含まない行を検索する $ grep -v &#39;TODO&#39; file.txt AND 検索 grep で AND 検索したいときは、grep の検索結果をパイプで繋いでさらに grep 検索してしまうのが簡単です。 例: すべての .txt ファイルから AAA と BBB の両方を含む行を検索する $ find . -name &#39;*.txt&#39; | xargs grep AAA | grep BBB 例: すべての .html ファイルから http: を含む行（ただし http://localhost ではない）を検索する $ find . -name &#39;*.html&#39; | xargs grep &#39;http:&#39; | grep -v &#39;http://localhost&#39; OR 検索 grep で OR 検索したいときは、検索した文字列を -e オプションで複数回指定します。 例: AAA あるいは BBB を含む行を検索する $ grep -e AAA -e BBB file.txt 別の方法として、正規表現（-E オプション）を使用して OR 検索する方法もあります。 $ grep -E &#39;AAA|BBB&#39; file.txt $ egrep &#39;AAA|BBB&#39; file.txt find のオプションいろいろ ファイル名で OR 検索する find でファイル名の OR 検索をするときは、-o オプションで -name などの検索オプションを繋ぎます。 例: .py ファイルと .rb ファイルを検索する $ find . -name &#39;*.py&#39; -o -name &#39;*.rb&#39; ファイル名の大文字と小文字を区別しない (-iname) -name オプションの代わりに -iname オプションを使用すると、ファイル名の大文字と小文字を区別せずにファイル検索することができます。 例: カレントディレクトリ以下の foo.txt や FOO.TXT や Foo.Txt などを検索 $ find . -iname foo.txt 特定のディレクトリを検索対象外にする (-not -path) -not -path あるいは ! -path で検索対象外にするパスのパターンを指定できます。 例: node_modules ディレクトリを検索対象外にする $ find . -name &#39;*.md&#39; -not -path &#39;*/node_modules/*&#39; $ find . -name &#39;*.md&#39; ! -path &#39;*/node_modules/*&#39; 空のファイル／ディレクトリを検索する (-empty) $ find . -type f -empty # サイズが 0 のファイルを検索する $ find . -type d -empty # 空っぽのディレクトリを検索する 相対パスで出力する (-printf &ldquo;%P\\n&rdquo;) 例: src ディレクトリからの相対パスで出力 $ find src -name &#39;*.py&#39; -printf &#39;%P\\n&#39;"},{url:"/p/e3xdbxe/",title:"Vim/Neovim で GUI モード用のフォントを設定する (guifont)",date:"2008-05-12T00:00:00+09:00",body:"Vim/Neovim で GUI モード用のフォントを設定する (guifont) フォント設定ダイアログを開く nvim-qt や gVim などの GUI モードで動作する Vim/Neovim 環境では、次のようにフォント設定ダイアログを開くことができます。 :set guifont=* ターミナル上で vim や nvim を動かしているときは、そのターミナルで設定されているフォントがそのまま使われるので、この設定は必要ありません。 ダイアログでフォントの設定を行った後は、 set guifont? として guifont オプションに具体的にどのような設定値が格納されているかを確認することができます。 この設定値を、設定ファイルに記述しておけば、次回の起動時からは自動的にそのフォント設定が反映されます。 設定ファイルでフォントを指定する Neovim (nvim-qt) の場合 GUI モードの Neovim（nvim-qt など）のフォントを設定するには、コマンドラインモードでの :set guifont=Consolas:h14 に相当する下記のようなコードを実行すれば OK です。 Neovim (~/.config/nvim/init.lua) の場合 vim.o.guifont = &#34;Consolas:h14&#34; 現在の環境が GUI モードで動作しているかどうかを調べるには、vim.fn.has('gun_running') の値が 1 かどうかをチェックします。 下記は、HackGen フォントを使用するように設定した例です。 Neovim (~/.config/nvim/init.lua) の場合 -- -- GUI モード（nvim-qt など）のフォント設定 -- -- 白源フォント (HackGen Console NF) を下記からダウンロードしておく。 -- Nerd Fonts が組み込まれているのでリッチな UI 表示に使える。 -- https://github.com/yuru7/HackGen/releases -- if vim.fn.has(&#39;gui_running&#39;) == 1 then vim.o.guifont = &#34;HackGen Console NF:h14&#34; end さらに Windows かどうかで分岐させたいときは、vim.fn.has(&quot;win64&quot;) == 1 による条件分岐を追加してください。 gVim/MacVim の場合 gVim/MacVim では、.gvimrc ファイルに GUI モード用のフォント設定を記述します。 次の例では、Windows と macOS でそれぞれ異なるフォントを設定しています。 ~/.gvimrc &#34; Font settings for Windows and macOS if has(&#34;win64&#34;) set guifont=ＭＳ_ゴシック:h14::cSHIFTJIS set ambiwidth=double &#34;Display double-width symbols properly elseif has(&#34;macunix&#34;) set guifont=Menlo\\ Regular:h14 endif"},{url:"/p/gowvphv/",title:"ダイナミック・ルーティング・プロトコルのメモ (RIP, OSPF, BGP-4)",date:"2008-05-09T00:00:00+09:00",body:"ダイナミック・ルーティング・プロトコルのメモ (RIP, OSPF, BGP-4) RIP (Routing Information Protocol) 特徴 最も歴史があり、最も簡単で、多くのエンジニアが知っている。 小、中規模の WAN を介さないネットワークで使われる。 サポートしている機器が多い。 仕組み ルータが自身のルーティングテーブルをブロードキャストで隣のルータへ伝える、ということを繰り返してルーティングテーブルを伝播していく。 自分自身のルーティングテーブルは最初、メトリック値１としてブロードキャストする。ルーティングテーブルを伝播するごとに、ルーティングテーブルのメトリック値が＋１される。メトリック値が大きいほど、遠いルータだということが分かる。同じサブネットへの経路として複数のルータが選択できる場合、メトリック値が小さいもの（要するにルータのホップ数が少なく、近いもの）が選択される。 30秒ごとにルータはまわりのルータに情報を送信する（レギュラーアップデート）。あるルータのレギュラーアップデートを 6 回受信できない状態が続くと、そのルータに障害が発生したとみなされ、メトリック値 16 が設定され、さらに 4 回 RIP パケットの応答がない場合はルーティングテーブルからそのルータの情報が削除される。 RIPv2 では可変長サブネットマスクに対応している。 欠点 30秒後とのレギュラーアップデートなので、経路情報の伝播には時間がかかる。また、ブロードキャストなので、ネットワークへの負荷がかかる。RIPv2 ではレギュラーアップデートはブロードキャストではなく、マルチキャスト (224.0.0.9) で送られるが、送信周期は 30 秒で同じ。 RIP におけるメトリック値の上限は 16 であり、その値が設定されると、使用できないルートであるという意味になる。結果として、RIP は 16 個以上のルータを経由する大規模なネットワークには適用できない。逆に、この制限のおかげで経路のループによる問題が起こらないようになっている。 経路はメトリック値だけで判断されるので、回線速度、品質が考慮されない。 OSPF (Open Shortest Path First) 特徴 RIP の課題を解決したプロトコル。 回線速度などを考慮しているので、WAN を含む中～大規模のネットワークに適用できる。 RIP よりも複雑で構築が難しい。 OSPF をサポートする機器は、RIP だけサポートしている機器に比べて高価。 仕組み サブネットに主従関係を持たせ、1 つのルータを代表ルータとする。そのサブネット内のルータ情報は代表ルータが集中管理して他のサブネットへ通知するため、通信量が RIP に比べて少ない。 サブネット内のルータの中で、プライオリティ値が一番高く設定されているものが代表ルータとなる。ルータのプライオリティ値は各インタフェースごとに設定できる。 RIP のように定期的に情報を送信（レギュラーアップデート）するのではなく、ルータ情報に変化が起きたときにただちに情報が伝えられる。ネットワークへの負荷が少なく、情報の更新が速い。 ルータの各ポートにコスト値が設定され、この値を元にメトリック値が計算され、最適な経路が決定される。コスト値は手動で設定することも自動で計算することもできる。 16 台以上のルータを越えるルーティングが可能。 可変長サブネットマスクに対応している。 BGP-4 プロバイダ向け。"},{url:"/p/25gurcf/",title:"NAT の種類のメモ（SNAT、DNAT、NAPT、IP マスカレード）",date:"2008-05-07T00:00:00+09:00",body:"NAT の種類のメモ（SNAT、DNAT、NAPT、IP マスカレード） NAT (Network Address Translation) とは、パケット中の IP アドレスを書き換える技術のことをいいます。 送信元、送信先のどちらを書き換えるかで次のように区別することもあります。 SNAT (Source NAT) 送信元の IP アドレスを書き換える DNAT (Destination NAT) 送信先の IP アドレスを書き換える IP アドレスだけでなく、TCP や UDP のポート番号も同時に変換する機能を NAPT (Network Address Port Translation)、あるいは IP マスカレードといいます。 この機能は、ブロードバンドルータなどによく実装されています。 ネットワークのインタフェースを複数持っている端末で、NAT による設定を行うことで、柔軟なルーティングを行えるようになります。 例えば、Linux マシンに 2 枚の NIC（ネットワークカード）を挿して、iptables で NAT の設定を行えば、その Linux マシンをルータとして利用できるようになります。"},{url:"/p/8yz2uga/",title:"ルーティングテーブルの管理",date:"2008-04-22T00:00:00+09:00",body:"ルーティングテーブルの管理 ルーティングテーブルを表示する Linux の場合 $ /sbin/route Windows の場合 C:\\&gt; route print ルーティングテーブルにエントリを追加する Linux の場合 $ route add -net &lt;NetworkAddr&gt; netmask &lt;NetMask&gt; gw &lt;GatewayAddr&gt; [Metric] [Interface] 実行例 $ route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.100.254 metric 1 eth0 Windows の場合 C:\\&gt; route add &lt;NetworkAddr&gt; netmask &lt;NetMask&gt; gateway &lt;GatewayAddr&gt; ルーティングテーブルからエントリを削除する Linux の場合 $ route del -net 192.168.1.0 netmask 255.255.255.0 ネットワーク・トラブルの調査 (Windows) ルータに ping は通るが他のネットワークに ping が通らないケース route print コマンド（あるいは netstat -r）でルーティングテーブルを表示し、デフォルトゲートウェイのアドレスを確認します。 正しいルータのアドレスになっていなければ、NIC の設定で正しいアドレスを設定します。 C:\\&gt; route print ... Default Gateway: 192.168.1.254 tracert コマンドで他のネットワークの経路の先頭にデフォルトゲートウェイの IP Address が表示されるかを確認します。 複数の NIC が刺さっている場合は、ルータに実際に繋がっている方の NIC の設定のみにデフォルトゲートウェイのアドレスを設定するようにします。"},{url:"/p/bbsprto/",title:"Vim で記号（引用符など）で囲まれた範囲のテキストを削除する",date:"2008-04-06T00:00:00+09:00",body:"Vim で記号（引用符など）で囲まれた範囲のテキストを削除する 引用符で囲まれた文字を一気に削除する 例えば、以下のようなテキストがあった場合、 AAA &#34;BBB&#34; CCC カーソルを &quot;BBB&quot; のどこかに合わせた状態で、 di&quot; と入力すると、ダブルクォート (&quot;) で囲まれた文字列 BBB を全て削除することが出来ます。 da&quot; とすると、ダブルクォート (&quot;) まで含めて削除することができます。 補足メモ 最初の文字を c、y、v に変えることにより入力モード、ヤンク、リージョン選択へ変化する。 1文字目 (d, c, y, v) の次の i&quot; とか a&quot; の部分は範囲を示す text-object というものである。 詳しくは :h text-objects で確認できる。"},{url:"/p/z8fh4xj/",title:"Vim でスワップファイルからファイルを復旧する (:recover)",date:"2008-04-02T00:00:00+09:00",body:"Vim でスワップファイルからファイルを復旧する (:recover) スワップファイルの扱い方 Vim でファイルを開くと、一時的に編集内容を保持するためのスワップファイルが作成されます。 デフォルトでは、sample.txt のスワップファイル名は .sample.txt.swp になります。 Vim を終了すると、スワップファイルは自動的に削除されます。 以下のようなケースの場合、Vim でファイルを開いたときに前回作成されたスワップファイルが残っている可能性があります。 別の Vim で同じファイルを開いている。 前回の編集中に Vim がクラッシュした。 このような場合は、編集開始時に、「読み込み専用で開く」、「復活させる」、といった選択肢が表示されるので、適切な処理を選択してください。 例えば、別の Vim で同時編集しているような場合は、読み込み専用で開くのがよいでしょう。 スワップファイルからのファイルの復旧を明示的に実行するには下記のようにします。 :recover sample.txt あるいは、起動時に -r オプションを指定します。 $ vim -r sample.txt スワップファイルの名前を確認する 現在編集中のファイルに対応するスワップファイルの名前は、下記のようにして確認することができます。 :swapname スワップファイルに直ちに書き込む スワップファイルへの書き込みは、時間、あるいはタイプ数によって自動的に実行されますが、明示的に書き込みを実行することもできます。 :preserve 参考 Vim でバックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile)"},{url:"/p/xv4yhu2/",title:"Vim設定: バックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile)",date:"2008-04-02T00:00:00+09:00",body:"Vim設定: バックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile) バックアップファイルの設定 Vim には、編集中のファイルを自動でバックアップするための機能が付いています（デフォルトではバックアップ機能 Off になっています）。 バックアップを有効に設定した状態で、例えば、sample.txt というファイルを保存すると、同じディレクトリに sample.txt~ というバックアップファイルが生成されます。 バックアップの ON/OFF (backup, nobackup) バックアップの On/Off を切り替えるには以下のようにします。 :set backup &#34;バックアップファイルを生成する :set nobackup &#34;バックアップファイルを生成しない（デフォルト） 現在の設定は、:set backup? で確認することができます。 バックアップディレクトリの設定 (backupdir) バックアップファイルは、デフォルトでは編集中のファイルと同じディレクトリに作成されますが、このディレクトリは自由に変更することができます。 バックアップファイルを保存するディレクトリの設定は、backupdir オプションで行います。 ディレクトリ候補をカンマ (,) で区切って複数指定することができます。 バックアップディレクトリの設定例 :set backupdir=.,~/tmp,~/ &#34;デフォルトの設定（カレントディレクトリに作られる） :set backupdir=~/temp/backup/ :set backupdir=D:/y/backup/vim,C:/tmp,C:/temp backup オプションを設定してあっても、この backupdir が指定されていないとバックアップファイルは生成されません。 backupdir には、存在するディレクトリを指定しておく必要があります。 存在しないディレクトリを指定すると、ファイルを保存したときに、**「E510: バックアップファイルを作れません」**というエラーが発生します。 backupdir をカレントディレクトリ以外の特定のディレクトリに設定した場合は、同じファイル名のファイルを編集して保存すると、バックアップディレクトリにあるバックアップファイルは上書きされます。 バックアップファイル名のプレフィックスを変更する (backupext) :set backupext=.back 上記のように設定しておくと、sample.txt のバックアップファイル名は sample.txt~ ではなく、sample.txt.back になります。 スワップファイルの設定 Vim はデフォルトで、ファイルをオープンしたときに、.＜ファイル名＞.swp というスワップファイルを同じディレクトリに作成します。 これは、万が一 Vim がクラッシュしたときに備えるためのものです。 正常に Vim を閉じた場合は、スワップファイルは自動的に削除されます。 スワップファイルの ON/OFF (swapfile, noswapfile) スワップファイルの機能を On/Off するには以下のようにします。 :set swapfile &#34;スワップファイルを生成する（デフォルト） :set noswapfile &#34;スワップファイルを生成しない スワップファイルを保存するディレクトリの設定 (directory) スワップファイルの生成場所を、任意のディレクトリに変更することができます。 :set directory=.,c:\\tmp,c:\\temp &#34;デフォルトの設定（カレントディレクトリに作成） :set directory=~/temp/backup/ :set directory=D:/y/backup/vim,C:/tmp,C:temp デフォルトの設定では、まずカレントディレクトリ (.) にスワップファイルを作成しようとします。 既に同じ名前のファイルがあったりして、スワップファイルを作成できない場合は、カンマで区切られた次の候補（上の場合は c:\\tmp）のディレクトリへ保存されます。 スワップファイルの保存タイミングを変更する (updatetime, updatecount) デフォルトでは、4 秒おき、あるいは 200 文字タイプするごとにスワップファイルに保存されます。 これらのタイミングを変更するには以下のように設定します。 :set updatetime=30000 &#34;30秒ごとに保存 :set updatecount=500 &#34;500文字タイプするごとに保存 アンドゥファイルの設定 Vim でファイルを保存したときに、同じディレクトリに生成される .&lt;ファイル名&gt;.un~ というファイルは、アンドゥ情報が保存されたファイルです（例えば、sample.txt というファイルを保存した場合は、.sample.txt.un~ という名前のファイルが作成されます）。 このファイルがあると、次回ファイルを Vim で開いたときにも、前回の編集内容をさかのぼってアンドゥ (Ctrl-U)、リドゥ (Ctrl-R) を実行できるようになります。 アンドゥファイルの ON/OFF (undofile, noundofile) アンドゥファイルの機能を On/Off するには以下のようにします。 :set undofile &#34;アンドゥファイルを生成する（デフォルト） :set noundofile &#34;アンドゥファイルを生成しない アンドゥファイルを保存するディレクトリの設定 (undodir) アンドゥファイルの生成場所を、任意のディレクトリに変更することができます。 指定方法は backupdir の指定方法と同様で、ディレクトリ候補をカンマ (,) で区切って複数指定することができます。 :set undodir=. &#34;デフォルトの設定（カレントディレクトリに作成） :set undodir=~/temp/vim_undo/,~/temp/,. 複数のディレクトリを指定すると、最初に見つかったディレクトリにアンドゥファイルを保存しようとします。どのディレクトリも見つからない場合は、アンドゥファイルは作成されず、エラーも発生しません。最後にカレントディレクトリ (.) を指定しておけば、少なくともカレントディレクトリにはアンドゥファイルが作成されることになります。 次回に同じファイルを開いたときには、undodir に設定されたすべてのディレクトリからアンドゥファイルを検索して、最初に見つかったアンドゥファイルを使用します。 ちなみに、アンドゥファイルの保存先ディレクトリをカレントディレクトリ以外に設定すると、ディレクトリ階層を % で繋いだファイル名でアンドゥファイルが作成されます（例: Users%maku%sample.txt）。このあたりの仕様は、バックアップファイルとスワップファイルの仕様とは少々異なりますね。 まとめ バックアップファイルやスワップファイル、アンドゥファイルは、デフォルトでは編集中のファイルと同じディレクトリに作成されます。 カレントディレクトリに勝手にファイルが作成されるのが気になる場合は、下記のように保存先のディレクトリを変更しておくとよいでしょう。 ~/.vimrc &#34;&#34;&#34; Backup file settings (file.txt~) set backup set backupdir=~/temp/vim_backup &#34;&#34;&#34; Swap file settings (.file.txt.swp) set swapfile set directory=~/temp/vim_backup &#34;&#34;&#34; Undo file settings (.file.txt.un~) set undofile set undodir=~/temp/vim_backup 保存先のディレクトリは、あらかじめ作成しておく必要があることに注意してください。 個人的には、ファイルを再オープンしたときに前回の編集を遡ってまでアンドゥできてしまうと逆に怖いので、アンドゥファイルだけは無効にしています (set noundofile)。 参考 スワップファイルからファイルを復旧する (:recover)"},{url:"/p/g2qyu9b/",title:"Vim でファイルのエンコーディング形式、改行コードを変更する (fenc, ff)",date:"2008-02-01T00:00:00+09:00",body:"Vim でファイルのエンコーディング形式、改行コードを変更する (fenc, ff) 改行コードの変更 Vim でファイルの改行コードを変更するには、次のように fileformat (ff) オプションの値を設定してから :w で保存します。 :set ff=unix &#34;&lt;NL&gt; :set ff=dos &#34;&lt;CR&gt; &lt;NL&gt; :set ff=mac &#34;&lt;CR&gt; 現在の改行コードは以下のように確認できます。 :set ff? 新規ファイルを作成したときの改行コード 新規ファイルを :vi new.txt というように作成する場合、デフォルトの改行コードは fileformats オプションの先頭に記述されたフォーマットになります（末尾に s が付くことに注意）。 例えば、以下のように .vimrc ファイルに記述されていると、新規ファイルの改行コードのフォーマットは UNIX 形式 (NL) になります。 ~/.vimrc set fileformats=unix,dos,mac また、この設定は、既存のファイルを開くときに認識する改行コードのリストとしても使用されます。 DOS 形式 (CR+NL) の改行コードで保存されたテキストファイルを開くとき、fileformats に unix としか設定されていない場合は、unix 形式の改行コードで開かれてしまうので注意してください。 なので、通常は上記のように扱う可能性のある改行コードを列挙しておきます。 エンコーディング形式の変更 現在編集中のファイルのエンコーディング形式を変更するには、 :set fenc=utf-8 :set fenc=euc-jp :set fenc=shift_jis のように現在の fileencoding (fenc) オプションを変更し、:w で保存します。 指定できるエンコーディング形式名の一覧は、:help encoding-values で確認することができます。 新規ファイルを作成したときのエンコーディング形式 fileencoding は、ファイルを保存するときに使用されるエンコーディング形式の設定ですが、新しいファイルを :vi new.txt のように作成する場合のエンコーディング形式としても使われます。 :set fileencoding=euc-jp fileencoding の値が空の場合は、encoding の値が使用されます。 utf-8 に設定しておく場合は、全ての文字を正しく処理できるように、Vim が内部で使用するエンコーディング形式を示す encoding の値も utf-8 に設定しておきましょう。 Vim が内部で使用するエンコーディング形式（encoding は utf-8 に設定すべし） Vim が内部で使用しているエンコーディング形式は encoding に設定されています。 この値は以下のように確認できます。 :set encoding? この値は、デフォルトではシステムのロケール設定をもとに設定されます。 Windows で日本語を使用している場合は、おそらく cp932 (Shift-JIS) になっています。 この状態で、UTF-8 エンコーディングで保存されたテキストを Vim で開くと、Vim は cp932 エンコーディングとして処理しようとするので文字化けが発生することがあります（cp932 で表現できる文字だけを含んでいるファイルなどは正しく処理できたりします）。 Vim に、ちゃんと UTF-8 としてテキストを処理するように指示するには、.vimrc ファイルに以下のように設定しておきます。 set encoding=utf-8 つまり、Vim で UTF-8 のテキストを問題なく開くには、少なくとも encoding が utf-8 に設定されていないといけません。 .vimrc に必ず上のように記述しておきましょう。 encoding が utf-8 に設定されていても、Shitf-JIS や EUC-JP で保存されたテキストファイルはちゃんと開くことができます。 Vim のヘルプを見ると、encoding の設定は、システムデフォルトの値を使用するか、.vimrc ファイルで任意の値を設定するようにすべき、と書いてあります。 ファイルを開いている状態で、:set encoding=utf-8 と動的に変更しようとすると、Vim のメニューなどが文字化けしたりして、正常に動かなくなるので注意してください。 encoding にどのようなエンコーディング形式を指定すべきかは、使用している OS などにも依存します。 ほとんどのケースでは utf-8 に設定しておけばよいでしょう。 ファイルを開くときに認識するエンコーディング形式を指定する 既存のファイルを開くときは、fileencodings に指定したエンコーディングが順番に試されて、ファイルを正常に開けたものが使用されます。 :set fileencodings=ucs-bom,utf-8,default,latin1 ファイルを正常に開けた時点で、そのエンコーディング形式が fileencoding に設定されます（fileencodings ではなくて、s のない fileencoding ということに注意）。 もし、fileencodings に指定したエンコーディング形式のいずれでも正常に開けなかった場合は、fileencoding の値は空に設定されます。 その場合、エンコーディング形式として、encoding に設定された値が使用されます。 注意点: Unicode BOM (Byte Order Mark) を正しく処理するために、ucs-bom は他の Unicode 形式 (utf-8) などより前に指定する必要があります。 latin1 （8-bit encoding) や、cp1250 などは一番最後に指定する必要があります（latin1 でファイルを開くと必ず成功してしまうため）。 default という指定は、encoding に指定したエンコーディング形式を使用することを意味します。 UTF-8、EUC-JP、Shift-JIS のファイルを読み書きできるようにする 様々なエンコーディング形式で保存された日本語ファイルを開くには、下記のように設定しておくのがよいでしょう。 ~/.vimrc set encoding=utf-8 &#34;Vim が内部で使用するエンコーディング形式 set fileencoding=utf-8 &#34;ファイルを新規作成するとき set fileencodings=ucs-bom,utf-8,euc-jp,cp932,latin1 &#34;ファイルを開くとき set fileformats=unix,dos,mac 概要説明 ファイルを新規作成する場合は、fileencoding に指定した値が使われます。 もし、fileencoding を設定していなかったら、encoding の値が使用されます。 ファイルを開くときは、fileencodings に指定したエンコーディング形式が順に試されます（どれにも一致しない場合は、encoding の値が使われます）。 ただし、latin1 では必ずファイルオープンに成功するので、上記のように fileencodings の中に latin1 を指定した場合、encoding に指定した値が使われることはありません。 また、新規ファイルを生成する場合に、デフォルトで使用される改行コードは fileformats の先頭に指定された形式が使用されるので、上記のように fileformats の先頭に unix を指定しておくと、改行コードを LF で揃えられるようになります。"},{url:"/p/qmuxpqp/",title:"Vim で補完機能を使用してテキストを入力する",date:"2008-02-01T00:00:00+09:00",body:"Vim で補完機能を使用してテキストを入力する 前後のテキストから補完候補を探して補完入力する 入力モードでテキストを途中まで入力し、以下のように入力すると、前後のテキストを検索して、一致する文字列を補完入力してくれます。 CTRL-P &#34;前方検索して補完 CTRL-N &#34;後方検索して補完 CTRL-Y &#34;決定 補完候補のテキストは、デフォルトでは以下の場所から順番に検索されます。 カレントバッファ 他のウィンドウのファイル カレントバッファ以外のバッファ アンロードされたバッファ tags ファイル インクルードされているファイル（#include で指定されているファイル） 補完候補の検索先を変更するには、complete オプションを設定します。 :set complete=.,w,b,u,t,i &#34;Default 検索先は、以下のキーを優先順にコンマで区切って指定します。 . カレントバッファから検索 ( &#39;wrapscan&#39; の値は無視) w 別のウィンドウ内のバッファから検索 b バッファリスト内の、現在読み込まれている別のバッファから検索 u バッファリスト内の、現在読み込まれていない別のバッファから検索 U バッファリストにないバッファから検索 k &#39;dictionary&#39; で指定されたファイルから検索 kspell 現在有効化されているスペルチェックを使う k{dict} {dict} で与えられたファイルから検索。&#34;k&#34; を複数指定してもよい。 ファイル名はパターンでも指定できる。例: :set cpt=k/usr/dict/*,k~/spanish s &#39;thesaurus&#39; で指定されたファイルから検索 s{tsr} {tsr} で与えられたファイルから検索。 &#34;s&#34; を複数指定してもよい。 ファイル名はパターンでも指定できる。 i カレントファイルとインクルードされるファイルから検索 d カレントファイルとインクルードされるファイルから、 定義された名前またはマクロを検索 ] タグ補完 t &#34;]&#34; と同じ 詳しくは、:help 'complete' で確認することができます。 補完時に大文字小文字を区別する／しない 補完入力時の検索も、/ による検索と同様に、下記のオプションで大文字・小文字の扱いを設定します。 :set ignorecase &#34;大文字小文字を区別しない :set noignorecase &#34;大文字小文字を区別する（デフォルト） 辞書ファイルに登録された単語を補完入力する (CTRL-X CTRL-K) 単語のリストを含んだ辞書ファイル（単なるテキストファイル）を用意しておき、それを補完候補として扱うことができます。 辞書ファイルによる補完入力を行うには、下記のように辞書ファイルのパスを設定しておきます。 :set dictinary=ファイル名,ファイル名, ... 入力モードで CTRL-X CTRL-K と入力すると、辞書ファイル内の単語を補完入力することができます。 ちなみに、CTRL-X CTRL-P（前方検索）による補完入力時に、辞書ファイル内の単語も検索対象に入れたい場合は、complete オプションに k を指定します（同時に dictionary オプションの方も設定しておく必要があります）。 :set complete=.,w,b,u,t,i,k カレントディレクトリ内のファイル名の補完 (CTRL-X CTRL-F) 入力モードでファイル名を途中まで入力し、 CTRL-X CTRL-F と入力すると、カレントディレクトリ内のファイル名を補完入力することができます。"},{url:"/p/sh79ewb/",title:"Vim でテキストを中央寄せ／左寄せ／右寄せする",date:"2008-01-15T00:00:00+09:00",body:"Vim でテキストを中央寄せ／左寄せ／右寄せする テキストの中央／左／右寄せ 指定した範囲のテキストをセンタリングするには、ex コマンドの :center を使用します。 同様に、右寄せは :right、左寄せは :left で実行できます。 :[range] center [width] :[range] right [width] :[range] left [margin] テキスト幅を示す width オプションを省略した場合は、textwidth の値が使用されます。 textwidth が設定されていない場合は、デフォルトで 80 が使用されます。 :left の場合だけは、左端からのマージンを指定できます。 例: テキスト全体をセンタリング（テキスト幅は 80 とする） :% center 80 例: 1 行目から 5 行目までを右寄せ（テキスト幅は 80 とする） :1,5 right 80 ビジュアルモードで選択した範囲を左寄せ（左端からのマージン 5 文字分） :`&lt;,`&gt; left 5 テキストの両端揃え Vim に付属している justify.vim マクロパッケージを使用すると、テキストの両端揃えを実行できます。 justify.vim は以下のようにロードします。 :source $VIMRUNTIME/macros/justify.vim ビジュアルモードで範囲選択し、以下のコマンドを入力すると、両端揃えが実行されます。 _j"},{url:"/p/zmnwu3z/",title:"Vim で指定した行範囲だけ別のファイルに保存する",date:"2008-01-15T00:00:00+09:00",body:"Vim で指定した行範囲だけ別のファイルに保存する 指定した行範囲を別ファイルに保存 行範囲を指定して :write コマンド（省略形は :w）を使用すると、その範囲だけを抽出して別のファイルに保存することができます。 :[range] write &lt;filename&gt; 例: 行番号で指定した反荷を file.txt に保存 :1,5 w file.txt &#34; 1行目から5行目まで保存 :5,$ w file.txt &#34; 5行目から最後まで保存 :.,10 w file.txt &#34; カレント行から10行目まで保存 :.;+5 w file.txt &#34; カレント行から5行下の行までを保存 :g/^Todo/ w D:\\todo.txt &#34; Todo で始まる行を D:\\todo.txt に保存 ビジュアルモードで選択した範囲を別ファイルに保存 上記は、保存する行範囲を行番号などで指定する方法ですが、実際には次のようにしてビジュアルモードで行範囲を選択してしまうのが早いでしょう。 例: ビジュアルモードで選択した範囲を file.txt に保存 SHIFT-V の行選択モードなどで行を選択 :w file.txt と入力して Enter"},{url:"/p/xr9stqi/",title:"Vim で文字を入れ替える、行を入れ替える（スワップ操作）",date:"2008-01-15T00:00:00+09:00",body:"Vim で文字を入れ替える、行を入れ替える（スワップ操作） 下記は Vim の基本的な編集コマンドの組み合わせ技ですが、使用頻度の高い編集操作なので押さえておきましょう。 文字のスワップ カーソル位置の文字を、1つ後ろの文字と素早く入れ替えるには以下のように実行します。 xp x で一文字削除し、p でその文字を後ろに貼り付け、という操作をしているだけです。 行のスワップ カーソル行を、1つ下の行と素早く入れ替えるには以下のように実行します。 ddp dd で一行削除し、p でその行を下に貼り付け、という操作をしているだけです。"},{url:"/p/iumn4xs/",title:"Vim のビジュアルモードの基本 (v, Shift-v, Ctrl-v)",date:"2008-01-15T00:00:00+09:00",body:"Vim のビジュアルモードの基本 (v, Shift-v, Ctrl-v) ビジュアルモードの開始・終了 ビジュアルモードは、Vim においてテキストの範囲選択を行うためのモードです。 ノーマルモードで下記のようなコマンドを入力することでビジュアルモードに入ることができます。 入力 説明 v ビジュアルモード（文字単位） Shift-v ビジュアルラインモード（行単位） Ctrl-v ビジュアルブロックモード（矩形） ビジュアルモードを抜けてノーマルモードに戻るには、Esc を押すか、何かコマンドを実行します（d で削除するなど）。 コマンドを実行した場合は、選択した範囲に対してコマンドが適用されます。 ビジュアルモードの選択範囲を拡張する カーソル移動で拡張する ビジュアルモードに入った後で o を入力することで、カーソル位置を選択領域の先頭、末尾へ交互に移動することができます。 この状態でカーソルを動かすと、選択領域を自在に伸縮させることができます。 ルールに応じて拡張する ビジュアルモードに入った後で、下記のような操作を行うと、ルールに従って選択範囲を拡張することができます。 入力 説明 ip カーソル位置の段落全体を選択 ap カーソル位置の段落全体を選択（後続の空行も含めて選択） iw カーソル位置の単語全体を選択 aw カーソル位置の単語全体を選択（後続のスペースも含めて選択） i( 括弧 () に囲まれた領域を選択 a( 括弧 () に囲まれた領域を選択（括弧も含めて選択） i{ 括弧 {} に囲まれた領域を選択 a{ 括弧 {} に囲まれた領域を選択（括弧も含めて選択） i[ 括弧 [] に囲まれた領域を選択 a[ 括弧 [] に囲まれた領域を選択（括弧も含めて選択） i&lt; 括弧 &lt;&gt; に囲まれた領域を選択 a&lt; 括弧 &lt;&gt; に囲まれた領域を選択（括弧を含めて選択） 例えば、ビジュアルモードで段落全体（空行で区切られた連続する行）を一気に選択するには、その段落内にカーソルがある状態で ip と入力します。 ノーマルモードから段落全体を選択状態にするには vip と入力すればよいことになります（上のデモアニメを参照）。 「段落選択はビップ」と覚えます。 段落全体を操作対象とする ip は便利なので、是非覚えておきましょう。 他にも下記のようなシーケンスで使用することができます。 dip &#34;段落全体を削除する （vip → d としても同様） yip &#34;段落全体をヤンク（コピー）する （vip → y としても同様） ビジュアルモードに関するヘルプ ビジュアルモードで使用できるコマンドのヘルプを表示するには、そのコマンドのプレフィックスとして v_ を付けて :help コマンドを実行します（参考: Vim の help コマンドの使い方）。 ビジュアルモードの d コマンドのヘルプを表示 :help v_d 同様に、Ctrl-v で入ることのできるビジュアルブロックモードのコマンドのヘルプを表示するには、プレフィックスとして v_b_ を付けます。 ビジュアルブロックモードの r コマンドのヘルプを表示 :help v_b_r 複数行に同じテキストを挿入する 図: 複数行に同じ文字を挿入 Ctrl-v のビジュアルブロックモードで複数行を選択し、Shift-i でテキストを入力すると、その範囲に同じテキストを一気に挿入できます（2 行目以降には Esc を押した段階で挿入されます）。 上記の例では、Java コードの複数行をまとめてコメントアウトしています。 図: 複数行を矩形削除 逆に選択範囲を削除するには、ビジュアルモードで選択した後で、x あるいは d を入力するだけで OK です。"},{url:"/p/r3udg6c/",title:"テキストからシーケンス図を作成するツール (sdedit)",date:"2008-01-10T00:00:00+09:00",body:`テキストからシーケンス図を作成するツール (sdedit) sdedit とは UML 図をグラフィカルに作成することのできるツールはたくさんありますが、シーケンス図のように処理の前後関係を頻繁に入れ替えたくなる図は、逆にグラフィカルなツールでの修正は面倒かもしれません。 Quick Sequence Diagram Editor (sdedit) は、テキストでシーケンスを定義し、画像ファイルとして出力することのできるツールです。 Quick Sequence Diagram Editor - SourceForge Quick Sequence Diagram Editor - GitHub このツール自体はグラフィカルな UI を提供しており、テキストエリアに専用のフォーマットでシーケンスを入力していくと、リアルタイムに図が更新されていきます。 他にも次のような特徴があります。 いろんな画像フォーマットで出力できる。ベクタ形式の EMF で出力して、PowerPoint などにきれいに貼り付けることも可能。 図中のコンポーネントをクリックすると、その定義位置へジャンプできる。 TAB キーで入力補間できる。 日本語も表示可能。 シーケンスの書き方 オブジェクトを定義する Object section と、メッセージのやりとりを定義する Message section を分けて記述していきます。 Object section と Message section は空白行で区切って定義します。 Object section の記述 シーケンス図内に登場させるオブジェクトは、Object section で次のように定義します。 行の先頭を # で始めるとコメント行になります。 # Object section a:ClassA b:ClassB c:ClassC Invisible object オブジェクト定義時にプレフィックスとして /（スラッシュ）を付けると、そのオブジェクトは Invisible object となり、Message section で他のオブジェクトから new されるまで図に表示されなくなります。 逆に、destroy メッセージによって図から削除することができます。 次のコードは、オブジェクト a が b を new し、最後に destroy することを示しています。 # Object section a:ClassA /b:ClassB # Message section a:b.new a:b.DoSomething() a:b.destroy オブジェクト定義時に指定できるフラグ Anonymous フラグ [a] インスタンス名を表示せず、クラス名だけを表示する。 Role フラグ [r] ラベルの下にアンダーラインを引かない。 Process フラグ [p] Actor のような振る舞いをするオブジェクトに対して付ける（描画方法が変わる）。 Auto-destruction フラグ [x] lifeline の最後に×マークを付ける。 例 # Object section a:ClassA[a] アクターの定義 アクターを定義する場合は、クラス名に Actor を指定します。 アクターは常にアクティブで、自分自身にメッセージを送ることができません。 # Object section user:Actor hoge:Hoge # Message section user:hoge.ShowImages() Return メッセージに名前をつける Return メッセージに名前を付けるには、次のようにします。 a:returnValue=b.Hoge() 上記のようにすると、オブジェクト a が b.Hoge() を呼び出し、戻り値として returnValue を受け取ることを表すことができます。 ちょうど、以下のような C++ や Java の関数呼び出しの構文に似ているので分かりやすいです。 returnValue = b.Hoge(); 改行 メッセージ名に改行を入れる場合は \\\\n と入力すれば OK です。 アクティブコメント コメント行を #! で始めると、アクティブコメントとなり、特別な意味を持つようになります。 例: シーケンス図のタイトルを表示 #![Title] 例: シーケンス図の上部にコメントを入力 #!&gt;&gt; #! This is the first line. #! This is the second line. #! This is the third line. #!&lt;&lt; Message section のグルーピング Message section の各パートを以下のように分割することができます。 このように分割されたものをフラグメントと読んでいます。 # Message section [c FragmentName1] a:b.Message1() a:b.Message2() [/c] [c FragmentName2] a:b.Message3() a:b.Message4() [/c] ループ処理 ループ処理などを書きたい場合は次のような感じで記述可能です。 # Message section [c:loop while count &lt; 100] a:b.Message1() a:b.Message2(count) [/c] 条件分岐 フラグメント内に --label という行を挿入すると、そのフラグメントを点線で区切ることができます。 例えば、条件分岐は以下のように記述できます（x==1 のときの処理と else の処理を表現）。 # Message section [c:alt x==1] a:b.Message1() a:b.Message2() --[else] a:b.Message3() a:b.Message4() [/c]`},{url:"/p/qxjtb39/",title:"Vim で省略形を用いたテキスト入力を行えるようにする (abbrevaite)",date:"2007-12-26T00:00:00+09:00",body:"Vim で省略形を用いたテキスト入力を行えるようにする (abbrevaite) 省略形を登録する Vim の :abbreviate (:ab) コマンドを使うと、テキストの省略形を定義することができます。 省略形のテキストを入力して Space や TAB、Enter キーを押すと、自動的に展開してくれます。 :abbreviate ＜省略形＞ ＜展開後のテキスト＞ 例: YT と入力したら、自動的に Yamada Taro に展開 :ab YT Yamada Taro 展開後のテキストの先頭文字が Space の場合 :abbreviate で指定する展開後のテキストの先頭文字に半角スペースを指定する場合は、その半角スペースが Vim に無視されてしまわないように、明示的に &lt;Space&gt; と記述する必要があります。 :ab hghg &lt;Space&gt;HogeHoge 省略形の一覧表示 登録済みの省略形を一覧表示するには、:abbreviate (:ab) コマンドをパラメータなしで実行します。 :abbreviate"},{url:"/p/zneoq8d/",title:"Vim/Neovim で設定ファイル (.vimrc, init.lua) を開く、リロードする",date:"2007-12-26T00:00:00+09:00",body:"Vim/Neovim で設定ファイル (.vimrc, init.lua) を開く、リロードする 設定ファイルを開く Vim の場合 Vim エディタから設定ファイル（.vimrc や .gvimrc）を開くには、下記のようにします（:e は :edit コマンドの省略系です）。 設定ファイルを開く（OS に依存しない方法） :e $MYVIMRC :e $MYGVIMRC 設定ファイルの名前は Linux (.vimrc) と Windows (_vimrc) で微妙に異なりますが、実際に読み込まれた設定ファイルのパスが $MYVIMRC、$MYGVIMRC という変数に格納されているので、上記のようにして OS に依存しない方法で設定ファイルを開くことができます（:echo $MYVIMRC でパスを確認できます）。 明示的にファイルパスを指定して開きたいときは次のようにします。 Vim の設定ファイルを開く（Linux/macOS の場合） :e ~/.vimrc :e ~/.gvimrc Vim の設定ファイルを開く（Windows の場合） :e ~/_vimrc :e ~/_gvimrc Neovim の場合 Neovim の設定ファイル (init.lua or init.vim) を開くには次のようにします。 Neovim の設定ファイルを開く（OS に依存しない方法） :e $MYVIMRC Neovim は、設定ファイルとして init.lua と init.vim のどちらかを使うことができます（init.lua が優先されます）。 実際に読み込まれた設定ファイルのパスが $MYVIMRC に格納されるので、上記のように設定ファイルを開くことができます（:echo $MYVIMRC でパスを確認できます）。 明示的にファイルパスを指定して init.lua または init.vim を開きたいときは次のようにします。 Neovim の設定ファイルを開く（Linux/macOS の場合） :e ~/.config/nvim/init.lua :e ~/.config/nvim/init.vim Neovim の設定ファイルを開く（Windows の場合） :e %USERPROFILE%\\AppData\\Local\\nvim\\init.lua :e %USERPROFILE%\\AppData\\Local\\nvim\\init.vim 参考: Vim/Neovim の設定ファイルのパスを確認する ($MYVIMRC) 設定ファイルをリロードする 設定ファイルを変更した後で、その内容を反映させるには下記のように :source コマンドでそのファイルを読み込みます。 Vim の場合 :source $MYVIMRC &#34; ~/.vimrc のリロード :source $MYGVIMRC &#34; ~/.gvimrc のリロード Neovim の場合、$MYVIMRC が示すパスは、init.lua または init.vim のうち実際に読み込まれたファイルのパスになります。 どちらの場合も :source コマンドで読み込むことができます。 Neovim の場合 :source $MYVIMRC &#34; init.lua あるいは init.vim のリロード ☝️ :luafile コマンド Neovim には Lua スクリプトを読み込むための :luafile コマンドもあります。 こちらは純粋に .lua ファイルしか読み込めないため、Vimscript として記述された init.vim を開こうとするとエラーになります。 :source コマンドを使った場合は、Lua スクリプトが指定された場合に、内部的に :luafile コマンドで読み込んでくれます。 現在編集中の Lua ファイルを実行したいときは、:luafile % とします。 参考 ショートカットキーで設定ファイル (.vimrc, init.lua) を開く"},{url:"/p/7mabuvq/",title:"Vim/Neovim の設定ファイルのパスを確認する ($MYVIMRC)",date:"2007-12-26T00:00:00+09:00",body:"Vim/Neovim の設定ファイルのパスを確認する ($MYVIMRC) 設定ファイルのパスを調べる Vim や Neovim の設定ファイル（やディレクトリ）のパスは、:echo コマンドを使って以下のように確認することができます。 Vim の場合: :echo $MYVIMRC 出力例: C:\\Users\\maku\\_vimrc （Windows の場合） 出力例: /Users/maku/.vimrc （Linux/macOS の場合） :echo $MYGVIMRC 出力例: C:\\Users\\maku\\_gvimrc （Windows の場合） 出力例: /User/maku/.gvimrc （Linux/macOS の場合） Neovim の場合（init.lua と init.vim のうち実際に読み込まれたファイルのパス）: :echo $MYVIMRC or :=vim.env.MYVIMRC 出力例: C:\\Users\\maku\\AppData\\Local\\nvim\\init.lua （Windows の場合） 出力例: /Users/maku/.config/nvim/init.lua （Linux/macOS の場合） また、nvim ディレクトリのパスは、以下のように確認できます。 :echo stdpath('config') 出力例: C:\\Users\\maku\\AppData\\Local\\nvim （Windows の場合） 出力例: /Users/maku/.config/nvim （Linux/macOS の場合） デフォルトのパス デフォルトでは、次のようなファイルパスに置かれた設定ファイルが読み込まれます。 Vim の場合 Windows の場合: %USERPROFILE%/_vimrc （ただし HOME 環境変数が設定されている場合は %HOME%/_vimrc） Linux/macOS の場合: ~/.vimrc Neovim の場合 Windows の場合: %USERPROFILE%\\AppData\\Local\\nvim\\init.vim Linux/macOS の場合: ~/.config/nvim/init.vim Vim/Neovim の設定ファイルは基本的に自分で作成する必要があります。 Neovim の設定ファイル (init.lua) を作成する $ mkdir -p ~/.config/nvim $ touch ~/.config/nvim/init.lua version コマンド Vim の :version コマンドの出力の中央あたりを見ると、起動時に Vim がロードする設定ファイルの一覧を確認することができます。 VIM7.0 (Windows) の :version コマンドの出力（抜粋） ... システム vimrc: &#34;$VIM\\vimrc&#34; ユーザー vimrc: &#34;$HOME\\_vimrc&#34; 第2ユーザー vimrc: &#34;$HOME\\vimfiles\\vimrc&#34; 第3ユーザー vimrc: &#34;$VIM\\_vimrc&#34; ユーザー exrc: &#34;$HOME\\_exrc&#34; 第2ユーザー exrc: &#34;$VIM\\_exrc&#34; システム gvimrc: &#34;$VIM\\gvimrc&#34; ユーザー gvimrc: &#34;$HOME\\_gvimrc&#34; 第2ユーザー gvimrc: &#34;$HOME\\vimfiles\\gvimrc&#34; 第3ユーザー gvimrc: &#34;$VIM\\_gvimrc&#34; デフォルトファイル: &#34;$VIMRUNTIME\\defaults.vim&#34; システムメニュー: &#34;$VIMRUNTIME\\menu.vim&#34; ..."},{url:"/p/96itrdp/",title:"Vim で C/C++ の変数／マクロの定義位置にジャンプする",date:"2007-11-21T00:00:00+09:00",body:"Vim で C/C++ の変数／マクロの定義位置にジャンプする C/C++ の変数／マクロの定義位置にジャンプ 変数にカーソルを当てた状態で、以下のように入力すると、その変数の定義位置にジャンプすることができます。 コマンド 説明 gd ローカル変数の定義位置へジャンプ gD グローバル変数の定義位置へジャンプ 検索の精度はあまり高くありません。。。 C/C++ のマクロの定義を表示／定義位置へジャンプ C/C++ のマクロは次のような感じで定義されます。 #define BUF_SIZE 256 マクロを使用している場所から、そのマクロの定義（上記のコード）を調べるには、マクロ名にカーソルを当てた状態で次のように入力します。 #include されているファイルの内容も検索してくれます。 コマンド 説明 [D マクロの定義を表示（すべての定義を表示） [d マクロの定義を表示（最初の定義のみ） [Ctrl-d マクロの定義位置へジャンプ"},{url:"/p/3hp29j9/",title:"Vim でカーソル位置の単語に対して任意のコマンド（ヘルプなど）を実行する (keywordprg)",date:"2007-11-21T00:00:00+09:00",body:"Vim でカーソル位置の単語に対して任意のコマンド（ヘルプなど）を実行する (keywordprg) Vim で任意のキーワードにカーソルを合わせた状態で SHIFT-K と入力すると、そのキーワードをパラメータにして、keywordprg オプションに設定されたコマンドが実行されます。 keywordprg の初期値は以下のようになっています。 keywordprg オプションのデフォルト値 set keywordprg=man &#34; Unix の場合 set keywordprg=:help &#34; Windows の場合 つまり、Unix の場合は、SHIFT-K と入力するだけでカーソル位置にあるキーワードの man ページを参照することができます。 man ページのセクション番号を指定するには、2 SHIFT-K のように、先にセクション番号を入力します。 どの文字をキーワードとみなすかは、iskeyword オプションに文字コードで設定します。 iskeyword のデフォルト値は下記のような感じになっています。 iskeyword オプションのデフォルト値 set iskeyword=@,48-57,_,128-167,224-235"},{url:"/p/oe94dkh/",title:"Vim/Neovim で自動インデントモードを有効にする (autoindent, smartindent, cindent)",date:"2007-11-16T00:00:00+09:00",body:"Vim/Neovim で自動インデントモードを有効にする (autoindent, smartindent, cindent) Vim の 3 種類のインデントモード Vim には、大きく分けて、以下のようなオートインデント設定があります。 autoindent &hellip; カレント行のインデントをキープする。シンプル。 smartindent &hellip; C-like なプログラミング言語向けの自動インデント。 cindent &hellip; C/Java言語に特化したインデント（smartindent よりも厳密に文法を考慮） Vim/Neovim はファイルタイプに応じて自動的に cident などのインデントモードが有効化されるようになっています（参照: :e $VIMRUNTIME/filetype.lua）。 インデントモードの有効化／無効化 autoindent の有効化 .vimrc/init.vim (VimL) の場合 :set autoindent &#34; autoindent を ON :set noautoindent &#34; autoindent を OFF :set autoindent? &#34; autoindent の設定を確認 (autoindent or noautoindent) autoindent を有効にすると、新しい行を追加したときに、前の行のインデントが引き継がれるようになります。 ただそれだけのシンプルなインデントモードです。 新しい行の追加は例えば、以下のような入力があった場合が対象になります。 o コマンド（あるいは O コマンド） インサートモード時の Enter インサートモードのまま、インデントの量を変えるには CTRL-T、CTRL-D などのコマンドを使用します。 下記は、:help index からのキーマップ説明の抜粋です。 i_CTRL-T: 現在の行に shiftwidth 分のインデントを挿入する。 i_CTRL-D: 現在の行から shiftwidth 分のインデントを削除する。 smartindent の有効化 :set smartindent &#34; smartindent を ON :set nosmartindent &#34; smartindent を OFF :set smartindent? &#34; smartindent の設定を確認 (smartindent or nosmartindent) smartindent は、C-like な言語を編集するときに、下記のようにそれっぽく字下げや字上げを自動化してくれるインデントモードです。 { ごとにインデントを深くし、} ごとにインデントを浅くする。 前の行が cinwords に設定されたキーワードで始まっているときにインデントを深くする（cinwords のデフォルト値は if,else,while,do,for,switch）。 ただし、C 言語風のプリプロセッサのために、# で始まる行はインデント数を 0 にするといった特殊ルールも設定されています。 cindent の有効化 :set cindent &#34; cindent を ON :set noindent &#34; cindent を OFF :set cindent? &#34; cindent の設定を確認 (cindent or nocindent) cindent を有効にしておくと、C/C++ や Java などの言語構文をより厳密に考慮して、非常に賢いインデントを自動で行ってくれます。 例えば、if ブロックを {} で囲まなかった場合に、次の一行だけインデントを深くする、といったことを行ってくれます。 cindent が設定されている場合は、smartindent の設定は無効になります。 cindent の詳しい設定方法は、:help C-indenting で参照できます。 参考 インデント（シフトコマンド）を設定する (shiftwidth, shiftround) インデント用のスペースを入力する（シフトコマンド） (&gt;&gt;, &lt;&lt;, Ctrl-T, Ctrl-D) 選択した範囲を自動インデントする (=)"},{url:"/p/syn3cyx/",title:"GVim 起動時のウィンドウの幅、高さを設定する (columns, lines)",date:"2007-11-14T00:00:00+09:00",body:"GVim 起動時のウィンドウの幅、高さを設定する (columns, lines) GVim を起動したときのウィンドウのサイズは、columns オプション（横幅）と、lines オプション（高さ）で指定します。 単位は半角文字の数です。 起動時に読み込まれる ~/.gvimrc に記述してください（Windows の場合は %HOME%\\_gvimrc）。 set columns=120 &#34;横幅 set lines=60 &#34;高さ"},{url:"/p/9aqzppe/",title:"Python でファイルやディレクトリの名前を変更する (os.rename, os.renames)",date:"2007-11-09T00:00:00+09:00",body:"Python でファイルやディレクトリの名前を変更する (os.rename, os.renames) os.rename / os.renames 関数 os.rename 関数 を使用して、ファイルやディレクトリの名前を変更することができます。 次の例では、src.txt という名前のファイルを dst.txt という名前にリネームしています。 import os try: os.rename(&#39;src.txt&#39;, &#39;dst.txt&#39;) except Exception as e: print(&#39;Error: {0}&#39;.format(e), file=sys.stderr) os.rename 関数は次のようなエラーを発生させる可能性があります。 通常の使用時にも発生し得るものなので、エラーハンドル処理はちゃんと記述しておくことをお勧めします。 FileExistsError &hellip; Windows で dst がすでに存在する場合。 IsADirectoryError &hellip; Unix で、src がファイルで dst が（存在する）ディレクトリの場合。 NotADirectoryError &hellip; Unix で、src がディレクトリで dst が（存在する）ファイルの場合。 OSError &hellip; Unix で、src がディレクトリで dst が（存在する）ディレクトリで、かつ、dst が空でない場合。dst が空のディレクトリであれば、dst へのリネームは成功します（dst に src の中身が移動した状態になる）。 深いディレクトリ階層にファイルを移動させたいときは、os.renames 関数 を使うのが便利です。 os.renames 関数は、移動先のディレクトリが存在しない場合に自動的に作成してくれます。 os.renames(&#34;src.txt&#34;, &#34;aaa/bbb/ccc/dst.txt&#34;) 上記のようにすると、aaa/bbb/ccc というディレクトリ階層を作ってからファイルを移動してくれます。 os.renames ではなく、os.rename を使用した場合は、aaa/bbb/ccc というディレクトリが存在しないときにエラーになります。 例: ファイル名のプレフィックスに日付 (&rsquo;-YYYYMMDD&rsquo;) を付加する 下記のサンプルスクリプトは、ディレクトリ内のすべての .png ファイルのファイル名を変更し、拡張子の前に -20071109 のような日付を表す文字列を挿入します。 例えば、sample.png というファイル名は sample-20071109.png というファイル名に置換されます。 rename.py import glob import os import re import time time_str = time.strftime(&#39;%Y%m%d&#39;) for old_name in glob.iglob(&#39;*.png&#39;): new_name = re.sub(r&#39;(\\.png)$&#39;, &#39;-&#39; + time_str + r&#39;\\1&#39;, old_name) os.rename(old_name, new_name) 実行例（ディレクトリ内に a.png, b.png, c.png がある場合） $ ls a.png b.png c.png $ python rename.py $ ls a-20071109.png b-20071109.png c-20071109.png"},{url:"/p/i3ao6oc/",title:"Vim でカーソル位置にマークしてジャンプしてこれるようにする",date:"2007-10-07T00:00:00+09:00",body:"Vim でカーソル位置にマークしてジャンプしてこれるようにする Vim のマーク機能を使用すると、カーソル位置に a～z、あるいは A～Z のマークを付け、別の場所からそこへジャンプして来ることができるようになります。 マークを付ける m に続けて、1 文字のアルファベットを入力すると、現在のカーソル位置にマークを設定することができます。 入力 説明 ma カーソル位置をローカルマーク a として保存（a～z を使用可能） mA カーソル位置をグローバルマーク A として保存（A～Z を使用可能） マーク用のアルファベットとして 小文字の a～z を使用すると、カレントバッファのみに有効なローカルマーク として設定されます。 大文字の A～Z を使用すると、グローバルマーク（ファイルマーク） として設定されます。 ローカルマークはファイルごとに a～z を使用することができ、グローバルマークは全体で A～Z を共有することになります。 マークを設定した位置へジャンプする 入力 説明 `a ローカルマーク a へジャンプ 'a ローカルマーク a の行頭へジャンプ `A グローバルマーク A へジャンプ 'A グローバルマーク A の行頭へジャンプ ローカルマーク (a～z) を指定してジャンプするときは、カレントバッファで開いているファイルに設定されたローカルマークがジャンプ先のターゲットとなります。 一方、グローバルマーク (A～Z) は、マークしたファイルまで一緒に記録されており、Vim でどのファイルを編集中であっても、そのファイルにジャンプすることができます。 頻繁に使用するファイルに mA でグローバルマークを設定しておけば、'A でそのファイルをいつでも簡単に開けるようになります。 また、ジャンプ元とジャンプ先で行ったり来たりするために、下記のようなジャンプコマンドを使用することができます。 入力 説明 `` バッファ内のジャンプ元へジャンプ '' バッファ内のジャンプ元の行頭へジャンプ マークの一覧を表示する 現在設定されているローカルマークとグローバルマークの一覧を表示するには、次のコマンドを実行します。 :marks 応用: 最近開いていたファイルを開く 前回開いていたファイルは、グローバルマーク 0 を指定してジャンプすることで開けます。 &#39;0 もとのファイルに戻ってきたい場合は、グローバルマーク 1 を指定すると戻ってこれます。 &#39;1 もっと前に開いていたファイルも、:marks コマンドでグローバルマークの番号を確認してジャンプすることができます。 応用: マークを利用した編集 `a と入力するとローカルマーク a へ移動しますが、これと d コマンドを組み合わせて使用すれば、カーソル位置からローカルマーク a までのテキストを削除することができます。 ローカルマーク a までを削除する d`a"},{url:"/p/ym9pa88/",title:"Vim でウィンドウを分割する",date:"2007-10-05T00:00:00+09:00",body:"Vim でウィンドウを分割する Vim のウィンドウを分割すると、複数のファイルの内容を同時に表示しながら作業することができます。 同一ファイル内の 2 か所を表示することもできます。 ウィンドウを分割する 入力 説明 :sp[lit] 上下に分割（編集中のファイルを開く）。Ctrl-w s としても OK :vs[plit] 左右に分割（編集中のファイルを開く）。Ctrl-w v としても OK :new 上下に分割（空のファイルを開く）。Ctrl-w n としても OK :vnew 左右に分割（空のファイルを開く） :sview [file] 閲覧用にファイルを開く。:split → :view としても OK ウィンドウを閉じる 入力 説明 Ctrl-w q ウィンドウを閉じる。最後のウィンドウであれば Vim を終了 (= :quit) Ctrl-w c ウィンドウを閉じる。最後のウィンドウを閉じることはできない (= :close) Ctrl-w o カレントウィンドウ以外を閉じる ウィンドウを切り替える 入力 説明 Ctrl-w w 次のウィンドウへ移動（★最低限これだけ覚えておく） Ctrl-w h 左のウィンドウへ移動 Ctrl-w j 下のウィンドウへ移動 Ctrl-w k 上のウィンドウへ移動 Ctrl-w l 右のウィンドウへ移動 キーシーケンスの 2 番目のキーは、Ctrl キーを押しながら入力することもできるようになっています。 例えば、Ctrl-w w と入力する代わりに、Ctrl-w Ctrl-w と入力しても OK です。 ウィンドウサイズの変更 入力 説明 &lt;NUM&gt;z 指定した行数にウィンドウサイズを変更 Ctrl-w = すべて同じサイズにする（★これが基本） Ctrl-w + ウィンドウを縦に大きくする Ctrl-w - ウィンドウを縦に小さくする Ctrl-w _ ウィンドウを縦に最大化 Ctrl-w &gt; ウィンドウを横に大きくする Ctrl-w &lt; ウィンドウを横に小さくする Ctrl-w | ウィンドウを横に最大化 ウィンドウサイズを大きくするときに、先に数値を入力すると、何行大きくするかを指定できます。 例: 現在のウィンドウを 3 行分大きくする 3 Ctrl-w + ウィンドウサイズを最大化したい場合は、実際にはカレントウィンドウ以外を閉じたいことが多いです。 その場合は、Ctrl-w o で他のウィンドウをすべて閉じることができます。"},{url:"/p/6aycfga/",title:"Vim でファイル名を指定してファイルを開く (:e, :edit, :view)",date:"2007-10-05T00:00:00+09:00",body:"Vim でファイル名を指定してファイルを開く (:e, :edit, :view) ファイル名を指定してファイルを開く Vim で :edit コマンド（:e と省略可）を使用すると、指定した名前のファイルをカレントバッファで開くことができます。 hoge.txt を開く :e hoge.txt :edit hoge.txt 別のファイルを開く前に、カレントバッファで開いているファイルの編集内容を :w で保存しておく必要があります。 現在の編集を破棄して別のファイルを開きたい場合は、コマンドの後ろに ! を付けて実行します。 :e! hoge.txt :edit! hoge.txt 読み取り専用でファイルを開く :edit コマンドの代わりに、:view コマンドを使用してファイルを開くと、読み取り専用（ReadOnly モード）でファイルを開くことができます。 :view hoge.txt ファイルを開くときは :e コマンドで代用してしまうことが多いので、:view コマンドを使用することはあまりないかもしれません。 ☝️ ワンポイント :edit コマンドは :e と 1 文字まで省略することができますが、:view コマンドは :vie までしか省略できません。 詳しくは、:help :view&lt; でヘルプを確認してみてください。"},{url:"/p/3r6ds3r/",title:"make を使いこなすためのメモ",date:"2007-06-29T00:00:00+09:00",body:"make を使いこなすためのメモ make の種類あれこれ 一番よく使用されているのは GNU make ですが、いろいろな亜種があります。 System V make Stuart I. Feldman によって作成されたオリジナルの make です GNU make Linux の世界で一般的に使用されている make です Implemented by Richard Stallman and Roland McGrath. Development since Version 3.76 has been handled by Paul D. Smith. Microsoft 版 nmake Microsoft C コンパイラ ver. 6.0A に付属 Borland 版 make Borland Turbo C++ コンパイラ ver.2 に付属 参考: MAKE の達人 (1992) Makefile に記述する rule のフォーマット Makefile には、下記のようなフォーマットで rule を記述していきます。 targets : prerequisites command ... あるいは、 targets : prerequisites ; command command ... それぞれ、下記のような内容を記述していきます。 targets 更新（あるいは作成）する対象となるファイルを指定します。複数のファイル名を指定する場合はスペースで区切ります。ワイルドカードを使ってファイル名を指定することもできます。 prerequisites targets の更新（あるいは作成）に必要なファイル郡を指定します。複数のファイル名を指定する場合はスペースで区切ります。ワイルドカードを使ってファイル名を指定することもできます。 command targets を更新（あるいは作成）するためのコマンド郡を指定します。command 行は必ず TAB で始めること。複数のコマンドを指定する場合は、次の行に記述するか、セミコロン (;) で区切ります。 上記のような target の処理内容をまとめて rule と呼びます。 １つの target を複数の rule に分けて記述することも可能ですが、そのような書き方は見通しが悪くなるため、おすすめはできません。 make コマンドの振る舞い target ... : prerequisites ... command ... make コマンドを実行したとき、上記のように指定された command は以下のようなルールで実行されます。 target を指定せずに make を実行すると、Makefile の最初に出てくる target を処理する（ドット (.) で始まる target を除く）。この target のことを default goal と呼ぶ。 target に指定したファイルが存在しない場合、あるいは、target が prerequisites に指定したファイルより古い場合は command が実行される。prerequisites は空でもよく、その場合は、target と同じ名前のファイルがない場合だけ command が実行される。 prerequisites に指定したものと同じ名前の target がある場合は、その target を先に評価する。 Makefile の例 app : main.o util.o cc -o app main.o util.o main.o : main.c util.h cc -c main.c util.o : util.c util.h cc -c util.c .PHONY : clean clean : rm app main.o util.o Variables（変数）を使用する Makefile 内に同じ内容を何度も記述しなければいけない場合は、その内容を変数に入れておくことで簡潔に記述できるようになります。 例えば、オブジェクトファイル (.o) のリストはよく、objects、OBJECTS、objs、OBJS、obj、OBJ といった名前の変数で表現されます。 OBJECTS = obj1.o obj2.o obj3.o 変数の内容を取り出すには、$(OBJECTS) のように参照します。 Variables（変数）を使った Makefile の例 objects = main.o util.o app : $(OBJECTS) cc -o app $(OBJECTS) main.o : main.c util.h cc -c main.c util.o : util.c util.h cc -c util.c .PHONY : clean clean : rm app $(OBJECTS) オブジェクトファイル (.o) を作る rule の省略記法 ソースファイル util.c、util.h をコンパイルして util.o ファイルを作る rule を記述する場合、implicit rules（暗黙のルール） を使用して rule 記述を省略することができます。 ここでは、prerequisites から .c ファイルの記述を省略し、command の記述を省略することができます。 例えば、 util.o : util.c util.h cc -c util.c このような rule は、implicit rules によって以下のように 1 行で記述することができます。 util.o : util.h 長めのサンプル OBJECTS = main.o util.o app : $(OBJECTS) cc -o app $(OBJECTS) main.o : main.c util.h cc -c main.c util.o : util.c util.h cc -c util.c これを、以下のように省略して記述することができます。 OBJECTS = main.o util.o app : $(OBJECTS) cc -o app $(OBJECTS) main.o : util.h util.o : util.h main.o と util.o は同じ prerequisites（ここでは util.h）を持つので、一行にまとめて以下のようにも書けます。 ただし、このように target をまとめることを好まない人もいます。 OBJECTS = main.o util.o app : $(OBJECTS) cc -o app $(OBJECTS) $(OBJECTS) : util.h Makefile の名前 GNU make は、以下の順番で Makefile を探します。 GNUmakefile（GNU make 以外の make はこのファイルを検索しない） makefile Makefile（推奨） GNU make のマニュアルでは、Makefile という名前にすることを推奨しています。 これは、ディレクトリ内のファイルリストを表示したときに、比較的前の方に表示され、README ファイルの近くに表示される可能性が高いからです。 別の Makefile を include する include の構文 下記のような構文を使用すると、Makefile の中から別のファイルをインクルードすることができます。 include filenames... ファイル名にはシェルのファイル名パターンを使用することができます。 include *.mk ファイル名の中で変数 (variable) や関数 (function) を参照すると、展開されてからファイルを検索します。 HOGE = foo.mk bar.mk include $(HOGE) include される Makefile の検索パス インクルードする Makefile を相対パスで指定した場合、以下のような順番で検索されます。 カレントディレクトリ -I または --include-dir オプションで指定したディレクトリ &lt;prefix&gt;/include（通常は /usr/local/include） /usr/gnu/include /usr/local/include /usr/include インクルードする Makefile が見つからなかったときのエラーを抑制する デフォルトでは、インクルードしようとしたファイルが見つからなかったときはエラーになります。 ファイルが見つからなかった場合にエラーを出さないようにするには、include の前にハイフンを付けて、-include と記述します。 -include filenames... GNU make 以外の make 実装では、-include の代わりに sinclude を使用するものもあります。 どんなターゲット名にも一致する % all: @echo all %: @echo % 上記のように、ターゲット名に % を指定すると、任意のターゲット名に一致するものとみなされます。 $ make ⇒ ターゲット all を実行 $ make all ⇒ ターゲット all を実行 $ make hoge ⇒ ターゲット % を実行 make の２フェイズ処理（変数の展開順序について） make コマンドが Makefile を処理するとき、次のように 2 フェイズに分けて処理されます。 Read-in phase (1st phase): make を実行すると、最初に Makefile の内容をすべて読み込み（インクルードしたファイルもすべて）、各ルールの依存関係や、変数の値などを内部に保持します。 Target-update phase (2nd phase): 1st phase で構築された内部構造を用い、各ルールを処理します。 この知識は、Makefile 内で変数がどのような順序で展開されるかを理解するために必要になってきます。 例えば、以下のような Makefile を実行すると、 FOO = 100 all: @echo $(FOO) FOO = 200 Read-in phase では $(FOO) の値は展開されず、echo コマンドが実行される Target-update phase で $(FOO) の値が展開されるため、echo される値は 200 となります。 変数の展開タイミングは、Makefile 内のどの位置で変数が使われているかによって変わってきます。 以下は、Makefile 内で記述できるフォーマットを羅列したものですが、この中の &lt;immediate&gt; と書かれた部分は、1st phase で展開される（その時点で格納されている値が使用される）ことを表しています。 &lt;deferred&gt; と書かれた部分は、1st phase では展開されない（Makefile を最後まで読んで再帰的に展開される）ことを表しています。 &lt;immediate&gt; = &lt;deferred&gt; &lt;immediate&gt; ?= &lt;deferred&gt; &lt;immediate&gt; := &lt;immediate&gt; &lt;immediate&gt; += &lt;deferred&gt; or &lt;immediate&gt; （右辺に指定した変数が := で作成されたものなら &lt;immediate&gt; となる） define &lt;immediate&gt; &lt;deferred&gt; endif &lt;immediate&gt; : &lt;immediate&gt; ; &lt;deferred&gt; &lt;deferred&gt; ワイルドカードを使う rule の定義にワイルドカードを使う target や prerequisite の指定には、Bourne シェルのワイルドカードを使用することができます。 command でワイルドカードを使うと、そのコマンドを実行するシェルによって展開されます。 * &hellip; 任意の文字列 ? &hellip; 任意の 1 文字 ~ &hellip; ホームディレクトリ（Windows の場合は HOME 環境変数の値） ~john &hellip; john のホームディレクトリ ワイルドカードを使った Makefile の例 clean: rm -f *.o 変数の定義にワイルドカードを使う 変数を定義するときにワイルドカードを展開したい場合は、wildcard 関数を使用します。 例えば、 OBJECTS = *.o とすると、OBJECTS の値は *.o のままになります。 この *.o を展開したものを OBJECTS に代入したい場合は、次のように記述する必要があります。 OBJECTS := $(wildcard *.o) 右辺の関数やワイルドカードを代入時に展開するために、代入演算子として = ではなく、:= を使用している点に注意してください。 ワイルドカードのエスケープ ファイル名の中に * を含むものを指定したい場合は、バックスラッシュ (\\) でエスケープします。 foo\\*.c ==&gt; &#39;foo*.c&#39; というファイル名を示す このエスケープ処理は、Windows のパス指定でバックスラッシュ (/) を含む場合にしばしば問題になります。 例えば、C:\\foo ディレクトリの下の .cpp ファイルをワイルドカードで示したい場合に、 C:\\foo\\*.cpp のように記述すると、アスタリスク (*) をエスケープしようとして、C:\\foo*.cpp というファイルを表すことになってしまいます。 この問題を避けるためには、Windows のディレクトリ・セパレータとして、Unix と同様にスラッシュ (/) を使用するようにします。 C:/foo/*.cpp Prerequisites の検索パスを追加する (VPATH, vpath) VPATH 変数 target や prerequisites の検索パスを追加したい時は、VPATH 変数にディレクトリのパスを設定します。 複数のパスを指定したい場合は、コロン (:) かスペースで区切って指定します（Windows の場合はセミコロン (;) で区切ります）。 カレントディレクトリはデフォルトで検索するので、指定する必要はありません。 VPATH = src:../headers 上記のように設定すると、 foo.o : foo.c というルールを処理するとき、カレントディレクトリで foo.c が見つからない場合、src/foo.c が検索され、さらに見つからない場合に ../headers/foo.c が検索されるようになります。 ファイルの種類ごとに検索パスを追加する vpath ディレクティブ vpath ディレクティブを使用すると、ファイル名に応じて別々の検索パスを設定することができます。 例えば、 vpath %.h ../headers vpath %.cpp src vpath % hoge このようにすると、拡張子が .h のファイルの検索パスとして ../headers ディレクトリが追加され、拡張子が .cpp のファイルの検索パスとして src ディレクトリが追加されます。 さらに、すべてのファイルの検索パスとして hoge ディレクトリが追加されます。 ディレクトリパスは VPATH の場合と同様に、コロンで区切って複数指定することができます。 検索の順序は vpath ディレクティブの呼び出し順序に従います。 例えば、 vpath %.cpp foo:bar vpath %.cpp hoge と指定すると、.cpp ファイルが、カレントディレクトリ ⇒ foo ⇒ bar ⇒ hoge の順番で検索されます。 検索パスをクリアしたい場合は、ディレクトリパスを指定せずに vpath ディレクティブを呼び出します。 vpath % # すべてのファイルの検索パスを削除 vpath %.cpp # .cpp ファイルの検索パスを削除 prerequisites で指定したファイルを command 行で参照するマクロ ($^, $&lt;) command 行で $^ を使用すると、prerequisites で指定したすべてのファイル名に展開されます。 app : a.cpp b.cpp c.cpp g++ $(CXXFLAGS) $^ -o $@ 上記のように記載すると、下記のように展開されます。 $^ ⇒ a.cpp b.cpp c.cpp $@ ⇒ app command 行で $&lt; を使用すると、prerequisites で指定した最初のファイル名に展開されます。 foo.o : foo.cpp foo.h defs.h g++ -c $(CXXFLAGS) $&lt; -o $@ $&lt; ⇒ foo.cpp $@ ⇒ foo.o $^ の ^ という記号が上を指す矢印、$&lt; の &lt; という記号が左を指す矢印だと考えると覚えやすいです。 リンクライブラリの検索パス prerequisistes に -l&lt;name&gt; という形式でリンクライブラリを指定しておくと、lib&lt;name&gt;.so、あるいは lib&lt;name&gt;.a が検索されます。 例えば、 foo : foo.c -lcurses cc $^ -o $@ とすると、以下の順番で libcurses.so ファイルが検索されます。 カレントディレクトリ vpath に設定したディレクトリ VPATH に設定したディレクトリ /lib /usr/lib &lt;prefix&gt;/lib （通常は /usr/local/lib） libcurses.so ファイルが見つからなかった場合は、上記の順で libcurses.a ファイルが検索されます。 prerequisites に -l&lt;name&gt; と指定した場合に、どんな名前のファイルを検索するかは、.LIBPATTERNS 変数に設定されたパターンによって決められます。 デフォルトでは次のような値に設定されています。 .LIBPATTERNS = lib%.so lib%.a よって、-lcurses と指定したときに、libcurses.so と libcurses.a ファイルが検索されることになります。 .PHONY ターゲットの役割 clean: rm *.o temp というルールが設定されているとき、通常は $ make clean と実行すると、rm コマンドが実行されます。 ただし、上記のルールは、基本的には clean というファイルを作成するためのルールとみなされるので、カレントディレクトリに clean というファイルが存在する場合は rm コマンドが実行されなくなってしまいます。 カレントディレクトリに clean というファイルが存在する場合でも rm コマンドを実行するようにするには、.PHONY ターゲットの prerequisites に clean を指定するようにします。 .PHONY: clean clean: rm *.o temp .PHONY ターゲットに記述しておくことで、ファイル検索にかかる時間を省略できるというメリットもあります。 「ターゲット名＝ファイル名」でないときは、.PHONY ターゲットに指定しておくとよいです。 .PHONY ターゲットが使用できない make 実装の場合は、空のターゲット FORCE を用意して以下のようにするのが慣例となっています。 clean: FORCE rm $(OBJECTS) FORCE: make コマンドのパラメータで make 変数を定義する make コマンドを実行するときのパラメータで、make 変数を定義することができます。 次のサンプルは、HOGE という make 変数の値を、コマンドラインパラメータで指定する例です。 Makefile HOGE= all: @echo $(HOGE) 実行例 $ make HOGE=aaa aaa Makefile 内で定義された変数の値は、make コマンドのパラメータで上書きされます。 Makefile HOGE=100 all: @echo $(HOGE) 実行例 $ make 100 $ make HOGE=200 200 Static Pattern Rules: target 名から prerequisites を自動構成するためのルール Static Pattern Rules の構文 targets ...: target-pattern: prereq-patterns ... commands ... targets では、通常のルールと同様にワイルドカードを使用することができます。 target-pattern には、一つの % を含めることができ、targets に指定したファイル名の一部にマッチするように指定します。 Static Pattern Rules の例 OBJECTS = foo.o bar.o all: $(OBJECTS) $(OBJECTS): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 上記の例では、foo.o がターゲットになったとき、target-pattern の %.o に一致します。 この場合 % に一致する部分文字列は foo であり、自動的に foo.c という prerequisite が構成されます。 この % に一致した部分文字列のことを stem と呼びます。 この Static Pattern Rule により、自動的に以下のような foo.o、bar.o の構築ルールが生成されます。 foo.o: foo.c $(CC) -c $(CFLAGS) foo.c -o foo.o bar.o: bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o Static Pattern Rules の command で stem を参照する bigoutput littleoutput: %output: text.g generate text.g -$* &gt; $@ command 行で stem（% に一致した部分文字列）を参照するには $* を使用します。 上記の Static Pattern Rule では、$* の部分に big, little という文字列が展開されるので、結果として以下のように解釈されます。 bigoutput: text.g generate text.g -big &gt; bigoutput littleoutput: text.g generate text.g -little &gt; littleoutput command 行のあれこれ コマンド行の解釈に使用されるシェル コマンドの解釈はデフォルトでは /bin/sh が使用されます。 all: @echo $$SHELL # shell 変数 @echo $(SHELL) # make 変数 実行例 $ make /bin/sh /bin/sh コマンドの解釈に使用するシェルを変更するには、make 変数の SHELL を設定します。 SHELL = /bin/bash all: @echo $$SHELL # shell 変数 @echo $(SHELL) # make 変数 実行例 $ make /bin/bash /bin/bash MS-DOS, Windows の場合の make 変数 SHELL の解釈について MS-DOS, Windows 版の make ではデフォルトのシェルとして COMSPEC 環境変数に設定されているものが使用されます。 SHELL 変数に Unix 形式のパスでシェルを指定すると、以下のようにシェルの実行ファイルが検索されます。 指定されたパス通りのファイル（SHELL = /bin/sh とした場合、カレントドライブが C: の場合は C:\\bin\\sh） カレントディレクトリのファイル PATH 環境変数に指定されたディレクトリにあるファイル 完全にファイル名が一致するファイルがない場合、実行可能な形式のファイルが検索されます（.exe, .com, .bat, .btm, .sh）。 以上のようなルールにより、SHELL = /bin/sh と指定しておけば、PATH の通ったディレクトリに、sh.exe があればそれが使用されます。 command 行間の空白行、コメントについて 2 つのコマンド行の間の空白行や、make のコメント行は無視されます。 all: @echo 100 @echo 200 # Comment for make. @echo 300 上記の Makefile を使って make コマンドを実行すると、以下のように表示されます。 $ make 100 200 300 行頭がタブ文字で始まっている場合は、その後ろが空白であったとしても、必ずシェルによって処理されます。 例えば、 all: @echo 100 [TAB] @echo 200 # Comment for shell. @echo 300 とすると、シェルに空白行と、コメント行が渡されることになります。 ただし、/bin/sh は渡された空白行とコメント行を無視するので、実際には何も実行されていないかのように見え、先の例と結果は同じになります。 $ make 100 200 300 コマンド行での make 変数の展開について コマンド行の変数は Makefile を全て読んだ後に展開されます。 ただし、リビルド対象となったターゲットのコマンドに出てくる変数のみ展開されます。 HOGE = aaa all: @echo $(HOGE) HOGE = bbb $ make bbb コマンド行でのシェル変数の展開について コマンド行でシェル変数を使用するときは、make 変数を参照するときの $ 記号と区別するために、変数名の前に $$ を付けるようにします（$$ を２つ並べることで、$ がエスケープ処理されて、シェルコマンド本来の $ 記号の振る舞いをするようになります）。 LIST = one two three all: for i in $(LIST); do \\ echo $$i; \\ done command 行は各行ごとにサブシェルで実行されるので、上記のような for ループは、必ずバックスラッシュ (\\) で各行を連結させる必要があります。 コマンド行は各行ごとにサブシェルで実行される コマンド行は各行ごとにサブシェルか起動されて実行されます。 たとえ cd コマンドでカレントディレクトリを変更したとしても、次のコマンド行にはそのカレントディレクトリを引き継ぐことができません。 all: cd hoge pwd # hoge ディレクトリではない この問題に対処するには、&amp;&amp; 演算子でコマンドを繋いでひとつのコマンド行にまとめてやる必要があります。 all: cd hoge &amp;&amp; pwd # pwd コマンドは hoge ディレクトリで実行される 注）MS-DOS ではカレントディレクトリがグローバルに保持されるため、上記のようにコマンドをまとめなくても cd コマンドの結果が次のコマンド行にも反映されます。 コマンドの実行でエラーが出ても処理を継続する command の実行でエラー（終了ステータスが 0 以外）が発生した場合、make はそれ以降の command を実行しないで終了します。 command の実行でエラーが発生しても処理を継続するには、command の前に - を付けます（この - はシェルに command 行が渡される時に削除されます）。 例えば、mkdir コマンドは、既にディレクトリが存在する場合にはエラーで終了しますが、このエラーによって make の処理を終了しないようにするには以下のように記述します。 all: -mkdir hoge @echo Hello rm コマンドなども同様です。 clean: -rm -f *.o すべてのコマンドのエラーを無視するようにするには、make を実行するときのパラメータに -i (--ignore-erros) を指定するか、スペシャルターゲットの .IGNORE を prerequisites を指定せずに Makefile の中に記述します。 ただし、それぞれのコマンドの振る舞いを明確にするために - を使うことが推奨されています。 複数の prerequisites を処理している最中に、command の実行エラーが発生した場合に、残りの prerequisites の target の処理を継続させるには -k (--keep-going) オプションを指定して make を実行します。 再帰 make (recursive make) 再起 make とは コマンド行で make コマンドを実行することで、再帰的に make を実行することができます。 例えば、大きなプロジェクトでは、ディレクトリごとに Makefile を置き、サブシステムごとのビルド方法を定義します。 subsystem: cd subdir &amp;&amp; $(MAKE) あるいは subsystem: $(MAKE) -C subdir MAKE 変数は、トップレベルの Makefile を読み出した make のパスに置き換えられます。 make コマンドを -t (--touch) オプションを付けて起動した場合は、通常 command 行は処理されませんが、command 行に、上記のように $(MAKE) が含まれている場合、例外として command 行が処理されることになっています。 この例外的処理のおかげで、make -t を実行した場合でも、再帰的な make 呼び出しを正しく実行することができます。 ちなみに、$(MAKE) のない command 行でも、先頭に + 記号を付けることで処理のスキップを避けることができます。 つまり、再帰 make において、make コマンドを実行するときは、以下のような理由で $(MAKE) を指定するべきだと言えます。 すべての make 処理で同一の make コマンドを利用できる（トップレベルで起動した make）。 make のオプションで -t、-n、-q を指定した場合にも、再帰 make 呼び出しを正しく実行することができる。 再帰 make で sub-make に変数の値を渡す デフォルトでは、呼び出し側の Makefile で定義した変数の値は、sub-make 側に渡されません。 sub-make に対して変数の値を公開するには、export ディレクティブを使用します（各 command への export ではなく、あくまで sub-make への export です）。 export &lt;variable&gt; ... export ディレクティブでは、値の代入を同時に行うことができます。 Makefile export HOGE = 100 all: $(MAKE) -f sub.mk sub.mk all: @echo $(HOGE) export の処理は、変数の定義と同様に Makefile の呼び出し時に行われます。 よって、command 行よりも後ろに export が記述されている場合も、その定義は有効になります。 すべての変数を sub-make 側に渡すには、パラメータなしで export を実行します。 このとき、特定の変数の内容だけ渡さないようにするには unexport ディレクティブを使用します。 export unexport FOO BAR make 実行時に、コマンドライン・パラメータとして指定した変数は、デフォルトで sub-make にも引き渡されます。 これらのパラメータは、内部的に MAKEFLAGS という変数に保持されています。 例えば、 $ make -k HOGE=100 のように実行すると、$(MAKEFLAGS) の値は k -- HOGE=100 のような感じで、make が内部的に理解しやすい形に変換されて保持されます。 オプションの性質上、MAKEFLAGS 変数に保持されないパラメータもあります（-C、-f、-o、-W など）。 sub-make に対して、コマンドライン・パラメータを渡さないようにするには、以下のように MAKEFLAGS の値を空にします。 subsystem: cd subdir &amp;&amp; $(MAKE) MAKEFLAGS= 似たような変数に、コマンドラインで指定したオプションのみを参照する MFLAGS 変数や、コマンドラインで指定した変数定義のみを参照する MAKEOVERRIDES 変数などがありますが、これらは互換性のために残されており、MAKEFLAGS 変数の使用が推奨されています。 Makefile の中で、MAKEFLAGS 変数にオプションを追加して make の振る舞いを変更することもできますが、大きく動作が変わるようなオプションを指定することは避けるべきです。 top-level の make か sub-make かを調べる 再帰 make において、何階層目の sub-make かを調べたいときは、MAKELEVEL 変数を参照します。 トップレベルの make では、この値は 0 になります。 all: ifeq ($(MAKELEVEL), 0) @echo top-level make. else @echo not top-level make. endif 複数の command 呼び出しをまとめて使いまわす (Canned Command Sequences) define - endef ディレクティブを使用すると、複数のコマンド呼び出しをひとつにまとめることができます (Canned Command Sequence)。 ここで定義する command 行は、TAB 文字で初まっている必要はありません。 command 行の中で使用した変数は、実際に command が実行されるときに展開されます。 定義した Canned Command Sequence は、複数のターゲットで使いまわすことができます。 Makefile define greet-and-print-target echo Hello. @echo Target is $@. endef all: $(greet-and-print-target) 実行例 $ make echo Hello. Hello. Target is all. Canned Command Sequence の呼び出し時に、@ などのプレフィックスを付けた場合、すべての command 行にプレフィックスを付けた場合と同様の効果が現れます。 all: @($greet-and-print-target) $ make Hello. Target is all. Makefile 内での条件分岐 (Condtional Parts) Makefile の中で ifeq ディレクティブや ifneq ディレクティブを使用すると、変数同士の比較や、変数と文字列の比較を行って処理を分岐させることができます。 HOGE = aaa all: ifeq ($(HOGE), aaa) @echo matched. else @echo not matched. endif これらの条件分岐は、もちろん command 行以外でも使用できます。 ifeq ($(DEBUG), 1) LIBS = $(LIBS_FOR_DEBUG) else LIBS = $(LIBS_FOR_RELEASE) endif 上記の例では、変数定義部で分かりやすいようにインデントしています。 command 行以外でのインデントには、TAB 文字ではなく、半角スペースを使う ようにしてください。 TAB 文字を使用すると、command 行だとみなされてしまいます。 ifeq の構文としては、下記のいずれかを使用することができます。 ifeq (arg1, arg2) ifeq &#39;arg1&#39; &#39;arg2&#39; ifeq &#34;arg1&#34; &#34;arg2&#34; ifeq &#39;arg1&#39; &#34;arg2&#34; ifeq &#34;arg2&#34; &#39;arg2&#39; ifeq の代わりに、ifneq を使用すると、2 つの引数が一致していないことを調べることができます。 ifneq ($(HOGE), aaa) @echo Not matched. else @echo Matched. endif 変数の内容が空かどうかを調べるには以下のようにします。 この例では、strip 関数により、空白文字を削除してから変数の値が空かどうかをチェックしています。 ifeq ($(strip $(HOGE)),) @echo Empty. else @echo Not empty. endif 条件チェックは Makefile を読み込むときに行うので、変数の定義のタイミングによって動作が変化します。 Makefile HOGE = 1 all: ifeq ($(HOGE), 1) @echo Hoge is one. endif HOGE = 2 実行結果 $ make Hoge is one. 条件文での OR や AND バージョン 3.81（2006/04 リリース）からは、AND 条件や OR 条件を表現するための、$(and) や $(or) が使えるようになったようです。 それ以前のバージョンだと、ifeq や ifdef をネストしてがんばります。 参考: 2006-09-03 - bopperjp の日記 GNU Make document (Ver. 3.81) を読むと、 条件 ... else 条件 ... else ... endif のように else if できるように書いてありますが、少なくとも Ver. 3.79.1 ではうまく動きませんでした。 else の後ろにさらに条件を書こうとすると、 $ make Makefile:5: Extraneous text after `else&#39; directive Makefile:7: *** only one `else&#39; per conditional. Stop. みたいなエラーになってしまいます。 変数の詳細 基本 GNU make 以外の make では、変数のことをマクロと呼んでいるものもあります。 変数の値を参照するときは、$(foo) あるいは、${foo} のように記述します。 変数展開は Makefile の読み込み時に行われますが、command 行に記述された変数は、command が実行される段階で展開されます。 変数名は C 言語と同様、大文字／小文字が区別されます。 変数名は伝統的に大文字だけで構成されることが多いのですが、GNU make のマニュアルでは、ユーザ定義の変数は小文字だけで構成することを推奨しています。これは、implicit rule で使用される変数や、コマンドのオプションを定義するために用意されている変数と区別しやすくするためです。 例: 変数のデフォルト値を確認してみる .PHONY: all all: @echo CC = $(CC) @echo CFLAGS = $(CFLAGS) @echo CXX = $(CXX) @echo CXXFLAGS = $(CXXFLAGS) 実行結果 $ make CC = cc CFLAGS = CXX = g++ CXXFLAGS = 変数の定義 変数を定義するときに他の変数の値を参照する場合、その展開方法が大きく分けて２種類あります。 展開方法は変数代入時に使用する演算子などで決定されます。 1 つ目の展開方法は、Recursively expanded variable（再帰展開変数） です。 = 演算子や、define を使って変数を定義する場合、右辺の変数は再帰的に展開が行われます。 つまり、Makefile を最後まで処理して、右辺の変数の値が最終的にどのような値になるかが決定されます。 Makefile a = $(b) b = $(c) c = foo c = bar all:; @echo $(a) 実行結果 $ make bar 変数が再帰的に展開されるため、次のように自分自身を参照しようとするとエラーになります。 Makefile a = foo a = $(a) bar all:; @echo $(a) 実行結果 $ make Makefile:4: *** Recursive variable `a&#39; references itself (eventually). Stop. 2 つ目の展開方法は、Simply expanded variables（単純展開変数） です。 := 演算子を使用して変数を定義すると、代入時に格納されている値が、参照結果として使用されます。 一般的な手続き型のプログラム言語の変数定義ような感覚で使用することができます。 Makefile a := foo b := $(a) a := bar all:; @echo $(b) 実行結果 $ make foo 当然、まだ定義されていない変数を参照すると、その中身は空っぽです。 Makefile a := $(b) all:; @echo $(a) 実行結果 $ make 変数が未定義のときのみ定義する Conditional variable assignment (?=) ?= 演算子を使うと、その変数がまだ未定義のときのみ値を代入（定義）することができます。 例1: 変数がすでに定義されているケース a = 100 a ?= 200 all:; @echo $(a) 実行結果 $ make 100 例2: 変数が未定義のケース a ?= 200 all:; @echo $(a) 実行結果 $ make 200 ?= による代入は、以下のような条件文と同様の効果を持ちます。 ifeq ($(origin FOO), undefined) FOO = bar endif 変数に空文字が代入されている時は、その変数は未定義であるとはみなされません。 Makefile a = a ?= 100 all:; @echo $(a) 実行結果 $ make 100 変数のサフィックスを置換して展開する (Substitution References) $(var:aaa=bbb) という書式で変数を参照すると、変数中の文字列の aaa が bbb に置換されて展開されます。 ただし、変換されるのは、文字列の末尾、あるいは空白文字の直前の aaa だけです。 例 foo := a.o b.o c.o.o bar := $(foo:.o=.c) all:; @echo $(bar) 実行結果 $ make a.c b.c c.o.c c.o.o の末尾の .o だけが .c に変換されているところに注目です。 変数の値の最後の空白は strip されない 変数を = や := で定義するとき、= の直後の空白は無視されますが、行末の空白スペースは変数の値として格納されます。 hoge = aaa # 3 spaces とすると、$(hoge) の値は、aaa___（_はスペース）となります。 行末に意図的にスペースを入れたい場合は、上記のように行末にコメントを入れることで、見た目でスペースがあることを判断できるようになります。 変数の値を追加する場合は += 演算子を使うべし Makefile hoge = aaa bbb hoge += ccc all: @echo $(hoge) 実行結果 $ make aaa bbb ccc 上記のように += 演算子を使用すると、現在の変数の値を追加することができます。 追加する値の前には、１つのスペースが入ります。 += 演算子で値を追加しようとした場合に、その変数がまだ定義されていない場合は、= 演算子を使ったのと同じ振る舞いをします。 Simply expand の行われる := 演算子を使い、以下のように変数の値にテキストを追加することもできます。 hoge := aaa bbb hoge := $(hoge) ccc ※ $(hoge) → &#34;aaa bbb ccc&#34; ただし、このような自己参照によって値を追加する方法は、Recursive expand（再帰展開）の行われる = 演算子と組み合わせた場合に若干問題となることがあります。 例えば、 CFLAGS = $(includes) -O CFLAGS := $(CFLAGS) -pg ※(1) includes = header all: echo $(CFLAGS) ※ $(CFALGS) → &#34;-O -pg&#34; のようにすると、(1) の代入部分で CFLAGS の値を参照すると、$(includes) -O となっていますが、この時点で CFLAGS は Recursive expanded variable として定義されているので、まだ $(includes) の内容は空の状態です（Makefile を最後まで読まないと、Recursive expanded variable はちゃんと展開されない）。 にもかかわらず、:= 演算子を使った時点で Simply expand による展開（定義時の値決定）をしようとするため、最終的に CFLAGS 変数の値に includes 変数の値は含まれず、-O -pg となってしまいます。 このようなケースでは、以下のように += 演算子を使用すれば、すべての代入が Recursive expand（再帰展開）されるので、意図通りの結果を得ることができます。 CFLAGS = $(includes) -O CFLAGS += -pg includes = header all: echo $(CFLAGS) ※ $(CFALGS) → &#34;header -O -pg&#34; make のコマンドライン・パラメータで指定した値を上書きする make のコマンドライン引数で変数値を指定すると、通常は Makefile 内での定義よりも優先されます。 Makefile hoge = 100 all:; echo $(hoge) 実行結果 $ make hoge=200 200 この優先度を変えて、Makefile 内の変数定義を有効にしたい場合は override ディレクティブを使用します。 Makefile override hoge = 100 all:; echo $(hoge) 実行結果 $ make hoge=200 100 この優先度は、+= 演算子による値の追加でも同様で、コマンドライン引数で変数値が指定されていると、その変数への += での追加は通常無視されます。 Makefile hoge = 100 hoge += 200 all:; echo $(hoge) 実行結果 $ make hoge=aaa aaa Makefile hoge = 100 override hoge += 200 all:; echo $(hoge) 実行結果 $ make hoge=aaa aaa 200 変数の優先順位 変数定義の優先順位は、高い順に以下のようになっています。 Makefile 内の変数定義（override ディレクティブ付き） コマンドライン引数で指定した変数定義 Makefile 内の変数定義（override ディレクティブなし） 環境変数 環境変数の優先度が低くなっているおかげで、make 以外の用途で設定した環境変数によって make の振る舞いを大きく変えてしまうような危険性を軽減しています。 例えば、make 内のコマンド解釈に使用するシェルを、Makefile 内の SHELL 変数定義で安心して変更することができます。 ターゲット内だけで有効な変数を定義する (Target-specific Variable) target ... : variable-assignment 上記のような構文で変数を定義すると、そのターゲット内でのみ有効な変数を定義することができます。 例えば、特定のターゲットでのみコマンドのオプションを変更したい場合などに有効です。 例 prog: CFLAGS = -g ... Target-specific Variable は、そのターゲットの prerequisites の構築に対しても有効です。 例えば、 prog: CFLAGS = -g prog: prog.o foo.o bar.o のようにすると、CFLAGS 変数は prog.o、foo.o、bar.o ターゲットの構築においても有効です。 ターゲットにパターンを使用した場合は、特に Pattern-specific Variable と呼びます。 例 %.o: CFLAGS = -O"},{url:"/p/hro2nd4/",title:"Linuxメモ: Bash の構文: case による分岐処理",date:"2007-05-08T00:00:00+09:00",body:"Linuxメモ: Bash の構文: case による分岐処理 Bash スクリプトで case を使用すると、ある値がどのパターンに一致するかによって分岐処理を行うことができます。 構文は以下の通りです。 case 式 in パターン1) 処理1 ;; パターン2) 処理2 ;; パターン3) 処理3 ;; *) いずれにも一致しない場合の処理 ;; esac 式 の評価結果が、パターン1 ～ パターン3 のいずれかに一致すると、対応する 処理1 〜 処理3 が実行されます。 パターンには正規表現を使うことができます。 case $1 in -[mM]) # -m あるいは -M だったら more $2;; esac シェルスクリプトや関数に渡された引数の値 ($1) によって処理を分岐させたいときに便利です。 case $1 in one | One) echo 1 ;; two | Two) echo 2 ;; three | Three) echo 3 ;; *) echo unknown ;; esac 次のように処理部分を複数行に分けて記述することもできます。 case $1 in one | One) echo 1 ;; two | Two) echo 2 ;; three | Three) echo 3 ;; *) echo unknown ;; esac"},{url:"/p/seogpah/",title:"Linuxメモ: Bash の構文: if-else による分岐処理",date:"2007-05-08T00:00:00+09:00",body:"Linuxメモ: Bash の構文: if-else による分岐処理 if-else の基本 Bash スクリプト内での if による条件分岐は下記のように記述します。 if 条件 then 処理 fi then を if と同じ行に記述しているスクリプトもよく見かけます。 Google もこのようなスタイルを採用しています。 if 条件; then 処理 fi 処理内容が簡潔な場合は、下記のようにセミコロンを使用して一行で記述してしまうこともできます。 if 条件; then 処理; fi 複数の条件分岐を連ねる場合 (else if) は、以下のように elif と else を使って記述します。 if 条件1; then 処理1 elif 条件2; then 処理2 elif 条件3; then 処理3 else 処理4 fi test コマンドによる比較処理 if の条件部では、test コマンドを使用して、数値比較や文字列比較を行うことができます。 実際には、test コマンドへのシンボリックリンクである [ を使って記述するのが一般的です。 例えば、以下では数値比較を行うために test コマンドを使っていますが、 if test 1 -gt 0; then echo &#39;OK&#39;; fi これは次のように書くことができます。 if [ 1 -gt 0 ]; then echo &#39;OK&#39;; fi [ は単に test コマンドのエイリアスなので、[ の後ろには必ず 1 つ以上のスペースが必要です（上記では 1 が test コマンドへ渡すパラメータとして扱われています）。 [ で使用できる -eq や -gt などのオプションは、man test とすれば調べることができます。 test コマンドの例 test コマンドのオプション指定により、様々な判定を行うことができます。 -z: 文字列の長さが 0 なら True -f: 指定したファイルが存在するなら True 例: 環境変数 $HOGE が空かどうかを調べる if [ -z &#34;$HOGE&#34; ]; then ... fi 例: $HOME/.vimrc というファイルが存在するか調べる if [ -f &#34;$HOME/.vimrc&#34; ]; then ... fi 文字列を比較する 文字列変数の値を他の文字列と比較するときは、変数値にスペースが含まれているケースを考慮して、ダブルクォートで囲んで参照するようにします。 if [ &#34;$str&#34; = &#39;hoge&#39; ]; then # match fi 上記のように記述しておけば、$str に値がセットされていないときもエラーになりません。 &amp;&amp; を短絡演算子として使用する if の条件部が真 (true) になるケースだけ簡単な処理を行いたい場合は、下記のように &amp;&amp; を利用して if の代わりにすることができます。 echo &#34;ごみ箱を空にしますか？ [y/n]&#34; read input [ &#34;$input&#34; = &#39;Y&#39; -o &#34;$input&#34; = &#39;y&#39; ] &amp;&amp; rm ~/trash/* 上記は、下記のように記述したのと同様に振る舞います。 echo &#34;ごみ箱を空にしますか？ [y/n]&#34; read input if [ &#34;$input&#34; = &#34;Y&#34; -o &#34;$input&#34; = &#34;y&#34; ]; then rm ~/trash/* fi"},{url:"/p/8okf7d3/",title:"Vim/Neovim でタブ文字に関する設定を行う (tabstop, expandtab, softtabstop)",date:"2007-04-11T00:00:00+09:00",body:"Vim/Neovim でタブ文字に関する設定を行う (tabstop, expandtab, softtabstop) タブ文字 1 文字分の表示幅を設定する タブ文字がどれくらいの幅で表示されるかの設定は tabstop オプションで行います。 Vim (~/.vimrc) の場合 :set tabstop=4 &#34;タブ 1 文字の表示幅 (default: 8) Neovim (~/.config/nvim/init.lua) の場合 vim.opt.tabstop = 4 -- タブ 1 文字の表示幅 (default: 8) 例えば、tabstop を 4 に設定すると、ファイル内のタブ文字は 4 文字分のスペースとして表示されます。 この設定は、あくまで見え方の設定であって、タブは 1 文字のタブ文字 (\\t) として存在します。 他のエディタでファイルを開くと、タブ文字の見え方は変わってきます。 タブを入力したときにタブ文字の代わりにスペースを挿入する TAB キーを押したときに、タブ文字の代わりに半角スペース x N を入力したいときは、expandtab を有効化します。 さらに、TAB キーを押したときに何文字分の半角スペースを入力するかは、softtabstop で設定します。 softtabstop=4 と具体的な値を設定するのもよいですが、負の値（-1 など）を設定すると、tabstop で設定した値に合わせてくれます。 Vim (~/.vimrc) の場合 :set expandtab &#34;タブキーでスペースを入力する (default: noexpandtab) :set softtabstop=-1 &#34;タブキーで入力するスペース数 (-1: tabstop に合わせる) Neovim (~/.config/nvim/init.lua) の場合 vim.opt.expandtab = true -- タブキーでスペースを入力する (default: false) vim.opt.softtabstop = -1 -- タブキーで入力するスペース数 (-1: tabstop に合わせる) ちなみに、expandtab が有効化されているときにタブ文字を明示的に入力したくなった場合は、CTRL-V &lt;TAB&gt; あるいは CTRL-Q &lt;TAB&gt; で入力できます。 参考 すでに入力されているタブをスペースに変換する (:retab)"},{url:"/p/kyj2izf/",title:"Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe)",date:"2007-04-10T00:00:00+09:00",body:"Python スクリプトを Windows の実行ファイル (.exe) に変換する (py2exe) py2exe を使用すると、Python のスクリプトから Windows 上で実行可能な .exe ファイルを作成することができます。 基本的な使い方 変換対象のスクリプト hello.py と、変換設定ファイル setup.py を用意します。 hello.py print &#39;Hello&#39; setup.py from distutils.core import setup import py2exe setup(console=[&#39;test.py&#39;]) コマンドラインから、次のように実行すると、dist ディレクトリに hello.exe と、必要なライブラリが生成されます。 C:\\&gt; python setup.py py2exe 配布するときは、dist ディレクトリの中身をすべてまとめて配布します。 （応用）wxPython などの GUI アプリケーションの場合 setup.py from distutils.core import setup import py2exe setup(windows=[&#39;test.py&#39;]) GUI を持つアプリケーションで、実行時にコマンドプロンプトを表示したくない場合は、setup メソッドのパラメータとして、console の代わりに windows を指定します。"},{url:"/p/r3m4k2h/",title:"Python でクラスの属性に名前でアクセスする (getattr, setattr)",date:"2007-03-31T00:00:00+09:00",body:"Python でクラスの属性に名前でアクセスする (getattr, setattr) Python でオブジェクトの属性にアクセスするには、通常 obj.属性名 という構文を使用しますが、次のような仕組みを使うと、属性名を文字列で指定してアクセスすることができます。 ビルトイン関数の getattr / setattr 関数 オブジェクトの __dict__ 属性 変数などに格納した属性名を使えるようになるため、属性名のリストをループ処理したり、あらかじめ属性名が決められない場合に後付けで属性を追加したりすることができます。 getattr/setattr 関数を使う方法 ビルトイン関数の getattr や setattr を使うと、任意のオブジェクトの属性に次のような形式でアクセスできます。 getattr(object, name [, default]) # 属性値の取得 setattr(object, name, value) # 属性値の設定 getattr 関数で指定した名前の属性が見つからない場合は、default 引数で指定した値が返されます。 default 引数が指定されていないと AttributeError が発生するので、できるだけ default 引数は指定しておくのが安全です。 次の例では、属性名のタプル (&quot;name&quot;, &quot;age&quot;) をループ処理して、対応する属性値を順番に取り出しています。 例: person オブジェクトの name 属性と age 属性を参照する class Person: def __init__(self, name: str, age: int): self.name = name self.age = age person = Person(name=&#34;Maku&#34;, age=14) for attr_name in (&#34;name&#34;, &#34;age&#34;): attr_val = getattr(person, attr_name) print(f&#34;{attr_name} = {attr_val}&#34;) 実行結果 name = Maku age = 14 __dict__ 属性を使用する方法 特殊属性の __dict__ でも属性値にアクセスできます。 この属性は辞書オブジェクトになっているので、__dict__[&quot;属性名&quot;] という形で参照します。 class MyClass: pass if __name__ == &#34;__main__&#34;: obj = MyClass() # 名前指定で属性値を設定する obj.__dict__[&#34;foo&#34;] = 100 print(obj.foo) # =&gt; 100 # 名前指定で属性値を取得する obj.bar = 200 print(obj.__dict__[&#34;bar&#34;]) # =&gt; 200"},{url:"/p/vugpfvz/",title:"VMware のネットワーク設定",date:"2007-03-22T00:00:00+09:00",body:"VMware のネットワーク設定 VMware Player 1.0.3 で確認しています。 仮想ネットワーク (virtual network)／仮想スイッチ (virtual switch) VMware をインストールすると、最大 9 つの virtual network（VMnet0 ～ VMnet8）が利用できるようになります。 デフォルトの設定では、VMnet0、VMnet1、VMnet8 がそれぞれ次のような構成のネットワークとして設定されています。 VMnet0: bridged network（ブリッジ接続ネットワーク） VMnet1: host-only network（ホストオンリー接続ネットワーク） VMnet8: NAT network（NAT 接続ネットワーク） 例えば、デフォルトで VMnet0 は物理的な NIC と接続するための virtual bridge（仮想ブリッジ）として使えるようになっているので、virtual machine（ゲスト OS）の virtual network adapter（仮想ネットワークアダプタ）を VMnet0 に接続するように設定すれば、物理的な NIC が繋がっている外のネットワークに接続することができます。 [virtual machine] virtual network adapter ---&gt; VMnet0 (bridge) ---&gt; [physical NIC] ---&gt; external network virtual network (VMnet\\*) の数は上記のように 9 個までと制限されていますが、ひとつの virtual network に対して複数の virtual machine（正確には virtual network adapter）を接続することができるので、ほとんど問題にはなりません（Windows ホストでは接続数に制限なし、Linux ホストでは 32 個の virutal network adapter をひとつの virtual network に接続可能）。 virtual network adapter -------+ | virtual network adapter ---- VMnet0 (bridge) ---&gt; [Physical NIC] | virtual network adapter -------+ ☝️ virtual network = virtual switch? VMnet0 ～ VMnet8 という名前は、正確には virtual network を示しているのだと思いますが、VMware のマニュアルでは、virtual switch と呼んでいたりします。よく考えてみると、 「ネットワークに接続する」＝「そのネットワークに繋がっているスイッチに接続する」 とみなしても大差はないので、VMnet0 ～ VMnet8 のことを virtual network ではなく、virutal switch と呼んでも問題ないのでしょう。 VMnet0 ～ VMnet8 までの 9 個の仮想的なスイッチングハブがあるんだと考えると分かりやすいです。 ホスト OS と、ゲスト OS は必ず VMnet\\* を介して通信します。 [Host OS] [Guest OS] virtual network adapter ----&gt; VMnet1 &lt;---- virtual network adapter virtual network adapter（仮想ネットワークアダプタ） ホスト OS 側の virtual network adapter Windows に VMware Player をインストールすると、virtual network に接続するための virtual network adapter（仮想の NIC）が追加されます。 デフォルトでは、次の 2 つの仮想ネットワークアダプタが追加されます。 VMware Network Adapter VMnet1 (for host-only network) VMware Network Adapter VMnet8 (for NAT network) ※ bridged network (VMnet0) は、ホスト OS 側の物理的 NIC に直接接続されているような状態になるため、ホスト OS 側に VMnet0 用の virtual network adapter は追加されません。 ※ VMnet1、VMnet8 という仮想スイッチングハブに接続された 2 つのネットワークカード (VMware Network Adapter) があると考えると分かりやすいです。 host-only network も NAT network も通常は private IP アドレスを使用するネットワークであるため、上記の virtual network adapter には 192.168.***.*** という IP アドレスが割り当てられているはずです。 VMnet1 と VMnet8 は仮想といえども別のネットワークなので、それぞれ別のネットワークアドレスが割り振られます（例えば、192.168.100.1 と 192.168.200.1）。 これらの IP アドレスは固定で指定することも、VMware 内部の DHCP サーバによって割り当てることもできます。 ここで割り当てた IP アドレスが、ゲスト OS 側から見えるホスト OS の IP アドレスとなります。 ゲスト OS 側の virtual network adapter virtual machine 側では、virtual network (VMnet0-8) に接続するための virtual network adapter を最大 3 つまで使用することができます。 ホスト OS 側の virtual network adapter と同様に、これらはそれぞれ別の virtual network (virtual switch) に接続することができます。 3 つの virtual network adapter を、どの virtual network (virtual switch) に接続するかは、virtucal machine の設定ファイル (.vmx) で指定します。 ethernet0.present = &#34;true&#34; ethernet0.connectionType = &#34;custom&#34; ethernet0.vnet = &#34;vmnet5&#34; ethernet1.present = &#34;true&#34; ethernet1.connectionType = &#34;custom&#34; ethernet1.vnet = &#34;vmnet2&#34; connectionType を bridged, hostonly, nat のようなネットワーク構成で指定する場合は、以下のように記述します。 このとき、vnet の指定は必要ありません。 ethernet0.present= &#34;true&#34; ethernet0.connectionType = &#34;bridged&#34; ethernet0.present= &#34;true&#34; ethernet0.connectionType = &#34;hostonly&#34; ethernet0.present= &#34;true&#34; ethernet0.connectionType =&#34;nat&#34; ネットワーク構成の種類 bridged network（ブリッジ接続ネットワーク） virtual switch を bridged network として構成した場合、物理的 NIC に接続された virtual bridge として振る舞うようになります。 デフォルトでは VMnet0 が bridged network として構成されています。 virtual machine 側の virtual network adapter を、この virtual bridge に接続する場合、ホスト OS が使っている物理的 NIC を利用して virtual network adapter に新しい IP アドレスを割り当てます。 つまり、物理的 NIC が接続しているネットワークの IP アドレスがもう 1 つ必要になります。 [virtual machine] vitual network adapter (xxx.yyy.zzz.128) | | virtual bridge ---- physical NIC ---- external network (VMnet0) (xxx.yyy.zzz.0) イメージとしては、virtual machine が直接、物理的 NIC を利用して外部のネットワークに接続しているようなものです。 NAT network や host-only network の場合とは違い、private ネットワークは構成されません。 つまり、以下のように、ゲスト OS が物理的 NIC を使用していると考えることができます。 [virtual machine] physical NIC (xxx.yyy.zzz.128) ---- external network (xxx.yyy.zzz.0) bridged network では、virtual machine とホスト OS に対して、物理的 NIC が接続しているネットワークの IP アドレスをそれぞれ個別に割り当てるため、外のマシンからは単純に複数のマシンが稼動しているかのように見えます（1 つの物理 NIC が複数の IP アドレスを持つ）。 そのため、vitual machine 上で Web サーバなどを立ち上げれば、外のマシンからアクセスすることができます。 複数の vitual machine をひとつの virtual bridge (VMnet0) に繋ぐことも可能です。 ただし、その数だけ IP アドレスが必要になることに注意が必要です。 ホストに複数の物理的 NIC が接続されている場合は、その数だけ virtual bridge を追加することができます（VMnet0 ～ 8 のいずれかをその NIC 用の virtual bridge とする）。 NAT (Network address translation) network（NAT 接続ネットワーク） VMware のアドレス変換機能 (NAT) を用いて、virtual machine 側の virtual network adapter に割り当てた private IP アドレスと、物理的 NIC に割り当てた IP アドレスによる通信を仲介します。 デフォルトでは VMnet8 が NAT network として構成されています。 ホスト OS が使っている物理的 NIC の IP アドレスと MAC アドレスを共有して外部ネットワークに接続することができるため、新しい IP アドレスを追加できない場合に便利です。 ただし、NAT ネットワークには通常 private IP アドレスが割り当てられるため、外部のネットワークから virtual machine にアクセスすることはできません（外部に公開する Web サーバなどは構築できません）。 [virtual machine] virtual network adapter (192.168.0.128) | | virtual switch ---- VMware NAT device ---- external network (VMnet8) (xxx.yyy.zzz.0) ホスト OS 側にも、NAT ネットワーク (VMnet8) に接続するための virtual network adapter が追加され、ホスト OS と virtual machine の間で private IP アドレスを用いて通信することができます。 [virtual machine] virtual network adapter (192.168.0.128) | | virtual switch (VMnet8) | | virtual network adapter (192.168.0.1) [host OS] NAT 接続では、単純にネットワーク間のアドレス変換、パケットの仲介をするだけなので、物理的 NIC の存在は意識されません。 これは、物理的 NIC がどのような種類のネットワークに接続されていても、IP アドレスさえ割り当てられていれば virtual machine がそのネットワークへ接続できることを意味しています。 例えば、Ethernet 以外の次のようなネットワークにも接続することが可能です。 ダイアルアップ トークンリング ATM host-only network (ホストオンリー接続ネットワーク) ホスト OS と virtual machine の間を繋ぐためのプライベートネットワークです。 基本的には物理的 NIC や、外部のネットワークとは隔離されたものなので、ローカル環境からのみアクセス可能なセキュアなサーバを構築することができます。 テスト用の virtual machine を動作させる場合は、このモードで動作させるのが安全です。 [virtual machine] virtual network adapter (192.168.34.128) | | virtual switch (VMnet1) | | virtual network adapter (192.168.34.1) [host OS] 基本的に、private ネットワークに配置された virtual machine は外部のネットワークにアクセスできませんが、ホスト OS 側でルーティングソフトウェアや、Proxy ソフトウェアを動作させることで、外部のネットワークに接続することが可能です。 例えば、Windows の「インターネット共有」の機能を使えば、host-only network からインターネットへ接続することができます。 このような構成を利用することで、NAT network の場合と同様に、Ethernet 以外のネットワーク（ダイアルアップ等）にも接続することができます。 VMware DHCP サーバによる private IP アドレス自動割り当て NAT network、host-only network に接続する virtual network adapter の private IP アドレスは、VMware の提供する DHCP サーバ機能によって自動的に割り振ることができます。 この場合、virtual switch (VMnet1, VMnet8) にそれぞれ DHCP サーバ機能が組み込まれているかのように振る舞います。 [virtual machine] virtual network adapter (192.168.0.128) | | virtual switch ---- VMware DHCP server (VMnet8) (for 192.168.0.0 network) DHCP サーバの IP アドレス割り当て範囲などは、VMware のネットワーク設定ツールで変更できます（Windows の場合は vmnetcfg.exe の DHCP タブで設定）。 NAT 接続の設定 VMware のマニュアル に NAT ネットワーク上の DHCP について分かりやすい説明があるので抜粋しておきます。 ネットワークの構成作業を簡易化するために、VMware Server のインストール時にDHCP サーバが自動的にインストールされます。 このため、NAT デバイスを使ってネットワーク上で稼働する仮想マシンは、DHCP リクエストを送信してIP アドレスをダイナミックに取得することができます。 NAT ネットワーク上のDHCP サーバ（ホストオンリーネットワーク構成でも使用されます）は、&lt;net&gt;.128 ～ &lt;net&gt;.254 の範囲でIP アドレスをダイナミックに割り当てます。 ここで&lt;net&gt; は、NAT ネットワークに割り当てあられたネットワーク番号のことです。 VMware Server は NAT ネットワークには常にクラス C アドレスを使用します。 &lt;net&gt;.3 ～ &lt;net&gt;.127 の IP アドレスは、静的 IP アドレスに使用することができます。 IP アドレス &lt;net&gt;.1 はホストアダプタに、&lt;net&gt;.2 はNAT デバイスに割り当てられています。 簡単にまとめると、 NAT で GuestOS を外部ネットワークに繋ぐには、GuestOS の Virtual Adapter を VMnet8 に繋げばよい。 VMnet8 に繋ぐ Host OS 側の Virtual Adapter には固定 IP アドレス 192.168.11.1 などが割り当てられている。 VMnet8 に繋ぐ Guest OS 側の Virtual Adapter は通常 DHCP でアドレス取得 (128～254) するようにしておけば問題ない。固定 IP アドレスを割り当てたい場合は、3 ～ 127 の範囲で割り当てること。この割り当て範囲は、Virutla Network Editor (vmnetcfg.exe) の DHCP タブで変更可能。 NAT デバイスは、デフォルトで VMnet8 に接続されていることになっているが、Virtual Network Editor (vmnetcfg.exe) で変更できる。NAT デバイスの IP アドレスは、192.168.11.2 などになっている（これも変更可能）。 設定例 （Host OS: Windows Vista、Guest OS: CentOS 5.1 で確認しています） Windows 側 (Host OS) の設定 インターネットに接続された NIC があることを前提とします。 VMnet8 用の仮想アダプタ（Local Area Connection 4 など）には、192.168.11.1 などの固定 IP アドレスが割り当てられます（デフォルト）。 VMware の vmnetcfg.exe の Host Virtual Network Mapping タブで、以下のようになっているか確認してください。 VMnet8 ==&gt; Local Area Connection 4 # NAT network Linux 側 (Guest OS) の設定 仮想マシンの構成ファイル (CentOS_5.1.vmx) を編集して、NAT 接続 (VMnet8) できるようにします。 ethernet0.present = TRUE ethernet0.connectionType = &#34;custom&#34; ethernet0.vnet = &#34;VMnet8&#34; Linux の eth0 の IP アドレスを DHCP で割り当てます（GATEWAY の設定はなくてもよいっぽい）。 /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE=eth0 ONBOOT=yes BOOTPROTO=dhcp TYPE=Ethernet USERCTL=yes IPV6INIT=no PEERDNS=yes virtual bridge と接続する物理的 NIC を指定する 物理的 NIC が 1 つしか存在しない場合、デフォルトでは VMnet0 の virtual bridge はその NIC に接続されます。 複数の NIC が存在する場合は、いずれかの NIC が接続されます。 Windows の場合、仮想ネットワークエディタ (Vertual Network Editor) vmnetcfg.exe を使って virtual bridge をどの物理的 NIC に接続するかを明示的に指定することができます。 デフォルトでは、「自動ブリッジ」ページの、「VMnet0 へブリッジできる物理ネットワークアダプタを自動的に選択する。」 にチェックが入っているので、VMnet0 の virtual bridge は、自動的にいずれかの物理的 NIC に接続されます。 物理的 NIC が複数存在し、VMnet0 の virtual bridge を特定の NIC に接続したい場合は、「ホスト仮想ネットワークの割り当て」ページを開き、VMnet0 のプルダウンメニューから接続したい物理的 NIC を選択します。 ※ この図は、左側の VMnet0～9 のどのネットワーク（仮想スイッチ）に、Host OS のどの NIC（物理 NIC、仮想 NIC 含む）を接続するかの対応表だと考えればよいです。 ここでの設定は、あくまで Host OS 側の設定です。Guest OS 側の VMnet と仮想 NIC の接続の設定は、構成ファイル (.vmx) で行います。 ※ ちなみに、ここで表示される「ホストと共有プライベートネットワーク」を選択すると、いずれかの NIC が自動的に選択されます。 つまり、「自動ブリッジ」ページのチェックボックスにチェックを入れるのと同じことです。 その他 Guest OS で Multi-core CPU を使用する VMware 構成ファイル (.vmx) の以下のコメントアウト行の # を外して有効にする。 # If you wish to use multi-core CPU on guest OS, uncomment a below line. # numvcpus = &#34;2&#34; VMnetDHCP を停止する スタートメニューから services.msc を起動 サービス一覧から &ldquo;VMware DHCP Service&rdquo; を右クリック ==&gt; Properties Stop をクリック Startup type: を Disabled に設定 トラブルシューティング: NIC 二枚挿しで Bridge 接続がうまくいかない Guest OS (Linux) 側の仮想アダプタの 1 枚目を Bridge 接続用に設定するとうまくいくことがあります。 # Bridge 接続用 ethernet0.present = &#34;true&#34; ethernet0.connectionType = &#34;custom&#34; ethernet0.vnet = &#34;VMnet0&#34; # NAT 接続用 ethernet1.present = &#34;true&#34; ethernet1.connectionType = &#34;custom&#34; ethernet1.vnet = &#34;VMnet8 Virtual Network Editor (vmnetcfg.exe) の &ldquo;Host Virtual Network Mapping&rdquo; タブの VMnet0 で、ブリッジする NIC を選択する（自動選択にしない）。 Windows のネットワーク設定で、ブリッジ接続に使用する NIC だけ、Properties のダイアログで &ldquo;VMware Bridge Protocol&rdquo; にチェックを入れておくのがよいかも。 トラブルシューティング: VMware の DHCP が動いているはずなのに IP アドレスを取得できない （Host OS: Windows Vista、Guest OS: CentOS 5.1 で確認） /etc/sysconfig/network-scripts/ifcfg-eth0 などで BOOTPROTO=dhcp になっているか確認。 Virtual Network Editor (vmnetcfg.exe) で DHCP サービスがちゃんと動いているか確認。 仮想マシン構成ファイル (CentOS_5.1.vmx) で仮想アダプタが DHCP の有効な仮想ネット (VMnet8) などに接続されているか確認。 うまく行かなかったら、Host OS と Guest OS を再起動してみる。※意外と重要 トラブルシューティング: vmnetcfg.exe で任意の物理 NIC を VMnet に割り当てられない （Host OS: Windows Vista、VMware 2.5.2 で確認） 症状はこんな感じ。 仮想ネットワークエディタ (Virtual Network Editor) の「自動ブリッジ (Automatic Bridging)」タブの次のような項目がグレーアウトされていてチェックが外せない。VMnet0 へブリッジできる物理ネットワークアダプタを自動的に選択する。(Automatically choose an available physical network adapter to bridge to VMnet0) 仮想ネットワークエディタ (Virtual Network Editor) の「ホスト仮想ネットワークの割り当て (Host Virtual Network Mapping)」タブで、任意の物理 NIC を選択できない。 原因は、vmnetcfg.exe を Administrator 権限で実行していないから。 Vista の場合は以下のように設定しておかないとダメらしい。まぎらわしいっ (T-T) vmnetcfg.exe を右クリック ==&gt; Properties。 Conpatibility タブの &ldquo;Run this program as an administrator&rdquo; にチェックを入れて OK。 トラブルシューティング: Windows Vista の Windows Firewall で Guest OS から Host OS へ ping が通らない スタートメニューから &ldquo;Windows Firewall&rdquo; &ldquo;Change settings&rdquo; を選択して、Off にしてみる 参考: Windows Vistaのファイアウォールでpingへの応答を許可する － ＠IT トラブルシューティング: ウィルスバスターの Firewall で Host OS と Guest OS の接続がうまくいかない スタートメニューから services.msc を起動 サービス一覧から &ldquo;OfficeScan NT Firewall&rdquo; を右クリック ==&gt; Properties Stop をクリック Startup type: を Disabled に設定 トラブルシューティング: VMware 上の Red Hat Linux 9 で DHCP でアドレスをとれない ifcfg-eth0 ファイルなどに、おまじないコードみたいなのを書けば直るらしい。 確かに直った。 DEVICE=eth0 BOOTPROTO=dhcp ONBOOT=yes check_link_down () { return 1; }"},{url:"/p/bmriv55/",title:"Vim でキーボードマクロを記録して一連のキー入力を繰り返し実行する",date:"2007-03-12T00:00:00+09:00",body:"Vim でキーボードマクロを記録して一連のキー入力を繰り返し実行する Vim のノーマルモードで q を入力すると、キーボードマクロの記録モードに入ります。 最初に保存先のレジスタ名称（a-zA-Z0-9 のうち1文字）を入力してから記録させたいテキスト入力を行うと、そのレジスタにマクロとして登録されます。 最後にノーマルモードで再び q を入力すると、キーボードマクロの記録モードが終了します。 登録したキーボードマクロを再生したいときは、@ に続けてレジスタ名を入力します。 qa &hellip; マクロ記録開始（q の後ろは a-zA-Z0-9 のいずれか1文字） q &hellip; マクロ記録終了 @a &hellip; マクロ実行（q の後ろは a-zA-Z0-9 のいずれか1文字） 例: 行頭に // を挿入するキーボードマクロを記録（Java のコメント） qaI// &lt;Esc&gt;q # 記録 @a # 再生 @a などでマクロを再生した後に、さらに続けて同じマクロを実行したい場合は、@a を入力するのではなく、.（ドット）で繰り返し実行すると簡単です。"},{url:"/p/fdep5i7/",title:"Vim のヘルプコマンドの使い方 (:help, :helpgrep)",date:"2007-03-12T00:00:00+09:00",body:"Vim のヘルプコマンドの使い方 (:help, :helpgrep) ヘルプの起動／終了 Vim/Neovim エディタ内で下記のコマンドを実行することで、ヘルプを起動・終了することができます。 :help &hellip; ヘルプを起動する :q / ZZ &hellip; ヘルプを終了する vim/nvim コマンド実行時に + オプションを付けて起動することで、Vim のヘルプを直接開くこともできます。 $ nvim +help # Vim のヘルプを起動して開く $ nvim +&#34;help :highlight&#34; # highlight コマンドのヘルプを起動して開く :help コマンドに渡すパラメータ :help コマンドの引数に特定のプレフィックスを付けたり、引数を引用符で囲むことで、異なるモードのコマンドのヘルプを見ることができます。 何のヘルプを読むか プレフィックスなど 例 exコマンド : :help :quit オプション 'name' :help 'number' Vim の起動パラメータ - :help -t キー入力 (normal mode) なし :help u キー入力 (insert mode) i_ :help i_CTRL-N, :help i_&lt;Esc&gt; キー入力 (visual mode) v_ :help v_u キー入力 (command mode) c_ :help c_&lt;Del&gt; 特殊なキー入力は、CTRL-A、&lt;Del&gt;、&lt;Esc&gt; のように表現することができます（他のキーの表現方法は :help keycodes で確認できます）。 例: Ctrl-A（normal mode）のヘルプを表示する :help CTRL-A 例: Ctrl-A（insert mode）のヘルプを表示する :help i_CTRL-A 例: Vim の起動パラメータ -t のヘルプを表示する :help -t 例: number オプションのヘルプを見る :help &#39;number&#39; ヘルプファイルを grep する :helpgrep コマンドを使用すると、ヘルプファイル内を grep 検索することができます。 :helpgrep keyword 検索が終了すると、最初にキーワードにヒットした部分のヘルプが表示されるのですが、多くの場合は複数個所がヒットしているはずです。 検索後に :copen コマンドを実行すると、ヒットした行の一覧を表示し、そこから各ヒット位置へジャンプすることができます。 一覧表示のウィンドウは :cclose コマンドで閉じることができます。 ヘルプを起動した後の操作方法 :help コマンドでヘルプを起動した後は、下記の操作で項目間をジャンプすることができます。 Ctrl-] &hellip; |:help| などのリンク先へジャンプ（タグジャンプ） Ctrl-t &hellip; ジャンプ先から戻る Vim の doc ディレクトリ内に tags ファイルが用意されているので、Ctrl-] を使ってカーソル位置の単語に関連するヘルプページにジャンプすることができます。 GUI 版の gvim を使用している場合は、マウスで単語をダブルクリックしても同様にジャンプできます。 例えば、:help で表示されたページの usr_01.txt にカーソルを合わせて Ctrl-] を入力すると、usr_01.txt のヘルプページへジャンプできます。 ジャンプ元に戻って来たい場合は、Ctrl-t と入力します。"},{url:"/p/dsbsaq7/",title:"Python の対話型シェルで使える小技",date:"2007-03-07T00:00:00+09:00",body:"Python の対話型シェルで使える小技 Python のインタラクティブシェルで _（アンダースコア）を使用すると、 前回評価した値を参照することができます。 &gt;&gt;&gt; [1, 2, 3] [1, 2, 3] &gt;&gt;&gt; len(_) 3"},{url:"/p/f4ckt29/",title:"Python でテキストファイルを読み込む (open, read, readline, readlines)",date:"2007-03-06T00:00:00+09:00",body:`Python でテキストファイルを読み込む (open, read, readline, readlines) テキストファイルを 1 行ずつ読み込む for-in ループで 1 行ずつ処理する方法 Python の open 関数で生成したファイルオブジェクトを for-in ループでイテレートすることで、テキストファイルを 1 行ずつ読み込むことができます。 Python 2.5 以降であれば、open するときに、with キーワードを使用することによって close 処理を自動化することができます。 ファイルを使用している区間が明示的になるので、この方法を使うのがオススメです。 テキストファイルを 1 行ずつ処理 with open(&#39;input.txt&#39;, encoding=&#39;utf-8&#39;) as f: for line in f: line = line.rstrip(&#39;\\r\\n&#39;) # 改行文字の削除 print(line) # 改行付きで出力 line には改行コードを含むので、line.rstrip('\\r\\n') で末尾の改行系文字を削除しています。 別の方法としては、line 内の改行はそのままで、print(line, end='') として出力時の改行を抑制する方法あります（Python 2.x の頃は print line, のように最後にカンマを付ければ改行抑制できました）。 with によってインデントが深くなってしまうのが嫌な場合は、下記のようにユーティリティ関数を用意しておくのもよいです。 def each_line(filename): with open(filename, encoding=&#39;utf-8&#39;) as f: for line in f: yield line.rstrip(&#39;\\r\\n&#39;) for line in each_line(&#39;input.txt&#39;): print(line) readline で 1 行ずつ読み込む方法 readline メソッドを使うと、次の 1 行を文字列として取得することができます。 ファイルの最後まで読み込み終わると、readline は空文字列 (&quot;&quot;) を返します。 with open(&#39;input.txt&#39;, encoding=&#39;utf-8&#39;) as f: while True: line = f.readline() if not line: break line = line.rstrip(&#39;\\r\\n&#39;) print(line) テキストファイルのすべての行を一度に読み込む それほど大きなテキストファイルでなければ、テキストファイル全体の内容を一度にメモリ上に読み出してしまうこともできます。 すべての行を文字列リストとして取得する readlines メソッドで、全ての行を文字列のリスト (list[str]) の形で取得できます。 各要素の末尾には改行が残っています（最終行には改行は含まれていない可能性があります）。 with open(&#39;input.txt&#39;, encoding=&#39;utf-8&#39;) as f: lines = f.readlines() #=&gt; list[str] print(lines) 実行結果 [&#39;First line\\n&#39;, &#39;Second line\\n&#39;, &#39;Third line&#39;] 次のようなリスト内包表記を使用して、各行の末尾の空白・改行を削除しながら、リスト形式で読み込むこともできます。 lines = [line.rstrip() for line in open(&#39;input.txt&#39;, encoding=&#39;utf-8&#39;)] すべての行を連結して読み出す（改行文字は残す） read メソッドを使用すると、ファイルの内容すべてを 1 つの文字列変数に取得することができます。 with open(&#39;input.txt&#39;, encoding=&#39;utf-8&#39;) as f: content = f.read() #=&gt; str print(content) 実行結果 First line Second line Third line テキストファイルの内容を 1 文字ずつ処理する テキストファイルの内容を read メソッドで一度に読み込み、そのテキストをさらにイテレートすることで、テキストファイルの内容を 1 文字ずつ処理することができます。 input.txt ファイルの内容を 1 文字ずつ処理 with open(&#39;input.txt&#39;, encoding=&#39;utf-8&#39;) as f: content = f.read() for ch in content: if ch == &#39;\\n&#39;: print(&#39;改行発見！&#39;) else: print(ch) 次のようなユーティリティメソッドを作っておけば、1 文字ずつ処理するコードを簡単に書けるようになります。 def iter_chars(filename): &#34;&#34;&#34; Reads a text file char by char. &#34;&#34;&#34; with open(filename, encoding=&#39;utf-8&#39;) as f: content = f.read() for ch in content: yield ch # 使用例 for ch in iter_chars(&#39;input.txt&#39;): print(&#39;--&gt; &#39; + ch)`},{url:"/p/f92ub3d/",title:"Vim のコマンドモードでのカーソル移動 (Ctrl-B, Ctrl-E, Ctrl-H, Ctrl-U)",date:"2007-02-22T00:00:00+09:00",body:"Vim のコマンドモードでのカーソル移動 (Ctrl-B, Ctrl-E, Ctrl-H, Ctrl-U) コマンドモードでの入力操作 Vim で :（ex コマンド）や、/ （検索）キーを押すと、コマンドを 1 行だけ入力できるコマンドラインモード（コマンドモード）に入ります。 コマンドモードでは、下記のようなキーシーケンスでカーソル移動や編集操作を行うことができます。 入力 説明 Ctrl-U 行頭まで削除 Ctrl-B 行頭に移動 Ctrl-E 行末に移動 Ctrl-H 1 文字削除 Ctrl-W 1 単号削除 Ctrl-P 1 つ前の履歴を表示 Ctrl-N 1 つ後の履歴を表示 Ctrl-R % ファイル名を挿入（% レジスタ） Ctrl-R * クリップボードの内容を挿入（* レジスタ） Ctrl-R &quot; 最後にヤンクした内容を挿入（&quot; レジスタ） コマンドモードのヘルプ コマンドモードでの入力操作に使えるキーシーケンスのヘルプは次のように確認できます。 入力 説明 :help cmdline-editing コマンドラインの編集操作についてのヘルプ全般 :help c_CTRL-W コマンドモードでの Ctrl-W というキー入力についてのヘルプ :help map-modes キーマッピングについてのヘルプ（コマンドモード用には :cmap や :cnoremap を使う）"},{url:"/p/ow6rvbz/",title:"Vim のコマンドモードで入力補完する (Ctrl-D, Tab)",date:"2007-02-21T00:00:00+09:00",body:"Vim のコマンドモードで入力補完する (Ctrl-D, Tab) Vim のコマンドモードでコマンドを入力している最中に、Ctrl-D や Tab を押すと、入力候補の一覧表示や、入力の補完を行うことができます。 例: add を含んでいるパラメータの入力候補を表示 :help add&lt;Ctrl-D&gt; 例: add で始まるパラメータの入力を補完 :help add&lt;TAB&gt;"},{url:"/p/b5o6ksu/",title:"Vim/Neovim でインデント（シフトコマンド）を設定する (shiftwidth, shiftround)",date:"2007-02-20T00:00:00+09:00",body:"Vim/Neovim でインデント（シフトコマンド）を設定する (shiftwidth, shiftround) シフトコマンドで挿入／削除するスペースの量を設定する shiftwidth オプションに設定した値は、&gt;&gt; コマンドなどで行頭に挿入するスペースの数を示します。 :set shiftwidth=4 &#34; デフォルトは 8 タブストップ (tabstop) と混同しがちなので注意してください。 タブストップは、タブ文字を入力した場合に表示位置をどこへずらすかの基準を指定します。 シフトコマンド (&gt;&gt;) に効いてくる値はあくまで shiftwidth の方です。 シフトしたときに shiftwidth の値の倍数になるようにスペースを挿入する シフトコマンド（&gt;&gt; など）を実行すると、行の先頭に shiftwidth で設定した数だけスペースが挿入されます。 このとき、すでに行頭に何文字かのスペースが存在する場合に、スペース数が shiftwidth の倍数になるように調整してスペースを挿入したい場合は、次のように shiftround を有効化します（デフォルトはオフ (noshiftround) です）。 Vim（/.vimrc の場合） :set shiftround &#34;シフトコマンドでのインデント量を丸める Neovim（~/.config/nvim/init.lua の場合） vim.opt.shiftround = true -- シフトコマンドでのインデント量を丸める ほとんどの場合は、行頭からのインデント量は 2 の倍数とか 4 の倍数とかに揃えておきたいはずなので、shiftround はセットしておくことをお勧めします。 ファイルタイプごとのインデントを設定する 以下のように設定しておくと、ソースコードを開いたときに、その言語別（Vim 的にはファイルタイプ別）にインデント設定を切り替えることができます。 現在の編集中のファイルのファイルタイプが切り替わると、FileType イベントが発生するので、これを autocmd で捕まえて設定を行います。 現在のバッファが認識しているファイルタイプを確認するには、:set filetype? コマンドを実行します。 下記の例では、Lua/Markdown/Svelte/Ruby ファイルを開いたときに、インデント幅を 2 スペースに設定しています。 カレントバッファーのみに設定を反映するため、Neovim では vim.opt_local、Vim では setlocal (setl) を使用することに注意してください。 Neovim/Lua用 (~/.config/nvim/init.lua) -- ファイルタイプ検出は Neovim では自動で有効なので通常不要ですが、明示するなら以下 vim.cmd(&#39;filetype on&#39;) -- autocmd グループを定義（すでに存在する場合はクリア） local my_group = vim.api.nvim_create_augroup(&#34;my_group&#34;, { clear = true }) -- ファイルタイプ別にインデント設定 vim.api.nvim_create_autocmd(&#34;FileType&#34;, { group = my_group, pattern = { &#34;lua&#34;, &#34;markdown&#34;, &#34;ruby&#34;, &#34;svelte&#34; }, callback = function() vim.opt_local.expandtab = true -- タブキーでスペースを入力する vim.opt_local.shiftround = true -- シフトコマンドでのインデント量を tabstop 単位に丸める vim.opt_local.tabstop = 2 -- タブ文字の表示幅 vim.opt_local.shiftwidth = 2 -- シフトコマンドでのインデント量 vim.opt_local.softtabstop = -1 -- タブキーで入力するスペース数 (-1: tabstop に合わせる) end, }) Vim用 (~/.vimrc) &#34; ファイルタイプ検出を有効にする filetype on augroup my_group &#34; 以前の autocmd コマンドをクリア autocmd! &#34; ファイルタイプ別にインデント設定 autocmd FileType lua,markdown,ruby,svelte setl expandtab tabstop=2 shiftwidth=2 softtabstop=2 shiftround augroup END ☝️ ファイルタイプを追加する 例えば、.svelte という拡張子のファイルを開いたときに svelte というファイルタイプとして認識してくれない場合は、次のようにファイルタイプの設定を追加します。 vim.filetype.add({ extension = { svelte = &#34;svelte&#34;, foo = &#34;mycustomtype&#34;, }, }) 参考 自動インデントモードを有効にする (autoindent, smartindent, cindent) インデント用のスペースを入力する（シフトコマンド） (&gt;&gt;, &lt;&lt;, Ctrl-T, Ctrl-D)"},{url:"/p/i2m4nqt/",title:"Vim/Neovim でインデント用のスペースを入力する（シフトコマンド）",date:"2007-02-20T00:00:00+09:00",body:"Vim/Neovim でインデント用のスペースを入力する（シフトコマンド） Vim にはインデント用のスペースを簡単に入力するためのシフトコマンドが用意されています。 現在のモードによって下記のように入力します。 コマンドモードのとき &gt;&gt; &hellip; 右へ 1 レベルシフト &lt;&lt; &hellip; 左へ 1 レベルシフト 入力モードのとき Ctrl-T &hellip; 右へ 1 レベルシフト Ctrl-D &hellip; 左へ 1 レベルシフト 0 Ctrl-D &hellip; すべてのインデントを取り除く（いったん 0 が表示されますが、次の Ctrl-D で消えます） 参考 インデント（シフトコマンド）を設定する (shiftwidth, shiftround) 自動インデントモードを有効にする (autoindent, smartindent, cindent) ビジュアルモードで簡単にインデントを行えるようにする"},{url:"/p/rocrnht/",title:"Vim で外部の ex スクリプトを実行する",date:"2007-02-14T00:00:00+09:00",body:"Vim で外部の ex スクリプトを実行する Vim エディタでは、複数の ex コマンドを記述したファイル（ex スクリプト）を読み込んで、現在編集中のファイルに対して実行することができます。 下記の ex スクリプト (replace.ex) は、現在編集中のテキストのファイルの AAA を BBB に置換し、保存して終了します。 ex スクリプトの例 (replace.ex) %s/AAA/BBB/g wq この ex スクリプトを実行するには、:source コマンドを使って以下のようにします（省略形は :so** です）。 :so replace.ex Linux には同様のことを行う単独のコマンド ex が標準で付属しています。 Vim を起動しなくても、次のようにして ex スクリプトを任意のファイルに対して実行できます。 $ ex input.txt &lt; replace.ex"},{url:"/p/cismh7n/",title:"Vim で同じテキストを指定した回数だけ繰り返し挿入する",date:"2007-02-09T00:00:00+09:00",body:"Vim で同じテキストを指定した回数だけ繰り返し挿入する i コマンドや o コマンドでインサートモードに入る前に、繰り返しの回数を入力しておくと、Esc でインサートモードを抜けたときに、指定した回数だけ入力したテキストが繰り返し挿入されます。 例: 40個の - を挿入する（罫線のようなもの） 40i-&lt;ESC&gt; 実行結果 ---------------------------------------- 例: 5 行の同じテキストを挿入する 5oあいうえお&lt;ESC&gt; 実行結果 あいうえお あいうえお あいうえお あいうえお あいうえお 上記のように o コマンドを使用すると、同じテキストを 複数行 同時に挿入できます（i コマンドを使うと、同じ行に改行なしで繰り返しテキストが挿入されます）。"},{url:"/p/pyk3j2h/",title:"Python のコーディングスタイル",date:"2007-02-06T00:00:00+09:00",body:"Python のコーディングスタイル Python のコーディングスタイルは、PEP 8 や PEP 257 で指針が示されています。 PEP 8 &ndash; Style Guide for Python Code PEP 257 &ndash; Docstring Conventions このページでは主に上記の内容についてまとめていますが、実際に Python のプロジェクトにコーディングスタイルを適用するときは、Black などの Python フォーマッターを導入 することをおすすめします。 Black は、PEP 8 や PEP 257 と若干異なるところがありますが、理にかなったスタイルを強制的に適用してくれます。 命名規則 大文字／小文字 パッケージ名は小文字のみ（例: mypackage） クラス名は大文字で始める（例: MyClass） 関数、あるいは public メソッドは小文字（例: my_public_method） protected メソッドはアンダースコア 1 つで始める（例: _my_protected_method） private メソッドはアンダースコア 2 つで始める（例: __my_private_method） 定数名はすべて大文字（例: MY_CONSTANT） Python の name mangling の仕組みによって、アンダースコア 2 つで始まる名前は、クラス外部、あるいはサブクラスからその名前ではアクセスできないようになっています（正確には _ClassName__method という名前でアクセスできますが）。 この特性を利用して、private メソッドをアンダースコア 2 つで始めるようにするのがよい、ということです。 グローバル領域でのアンダースコアの使用について トップレベルに定義するクラスや関数で、モジュール（ファイル）内に閉じて外部に公開しないものは、プレフィックスとして 1 つのアンダースコアを付けます。 こうすることで、from M import * の形での自動インポートを防ぐことができます。 # モジュール内部で使う関数 def _parse_timestamp_with_tzinfo(value, tzinfo): &#34;&#34;&#34;Parse timestamp with pluggable tzinfo options.&#34;&#34;&#34; ...省略... # モジュール内部で使うクラス class _RetriesExceededError(Exception): &#34;&#34;&#34;Internal exception used when the number of retries are exceeded.&#34;&#34;&#34; pass モジュール名（ファイル）とパッケージ名（ディレクトリ）は、小文字のみで構成します。 モジュール名は、必要があれば単語の区切りのためにアンダースコアを含めてもよいとされていますが、パッケージ名（ディレクトリ）にはアンダースコアを含めてはいけません。 モジュール名にはアンダースコアを含んでもよい (OK: user.py, user_info.py) パッケージ名にはアンダースコアを含めない (OK: game/, NG: game_db/) これらのアンダースコアの扱いに関しては、PEP 0008 (Style Guide for Python Code) の Package and Module Names のセクションにおいて、下記のように記述されています。 Modules should have short, all-lowercase names. Underscores can be used in the module name if it improves readability. Python packages should also have short, all-lowercase names, although the use of underscores is discouraged. その他の命名規則 独自の Exception クラスは、Exception を継承して作成し、サフィックスに Error を付ける（例: HogeHogeError）。 インスタンスメソッドの最初の引数名は self、クラスメソッドの最初の引数名は cls。 予約語と被る attribute 名を使用したい場合は、変に省略名を付けるのではなく、サフィックスとしてアンダースコアを付ける。ただし、class という名前に関しては、class_ でなく cls を用いる。 インデント／スペース インデントは スペース 4 文字。タブは使用しない。 python のコマンドライン引数で -t を指定すればスペースとタブが混在しているときに警告を表示してくれます（-tt オプションならエラーにしてくれる）。 一行は 79 文字（+ 改行）まで。ただし、ドキュメント (docstring) やコメント行は 72 文字まで。 デフォルトパラメータの = の前後にはスペースを入れない。 def complex(real, imag=0.0): return magic(r=real, i=imag) 長い行の途中で改行する場合は、次の行のインデントは前の行の開き括弧の位置に合わせる。演算子の後ろで改行する。 if (width == 0 and height == 0 and color == &#39;red&#39; and emphasis == &#39;strong&#39; or highlight &gt; 100): クラス内のメソッド間は 1 行の空白行で区切る。トップレベルのクラス定義やメソッドは 2 行の空白行で区切る。 ▽このあたりのルールは有名どころの OSS のコードは ちゃんと守ってます が、ドキュメンテーションコメントの最初の動詞に三単現の s を付けない、というルールはあまり守られていないっぽいです。 開き括弧 (、[ の前後に空白スペースを入れない。 コロン :、セミコロン ; の前に空白スペースを入れない。 算術演算子の前後には空白スペースを入れる。 代入文が複数行に渡って続く場合に、= の位置を空白スペースで揃えたりしない。 エンコーディング形式 Python 3.0 からはエンコーディング形式に UTF-8 が推奨される。 コメントや docstring 以外の文字列リテラルで ASCII 意外のエンコーディング形式を使用する場合は、\\x, \\u, \\U でエスケープすること。 インポート import は次の順番で宣言し、各セクションを空白行で区切る。 標準ライブラリ サードパーティ・ライブラリ ローカル・ライブラリ import random import os import socket import dateutil.parser from dateutil.tz import tzutc import foo import foo.bar import は次のように 1 行ずつ分離して行う。 import os import sys ただし、次のような from -- import -- の形式は 1 行で書いても OK。 from subprocess import Popen, PIPE 上記の import 以降が複数行に渡るときは、次のように括弧で囲めば OK。 from botocore.compat import ( json, quote, zip_longest, urlsplit, urlunsplit, OrderedDict, six, urlparse, get_tzinfo_options, get_md5, MD5_AVAILABLE, HAS_CRT ) コメント コメントはセンテンスになっているべきで、最初の文字は大文字で始める。短いセンテンスは最後のピリオドを省略してよいが、通常はピリオドを省略してはならない。 コメントは基本的には英語で。 ブロックコメントの中のパラグラフは、1 つの # を含む行で区切ること。 インラインコメントの # は、ステートメントの後ろに 2 つ以上のスペースを置いてから記述すること。 モジュール（ファイル）や、クラス、関数などのドキュメンテーションコメントは、docstring 形式 での記述が推奨されています。下記記事を参考にしてください。 Docstring でドキュメンテーションコメントを記述する"},{url:"/p/fw7q8q7/",title:"Vim の ex コマンドでの行範囲指定方法いろいろ",date:"2007-01-30T00:00:00+09:00",body:"Vim の ex コマンドでの行範囲指定方法いろいろ 行範囲指定の基本 Vim の ex コマンドは、: から始めるコマンドモードのことで、各コマンドの先頭には、コマンドをどの行に対して実行するかを示す、行範囲 を指定することができます。 :行範囲 コマンド 行範囲を省略した場合は、コマンドはカレント行にだけ影響を及ぼします。 行範囲に .（ドット）を指定した場合も、同様にカレント行に対してだけ実行されます。 例: カレント行を削除 :d 例: 123 行目を削除 :123 d 例: 10 行目から 20 行目をソート :10,20 sort 行範囲指定の例 行番号ベースで指定する方法 :% &lt;command&gt; &#34; ファイル全体に対して command を実行 :3 &lt;command&gt; &#34; 3 行目に対して command を実行 :3,5 &lt;command&gt; &#34; 3 行目から 5 行目までに対して command を実行 :3,$ &lt;command&gt; &#34; 3 行目から最後の行までに対して command を実行 :. &lt;command&gt; &#34; カレント行に対して command を実行（省略した場合と同様） :.,5 &lt;command&gt; &#34; カレント行から 5 行目までに対して command を実行 :.;+5 &lt;command&gt; &#34; カレント行から 5 行目下の行までに対して command を実行 パターンに一致する文字列を含む行を検索して行指定する方法 :/pattern/ &#34; pattern を含む行（1 行のみ） :/pattern/+1 &#34; pattern を含む行の 1 行下の行（1 行のみ） :/pattern/;+4 &#34; pattern を含む行から 4 行下の行まで :g/pattern/ &#34; pattern を含むすべての行 :/pat1/,/pat2/ &#34; pat1 を含む行から pat2 を含む行まで（最初に見つかった部分のみ） :/pat1/,/pat2/g &#34; pat1 を含む行から pat2 を含む行まで（見つかった範囲すべて） 例: TODO というテキストを含む行をすべて削除 :g/TODO/ d 範囲指定を連続して記述すると AND 条件で絞り込むことができます。 例: 1 行目から 10 行目までで ABC で始まる行をすべて削除 :1,10 g/^ABC/ d"},{url:"/p/etvrhdd/",title:"Vim のカーソル移動方法まとめ",date:"2007-01-30T00:00:00+09:00",body:"Vim のカーソル移動方法まとめ カーソル移動（左右） 入力 説明 h 1 文字左へ l 1 文字右へ 0 行頭へ $ 行末へ 5| カレント行の 5 文字目へ ^ 最初の表示可能な文字へ カーソル移動（行番号指定でジャンプ） 入力 説明 gg :1 1 行目へジャンプ 10gg 10G :10 10 行目へジャンプ G :$ 最終行へジャンプ :$-3 最終行より 3 行上へジャンプ :+10 カレント行から 10 行下へジャンプ 応用例: カーソル位置からファイルの最後までを削除 dG カーソル移動（画面内でジャンプ） 入力 説明 H 画面内の一番上にジャンプ（ホーム行） M 画面内の中央行にジャンプ L 画面内の一番下にジャンプ 3H 画面内の一番上から 3 行目にジャンプ 3L 画面内の一番下から 3 行目にジャンプ カーソル移動（ブロック単位でジャンプ） 入力 説明 w 次の単語の先頭へ W 次の単語の先頭へ（後続する記号も単語の一部とみなす） b 前の単語の先頭へ B 前の単語の先頭へ（後続する記号も単語の一部とみなす） e 単語の末尾へ E 単語の末尾へ（後続する記号も単語の一部とみなす） ( 現在の文の先頭へ ) 次の文の先頭へ { 現在の段落の先頭へ（空行で判断） } 次の段落の先頭へ（空行で判断） [[ 現在のセクションの先頭へ（行頭にある { を検索） ]] 次のセクションの先頭へ（行頭にある { を検索） w や b によるカーソル移動時に、どこまでを単語の切れ目と見なすかは、iskeyword オプションによって設定されています。 現在の設定値を見るには次のようにします。 :set iskeyword? 例えば、次のような値が設定されていることを確認できます。 iskeyword=@,48-57,_,192-255 @ は、C 言語の isalpha() が true を返す文字を示しています。 数値は ASCII コードを示しています。 小文字だけを単語に含むことができることを指定するには、次のようにします。 :set iskeyword=a-z 詳しくは、:help 'iskeyword' と :help 'isfname' で確認してください。 カーソル移動（特殊なジャンプ） 入力 説明 Enter 次の行の表示可能な先頭文字へ + 次の行の表示可能な先頭文字へ - 前の行の表示可能な先頭文字へ `` ジャンプ前のカーソル位置へ戻る '' ジャンプ前のカーソル位置へ戻る（表示可能な先頭文字へ） 対応する括弧にジャンプする 入力 説明 % 対になっている括弧へジャンプ ノーマルモードのとき、括弧の上にカーソルを合わせて % と入力することで、対応する括弧（()、{}、[] など）にジャンプすることができます。 括弧の上にカーソルを合わせなくても、カーソル行に対になっている括弧があれば、そこにジャンプすることができます。 このジャンプは、C 言語のコメントの /* と */ にも対応しており、さらに、プリプロセッサの #ifdef と #else、#endif 間のジャンプにも使用することができます。 デフォルトでは % によりマッチさせる括弧の種類は ()、{}、[] になっていますが、matchpairs オプションで変更することができます。 マッチさせる括弧の設定 (~/.vimrc) set matchpairs=(:),{:},[:]"},{url:"/p/gu9om5z/",title:"Vim/Neovim の画面スクロール方法まとめ (scrolljump, scrolloff, scroll)",date:"2007-01-30T00:00:00+09:00",body:"Vim/Neovim の画面スクロール方法まとめ (scrolljump, scrolloff, scroll) 画面スクロール操作 画面スクロール コマンド 説明 Ctrl-f 1 画面下へスクロール Ctrl-b 1 画面上へスクロール Ctrl-d 半画面下へスクロール、あるいは scroll オプションで指定された行数だけ下へスクロール Ctrl-u 半画面上へスクロール、あるいは scroll オプションで指定された行数だけ上へスクロール 表示位置を移動 下記の操作では、カーソル位置（行）をキープしたまま、画面の表示位置だけを移動させます。 コマンド 説明 z&lt;CR&gt; カレント行を画面上端へ ※1 zz カレント行を画面中央へ z. カレント行を画面中央へ（カーソルを最初の非空白文字へ） zb カレント行を画面下端へ z- カレント行を画面下端へ（カーソルを最初の非空白文字へ） z+ 画面下端を画面上端へ（これ使い道ある？） Ctrl-y 1 行下へスクロール Ctrl-e 1 行上へスクロール ※1 例えば、ソースコードの関数名を定義している行で、z [Enter] とすれば、その関数の定義が画面上端から表示されます。 z コマンドは、scrolloff オプションに 0 以外が設定されていると、その値によって移動後の表示位置が少々変わります。 z コマンドを実行するときに数値プレフィックスを付けると、カレント行とみなす行番号を指定することができます。 例: 30 行目が画面上端に表示されるように移動 30z[Enter] 画面上端、下端でのスクロール方法の設定 (scrolljump, scrolloff) 1 番上の行にカーソルがあるときに、さらに上へカーソルを移動させようとするとスクロールが発生します。 このときのスクロール行数は scrolljump オプションで指定することができます（デフォルトは 1）。 :set scrolljump=1 カーソルが画面の上端、下端まで行く前にスクロールを開始するには、scrolloff オプションで何行残してスクロールを開始するかを指定します（デフォルトは 0）。 この値を 0 以外にしておくと、スクロールが早めに始まるので作業効率が上がります。 :set scrolloff=5 ~/.config/nvim/init.lua（Neovimの設定ファイル） -- Number of context lines to keep above and below the cursor (default: 0). vim.opt.scrolloff = 10 画面スクロール量の設定 (scroll) Ctrl-d や Ctrl-u による画面スクロール行数は、scroll オプションで設定できます。 個人的には、一度に画面半分もスクロールされると脳がついていけないので、3 行くらいのスクロールに変更しておくと使いやすいです。 :set scroll=3 ただし、この設定は Vim エディタのウィンドウサイズを変更したタイミングなどでリセットされてしまいます。 そのため、設定ファイルで scroll オプションを設定するときは、下記のように autocmd を使ってバッファ切り替え時に再設定するようにしておくとよいでしょう。 ~/.vimrc（Vimの設定ファイル） &#34; Number of lines to scroll with CTRL-U and CTRL-D commands. &#34; scroll 値は自動的に変更されてしまうため、バッファ切替時に再設定しておく。 autocmd BufEnter * setlocal scroll=3 ~/.config/nvim/init.lua（Neovimの設定ファイル） vim.api.nvim_create_autocmd(&#34;BufEnter&#34;, { pattern = &#34;*&#34;, callback = function() -- Number of lines to scroll with CTRL-U and CTRL-D commands. -- scroll 値は自動的に変更されてしまうため、バッファ切替時に再設定しておく。 vim.opt_local.scroll = 3 end, }) （追記）この scroll オプションの指定は、telescope.nvim プラグインとの相性が悪いようです（telescope のウィンドウを開いたときにエラーが発生します）。 現状この設定はコメントアウトしています。"},{url:"/p/g5xg2nc/",title:"Python で SQLite データベースを扱う",date:"2007-01-25T00:00:00+09:00",body:"Python で SQLite データベースを扱う Python は標準ライブラリとして sqlite3 モジュールを備えています。 SQLite3 データベースへの接続 sqlite3.connect 関数でデータベースファイルを指定すると、SQLite3 データベースへの接続（sqlite3.Connection オブジェクト）を取得できます。 指定したデータベースファイルが存在しない場合は新規に作成されます。 SQLite DB へ接続する import sqlite3 # Create a Connection object. conn = sqlite3.connect(&#34;sample.db&#34;) テーブルの作成 SQL コマンドを実行するには、Connection#cursor メソッドで sqlite3.Cursor オブジェクトを作成し、execute メソッドを呼び出します。 次の例では、データベースに新しい memo テーブルを作成しています。 memo テーブルを作成する # Create a Cursor object from Connection object. cur = conn.cursor() # Create a table cur.execute(&#34;&#34;&#34;CREATE TABLE memo (date TEXT, title TEXT, body TEXT)&#34;&#34;&#34;) テーブルにレコードを追加 テーブルを作成するのと同様に、Cursor#execute メソッドを使ってレコードを追加できます。 レコードを追加する # Insert a record cur.execute(&#34;&#34;&#34;INSERT INTO memo VALUES(&#39;2007-01-01&#39;, &#39;Memo1&#39;, &#39;Body1&#39;)&#34;&#34;&#34;) DB-API の ? 文字によるパラメータ置換（プレースホルダ機能）を使えば、各列の値を保持したタプルを渡すことによってレコードを追加することができます。 t = (&#34;2007-01-01&#34;, &#34;Memo1&#34;, &#34;Body1&#34;) cur.execute(&#34;INSERT INTO memo VALUES(?,?,?)&#34;, t) 例えば、下記のようにループでタプルを処理すれば、複数のレコードを一度に追加できます。 tuples = ( (&#34;2007-01-01&#34;, &#34;Memo1&#34;, &#34;Body1&#34;), (&#34;2007-01-02&#34;, &#34;Memo2&#34;, &#34;Body2&#34;), (&#34;2007-01-03&#34;, &#34;Memo3&#34;, &#34;Body3&#34;), ) for t in tuples: cur.execute(&#34;INSERT INTO memo VALUES(?,?,?)&#34;, t) 一方で、以下のように % を使って SQL クエリ文字列を作成してしまうと、SQL インジェクション攻撃に対して脆弱性が残ってしまう可能性が高いので、DB-API の ? を使ったパラメータ置換を行うようにしたほうが安全です。 危険な方法 t = (&#34;2007-01-01&#34;, &#34;Memo1&#34;, &#34;Body1&#34;) cur.execute(&#34;INSERT INTO memo VALUES(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&#34;, t) テーブルからレコードを検索 Cursor#execute メソッドで SELECT 文を実行した後は、Cursor オブジェクトをイテレータとして用いることにより、検索結果を順番に取得していくことができます。 レコード検索の基本（Cursor によるイテレート） sample.py cur = conn.cursor() cur.execute(&#34;SELECT * FROM memo&#34;) for row in cur: print(row) 実行結果 (u&#34;2007-01-01&#34;, u&#34;Memo1&#34;, u&#34;Body1&#34;) (u&#34;2007-01-02&#34;, u&#34;Memo2&#34;, u&#34;Body2&#34;) (u&#34;2007-01-03&#34;, u&#34;Memo3&#34;, u&#34;Body3&#34;) 検索結果をひとつだけ取得する (Cursor#fetchone()) Cursor#fetchone メソッドを使うと、検索結果を 1 つだけタプルで取得できます。 sample.py cur.execute(&#34;SELECT * FROM memo&#34;) result = cur.fetchone() print(result) 実行結果 (u&#34;2007-01-01&#34;, u&#34;Memo1&#34;, u&#34;Body1&#34;) 検索結果をリストで取得する (Cursor#fetchall()) Cursor オブジェクトを使って検索結果をイテレートするのではなく、リストデータとして一度に読み取ってしまうこともできます。 sample.py cur.execute(&#34;SELECT * FROM memo&#34;) results = cur.fetchall() print(results) 実行結果 [(u&#34;2007-01-01&#34;, u&#34;Memo1&#34;, u&#34;Body1&#34;), (u&#34;2007-01-02&#34;, u&#34;Memo2&#34;, u&#34;Body2&#34;), (u&#34;2007-01-03&#34;, u&#34;Memo2&#34;, u&#34;Body3&#34;)] 最大 n 個の検索結果をリストで取得する (Cursor#fetchmany(n)) Cursor#fetchmany メソッドを使用すると、指定した数だけレコードを取得できます。 sample.py cursor.execute(&#34;SELECT * FROM memo&#34;) print(cursor.fetchmany(2)) 実行結果 [(u&#34;Title 1&#34;, u&#34;Body 1&#34;), (u&#34;Title 2&#34;, u&#34;Body 2&#34;)]"},{url:"/p/f8v2npx/",title:"Vim の文字の置換方法まとめ (:s, :substitute)",date:"2007-01-08T00:00:00+09:00",body:"Vim の文字の置換方法まとめ (:s, :substitute) Vim の s (substitute) コマンドを使用すると、ファイル内の任意の範囲のテキストをまとめて置換することができます。 substitute コマンドの基本 substitute コマンドは、ノーマルモード中に下記のように入力して実行します。 :&lt;行範囲&gt; s/&lt;置換前パターン&gt;/&lt;置換後パターン&gt;/&lt;フラグ&gt; 指定した &lt;行範囲&gt; のテキストの中で、&lt;置換前パターン&gt; に一致する文字列を &lt;置換後パターン&gt; に置換します。 substitute コマンドは通常、上記のように省略系の s を使って実行します。 デフォルトでは、行内で最初に見つかった文字列だけを置換しますが、&lt;フラグ&gt; 部分に g（global フラグ）を指定することで、行内のすべての文字列を置換することができます。 :s/old/new/ &#34;カレント行の文字列を置換（1 つだけ置換） :s/old/new/g &#34;カレント行の文字列を置換（すべて置換） 上記のように &lt;行範囲&gt; の指定を省略した場合は、カレント行のみが置換対象になりますが、そのような使い方はまれでしょう。 ファイル内の全ての行を置換対象にしたい場合は、&lt;行範囲&gt; として % を指定します（1,$ としても同様）。 下記の例では、% の後ろにスペースを入れていますが、このスペースは省略することができます。 :% s/old/new/g &#34;ファイル全体の文字列を置換 置換対象とする行範囲を指定したい時は、下記のように明示的に 開始行,終了行 を指定することもできますし、 :1,5 s/old/new/g &#34;1～5行目までを置換対象にする :5,$ s/old/new/g &#34;5行目～最終行までを置換対象にする Shift-V で行選択した状態から、:s/old/new/g と続けて実行することもできます（こちらの方法がオススメ）。 行選択した状態で : をタイプすると、コマンドの入力欄には下記のように表示されますが、これは行選した択範囲を操作対象としていることを示しています。 そのまま s/old/new/g と続けて入力すれば OK です。 :&#39;&lt;,&#39;&gt; 区切り文字にスラッシュ (/) 以外を使用する :s/old/new/g という置換コマンド自体がスラッシュを含んでいるため、置換対象の文字列にスラッシュが含まれる場合は、下記のようにバックスラッシュを使ったエスケープ処理が必要です（/ ではなく \\/ と入力する）。 例: /home/aaa を /home/bbb に置換する (1) :% s/\\/home\\/aaa/\\/home\\/bbb/g このようなエスケープ処理の煩雑さを防ぐために、substitute コマンドでは、セパレータ文字列としてスラッシュ以外のほとんどの種類の記号を使用できるようになっています。 下記の例は、セパレータ文字としてスラッシュの代わりにセミコロン (;) を使用しています。 例: /home/aaa を /home/bbb に置換する (2) :% s;/home/aaa;/home/bbb;g 正規表現を使ったパターン検索 &lt;置換前パターン&gt; の部分では正規表現を使用することができます。 ほとんどの特殊文字（+など）は、バックスラッシュをつけてエスケープしないといけないことに注意してください。 特殊文字 意味 \\a アルファベット文字に一致（[A-Za-z] と同様） \\A 非アルファベット文字に一致（[^A-Za-z] と同様） \\d 数字に一致（[0-9] と同様） \\D 非数字に一致（[^0-9] と同様） \\w 英数字に一致（[0-9A-Za-z] と同様） \\W 非英数字に一致（[^0-9A-Za-z] と同様） \\o 8進数に一致（[0-7] と同様） \\O 非8進数に一致（[^0-7] と同様） \\x 16進数に一致（[0-9A-Fa-f] と同様） \\X 非16進数に一致（[^0-9A-Fa-f] と同様） \\s スペースあるいはタブに一致 \\S スペースでもタブでもない文字に一致 \\t タブ文字に一致 . 任意の 1 文字に一致 \\+ 前の文字の 1 回以上の繰り返し（できるだけ多くの回数に一致） \\{-1,} 前の文字の 1 回以上の繰り返し（最も少ない回数に一致） * 前の文字の 0 回以上の繰り返し（できるだけ多くの回数に一致） \\{-} 前の文字の 0 回以上の繰り返し（最も少ない回数に一致） \\= 前の文字の 0 回、あるいは 1 回に一致（一般的な正規表現の ? に相当） \\&lt; 単語の始まりに一致 \\&gt; 単語の終わりに一致 [ 文字グループの開始 ] 文字グループの終了 ^ 行頭に一致（文字グループの先頭で使用すると「それ以外の文字」の意味になる） $ 行末に一致 パターン|パターン どちらかのパターンに一致 \\(パターン\\) 一致部分を後から参照するためにマークする ほとんどの文字はエスケープしなければいけないので、エスケープしなくてもよい特殊文字を覚えておくのがよいでしょう（.、*、[、]、^、$）。 逆にこれらを、その文字そのものとして扱う場合はエスケープが必要です（例: . という文字に一致させたいなら \\. と入力する）。 [:alnum:] や [:alpha:]、[:digit:] といった文字クラスも使用できますが、上記の特殊文字を覚えておけばほとんどのケースはカバーできます。 例: 単語の境界を意識して child を children に置換する :% s/\\&lt;child\\&gt;/children/g 例: ing で終わる単語を XXX に置換 :% s/\\&lt;[^ ]*ing\\&gt;/XXX/g 例: apple あるいは apples を banana に置換 :% s/apples\\=/banana/g 例: カレント行から 5 行分の行頭に引用記号 (&gt; ) を挿入する :.,+4 s/^/&gt; / 実際には、複数行の行頭に同じテキストを挿入したい場合は、上記のようなコマンドを使用するより、CTRL-V で行頭を矩形選択して SHIFT-I でテキスト入力する、という方法の方が手軽です。 パターンに一致した文字列を置換後パターンの中で参照する &lt;置換前パターン&gt; に実際に一致した文字列は、&lt;置換後パターン&gt; の中で &amp; で参照することができます。 例: ファイル全体の google を google.com に置換する :% s/google/&amp;.com/g 上記のように記述すると、&amp; の部分に google と記述したのと同じ振る舞いをします。 上記の使い方はあまり意味がないかもしれませんが、次のように正規表現を使用してパターンマッチングさせた場合に効果を発揮します（実際に一致した文字列は &amp; で参照するしかありません）。 例: 連続する数字を【】で囲む :% s/\\d\\+/【&amp;】/g &lt;置換前パターン&gt; の中で、\\( と \\) でパターンをグループ化しておくと、後から実際に一致した文字列を \\1 で参照することができます。 複数のグループがある場合は、それぞれ \\1、\\2、\\3 のように参照します。 例: 「」で囲まれた部分を『』で囲みなおす :% s/「\\(.\\{-}\\)」/『\\1』/g &lt;置換前パターン&gt; の中の \\{-} という表現が分かりにくいかもしれませんが、これは直前の文字の 0 回以上の繰り返しで最短一致させる特殊表現です（* を使用すると最長一致になってしまいます）。 この表現を使用することで、下記のように行内にパターン一致する部分が複数登場する場合にもうまく置換できます。 置換前 「これは」 「サンプルの」 「テキストだよ」 置換後 『これは』 『サンプルの』 『テキストだよ』 大文字と小文字を変換する すべての行の Help を大文字の HELP に置換する :% s/help/\\U&amp;/g \\U は、その後ろに続くテキストをすべて大文字に変換します。 &amp; は &lt;置換前パターン&gt; に一致した実際のテキストを表すため、上記の場合は &amp; は help になります。 それがすべて大文字に変換されるため、結果的に HELP に置換されることになります。 カレント行をすべて大文字／小文字に置換する :s/.*/\\U&amp;/g &#34;すべて大文字に置換 :s/.*/\\u&amp;/g &#34;すべて小文字に置換 SHIFT-V で行全体を選択して、U（あるいは u）とタイプしても同様のことを行えます。 パターンに一致する文字列を削除する s コマンドによる置換を行うときに、&lt;置換後パターン&gt; を空っぽにしておけば、&lt;置換前パターン&gt; に一致する文字列を削除することができます。 例: 行頭のスペースとタブをすべて削除する :% s/^\\s\\+// 例: 行末のスペースとタブをすべて削除する :% s/\\s\\+$// Vim では、正規表現の + は \\+ とエスケープしないといけないことに注意してください。 参考: 正規表現にマッチする行を削除する 1 単語ずつ確認しながら置換する c フラグを使う方法 置換時に &lt;フラグ&gt; として c（confirm フラグ）を指定すると、置換対象となる文字列に関して、1 つずつ置換するかどうかを確認しながら置換していくことができます。 置換対象となる文字列が順番にハイライトされていくので、置換するなら y、置換しないなら n を入力していきます。 :% s/old/new/gc 検索しながら繰り返しコマンドで置換する方法 ちょっとマニアックですが、こんな手順で置換を繰り返していくこともできます。 /&lt;単語&gt; で目的の単語を検索。 cw で単語を置き換え、ESC で insert モードを抜ける。 n で次の単語に移り、置換したい場合は . で置換する、という操作を繰り返す。 例: old という単語を検索しながら new に置き換えていく /old cwnew [Esc] nnnn . nnn . この操作例では、まず old というテキストを検索し、cw コマンドでその単語を new に置換しています。 あとは、n で次の置換対象までジャンプし、. で置換コマンドを再実行しています。 置換パターンの中で改行を扱う 置換パターンの中で改行文字を入力するには、CTRL-V → Enter（あるいは CTRL-Q → Enter）とタイプする必要があります。 コマンド入力欄には、^M と表示されて見えます。 例: aaa を bbb[改行]ccc に置換する :% s/aaa/bbb^Mccc/g 例: セミコロンの後ろに改行を挿入する :% s/;/;^M/g"},{url:"/p/oh8nhyw/",title:"Vim で別ファイルの内容や外部コマンドの出力を挿入する (:read)",date:"2006-12-21T00:00:00+09:00",body:"Vim で別ファイルの内容や外部コマンドの出力を挿入する (:read) 別ファイルの内容を挿入する Vim の :read コマンド（省略形は :r）を使用すると、現在カーソルがある行に別のテキストファイルの内容を挿入することができます。 カレント行に別ファイルの内容を挿入 :r /home/maku/sample.txt 行番号を先に指定すれば、任意の位置に挿入することができます。 ファイルの先頭 (0) に別ファイルの内容を挿入 :0 r /home/maku/sample.txt ファイルの末尾 ($) に別ファイルの内容を挿入 :$ r /home/maku/sample.txt 外部コマンドの出力を挿入する :read コマンドのパラメータとして、ファイル名の代わりに !コマンド名 を指定すると、任意のコマンドの出力結果をカーソル位置に挿入することができます。 ls コマンドの出力をカーソル位置に挿入 :r !ls 以下のように挿入位置を指定する方法でも同様のことを行えます。 :. !ls 外部コマンドによるテキストフィルタリング 行範囲を指定して外部コマンドを実行すると、その範囲のテキストを外部コマンドの標準入力へ渡すことができます。 指定した範囲のテキストは、外部コマンドの出力結果で置き換えられます。 1 行目から 5 行目までをソートする :1,5 !sort 上記のように実行すると、外部コマンドの sort が実行されます。 ちなみに、行ソートを行いたいときは、通常は Vim 組み込みの sort を使用すれば事足ります。 ソートしたい行範囲を Shift-V で選択し、次のようにソートを実行できます。 :sort"},{url:"/p/9pyh4ip/",title:"Vim のファイル保存コマンド :w、:x の基本",date:"2006-12-21T00:00:00+09:00",body:"Vim のファイル保存コマンド :w、:x の基本 ファイル保存の基本 (:w) Vim で編集内容を保存するためのもっとも基本的なコマンドは :write（省略系は :w）です。 :w &#34; 上書き保存 :w file.txt &#34; file.txt という名前で保存 :w &gt;&gt; file.txt &#34; file.txt に追記保存 ファイルを保存してついでに閉じる (:x) :w の代わりに :x を使用すると、ファイルを保存して、ついでにカレントバッファを閉じることができます。 :wq でも「保存して閉じる」という操作を同時に行うことができますが、:x とは若干振る舞いが異なります。 :x &#34; ファイルが編集されている場合のみ保存してバッファを閉じる :wq &#34; ファイルが編集されていなくても保存してバッファを閉じる"},{url:"/p/k7r37a7/",title:"Vim で指定した行範囲を一時的に表示する",date:"2006-12-20T00:00:00+09:00",body:"Vim で指定した行範囲を一時的に表示する Vim エディタ内で下記のようなコマンドを実行すると、指定した行範囲のテキストを一時的に表示することができます。 :行範囲 p 上記のコマンドの代わりに下記のように実行すると、行番号付きで表示することができます。 :行範囲 # :行範囲 number 例: 5 行目から 10 行目までを表示 :5,10 p :5,10 # &#34;行番号付き :5,10 nu &#34;行番号付き 例: 20 行目から 5 行下の行までを表示 :20;+5 p :20;+5 # &#34;行番号付き :20;+5 nu &#34;行番号付き 例: TODO という文字列を含む行をすべて表示 :g/TODO/ p :g/TODO/ # &#34;行番号付き :g/TODO/ nu &#34;行番号付き プレフィックスの g を省略すると、一行だけを表示します。"},{url:"/p/fmbya48/",title:"Vim で切り取り＆貼り付け操作、レジスタの扱いについて理解する",date:"2006-12-13T00:00:00+09:00",body:"Vim で切り取り＆貼り付け操作、レジスタの扱いについて理解する 切り取り、ヤンク（コピー）、貼り付けの基本【無名レジスタ】 d, x コマンドなどでテキストを削除したときや、y コマンドでテキストをヤンクした場合、そのテキストは 無名レジスタ &quot;&quot; に保存されます。 無名レジスタの内容は p, P コマンドで貼り付けることができます。 ノーマルモードでの操作 dd -- カレント行を削除 yy(Y) -- カレント行をヤンク p -- 貼り付け D -- カーソル位置から行末までを削除 C -- カーソル位置から行末までを置換（削除して挿入モードへ） s -- カーソル位置の 1 文字を削除して挿入モードへ S -- カーソルのある行を削除して挿入モードへ 名前付きレジスタに切り取り／ヤンク（コピー）／貼り付け x, d, y などの削除／ヤンクコマンドの前に、名前付きレジスタ を指定すると、そのレジスタにテキストの内容を保存できます。 名前付きレジスタには、&quot;a から &quot;z までのいずれかを指定します。 p, P コマンドの前に名前付きレジスタを指定すれば、そのレジスタの内容を貼り付けることができます。 ノーマルモードでの操作 &#34;a yy -- カレント行を &#34;a にヤンク（コピー） &#34;a dd -- カレント行を &#34;a に切り取り &#34;a 3d -- 3 行を &#34;a に切り取り &#34;a p -- &#34;a の内容をカーソルの後ろに貼り付け &#34;a P -- &#34;a の内容をカーソルの前に貼り付け ex コマンドで同様のことを行う場合は、コマンドの後ろにスペースを入れてからレジスタ名を指定します。 ex コマンド :10,20ya a -- 10 行目から 20 行目までを &#34;a にヤンク（コピー） :pu a -- &#34;a の内容をカーソルの後ろに貼り付け 挿入モードでは Ctrl-R に続けてレジスタ名を入力することで、その内容を挿入することができます。 挿入モード ^Ra -- レジスタ a の内容を挿入 名前付きレジスタに格納したテキストにアペンドする レジスタ名を大文字で指定することにより、名前付きレジスタに既に格納されている内容に対して、テキストをアペンドすることができます。 ノーマルモードでの操作 &#34;A yy -- カレント行の内容をレジスタ &#34;a にアペンド OS のクリップボードへのコピー／貼り付け（レジスタ: &ldquo;*）(for Windows) クリップボード・レジスタ &quot;* は OS のクリップボードとの同期用に用意されています。 レジスタ &quot;* に対して y, p コマンドなどを実行すると、OS のクリップボードのテキストをコピーしたり、貼り付けたりすることができます。 &#34;*yy -- クリップボードへカレント行をコピー &#34;*p -- クリップボードの内容を貼り付け 設定: クリップボードの内容と無名レジスタの内容を同一にする OS クリップボードとの同期のために、いちいち &quot;* レジスタを指定するのが面倒な場合は、 :set clipboard+=unnamed と設定しておくと、自動的にクリップボード・レジスタ &quot;* の内容と無名レジスタ &quot;&quot; の内容が同期されるようになります。 その結果、レジスタを指定しないでもクリップボードへのコピー、クリップボードからの貼り付けが可能になります。 詳しく仕組みについては :help gui-clipboard を参照してください。 番号付きレジスタ (レジスタ: &ldquo;1 ～ &ldquo;9） d コマンドにより削除したテキストは、番号付きレジスタ（&quot;1 ～ &quot;9）に直近の削除内容が 9 つまで保持されます。 例えば、最後に削除したテキストはレジスタ &quot;1 に格納されており、3 つ前に削除されたテキストはレジスタ &quot;3 に格納されています。 これらの内容はいつでも取り出して貼り付けることができます。 &#34;3p -- 3 つ前に削除されたテキストを貼り付け 番号付きレジスタに保存されるのは、削除したテキストだけで、ヤンク（コピー）したテキストは保存されないことに注意してください。 ブラックホールレジスタ（レジスタ: &ldquo;_） ヤンク／削除したテキストは自動的に無名レジスタ &quot;&quot; や、番号付きレジスタ (&quot;1 ～ &quot;9) に格納されますが、どのレジスタにもテキストの内容を保存したくない場合は、ブラックホールレジスタ &quot;_ を指定して削除を実行します。 &#34;_dd 現在のレジスタの内容を一覧表示する 下記のコマンドを実行することで、現在レジスタに保持されている値を一覧表示できます。 :reg[isters] -- すべてのレジスタの内容を表示 :reg[isters] abc -- レジスタ a, b, c の内容を表示 実行例 :reg --- レジスタ --- &#34;&#34; hoge &#34;1 aaa &#34;2 bbbasdf &#34;3 Hello &#34;4 abc^J &#34;5 bbb &#34;6 CCC &#34;7 ddd &#34;8 EEE &#34;9 asdf sdf &#34;a dd &#34;b I// ^[ &#34;c kvvkvk &#34;- &#34;* クリップボード &#34;. &#34;: やほ &#34;/ レジスタの内容は、ファイル (~/.viminfo) に保存されているため、Vim を再起動しても前回格納した値を取得することができます。"},{url:"/p/3m53tcz/",title:"Vim で行情報を表示する",date:"2006-12-12T00:00:00+09:00",body:"Vim で行情報を表示する Vim エディタ上で下記のようなコマンドを実行すると、行の情報を表示することができます。 ^G &hellip; カレント行の情報を表示する（行番号、ファイル全体の相対位置など） := &hellip; ファイル全体の行数を表示する :.= &hellip; カレント行の行番号を表示する :/pattern/ = &hellip; パターンに一致する最初の行番号を調べる"},{url:"/p/x8f9e87/",title:"Vim/Neovim を起動するときに行番号や検索パターンを指定してファイルを開く (+n)",date:"2006-12-12T00:00:00+09:00",body:"Vim/Neovim を起動するときに行番号や検索パターンを指定してファイルを開く (+n) 行番号を指定してファイルを開く Vim (Neovim) を起動するときに、+数値 オプションを指定すると、カーソルの初期フォーカス行を指定してファイルを開くことができます。 数値を省略して + のみを指定すると、最終行に移動します。 $ vim +100 filename # ファイルを開いて 100 行目へ移動 $ vim + filename # ファイルを開いて最終行へ移動 検索パターンを指定してファイルを開く Vim (Neovim) を起動するときに、__+/パターン オプションを指定すると、指定した正規表現に一致する文字列を含んだ行をフォーカスした状態でファイルを開くことができます。 $ vim +/pattern filename # ファイルを開いて pattern にヒットする行へ移動 このオプションを指定してファイルを開くと、/ コマンドで検索された状態でファイルが開くので、続けて n キーを押すことで次のヒット位置に移動できます。"},{url:"/p/u4gw7c3/",title:"Vim でカレントファイル内の文字列を検索する (/, ?, *, #)",date:"2006-12-06T00:00:00+09:00",body:"Vim でカレントファイル内の文字列を検索する (/, ?, *, #) 検索の基本 Vim でカレントファイル内の文字列を検索するには、次のような検索コマンドを使用します。 入力 説明 /pattern [Enter] パターンを検索（順方向） ?pattern [Enter] パターンを検索（逆方向） n 次の一致箇所にジャンプ N 前の一致箇所にジャンプ / [Enter] 同じパターンで再検索（順方向） ? [Enter] 同じパターンで再検索（逆方向） * カーソル下の単語を後方検索（g* で部分一致検索） # カーソル下の単語を前方検索（g# で部分一致検索） パターンによる検索 (/, ?) 検索パターンでは正規表現を使用できます。 例: void で始まる行を検索 ^ /^void &#34; ^ は行頭に一致 例: 0 回以上の繰り返しに一致 * /te* &#34; t, te, tee などに一致 例: 1 回以上の繰り返しに一致 \\&#43; /te\\+ &#34; te, tee, teee などに一致 例: 0 回あるいは 1 回に一致 \\= /te\\= &#34; t あるいは te に一致 例: 任意のアルファベット (A-Za-z) に 1 文字だけ一致 \\a /\\a\\a\\a &#34; 任意の 3 文字のアルファベットに一致 例: 任意の数字に 1 文字だけ一致 \\d /\\d\\d\\d &#34; 任意の 3 桁の数字に一致 例: いずれかの文字に一致 [...] /[Tt]he &#34; The, the を検索 （:set ignorecase しておく手もあり） /x[+*%]y &#34; x+y, x*y, x%y を検索 /x[\\^\\-]y &#34; x^y, x-y を検索 （ブラケット式の中の ^ や - はエスケープする） 例: 繰り返し回数の指定 \\{min,max} /a\\{3,5} &#34; aaa, aaaa, aaaaa に一致 （aaaaa があれば aaaaa に一致する） /a\\{-3,5} &#34; aaa, aaaa, aaaaa に一致 （aaaaa があっても aaa に一致する） /a\\{3,} &#34; 3 個以上の a に一致 /a\\{,3} &#34; 3 個以下の a に一致 /a\\{3} &#34; 3 個の a に一致 例: グルーピング \\(...\\) /\\(abc\\)\\+ &#34; abc, abcabc, abcabcabc などに一致 &#34; \\( と \\) で囲まれた部分に一致したテキストの繰り返し /\\(ab\\+c\\)\\1 &#34; abcabc, abbcabbc などに一致 &#34; \\( と \\) で囲まれた部分に一致したテキストを \\1 で参照 例: OR 検索（文字列1\\|文字列2） /foo\\|bar &#34; foo か bar に一致 例: print で始まる単語を検索 \\&lt; /\\&lt;print &#34; \\&lt; は単語の先頭に一致 例: 単語 word を検索 \\&lt; ... \\&gt; /\\&lt;word\\&gt; &#34; \\&lt; は単語の先頭、\\&gt; は単語の末尾に一致 例: 文字クラスの利用 [: ... :] /^[[:digit:]] &#34; 数字で始まる行を検索 &#34; ブラケット式の中の [:digit:] という文字クラスは数字を表す 検索履歴 / や ? による検索モードで、CTRL-P や CTRL-N（あるいは上下カーソルキー）を入力すると、検索履歴を表示することができます。 過去に入力した複雑な検索パターンで再検索したいときに便利です。 カーソル位置の単語を検索する (*, #) Vim のノーマルモードで、* や # を入力すると、カーソル位置にある単語を後方検索、前方検索することができます。 入力 説明 * カーソルの下の単語を後方検索（g* で単語を一部に含む文字列も検索） # カーソルの下の単語を前方検索（g# で単語を一部に含む文字列も検索） 続けて、n（あるいは N）を入力することで、次の一致場所にジャンプすることができます。 検索後は同じ単語の上にカーソルが移動するので、実際には続けて * を入力することでも次の一致場所にジャンプすることができます。 つまり、同じ単語で連続して検索する場合、連続して入力するキーは、n と * のどちらでも構いません。 応用 識別子検索 [I &#34; カーソル位置のキーワードを含む行をすべて表示する [D &#34; カーソル位置のマクロ定義を含む行をすべて表示する 例: 行内に限定して検索 fx &#34; カレント行の次の文字 x へ移動 Fx &#34; カレント行の前の文字 x へ移動 tx &#34; カレント行の次の文字 x のひとつ前の文字へ移動 Tx &#34; カレント行の前の文字 x のひとつ後ろの文字へ移動 ; &#34; 前回の行内の文字検索を繰り返し（同じ方向） , &#34; 前回の行内の文字検索を繰り返し（逆の方向） 例: ピリオドまでのテキストを削除 dt. 例: 閉じ括弧 `)` までのテキストを置換 ct) 例: 空白スペースまでを削除 dt &#34; 最後にスペースを入力しています"},{url:"/p/ds9wgfz/",title:"Python で 2 つの dictionary をマージする (update)",date:"2005-10-20T00:00:00+09:00",body:"Python で 2 つの dictionary をマージする (update) dictionary に別の dictionary をマージする Python で 2 つの dictionary オブジェクトをマージするには dict.update() メソッドを使用します。 例えば、d1 という dictionary オブジェクトに、d2 という dictionary オブジェクトの内容をマージするには次のようにします。 &gt;&gt;&gt; d1 = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;org&#39;: &#39;d1&#39;} &gt;&gt;&gt; d2 = {&#39;three&#39;: 3, &#39;four&#39;: 4, &#39;org&#39;: &#39;d2&#39;} &gt;&gt;&gt; d1.update(d2) &gt;&gt;&gt; d1 {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;org&#39;: &#39;d2&#39;, &#39;three&#39;: 3, &#39;four&#39;: 4} &gt;&gt;&gt; d2 {&#39;three&#39;: 3, &#39;four&#39;: 4, &#39;org&#39;: &#39;d2&#39;} ポイント d1 の内容は変化しますが、d2 の内容は変化しません。 d1 と d2 に同じキーが存在する場合、d2 の値で上書きされます（上記の例では d1['org'] の値が上書きされています）。 もとの ditionary の内容を変化させずに新しい dictionary を作る 2 つの dictionary オブジェクト（dict1 と dict2）の内容を変化させずに内容をマージするには、** 演算子を使って、次のように新しい dictionary オブジェクトを作成します。 同じキーが存在する場合は、後ろに記述した dictionary の値が優先されます。 &gt;&gt;&gt; dict1 = {&#39;a&#39;: 1, &#39;b&#39;: 2} &gt;&gt;&gt; dict2 = {&#39;b&#39;: 3, &#39;c&#39;: 4} &gt;&gt;&gt; merged_dict = {**dict1, **dict2} &gt;&gt;&gt; merged_dict {&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;c&#39;: 4} &gt;&gt;&gt; dict1 {&#39;a&#39;: 1, &#39;b&#39;: 2} &gt;&gt;&gt; dict2 {&#39;b&#39;: 3, &#39;c&#39;: 4} 別の方法として、dict.copy() で dictionary オブジェクトをコピーしておいて、そこに対してマージするという方法もあります。 下記のコードは上記のコードと同じ結果になります。 &gt;&gt;&gt; dict1 = {&#39;a&#39;: 1, &#39;b&#39;: 2} &gt;&gt;&gt; dict2 = {&#39;b&#39;: 3, &#39;c&#39;: 4} &gt;&gt;&gt; merged_dict = dict1.copy() # dict1 のコピーを作成 &gt;&gt;&gt; merged_dict.update(dict2) # dict2 をマージ 一般的に、** 演算子を使用した方が、コードをより簡潔に記述することができます。 この方法を用いれば、3 つ以上の dictionary をマージすることができ、マージの際に他のキーと値を追加することも可能です。 merged_dict = {**dict1, **dict2, **dict3, &#39;foo&#39;: &#39;bar&#39;}"},{url:"/p/83e3wrw/",title:"Python で dictionary からキーや値のリストを作成する (keys, values, items)",date:"2005-10-20T00:00:00+09:00",body:"Python で dictionary からキーや値のリストを作成する (keys, values, items) Python の dictionary オブジェクトから、「キーのリスト」、「値のリスト」、「キーと値をペアにしたリスト」を取り出すには、それぞれ下記のようなメソッドを使用します。 d.keys() &hellip; キーのリスト（戻り値は dict_keys オブジェクト） d.values() &hellip; 値のリスト（戻り値は dict_values オブジェクト） d.items() &hellip; (キー, 値) というタプルのリスト（戻り値は dict_items オブジェクト） &gt;&gt;&gt; d = {&#39;one&#39;:1, &#39;two&#39;:2, &#39;three&#39;:3} &gt;&gt;&gt; d.keys() dict_keys([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]) &gt;&gt;&gt; d.values() dict_values([1, 2, 3]) &gt;&gt;&gt; d.items() dict_items([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)]) [(&#39;three&#39;, 3), (&#39;two&#39;, 2), (&#39;one&#39;, 1)] それぞれの戻り値は dict_* という型のオブジェクトになっており、元のディクショナリ内のデータを参照するためのビューとして働きます。 このビューを介してディクショナリの内容を変更することはできませんが、ディクショナリ側の変更はビューに反映されます。 それぞれのオブジェクトは for ループでイテレートできます。 &gt;&gt;&gt; for k in d.keys(): ... print(k) ... one two three &gt;&gt;&gt; for k, v in d.items(): ... print(&#34;{} -&gt; {}&#34;.format(k, v)) ... one -&gt; 1 two -&gt; 2 three -&gt; 3"},{url:"/p/cmy6ar3/",title:"Python でキーのリストと値のリストを組み合わせて dictionary を生成する (zip)",date:"2005-10-20T00:00:00+09:00",body:"Python でキーのリストと値のリストを組み合わせて dictionary を生成する (zip) Python の zip 関数と dict 関数を組み合わせることで、「キーのリスト」と「値のリスト」から、新しい dictionary オブジェクトを生成することができます。 &gt;&gt;&gt; keys = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] &gt;&gt;&gt; values = [1, 2, 3] &gt;&gt;&gt; d = dict(zip(keys, values)) &gt;&gt;&gt; d {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} 2 つのリストの要素数が異なる場合は、少ない方に合わせて生成されます。 &gt;&gt;&gt; keys = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] &gt;&gt;&gt; values = [1, 2] &gt;&gt;&gt; d = dict(zip(keys, values)) &gt;&gt;&gt; d {&#39;one&#39;: 1, &#39;two&#39;: 2}"},{url:"/p/5fhvypy/",title:"Linuxメモ: シェルスクリプト: ランダムな数値を取得する ($RANDOM)",date:"2005-07-27T00:00:00+09:00",body:"Linuxメモ: シェルスクリプト: ランダムな数値を取得する ($RANDOM) Bash のシェル変数 $RANDOM を参照すると、0 ～ 32767 の範囲のランダムな整数を取得することができます。 $ echo $RANDOM 27591"},{url:"/p/jw5xt77/",title:"Linuxメモ: Linux でリダイレクトによってファイルが上書きされてしまうのを防ぐ (`set -o noclobber`)",date:"2005-05-26T00:00:00+09:00",body:"Linuxメモ: Linux でリダイレクトによってファイルが上書きされてしまうのを防ぐ (`set -o noclobber`) 例えば Linux で下記のように標準出力をリダイレクトしようとしたときに、すでに出力先のファイルが存在する場合は、そのファイルの内容が上書きされてしまいます。 例: hoge.txt が上書きされてしまう $ echo Hello &gt; hoge.txt こういったリダイレクトによるファイルの上書きを抑制するには、シェルオプションの noclobber を有効化します（bash と zsh で共通です）。 有効化後に hoge.txt が上書きされるような処理を実行すると、以下のようにエラーになります。 例: hoge.txt が上書きされてしまう $ set -o noclobber $ echo Hello &gt; hoge.txt zsh: file exists: hoge.txt シェルオプションは、set -o で有効化、set +o で無効化できます。 bash では ~/.bashrc、zsh では ~/.zshrc に設定を追加しておくとよいでしょう。 ~/.zshrc set -o noclobber # noclobberを有効化（既存ファイルの上書きを防止） set +o noclobber # noclobberを無効化（既存ファイルの上書きを許可）（デフォルト） ちなみに、現在のすべてのシェルオプションの設定を確認するには以下のようにします。 $ set -o # on, off 表示 $ set +o # 設定コマンド表示"},{url:"/p/knkamyp/",title:"Linuxメモ: リダイレクトとパイプ処理のまとめ",date:"2005-05-24T00:00:00+09:00",body:"Linuxメモ: リダイレクトとパイプ処理のまとめ リダイレクトとパイプの役割 デフォルトでは、標準出力 (stdout) の出力先はモニタで、標準入力の入力元はキーボードになっています。 リダイレクトやパイプは、これを変更する役割を持っています。 command &gt; file &hellip; command の標準出力の内容をファイルへ出力する command &lt; file &hellip; ファイルの内容を command の標準入力へ入力する command1 | command2 &hellip; command1 の標準出力を command2 の標準入力へ繋ぐ 例: list.txt の内容を sort コマンドの標準入力へ渡す $ sort -r &lt; list.txt # リダイレクトを使う場合 $ cat list.txt | sort -r # パイプを使う場合 標準出力のリダイレクト 標準出力と標準エラー出力をリダイレクトする $ command &amp;&gt; output.txt 以下のように実行する方法もあり、Linux (bash) も Windows も共通の指定方法で実行できます。 $ command &gt; output.txt 2&gt;&amp;1 2&gt;&amp;1 は、STDERR (2) を STDOUT (1) に結合するという指示です。 標準出力と標準エラー出力を別々にリダイレクトする $ command 1&gt; stdout.txt 2&gt; stderr.txt 標準エラー出力だけをリダイレクト $ command 2&gt; stderr.txt 例: find コマンドを実行するときにエラー出力を抑制する（/dev/null へのリダイレクト） $ find / -name ifconfig 2&gt; /dev/null 標準エラーのパイプ 標準出力と標準エラー出力をパイプ $ command1 2&gt;&amp;1 | command2 標準エラー出力だけをパイプ（標準出力は破棄） $ (command1 1&gt; /dev/null) 2&gt;&amp;1 | command2"},{url:"/p/z3dxcch/",title:"Linuxメモ: ls コマンドが使えないときに echo コマンドで代用する",date:"2005-05-23T00:00:00+09:00",body:"Linuxメモ: ls コマンドが使えないときに echo コマンドで代用する Linux 環境でパスが狂ってしまったりして、外部コマンドである ls が使えないときは、内部コマンドの echo とシェルのワイルドカード展開機能を使って、ディレクトリ内のファイル一覧を表示できます。 $ echo * $ echo dir/* $ echo test*"},{url:"/p/vtkjxha/",title:"Linuxメモ: ls コマンドでパターンに一致するファイルだけを列挙する",date:"2005-05-22T00:00:00+09:00",body:"Linuxメモ: ls コマンドでパターンに一致するファイルだけを列挙する ls コマンドでファイルを列挙するときに、Linux シェルのワイルドカードやグロブパターンを利用すると、特定のパターンにマッチするファイルだけを列挙できます。 ? は任意の 1 文字、* は 0 文字以上の任意の文字列にマッチします。 例: 3文字以上のファイルを列挙する $ ls ???* 例: 01, 02, 03 のいずれかの文字列を含むファイルを列挙する $ ls *{01,02,03}* # 方法1 $ ls *0[1-3]* # 方法2"},{url:"/p/7aj35xe/",title:"Linuxメモ: 今日の日付から YYYYMMDD のような文字列を作成する (date)",date:"2005-04-21T00:00:00+09:00",body:"Linuxメモ: 今日の日付から YYYYMMDD のような文字列を作成する (date) Linux の date コマンドを使用すると、現在時刻を表す文字列を自由なフォーマットで取得することができます。 $ date +%Y%m%d-%H%M%S 20050521-231345 時刻入りの簡単なログを出力したいときや、バックアップを作成するときのファイル名構成のために使用することができます。 例: 現在日時をファイル名に付けてファイルコピー（バックアップ） $ cp sample.txt sample.txt.`date +%Y%m%d`.back $ ls sample.txt sample.txt.20050102.back"},{url:"/p/sybn8yf/",title:"Linuxメモ: 行番号付きでテキストファイルの内容を出力する (cat -n, cat -b)",date:"2005-04-21T00:00:00+09:00",body:"Linuxメモ: 行番号付きでテキストファイルの内容を出力する (cat -n, cat -b) cat コマンドには行番号を付加して出力する -n オプションが用意されています。 行番号付きで出力 $ cat -b input.txt -n オプションの代わりに -b オプションを使用すると、空行を除いた行に対して行番号が付加されます。 空行以外の行にだけ行番号を付ける $ cat -b input.txt"},{url:"/p/fiw27s4/",title:"プログラム内のコメントの書き方 (Javadoc ドキュメンテーションコメントの書き方）",date:"2004-07-12T00:00:00+09:00",body:"プログラム内のコメントの書き方 (Javadoc ドキュメンテーションコメントの書き方） はじめに（モチベーション） こんな話があります。あるソフトウェア企業が一人の技術者の採用を決めました。その決め手となった理由は、「公開しているオープンソースソフトウェアのドキュメントが素晴らしかったから」です。彼らは、作成されたドキュメントを見ただけで、その人には技術力がある、一緒に働いて欲しいと判断したのです。 ある国の言語を学ぶために読み書きの練習が必要であるのと同様に、コーディング技術をつけるには、多くの良質なコードを読み、多くのコードを書くことが必要です。設計ドキュメントを書くのも同じことです。日頃から分かりやすいドキュメントを書く鍛錬を怠らず、長年の経験を積んでいかなければ、良質なドキュメントを書く力は身に付きません。今日からドキュメンテーションコメントをバリバリ書いて、ドキュメンテーション力を付けていきましょう。 Let's Enjoy ドキュメンテーションコメント! ドキュメンテーションコメントとは？ API の使用方法を表すコメント（＝ドキュメンテーションコメント） ドキュメンテーションコメントは「APIの仕様」であり、主に API を使用する人のために記述するものです。そのため、通常は public あるいは protected なメソッドや、フィールドが記述の対象となります。ドキュメンテーションコメントを見ただけで、その API を正しく使えるようになっている必要があります。ある API を使おうと思った時に、そのメソッドの実装を見なければ呼び出し方が分からないようであれば、正しく説明ができていないということです。 Java の ドキュメンテーションコメントは /** */ という形式の Javadoc フォーマットで記述します。C# では ///、Python では &quot;&quot;&quot; と、いろいろ書き方はありますが、何を書くべきかという本質的な部分はどの言語でも同じです。Javadoc フォーマットでコメントを記述しておくと、javadoc コマンドを使ってドキュメントファイルを生成できます（一般的に HTML 形式で出力します）。javadoc コマンドは、デフォルトで public/protected メソッドのみドキュメントを生成するようになっています。 API の実装方法を表すコメント（＝通常コメント） そのメソッドを「どのように実装しているのか」を示すコメントは、実装者のための通常コメントであり、ドキュメンテーションコメントとしては出力しなくてもよいものです。private メソッドとして実装される部分は、この種のコードに該当します。private メソッドを使用できる状況というのは、つまりは、そのクラスのコードを参照しながら作業しているということなので、ドキュメントとして出力する必要はないということです。これは、private なフィールドにコメントが必要ないということではないので注意してください。詳細実装に必要なコメントは private なフィールドに対しても記述しておくべきです。Java では、通常のコメントは // や /* */ を使って記述します（もちろん Javadoc 形式 /** */ でも記述可能です）。 コメントを記述するときは、API 実装者のためのコメント（実装方法）と、API 使用者のためのコメント（使用方法）のどちらを書いているのかを常に意識しましょう。 なぜドキュメンテーションコメントが必要なのか？ 一般公開する目的で作られたライブラリにドキュメントが必要なのは明らかです（中には、「コード読め」、「試しながら使え」、といったやる気なしライブラリもありますが）。一方で、内製のアプリケーションを作成するときにも、ドキュメンテーションコメントを記述すべき理由があります。 多人数での開発効率を上げるため 大規模なソフトウェアを開発する場合、多人数でコードを共有して修正していくことはよくあることです。他の人が作成した API を呼び出すこともありますし、その API を修正しなければならないこともあります。このとき、API 仕様が明確になっていないと、正しく API を呼び出すことはできませんし、既存のコードを正しく修正することもできません。その結果、全体のコード品質は低下し、メンテナンスコストは増大していきます。 Aさん「このメソッドの動きよく分からないんだけど、誰が作ったの？」 Bさん「Cさんか、Dさんじゃない？」 Cさん「うーん、これ何だったけ・・・忘れた！」 Dさん「I&#39;m not sure, E-san knows about it.」 Eさん「这是什么？我不太记得」 ・・・ Aさん「しょうがない、コード解析するか・・・」 そもそも、そのメソッドの作成者が近くにいない場合、こういった確認すら行えません。結局、あるメソッドを使うために、そのメソッドの実装を時間をかけて分析することになるため、複数人で開発していることが、逆に開発効率を悪化させてしまいます。つまり、簡単に言うと、 「仕様の明確でないメソッドを作るのは迷惑行為です！」 ドキュメンテーションコメントによって API 仕様が明確にされていれば、こういった無駄なやりとりがなくなるため、開発効率もコード品質も上がります。下記のグラフは、開発メンバの人数と、生産性の関係を表しています。 生産性 | *** ドキュメンテーション | *** コメントのあるプロジェクト | *** | *** | *** ............. ドキュメンテーション | *** ....... コメントのないプロジェクト | **..... | ** |* +---------------------------------------------------- 開発メンバ数 仕様の不明確な API が溢れているプロジェクトに新しい実装メンバを投入しても、開発効率はうまく上がっていきません。すべての API の仕様が明確になっていれば、不具合が見つかった場合でも、各メソッドが何を実現すべきかが分かるので、別の人が実装を引き継いで修正していくことが可能になります。クラスの責務が明らかになっていれば、そのクラスにどのようなメソッドを追加すべきなのか、すべきではないのかも分かるため、メンテナンス不能な巨大クラスが作られるのを防ぐことができます。 後継者のため プログラムはある瞬間、あるリリースバージョンだけ動けばいいというものではありません。長期的にコード品質を維持していくために、ドキュメンテーションコメントは必須だと考えましょう。あなたの書いたコードを、今後数年にわたってメンテナンスしていくのは他の人かもしれません。 「自分にしか理解できないコードを書くことは迷惑行為です！」 チームリーダやマネージャの立場の人は、ソフトウェアの動作だけを見て、そのソフトウェアの品質を評価するのではなく、コードそのものの品質やメンテナンス性まで見るべきです。実際のところ、コードを深くまで読む時間はないでしょうから、その代わりに、生成されたドキュメントをざっと見てみれば、コードの品質も分かるものです。 ユニットテストを正しく記述するため どのようなユニットテストを記述すべきかは、API 仕様が明確になっていれば、自ずと明らかになります。そもそも、API の仕様を説明できないのであれば、正しいユニットテストを書くことはできません。まずは、API の仕様をドキュメンテーションコメントという言葉で説明し、それを具体的にユニットテストの形にブレイクダウンする、という流れがおすすめです（少なくとも、両方とも存在しないという状況にはならないようにしましょう）。 多人数でのプロジェクトの場合、他の人が書いたメソッドのテストコードを作成しなければならないケースもあるでしょう（もちろん望ましいプロセスではありません）。そのためには、パラメータの定義域などの詳細情報が必要になります。それらを含めた API 仕様がちゃんと記述されていれば、他の人にバトンタッチしても、正しくユニットテストコードを作成することができます。逆に API 仕様が記述されていなかったとしたら、何を頼りにしてテストコードを書けばいいのでしょうか？メソッドの実装を見て、必ず成功するテストコードを書きますか？それは、そのメソッドの実装に対して、うまく動作する範囲の入力を与えているだけで、そのテストコードにあまり意味はありません。テストコードは、そのメソッドが正しく動作しているかを調べるためのものであって、メソッドの変更を検出するものではありません。テストコードの前に、必ずそのメソッドの仕様があるはずです。 オープンソースの世界で生きていくため 自分ひとりで作成しているソフトウェアであったとしても、Sourceforge、GitHub といったサイトでコードを管理するのであれば、そのソフトウェアの使い方、ドキュメンテーションコメントを分かりやすく記述しておくべきです。ドキュメンテーションコメントは、オープンソースのコードを読むときの手掛かりになります。世界中の人から、改善案や不具合修正などのコントリビューションを受けやすくなります。他の人のために書いたドキュメントは、自分のためのフィードバックとなって返ってきます。 いつ、誰が書くべきか？ そのクラス、メソッドを実装するときに、その実装者がドキュメンテーションコメントを書くべきです。とりあえず実装しておいて、後からドキュメンテーションコメントをまとめて書こうという姿勢はよくありません。そのメソッドを実装しようとしているときが、その API の仕様を一番理解しているときなので、そのタイミングでドキュメンテーションコメントを記述してしまうのが一番効率がよいです。後になって、誰が実装したのかも分からないクラス、メソッドの仕様を定義するなんてゾッとします。ドキュメントは実装時に記述しておかないと、結局最後まで記述されないものが出てきます。 何を書くべきか？ クラス名や、メソッドのシグネチャを見ただけでは分からない情報がたくさんあるはずです。例えば、ReentrantLock という名前のクラスがあったとします。その名前だけを見て、そのクラスの役割や、どのように使うものなのか分かるでしょうか？そのようなことをドキュメンテーションコメントとして記述します。実装者がどう実装しているかではなく、利用者がどう利用するべきかという観点で書きましょう。 ユニットテストのコードは、ドキュメンテーションコメントの代わりにはなりません。「使い方はユニットテストのコードを参照」というのは避けてください。テストコードは、あくまで API 仕様を満たしていることをテストするため、API 仕様の説明を補うためにあるべきす。ドキュメンテーションコメントが書きにくい、ユニットテストも書けないと感じたら、まずは設計のまずさを疑ってみることをお勧めします（複数の責務が混ざってしまっていないかは特に気を付けるべきポイントです）。 メソッドのコメント メソッドのドキュメンテーションコメントには、何のためのメソッドなのか、どのように使用するのか、どういった副作用があるのかなどを記述します。 メソッドのパラメータに関するコメント どういった入力を与えることができるのか、想定範囲（定義域）を超えた値を渡した場合に何が起こるのかなどを明確にします。渡されたオブジェクトの内容が変更される（副作用がある）場合は、必ず分かるように記述しましょう。 パラメータとして null を渡せるのか？渡した場合に何が起こるのか？（オブジェクト、String、配列型のパラメータが該当します） パラメータとして空の文字列 (&quot;&quot;) を渡せるのか？渡した場合に何がおこるのか？ サイズ 0 のリスト、配列を渡せるのか？渡した場合に何が起こるのか？ パラメータに渡せる数値の範囲は？ 0 や負の値を渡せるのか？ 小さすぎる値、大きすぎる値を渡せるのか？ 文字列形式で、アルゴリズム名や定数値を渡す場合、どのような値を渡せるのか？ パラメータで渡したオブジェクトは変更されるのか？（Java の final は C++ の const と全然違うよ！） パラメータに null を渡せるかどうかは、例えば、下記のように記述しておけばよいでしょう。 * @param ... , not {@code null} * @param ... . Cannot be {@code null}. * @param ... . May be {@code null}, in which case ... メソッドの戻り値に関するコメント どのようなときに、どういった戻り値を返すのかを記述します。特に、null を返すことがあるのであれば、それはどんな場合かを明確に書いておくべきです。メソッドのシグネチャを見ただけでは、そのメソッドの呼び出し側で null チェックをすべきかどうかは分からないので、必ずドキュメンテーションコメントとして記述する必要があります（そもそも、安易に null を返すようなメソッドを作るべきではありませんが、それはまた別のお話）。例えば、戻り値の説明に、下記のような説明があるだけで、null に関する扱いは明確になります。 * @return ... . Returns {@code null} if ... 空文字 と null のどちらを返すのか？ 空リストと null のどちらを返すのか？ どんな範囲の値を返すのか？ 0 や負の値を返すことがあるのか？ オブジェクトを返す場合、呼び出し元でそのオブジェクトの内容を変更しても問題ないか？（primitive な型の値や、immutable なオブジェクトを返すのであれば問題なし） 配列やコレクションを返す場合、その要素はソートされているのか？ 一意の ID として数値を返すような場合でも、その値域が明らかになっていると、呼び出し側のコーディングが楽になることがあります。例えば、0 以上の値が返されることが明らかになっているのであれば、呼び出し側で、その値を配列インデックスとして扱える可能性があります。負の値を渡してはいけないメソッドにも、値のチェックをせずにそのまま渡すことができます。 メソッド全般に関するコメント そのメソッドはスレッドセーフなのか？ ただし、通常はスレッドセーフかどうかはクラス単位で設計すべきなので、クラスのコメントとして記述すべきです。 そのメソッドを呼び出すことにより、どのような副作用があるのか？ あるメソッドを呼び出すと、別のメソッドの振る舞いが変わるなど（こういったものはクラスのコメントとしても記述すべきです）。 例外が発生する場合は、どのような条件で発生するのか？ (@throws) 例外の回避のために特別な処理が必要な場合は、その方法を明記。 よくない例: @throws XxxException ○○例外が発生した場合 例外が発生する「条件」が明記されていません よくない例: @throws XxxException 不正な引数が渡された場合 「不正な引数」とは何なのかが明記されていません 非推奨メソッドである場合はその理由と代替案 (@deprecated) メソッド呼び出し前の事前条件 メソッド呼び出しに失敗したときに何が起こるか 似たようなメソッドとの使い分け基準 メソッドのパラメータとして null を渡せないことや、メソッドが null を返さないことを毎回記述するのは煩雑だというときは、プロジェクト全体で下記のようなルールを作っておくのもよいでしょう。 ドキュメントに記載がない限り、メソッドのパラメータに null は渡してはいけない。 null を渡してしまった場合は、メソッドの呼び出し側の不具合とみなす。 メソッドの実装側では null が渡されないことを前提に実装してよい。null が渡された場合に、明示的に NullPointerException や IllegalArgumentException を投げるのもあり。 ドキュメントに記載がない限り、メソッドは null を返さない。 メソッドの呼び出し側は、戻り値の null チェックを行う必要はない。 メソッドが List 型を返すようなケースでは、null ではなく Collections.emptyList() を返すようにする。 独自オブジェクトを返すようなケースでは、Null オブジェクトパターンを適用し、不用意に null を返さない。 メソッドのオーバーライド版が存在する場合は、何らかの目的のあるために作ったはずですので、ドキュメントの内容からもそれが分かるように記述しましょう。概要説明もコピペするのではなく、どのように使い分けるべきかが分かるように記述すべきです。 クラスのコメント クラスのドキュメンテーションコメントには、そのクラスの目的、責務、特徴などを記述します。また、クラスの全体的な使用方法に制約がある場合（例えば、最初に init() を呼ばないと、別のメソッドが動作しないなど）、各メソッドの説明に記述するだけでは分かりにくいので、そのクラスの使い方として記述しておくべきです（ちなみに、このようなケースでは IllegalStateException 例外を適用できます）。 複数メンバで開発している場合は、クラスの責務を記載しておくことは特に重要になります。クラスの責務が明確になっていないと、別の開発者が、関係のないメソッドをそこに追加してしまいます。最終的に、数千行を超える何でも入りクラスになってしまい、メンテナンス性の悪いコードができてしまいます。クラスのドキュメントは、そのクラスを作成する人が必ず記載するようにしましょう。一方で、メソッド、フィールドを追加する人は、必ずそのクラスの責務が何なのかを確認し、本当にそのクラスに追加すべきものなのかをよく考えるようにしましょう。 :arrow_right: 単一責任の原則 (SRP) 他にも、クラスの説明には以下のようなことを記述します。 そのクラスはスレッドセーフ（複数スレッドからオブジェクトを扱える）なのか？ 特に記載がない場合、そのクラスはスレッドセーフに実装されているとみなす 代替となるスレッドセーフ版クラスへのリンク（例: Java の HashMap と Hashtable） そのクラス内で使う用語の定義（パッケージ全体で使用する用語であれば、パッケージドキュメントに書くべきです） 別のクラスとの関連、およびそのクラスドキュメントへのリンク。 インスタンス化方法が特殊なのであれば、その方法と、その方法で生成する理由。インスタンス化に別のファクトリクラスが必要なのであれば、その方法とドキュメントへのリンク 使用方法が難しいのであれば、サンプルコード (&lt;pre&gt;) 存在するのであれば、クラスの型パラメータの説明 (@param &lt;T&gt;) 継承することを想定した abstract クラスであれば、どのように実装すべきか オブジェクトの状態によって全体の振る舞いが変化するのであれば、その説明 不具合があることが分かっていて、当面直せそうにないものであれば、それによる制約 シリアライズの対象外となるデータの説明 例: ArrayList のコメント /** * ArrayList is an implementation of {@link List}, backed by an array. * All optional operations including adding, removing, and replacing elements are supported. * * &lt;p&gt;All elements are permitted, including null. * * &lt;p&gt;This class is a good choice as your default {@code List} implementation. * {@link Vector} synchronizes all operations, but not necessarily in a way that&#39;s * meaningful to your application: synchronizing each call to {@code get}, for example, is not * equivalent to synchronizing the list and iterating over it (which is probably what you intended). * {@link java.util.concurrent.CopyOnWriteArrayList} is intended for the special case of very high * concurrency, frequent traversals, and very rare mutations. * * @param &lt;E&gt; The element type of this list. * @since 1.2 */ public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess { インタフェースのコメント インタフェースのドキュメントは、どう振る舞うのかを記述すべきで、どう実装すべきかは実現クラス側の責務であることに注意しましょう。インタフェースが定義する API のコメントは、その実現クラスのコメントよりも慎重に記載する必要があります。例えば、あるインタフェースの API が戻り値として List を返すとします。この戻り値の仕様が明確に記述されていないと、ある実装クラスは null を返したり、また別の実装クラスは空リストを返したり、バラバラの実装をしてしまいます。これでは、その API の使用者は、どのように戻り値をハンドルすべきかが分かりません。典型的なパターンとして、あちこちに null チェックが入ることになり、コードの見通しが悪くなり、実行効率も悪くなってしまいます。 形容詞の名前が付くインタフェースは、何らかの付加価値を表しています。中には、メソッドをひとつも持たないマーカーインタフェースとして定義することもあります（例: Serializable, Cloneable）。このような場合は、それを実現したクラスで何が可能になるのかをドキュメントとして記述します。 パッケージのコメント Java プロジェクトの場合、クラスが増えてくるとパッケージとしてグルーピングをすることになるでしょう。パッケージのドキュメンテーションコメントには、そのパッケージがどのようなクラスを提供するのかを記述します。パッケージを作成するときは、そのディレクトリに package-info.java という、パッケージのコメントを記述するためのファイルを作成できます。新規に Java パッケージを作成する人は、同時に package-info.java を書く責任を持ってください。 どんなクラスを含めるためのパッケージなのかを一番よく分かっているのは、そのパッケージを作った本人です。パッケージを作成する人は、まずはそのパッケージがどんな役割を持っているかを示すドキュメントを書くようにしましょう。他のプロジェクトメンバは、そのドキュメントを見て、新しいクラスをそのパッケージに含めるべきかどうかを判断できるようになります。 Javadoc の文法など パッケージ概要や、クラス概要、メソッド概要（最初のピリオドまでの文章）は、ドキュメントの一覧のページに表示されることになるので、特に簡潔かつ用途が分かるように書きましょう。 http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html 書き方に迷ったら、Java のコアライブラリのコードを参考にするとよいです。 Java のコアライブラリであれば、Javadoc の文法的にも正しく書かれているはずなので、安心して真似できます。 ドキュメンテーションコメントの構成 ドキュメンテーションコメントの構成は、大きく、説明文を記述するセクション (description block) と、0 個以上のブロックタグ (block tags) を配置するセクションの 2 つに分かれます。ブロックタグの後ろに、説明文 (description block) を配置することはできないので、必ず下記のような構成になります。 /** * Description（概要説明 ＋詳細説明） * * Block tags（ブロックタグ） */ Javadoc ドキュメンテーションコメント内では、ブロックタグとインラインタグを使用して、別ドキュメントへリンクしたり、表示の制御を行うことができます。 ブロックタグ @タグ名 ... のように、行頭から記述します。メソッドのパラメータの説明、例外の説明、外部ドキュメントへのリンク、バージョン情報などを記述できます。 インラインタグ 各文章の中で {@code Hoge} のように中括弧（curly brace) で囲んで記述し、主に表示上の体裁を整えるために使用します。 概要説明＋詳細説明コメントの書き方 すべての Javadoc コメントの共通ルールとして、コメントの最初の一行（ピリオドで終わるまで、あるいは、最初にブロックタグが現れるまで）は、概要説明 (summary description)を記述します。必要であれば、その後ろに詳細説明を記述できます。 /** * Specifies whether or not date/time parsing shall be lenient. * With lenient parsing, the parser may use heuristics to interpret inputs * that do not precisely match this object&#39;s format. With strict parsing, * inputs must match this object&#39;s format. * ... 上記の例では、一行目が「概要説明」、二行目以降が「詳細説明」として扱われます。「概要説明」の一文は、パッケージ一覧、クラス一覧、メソッド一覧のページにまとめて表示されるので、ひと目で使い方がわかるように、必要な情報を簡潔に記述する必要があります。「概要説明」は完全な文の形になっていることは少なく、簡潔に記述するため、通常は動詞句や名詞句の形で記述されます（主語は明らかなので冗長なことが多い）。 概要説明が動詞句になるもの: メソッド 概要説明が名詞句になるもの: クラス、インタフェース、フィールド、メソッドのパラメータ メソッドがオーバーロードされている場合は、どう使い分けるかが分かるように概要説明を記述するべきです。 CopyOnWriteArrayList(): Creates an empty list. CopyOnWriteArrayList(E[] toCopyIn): Creates a list holding a copy of the given array. CopyOnWriteArrayList(Collection&lt;? extends E&gt; c): Creates a list containing the elements of the specified collection, in the order they are returned by the collection&rsquo;s iterator. 文章の中に現れるピリオドが、概要説明の終わりかどうかを判断する基準は、後ろにスペース、あるいは改行が続いていることです。この判断基準を無効にするためには、{@literal} インラインタグが使用できます（例: {@literal 10 p.m.}）。ピリオドの直後のスペースを &amp;nbsp; に置き換えるという方法もありますが、{@literal} インラインタグを使ったほうが直感的です。 メソッドのコメントの書き方 下記は、典型的なメソッドの Javadoc コメントの例です。 /** * Inserts the objects in the specified collection at the specified location * in this List. The objects are added in the order they are returned from * the collection&#39;s iterator. * * @param index the index at which to insert * @param collection the collection of objects * @return {@code true} if this {@code ArrayList} is modified, {@code false} otherwise * @throws IndexOutOfBoundsException when {@code location &lt; 0 || location &gt; size()} */ @Override public boolean addAll(int index, Collection&lt;? extends E&gt; collection) { メソッドの概要説明は、三単現の s を付けた動詞で始め、ピリオドで終わります。その後に詳細説明が続く場合は、通常の文章（主語＋述語.）の形で記述していきます。 /** * Registers the text to display in a tool tip. Second sentence ... 一方で、タグブロックの @param、@return、@throws の後のフレーズは、慣例として小文字で始まり、ピリオドでは終わりません（まれに Java のコアライブラリ実装でも、ピリオドが付いているものがありますが）。ただし、後ろに文が続く場合は、その文は大文字で初めてピリオドで終わります。@param タグの説明は、多くの場合 the/a/an などで始められます。@throws タグの説明は、多くの場合 if/when などで始められます。 * @param ch the character to be tested * @param observer the image observer to be notified, not null * @param x the x-coordinate, measured in pixels * @param x the x-coordinate. Measured in pixels. @throws タグでは、メソッドが投げる可能性のあるすべての捕捉例外の説明を記述すべきです。非捕捉例外 (RuntimeException) に関しての説明を記述すべきかどうかはいろいろと議論があります。なぜなら、メソッドが内部で呼び出した外部メソッドの非捕捉例外をすべて把握することは不可能だからです。とはいえ、少なくとも、使用者の判断で捕捉 (catch) するかしないかを選択することを前提に作られた非捕捉例外は @throws で説明しておくべきです。 メソッドの説明の中で、そのクラスのインスタンスに関して言及する場合は、「the ～」のように表現するのではなく、「this ～」と表現するのが慣例です。「the ～」とすると対象が曖昧になることがあるというのが理由でしょう。Java 言語の中の this キーワードの意味にも合致するという面もあります。 * Gets the toolkit for this component. (preferred) * Gets the toolkit for the component. (avoid) コード断片、HTML メタ文字の記述方法 HTML タグを記述できるようになっているため、小なり記号「&lt;」や、大なり記号「&gt;」をそのまま表示したい場合は、{@literal} インラインタグを使用する必要があります（JDK1.4 までは &amp;lt; のように実体参照を使用していました）。 {@literal 0 &lt; size &lt; 10} コードの断片を文章内に記述したい場合は、{@code} インラインタグを使用します。{@literal} と同様に HTML メタ文字をエスケープする機能を持ちますが、{@code} を使用することで、等幅フォントで表示されるようになるため、コードの一部であることをより視覚的に表すことができます。Java の予約語やメソッドのパラメータ名など、コード内に登場するキーワードは、通常の英単語と区別しやすいように、{@code} を使って記述すべきです。 ... cannot be {@code null}. サンプルコードなど、複数行にわたる表示を行いたい場合は、&lt;pre&gt; HTML タグと、{@code} インラインタグを組み合わせて使用します。 &lt;pre&gt;{@code StringBuilder sb = new StringBuilder(); Formatter formatter = new Formatter(sb, Locale.US); }&lt;/pre&gt; ドキュメント間のリンク 別のメソッドやクラスへのリンクを張るときには、{@link} インラインタグを使用できます。 {@link パッケージ名.クラス名#メソッド名 代替テキスト} 対象パッケージの import を行っている場合は、「パッケージ名」を省略することができます。さらに、クラス内のメソッドやフィールドへのリンクであれば、「クラス名」も省略することができます。「代替テキスト」を指定すると、ドキュメント上はそのテキストが表示されるようになります。下記は、いずれも正しいリンク方法です。 {@link com.example} {@link com.example.Class} {@link com.example.Class#Constructor()} {@link com.example.Class#method()} {@link com.example.Class#method(int, String)} {@link com.example.Class#MAX_SIZE} {@link com.example.Class#MAX_SIZE 最大値} {@link Class} {@link Class#Constructor() {@link Class#method()} {@link Class#method(int, String)} {@link Class#MAX_SIZE} {@link Class#MAX_SIZE 最大値} {@link #Constructor() {@link #method()} {@link #method(int, String)} {@link #MAX_SIZE} {@link #MAX_SIZE 最大値} パラメータの型などで Generics を使用している場合、そのオブジェクトの型は Object としてリンクを記述しておく必要があります。クラスやメソッドにリンクを張るときは、その Javadoc ブロックの中で最初に登場したときに限定するのがよいプラクティスです（リンクだらけになって見にくくなるからです）。2 回目の登場の際には、{@link #something(Foo, Bar)} とするのではなく、シンプルに {@code something} と書くとスッキリします。 等幅フォントでリンクが表示されるがいやな場合は、{@link} の代わりに {@linkplain} を使用します。 /** * A ThreadFactory builder, providing any combination of these features: * &lt;ul&gt; * &lt;li&gt; whether threads should be marked as {@linkplain Thread#setDaemon daemon} * threads * &lt;li&gt; a {@linkplain ThreadFactoryBuilder#setNameFormat naming format} * &lt;li&gt; a {@linkplain Thread#setPriority thread priority} * ... 他にも、参照すべきドキュメントを示すためのタグとして、@see ブロックタグが用意されています。{@link} インラインタグと同様に、別のクラスへのリンクを記述することもできますし、下記のように、外部ドキュメントの名前を記述することもできます。外部ドキュメントが、Web サイト上にある場合は、HTML リンクの形で記述しておくと親切です（RFC のサイトのように、URL があまり変化しないことが前提です）。 @see RFC 2045 section 6.8 @see &lt;a href=&#34;http://www.ietf.org/rfc/rfc2045.txt&#34;&gt;RFC 2045 section 6.8&lt;/a&gt; 定数値のドキュメントへの埋め込み {@value} インラインタグを使用すると、定数として定義された値そのものをドキュメント内に表示することができます。 /** * Chunk size per RFC 2045 section 6.8. * * &lt;p&gt;The {@value} character limit does not count the trailing CRLF, but counts * all other characters, including any equal signs.&lt;/p&gt; * * @see &lt;a href=&#34;http://www.ietf.org/rfc/rfc2045.txt&#34;&gt;RFC 2045 section 6.8&lt;/a&gt; */ static final int CHUNK_SIZE = 76; ただし、一般的には具体的な定数値はドキュメンテーションコメントとして含めるべきではありません。実装者がその値を前提にコーディングしてしまうと、後から定数の値を変更することができなくなってしまうからです。将来的にも絶対に変わることがない値であることが分かっているのであれば、ドキュメンテーションコメント内に含めてしまっても問題ありません。例えば、以下のような値は、具体的な値を含めてしまうことができます（含める必要性があるかは別の話です）。 具体的なエラーコード TCP/IP の well-known ポート番号 アルゴリズム上、変更できないバッファサイズ 段落、リスト、テーブルのための HTML タグを使用する Javadoc コメントには、HTML タグを含めることができるため、次のように使用することが可能です。 段落を分ける (p) /** * First paragraph. * ... * &lt;p&gt; * Second paragraph. * ... * &lt;p&gt; * Third paragraph. * ... */ リストを表示する (ul/ol/li) /** * ... * &lt;ul&gt; * &lt;li&gt;Item 1 ... * &lt;li&gt;Item 2 ... * &lt;li&gt;Item 3 ... * &lt;/ul&gt; */ 表（テーブル）を表示する (table/tr/th/td) /** * ... * &lt;table&gt; * &lt;tr&gt;&lt;th&gt;Header1&lt;/th&gt;&lt;th&gt;Header 2&lt;/th&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;Description 1&lt;/td&gt;&lt;td&gt;Description 2&lt;/td&gt;&lt;/tr&gt; * &lt;tr&gt;&lt;td&gt;Description 3&lt;/td&gt;&lt;td&gt;Description 4&lt;/td&gt;&lt;/tr&gt; * &lt;/table&gt; */ 単語や文章を強調表示する (b/em/strong) /** * Return a list of the services that are currently running. * * &lt;p&gt;&lt;b&gt;Note: this method is only intended for debugging or implementing * service management type user interfaces.&lt;/b&gt;&lt;/p&gt; * ... */ 一般的に em はイタリックで表示されてしまい、見た目の強調が若干弱いため、代替手段として b が使われることが多いようです（意味的には strong の方が正しいのですが、無駄に長くなってしまうので避けられているっぽい）。 最低限守っておきたいこと 一行目の概要文は、大文字で初めて、ピリオドで終わる。 /** */ だけ書くような CheckStyle 警告抑制のためだけのコメントを書かない。 クラス名、関数名、フィールド名と同じことを書かない。 メソッドが null を返すことがあるのであれば、必ずその条件を記述する（逆に null を返さないことが分かっているのであれば、呼び出し側では無駄な null チェックを行わない）。 javadoc コマンドでドキュメント生成して文法エラーが出ていないかを確認する (ant javadoc で簡単に実行できるようにしておくのがよい）。 『Effective Java 項目 44』にも、これまでの内容とほぼ同様のことが記述されています。 メソッドとそのクライアント間の契約を簡潔に記述すべき。 どのように処理を行っているかではなく、メソッドが何を行っているかを述べるべき。 すべての事前条件 (precondition) と事後条件 (postcondition) を列挙すべき。 メソッドではいかなる副作用も文書化すべき。 クラスのスレッド安全性 (thread safety) について記述すべき。 スローするすべての例外に対する @throws タグが書かれるべき。 @param タグあるいは @return タグに続くテキストは名詞句であるべき。 @throws タグの説明は if から構成される。 @param、@return、@throws タグの後の名詞句は慣例としてピリオドでは終わらない。 2つのメンバーあるいはコンストラクタが同じ概要説明を持つべきではない。=&gt; オーバーライドしたメソッドがあるのであれば、それぞれ異なる概要説明を書くべきということ。 クラスのスレッド安全性のレベルを記述すべき（項目 70）。Immutable である、スレッドセーフである、条件付きスレッドセーフ (unconditionally thread-safe) である、などなど。、synchroznized 修飾子は Javadoc の出力には影響しません。 クラスがシリアライズ可能であれば、シリアライズ形式を文書化すべき（項目 75）。 外部文書があるときは、関連するクラスあるいはパッケージからのリンクがあるべき。 ドキュメンテーションコメントは必須だとみなされるべきです。 （参考）Effective Java の中でのコメントサンプル: /** * Returns the element at the specified position in this list. * * &lt;p&gt;This method is &lt;i&gt;not&lt;/i&gt; guaranteed to run in constant * time. In some implementations it may run in time proportional * to the element position. * * @param index index of element to return; must be * non-negative and less than the size of this list * @return the element at the specified position in this list * @throws IndexOutOfBoundsException if the index is out of range * ({@code index &lt; 0 || index &gt;= this.size()}) */ E get(int index) よくない例 クラス／メソッド説明で、その名前以上の情報を提供していない /** Frame data. */ public class FrameData { クラス名から得られる情報以上の情報が含まれていません。「クラスのコメント」のセクションを参照してください。 // ダメな例 /** * Sets the tool tip text. * @param text the text of the tool tip */ public void setToolTipText(String text) { // よい例（Oracle サイトより抜粋） /** * Registers the text to display in a tool tip. The text * displays when the cursor lingers over the component. * * @param text the string to display. If the text is {@code null}, * the tool tip is turned off for this compornent. */ API ドキュメントは、メソッド名以上の情報を提供するべきです。「メソッドのコメント」のセクションを参照してください。 実装詳細が含まれてしまっている /** * Returns the mData. */ このドキュメントはツッコミどころ満載ですが、少なくとも、ドキュメンテーションコメントは、コードを読まないでも API 仕様が分かるように記述されている必要があります。詳細実装に出てくる mData のようなワードを API ドキュメントに含めるべきではありません。詳細実装を修正したとたんに嘘の情報になりますし、そもそもこういった情報は、API の使用者にとって役に立ちません。 パラメータの説明が型情報だけ @param dateFormat DateFormat パラメータの型情報はシグネチャから分かるので、あえて記載する必要はありません。何のために、どんな値を渡せばよいのか分かるように書きましょう。 翻訳しただけ @param errorType エラータイプ 情報量ゼロ。 Unknown の説明が Unknown enum MessageType { /** Unknown type. */ UNKNOWN, UNKNOWN という列挙値があるのであれば、そのコメントは &ldquo;Unknown&rdquo; ではなく、それが何を意味しているのかを記載すべきです。例えば、UNKNOWN という正しい値が存在していることと、正常なデータが取得できなかったときのために UNKNOWN という値を用意しているのでは、全く意味が異なります。 さいごに プログラミングに必要な能力の半分は思いやりです。思いやりを持って設計、コーディングすれば、自然に分かりやすいクラス、メソッドができあがっていくはずです。 [2004-07-12] 初版発行 [2014-09-29] Markdown 化。なぜ書くべきか、サンプル、Effective Javaの言及、リンク切れなどを修正・追記。"},{url:"/p/sxmuvwz/",title:"型変換用メソッドは受け取り側クラスに作る",date:"2003-08-04T00:00:00+09:00",body:"型変換用メソッドは受け取り側クラスに作る あるアプリケーションドメイン内のクラスにおいて、データ変換用のメソッドを用意する場合は、自分自身のデータを他のデータ型に変換するメソッドを作るのではなく、他のデータを自分自身の型に変換するメソッドを用意すると全体の構造がすっきりします。 public class A { public static A convertFrom(B b) { ... } // コンストラクタで他のデータ型から変換する方法もあり } 利点は、変換元のクラスに変換先クラスの知識を持たせないでよいことと、以下のように一貫した呼び方で、いろんなオブジェクトからの変換を行えることです。 A a = A.convertFrom(b); A a = A.convertFrom(c); A a = A.convertFrom(d); 次のように変換元のクラスにメソッドがたくさん増えるのはあまり格好良くないです。 B b = a.createB(); C c = a.createC(); D d = a.createD(); ただ、これは変換先の型への依存関係をどちらに持たせるかの問題なので、後者の方法しかとれない場合もあります。 変換メソッドのいい例は Java の Integer クラスなどです。Integer.valueOf() メソッドは、引数で受け取ったデータから、Integer オブジェクトを生成します（ちなみに、プリミティブな int 型が欲しいときは Integer.parseInt() の方を使います）。 Integer a = Integer.valueOf(100); Integer b = Integer.valueOf(&#34;100&#34;);"},{url:"/p/w6pogd4/",title:"３軸加速度センサの入力を 200Hz でサンプリング＆シリアル通信するサンプルプログラム ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"３軸加速度センサの入力を 200Hz でサンプリング＆シリアル通信するサンプルプログラム ─ PIC めもめも ３軸加速度センサの入力を 200Hz で A/D 変換し、シリアルポートから 9600bps で 1byte ずつ送信（5msec ごとに 0x00, Ax, Ay, Az の計 4 byte を送信）するサンプルコードです。 最初にデリミタのための 0x00 を送信するようにしているので、0x00, Ax, Ay, Az の 4 byte が 5msec ごとにまとめて送信されます。 ;============================================================================== ; ; File : ad_200hz.asm ; Author: Masatoshi OHTA ; Update: 2002/11/18 ; ; デバイス : PIC16F873 ; 通信スピード : 9600bps ; データ長 : 8bit ; ストップビット: 1bit ; フロー制御 : なし ; ;============================================================================== LIST P=PIC16F873 INCLUDE &#34;P16F873.INC&#34; __CONFIG _HS_OSC &amp; _WDT_OFF ;ウォッチドッグ・タイマ OFF ;============================================================================== ; 変数定義 ;============================================================================== CBLOCK H&#39;20&#39; w_temp ; variable used for context saving status_temp ; variable used for context saving temp ; wait_count ; 遅延サブルーチン用の変数 ENDC ;============================================================================== ; エントリ・ポイント ;============================================================================== ORG 0 goto Start ORG 4 goto Interrupt ;============================================================================== ; メインルーチン ;============================================================================== Start bsf STATUS, RP0 ; Bank1 に切り替え ;[TRISA] 入出力ポートの設定 movlw B&#39;00000111&#39; ; RA0, RA1, RA2 は入力(センサから) movwf TRISA ; ;[ADCON1] アナログ入力にするポート、左詰右詰を決定 movlw B&#39;00000010&#39; ; 左詰、AN0～AN4 全部アナログ入力 movwf ADCON1 ;[TRISC] USART 用入出力ポートの設定 bcf TRISC, 6 ; PortC&lt;6&gt; (TX) is an output ; bsf TRISC, 7 ; PortC&lt;7&gt; (RX) is an input ;[TXSTA] USART 送信ステータスの設定 movlw B&#39;00100000&#39; ; Async mode movwf TXSTA ; ;[SPBRG]USART ボーレートの設定 movlw 0FH ;9600bps 10MHz BRGH=0(低速) movwf SPBRG bcf STATUS, RP0 ; Bank0 に戻す ;[RCSTA] USART 受信ステータスの設定 movlw B&#39;10010000&#39; ; movwf RCSTA ; ;[ADCON0] AD 変換クロックを指定。AD 変換を有効に movlw B&#39;10000001&#39; ; Fosc/32, CH0, ADON=1 movwf ADCON0 ;CCP1 のコンペアモード（SpecialEventTrigger）による割り込みの設定 ;SetupTimer1 movlw B&#39;00000001&#39; movwf T1CON ;SetupCCP1 movlw B&#39;00001011&#39; movwf CCP1CON ;SetCCP1Counter movlw H&#39;30&#39; ; 0x61A8 = 25000 Count (10msec - 100Hz) movwf CCPR1H ; 0x30D4 = 12500 Count ( 5msec - 200Hz) movlw H&#39;D4&#39; movwf CCPR1L ;割り込み許可 bsf STATUS, RP0 ;Go to Bank1 bsf PIE1, CCP1IE ;CCP1 割り込みイネーブル bcf STATUS, RP0 ;Back to Bank0 bsf INTCON, PEIE ;周辺機能割り込みイネーブル (CCP1は周辺機能) bsf INTCON, GIE ;全体の割り込みイネーブル ;****************************************************************************** ; Idle Loop ;****************************************************************************** MainLoop ;Nothing to do. goto MainLoop ;****************************************************************************** ; 割り込み時の処理 ; フラグクリア ; 0 を送信 ; (アナログ入力ポート選択 → シリアル送信) x 3 ;****************************************************************************** InterruptProcedure ;CCP1 割り込みフラグをクリア bcf PIR1, CCP1IF ;デリミタとして 0x00 を送信する call SendZero ;アナログ入力を RA0 に切り替え movf ADCON0, W andlw B&#39;11000111&#39; iorlw B&#39;00000000&#39; movwf ADCON0 call AdConvertAndSend ;アナログ入力を RA1 に切り替え movf ADCON0, W andlw B&#39;11000111&#39; iorlw B&#39;00001000&#39; movwf ADCON0 call AdConvertAndSend ;アナログ入力を RA2 に切り替え movf ADCON0, W ;ADCON0 -&gt; W andlw B&#39;11000111&#39; ;W &amp; 11000111 -&gt; W iorlw B&#39;00010000&#39; ;W | 00010000 -&gt; W movwf ADCON0 ;W -&gt; ADCON0 call AdConvertAndSend return ;****************************************************************************** ; セレクトしたポートに対して A/D 変換を実行 ; チャンネルをセレクトしてからCholdに電圧を蓄積するまで待機する必要がある ; 8bit 変換の時 … 12μsec ; 10bit 変換の時 … 20μsec ;****************************************************************************** AdConvertAndSend call Wait20_10MHz ;コンデンサの充電まち (20μsec, 10MHz) bsf ADCON0, GO ;A/D 変換スタート WaitAdFinish btfsc ADCON0, GO ;GO ビットがクリアされたら A/D 変換終了 goto WaitAdFinish movf ADRESH, W ;A/D 変換の結果を取得 (上位8bit) ;A/D 変換結果をシリアルで送信 call SendUsart return ;****************************************************************************** ; シリアル送信サブルーチン ; TXSTA&lt;TRMT(1)&gt; を監視し、W レジスタのデータ (8 bit) をシリアルで送信します。 ; （TEMP を Bank0 の汎用レジスタに指定してあることを前提とします。 ; このルーチンを呼び出す時は Bank0 に切り替えてから呼び出すこと） ;****************************************************************************** SendUsart movwf temp ;W レジスタを保存 bsf STATUS, RP0 ;Bank1 に切り替え SendUsartLoop btfss TXSTA, TRMT ;TXSTA&lt;TRMT(1)&gt; が 1 になるまで待機 goto SendUsartLoop bcf STATUS, RP0 ;Bank0 に戻す movf temp, W ;W レジスタの復旧 movwf TXREG ;TXREG レジスタにセット (実際の送信開始) return ;****************************************************************************** ; Send 0x00 By RS232C ;****************************************************************************** SendZero clrw call SendUsart return ;****************************************************************************** ; 20μsec の遅延発生ルーチン (クロック = 10MHz) ;****************************************************************************** Wait20_10MHz movlw D&#39;14&#39; movwf wait_count Wait20_10MHz_Loop decfsz wait_count, F goto Wait20_10MHz_Loop nop nop return ;****************************************************************************** ; 割り込みルーチン ;****************************************************************************** Interrupt movwf w_temp movf STATUS, w bcf STATUS, RP0 movwf status_temp call InterruptProcedure bcf STATUS, RP0 movf status_temp, w movwf STATUS swapf w_temp, f swapf w_temp, w retfie ;============================================================================== ; Directive &#39;End of Program&#39; ;============================================================================== END"},{url:"/p/izgbusm/",title:"A/D 変換を実行する ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"A/D 変換を実行する ─ PIC めもめも A/D 変換モジュール PIC16F873/876 (28ピン)、PIC16F874/877 (40ピン) などには A/D 変換モジュールが付いています。 28 ピンモジュールには 5 入力、40 ピンモジュールには 8 入力あります。 5 入力全部使えば、3 軸加速度センサと 2 軸ジャイロセンサの出力を 1 つの PIC で A/D 変換することができます（入力が多いほど A/D 変換に時間はかかります）。 A/D 変換モジュールには次の 4 つのレジスタがあります。 A/D 変換制御レジスタ 0 ･･･ ADCON0 A/D 変換制御レジスタ 1 ･･･ ADCON1 A/D 変換結果 High レジスタ ･･･ ADRESH A/D 変換結果 Low レジスタ ･･･ ADRESL A/D 変換制御用レジスタ ─ ADCON0 レジスタの構成 ADCON0 レジスタ (1Fh : Bank0) は、クロック、チャンネルの指定、A/D 変換開始などに使用します。 ADCS1(7) ADCS0(6) CHS2(5) CHS1(4) CHS0(3) GO/DONE(2) ─(1) ADON(0) ADCS1(7) ～ ADCS0(6): AD 変換クロックセレクトビット 00 ･･･ Fosc/2 01 ･･･ Fosc/8 10 ･･･ Fosc/32 11 ･･･ FRC (RC 発振) CHS2(5) ～ CHS0(3): アナログチャネルセレクトビット 000 ･･･ channel 0, (RA0/AN0) 001 ･･･ channel 1, (RA1/AN1) 010 ･･･ channel 2, (RA2/AN2) 011 ･･･ channel 3, (RA3/AN3) 100 ･･･ channel 4, (RA5/AN4) 101 ･･･ channel 5, (RE0/AN5) (※ 28pin デバイスにはありません) 110 ･･･ channel 6, (RE1/AN6) (※ 28pin デバイスにはありません) 111 ･･･ channel 7, (RE2/AN7) (※ 28pin デバイスにはありません) A/D 変換は 1 度に 1 つのポートからの入力に対してしか行なえないので、この 3 bit でどのポートからの入力を変換するか切り替えます。 GO/DONE(2): A/D 変換ステータスビット If ADON = 1 1 ･･･ A/D 変換中（このビットをセットすると A/D 変換が開始します） 0 ･･･ A/D 変換中ではない（このビットは A/D 変換が終了する自動的にハードウェアでクリアされます） A/D 変換の設定が終わったら、このビットをセットすることによって実際に A/D を開始します。 A/D が終了すると、このビットは自動的にクリアされます。 割り込みを使わなくても、このフラグをループで監視することで、A/D 変換が終了したことを知ることができます（A/D 変換にはほとんど時間がかからないので、割り込みを使う必要はないかも）。 なし(1) このビットは常に 「0」 とリードされます。 ADON(0): A/D ON ビット 1 ･･･ A/D 変換器モジュールは動作中 0 ･･･ A/D 変換器モジュールはオフになり、消費電流無し A/D 変換器モジュールを動作させるかを指定します（実際に A/D 変換を開始する時は GO/DONE(2) をセットします）。 A/D 変換を行なう必要のない場合は、電力の消費を抑えるために停止しておくとよいです。 A/D 変換制御用レジスタ ─ ADCON1 レジスタの構成 ADCON1 レジスタ (9Fh : Bank1) では、アナログ入力用ポートの指定を行います。 ADFM (7) ─ (6) ─ (5) ─ (4) PCFG3 (3) PCFG2 (2) PCFG1 (1) PCFG0 (0) ADFM(7): A/D 変換結果フォーマットセレクト 0 ･･･ 左詰。ADRESL の 6LSb は 「0」 とリードされる。 1 ･･･ 右詰。ADRESH の 6MSb は 「0」 とリードされる。 +--------+--------+ +--------+--------+ +xxxxxxxx|xx000000| +000000xx|xxxxxxxx| +--------+--------+ +--------+--------+ ADRESH ADRESL ADRESH ADRESL PIC16F87x では、A/D 変換後の値が 10bit で得られるので、ADRESH、ADRESL の計 16bit に右詰か左詰どちらで結果を格納するか指定します。 あまり細かい精度まで求める必要がない場合は、左詰めにして ADRESH の 8bit だけ参照すればよいでしょう。 なし(6～4): 常に 「0」 とリードされます。 PCFG3(3) ～ PCFG0(0): A/D ポート構成コントロールビット 省略。 A/D 変換手順 設定 TRISA レジスタで AN0 ～ AN7 のピンの入出力モードを決定 (アナログ入力ピンを 1(入力) にする) ADCON0 レジスタを設定 A/D 変換クロックの設定 (bit7-6) (ADCS1:ADCS0) アナログチャネルをセレクト (bit5-3) (CHS2:CHS0) A/D モジュールを使用するにセット (bit0) (ADON=1 にする) ADCON1 レジスタを設定 結果は左詰か右詰か (bit7) (ADFM) A/D ポートの構成 (bit3-0) (PCFG3:PCFG0) 割り込みを使うなら、割り込み設定 ADIF = 0 ADIE = 1 GIE = 1 変換実行 アクィジション時間待つ 8 ビット変換なら 12μsec 10 ビット変換なら 20μsec A/D 変換開始 (ADCON0&lt;GO/DONE&gt; をセット) A/D 変換の終了を待つ (次のどちらかの方法で) GO/DONE ビットがクリアされるまでループで待機する A/D 割り込みを待つ 結果 (ADRESH:ADRESL) をリードする (必要なら ADIF をクリア) 以降の変換は、変換に使用したいアナログチャネルをセレクト (CHS2:CHS0) して繰り返します。 A/D 変換のサンプルプログラム AN0 からの入力を A/D 変換した結果を、USART を使ってシリアルで PC に送信するプログラムの例です。 デバイス : PIC16F873 通信スピード : 9600bps データ長 : 8bit ストップビット : 1bit フロー制御 : なし ad_convert.asm ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; ; AN0 からの入力を A/D 変換した結果を、 ; USART を使ってシリアルで PC に送信するサンプルプログラム ; ; デバイス : PIC16F873 ; 通信スピード : 9600bps ; データ長 : 8bit ; ストップビット: 1bit ; フロー制御 : なし ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; LIST P=PIC16F873 INCLUDE &#34;P16F873.INC&#34; ;============================================================================== ; Variable Definition ;============================================================================== TEMP EQU 020H TCNT EQU 021H ; 遅延サブルーチン用の変数 ORG 0 ;============================================================================== ; 初期設定 ;============================================================================== INIT BSF STATUS, RP0 ; Bank1 に切り替え ;**** 入出力ポートの設定 (TRISA) **** MOVLW B&#39;00000001&#39; ; RA0 は入力(センサから) MOVWF TRISA ; ;**** アナログ入力にするポート、左詰右詰を決定 (ADCON1) **** MOVLW B&#39;00000010&#39; ; 左詰、AN0～AN4 全部アナログ入力 MOVWF ADCON1 ;**** USART 用入出力ポートの設定 (TRISC) **** BCF TRISC, 6 ; PortC&lt;6&gt; (TX) is an output ; BSF TRISC, 7 ; PortC&lt;7&gt; (RX) is an input ;**** USART 送信ステータスの設定 (TXSTA) **** MOVLW B&#39;00100000&#39; ; Async mode MOVWF TXSTA ; ;**** USART ボーレートの設定 (SPBRG) **** MOVLW 0FH ;9600bps 10MHz BRGH=0(低速) MOVWF SPBRG BCF STATUS, RP0 ; Bank0 に戻す ;**** USART 受信ステータスの設定 (RCSTA) **** MOVLW B&#39;10010000&#39; ; MOVWF RCSTA ; ;**** AD 変換クロックを指定。AD 変換を有効に (ADCON0) **** MOVLW B&#39;10000001&#39; ; Fosc/32, CH0, ADON=1 MOVWF ADCON0 ;============================================================================== ; A/D 変換を行うアナログ入力ポートを選択 ;============================================================================== SELECT_AD_CHANNEL ;今回は AN0 からの入力だけを変換するの切り替える必要なし ;============================================================================== ; セレクトしたポートに対して A/D 変換を実行 ; チャンネルをセレクトしてからCholdに電圧を蓄積するまで待機する必要がある ; 8bit 変換の時 … 12μsec ; 10bit 変換の時 … 20μsec ;============================================================================== AD_CONVERT CALL WAIT20_10MHZ ;コンデンサの充電まち (20μsec, 10MHz) BSF ADCON0, GO ;A/D 変換スタート WAIT_AD_FINISH BTFSC ADCON0, GO ;GO ビットがクリアされたら A/D 変換終了 GOTO WAIT_AD_FINISH MOVF ADRESH, W ;A/D 変換の結果を取得 (上位8bit) ;============================================================================== ; A/D 変換結果をシリアルで送信 ;============================================================================== CALL SEND_USART ; 1 を送ってみる（テスト用） ; MOVLW 1 ; CALL SEND_USART ;**** チャンネルセレクトへもどる **** GOTO SELECT_AD_CHANNEL ;============================================================================== ; シリアル送信サブルーチン ; TXSTA&lt;TRMT(1)&gt; を監視し、W レジスタのデータ (8 bit) をシリアルで送信します。 ; （TEMP を Bank0 の汎用レジスタに指定してあることを前提とします。 ; このルーチンを呼び出す時は Bank0 に切り替えてから呼び出すこと） ;============================================================================== SEND_USART MOVWF TEMP ;W レジスタを保存 BSF STATUS, RP0 ;Bank1 に切り替え SEND_USART_LOOP BTFSS TXSTA, TRMT ;TXSTA&lt;TRMT(1)&gt; が 1 になるまで待機 GOTO SEND_USART_LOOP BCF STATUS, RP0 ;Bank0 に戻す MOVF TEMP, W ;W レジスタの復旧 MOVWF TXREG ;TXREG レジスタにセット (実際の送信開始) RETURN ;============================================================================== ; 20μsec の遅延時間 ─ 10MHz (周期 0.4μsec) の時 ;============================================================================== WAIT20_10MHZ MOVLW D&#39;14&#39; ; 20 / 0.4 = 50 MOVWF TCNT ; (50 - 6) / 3 = 14 余り 2 WAIT20_10MHZ_LOOP DECFSZ TCNT, F ; GOTO WAIT20_10MHZ_LOOP NOP ; 余り 2 だから NOP は 2 つ NOP ; RETURN ; ;============================================================================== ; End Program ;============================================================================== END"},{url:"/p/pzazwmj/",title:"C 言語 → アセンブラ言語 ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"C 言語 → アセンブラ言語 ─ PIC めもめも 様々な C 言語のコードを PIC アセンブラ言語に変換するためのメモです。 代入 VAR = 100 MOVLW D&#39;100&#39; MOVF VAR, F VAR1 = VAR2 MOVF VAR2, W MOVWF VAR1 VAR++ INCF VAR, F VAR += 100 MOVLW D&#39;100&#39; ADDWF VAR, F VAR1 += VAR2 MOVF VAR2, W ADDWF VAR1, F ループ for (i = 100; i &gt; 0; i&ndash;) MOVLW D&#39;100&#39; ;100 回ループ MOVWF i LOOP ... DECFSZ i, F GOTO LOOP IF 分岐 if (w == 100) SUBLW 100 ; 100 - w -&gt; w BTFSC STATUS, Z ; w == 100 でなかったらスキップ GOTO W_IS_100 GOTO W_IS_NOT_100 W_IS_100 ... goto ... W_IS_NOT_100 ... if (VAR == 100) MOVLW 100 ;VAR - 100 → W SUBWF VAR, W ; BTFSC STATUS, Z ;VAR == 100 でなかったらスキップ GOTO VAR_IS_100 GOTO VAR_IS_NOT_100 VAR_IS_100 ... VAR_IS_NOT_100 ... if (A &gt;= B) MOVF B, W ; B → W SUBWF A, W ; A - W → W BTFSC STATUS, C ; A &gt;= B なら負でない GOTO A_LARGER_EQUAL GOTO B_LARGER SWITCH 分岐 CASE 1, 2, 3 への分岐（1 からの連番の場合） C switch (FLAG) { case 1: ... break; case 2: ... break; case 3: ... break; default: ... break; } ASSEMBLER DECF FLAG, F BTFSC STATUS, Z GOTO CASE_1 DECF FLAG, F BTFSC STATUS, Z GOTO CASE_2 DECF FLAG, F BTFSC STATUS, Z GOTO CASE_3 DEFAULT ... GOTO xxx CASE_1 ... GOTO xxx CASE_2 ... GOTO xxx CASE_3 ... GOTO xxx ;;; FLAG の値を壊さないようにする場合は次のように TEMP_FLAG を用意する MOVF FLAG, W MOVWF TEMP_FLAG ; FLAG の値を代入 DECF TEMP_FLAG, F BTFSC STATUS, Z GOTO CASE_1 DECF TEMP_FLAG, F BTFSC STATUS, Z GOTO CASE_2 DECF TEMP_FLAG, F BTFSC STATUS, Z GOTO CASE_3 DEFAULT ... GOTO xxx CASE_1 ... GOTO xxx CASE_2 ... GOTO xxx CASE_3 ... GOTO xxx CASE 2, 4, 6 への分岐（とびとびの値の場合） C switch (FLAG) { case 2: ... break; case 4: ... break; case 6: ... break; default: ... break; } ASSEMBLER MOVLW 2 ; 2 の場合の分岐処理 SUBWF FLAG, W ; BTFSC STATUS, Z ; GOTO CASE_2 ; MOVLW 4 ; 4 の場合の分岐処理 SUBWF FLAG, W ; BTFSC STATUS, Z ; GOTO CASE_4 ; MOVLW 6 ; 6 の場合の分岐処理 SUBWF FLAG, W ; BTFSC STATUS, Z ; GOTO CASE_6 ; DEFAULT ... GOTO xxx CASE_2 ... GOTO xxx CASE_4 ... GOTO xxx CASE_6 ... GOTO xxx 演算 2 バイトデータの足し算 (A += B) A_LOW EQU ... B_LOW EQU ... A_HIGH EQU ... B_HIGH EQU ... MOVF B_LOW, W ADDWF A_LOW, F ; 下位が A_LOW へ BTFSC STATUS, C ; あふれたら上位へ +1 INCF B_HIGH, F MOVF B_HIGH, W ADDWF A_HIGH, F ; 上位が A_HEGH へ 2 倍 (VAR *= 2) BCF STATUS, C RLF VAR, F キャリーフラグをクリアしてからシフトするのがポイントです。 1/2 倍 (VAR /= 2) BCF STATUS, C RRF VAR, F キャリーフラグをクリアしてからシフトするのがポイントです。"},{url:"/p/gx3mib3/",title:"CCP (Compare/Capture/PWM) モジュール ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"CCP (Compare/Capture/PWM) モジュール ─ PIC めもめも CCP モジュールのモード CCP モジュールには 3 つのモードがあり、それぞれの用途によって使い分けて使用することができます。 コンペア・モード タイマ 1 のカウントがある値になったときに、何らかのアクションを行います。タイマ 1 の設定をクロック同期モードにしておく必要があります。タイマ 1 を正確なインターバルタイマとして利用できるようになります。 キャプチャー・モード CCP1 (あるいは CCP2) ピンからの入力を元にして、タイマ 1 のカウントを CCPR1H、CCPR1L レジスタ（あるいは CCPR2H、CCPR2L レジスタ）にコピーします。 パルス幅変調モード (PWM: Pulse Width Modulation) 周期的なパルスを発生させ外部機器を操作します。Duty の指定によりパルス幅を調整できます。 コンペア・モードの 4 つのアクション CCP モジュールをコンペア・モードで動作させると、タイマ 1 のカウンタ TMR1L、TMR1H が レジスタ CCPRxL、CCPRxH で指定した値と等しくなったときに、何らかのアクションを行います（CCP モジュールが 2 つある場合、x に 1 または 2 が入ります）。 TMR1L, TMR1H (タイマ 1 のカウンタ) ↓ 常に比較 → 一致したならアクション発生（アクションは 4 パターンから選択） ↑ CCPRxL, CCPRxH (ユーザが自由に設定する) どんなアクションを行なうかは、CCPxCON&lt;CCPxM0&gt; ～ &lt;CCPxM3&gt; で指定します。 一致した時のアクションの指定 CCPxCON &lt;CCPxM3(3)&gt; ～ &lt;CCPxM0(0)&gt; アクション 1000 割り込みが発生と同時に PIRx&lt;CCPxIF&gt; ビットがセットされる。CCPx ピンの出力を H レベルにする。 1001 割り込みが発生と同時に PIRx&lt;CCPxIF&gt; ビットがセットされる。一致したら CCPx ピンの出力を L レベルにする。 1010 割り込みが発生と同時に PIRx&lt;CCPxIF&gt; ビットがセットされる。 1011 (SpecialEventTrigger) 割り込みが発生と同時に PIRx&lt;CCPxIF&gt; ビットがセットされる。CCP1 の場合はタイマ 1 をリセットする。CCP2 の場合はタイマ 1 をリセットし、A/D コンバータを起動する。 コンペア・モードを有効にするには、タイマ 1 の設定をクロック同期モードにしておく 必要があります。 また、CCPx ピンの出力を利用する場合は、TRISC レジスタで出力ピンに設定しておく 必要があります（CPP1 ピンを出力にするには TRISC&lt;2&gt; ビットをクリアします）。 日本語のデータシートには、コンペアモードを使用するときは CCPx ピンを必ず出力に設定するように書かれています（2002年現在）が、SpecialEventTrigger などでインターバルタイマを実現する場合などは、CCPx ピンの出力を利用しないので、TRISC レジスタの設定を行なう必要はありません（PIC16F873 で動作確認済み）。 CCP モジュールからの割り込み CCP モジュールからの割り込みは、割り込みフラグビット PIR1&lt;TMR1IF(0)&gt; をセットしません。 その代わり、PIRx&lt;CCPxIF&gt; がセットされます。 CCP モジュールによる割り込みが発生すると、タイマ 0 による割り込みの時と同様に 0x04 番地へ強制的にジャンプします。 どの原因により割り込みが発生したかを調べるには、どのフラグがセットされているかを確認する必要があります。 割り込み時に、ソフトウェア側で明示的に PIRx&lt;CCPxIF&gt; フラグをクリアする必要があります。 このフラグをクリアするのを忘れると、割り込みルーチンから retfie した瞬間にまた割り込みが発生してしまうので、永遠に割り込みルーチンをループして実行し続けることになってしまいます。 正確なインターバルタイマのプログラム例 1011 (SpecialEventTrigger) に設定しておくと、割り込みが発生すると同時にタイマ 1 をリセットしてくれるので、正確なインターバルタイマを作成することができます。 次の例は、10MHz クロックで、10msec ごとに割り込み処理を行っています。 LIST P=PIC16F84 INCLUDE &#34;P16F84.INC&#34; __CONFIG _HS_OSC &amp; _WDT_OFF ;ウォッチドッグ・タイマ OFF ORG 0 ;リセット後のエントリポイント GOTO Start ORG 4 ;割り込みルーチンのエントリポイント GOTO Interrupt ;============================================================================== ; エントリポイント ;============================================================================== Start ;CCP1 のコンペアモード（SpecialEventTrigger）による割り込みの設定 ;Setup Timer1 (内部クロックでカウントに設定) movlw B&#39;00000001&#39; ;プリスケーラ 1:1 ;オシレータ停止 ;内部クロック movwf T1CON ;Setup CCP1 (コンペアモードの SpecialEventTrigger に設定) movlw B&#39;00001011&#39; movwf CCP1CON ;Setup CCP1 Counter movlw H&#39;30&#39; ;インターバルによって目標カウンタ値を設定 (次は 10 MHz の場合) movwf CCPR1H ; 0x30D4 = 12500 Count ( 5msec ごとに割り込みの場合) movlw H&#39;D4&#39; ; 0x61A8 = 25000 Count (10msec ごとに割り込みの場合) movwf CCPR1L ;割り込み許可 bsf STATUS, RP0 ;Go to Bank1 bsf PIE1, CCP1IE ;CCP1 割り込みイネーブル bcf STATUS, RP0 ;Back to Bank0 bsf INTCON, PEIE ;周辺機能割り込みイネーブル (CCP1は周辺機能) bsf INTCON, GIE ;全体の割り込みイネーブル ;****************************************************************************** ; Main Loop ;****************************************************************************** MainLoop ;■■■ ここにメインの処理を書く ■■■ ;Nothing to do. goto MainLoop ;****************************************************************************** ; 割り込み時に行なう処理 ;****************************************************************************** InterruptProcedure bcf PIR1, CCP1IF ;CPP1 コンペアモード 割り込みフラグクリア ;■■■ 割り込み時に行ないたい処理をここに自由に記述 ■■■ return ;****************************************************************************** ; 割り込みのエントリポイント (レジスタの保存復帰、InterruptProcedure 呼び出し) ;****************************************************************************** Interrupt movwf w_temp movf STATUS, w bcf STATUS, RP0 ;Bank 0 movwf status_temp call InterruptProcedure ;このルーチンの中で独自の処理を記述する bcf STATUS, RP0 ;Bank 0 movf status_temp, w movwf STATUS swapf w_temp, f swapf w_temp, w retfie ;****************************************************************************** ; Directive &#39;End of Program&#39; ;****************************************************************************** END"},{url:"/p/fyzm2ts/",title:"MPLAB によるプロジェクト作成 ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"MPLAB によるプロジェクト作成 ─ PIC めもめも MPLAB の設定（デベロップメント・モードの設定） MPLAB を起動し、次のように設定します。 「Options」 → 「Development Mode」 → 「Tools」タブ &ldquo;Development Mode&rdquo; で MPLAB-SIM Simulator にチェック &ldquo;Processor&rdquo; を使用するデバイスに変更 新規プロジェクトの作成 「Project」 → 「New Project」 &ldquo;File Name&rdquo; にプロジェクト名 (例えば test.prj) を入力 &ldquo;Directories&rdquo; には空白を含まないパス (例えば D:\\PIC_ASM\\test) を選択して「OK」 「OK」 ボタンを押すと、Edit Project ダイアログが開きます。 新規ソースの追加（Edit Project ダイアログ） &ldquo;Development Mode&rdquo; が MPLAB-SIM、正しいデバイス名になっているか確認 &ldquo;Project Files&rdquo; の 「Add Node」 ボタンをクリック ASM ファイル名 (例えば test.asm) を入力して 「OK」 &ldquo;Project Files&rdquo; の test [.hex] を選択して 「Node Properties&hellip;」 ボタンをクリック Hex Format ･･･ INHX8M Warning level ･･･ all Case sensitivity … OFF (大文字と小文字を区別しない) Tab size ･･･ 4（タブ使わないかもしれないけどいちおう） 「OK」 この作業では、実際に test.asm は作成されない ので、エクプローラで新規作成するか、「File」 → 「New」 で新規作成して、Ctrl-S で test.asm として保存してください。 プログラムの作成 「Window」 → 「Project」 リストから開きたいソースファイル（例えば &ldquo;test.asm&rdquo;）をダブルクリック エディタが開くので、コードを自由に記述してください。 ただし、MPLAB 付属のエディタは日本語が入力できないので、日本語のコメントを記述したい場合は、別の日本語対応のエディタを使ってください。 動作をテストしたい場合は、とりあえず次のように記述してみてください（END の前に空白を入れるのを忘れずに）。 test.asm（これだけでもビルドは可能） END ビルド 「Project」 → 「Make Project」 &ldquo;Build completed successfully.&rdquo; と出ればビルド成功です。 エラーが出た場合は、そのエラー表示行をダブルクリックすれば、該当行に移動できます。 Bank0 以外のデータ RAM にアクセスすると、&ldquo;Message&rdquo; という表示が出ることがありますが、エラーではないのでビルドは成功しています。 ビルドに成功すると、HEX ファイルがそのプロジェクトのディレクトリに作成されます。 HEX ファイルができたら、次は MPLAB-SIM を使ってデバッグするか、PIC ライタで実際に PIC に書き込んで実機テストに入ります。"},{url:"/p/iwkdah6/",title:"MPLAB のインストール ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"MPLAB のインストール ─ PIC めもめも MPLAB のダウンロード Microchip Technology https://www.microchip.com/ (English) https://www.microchip.co.jp/ (Japanese) MPLAB ダウンロード https://www.microchip.co.jp/tool.htm MPLAB のインストール Mp57full.exe などを実行します。 ほとんどデフォルトのまま Next ボタンで進んでいけば OK です（「Linker script Location」では Install files to MPLAB\\Lkr sub directory を選択した方がよいかも）。 Windows を再起動してインストール完了！ 関連ドキュメントへのリンク MPLAB チュートリアル MPLAB チュートリアル (29 Pages) MPLAB プロジェクト・チュートリアル (33 Pages) PIC データシート PIC16F83/4 データシート (912KB) PIC16F873/4/6/7 データシート (1.75MB) その他 MPLAB、MPASM、PICStart Plus を使ったセミナー実習テキスト (1,839KB) （ソースコード）"},{url:"/p/5n5vokj/",title:"MPLAB-SIM Software Simulator によるデバッグ ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"MPLAB-SIM Software Simulator によるデバッグ ─ PIC めもめも MPLAB-SIM Software Simulator を使うと、ブレークポイントやトレース機能などを用いてプログラムのデバッグを行なうことができます。 Absolute List Absolute List 表示では、記述したアセンブラソースとアセンブル後の機械語を照らし合わせて表示することができます。 「Window」 → 「Absolute Listing」 このコードは、デバッグを進めていくうちに次のように色が付いて作業の目安になるので、デバッグ中はずっと表示しておくとよいです。 ブレークポイント &hellip; 赤色 トレース範囲 &hellip; 緑色 ブレークポイント ＆ トレース範囲 &hellip; マゼンタ File Register Window File Register Window の表示 「Window」 → 「File Registers」 File Register Window では、SFC (Special Function Register) やユーザ定義の変数の現在の値を確認したり変更したりすることができます。 レジスタ内容の変更 File Register Window で変更したい範囲を選択 「右クリック」 → 「Fill Register(s)」 ブレークポイントの設定 Absolute List を表示 ブレークポイントを設定したい行で右クリック → 「Break Point(s)」 （あるいは、「Debug」 → 「Break Settings&hellip;」） トレースポイントの設定 Absolute List を表示 トレースポイントを設定したい行で右クリック → 「Trace Point(s)」 （あるいは、「Debug」 → 「Trace Settings&hellip;」）"},{url:"/p/no9voj9/",title:"PIC アセンブラ (PIC16Fxxx) 命令セット ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"PIC アセンブラ (PIC16Fxxx) 命令セット ─ PIC めもめも PIC16Fxxx 命令セット (14bit) カテゴリニモニック意味コード 加算・減算 ADDWF f, d W + f → d Add W and f 00 0111 dfff ffff SUBWF f, d f - W → d Subtract W from f 00 0010 dfff ffff ADDLW k W + k → W Add literal and W 11 111x kkkk kkkk SUBLW kk - W → W Subtract W from literal 11 110x kkkk kkkk 論理演算 ANDWF f, d W AND f → d AND W with f 00 0101 dfff ffff IORWF f, d W OR f → d Inclusive OR W with f 00 0100 dfff ffff XORWF f, d W XOR f → d Exclusive OR W with f 00 0110 dfff ffff ANDLW k W AND k → W And literal with W 11 1001 kkkk kkkk IORLW k W OR k → W Inclusive OR literal with W 11 1000 kkkk kkkk XORLW k W XOR k → W Exclusive OR literal with W 11 1010 kkkk kkkk COMF f, d f → d Complement f 00 1001 dfff ffff 移動 MOVF f, d f → d Move f 00 1000 dfff ffff MOVWF f W → f Move W to f 00 0000 1fff ffff MOVLW k k → W Move litaral to W 11 00xx kkkk kkkk クリア CLRF f 0 → f Clear f 00 0001 1fff ffff CLRW W 0 → W Clear W 00 0001 0xxx xxxx インクリメントデクリメント DECF f, d f - 1 → d Decrement f 00 0011 dfff ffff INCF f, d f + 1 → d Increment f 00 1010 dfff ffff DECFSZ f, d f - 1 → dSkip if result = 0 Decrement f, Skip if 0 00 1011 dfff ffff INCFSZ f, d f + 1 → dSkip if result = 0 Increment f, Skip if 0 00 1111 dfff ffff ビット操作 BCF f, b 0 → f[b] Bit Clear f 01 00bb bfff ffff BSF f, b 1 → f[b] Bit set f 01 01bb bfff ffff スキップ BTFSC f, b Skip if f[b] = 0 Bit Test f, Skip if Clear 01 10bb bfff ffff BTFSS f, b Skip if f[b] = 1 Bit Test f, Skip if Set 01 11bb bfff ffff シフト RLF f, d f[n] → d[n+1] f[7] → C → d[0] Rotate Left f through Carry(左巡回シフト) 00 1101 dfff ffff RRF f, d f[n] → d[n-1] f[0] → c → d[7] Rotate Right f through Carry(右巡回シフト) 00 1100 dfff ffff SWAPF f, d f[0:3] → d[4:7] f[4:7] → d[0:3] Swap nibbles in f(上位ビット ⇔ 下位ビット) 00 1110 dfff ffff ジャンプ GOTO k Go to address 10 1kkk kkkk kkkk CALL k Call subroutine 10 0kkk kkkk kkkk RETFIE Return from interrupt 00 0000 0000 1001 RETLW k Return with literal in W 11 01xx kkkk kkkk RETURN Return from Subroutine 00 0000 0000 1000 その他 CLRWDT Clear Watchdog Timer 00 0000 0110 0100 NOP No Operation 00 0000 0xx0 0000 SLEEP Go into standby mode 00 0000 0110 0011 OPCODE フィールドの説明 FieldSizeDescription f7 ワーキングレジスタのアドレス (0x00 ～ 0x7F) W─ ワーキングレジスタ（アキュムレータ） b3 8 ビットファイルレジスタ内のビットアドレス k8/11 リテラル、定数またはラベル (0 ～ 255) or (-128 ～ 127) or (アスキーコード 'A' とか) x─ 無効 (0 or 1) アセンブラは x=0 としてコードを生成します。 すべてのソフトウェアツールとの互換性を確保するために x=0 を推奨します。 d1 結果格納先指名子 (0 or 1) 0: W に格納 1: ファイルレジスタ f に格納 (Default) PC─ プログラムカウンタ TO─ タイムアウトビット PD─ パワーダウンビット"},{url:"/p/48ipjkq/",title:"PIC めもめも（PIC アセンブラ）",date:"2002-08-01T00:00:00+09:00",body:"PIC めもめも（PIC アセンブラ） アセンブラ MPASM (MPLAB に含まれる) PIC アセンブラ (PIC16Fxxx) 命令セット ラベルの定義 バンクとページの切り替え バンク ･･･ 汎用レジスタ (RAM) の区分け ページ ･･･ プログラムメモリ (ROM) の区分け 変数の割り当て ユーザが変数領域として自由に使用できる汎用レジスタの範囲 汎用レジスタに変数領域を確保する 遅延時間の作成 1 サイクル (1 命令) にかかる時間 遅延時間を作るサブルーチン 遅延時間サブルーチン自動生成 Script USART によるシリアル通信 PC 側の通信プログラム USART によるシリアル通信 サンプルコード A/D 変換を実行する A/D 変換用レジスタ、変換結果が格納されるレジスタ、A/D 変換手順、A/D 変換サンプルプログラム タイマ 0 を使用する タイマ 0 による割り込みの仕組み タイマ 0 用のクロック カウント値の決定 割り込み時の処理 インターバルタイマーとしてタイマ 0 を使う タイマーの開始 タイマ 0 サンプルプログラム タイマ 1 を使用する（ミッドレンジシリーズ以上） T1CON レジスタの構成 タイマ 1 による割り込みの仕組み タイマ 1 用のクロック 割り込み時の処理 CCP モジュールのコンペアモードを利用した割り込み CCP (Compare/Capture/PWM) コンペア・モード キャプチャ・モード パルス幅変調モード (PWM: Pulse Width Modulation) C 言語 → アセンブラ言語 C 言語の構文からアセンブラの構文に直す 汎用雑多メモ どの Page にあるか分からないサブルーチンにジャンプする 特定のマスクで 2 つの値を比較 W レジスタの値 (0～F) を 7 セグメント LED 用の値に変換する サンプルプログラム RA0 の出力を ON/OFF する ３軸加速度センサの入力を 200Hz でサンプリング＆シリアル通信 PIC16F84 用テンプレート PIC16F873 用テンプレート 電子回路・部品メモ RS-232C (Recommend Standard number 232) LED（Light Emitting Diode: 発光ダイオード） 水晶振動子（クリスタル振動子、オシレーター） 3端子レギュレータ その他、用語メモ、未分類メモ 統合開発環境 MPLAB MPLAB のインストール MPLAB のダウンロード MPLAB のインストール 関連ドキュメントへのリンク MPLAB によるプロジェクト作成 MPLAB の設定 新規プロジェクトの作成 プログラム作成＆ビルド MPLAB-SIM Software Simulator によるデバッグ"},{url:"/p/hjocz3n/",title:"RA0 の出力を ON/OFF するサンプルプログラム ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"RA0 の出力を ON/OFF するサンプルプログラム ─ PIC めもめも ;============================================================================== ; ; File : ra0_test.asm ; Author: Masatoshi OHTA ; Update: 2000-08-20 ; ;============================================================================== LIST P=PIC16F84 INCLUDE &#34;P16F84.INC&#34; __CONFIG _WDT_OFF ; ウォッチドッグ・タイマ OFF ; ;****************************************************************************** ; Entry Point ;****************************************************************************** ORG 0 clrf PCLATH goto Start ;****************************************************************************** ; Main Routine ;****************************************************************************** Start ;**** Set I/O Mode SetIoMode bsf STATUS, RP0 ; Bank1 に切り替え clrf TRISA ; PORTA をすべて出力モードに bcf STATUS, RP0 ; Bank0 に戻す ;**** RA0 を ON/OFF MainLoop bsf PORTA, 0 ; RA0 を High に nop bcf PORTA, 0 ; RA0 を Low に nop goto MainLoop ;****************************************************************************** ; Directive &#39;End of Program&#39; ;****************************************************************************** END"},{url:"/p/fewejde/",title:"USART によるシリアル通信 ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"USART によるシリアル通信 ─ PIC めもめも USART 用の送受信ピン TRISC&lt;6, 7&gt; の設定 USART (Universal Synchronous Asynchronous Receiver Transmitter) は次のモードで構成できます。 非同期（全二重） 同期 ─ マスター（半二重） 同期 ─ スレーブ（半二重） USART による通信は TX (送信)、RX (受信) ピンを使用します（TX を出力ピン、 RX を受信ピンに設定します）。 TRISC&lt;6&gt; が RC6/TX/CK、TRISC&lt;7&gt; が RC7/RX/DT の入出力設定ビットなので、これらの値を次のようにセットします。 TX, RX の入出力モードの設定 (TX=出力, RX=入力) INIT_TX_TR BSF STATUS, RP0 ; set bank1 BCF TRISC, 6 ; PortC&amp;lt;6&amp;gt; (TX) is an output BSF TRISC, 7 ; PortC&amp;lt;7&amp;gt; (RX) is an input BCF STATUS, RP0 ; set bank0 TRISC&lt;6&gt; をクリアして、 TRISC&lt;7&gt; をセットするだけですね。 TXSTA (送信ステータスおよびコントロールレジスタ) の設定 TXSTA (98h(Bank1)) レジスタは、送信ステータスおよびコントロールを設定するためのレジスタです。 このレジスタの構造は次のようになっています。 TXSTA レジスタ CSRC (7) TX9 (6) TXEN (5) SYNC (4) ─ (3) BRGH (2) TRMT (1) TX9D (0) CSRC (7): クロックソースセレクトビット 非同期モード Don’t care 同期モード 1 = マスターモード（内部でBRG から発生するクロック） 0 = スレーブモード（外部ソースからのクロック） TX9 (6): 9 ビット送信イネーブルビット このビットをセットすると、TXSTA&lt;TX9D(0)&gt; にセットしたビットも同時に送信されるようになります。 1 = 9 ビット送信を選択 0 = 8 ビット送信を選択 TXEN (5): 送信イネーブルビット 注意： 同期モードではSREN/CREN はTXEN をオーバーライドします。 1 = 送信はイネーブル 0 = 送信はディセーブル SYNC (4): USART モードセレクトビット 1 = 同期モード 0 = 非同期モード なし (3): 未使用 このビットを読み出すと、常に「0」とリードされます。 BRGH (2): 高速ボーレートセレクトビット 非同期モード 1 = 高速 0 = 低速 同期モード（使用しません） TRMT (1): 送信シフトレジスタステータスビット 1 = TSR が空 0 = TSR がフル TX9D (0): 送信データの第 9ビット。パリティビットとして使用可能 TXSTA レジスタは Bank1 にあるので注意してください（普通は Bank1 にある TRISC の設定といっしょにやってしまいます）。 例えば、送信イネーブル、非同期モードにするなら次のようにします。 TXSTA の設定例（送信 Enable） BSF STATUS, RP0 ; set bank1 MOVLW B&#39;00100000&#39; ; Async mode MOVWF TXSTA ; BCF STATUS, RP0 ; set bank0 他の設定にしたい時は、B'00100000 の部分を変更します。 RCSTA（受信ステータスおよびコントロールレジスタ）の設定 RCSTA レジスタ (18h(Bank0)) は受信ステータスおよびコントロールを設定するレジスタです。 RCSTA の構造は次のようになっています。 RCSTA レジスタ SPEN (7) RX9 (6) SREN (5) CREN (4) ADDEn (3) FERR (2) OERR (1) RX9D (0) SPEN (7): シリアルポートイネーブルビット 1 = シリアルポートはイネーブル（RC7/RX/DT およびRC6/TX/CK ピンはシリアルポートピンとして構成） 0 = シリアルポートはディセーブル RX9 (6): 9 ビット受信イネーブルビット 1 = 9 ビット受信を選択 0 = 8 ビット受信を選択 SREN (5): シングル受信イネーブルビット 非同期モード (Don’t care) 同期モード－マスター（このビットは受信完了後クリアされます） 1 = シングル受信はイネーブル 0 = シングル受信はディセーブル 同期モード－スレーブ（使用しません） CREN (4): 連続受信イネーブルビット 非同期モード 1 = 連続受信はイネーブル 0 = 連続受信はディセーブル 同期モード 1 = イネーブルビットCREN がクリアされるまでは連続受信可能（CREN はSREN をオーバーライドする） 0 = 連続受信はディセーブル ADDEN (3): アドレス検出イネーブルビット 非同期モード9 ビット（RX9=1) 1 = アドレス検出はイネーブル、RSR&lt;8&gt; が 1 のとき、受信バッファの割り込みとロードがイネーブル 0 = アドレス検出はディセーブル、全バイトを受信、第 9 ビットはパリティビットとして使用可能 FERR (2): フレーミングエラービット 1 = フレーミングエラー（RCREG レジスタのリードにより更新でき、次の有効バイトを受信する） 0 = フレーミングエラーなし OERR (1): オーバーランエラービット 1 = オーバーランエラー（ビット CREN のクリアによりクリア可能） 0 = オーバーランエラーなし RX9D (0): 受信データの第 9 ビット（パリティビットとして使用可能） RCSTA&lt;RX9 (6)&gt; をセットした場合、このビットに第 9 ビットが受信されます。送信側と受信側がこのことを認識してプログラムを作成する必要があります。 RCSTA&lt;7&gt; (SPEN) を 1 にセットすることで、TX, RX ポートをシリアルポートピンとして使用できるようになります。 RCSTA レジスタは Bank0(18h) にあるので、現在 Bank0 ならばバンクを切り替える必要はありません。 RCSTA の設定例（調歩同期方式［非同期］で通信） MOVLW B&#39;10010000&#39; ; Serial port is enable MOVWF RCSTA 他の設定にしたい場合は、B'10010000' の部分を変更します。 SPBRG（ボーレート発生器の設定レジスタ）の設定 調歩同期方式（非同期モード）を選択した場合は、ボーレートを決定するために SPBRG (99h(Bank1)) レジスタを設定する 必要があります。 SPBRG レジスタは、希望のボーレートによって 0～255 の値を設定します。 希望のボーレートとクロック周波数 (Hz) が決まれば、以下の式から SPBRG にセットすべき値 (X) を求めることができます（データシートから抜粋）。 X を求める式は SYNK ビットと BRGH ビットにより変化します。 ボーレートを求める式 &nbsp; TXSTA&lt;BRGH(2)&gt; = 0 (低速) TXSTA&lt;BRGH(2)&gt; = 1 (高速) TXSTA&lt;SYNC(4)&gt; = 0 (非同期) ボーレート = クロック / (64 (X + 1)) ボーレート = クロック / (16 (X + 1)) TXSTA&lt;SYNC(4)&gt; = 1 (同期) ボーレート = クロック / (4 (X + 1)) NA これを X = の式に変換すると次のようになります。 SPBRG レジスタにセットする値 (X) を求める式 &nbsp; TXSTA&lt;BRGH(2)&gt; = 0 (低速) TXSTA&lt;BRGH(2)&gt; = 1 (高速) TXSTA&lt;SYNC(4)&gt; = 0 (非同期) X = (クロック / (ボーレート * 64)) - 1 X = (クロック / (ボーレート * 16)) - 1 TXSTA&lt;SYNC(4)&gt; = 1 (同期) X = (クロック / (ボーレート * 4)) - 1 NA ちなみに PIC16F873 (28ピン) と PIC16F874 (40ピン) は BRGH は低速しか使えないらしいです。 高速に設定したい場合は、PIC16F876 (28ピン) とか PIC16F877 (40ピン) を使います。 SPBRG レジスタの設定値の計算例 例として、10MHz、非同期モード (SYNC=0)、低速ボーレート (BRGH=0) の時に 9600bps 出したい時の X の値を求めてみます。 X ＝ (10000000 / (9600 * 64)) - 1 ＝ 15.276･･･ ≒ 15 つまり、この場合は SPBRG に 15 (0x0F) をセットすればよいことになります。 SPBRG レジスタは Bank1 にあるので、次のように設定します。 Bank1 にある TRISC、TXSTA レジスタといっしょに設定してしまえばよいでしょう。 SPBRG レジスタ (Baud Rate) のセット BSF STATUS, RP0 ;Bank1 に切り替え MOVLW 0x0F ;9600bps MOVWF SPBRG ; BCF STATUS, RP0 ;Bank0 に戻す よく使うクロック周波数とボーレートでの SPBRG の値は次のようになります。 同じ 9600bps の場合でも、高速ボーレート (BRGH = 1) にした方がエラーレートは小さくなります（高速モードが使えるなら）。 非同期モードのボーレートによる SPBRG の値 &nbsp; BRGH = 0 (低速) BRGH = 1 (高速) 10MHz20MHz 10MHz20MHz 1200bps 129 (0x81) 255 (0xFF) ─ ─ 2400bps 64 (0x40) 129 (0x81) ─ ─ 9600bps 15 (0x0F) 32 (0x20) 64 (0x40) 129 (0x81) 19200bps 7 (0x07) 15 (0x0F) 32 (0x20) 64 (0x40) 38400bps ─ ─ 15 (0x0F) 32 (0x20) データ送信の流れ TXSTA&lt;TXEN&gt; ビットを 1 に設定して送信を Enable にしておく。 TXREG レジスタに送信したいデータ（8 ビット）をセットすると、その値が自動的に TSR レジスタにコピーされて TX ポートから送信が開始される。 TSR の値は操作できません。 TSR の内容は LSb から 1 ビットずつ送信されます。 図: PIC16F873 データシートより TXREG レジスタに次のデータをセットできることを確認する方法（3 通り） TXREG の値が TSR にコピーされた瞬間に PIR1&lt;TXIF&gt; ビットがセットされる。このビットがセットされたら次のデータを TXREG に格納してよい。TXREG に次の値をセットすると、PIR1&lt;TXIF&gt; ビットは自動的にクリアされる（ソフトでクリアすることはできない）。 PIE1&lt;TXIE&gt; を 1 にセットしておくと、TXREG の値が TSR にコピーされた瞬間に割り込みが発生するのでこれを利用する（PIR1&lt;TXIF&gt; ビットがセットされる）。 TSR の値が空になると、TXSRA&lt;TRMT&gt; が 1 にセットされるので、ループでこのビットを監視する。（9 ビット送信を行う場合は、この方法で監視する必要がある？） TXSTA&lt;TX9D&gt; ビットを使って 9 ビット送る時の注意 TXSTA&lt;TX9&gt; ビットを 1 に設定して 9 ビット送信を Enable にする。 TX9D ビット（9 ビット目のデータ）の設定は TXREG にデータをセットする前に行う必要がある。 サンプルコード シリアル送信サブルーチン (SendUsart) USART でデータを送信する時は、TXSTA レジスタの TRMT (TXSTA&lt;1&gt;) が 1 になるのを確認してから送信するようにします。 次のサブルーチンは、このルールに基づいて W レジスタのデータを送信します。 USART によるシリアル送信サブルーチン（方法 1） ;============================================================================== ; シリアル送信サブルーチン ; TXSTA&lt;1&gt; (TRMT) を監視し、W レジスタのデータをシリアルで送信します。 ; （TEMP を Bank0 の汎用レジスタに指定してあることを前提とします。 ; このルーチンを呼び出すときは Bank0 に切り替えてから呼び出すこと。） ;============================================================================== SendUsart MOVWF TEMP ;W レジスタを保存 BSF STATUS, RP0 ;Bank1 に切り替え SendUsartLoop BTFSS TXSTA, TRMT ;TXSTA&amp;lt;1&amp;gt; (TRMT) が 1 になるまで待機 GOTO SendUsartLoop BCF STATUS, RP0 ;Bank0 に戻す MOVF TEMP, W ;W レジスタの復旧 MOVWF TXREG ;TXREG レジスタにセット (実際の送信開始) RETURN ここでは TXSTA レジスタの TRMT(1) ビットを監視して、TSR レジスタが空になったかどうかを調べていますが、次のように PIR1 の TXIF(4) ビットをポーリングすることでも USART によるシリアル送信処理を行うことができます。 そのようにした方が、Bank0 にあるレジスタを監視するので扱いが容易であり、送信バッファ自体の状態を見ているので若干高速です（2003-11-02 に追記。木下隆さん情報提供ありがとうございました）。 USART によるシリアル送信サブルーチン（方法 2：おすすめ） ;****************************************************************************** ; USART によるシリアル送信サブルーチン ; PIR1&lt;TXIF(4)&gt; を監視し、W レジスタのデータ (8 bit) をシリアルで送信します。 ; (このルーチンを呼び出す時は Bank0 に切り替えてから呼び出すこと） ;****************************************************************************** SendUsart btfss PIR1, TXIF ;PIR1&lt;TXIF(4)&gt; が 1 になるまで待機 goto SendUsart movwf TXREG ;TXREG レジスタにセット return ただ、データシートを見てもよくわからないのが、USART で 9 ビット送信をイネーブルにして、TX9D（9ビット目）のデータも送信する場合に、TX9D がどのタイミングで TSR にコピーされるかということです。 TXREG に値をセットした瞬間に TX9D も TSR にコピーされるのなら、TXIF フラグが 1 になった時に TX9D をセットしてよいのですが、TX9D に値をセットした瞬間に TSR にそのビットがコピーされるとしたら、TRMT フラグが 1 になるまでは TX9D に値をセットしてはいけないことになるようなならないような（9 ビット目が上書きされそう）。 マイクロチップテクノロジーのアプリケーションノートの参考例を見ると次のように書いてあるので、まぁ大丈夫なんでしょう。 Application Note : AN774 -- Asynchronous Communications with the PICmicroR USART ;------------------------------------------------------------------------------ ;Transmit data with parity when the transmit register is empty. ;------------------------------------------------------------------------------ TransmitSerial: Bank0 ; select bank 0 btfss PIR1,TXIF ; check if transmitter busy goto $-1 ; wait until transmitter is not busy movf TxData,W ; get data to be transmitted call CalcParity ; calculate parity rrf CalcParity,W ; get parity bit in carry flag Bank1 ; select bank 1 bcf TXSTA,TX9D ; set TX parity to zero btfsc STATUS,C ; check if parity bit is zero bsf TXSTA,TX9D ; if not then set TX parity to one Bank0 ; select bank 0 movf TxData,W ; get data to transmit movwf TXREG ; and transmit the data return 0x01, 0x02, 0x03 を繰り返し送信する (PIC16F873) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ; ; USART を使ってシリアルで PC に送信するサンプルプログラム ; 0x01, 0x02, 0x03 を繰り返し送信します。 ; ; 通信スピード : 9600bps ; データ長 : 8bit ; ストップビット: 1bit ; フロー制御 : なし ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; LIST P=PIC16F873 INCLUDE &#34;P16F873.INC&#34; ;============================================================================== ; Variable Definition ;============================================================================== TEMP EQU 020H ORG 0 ;============================================================================== ; 初期設定 ;============================================================================== INIT BSF STATUS, RP0 ; Bank1 に切り替え ;**** USART 用入出力ポートの設定 (TRISC) **** BCF TRISC, 6 ; PortC&lt;6&gt; (TX) is an output ; BSF TRISC, 7 ; PortC&lt;7&gt; (RX) is an input ;**** USART 送信ステータスの設定 (TXSTA) **** MOVLW B&#39;00100000&#39; ; Async mode MOVWF TXSTA ; ;**** USART ボーレートの設定 (SPBRG) **** MOVLW 0FH ;9600bps 10MHz BRGH=0(低速) MOVWF SPBRG ;**** USART 受信ステータスの設定 (RCSTA) **** BCF STATUS, RP0 ; Bank0 に戻す MOVLW B&#39;10010000&#39; ; MOVWF RCSTA ; ;============================================================================== ; メインルーチン ;============================================================================== MAIN MOVLW 1 CALL SEND_USART ;シリアルで W の内容を送信 MOVLW 2 CALL SEND_USART MOVLW 3 CALL SEND_USART GOTO MAIN ;============================================================================== ; シリアル送信サブルーチン ; TXSTA&lt;1&gt; (TRMT) を監視し、W レジスタのデータ (8 bit) をシリアルで送信します。 ;============================================================================== SEND_USART MOVWF TEMP ;W レジスタを保存 BSF STATUS, RP0 ;Bank1 に切り替え SEND_USART_LOOP BTFSS TXSTA, TRMT ;TXSTA&lt;1&gt; (TRMT) が 1 になるまで待機 GOTO SEND_USART_LOOP BCF STATUS, RP0 ;Bank0 に戻す MOVF TEMP, W ;W レジスタの復旧 MOVWF TXREG ;TXREG レジスタにセット (実際の送信開始) RETURN ;============================================================================== ; End Program ;============================================================================== END シリアル受信 (Receive) 0x01 を受信したら LED On、0x02 を受信したら LED Off (PIC16F873) するサンプルコードです。 ;============================================================================== ; ; シリアルポートから 9600bps で 1byte のデータを受信し、 ; 受信データが 1 なら PORTB&lt;0&gt; (RB0) を High (LED On) にし、 ; 受信データが 2 なら PORTB&lt;0&gt; (RB0) を Low (LED Off) にする。 ; ;============================================================================== ; ; File : usart_recv.asm ; Author: Masatoshi OHTA &lt;ohta@hakoten.com&gt; ; Update: 2003/5/15 ; ; デバイス : PIC16F873 ; 通信スピード : 9600bps ; データ長 : 8bit ; ストップビット: 1bit ; フロー制御 : なし ; ;============================================================================== LIST P=PIC16F873 INCLUDE &#34;P16F873.INC&#34; __CONFIG _HS_OSC &amp; _WDT_OFF ;ウォッチドッグ・タイマ OFF ;============================================================================== ; 変数定義 ;============================================================================== CBLOCK H&#39;20&#39; RECV_BUF ; シリアルからの受信データを一時退避するバッファ ENDC ;============================================================================== ; エントリ・ポイント ;============================================================================== ORG 0 goto StartUp ;============================================================================== ; StartUp ルーチン ;============================================================================== StartUp bsf STATUS, RP0 ; Bank1 に切り替え ;[TRISB (bank1)] PORTB の入出力の設定 bcf TRISB, 0 ; PORTB&lt;0&gt; is an output. ;[TRISC (bank1)] USART 用入出力ポートの設定 bcf TRISC, 6 ; PortC&lt;6&gt; (TX) is an output. bsf TRISC, 7 ; PortC&lt;7&gt; (RX) is an input. ;[TXSTA (bank1)] USART 送信ステータスの設定 movlw B&#39;00100000&#39; ; Async mode movwf TXSTA ; ;[SPBRG (bank1)] USART ボーレートの設定 movlw 0FH ; 9600bps 10MHz BRGH=0(低速) movwf SPBRG bcf STATUS, RP0 ; Bank0 に戻す ;[RCSTA (bank0)] USART 受信ステータスの設定 movlw B&#39;10010000&#39; ; movwf RCSTA ; ;****************************************************************************** ; シリアルポートからの受信を監視するループ ;****************************************************************************** UsartRecvLoop btfss PIR1, RCIF ; PIR1&lt;5&gt;(RCIF) がセットされたら受信完了 goto UsartRecvLoop movf RCREG, w ; 受信したデータを w に取得 ;****************************************************************************** ; 受信したデータで処理を振り分け ; 1 を受け取ったら LED を On ; 2 を受け取ったら LED を Off ;****************************************************************************** movwf RECV_BUF ; 受信データ保存 sublw 1 ; 1 - w -&gt; w btfsc STATUS, Z ; 0 なら Case_1 へ goto Case_1 movf RECV_BUF, w ; RECV_BFU -&gt; w sublw 2 ; 2 - w -&gt; w btfsc STATUS, Z ; 0 なら Case_2 へ goto Case_2 goto UsartRecvLoop Case_1 bsf PORTB, 0 ; PORTB&lt;0&gt; (RB0) を High に (LED On) goto UsartRecvLoop Case_2 bcf PORTB, 0 ; PORTB&lt;0&gt; (RB0) を Low に (LED Off) goto UsartRecvLoop ;============================================================================== ; Directive &#39;End of Program&#39; ;============================================================================== END"},{url:"/p/52s4tfc/",title:"その他、用語メモ、未分類メモ ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"その他、用語メモ、未分類メモ ─ PIC めもめも 発振モード MODE BIT DESCRIPTION FREQ RANGE LP 00 低電力／水晶発振(Low Power Crystal) 200kHz 以下 XT 01 水晶／セラミック発振(Crystal／Resonator) 4MHz 以下 HS 10 高周波水晶／セラミック発振(High Speed Crystal／Resonator) 4MHz ～ 20MHz RC 11 RC 発振(Resister／Capacitor) 1MHz 以下 リセット回路 MCLR に電源をつないでおけば、とりあえずは動作しますが、周辺回路の電源が安定するまで遅延して 4.5V の入力があるべきです。 リセット用の IC にはミツミの PST600C などがあります。 MAX232 MAX232 ･･･ 1μF のコンデンサを使う MAX232A ･･･ 0.1μF ADM232AAN ･･･ 0.1μF 命令長の違う 3 シリーズ ベースライン・シリーズ ･･･ 12ビット命令 (12C5xx, 16C5xx) ミッドレンジ・シリーズ ･･･ 14ビット命令 ハイエンド・シリーズ ･･･ 16ビット命令 (17Cxxx, 18Cxxx) 一番使われている PIC16Fxxx などはミッドレンジ・シリーズにあたります。 AC と DC AC &mdash; Alternating Current (交流) DC &mdash; Direct Current (直流) VIH, VIL, VOH, VOL VIH = 3.15V MIN ･･･ これ以上の入力電圧を High 入力とみなす VIL = 1.35V MAX ･･･ これ以下の入力電圧を Low 入力とみなす VOH = 4.4V MIN ･･･ High 出力の時これ以上の電圧を出力する VOL = 0.1V MAX ･･･ Low 出力の時これ以下の電圧を出力する 入力電圧が High か Low かを決める閾値は VIL ～ VIH の値になります。 シュミットトリガ・インバータ (74HC14) などは、立ち上がり (Low → High と判断する時 (THH)) と、立ち下り (High → Low と判断する時 (THL)) でこの閾値が異なります。 この閾値の差を ヒステリシス と呼びます。 ヒステリシスを持たない 74HC04 よりも 74HC14 の方が入力電圧の微妙なぶれ（ノイズ）に強いといえます。 なぜなら、THH は THL よりも高い値に設定されていて、立ち上がりの際に入力電圧が少し下がっても THL まで下がることは少ないからです。 スイッチ入力回路の基本 通常はスイッチが OFF の時に入力ピンに High が入るようにします。 このときの上記の抵抗を プルアップ抵抗 と呼びます（数10kΩあたりを使うのが一般的です）。 このように配線すると常に電流が流れて電池が無駄に消耗してしまいそうに見えますが、実際には入力ピン側にも大きな抵抗がセットされていて（ハイインピーダンス入力）、電流はほとんど流れません。 上の図は概念図であり、実際にはチャタリングを防止する回路などが必要になります。 PIC16F84 と PIC16F84A の違い PIC16F84 PIC16F84A 最大クロック周波数 DC 10MHz DC 20MHz 動作電圧範囲 2.0V ～ 6.0V（1.5V 乾電池 x 4 で動かせる） 2.0V ～ 5.5V PIC のシンク／ソース電流の最大値は各 I/O ピンごとに 25mA, PORTA や PORTB の合計が 200mA 以下というように決まっています。 詳しくはデータシートを参照してください（キーワード：電気的特性、絶対最大定格）。"},{url:"/p/cnutuna/",title:"タイマ 0 を使用する ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"タイマ 0 を使用する ─ PIC めもめも タイマ 0 による割り込みの仕組み タイマ 0 では、8bit の TMR0 レジスタをタイマ 0 用のクロック (後述) でインクリメントしていき、オーバフローを意図的に起こすことによって割り込みを実現しています。 TMR0 レジスタにあらかじめ値をセットしておくことによって、割り込み時間を調整することができます。 ただし、TMR0 レジスタは 8bit しかないので、それだけでは最大 256 カウントしかすることができません。 そこで、プリスケーラという 8bit のカウンタを別に用意し、このカウンタが指定した値（2, 4, 8, 16, 32, 64, 128, 256 のいずれか）になった時にはじめて TMR0 レジスタをインクリメントすることにより、65536 (8bit + 8bit) までのカウントを実現しています。 プリスケーラカウンタを使うには、OPTION_REG&lt;PSA(3)&gt; ビットを 0 に設定します。 プリスケーラのスケール値を設定するには、OPTION_REG&lt;PS0(0)&gt; ～ &lt;PS2(2)&gt; で次のように指定します。 タイマ 0 のプリスケーラのスケール設定 OPTION_REG &lt;PS2(2)&gt;OPTION_REG &lt;PS1(1)&gt;OPTION_REG &lt;PS0(0)&gt; スケール 000 1:2 (256 * 2 = 512カウントまで) 001 1:4 (256 * 4 = 1024カウントまで) 010 1:8 (256 * 8 = 2048カウントまで) 011 1:16 (256 * 16 = 4096カウントまで) 100 1:32 (256 * 32 = 8192カウントまで) 101 1:64 (256 * 64 = 16384カウントまで) 110 1:128 (256 * 128 = 32768カウントまで) 111 1:256 (256 * 256 = 65536カウントまで) ※ タイマ 0 ではプリスケーラカウンタをプログラムから参照することはできません。 参照可能なのは TMR0 レジスタ (256 段階) のみになります。 タイマ 0 用のクロック タイマ 0 用のクロックは、システムクロックを利用して内部で発生させる方法と、外部からの専用クロック (T0CKI ピンからの入力) を利用する方法が選択できます。 OPTION_REG&lt;T0CS(5)&gt; のビットで切り替えます。 内部クロックを使う場合は、 システムクロックの 1/4 の周波数でカウントされていきます。 OPTION_REG&lt;T0CS(5)&gt; = 0 … 内部クロックを使用 (システムクロックから生成) (Fosc/4) OPTION_REG&lt;T0CS(5)&gt; = 1 … 外部クロックを使用 (T0CKI ピンの入力をクロックとする) カウント値の決定 システムクロックと、タイマーの割り込み時間 (インターバル時間) が決定したら、次は TMR0 に設定するカウント値を求めなければいけません。 タイマ 0 に必要なカウント数は次のように求めます。 カウント数 ＝ インターバル時間 / (システムクロック周期 * 4) ※ ここで、(システムクロック周期 * 4) という部分は、カウンタのインクリメントにかかる時間を示しています。 1 命令にかかる時間 (1 サイクル時間) は 4 クロックにかかる時間と同じです。 10 MHz のクロックなら、カウンタのインクリメントに 0.1 * 4 = 0.4μsec の時間がかかります。 20 MHz ならば、0.2μsec です。 つまり、システムクロックが速いほど、タイマーで設定できるインターバル時間は短くなってしまいます。 例: 10MHz の時に 10 msec のインターバルが欲しい時 インターバル時間 … 10 msec ＝ 10,000μsec クロック周期 * 4 … 0.1μsec * 4 ＝ 0.4μsec ∴必要なカウント数 ＝ 10,000 / 0.4 ＝ 25,000 TMR0 だけでは、256 カウントしかできませんから、25,000 カウントを実現するにはプリスケーラの力を借りる必要があります。 この場合、プリスケーラのスケール値は 128 あるいは 256 に設定することになります。 1:128 のスケールの場合 25,000 / 128 ＝ 195.3 … 1:256 のスケールの場合 25,000 / 256 ＝ 97.6 … 1:128 のスケールを使った場合は、TMR0 が 195 回インクリメントされた時に、オーバーフローが起こるようにすればいいわけです。 つまり、255 - 195 = 60 という値を TMR0 にセットしてからタイマをスタートさせてやります。 ;プリスケーラの設定 BSF STATUS, RP0 ;Bank1 MOVLW B&#39;10000110&#39; ;スケール 1:128 MOVWF OPTION_REG BCF STATUS, RP0 ;Bank0 ;TMR0 へカウンタ初期値をセット MOVLW D&#39;60&#39; ;255 - 195 = 60 MOVWF TMR0 割り込み時の処理 TMR0 レジスタがオーバーフローすると、INTCON&lt;T0IF&gt; ビットが 1 になり、割り込みが発生します（割り込みを許可していれば）。 割り込みが発生すると、プログラムカウンタが強制的に 0x0004 に設定され、4 番地にジャンプ します。 つまり割り込み発生時のルーチンは 4 番地に書いておけばよいことになります。 次のようにして、4 番地からサブルーチンにジャンプさせるのも 1 つの方法です。 ORG 0 ;エントリポイント GOTO MAIN ; ORG 4 ;割り込み時にここにジャンプしてくる GOTO INTR ;割り込みルーチンへ飛ばす : MAIN : INTR BCF INTCON, T0IF ;割り込みフラグをクリア（必須） （ここに割り込み処理を記述する） RETFIE ;次の割り込みを許可してリターン（必須） ※ 割り込み全体を許可するには、INTCON&lt;GIE&gt; ビットを 1 にセットします。 インターバルタイマーとしてタイマ 0 を使う 一定時間ごとにある特定の処理をしたい場合は、インターバルタイマとして使うことになります。 タイマ 0 をインターバルタイマとして使うには、割り込みルーチンの最初で再び TMR0 を再設定してやります。 INTR BCF INTCON, T0IF ;割り込みフラグをクリア（必須） MOVLW D&#39;60&#39; ;TMR0 の再設定 MOVWF TMR0 ; (ここに割り込み処理を記述する) RETFIE ;次の割り込みを許可してリターン（必須） ※ ただし、TMR0 の再設定までのタイムラグがあるため、正確なインターバル時間が要求される環境では使えません。 このような場合は、タイマ 1 と CCP の機能を利用してください。 タイマ 1 は、ミッドレンジシリーズの PIC16F84 などで使用することができます。 タイマーの開始 タイマーの設定が終了し、タイマーをスタートするには、タイマ 0 の割り込みと、全体の割り込みを許可してやります。 タイマーの開始 BSF INTCON, T0IE ;タイマ 0 の割り込みを許可 BSF INTCON, GIE ;全体の割り込みを許可 タイマ 0 サンプルプログラム 次のコードはタイマ 0 を使ったサンプルプルグラムです。 割り込み発生時の処理を自由に記述してください。 タイマ 0 を使ったサンプルプログラム ;****************************************************************************** ; タイマ 0 による割り込み処理のサンプルプログラム ; ; 10 msec でタイマ 0 割り込み (10MHz の場合) ;****************************************************************************** LIST P=PIC16F84 INCLUDE &#34;P16F84.INC&#34; ORG 0 ;エントリポイント GOTO MAIN ORG 4 ;割り込みルーチン GOTO INTR MAIN BSF STATUS, RP0 ;Bank1 MOVLW B&#39;10000110&#39; ;スケール 1:128 MOVWF OPTION_REG BCF STATUS, RP0 ;Bank0 MOVLW D&#39;60&#39; ;タイマ 0 用カウンタ初期値 MOVWF TMR0 BSF INTCON, T0IE ;タイマ 0 割り込み許可 BSF INTCON, GIE ;全体の割り込み許可 MAIN_LOOP NOP ■■■ ここにメインの処理を書く ■■■ GOTO MAIN_LOOP INTR BCF INTCON, T0IF ;タイマ 0 割り込みフラグクリア ; MOVLW D&#39;60&#39; ;インターバルタイマとして使うなら TMR0 再設定 ; MOVWF TMR0 ; ■■■ ここに割り込み処理を書く ■■■ RETFIE ;割り込みを許可してリターン"},{url:"/p/ecozpj9/",title:"タイマ 1 を使用する ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"タイマ 1 を使用する ─ PIC めもめも タイマ 1 はミッドレンジシリーズの PIC16F84 などで使用することができます。 タイマ 1 を使用することにより、より正確なインターバルタイマとして機能させることができます。 T1CON レジスタの構成 T1CON レジスタ (10h : Bank0) ─ (7) ─ (6) T1CKPS1 (5) T1CKPS0 (4) T1OSCEN (3) T1SYNC (2) TMR1CS (1) TMR1ON (0) T1CKPS1 (5) ～ T1CKPS0 (4): タイマ 1 入力クロックプリスケール選択ビット 00 ･･･ 1:1 プリスケール値 01 ･･･ 1:2 プリスケール値 10 ･･･ 1:4 プリスケール値 11 ･･･ 1:8 プリスケール値 T1OSCEN (3): タイマ 1 オシレータイネーブルコントロールビット 0 ･･･ オシレータを停止させる。オシレータインバータと帰還抵抗をオフにして消費電流を抑えます。 1 ･･･ オシレータを動作させる。 T1SYNC (2): タイマ 1 外部クロック入力同期コントロールビット If TMR1CS = 1 0 ･･･ 外部クロック入力を同期させる 1 ･･･ 外部クロック入力を同期させない If TMR1CS = 0 このビットは無視されます。TMR1CS = 0 のとき、タイマ 1 は内部クロックを使用します。 TMR1CS (1): タイマ 1 クロックソース選択ビット 0 ･･･ 内部クロック (Fosc/4) 1 ･･･ RC0/T1OSO/T1CKI（立ち上がりエッジ）ピンからの外部クロック TMR1ON (0): タイマ 1 オン・ビット 0 ･･･ タイマ 1 を停止する 1 ･･･ タイマ 1 を動作させる タイマ 1 による割り込みの仕組み タイマ 1 の仕組みは、ほぼタイマ 0 と同じ仕組みになっていますが、タイマ 1 のカウンタは TMR1L (8bit) と TMR1H (8bit) の計 16 bit を使うため、プリスケーラを入れないでも、65,536 までのカウントが可能です。 ただし、プリスケーラはタイマ 0 の時と違い、少なめの 3 bit になっており、スケールは 1:8 までです。 といっても、合計 19bit のカウンタとして働くので、プリスケーラを入れて、524,288 までのカウントが可能となり、システムクロックが 10MHz の場合は約 210 msec までのインターバルを実現することができます（20MHz の場合は約 105 msec まで）。 タイマ 0 の時は、プリスケーラを機能させるかどうかを OPTION_REG&lt;PSA(3)&gt; のビットで切り替えていましたが、タイマ 1 の場合は常にプリスケーラが働きます。 その代わり、スケール値は 1:2 からでなく、1:1 から設定できるようになっています。 スケール値は T1CON&lt;T1CKPS0(4)&gt;, T1CON&lt;T1CKPS1(5)&gt; で次のように設定します。 タイマ 1 のプリスケーラのスケール設定 T1CON &lt;T1CKPS1(5)&gt;T1CON &lt;T1CKPS0(4)&gt; スケール 00 1:1 (65,536 * 1 = 655,36 カウントまで) 01 1:2 (65,536 * 2 = 131,072 カウントまで) 10 1:4 (65,536 * 4 = 262,144 カウントまで) 11 1:8 (65,536 * 8 = 524,288 カウントまで) TMR1L がオーバーフローすると、TMR1H が自動的にインクリメントされ、TMR1H もオーバーフローすると割り込みが発生します。 タイマ 1 のカウンタのためのクロック タイマ 1 のカウントのためのクロックは外部クロックを使うか、内部クロックを使うか選択することができます。 T1CON&lt;TMR1CS(1)&gt; のビットで切り替えます。 内部クロックを使う場合は、システムクロックの 1/4 の周波数でカウントされていきます。 T1CON&lt;TMR1CS(1)&gt; = 0 … 内部クロックを使用 (Fosc/4) T1CON&lt;TMR1CS(1)&gt; = 1 … 外部クロックを使用 割り込み時の処理 TMR1H がオーバーフローすると、割り込みが発生 (4 番地にジャンプ) し、割り込みフラグビット PIR1&lt;TMR1IF(0)&gt; がセットされます。 CCP モジュールのコンペアモードを利用した割り込み CCP モジュールのコンペアモードを使うと、タイマ 1 のカウンタが指定した値になったときに割り込みを発生させることができます。 この場合は、オーバーフローによる割り込みを使用する必要がないので、カウンタの初期値をあらかじめ計算してセットする必要がありません（CCPR1L、CCPR1H の値と TMR1L、TMR1H の値が等しくなった時に、なんらかのアクションが発生します）。 コンペアモードを使うことにより、タイマ 1 を正確なインターバルタイマとして利用することができます。 タイマ 1 の設定例 SetupTimer1 MOVLW B&#39;00000001&#39; ;プリスケーラ 1:1 ;オシレータ停止 ;内部クロック MOVWF T1CON CCS モジュールのコンペアモードで割り込みを発生させる場合は、T1CON の設定はこれだけになります（この場合、CCPR1L, CCPR1H の値を目的の値に設定する必要があります）。 タイマ 1 は設定するとただちにカウントを始めるため、他のレジスタの設定が済んでから設定を行なうようにします。 あるいは、割り込みをイネーブルにする直前に、カウンタ (TMR1L, TMR1H) をリセットするのも 1 つの方法です。 タイマ 1 をタイマ 0 と同じように、カウンタのオーバーフローによる割り込み (PIR1&lt;TMR1IF(0)&gt;) で利用する場合は、TMR1H が予定時間にうまくオーバーフローするように、TMR1L、TMR1H の初期値を計算してあらかじめセットしておく必要があります。"},{url:"/p/dtabczb/",title:"バンクとページの切り替え ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"バンクとページの切り替え ─ PIC めもめも バンク ･･･ 汎用レジスタ (RAM) の区分け MOVWF 命令などのデスティネーションアドレスは下のように 7 ビットとなっているので、このままでは 128 バイト分の汎用レジスタにしかアクセスすることができません。 MOVWF 命令の構造 → 0000001fffffff これを解決するために、SFR (Special Function Register) である STATUS レジスタ の 5, 6 ビット目 (RP0, RP1) をアドレスの拡張に使用します。 これにより 7 + 2 = 9 ビット、つまり 512 バイト分の汎用レジスタにアクセスできるようになります（ただしデバイスごとに使用できるサイズは異なります）。 バンク STATUS&lt;RP0&gt; STATUS&lt;RP1&gt; アクセスできるアドレス範囲 Bank0 0 0 0x0000 ～ 0x007F (128 bytes) Bank1 1 0 0x0080 ～ 0x00FF (128 bytes) Bank2 0 1 0x0100 ～ 0x017F (128 bytes) Bank3 1 1 0x0180 ～ 0x01FF (128 bytes) PORTA を出力か入力かどちらに使うかの設定をするための TRISA レジスタは Bank1 にあるので、バンクを切り替えて値を設定する必要があります（PORTA は Bank0 にあります）。 バンクを切り替えて TRISA にアクセスする例を示します。 PortA[0] を出力用ポートに設定する BSF STATUS, RP0 ; set bank1 BCF TRISA, 0 ; PortA[0] is an output port BCF STATUS, RP0 ; set bank0 RP0 と RP1 は MPASM のヘッダファイルに EQU で定義されています。 ページ ･･･ プログラムメモリ (ROM) の区分け バンクは、データメモリへのアクセスを拡張するものでした。 これと同じようなに、プログラムメモリへのアクセスを拡張したものがページです。 GOTO 命令と CALL 命令のリテラル部分は、11 ビットまでの値が指定できるようになっています。 つまり通常は、この値を使って 2k ワードの範囲のジャンプができることになります。 GOTO 命令の構造 → 101kkkkkkkkkkk PIC ではページの機能を利用することによって、この 4 倍の 8k ワードまでのジャンプを実現しています。 そのために、PCLATH レジスタ というレジスタの 3, 4 ビット目をこの 11 ビットの値に付加したものをプログラムカウンタとして利用しています。 これにより、プログラムメモリ 0x0000 ～ 0x1FFF の 8k ワードの範囲に自由にアクセスできるようになっています（ただしデバイスごとに使用できるサイズは異なります）。 ページ PCLATH&lt;3&gt; PCLATH&lt;4&gt; アクセスできるアドレス範囲 Page0 0 0 0x0000 ～ 0x07FF (2k words) Page1 1 0 0x0800 ～ 0x0FFF (2k words) Page2 0 1 0x1000 ～ 0x17FF (2k words) Page3 1 1 0x1800 ～ 0x1FFF (2k words) PCLATH の 3, 4 ビット目の値をセットするには次のようにします。 ; Page0 に切り替え BCF PCLATH, 3 ; 0 BCF PCLATH, 4 ; 0 ; Page1 に切り替え BSF PCLATH, 3 ; 1 BCF PCLATH, 4 ; 0 ; Page2 に切り替え BCF PCLATH, 3 ; 0 BSF PCLATH, 4 ; 1 ; Page3 に切り替え BSF PCLATH, 3 ; 1 BSF PCLATH, 4 ; 1 次の例は、ページ 0 のルーチンから、ページ 1 のルーチンにジャンプする例です。 ORG 0x0000 ; ページ0 内のルーチン ... BSF PCLATH, 3 BCF PCLATH, 4 CALL BANK1_ROUTINE ... ORG 0x0800 ; ページ1 内のルーチン BANK1_ROUTINE ... RETURN ; ※戻る時はページ指定の必要はない RETURN、RETFIE、RETLW 命令で元のアドレスに戻る場合は、スタックから 13 ビットのアドレスが取り出されるため、ページの指定をする必要はありません（この時に使用できるスタックのレベルは 8 レベルまでなので、CALL を連続して呼ぶような場合は注意が必要です）。 バンクの数 PIC16F84 PIC16F877 バンク 2つ (BANK0, BANK1) 4つ (BANK0 ～ BANK3) 入出力ポート 2つ (PORTA, PORTB)(BANK0 にある) 5つ (PORTA ～ PORTE) 入出力切り替えレジスタ TRISA, TRISB(STATUS レジスタの 5bit目(= RP0) で切り替え)(BANK1 にある) プログラムメモリ 1KByte (0000h ～ 1FFFh) 8KByte (2KByte ごとに区切られている)0ページ ･･･ 0005h ～ 07FFh1ページ ･･･ 0800h ～ 0FFFh2ページ ･･･ 1000h ～ 17FFh3ページ ･･･ 1800h ～ 1FFFh"},{url:"/p/zm6rg3v/",title:"ラベル ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"ラベル ─ PIC めもめも ラベル定義の構文 &lt;ラベル名&gt; EQU &lt;リテラル値&gt; EQU 命令を使うことによってラベルを定義することができます。 指定したラベルは、リテラル (k) として使用することができます。 変数領域が割り当てられるわけではないので、定義する時にアドレスを気にしたりする必要はありません。 例: MAX_VAL を 0xFF として定義 MAX_VAL EQU 0xFF ; MAX_VAL=0xFF これは、C 言語のプリプロセッサの #define のようなものです。 #define MAX_VAL 0xFF"},{url:"/p/hoytbx6/",title:"変数の割り当て ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"変数の割り当て ─ PIC めもめも 領域として自由に使用できる汎用レジスタの範囲 ユーザが変数領域として自由に使用できる汎用レジスタ (データ RAM) の範囲の一例です。 Device Bank0 Bank1 Bank2 Bank3 データ RAM サイズ PIC16F83PIC16CR83 0Ch ～ 2Fh(36 bytes) 8Ch ～ AFh(Bank0 へのマップ) ─ ─ 36 bytes PIC16F84PIC16CR84 0Ch ～ 4Fh(68 bytes) 8Ch ～ CFh(Bank0 へのマップ) ─ ─ 68 bytes PIC16F873PIC16F874 20h ～ 7Fh(96 bytes) A0h ～ FFh(96 bytes) ─ ─ PIC16F876PIC16F877 20h ～ 7Fh(96 bytes) A0h ～ EFh(80 bytes) 110h ～ 16Fh(96 bytes) 190h ～ 1EFh(96 bytes) PIC16F87x の Bank1 ～ 3 の最後の部分には、Bank0 へのマッピングアドレスとして使えるものがあります。 うまく使えば効率的なプログラムが作れるかもしれません。 詳しくは各デバイスのデータシートを参照してください。 汎用レジスタに変数領域を確保する データメモリに変数を確保するには CBLOCK や RES を使うのが便利です。 Bank の切り替えの必要をなくすために、普通は Bank0 から変数を割り当てていきます。 PIC16F84A の場合の変数割り当て LIST P=16F84A INCLUDE P16F84A.INC ;================================== ; 変数定義 ;================================== CBLOCK H&#39;0C&#39; ;0Ch 番地から 34 バイト使える VAR_A VAR_B VAR_C ENDC ;CBLOCK 終了 PIC16F873 の場合の変数割り当て LIST P=16F873 INCLUDE P16F873.INC ;================================== ; 変数定義 ;================================== CBLOCK H&#39;20&#39; VAR_A VAR_B VAR_C ENDC"},{url:"/p/p83uim3/",title:"汎用テクニック ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"汎用テクニック ─ PIC めもめも どの Page にあるか分からないサブルーチンにジャンプする ; ; どのページにあるか分からないサブルーチンにジャンプする ; ... MOVLW HIGH(SUB) ; SUB の上位アドレス MOVWF PCLATH ; を PCLATH にセット CALL SUB ... SUB ... RETURN 特定のマスクで 2 つの値を比較 ; ; 特定のマスクで比較 (A と B を 01110000 のビットマスクで比較) ; MOVF A, W XORWF B, W ANDLW B&#39;01110000&#39; BTFSC STATUS, Z GOTO AB_IS_SAME ; 同じだった (→ AB_IS_SAME へ) GOTO AB_IS_NOT_SAME ; 違った (→ AB_IS_NOT_SAME へ) AB_IS_SAME ... GOTO xxx AB_IS_NOT_SAME ... GOTO xxx W レジスタの値 (0～F) を 7 セグメント LED 用の値に変換する ;============================================================================== ; W の値を 7 セグメント LED 用の値に変換します。 ; ; 使い方: ; (W に 0～9 の値が入っている時に) ; CALL TO_7SEG ;============================================================================== TO_7SEG ADDWF PCL, F ; プログラムカウンタに W の値を加える RETLW B&#39;01111110&#39; ; 0 の表示用 RETLW B&#39;00001100&#39; ; 1 の表示用 RETLW B&#39;10110110&#39; ; 2 の表示用 RETLW B&#39;10011110&#39; ; 3 の表示用 RETLW B&#39;11001100&#39; ; 4 の表示用 RETLW B&#39;11011010&#39; ; 5 の表示用 RETLW B&#39;11111010&#39; ; 6 の表示用 RETLW B&#39;00001110&#39; ; 7 の表示用 RETLW B&#39;11111110&#39; ; 8 の表示用 RETLW B&#39;11001110&#39; ; 9 の表示用"},{url:"/p/yzbkxhz/",title:"遅延時間 ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"遅延時間 ─ PIC めもめも 1 サイクル (1 命令) にかかる時間 1 つの命令を実行するためにかかる時間（1 サイクル）は、クロックの周期(sec) * 4、あるいは、4 / クロックの周波数(Hz) となります。 具体的な値は次のようになります。 10MHzの場合の1命令にかかる時間 ･･･ 0.1 (μsec) * 4 = 0.4 (μsec) 20MHzの場合の1命令にかかる時間 ･･･ 0.05 (μsec) * 4 = 0.2 (μsec) プログラムカウンタの値を変更する命令の場合は、2 サイクルの時間がかかります。 このような命令には CALL, GOTO, RETFIE, RETLW, RETURN があります。 また、DECFSZ, INCFSZ, BTFSC, BTFSS でスキップした場合も 2 サイクルかかります。 遅延時間を作るサブルーチン 遅延を発生させるサブルーチンを作る場合は、次のような手順で作成します。 1. 必要なサイクル数を求める サブルーチンに必要なサイクル数は、遅延時間 / 1 サイクルにかかる時間で求めることができます。 例えば、10MHz (0.4μsec) で 100μsec の遅延を作りたい場合は、100 / 0.4 = 250 サイクルが必要になります。 2. ループ回数を決める ループ回数は、(1 で求めたサイクル数 - 6) / 3 で求められます（余りは NOP で調整します）。 -6 の部分は、MOVLW, MOVWF, DECFSZ(2), RETURN のサイクルで、/3 の部分は、DECFSZ(1), GOTO の部分の実行回数を求めています。 以下にいくつかの遅延時間発生ルーチンの例を示します。 10MHz 用 20μsec の遅延時間サブルーチン 50μsec の遅延時間サブルーチン 100μsec の遅延時間サブルーチン 250μsec の遅延時間サブルーチン 20MHz 用 15μsec の遅延時間サブルーチン 長い遅延時間を作成する場合の注意 1 秒などの長い遅延時間を作成する場合、ループ用カウンタのオーバーフローを避けるため、短い遅延時間のサブルーチンを何度も呼び出すことになります。 この時、ループのカウントに使用する変数は別のものを使用することに注意してください。 遅延時間サブルーチン自動生成 Script クロックの周波数と、作りたい遅延時間を入力して「作成」ボタンを押してください。 遅延時間を発生するためのサブルーチンが表示されます。 ただし、あまり大きな遅延時間は作成できません（カウンタ用の変数がオーバーフローするため）。 10MHz … 308μsec まで 20MHz … 154μsec まで MHz　μsec　1 サイクルに必要な時間は 必要なサイクル数は 必要なループ数は 必要な NOP の数は"},{url:"/p/hzva4rn/",title:"部品メモ: 3端子レギュレータ ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"部品メモ: 3端子レギュレータ ─ PIC めもめも 可変3端子レギュレータ LM317 大きめの四角いレギュレータ 7805 (DC, +5V 1A) は、出力電流が 1A あり、7～20V を 5±0.25V に変換できます。 ちっちゃい３端子レギュレータ 78L05 (DC, +5V 100mA) は、ひらぺったい方から見て、右の端子から IN, GND, OUT になっています。 この順番はレギュレータごとに異なる ので、必ずデータシートで確認する必要があります。7～25V を 5±0.25V に変換できます。 3端子レギュレータの配線方法 3端子レギュレータの入力、出力側に共通のグランドが必要です。 出力側のコンデンサは不要ですが、あると過渡応答を改善できます。"},{url:"/p/spggmm3/",title:"部品メモ: LED（Light Emitting Diode: 発光ダイオード） ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"部品メモ: LED（Light Emitting Diode: 発光ダイオード） ─ PIC めもめも LED の極性 LED には２つの端子があり、それぞれ下記のような名前が付けられています。 アノード (A) ･･･ 端子の長い方 (+ 電源へ) カソード (K) ･･･ 端子の短い方 (GND へ) LED の電気的特性として、順方向 (アノード → カソード) にしか電流を流さないという特徴を持っています。 順方向でも一定の電圧降下があります（1.7V 程度）。 LED へ流す電流の決め方 LED の明るさは流す電流の大きさによって変わります。 ただし、あまり大きな電流を流すと LED が壊れてしまうので、電源との間に抵抗を入れて流れる電流を調整する必要があります。 何Ωの抵抗を接続すればいいかを計算する時は、LED による電圧降下を考えて求める必要があります。 計算式: R = (V - VLED) / I 例えば、電源 (V) を 5V、適正電流 (I) を 5mA とすると、 R = (5.0 - 1.7) / 0.005 = 660 (Ω) と求められます。"},{url:"/p/dppsjeu/",title:"部品メモ: RS-232C (Recommend Standard number 232) ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"部品メモ: RS-232C (Recommend Standard number 232) ─ PIC めもめも はじめに（用語とか） スペース状態 ･･･ 信号 0。入力 +3V 以上。出力 +5V ～ +15V。 マーク状態 ･･･ 信号 1。入力 -3V 以下。出力 -5V ～ -15V。 短絡時最大出力電流 ･･･ 500mA。 ハードウェアフローコントロール ･･･ RTS と CTS の信号線を使ったフロー制御。RTS／CTS とも記述されます。 ソフトウェアフローコントロール ･･･ ソフトウェアによるフロー制御。アプリケーションで決められた特殊な記号を送信することでフロー制御を行います。RTS と CTS ワイヤは使用しません。Xon／Xoff とも記述されます。 DTE デバイス ･･･ 通常は PC を示します。オスコネクタを持ちます。 DCE デバイス ･･･ 通常は シリアルデバイスを示します。メスコネクタを持ちます。DTE デバイスと DCE デバイスをつなぐ時は通常ストレートケーブルを用います。 ヌルモデムケーブル／ヌルアダプタ ･･･ 送信と受信の信号線をクロスさせたものです。TxD ⇔ RxD、DTR ⇔ DSR、RTS ⇔ CTS のようにクロスされます。 DSub 9 ピン （DTE デバイス（PC 側）オス） 9 ピンミニ DSUB コネクタ (PC 側オス) ピン番号表記I/O意味説明 1 DCD In Data Carrier Detect（キャリア検出） 外部端末の送受信準備ができたことを知る 2 RxD In Receive Data（受信データ） &nbsp; 3 TxD Out Transmit Data（送信データ） &nbsp; 4 DTR Out Data Terminal Ready（データ端末準備） PC が繋がっていることを認識させる（PC → 外部） 5 GND --- Ground（信号用グラウンド） &nbsp; 6 DSR In Data Set Ready（データセット準備） 端末が繋がっていることを認識する（PC ← 外部） 7 RTS Out Request To Send (DTE の送信要求) PC の送信開始信号（フロー制御用）（PC → 外部） 8 CTS In Clear To Send（DCE の送信要求） PC への受信開始要求（フロー制御用）（PC ← 外部） 9 RI In Ring Indication（被呼表示） 電話がかかってきたことを伝える／PC の電源を制御する PC からデータを送信するのに最低限必要なのは、TxD(3) と GND(5) です。 データを受信する時は RxD(2) が必要です。 出力の信号線は、デフォルトでマーク状態(-)かスペース状態(+)のどちらかを出力してます。 信号線COMポート接続時COMポートオープン時 TxD (3)mark(-)mark(-) DTR (4)mark(-)space(+) RTS (7)mark(-)space(+) 小さな回路なら、DTR(4) と RTS(7) から電源供給することができます。 といっても電流量は少ないし、マシンによって供給量が多少異なるので、あまり信頼できません。 DTR(4) と RTS(7) を並列に繋ぐと電流を増やせます。 CD／DCD (1) ･･･ モデムが相手側のモデムと接続を確立した時や、キャリアトーンの検出を知らせます。この信号線はめったに使用されません。 RD／RxD (2) ･･･ DCE から DTE へのデータ受信に使用されます。RD ワイヤは DTE デバイスがアイドル状態の時、マーク状態になります。 TD／TxD (3) ･･･ DTE から DCE へのデータ送信に使用されます。TD ワイヤは DTE デバイスがアイドル状態の時、マーク状態になります。逆にバッファがいっぱいの時はスペース状態になります。 DTR (4) ･･･ DTE デバイスの準備ができていることを示します。電源が入っていることを確かめるために使用したりしますが、あまり使われない信号線です。Windows で COM ポートを開くと 1 になり、閉じると 0 になります。 DSR (6) ･･･ DCE デバイスの準備ができていることを示します。電源が入っていることを確かめるために使用したりしますが、あまり使われない信号線です。 RTS (7) ･･･ DTE デバイスと DCE デバイス両方のハードウェアフローコントロールが ON の場合に使用されます。DTE がデータ受信可能（待機中）な時は、このワイヤがマーク状態になります。逆にバッファがいっぱいの時はスペース状態になります。 CTS (8) ･･･ DTE デバイスと DCE デバイス両方のハードウェアフローコントロールが ON の場合に使用されます。DCE がデータ受信可能（待機中）な時は、このワイヤがマーク状態になります。 RI (9) ･･･ モデムが呼び出し信号を受信したことを知らせます。つまり電話が鳴ったときに PC にそれを知らせます。この信号線はめったに使用されません。 非同期通信 Windows などの PC では主に非同期通信が使用されます。 同期通信のように常に信号をやりとりしていないため、データの送信を示すためのスタートビットが必要になります。 データを送信していない時（アイドル時）は TX はマーク状態 (1) になっているので、スタートビットは 0 の信号になります。 1 つのデータの構造は次のようになります。 スタートビット（1 bit） データ（4 ～ 8 bits。主に 8 bits） ストップビット（1 bit） ケーブル長 24 ゲージワイヤの実用的なケーブル長 Baud Rate シールドケーブル非シールドケーブル 1101500 m300 m 3001200 m 1200900 m150 m 2400600 m 4800150 m75 m 960075 m30 m"},{url:"/p/yzdxf7i/",title:"部品メモ: 水晶振動子（クリスタル振動子、オシレーター） ─ PIC めもめも",date:"2002-08-01T00:00:00+09:00",body:"部品メモ: 水晶振動子（クリスタル振動子、オシレーター） ─ PIC めもめも 水晶振動子（クリスタル振動子）20MHz"},{url:"/r/",title:"R",date:"0001-01-01T00:00:00Z",body:"R 統計解析やグラフプロットに便利な R 言語のメモです。 R のコーディングスタイル 下記は Google が採用している R のコーディングスタイルを参考にしています。 インデントはスペース 2 文字 一行 80 文字まで 代入は &lt;- を使用する（= は代入には使わない） attach は使わない エラーの生成には stop() を使う S3 オブジェクトを使う（S4 オブジェクトを使わない） 命名規則 関数: FunctionName 変数: variableName 定数: kConstantName R 環境の Locale 設定（日本語を使用する） R コンソールを起動したときに、システムの Locale 設定が正しく行われていないと、下記の様な警告メッセージが表示されます。 Mac での Locale 設定の警告メッセージ During startup - Warning messages: 1: Setting LC_CTYPE failed, using &#34;C&#34; 2: Setting LC_COLLATE failed, using &#34;C&#34; 3: Setting LC_TIME failed, using &#34;C&#34; 4: Setting LC_MESSAGES failed, using &#34;C&#34; 5: Setting LC_MONETARY failed, using &#34;C&#34; [R.app GUI 1.66 (7060) x86_64-apple-darwin13.4.0] WARNING: You&#39;re using a non-UTF8 locale, therefore only ASCII characters will work. Please read R for Mac OS X FAQ (see Help) section 9 and adjust your system preferences accordingly. R コンソールで正しくメッセージ表示を行うには、少なくとも UTF-8 を使用する設定を行っておく必要があります。 Mac でシステムの Locale 設定を変更する Mac のターミナルで defaults コマンドを使用すると、システムの Locale 設定を変更することができます。 ヘルプメッセージなどを日本語にしたい場合は、js_JP.UTF-8 の方を指定してください。 $ defaults write org.R-project.R force.LANG en_US.UTF-8 # 英語表示 $ defaults write org.R-project.R force.LANG ja_JP.UTF-8 # 日本語表示 上記を実行してから R コンソールを立ち上げ直すと、正しく Locale 設定が反映されます。 あるいは、R コンソールから下記の様に設定することもできます。 &gt; system(&#34;defaults write org.R-project.R force.LANG ja_JP.UTF-8&#34;) locale コマンドを実行すると、現在の設定を確認することができます。 &gt; system(&#34;locale&#34;) LANG=&#34;ja_JP.UTF-8&#34; LC_COLLATE=&#34;ja_JP.UTF-8&#34; LC_CTYPE=&#34;ja_JP.UTF-8&#34; LC_MESSAGES=&#34;ja_JP.UTF-8&#34; LC_MONETARY=&#34;ja_JP.UTF-8&#34; LC_NUMERIC=&#34;ja_JP.UTF-8&#34; LC_TIME=&#34;ja_JP.UTF-8&#34; LC_ALL= 参考: R for Mac OS X FAQ - CRAN Project ヘルプの使い方 ヘルプドキュメントのトップページを表示する help.start() 関数のヘルプを表示する help(function) ?function 指定した関数のシグネチャを表示する args(function) 関数の使用例を実行する（例: mean 関数の使用例） &gt; example(mean) mean&gt; x &lt;- c(0:10, 50) mean&gt; xm &lt;- mean(x) mean&gt; c(xm, mean(x, trim = 0.10)) [1] 8.75 5.50 上記で実行されるのは、help(mean) を実行したときに Example の項目で示されているサンプルコードです。 構文のヘルプを表示する（例: for の使い方） ?&#34;for&#34; help(&#34;for&#34;) キーワードでヘルプを検索する ??keyword help.search(&#34;keyword&#34;) Web 上で検索する RSiteSearch(&#34;keyword&#34;) R の構文 条件分岐 if (cond1) { ... } else if (cond) { ... } else { ... } 繰り返し for (i in 1:5) { ... } while (cond) { ... } repeat { ... } ループ内では break（ループ処理の終了）や next（次のループ処理へ）を使用することができます。 より詳しく調べるには if や for などの詳しい説明を読みたい場合は、下記のようにヘルプを表示することができます（これらのキーワードは、ダブルクォーテーションで括る必要があることに注意してください）。 ?&#34;if&#34; help(&#34;if&#34;) R のデータ型 実数 (numeric) x &lt;- 12.34 複素数 (complex) x &lt;- 1+2i 文字列 (character) x &lt;- &#39;Hello&#39; x &lt;- &#34;Hello&#34; 論理型 (logical) x &lt;- TRUE (or T) x &lt;- FALSE (or F) T と F は、TRUE と FALSE の代わりに使用することができますが、別の値を代入してしまうことができます（T と F は定数ではなく変数ということ）。 そのため、公式ドキュメントでは、常に TRUE と FALSE の方を使うことを推奨しています。 ベクトル x = c(1, 2, 3) ベクトル内に複数の型を含めると、文字列＞実数＞論理値 の優先度で同じ型になるように自動的に変換されます。 &gt; c(1, 2, 3.14) [1] 1.00 2.00 3.14 &gt; c(1, 2+3i) [1] 1+0i 2+3i &gt; c(123, TRUE, FALSE) [1] 123 1 0 &gt; c(&#34;ABC&#34;, 123, TRUE) [1] &#34;ABC&#34; &#34;123&#34; &#34;TRUE&#34; mode 関数で型を調べる mode() 関数を使用すると、指定した値を、R がどのような型とみなしているかを調べることができます。 &gt; mode(10) [1] &#34;numeric&#34; &gt; mode(1+2i) [1] &#34;complex&#34; &gt; mode(&#39;Hello&#39;) [1] &#34;character&#34; &gt; mode(TRUE) [1] &#34;logical&#34; &gt; mode(c(&#34;ABC&#34;, 123, TRUE)) [1] &#34;character&#34; R スクリプトファイルを実行する (source) 例えば、commands.R というテキストファイルに R のコマンドを記述してある場合、以下のように読み込んで実行することができます。 &gt; source(&#34;commands.R&#34;) 読み込み時のカレントディレクトリは、getwd() で取得、setwd() で変更することができます。 R コマンドの実行結果をファイルに保存する (sink) R コマンドの実行結果はデフォルトではウィンドウ (console) 内に表示されますが、sink() 関数で出力先をファイルに切り替えることができます。 &gt; sink(&#34;output.txt&#34;) 出力先をウィンドウ (console) に戻すには、パラメータ無しで sink() 関数を呼び出します。 &gt; sink() 現在作成されているオブジェクトの一覧を表示する (ls, objects) Java や C++ の変数にあたるものは、R ではオブジェクトと呼びます。 現在作成されているオブジェクトの一覧を確認するには、ls() あるいは objects() を使用します。 &gt; x &lt;- 1:10 &gt; y &lt;- x**2 &gt; ls() [1] &#34;x&#34; &#34;y&#34; &gt; objects() [1] &#34;x&#34; &#34;y&#34; 上記の結果表示されたオブジェクトは、下記のように「参照」できます。 &gt; x [1] 1 2 3 4 5 6 7 8 9 10 &gt; y [1] 1 4 9 16 25 36 49 64 81 100 不要なオブジェクトは、rm() で削除することができます。 &gt; ls() [1] &#34;x&#34; &#34;y&#34; &gt; rm(x) &gt; ls() [1] &#34;y&#34; # x が削除された R の実行環境を終了するとき、現在作成されているオブジェクトは、カレントディレクトリの .RData というファイルに保存されます。 Windows 環境では、この .RData ファイルをダブルクリックすることで、終了時と同じ状態で R を起動することができます。 このような仕組みがあるため、分析の対象ごとにディレクトリを作成しておくと便利です。 出力先を画像ファイルに切り替える R では 「作図デバイス」 を切り替えることによって、plot() や hist() による描画内容を画像ファイルとして保存することができます。 現在の環境でどのような形式をサポートしているかは下記のように確認できます。 help(&#34;Devices&#34;) PNG ファイルへの出力 たとえば、PNG ファイルにプロットするには下記のように png() 関数を使用して作図デバイスを切り替えます。 描画が終わったら、dev.off() で作図デバイスを閉じます（閉じないとファイルが使用中のままになってしまい、別のアプリケーションから開くことができません）。 png(&#34;output.png&#34;, width=400, height=300) # 作図デバイス(png)を開く plot(x, y) # 描画 dev.off() # 作図デバイス(png)を閉じる 作図デバイスを切り替えるときに、bg=&quot;transparent&quot; オプションを指定すると、背景を透過した画像 を出力することができます。 &gt; png(&#34;sample.png&#34;, width=400, height=300, bg=&#34;transparent&#34;) &gt; plot(x, y) &gt; dev.off() SVG ファイルへの出力 svg() 関数を使用すると、グラフの出力先を SVG ファイルに変更することができます。 svg() 関数の width、height パラメータの単位は、デフォルトで インチ となっていることに注意してください（png() 関数の場合はピクセルです）。 svg(&#34;output.svg&#34;, width=4, height=3) # 作図デバイス(svg)を開く plot(x, y) # 描画 dev.off() # 作図デバイス(svg)を閉じる こちらの場合も、実際の SVG ファイルは、dev.off() してからアクセスできるようになります。 ファイルの出力先ディレクトリ どこに画像ファイルが出力されたかを調べるには、getwd() を使用します。 &gt; getwd() [1] &#34;C:/Users/maku/Documents&#34; このワーキングディレクトリは setwd() により変更可能です。 &gt; setwd(&#34;C:/your/dir&#34;) # スラッシュを使う場合 &gt; setwd(&#34;C:\\\\your\\\\dir&#34;) # バックスラッシュを使う場合 この setwd() は柔軟にできており、次のようにして 1 つ上のディレクトリに移動することもできます。 &gt; setwd(&#34;../&#34;) データ生成 連番のベクトルを作成する (seq) コロンを使用した範囲指定により、連番要素からなるベクトルを簡単に生成することができます。 x &lt;- 1:5 # c(1, 2, 3, 4, 5) と同様 x &lt;- 5:1 # c(5, 4, 3, 2, 1) と同様 下記のように、ついでに演算を行うことで柔軟なベクトル生成を行えます。この例では、1, 2, 3 というシーケンスのそれぞれの要素に +1 したシーケンスを生成しています。 x &lt;- (1:3)+1 # c(2, 3, 4) や 2:4 と同様 ちなみに、演算子 : は、+ よりも結合度が高いため、上記の例のカッコを省略しても同様に動作します。 x &lt;- 1:3+1 #=&gt; 2, 3, 4 上記の結果は、ちょっと直感に反するかもしれません。 演算子 + を先に評価するには、次のようにする必要があります。 x &lt;- 1:(3+1) #=&gt; 1, 2, 3, 4 seq() 関数を使用すると、より柔軟にシーケンスデータを生成できます。 下記の例では、0.1 刻みのデータを作成しています。 x &lt;- seq(from=0, to=0.5, by=0.1) #=&gt; 0.0, 0.1, 0.2, 0.3, 0.4, 0.5 len パラメータを使うと、何分割するかを指定することができます。 下記の例では、-π～π の範囲の値を 100 等分して得られるシーケンスデータを生成しています。 x &lt;- seq(-pi, pi, len=100) plot(x, sin(x)) ちなみに sin 波は plot(sin, -pi, pi) とすることで滑らかに描画できます。 繰り返しのベクトルを作成する (rep) rep() 関数を使用すると、すでに存在するベクトルデータ内の要素を繰り返したベクトルデータを作成することができます。 例: ベクトル全体を 5 回繰り返す &gt; x &lt;- 1:3 &gt; rep(x, times=5) [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 例: 各要素ごとに 5 回繰り返す &gt; x &lt;- 1:3 &gt; rep(x, each=5) [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 ベクトルに対して算術演算を行う ベクトルに対してスカラ値の算術演算を行うと、各要素に対して演算 が行われます。 結果的に、元のベクトルと同じ数の要素のベクトルが作成されます。 &gt; x &lt;- c(1, 2, 3) &gt; x + 100 [1] 101 102 103 &gt; x - 100 [1] -99 -98 -97 &gt; x * 100 [1] 100 200 300 &gt; x / 100 [1] 0.01 0.02 0.03 &gt; x ^ 2 [1] 1, 4, 9 スカラ値に作用する算術系関数をベクトルに適用した場合も、ほぼ同様の振る舞いをします。 下記の例では、ベクトルの各要素に対して log10() を適用しています。 &gt; x &lt;- c(1, 10, 100, 1000) &gt; log10(x) [1] 0 1 2 3 この性質を利用して、下記の様に x 軸のベクトルデータから、y 軸のベクトルデータを作成するという使い方ができます。 例: y = x^2 のグラフを表示 x &lt;- 1:5 # 1～5 までの連番データを生成 (1, 2, 3, 4, 5) y = x^2 # 各要素の二乗からなるデータを生成 (1, 4, 9, 16, 25) plot(x, y) # 二次元グラフとしてプロット この例では y というオブジェクトを作成していますが、プロット系の関数に渡す時に直接データ生成してしまうこともできます。 plot(x, x^2) 他にもいろいろな演算や関数を組み合わせてデータを生成することができます。 plot(x, 1+sqrt(x)) ベクトル同士の演算を行う ベクトル同士の算術演算を行うと、対応する各要素ごとに算術演算が行われます。 &gt; x &lt;- c(1, 2, 3) &gt; y &lt;- c(100, 200, 300) &gt; x + y [1] 101 202 303 &gt; x - y [1] -99 -198 -297 &gt; x * y [1] 100 400 900 &gt; x / y [1] 0.01 0.01 0.01 要素数の異なるベクトル同士で算術演算を行うと、少ない方の要素が繰り返し参照 されます。 &gt; x &lt;- c(1, 2) &gt; y &lt;- c(100, 200, 300, 400, 500, 600) &gt; x + y [1] 101 202 301 402 501 602 要素数がちょうど整数倍になっていないときは警告が出ます。 &gt; x &lt;- c(1, 2) &gt; y &lt;- c(100, 200, 300) &gt; x + y [1] 101 202 301 Warning message: In x + y : longer object length is not a multiple of shorter object length 2 つのデータを結合する (c) 任意の数のベクトルを結合するには c() を使います。 a &lt;- 1:3 c(a, a) #=&gt; 1, 2, 3, 1, 2, 3 c(a, a*2) #=&gt; 1, 2, 3, 2, 4, 6 c(a, a^2) #=&gt; 1, 2, 3, 1, 4, 9 c(a, a, 7) #=&gt; 1, 2, 3, 1, 2, 3, 7 ベクトルの各要素にプレフィックス、サフィックスを付ける (paste) paste 関数を使用すると、2 つ以上のベクトルデータの各要素を文字列結合したベクトルデータを生成することができます。 サイズの異なるデータを与えた場合、少ない方のデータが繰り返し適用されます。 これを利用して、ベクトルの各要素にプレフィックスやサフィックスを付けることができます。 プレフィックスの追加（各要素の前に A を追加） &gt; paste(&#39;A&#39;, 1:3) [1] &#34;A 1&#34; &#34;A 2&#34; &#34;A 3&#34; 上記のように、デフォルトではスペースを挟んで結合されます。 セパレータは sep パラメータで変更できるので、次のように空文字列を指定することでスペースを挟まずに結合することができます。 &gt; paste(&#39;A&#39;, 1:3, sep=&#39;&#39;) [1] &#34;A1&#34; &#34;A2&#34; &#34;A3&#34; paste() 関数に渡すベクトルの順序を変更すれば、サフィックスを付加することができます。 サフィックスの追加（各要素の後ろに x を追加） &gt; paste(1:3, &#39;x&#39;, sep=&#39;&#39;) [1] &#34;1x&#34; &#34;2x&#34; &#34;3x&#34; 3 つ以上のベクトルを結合することもできます。 次の例では、3 つのベクトルを結合して連番からなるファイル名を作成しています。 &gt; paste(&#39;data&#39;, 1:5, &#39;.zip&#39;, sep=&#39;&#39;) [1] &#34;data1.zip&#34; &#34;data2.zip&#34; &#34;data3.zip&#34; &#34;data4.zip&#34; &#34;data5.zip&#34; ベクトルのサイズを切り詰める、拡張する (length) length() 関数を代入の左辺に持ってくると、ベクトルのサイズを変更することができます。 現在の要素数よりも小さいサイズを指定すれば切り詰めることになり、大きいサイズを指定すれば拡張することになります。 拡張された部分の要素の値は NA となります。 &gt; x &lt;- 1:10 &gt; x [1] 1 2 3 4 5 6 7 8 9 10 # サイズを切り詰める &gt; length(x) &lt;- 5 &gt; x [1] 1 2 3 4 5 # サイズを拡張する &gt; length(x) &lt;- 10 &gt; x [1] 1 2 3 4 5 NA NA NA NA NA ベクトルのサブセットを生成する（ベクトルのフィルタ） ベクトルデータに対して、[] 演算子を使って インデックスベクトル (index vector) を指定すると、そのベクトルの要素を特定の条件で組み合わせたベクトルを作成することができます。 インデックスベクトルに指定するベクトルの型により、動作が変わります。 数値ベクトル（1 〜 length(x) の範囲の数値で構成されるベクトル）を指定した場合 指定した要素位置で構成されたベクトルを作成 論理ベクトル（TRUE, FALSE で構成されるベクトル）を指定した場合 TRUE になる位置の要素のみで構成されたベクトルを作成（フィルタ） インデックスベクトルとして数値ベクトルを指定する 下記は、数値ベクトルで示した位置の要素から構成されるベクトルを作成しています。 &gt; x &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) &gt; x[c(1, 2, 3, 2, 1)] [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; &#34;B&#34; &#34;A&#34; Python のリスト（配列）と同様のインデックスアクセスや配列スライシングを行えるのは、この仕組みのおかげです。 &gt; x &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) &gt; x[2] [1] &#34;B&#34; &gt; x &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) &gt; x[2:3] [1] &#34;B&#34; &#34;C&#34; 範囲外のインデックスを指定すると、その位置の要素は NA になります。 &gt; x &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) &gt; x[1:5] [1] &#34;A&#34; &#34;B&#34; &#34;C&#34; NA NA 数値ベクトルを作成する関数（rep() など）と組み合わせて使用することで、柔軟なベクトル作成を行うことができます。 &gt; x &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) &gt; x[rep(c(1, 2, 2), times=3)] [1] &#34;A&#34; &#34;B&#34; &#34;B&#34; &#34;A&#34; &#34;B&#34; &#34;B&#34; &#34;A&#34; &#34;B&#34; &#34;B&#34; 負の数値からなる数値ベクトルを渡すと、その位置の要素を削除したベクトルを作成することができます。 次の例では、2 番目と、3 番目の要素を削除したベクトルを作成しています。 &gt; x &lt;- 1:5 &gt; x[c(-2, -3)] [1] 1 4 5 インデックスベクトルとして論理ベクトルを指定する 下記は、インデックスベクトルとして、論理ベクトルを指定する例です。 この仕組みを使うと、ベクトルから 条件に合致する要素だけを抽出する ことができます。 次の例では、数値ベクトルから偶数のみを取り出しています。 &gt; x &lt;- c(4, 7, 3, 2, 6) &gt; x[x%%2 == 0] [1] 4 2 6 内部的には x%%2==0 というところで、以下のような TRUE と FALSE から成る論理ベクトルを作成しています。 TRUE FALSE FALSE TRUE TRUE この論理ベクトルの中で、TRUE になっている位置（偶数）の要素を抽出していることになります。 ランダムな正規分布を生成する (rnorm) rnorm() を使用すると、指定した数のランダムな正規分布データを作成することができます。 x &lt;- rnorm(1000) hist(x, breaks=30) 標準偏差 (standard deviation) はデフォルトで 1 となりますが、sd パラメータで任意の標準偏差を指定することもできます。 x &lt;- rnorm(1000, sd=2) hist(x, breaks=30) データフレーム データフレームとは データフレームは、カラム名のあるレコードの集まりを表現します。 リレーショナル・データベースのレコードや、エクセルのシートのような表形式のデータを想像すると分かりやすいです。 R の起動時に、デフォルトで women というデータフレームが定義されているので、それを表示してみます（データ数が多いので head 関数を使って、表示数を減らしています） &gt; head(women) height weight 1 58 115 2 59 117 3 60 120 4 61 123 5 62 126 6 63 129 height と weight という名前のカラムが定義されていることがわかります。 左側の 1 から始まる数値は、データの行番号を示しています。 データフレームから特定のカラムを抽出する 下記のようにすると、データフレーム内の特定のカラムのみをベクトルデータとして取得することができます。 カラムのインデックス（1 から始まる）あるいは、カラム名で指定することができます。 インデックスを囲む括弧 (bracket) が 2 重になっていることに注意してください。 カラムを抽出（ベクトルとして取得） &gt; women[[1]] [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 &gt; women[[&#34;height&#34;]] [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 &gt; women$height [1] 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 次の例では別の形式でカラムを指定していますが、このようにすると、指定したカラムのデータがベクトルではなくデータフレームとして返されます。 つまり、データフレームのサブセットを作成していることになります。 c() を使用して、カラムを複数指定することも可能です。 カラムを抽出（データフレームとして取得） &gt; women[1] height 1 58 2 59 3 60 ... &gt; women[c(1, 2)] height weight 1 58 115 2 59 117 3 60 120 ... &gt; women[&#34;height&#34;] height 1 58 2 59 3 60 ... &gt; women[c(&#34;height&#34;, &#34;weight&#34;)] height weight 1 58 115 2 59 117 3 60 120 ... ベクトルからデータフレームを作成する (data.frame) data.frame 関数を使うと、ベクトルデータからデータフレームを作成することができます。 下記の例では、name と price というベクトルデータからデータフレームを作成しています。 &gt; name &lt;- c(&#34;apple&#34;, &#34;banana&#34;, &#34;strawberry&#34;) &gt; price &lt;- c(200, 100, 300) &gt; df &lt;- data.frame(name, price) &gt; df name price 1 apple 200 2 banana 100 3 strawberry 300 デフォルトでは、パラメータとして渡したオブジェクト名が、そのままデータフレームのカラム名になります。 名前付きパラメータとして渡すことで、任意のカラム名に変更することができます。 &gt; df &lt;- data.frame(n=name, p=price) &gt; df n p 1 apple 200 2 banana 100 3 strawberry 300 その他 標準で利用可能な標準データセット一覧を表示する (data) &gt; data() 実行結果 Data sets in package &#39;datasets&#39;: AirPassengers Monthly Airline Passenger Numbers 1949-1960 BJsales Sales Data with Leading Indicator BJsales.lead (BJsales) Sales Data with Leading Indicator BOD Biochemical Oxygen Demand CO2 Carbon Dioxide Uptake in Grass Plants ChickWeight Weight versus age of chicks on different diets DNase Elisa assay of DNase EuStockMarkets Daily Closing Prices of Major European Stock Indices, 1991-1998 Formaldehyde Determination of Formaldehyde HairEyeColor Hair and Eye Color of Statistics Students Harman23.cor Harman Example 2.3 Harman74.cor Harman Example 7.4 Indometh Pharmacokinetics of Indomethacin InsectSprays Effectiveness of Insect Sprays JohnsonJohnson Quarterly Earnings per Johnson &amp; Johnson Share LakeHuron Level of Lake Huron 1875-1972 LifeCycleSavings Intercountry Life-Cycle Savings Data Loblolly Growth of Loblolly pine trees Nile Flow of the River Nile Orange Growth of Orange Trees OrchardSprays Potency of Orchard Sprays PlantGrowth Results from an Experiment on Plant Growth Puromycin Reaction Velocity of an Enzymatic Reaction Seatbelts Road Casualties in Great Britain 1969-84 Theoph Pharmacokinetics of Theophylline Titanic Survival of passengers on the Titanic ToothGrowth The Effect of Vitamin C on Tooth Growth in Guinea Pigs UCBAdmissions Student Admissions at UC Berkeley UKDriverDeaths Road Casualties in Great Britain 1969-84 UKgas UK Quarterly Gas Consumption USAccDeaths Accidental Deaths in the US 1973-1978 USArrests Violent Crime Rates by US State USJudgeRatings Lawyers&#39; Ratings of State Judges in the US Superior Court USPersonalExpenditure Personal Expenditure Data UScitiesD Distances Between European Cities and Between US Cities VADeaths Death Rates in Virginia (1940) WWWusage Internet Usage per Minute WorldPhones The World&#39;s Telephones ability.cov Ability and Intelligence Tests airmiles Passenger Miles on Commercial US Airlines, 1937-1960 airquality New York Air Quality Measurements anscombe Anscombe&#39;s Quartet of &#39;Identical&#39; Simple Linear Regressions attenu The Joyner-Boore Attenuation Data attitude The Chatterjee-Price Attitude Data austres Quarterly Time Series of the Number of Australian Residents beaver1 (beavers) Body Temperature Series of Two Beavers beaver2 (beavers) Body Temperature Series of Two Beavers cars Speed and Stopping Distances of Cars chickwts Chicken Weights by Feed Type co2 Mauna Loa Atmospheric CO2 Concentration crimtab Student&#39;s 3000 Criminals Data discoveries Yearly Numbers of Important Discoveries esoph Smoking, Alcohol and (O)esophageal Cancer euro Conversion Rates of Euro Currencies euro.cross (euro) Conversion Rates of Euro Currencies eurodist Distances Between European Cities and Between US Cities faithful Old Faithful Geyser Data fdeaths (UKLungDeaths) Monthly Deaths from Lung Diseases in the UK freeny Freeny&#39;s Revenue Data freeny.x (freeny) Freeny&#39;s Revenue Data freeny.y (freeny) Freeny&#39;s Revenue Data infert Infertility after Spontaneous and Induced Abortion iris Edgar Anderson&#39;s Iris Data iris3 Edgar Anderson&#39;s Iris Data islands Areas of the World&#39;s Major Landmasses ldeaths (UKLungDeaths) Monthly Deaths from Lung Diseases in the UK lh Luteinizing Hormone in Blood Samples longley Longley&#39;s Economic Regression Data lynx Annual Canadian Lynx trappings 1821-1934 mdeaths (UKLungDeaths) Monthly Deaths from Lung Diseases in the UK morley Michelson Speed of Light Data mtcars Motor Trend Car Road Tests nhtemp Average Yearly Temperatures in New Haven nottem Average Monthly Temperatures at Nottingham, 1920-1939 npk Classical N, P, K Factorial Experiment occupationalStatus Occupational Status of Fathers and their Sons precip Annual Precipitation in US Cities presidents Quarterly Approval Ratings of US Presidents pressure Vapor Pressure of Mercury as a Function of Temperature quakes Locations of Earthquakes off Fiji randu Random Numbers from Congruential Generator RANDU rivers Lengths of Major North American Rivers rock Measurements on Petroleum Rock Samples sleep Student&#39;s Sleep Data stack.loss (stackloss) Brownlee&#39;s Stack Loss Plant Data stack.x (stackloss) Brownlee&#39;s Stack Loss Plant Data stackloss Brownlee&#39;s Stack Loss Plant Data state.abb (state) US State Facts and Figures state.area (state) US State Facts and Figures state.center (state) US State Facts and Figures state.division (state) US State Facts and Figures state.name (state) US State Facts and Figures state.region (state) US State Facts and Figures state.x77 (state) US State Facts and Figures sunspot.month Monthly Sunspot Data, from 1749 to &#34;Present&#34; sunspot.year Yearly Sunspot Data, 1700-1988 sunspots Monthly Sunspot Numbers, 1749-1983 swiss Swiss Fertility and Socioeconomic Indicators (1888) Data treering Yearly Treering Data, -6000-1979 trees Diameter, Height and Volume for Black Cherry Trees uspop Populations Recorded by the US Census volcano Topographic Information on Auckland&#39;s Maunga Whau Volcano warpbreaks The Number of Breaks in Yarn during Weaving women Average Heights and Weights for American Women Use &#39;data(package = .packages(all.available = TRUE))&#39; to list the data sets in all *available* packages. データが正規分布に従っているかを調べる Shapiro-Wilk 検定 Shapiro-Wilk の検定は、データが正規分布に従っているかどうかを検定する統計検定の 1 つです。 R では shapiro.test() 関数を使用することで、Shapiro-Wilk の検定を行うことができます。 women データセットの weight カラムを検定 &gt; shapiro.test(women[[&#34;weight&#34;]]) Shapiro-Wilk normality test data: women[[&#34;weight&#34;]] W = 0.96036, p-value = 0.6986 trees データセットの Volume カラムを検定 &gt; shapiro.test(trees[[&#34;Volume&#34;]]) Shapiro-Wilk normality test data: trees[[&#34;Volume&#34;]] W = 0.88757, p-value = 0.003579 ☝️ p 値 p 値 (p-value) は、帰無仮説を棄却してしまう「タイプ 1 の誤り」の確率を示しています。 有意水準を 10% とした場合、p 値が 0.10 未満であれば帰無仮説「正規分布に従う」を棄却することができます。 つまり、tree データセットの Volume カラムは正規分布に従っていないと判断できます。 Shapiro-Wilk の検定以外にも、Q-Q プロット や ヒストグラム を使ってデータが正規分布に従っているかどうかを確認することができます。 Q-Q プロット Q-Q プロットは、データが正規分布に従っているかどうかを視覚的に確認するためのグラフです。 R では qqnorm() 関数を使用することで、Q-Q プロットを描画することができます。 &gt; qqnorm(trees[[&#34;Height&#34;]]) ヒストグラム ヒストグラムは、データの分布を視覚的に確認するためのグラフです。 R では hist() 関数を使用することで、ヒストグラムを描画することができます。 &gt; hist(trees[[&#34;Height&#34;]]) 自己相関関係（1 時点前のデータとの関連をプロットする） &gt; data &lt;- AirPassengers &gt; plot(x=data[1:99], y=data[2:100]) 時系列データの自己相関を調べる際に使用します。 データが左下から右上に向かって直線的に分布している場合、1 時点前のデータとの相関が高いことを示しています。 ここでは、1 時点前（ラグ＝1）のデータとの関連をプロットしていますが、2 時点前、3 時点前といった関連を調べることもできます。 x 軸にラグ、y 軸に自己相関係数の値をプロットした図を、コレログラム と呼びます。 R ではコレログラムを描画するための acf() 関数が用意されています (ACF: Auto-Correlation Function)。 &gt; acf(AirPassengers, plot=TRUE) 上記のように plot=TRUE（デフォルト）とするとコレログラムを描画し、plot=FALSE とすると自己相関係数の値のみを返します。 type=&quot;partial&quot; オプションを指定すると、y 軸の値を「偏自己相関係数」とすることができます (Partial ACF)。 &gt; acf(AirPassengers, plot=TRUE, type=&#34;partial&#34;)"}];function search(e){const t=searchData(e),n=createHtml(t);showResult(n),showResultCount(t.length,data.length)}function searchData(e){const t=[];if(e=e.trim(),e.length<1)return t;const n=new RegExp(e,"i");for(let s=0;s<data.length;++s){const o=data[s].body.search(n);o!=-1&&t.push([s,o,o+e.length])}return t}function createHtml(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n][0],o=e[n][1],i=e[n][2],a=data[s].url,r=data[s].title,c=data[s].body;t.push(createEntry(a,r,c,o,i))}return t.join("")}function createEntry(e,t,n,s,o){return'<div class="item"><a class="item_title" href="'+e+'">'+t+'</a><div class="item_excerpt">'+excerpt(n,s,o)+"</div></div>"}function excerpt(e,t,n){return[e.substring(t-30,t),"<b>",e.substring(t,n),"</b>",e.substring(n,n+200)].join("")}function showResult(e){const t=document.getElementById("result");t.innerHTML=e}function showResultCount(e,t){const n=document.getElementById("resultCount");n.innerHTML="<b>"+e+"</b> 件見つかりました（"+t+"件中）"}function searchWithHash(){const e=decodeURI(location.hash.substring(1));search(e);const t=document.getElementById("query");t.value!==e&&(t.value=e)}window.addEventListener("DOMContentLoaded",searchWithHash),window.addEventListener("hashchange",searchWithHash),window.addEventListener("load",()=>{const e=document.getElementById("query");e.focus()})</script><script>const SIDEBAR_HIDE_THRESHOLD=800,SIDEBAR_WIDTH=250,OFFSET=10;let w=window.innerWidth;w>=SIDEBAR_HIDE_THRESHOLD&&(w-=SIDEBAR_WIDTH),w-=OFFSET,w>=728?rakuten_size="728x200":w>=600?rakuten_size="600x200":w>=468?rakuten_size="468x160":w>=336?rakuten_size="336x280":w>=300?rakuten_size="300x250":w>=250?rakuten_size="250x250":rakuten_size="200x350",rakuten_design="slide",rakuten_affiliateId="1239b074.74af6526.1239b075.bc72ef6e",rakuten_items="ctsmatch",rakuten_genreId=0,rakuten_target="_blank",rakuten_theme="gray",rakuten_border="off",rakuten_auto_mode="on",rakuten_genre_title="off",rakuten_recommend="on",rakuten_txtColor="333333",rakuten_moverColor="30C030",rakuten_bgColor="FFFFFF",rakuten_captionColor="333333"</script><script src=https://xml.affiliate.rakuten.co.jp/widget/js/rakuten_widget.js></script></div><div class=l-withSidebar__sidebarRight><nav class=navigation><div class=navigation__header>カテゴリ一覧</div><ul><li><a class=navigation__item href=https://maku77.github.io/memo/>いろいろ</a><li><a class=navigation__item href=https://maku77.github.io/android/>Android</a><li><a class=navigation__item href=https://maku.blog/p/8t6hr3d/>Ansible</a><li><a class=navigation__item href=https://maku77.github.io/blender/>Blender</a><li><a class=navigation__item href=https://maku77.github.io/cpp/>C/C++</a><li><a class=navigation__item href=https://maku77.github.io/docker/>Docker</a><li><a class=navigation__item href=https://maku77.github.io/git/>Git</a><li><a class=navigation__item href=https://maku77.github.io/go/>Go言語</a><li><a class=navigation__item href=https://maku77.github.io/gradle/>Gradle</a><li><a class=navigation__item href=https://maku77.github.io/web/>HTML/CSS</a><li><a class=navigation__item href=https://maku77.github.io/hugo/>Hugo</a><li><a class=navigation__item href=https://maku77.github.io/java/>Java</a><li><a class=navigation__item href=https://maku77.github.io/js/>JavaScript</a><li><a class=navigation__item href=https://maku77.github.io/kotlin/>Kotlin</a><li><a class=navigation__item href=https://maku77.github.io/linux/>Linux/Shell</a><li><a class=navigation__item href=https://maku.blog/p/somcgdw/>Mac</a><li><a class=navigation__item href=https://maku77.github.io/middleman/>Middleman</a><li><a class=navigation__item href=https://toushi.maku.blog/p/etedykx/>MetaTrader</a><li><a class=navigation__item href=https://maku77.github.io/nodejs/>Node.js</a><li><a class=navigation__item href=https://maku77.github.io/octave/>Octave</a><li><a class=navigation__item href=https://maku77.github.io/p4/>Perforce</a><li><a class=navigation__item href=https://maku77.github.io/perl/>Perl</a><li><a class=navigation__item href=https://maku77.github.io/php/>PHP</a><li><a class=navigation__item href=https://maku77.github.io/python/>Python</a><li><a class=navigation__item href=https://maku77.github.io/r/>R</a><li><a class=navigation__item href=https://maku77.github.io/ruby/>Ruby</a><li><a class=navigation__item href=https://maku77.github.io/rust/>Rust</a><li><a class=navigation__item href=https://maku77.github.io/sass/>Sass</a><li><a class=navigation__item href=https://maku77.github.io/sed/>sed/awk</a><li><a class=navigation__item href=https://maku77.github.io/sql/>SQL</a><li><a class=navigation__item href=https://maku77.github.io/tradestation/>トレードステーション</a><li><a class=navigation__item href=https://maku77.github.io/vagrant/>Vagrant</a><li><a class=navigation__item href=https://maku77.github.io/vba/>VBA</a><li><a class=navigation__item href=https://maku77.github.io/vim/>Vim</a><li><a class=navigation__item href=https://maku77.github.io/windows/>Windows</a></ul></nav><style>.codoc-support{display:inline-block;margin:0!important;padding:12px!important;width:200px!important;max-width:100%}.codoc-support .codoc-support-title{font-size:smaller!important;white-space:nowrap;margin-bottom:12px!important}.codoc-support .codoc-btn{width:160px!important}</style><script src=https://codoc.jp/js/cms.js data-css=black data-usercode=tp6ZPzTj3w defer></script><div id=codoc-entry-4gYwTntzzw class=codoc-entries data-without-body=1 data-support-button-text="（っ'-')╮シュッ🔴" data-show-like=0 data-show-about-codoc=0 data-show-powered-by=0 data-support-message=まくに投げ銭できます。></div></div></div><script>document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll("a[href^=http]");for(let n=0;n<e.length;++n){const t=e[n];if(t.href.startsWith("https://maku77.github.io"))continue;const s=t.getElementsByTagName("img");if(s.length>0)continue;const o=t.getElementsByTagName("svg");if(o.length>0)continue;t.classList.add("xExternalLinkIcon"),t.setAttribute("target","_blank"),t.setAttribute("rel","noopener")}})</script></body></html>