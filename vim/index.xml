<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Vim on 天才まくまくノート</title><link>https://maku77.github.io/vim/</link><description>Recent content in Vim on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 29 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/vim/index.xml" rel="self" type="application/rss+xml"/><item><title>Neovim の設定ファイル (init.lua) を GitHub や Dropbox で管理する</title><link>https://maku77.github.io/p/pzakg36/</link><pubDate>Wed, 29 Oct 2025 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pzakg36/</guid><description>Neovim の設定は ~/.config/nvim/init.lua ファイルに記述しますが、複数の PC で同じ設定を使いたい場合は、GitHub や Dropbox などのクラウドストレージを利用して設定ファイルを共有すると便利です。 ここでは、下記の 2 つの方法を紹介します。
シンボリックリンク／ジャンクションを使う方法 Neovim のランタイムパスを追加する方法 共有する設定ファイルは、下記のようなディレクトリ構造で Git 管理されているとします。
~/gitwork/nvim-config/ ├── .git/ ├── init.lua └── lua/ ├── options.lua ├── keymaps.lua └── ... シンボリックリンク／ジャンクションを使う方法 特に問題がなければこの方法を使うのが簡単です。 Linux や macOS ではシンボリックリンク、Windows ではジャンクションの機能を使って、Neovim の設定ディレクトリ (~/.config/nvim) の実体を、GitHub や Dropbox で管理されているディレクトリに結び付けるだけです。 Neovim の設定ディレクトリのパスは、OS ごとに異なることに注意してください。
Linux/macOS: ~/.config/nvim Windows: %LOCALAPPDATA%\nvim （通常は C:\Users\&amp;lt;ユーザー名&amp;gt;\AppData\Local\nvim） まず、Neovim の設定ディレクトリ (~/.config/nvim) の中身を Git 管理された共有ディレクトリに移動して、元の ~/.config/nvim ディレクトリは削除しておきます。 その後、次のようにシンボリックリンク／ジャンクションとして ~/.config/nvim を作り直します。
Linux/macOS の場合 ─ シンボリックリンクの作成 ln -s ~/gitwork/nvim-config ~/.</description></item><item><title>Neovim を manpager として使用する（man ページを Neovim で表示する）</title><link>https://maku77.github.io/p/hfwenni/</link><pubDate>Tue, 23 Sep 2025 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hfwenni/</guid><description>Neovim で man ページで開く Neovim は標準でファイルタイププラグインとして :Man を提供しており、man ページを Neovim 内で表示することができます。
Neovim 上で man ページを開く :Man {キーワード} 次のように MANPAGER 環境変数を設定しておくと、ターミナルから man コマンドを実行したときに、Neovim で開いてくれるようになります。
~/.zshrc など export MANPAGER=&amp;#34;nvim +Man!&amp;#34; :Man の操作方法 man ページを Neovim で開いた後の操作方法は、less ベースの操作方法と同様ですが、:Man ならではの操作方法もあります。 下記あたりを覚えておくと便利です。
gO &amp;hellip; 目次を開く（目次から Enter でジャンプできます） Shift-K / Ctrl-] &amp;hellip; カーソル下のキーワードの man ページへジャンプ Ctrl-O &amp;hellip; ジャンプ前の位置に戻る</description></item><item><title>Vim のインサートモードを抜けるときに自動で IME をオフにする (macOS, Karabiner-Elements)</title><link>https://maku77.github.io/p/bbkb63f/</link><pubDate>Tue, 06 May 2025 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bbkb63f/</guid><description>何をするか？ Karabiner-Elements は、macOS 用のキーボードカスタマイズツールです。 ここでは、Vim のインサートモードを抜けるときに IME を自動でオフにするための、Karabiner-Elements の設定を紹介します。
Karabiner-Elements の設定 設定方法 Karabiner-Elements のメニューから、
Complex Modifications ⇨ Add your own rules を選択し、下記の JSON を貼り付ければ設定完了です。
vim-auto-ime-off.json { &amp;#34;description&amp;#34;: &amp;#34;Vim - Auto IME Off&amp;#34;, &amp;#34;manipulators&amp;#34;: [ { &amp;#34;from&amp;#34;: { &amp;#34;key_code&amp;#34;: &amp;#34;escape&amp;#34; }, &amp;#34;to&amp;#34;: [ { &amp;#34;key_code&amp;#34;: &amp;#34;japanese_eisuu&amp;#34; }, { &amp;#34;key_code&amp;#34;: &amp;#34;escape&amp;#34; } ], &amp;#34;type&amp;#34;: &amp;#34;basic&amp;#34; }, { &amp;#34;from&amp;#34;: { &amp;#34;key_code&amp;#34;: &amp;#34;open_bracket&amp;#34;, &amp;#34;modifiers&amp;#34;: { &amp;#34;mandatory&amp;#34;: [&amp;#34;left_control&amp;#34;] } }, &amp;#34;to&amp;#34;: [ { &amp;#34;key_code&amp;#34;: &amp;#34;japanese_eisuu&amp;#34; }, { &amp;#34;key_code&amp;#34;: &amp;#34;escape&amp;#34; } ], &amp;#34;type&amp;#34;: &amp;#34;basic&amp;#34; }, { &amp;#34;from&amp;#34;: { &amp;#34;key_code&amp;#34;: &amp;#34;caps_lock&amp;#34;, &amp;#34;modifiers&amp;#34;: { &amp;#34;optional&amp;#34;: [&amp;#34;any&amp;#34;] } }, &amp;#34;to&amp;#34;: [ { &amp;#34;set_variable&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;caps_lock_pressed&amp;#34;, &amp;#34;value&amp;#34;: 1 } }, { &amp;#34;key_code&amp;#34;: &amp;#34;caps_lock&amp;#34;, &amp;#34;lazy&amp;#34;: true } ], &amp;#34;to_after_key_up&amp;#34;: [ { &amp;#34;set_variable&amp;#34;: { &amp;#34;name&amp;#34;: &amp;#34;caps_lock_pressed&amp;#34;, &amp;#34;value&amp;#34;: 0 } } ], &amp;#34;type&amp;#34;: &amp;#34;basic&amp;#34; }, { &amp;#34;conditions&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;caps_lock_pressed&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;variable_if&amp;#34;, &amp;#34;value&amp;#34;: 1 } ], &amp;#34;from&amp;#34;: { &amp;#34;key_code&amp;#34;: &amp;#34;open_bracket&amp;#34; }, &amp;#34;to&amp;#34;: [ { &amp;#34;key_code&amp;#34;: &amp;#34;japanese_eisuu&amp;#34; }, { &amp;#34;key_code&amp;#34;: &amp;#34;escape&amp;#34; } ], &amp;#34;type&amp;#34;: &amp;#34;basic&amp;#34; } ] } 解説 この設定では、下記のようなインサートモードを抜けるキー入力があった場合に、すべて 英数 → ESC と入力したかのように振る舞うようにしています。</description></item><item><title>Neovim カスタマイズのために Lua 言語をざっと理解する</title><link>https://maku77.github.io/p/d3exkpu/</link><pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/d3exkpu/</guid><description>Neovim を Lua スクリプトでカスタマイズできるようになるために、Lua 言語をざっと理解しておきます。
Lua スクリプトの実行方法 コマンドラインから実行する Neovim 自体が Lua の実行環境を備えているので、次のように nvim -l コマンドで Lua スクリプトを実行できます。
hello.lua print(&amp;#34;Hello, Lua!&amp;#34;) Lua スクリプトファイルを実行 $ nvim -l hello.lua Hello, Lua! 編集中のスクリプトを実行する Neovim で Lua スクリプトを編集しているときに、そのバッファの内容を実行する場合は次のようにします。
カレントバッファの内容を実行 :luafile % Neovim の設定ファイル (init.lua) で以下のような設定をしておけば、.lua ファイルを編集中に（ノーマルモードで） F5 キーを押すだけで実行できるようになります。
~/.config/nvim/init.lua --- .lua ファイルを編集中に &amp;lt;F5&amp;gt; キーで実行 vim.api.nvim_create_autocmd(&amp;#34;FileType&amp;#34;, { pattern = &amp;#34;lua&amp;#34;, callback = function() vim.keymap.set(&amp;#39;n&amp;#39;, &amp;#39;&amp;lt;F5&amp;gt;&amp;#39;, &amp;#39;&amp;lt;cmd&amp;gt;luafile %&amp;lt;CR&amp;gt;&amp;#39;, { buffer = true }) end }) VS Code で実行する Visual Studio Code で Lua スクリプトを編集する場合は、Code Runner 拡張 をインストールしておくと便利です。 Code Runner 拡張を使うと、各種言語のコードを編集中にショートカットキー (Ctrl+Alt+N) でそのコードを実行できるようになります（あるいはコマンドパレットから Run Code を実行）。 今回は Lua の実行環境として nvim -l コマンドを使うので、VS Code の設定ファイルで以下のように設定しておきます。</description></item><item><title>Neovim 用のプラグインマネージャー lazy.nvim をインストールする</title><link>https://maku77.github.io/p/cfc9tpn/</link><pubDate>Sun, 02 Mar 2025 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cfc9tpn/</guid><description>lazy.nvim は、Neovim 用のプラグインマネージャーです。 名前の通り、各種プラグインを必要に応じて遅延ロードしてくれるため、多くのプラグインを導入しても Neovim の起動があまり遅くならないという特徴があります。
lazy.nvim のインストール lazy.nvim は 公式サイトの Installation に記載されている手順に従ってインストールします。 まずは、Neovim の設定ファイルに以下のような行を追加します。
~/.config/nvim/init.lua require(&amp;#34;config.lazy&amp;#34;) この require により、~/.config/nvim/lua/config/lazy.lua というファイルが読み込まれるようになるので、lazy.nvim 関連の設定はこのファイルに記述していきます。 これは、公式サイトで Structured Setup として紹介されている方法です。
下記の設定も公式サイトに記述されている通りの初期設定ですが、このファイルを作成して Neovim を再起動すれば、lazy.nvim が自動的にインストールされます（内部で git コマンドを使ってダウンロードしています）。
~/.config/nvim/lua/config/lazy.lua -- Bootstrap lazy.nvim local lazypath = vim.fn.stdpath(&amp;#34;data&amp;#34;) .. &amp;#34;/lazy/lazy.nvim&amp;#34; if not (vim.uv or vim.loop).fs_stat(lazypath) then local lazyrepo = &amp;#34;https://github.com/folke/lazy.nvim.git&amp;#34; local out = vim.fn.system({ &amp;#34;git&amp;#34;, &amp;#34;clone&amp;#34;, &amp;#34;--filter=blob:none&amp;#34;, &amp;#34;--branch=stable&amp;#34;, lazyrepo, lazypath }) if vim.v.shell_error ~= 0 then vim.api.nvim_echo({ { &amp;#34;Failed to clone lazy.</description></item><item><title>Vim/Neovim で OS のクリップボードとヤンクレジスターを連動させる (clipboard)</title><link>https://maku77.github.io/p/nnhefs3/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nnhefs3/</guid><description>Vim/Neovim のデフォルト設定では、y でテキストをヤンク（コピー）したときに、OS のクリップボードにテキストの内容がコピーされません。 別のアプリ上で Ctrl+C でコピーした内容も、Vim の p でペーストすることができません。 これでは不便なので、多くの場合は次のように OS のクリップボードと連動させます。
Vim (~/.vimrc) や Neovim (init.vim) の場合 &amp;#34; OS のクリップボードと連動させる set clipboard+=unnamed,unnamedplus Neovim (init.lua) の場合 -- OS のクリップボードと連動させる vim.opt.clipboard:append({ &amp;#34;unnamed&amp;#34;, &amp;#34;unnamedplus&amp;#34; }) 細かい説明をすると、unnamed というフラグは * レジスターとの連動、unnamedplus というフラグは + レジスターとの連動を意味するのですが、通常は上記のように両方とも設定しておけば問題ありません。</description></item><item><title>Vim/Neovim の設定ファイルから別の設定ファイルを読み込む (source, dofile)</title><link>https://maku77.github.io/p/dnso7ds/</link><pubDate>Tue, 11 Jun 2024 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dnso7ds/</guid><description>複数の環境で Vim や Neovim を使用しているときは、設定ファイルを GitHub や Dropbox などの共有サービスで共有すると便利です。 共有した設定ファイルは、Vim の :source や Neovim (Lua) の :dofile() などで読み込むことができます。
Vim (~/.vimrc) の場合 &amp;#34; Linux/macOS の例 source $HOME/Dropbox/share/config/vim/vimrc &amp;#34; Windows の例 source D:/Dropbox/share/config/vim/vimrc Neovim (~/.config/nvim/init.lua) の場合 -- Linux/macOS の例 local home = os.getenv(&amp;#34;HOME&amp;#34;) dofile(home .. &amp;#34;/Dropbox/share/config/nvim/init.lua&amp;#34;) -- Windows の例 dofile(&amp;#34;D:/Dropbox/share/config/nvim/init.lua&amp;#34;)</description></item><item><title>Vim でウィンドウ（タブ）移動時にカレントディレクトリも自動で移動する (autochdir)</title><link>https://maku77.github.io/p/dpccbv7/</link><pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dpccbv7/</guid><description>カレントディレクトリとは Vim のカレントディレクトリは、Vim で最初に開いたファイルがあるディレクトリに設定されます。 カレントディレクトリは、例えば下記のようなコマンドを実行したときに、起点となるディレクトリとして参照されます。
:vim pattern **/*.txt などで複数ファイルを grep するとき :e sample.txt でファイルを開くとき :cd dirname でカレントディレクトリを移動するとき :terminal でターミナルを開くとき このカレントディレクトリは、:e や :tabnew コマンドで別のディレクトリにあるファイルを開いた場合も変化しません。 :vim (:vimgrep) コマンドでファイルを検索してもなぜかヒットしないというときは、カレントディレクトリが正しくセットされてない可能性があります。 カレントディレクトリは :pwd で確認することができます。
カレントディレクトリを変更する 手動で移動する 明示的にカレントディレクトリを設定するには :cd コマンドを使用します。
編集中のファイルがあるディレクトリへ移動する :cd %:h と実行すると、現在編集中のファイルがあるディレクトリ (%:h) へ移動することができます。 カレントウィンドウ（カーソルのあるウィンドウ）のみを対象にカレントディレクトリを移動したいときは、:cd の代わりに :lcd コマンドを使用します。
自動で移動する autochdir オプションをセットしておくと、新しくウィンドウを開いた時や、タブを切り替えたときなどに、そのファイルがあるディレクトリへ自動で移動してくれるようになります。
~/.vimrc &amp;#34; Change the current working directory automatically set autochdir Neovim の場合 (~/.config/nvim/init.lua) -- Change the current working directory automatically vim.opt.autochdir = true 現在の設定は :set autochdir?</description></item><item><title>Vim で &lt;Leader> キーを使ったキーコンビネーションを定義する (mapleader)</title><link>https://maku77.github.io/p/c9kmay4/</link><pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c9kmay4/</guid><description>Vim の Leader キー は、キーマッピングを定義するときに使用可能なプレフィックスキーです。
Leader キーとは 例えば、.vimrc で次のようなキーマップ設定があったとします。
.vimrc（Leader キーの使用例） nmap &amp;lt;Leader&amp;gt;a :echo &amp;#34;Hello&amp;#34;&amp;lt;CR&amp;gt; nmap &amp;lt;Leader&amp;gt;b :echo &amp;#34;World&amp;#34;&amp;lt;CR&amp;gt; これは、Leader キーに続けて a キーや b キーを入力することで、Hello や World と表示するキーコンビネーションを定義しています。 つまり、Leader キーはキーコンビネーションのためのプレフィックスキー です（実際には任意の位置で使えます）。
Leader キーには、デフォルトでバックスラッシュ (\) が割り当てられているため、上記の設定を行った場合は、\a と入力することで Hello と表示されることになります。 次のように直接バックスラッシュキー (&amp;lt;Bslash&amp;gt;) を使って定義するのとは何が違うのでしょうか？
.vimrc nmap &amp;lt;Bslash&amp;gt;a :echo &amp;#34;Hello&amp;#34;&amp;lt;CR&amp;gt; nmap &amp;lt;Bslash&amp;gt;b :echo &amp;#34;World&amp;#34;&amp;lt;CR&amp;gt; Leader キーを使ったキーマッピングには、次のような利点があります。
Leader キーは単なるプレフィックキーだということを強調できる（特に自分の .vimrc を公開するとき） Leader キーだけを変更したくなったときに、まとめて置き換えられる（Leader キーは任意のキーに設定できます） 他のユーザーの .vimrc 設定を使いまわしやすい（自分の好きな Leader キーで使える） Plugin の中でキーマッピングを定義するときに Leader キーを使うことで、ユーザーによるキー設定の余地を残す Leader キーを設定する (mapleader) Vim の場合 Leader キーを任意のキーに設定するには、次のように g:mapleader グローバル変数を設定します。 デフォルトではバックスラッシュキーが使用されますが、決して押しやすいキーではないので、スペースキーやカンマを Leader キーとして使用する人が多いようです。</description></item><item><title>Vim のキーマップ例: ショートカットキーでカレントディレクトリを Windows エクスプローラーや Mac の Finder で開く</title><link>https://maku77.github.io/p/tqmr4od/</link><pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tqmr4od/</guid><description>Vim/Neovim で次の設定を行っておくと、現在編集中のファイルが格納されたディレクトリをショートカットキー（ここでは F12 キー）一発で開くことができます。 Windows の場合は start コマンドを使って「エクスプローラー」を開き、Mac の場合は open コマンドを使って「Finder」を開くようにしています。
Neovim（Lua スクリプト）の場合 ~/.config/nvim/init.lua -- 編集中ファイルが格納されたディレクトリを開く関数 function open_current_dir() local command if vim.fn.has(&amp;#34;mac&amp;#34;) == 1 then command = &amp;#34;open&amp;#34; elseif vim.fn.has(&amp;#34;win32&amp;#34;) == 1 or vim.fn.has(&amp;#34;win64&amp;#34;) == 1 then command = &amp;#34;start&amp;#34; else print(&amp;#34;Could not open the directory (unsupported OS)&amp;#34;) return end local dir_path = vim.fn.expand(&amp;#34;%:p:h&amp;#34;) vim.fn.system(command .. &amp;#34; &amp;#34; .. dir_path) end -- F12 キーにマップする vim.keymap.set(&amp;#34;n&amp;#34;, &amp;#34;&amp;lt;F12&amp;gt;&amp;#34;, open_current_dir, { silent = true, desc = &amp;#34;Open current directory in file manager&amp;#34; }) Vim（Vim スクリプト）の場合 ~/.</description></item><item><title>Vim で 2 つのファイルの差分を取る・マージする (vimdiff, vim -d)</title><link>https://maku77.github.io/p/78gvwox/</link><pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/78gvwox/</guid><description>2 つのテキストファイルの差分を取る Vim（あるいは gVim）には、テキストファイルの差分を取る diff モード が付いています。
参考: diff - Vim日本語ドキュメント 参考: diff - Vim Documentation ハイライト表示された差分を確認しながらファイルを修正していくことができます。
Vim/gVim を diff モードで起動する (vimdiff/gvimdiff) コマンドラインから、Vim や gVim を diff モードを起動するには次のように vimdiff （あるいは gvimdiff） コマンドを実行します。 引数を増やせば、3 つ、あるいは 4 つのファイルを比較することも可能です。
vim の場合 vim -d ファイル1 ファイル2 vimdiff ファイル1 ファイル2 （vim -d のエイリアス） gvim の場合 gvim -d ファイル1 ファイル2 gvimdiff ファイル1 ファイル2 （gvim -d のエイリアス） 例えば、gVim 上で a.txt と b.txt を比較したいときは次のように gVim を起動します。
$ gvimdiff a.</description></item><item><title>Vim/Neovim でインサートモード中に Backspace キーや CTRL-W で文字を削除するときの振る舞いを変更する (backspace)</title><link>https://maku77.github.io/p/b9tsccu/</link><pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/b9tsccu/</guid><description>backspace オプション（Vim の場合） Vim エディタでは、インサートモード中に Backspace キーを押すと、入力した文字が削除されますが、デフォルトではインサートモードに入ったカーソル位置より前の文字を削除することはできません。 代表的な削除系のキー入力は、下記のような振る舞いをします。
Backspace: カーソル位置の直前の 1 文字を削除する。ただし、インサートモードに入ったときのカーソル位置までしか削除できない。 CTRL-W: カーソル位置の直前の 1 単語を削除する。ただし、インサートモードに入ったときのカーソル位置までしか削除できない。 CTRL-U: カーソル位置からインサートモードに入ったときのカーソル位置までを削除する。 backspace オプションを設定すると、上記のようなキー入力によって削除可能な文字の範囲を広げることができます。 backspace オプションには次のような値をカンマ区切りで設定します。
indent: オートインデント機能で挿入されたスペースを削除できる eol: 改行を削除できる（前の行に遡って削除していける） start: インサートモードに入ったときのカーソル位置よりも前の文字を削除できる（ただし、CTRL-W や CTRL-U による削除は、インサートモードに入ったカーソル位置までで削除範囲が一度止まる） 設定例 (~/.vimrc) &amp;#34; インサートモード中の BS、CTRL-W、CTRL-U による文字削除を柔軟にする set backspace=indent,eol,start 上記のように設定しておくと、それぞれの削除系のキー入力の振る舞いは下記のように変化します。
Backsapce: カーソル位置の直前の 1 文字を削除する。インサートモードに入った時のカーソル位置よりも前の文字を削除できる。 CTRL-W: カーソル位置の直前の 1 単語を削除する。インサートモードに入った時のカーソル位置よりも前の単語を削除できる。ただし、インサートモードに入った時のカーソル位置も単語の境界とみなす。 CTRL-U: カーソル位置から行頭までを削除する。ただし、インサートモードに入ったときのカーソル位置も行頭とみなす。 backspace オプション (Neovim の場合） Neovim の場合は、backspace オプションの設定値が デフォルトで indent,eol,start となっているため、何も設定しなくても Backspace キーが直感的に振る舞います（編集開始位置よりも前の文字を削除できます）。</description></item><item><title>Vim で行末の余分なスペースをまとめて削除する</title><link>https://maku77.github.io/p/pdvgf4v/</link><pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pdvgf4v/</guid><description>ノーマルモードから下記のように実行すると、行末にある余計なスペースをまとめて削除することができます。
:%s/\s*$// 各項目の意味 % &amp;ndash; すべての行を変更対象にする \s* &amp;ndash; 0個以上のスペース（半角スペースやタブ） $ &amp;ndash; 行末 ここでは、% を指定してすべての行を対象にしていますが、SHIFT-V のビジュアルモードで行を選択してから :s/\s*$// と入力すれば、選択した行のみを対象にでききます。</description></item><item><title>Vim で上の行の文字、下の行の文字をコピーする (CTRL-Y, CTRL-E)</title><link>https://maku77.github.io/p/4xbztoe/</link><pubDate>Wed, 31 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4xbztoe/</guid><description> インサートモードで下記のようなキー入力を行うと、カーソルのすぐ上の行の文字や、すぐ下の行の文字をコピーする形でカーソル位置に挿入できます。 テキストの一部だけが異なる文章を挿入したいときなどに便利です。
CTRL-Y: カーソル位置の上の行の文字をコピーして挿入 CTRL-E: カーソル位置の下の行の文字をコピーして挿入</description></item><item><title>Vim でプログラムの関数定義などにジャンプする（tags ファイルの利用）</title><link>https://maku77.github.io/p/qt8z5d3/</link><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qt8z5d3/</guid><description>Universal Ctags コマンドのインストール タグジャンプ系の機能を使用するには、あらかじめ検索対象のソースコードから tags ファイルを生成しておく必要があります。 tags ファイルを作成するには、外部コマンドの ctags を使用するのですが、このコマンドは下記の Universal Ctags で提供されているものを使用するのがよいでしょう。
Universal Ctags 各OS用のインストールパッケージ Windows であれば、ダウンロードしたアーカイブに含まれている ctags.exe をパスの通ったディレクトリに配置するだけでインストールは完了です。
昔は exhuberant ctags で提供されている ctags が主流でしたが、現在はメンテナンスされておらず、新しい言語にも対応していないので、そこから fork されたプロジェクトである Universal Ctags の方を使うことをオススメします。
Univasal Ctags でサポートしている言語は、下記のようにして確認することができます。
$ ctags --list-languages tags ファイルを作成する tags ファイルを作成するには、検索したいソースコードファイルのあるディレクトリで ctags コマンドを実行します。 ディレクトリを再帰的に走査するには -R (--recurse) オプションを付けて実行してください。
$ ctags -R ある言語のファイル群だけ（例えば .java だけ）を対象にしたいときは、--languages オプションを使用して以下のように実行します。
$ ctags -R --language=Java 指定するのは拡張子ではなく、言語名であることに注意してください（ctags --list-languages で表示される言語名から選択）。 複数の言語を指定することも可能です。
$ ctags -R --languages=Java,C,C++,Make,Python,Ruby しばらく待って、カレントディレクトリに tags ファイルが生成されれば成功です。
どの拡張子のファイルが検索対象になるか どのような言語名でどの拡張子のファイルが走査対象になるかは、--list-maps オプションで確認することができます（指定するときは大文字と小文字の違いは気にしなくてよいようです）。</description></item><item><title>Vim で現在のキーマップの一覧を表示する (map)</title><link>https://maku77.github.io/p/7uxykzp/</link><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7uxykzp/</guid><description>参考: Vim のキーマップの基本 (map, noremap) ユーザ定義のキーマップを確認する Vim でユーザが定義しているキーマップの一覧を表示するには、下記のように map 系のコマンドをパラメータなしで実行します。
キーマップの一覧を表示 :map &amp;#34; ノーマルモードとビジュアルモードのキーマップ :nmap &amp;#34; ノーマルモードのキーマップ :vmap &amp;#34; ビジュアルモードのキーマップ :imap &amp;#34; インサートモードのキーマップ :cmap &amp;#34; コマンドラインモードのキーマップ :map! &amp;#34; インサートモードとコマンドラインモードのキーマップ また、次のように verbose コマンド（省略形は verb）と組み合わせて使用すると、そのキーマップがどの設定ファイルで定義されているかを確認することができます。
キーマップの一覧と定義元のファイルを表示 :verbose map :verbose nmap :verbose vmap :verbose imap :verbose cmap :verbose map! デフォルトのキーマップを確認する Vim がデフォルト定義しているキーマップの一覧は、下記のヘルプファイルで参照することができます。
:help index.txt :help index 例えば、インサートモード時の Ctrl-H がどのようなマッピングになっているかは、i_CTRL-H という項目に記述されています（same as &amp;lt;BS&amp;gt; と書かれているので、BackSpace キーと同様の振る舞いをします）。
初めからどのモードのキーマッピングを調べたいかが決まっているときは、上記のようにヘルプを起動する代わりに、下記のように起動するとそのセクションから読み始めることができます。
:help normal-index &amp;#34; ノーマルモードのデフォルトマッピングを表示 :help visual-index &amp;#34; ビジュアルモードのデフォルトマッピングを表示 :help insert-index &amp;#34; インサートモードのデフォルトマッピングを表示 もっと具体的に、調べたいキーコンビネーションが決まっている場合は、そのキーに対応するヘルプを直接開くことができます。</description></item><item><title>Vim でカレントディレクトリを Windows エクスプローラーで開く</title><link>https://maku77.github.io/p/s8wxbon/</link><pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s8wxbon/</guid><description>Vim で任意のファイルを開いているときに、下記のように入力すると、そのファイルのあるディレクトリを Windows エクスプローラーで開くことができます。
:silent ! start %:h 使用頻度が高ければ、下記のようにキーマッピングしておけば、F12 キーを押すだけで Windows エクスプローラーを開くことができるようになります。
~/.vimrc nmap &amp;lt;F12&amp;gt; :silent ! start %:h&amp;lt;CR&amp;gt;</description></item><item><title>Vim で行を連結する (J, gJ)</title><link>https://maku77.github.io/p/etgm2a4/</link><pubDate>Thu, 20 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/etgm2a4/</guid><description>スペースを入れて行連結、スペース入れずに行連結 行末の改行を削除して次の行と連結するには下記のコマンドを使用します。
J: スペースを1文字いれて連結する。 gJ: スペースを入れずに連結する。 複数行をまとめて連結する ビジュアルモード (SHIFT-V) で複数行を選択してから J や gJ と入力すると、複数の行をまとめて連結することができます。
3行以上の行をスペースを入れずに連結したい場合は、上図のようにビジュアルモードで複数行を選択した状態で gJ とするか、一行だけ gJ で連結しておいて、残りの行を . の連打で連結するのがお手軽です。
文章の終わりはスペース 2 つで連結される J による行の連結部分には、通常 1 つの半角スペースが挿入されますが、行末が句点（.、 ?、!）で終了している場合は 2 つの半角スペースが挿入されます。 この振る舞いを変更するには、以下のオプションを設定します。
:set joinspaces &amp;#34;行連結時に句点のあとに 2 つのスペースを挿入 (default) :set nojoinspaces &amp;#34;行連結時に句点のあとに 1 つのスペースを挿入</description></item><item><title>Vim のサイレントバッチモードで ex スクリプトをファイルに適用する (-es)</title><link>https://maku77.github.io/p/q7eoz2z/</link><pubDate>Tue, 18 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q7eoz2z/</guid><description>vim (gvim) コマンドを起動するときに、-es オプションを使用すると、サイレントバッチモードで起動し、任意の ex スクリプトを指定したファイルに適用することができます。
例えば、下記のスクリプトは AAA という文字を XXX に置換して保存するだけの簡単な ex スクリプトです。
replace.vim :%s/AAA/XXX/g :wq このスクリプトを任意のテキストファイル (ここでは input.txt) に適用するには、下記のように実行します。
$ gvim -es -S replace.vim input.txt 例えば、入力したファイルの内容が下記のような内容だとすると、
input.txt AAA BBB AAA BBB BBB AAA BBB AAA AAA BBB AAA BBB 次のように変更されます。
input.txt（変更後） XXX BBB XXX BBB BBB XXX BBB XXX XXX BBB XXX BBB 指定したファイル自体の内容が変更されることに注意してください。 ex スクリプトの中で wq を実行しているため、上書き保存して終了するところまでがワンセットで実行されます。
-eq オプションの代わりに、-c オプションを使用すると、コマンドラインで直接 ex コマンドを指定して実行することができます。
$ gvim -c &amp;#34;%s/AAA/XXX/g&amp;#34; -c &amp;#34;wq&amp;#34; input.</description></item><item><title>Vim で複数行の行頭に同じテキストを挿入する</title><link>https://maku77.github.io/p/mp48ku2/</link><pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mp48ku2/</guid><description>すべての行の行頭にテキストを追加 すべての行の行頭にスペース4文字を挿入したいときは、次のように置換コマンドを実行します。
:%s/^/ / % はすべての行に対して置換を実行することを表します。 ^ は行頭を表す記号です。
選択範囲の行の行頭にテキストを追加 特定範囲の行の行頭だけに、文字を挿入したいときは次のようにします。
0 で行頭にフォーカスを移動する。 Ctrl-v で矩形選択モードにし、j を数回押して、対象範囲の行の行頭がすべて選択された状態にする。 Shift-i で行頭への挿入モードに入り、任意の文字を入力。 Esc で挿入モードを抜ける。 文字の入力中は、カレント行にしか文字が挿入されていないかのように見えますが、最後に Esc キーで挿入モードを抜けたときに、すべての行に同じ文字が挿入されます。
ソースコードの複数行をまとめてコメントアウトしたり、（上記アニメーションのように）Markdown 内のテキストをまとめて箇条書きにしたりするときに便利できます。</description></item><item><title>Vim で編集中のスクリプト（Ruby や Python など）をショートカットキーで実行する</title><link>https://maku77.github.io/p/nwqjyx8/</link><pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nwqjyx8/</guid><description>Vim の :autocmd コマンドを使用すると、編集中のファイルの種類に応じた設定を行うことができます。
参考: autocmd で自動コマンドを登録する これと :map コマンドを組み合わせて使用することで、単一のショートカットキー（例えば F5 キー）で編集中のスクリプトを、適切な処理系（python コマンドなど）で実行することができるようになります。 競技プログラミングなどでは、現在編集中のソースコードをさくっとコンパイルして、main 関数の実行結果をさくっと表示できると便利です。
.vimrc（Windows の場合は _vimrc） &amp;#34; File type detection is On. filetype on augroup vimrc &amp;#34; Remove all autocommands in this group autocmd! &amp;#34; &amp;lt;F5&amp;gt; key execution autocmd FileType java nmap &amp;lt;buffer&amp;gt; &amp;lt;F5&amp;gt; :!javac -encoding UTF-8 % &amp;amp;&amp;amp; java %&amp;lt;&amp;lt;CR&amp;gt; autocmd FileType javascript nmap &amp;lt;buffer&amp;gt; &amp;lt;F5&amp;gt; :!node %&amp;lt;CR&amp;gt; autocmd FileType php nmap &amp;lt;buffer&amp;gt; &amp;lt;F5&amp;gt; :!php %&amp;lt;CR&amp;gt; autocmd FileType python nmap &amp;lt;buffer&amp;gt; &amp;lt;F5&amp;gt; :!</description></item><item><title>Vim の autocmd で自動コマンドを登録する</title><link>https://maku77.github.io/p/rj6oatw/</link><pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rj6oatw/</guid><description>autocmd の概要 Vim の autocmd コマンドを使って自動コマンドを登録しておくと、ファイルのオープン時、保存時、カーソル移動時など、様々なタイミングで任意の処理を行えるようになります。 例えば、下記のようなことが行えます。
プログラミング言語のソースコードを開いたときに、言語に応じてインデントを設定する 圧縮されたテキストファイルを開いたときに、自動的に解凍してテキストを編集できるようにする（保存するときに再び自動で圧縮する） ノーマルモードに戻った時に、IME（日本語入力モード）をオフにする 日記ファイルを開いたときに自動で本日の日付を挿入する ファイルの種類によって異なる種類のキーワードハイライト設定を有効にする 下記は具体的な autocmd コマンドの使い方のサンプルです。
例: .txt ファイルを編集するときはタブキー入力をスペースに展開する :autocmd BufEnter *.txt setlocal expandtab autocmd コマンドに関する詳細なドキュメントは、Vim から :help autocmd.txt と入力して参照することができます。 下記サイトでも同じ内容のドキュメントを読むことができます。
autocmd - Vim Documentation（日本語） autocmd - Vim Documentation（英語） autocmd は構文が若干複雑なのでとっつきにくいのですが、使いこなせると非常に便利なので、是非ここで使い方をマスターしましょう。
autocmd で自動コマンドを設定する :autocmd ＜イベント＞ ＜ファイルパターン＞ ＜実行コマンド＞ という形式で :autocmd を実行すると、＜ファイルパターン＞ に一致するファイルにおいて、＜イベント＞ が発生したときに、＜実行コマンド＞ が実行されるようになります。
例: .html ファイルを読み込んだときに（この設定ファイルと）同じディレクトリにある html.vim を実行する :autocmd BufNewFile,BufRead *.html source &amp;lt;sfile&amp;gt;:h/html.vim 上記では、分かりやすくするために、＜イベント＞、＜ファイルパターン＞、＜実行コマンド＞ を 2 文字分のスペースで区切っています。
イベント ＜イベント＞ の部分に指定できるイベント名は、下記のヘルプに一覧があります。
autocmd-events - Vim Documentation イベント名はヘルプファイル上では CamelCase の形式で記載されていますが、イベント名の大文字と小文字の違いは無視されます。 複数のイベントに対して同じ自動コマンドを登録したいときは、イベント名をカンマで並べて指定することができます。 ただし、カンマの前後にスペースを入れてはいけないことに注意してください（例: BufNewFile,BufRead）。 BufNewFile イベントは新しいファイルを作成するときに発生し、BufRead インベントは既存のファイルを読み込んだときに発生します。</description></item><item><title>Vim で空行（改行だけの行）を削除する</title><link>https://maku77.github.io/p/6idyjje/</link><pubDate>Tue, 20 Jan 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6idyjje/</guid><description>編集中のファイル全体の空行を削除する ノーマルモードで下記の ex コマンドを実行すれば、現在編集中のファイル内の、改行のみの行をすべて削除することができます。
:%s/^\n// 指定した範囲の空行を削除する Shift-V でビジュアルモードに入る j および k キーで行の範囲を指定 :s/^\n// と入力して Enter</description></item><item><title>Vim で行をソートして重複行を削除する (:sort u)</title><link>https://maku77.github.io/p/ybvwp6b/</link><pubDate>Fri, 21 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ybvwp6b/</guid><description>ビジュアルモード (SHIFT-V) で対象範囲を選択し、下記のように実行すれば、指定した範囲の行をソートすることができます。
:sort &amp;#34;アルファベット順ソート :sort n &amp;#34;10進数とみなしてソート さらに、sort を実行するときに u オプション（unique の略）を付けることで、重複している行を一行にまとめることができます。
:sort u ファイル全体に対して実行したい場合は、下記のように % でファイル全体の行を指定すれば OK です。
:%sort u</description></item><item><title>Vim で大文字と小文字を変換する</title><link>https://maku77.github.io/p/iin6vwz/</link><pubDate>Tue, 18 Nov 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/iin6vwz/</guid><description>Vim では U や u と入力するだけで、テキストの大文字と小文字を変換することができます。
ビジュアルモードでの操作 U &amp;hellip; 選択した範囲を大文字に変換 u &amp;hellip; 選択した範囲を小文字に変換 ~ &amp;hellip; 選択した範囲の大文字と小文字を入れ替え 例えば、Shift-V で、行を選択しておいて U と入力すれば、その行全体のアルファベットを大文字にすることができます。
ノーマルモードでの操作 gUU / guu &amp;hellip; カーソル行すべての文字を大文字／小文字に変換する gUiw / guiw &amp;hellip; カーソル位置の単語を大文字／小文字に変換 ~ &amp;hellip; カーソル位置の一文字の大文字／小文字を反転させる g~~ &amp;hellip; カーソル行すべての文字の大文字／小文字を反転させる 若干難しい組み合わせのように見えますが、ノーマルモードでは、gU や gu の後に置換範囲を入力することで、その範囲を大文字、小文字に変換することができます。
例えば、置換範囲として iw を入力すると (guiw)、カーソル下の単語を変換対象とすることができます。 置換範囲として移動コマンドを入力することもできるため、例えば gu$ と入力すれば、カーソル位置から行末 ($) までを小文字に変換することができます。
ただし、どちらかというと、大文字と小文字の置換は、ビジュアルモードで範囲選択を行ってから u や U と入力する方がわかりやすいです（しかもタイプ数はほぼ同じ）。 例えば、カーソル下の単語を大文字に変換するには、viw で単語選択してから、U と入力すれば OK です。</description></item><item><title>Vim でXML/HTML の編集に便利なコマンド</title><link>https://maku77.github.io/p/sznjxob/</link><pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sznjxob/</guid><description>XML や HTML ファイルを編集しているときは、c（置換）や、d（削除）コマンドの後ろに編集範囲を表す it や at を指定することで、素早い編集が可能になります。 下記は、置換コマンド c を実行するときに、様々な修正範囲を指定する例です。
コマンド 操作内容 修正前 修正後 cit 要素の内側を置換 &amp;lt;b&amp;gt;XXX&amp;lt;/b&amp;gt; &amp;lt;b&amp;gt;編集箇所&amp;lt;/b&amp;gt; cat 要素の全体を置換 &amp;lt;b&amp;gt;XXX&amp;lt;/b&amp;gt; 編集箇所 ci&amp;lt; タグの内側を置換 &amp;lt;b&amp;gt;XXX&amp;lt;/b&amp;gt; &amp;lt;編集箇所&amp;gt;XXX&amp;lt;/b&amp;gt; ca&amp;lt; タグの全体を置換 &amp;lt;b&amp;gt;XXX&amp;lt;/b&amp;gt; 編集箇所XXX&amp;lt;/b&amp;gt; ci&amp;quot; 属性の内側を置換 &amp;lt;div style=&amp;quot;XXX&amp;quot;&amp;gt; &amp;lt;div style=&amp;quot;編集箇所&amp;quot;&amp;gt; ca&amp;quot; 属性の全体を置換 &amp;lt;div style=&amp;quot;XXX&amp;quot;&amp;gt; &amp;lt;div style=編集箇所&amp;gt; 上記は部分的な置換を行いたい場合の例ですが、c というところを d に変えれば、指定した範囲を削除することができます。
これらのコマンドは、ファイルタイプが XML や HTML でない場合も動作します。</description></item><item><title>Vim で構文強調（シンタックスハイライト）を有効にする (syntax)</title><link>https://maku77.github.io/p/wcfbnqj/</link><pubDate>Mon, 27 Jan 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wcfbnqj/</guid><description>構文強調（シンタックスハイライト）の機能を有効にしておくと、プログラムのソースコードをなどを編集しているときに、各種キーワードをカラフルに表示してくれるようになります。
:syntax on &amp;#34;構文強調を有効にする（:syntax enable でも OK） :syntax off &amp;#34;構文強調を無効にする 起動時に有効にしておきたい場合は、~/.vimrc に以下のように記述しておきます。
syntax on 特定のバッファでのみ設定を変更するには、コマンドモードから以下のように実行します。
:set syntax=ON &amp;#34;カレントバッファのみ構文強調を有効にする :set syntax=OFF &amp;#34;カレントバッファのみ構文強調を無効にする</description></item><item><title>Vim で編集中のファイルを印刷する (hardcopy)</title><link>https://maku77.github.io/p/nw89tw2/</link><pubDate>Mon, 27 Jan 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nw89tw2/</guid><description>Vim で印刷する 以下のように実行すると、OS の印刷機能を使って現在開いているファイルを印刷することができます。
:hardcopy 印刷する範囲を指定したい場合は、ビジュアルモード (Shift-v) で行選択してから上記を実行します。
Vim の印刷設定 Vim のオプション設定で、印刷時のヘッダー出力などの設定を行うことができます。 詳しくは、下記のようにしてヘルプを参照してみてください。
:help printdevice :help printencoding :help printheader :help printfont :help printoptions printoptions は、次のようにいろいろな設定を組み合わせて指定します。
例: 長い行を折り返し、行番号付き、横向きで印刷 :set printoptions=wrap:y,number:y,portrait:n 例: B5 サイズで、縦向き、両面印刷（長辺閉じ） :set printoptions=paper:B5,portrait:y,duplex:long 例: A3 サイズで、横向き、両面印刷（短辺閉じ） :set printoptions=paper:A3,portrait:n,duplex:short</description></item><item><title>Vim のキーマップ例: ショートカットキーで日時を挿入する</title><link>https://maku77.github.io/p/8xk6jnw/</link><pubDate>Mon, 27 Jan 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8xk6jnw/</guid><description>ショートカットキーで strftime 関数を実行する Vim で以下の設定をしておくと、ショートカットキーで 2014-01-27 のような本日の日付を挿入することができます。 ここでは、Ctrl-D → Ctrl-D というキーコンビネーションに割り当てていますが、任意の組み合わせに変更することができます。
~/.vimrc（Ctrl-D Ctrl-D で日付を挿入） imap &amp;lt;silent&amp;gt; &amp;lt;C-D&amp;gt;&amp;lt;C-D&amp;gt; &amp;lt;C-R&amp;gt;=strftime(&amp;#34;%Y-%m-%d&amp;#34;)&amp;lt;CR&amp;gt; nmap &amp;lt;silent&amp;gt; &amp;lt;C-D&amp;gt;&amp;lt;C-D&amp;gt; &amp;lt;ESC&amp;gt;i&amp;lt;C-R&amp;gt;=strftime(&amp;#34;%Y-%m-%d&amp;#34;)&amp;lt;CR&amp;gt;&amp;lt;CR&amp;gt;&amp;lt;ESC&amp;gt; imap と nmap の両方で定義しているので、挿入モードのときも、ノーマルモードのときも、ショートカットキーを入力して日付の挿入を行うことができます。 &amp;lt;silent&amp;gt; を入れることで、コマンドラインのエコーを防いでいます。 &amp;lt;C-R&amp;gt;= というのは、その後ろに記述した式を実行して展開するためのイディオムです（= は Expression register を示しており、詳細は :help i_Ctrl-R で確認できます）。 日付の挿入を頻繁に実行するのであれば、F1 キーのような単独キーに割り当てるようにすれば、さらに手軽に実行できるようになります。
~/.vimrc（F1 キーで日付を挿入、F2 キーで日付＋曜日を挿入） imap &amp;lt;silent&amp;gt; &amp;lt;F1&amp;gt; &amp;lt;C-R&amp;gt;=strftime(&amp;#34;%Y-%m-%d&amp;#34;)&amp;lt;CR&amp;gt; imap &amp;lt;silent&amp;gt; &amp;lt;F2&amp;gt; &amp;lt;C-R&amp;gt;=strftime(&amp;#34;%Y-%m-%d (%a)&amp;#34;)&amp;lt;CR&amp;gt; ちなみに、F1 キーはデフォルトではヘルプの起動 (:help) のショートカットキーとして設定されているため、上記のように設定すると、F1 キーでヘルプを起動することはできなくなります（まったく問題ないと思いますが）。 また、キーシーケンスの都合で、Ctrl-1 といった Ctrl キーと数字キーの組み合わせはうまく動作しません。
strftime 関数のフォーマット一覧 Vim の strftime のフォーマット文字列で使用できる記号 (%Yなど）は、C 言語の strftime 関数と同様のものです。 なので、Linux 環境や macOS 環境であれば、下記のようにして C 言語の man ページで詳細を確認できます。</description></item><item><title>Vim/Neovim のキーマップ例: ショートカットキーで設定ファイル (.vimrc, init.lua) を開く</title><link>https://maku77.github.io/p/r5fcfgk/</link><pubDate>Mon, 27 Jan 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r5fcfgk/</guid><description>Vim の場合 Vim の設定ファイルで下記のようにキーマッピング設定をしておくと、F1 キーを押すだけで簡単に ~/.vimrc ファイルを開くことができます。 Neovim の設定ファイルとして ~/.config/nvim/init.vim を使用している場合も同様に開くことができます。
Vim の .vimrc あるいは Neovim の init.vim を開く &amp;#34; ノーマルモード時に F1 キーで設定ファイルを開く nnoremap &amp;lt;silent&amp;gt; &amp;lt;F1&amp;gt; :tabnew $MYVIMRC&amp;lt;CR&amp;gt; ここでは、:tabnew コマンドを使って、新しいタブで設定ファイルを開くようにしています。 オプションとして &amp;lt;silent&amp;gt; を指定すると、F1 キーを押したときにコマンドライン領域に :tabnew $MYVIMRC と表示されるのを抑制できます。
Neovim (init.lua) の場合 Neovim の Lua 版の設定ファイル (~/.config/nvim/init.lua) を使う場合は、次のように設定します。
Neovim の init.lua を開く -- ノーマルモード時に F1 キーで設定ファイルを開く vim.keymap.set(&amp;#34;n&amp;#34;, &amp;#34;&amp;lt;F1&amp;gt;&amp;#34;, &amp;#34;:tabnew $MYVIMRC&amp;lt;CR&amp;gt;&amp;#34;, { silent = true }) -- $MYVIMRC を使わずに Lua ファイルのパスを指定する方法 -- vim.keymap.set(&amp;#34;n&amp;#34;, &amp;#34;&amp;lt;F1&amp;gt;&amp;#34;, -- &amp;#34;:tabnew &amp;#34; .</description></item><item><title>Windows でファイルを開くときに既存の GVim 内のタブで開く</title><link>https://maku77.github.io/p/6mdd9es/</link><pubDate>Fri, 25 Oct 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6mdd9es/</guid><description>以下のように設定しておくと、すでに gvim.exe のウィンドウが起動している状態で別のファイルを開いたときに、既存ウィンドウ内のタブとして開くことができます。
レジストリエディタ (regedit) を起動 /HKEY_CLASSES_ROOT/Applications/gvim.exe/shell/open/command の値を &amp;quot;C:\app\vim73-kaoriya\gvim.exe&amp;quot; --remote-tab-silent &amp;quot;%1&amp;quot; のように変更 gvim.exe のパスは自分の環境に合わせてください。</description></item><item><title>Vim のキーマップの基本 (map, noremap)</title><link>https://maku77.github.io/p/nqqixxy/</link><pubDate>Thu, 18 Jul 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nqqixxy/</guid><description>Vim のキーマップとは Vim の *map 系コマンドを使うと、キーマップ（キーバインド）を定義できます。 キーマップとは、特定のキー入力（キーシーケンス）を別のキー入力に変換する機能です。 例えば、&amp;lt;F1&amp;gt; キーを押すことで :help コマンドを実行するように設定することができます。 頻繁に使うコマンドを短いキーシーケンスに割り当てることで、効率的に作業できるようになります。
Vim では、ノーマルモード、インサートモード、ビジュアルモード、コマンドラインモードなど、それぞれのモードごとにキーマップを定義できます。 また、noremap 系コマンドを使うことで、マッピングの伝播を防ぐことができます。
キーマップのヘルプ Vim のキーマップに関するヘルプドキュメントは、以下のコマンドで表示することができます。 必要に応じて参照してください。
:help map.txt :help key-mapping map 系コマンドによるキーマッピング キーマップの設定を行うには、主に以下のようなコマンドを使用します。 コマンドを使い分けることによって、特定のモードでだけ有効なマッピングを定義できます。
map &amp;hellip; ノーマルモード、ビジュアルモード用のキーマッピング nmap &amp;hellip; ノーマルモード用のキーマッピング vmap &amp;hellip; ビジュアルモード用のキーマッピング imap &amp;hellip; インサートモード用のキーマッピング cmap &amp;hellip; コマンドラインモード用のキーマッピング よく使用するのは、ノーマルモード用のマップ定義を行う nmap と、インサートモード用のマップ定義を行う imap です。
マッピングの定義は、以下のような形式で行います。
キーマップの基本的な書式 :nmap ＜入力するキーシーケンス＞ ＜実行するコマンド＞ :imap ＜入力するキーシーケンス＞ ＜実行するコマンド＞ 例えば、下記のように実行したあとで、インサートモードで Ctrl キーを押しながら F10 キーを 2 回押すと、カーソル位置に Hello World が挿入されます。
キーマップの例（インサートモード用） :imap &amp;lt;C-F10&amp;gt;&amp;lt;C-F10&amp;gt; Hello World ☝️ ワンポイント &amp;lt;C-F10&amp;gt; は Ctrl キーを押しながら F10 キーを押すことを表します。 このようなキー入力の表現方法は、:help key-notation で詳しく説明されています。 もっと単純に F10 キー 1 つに割り当ててもよかったのですが、ここではこんな複雑なキーシーケンスにもマッピングできるよという例を示しています。 同様のキーシーケンスをノーマルモード用に割り当てる場合は、下記のように先に i コマンドでインサートモードに入らないといけないことに注意してください。 最後には &amp;lt;Esc&amp;gt; でノーマルモードに戻ってあげると行儀が良いです。</description></item><item><title>Vim で開いたファイルがあるディレクトリをカレントディレクトリにする</title><link>https://maku77.github.io/p/4ekh9ba/</link><pubDate>Sun, 16 Jun 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4ekh9ba/</guid><description> （追記） autochdir オプション が使える Vim であればそちらを使った方が簡単です。 Vim では、最初に Vim を起動するときに指定したファイルのあるディレクトリがカレントディレクトリとして使用されます。 このカレントディレクトリは、新しいバッファで別のディレクトリにあるファイルを開いた場合でも変更されません。 このため、編集中のファイルと同じディレクトリにあるファイルを :e . や :tabnew . コマンドで開く際に不便を感じることがあります（全然関係ないディレクトリが起点となってしまう）。
Vim の設定ファイル (~/.vimrc) で次のように設定しておくと、Vim 内で別のファイルを開いたときに、そのファイルの存在するディレクトリへ自動的に移動してくれるようになります。
~/.vimrc &amp;#34; 開いたファイルのあるディレクトリをカレントディレクトリにする au BufEnter * execute &amp;#34;:lcd &amp;#34; . expand(&amp;#34;%:p:h&amp;#34;)</description></item><item><title>Windows の右クリックメニューに「Vimで開く」を追加する</title><link>https://maku77.github.io/p/wwatzd9/</link><pubDate>Mon, 10 Jun 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wwatzd9/</guid><description>（Windows Vista、Windows 7 で動作確認）
以下のようにレジストリエディタ (regedit) で設定しておくと、テキストファイルを右クリックしたときに、「Vim で開く」というメニュー項目が表示されるようになります。
Windows + R（ファイル名を指定して実行）から regedit と入力してレジストリエディタを起動する。 HKEY_CLASS_ROOT/*/shell を右クリックして Vim というキーを新規作成。 HKEY_CLASS_ROOT/*/shell/Vim の規定の REG_SZ の値を &amp;amp;Vim で開く に修正。 HKEY_CLASS_ROOT/*/shell/Vim を右クリックして command というキーを新規作成。 HKEY_CLASS_ROOT/*/shell/Vim/command の規定の REG_SZ の値を C:\vim\gvim.exe &amp;quot;%1&amp;quot; などに修正（パラメータをダブルクォーテーションで囲んでおかないと、空白を含んだファイルを開けません）。</description></item><item><title>Vim で挿入モード、コマンドモードでの貼り付け</title><link>https://maku77.github.io/p/xqq89n2/</link><pubDate>Sun, 26 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xqq89n2/</guid><description>ノーマルモードでのテキストのコピペは、y コマンドでコピー (yank) 、p コマンドで貼り付け (put) することができます。 一方、挿入モードやコマンドモードで貼り付けを行うには、下記のように入力する必要があります（挿入モードで y と入力すると、そのまま y というテキストが入力されてしまいます）。
Ctrl-R 0 これは、具体的には 「レジスタ 0」 に格納されているテキスト（直近でヤンクされたテキスト）を選択して貼り付けるコマンドです。 レジスタ 0 に格納されるテキストは、あくまで Vim 内部でヤンクされたテキストです。 外部のアプリケーションでコピーしたテキストを貼り付けたい場合は、レジスタ 0 の代わりに、レジスタ * を指定してください。
Ctrl-R * レジスタに保存されているテキストの一覧は、以下のように確認することができます。
:reg 参考 切り取り＆貼り付け操作、レジスタの扱いについて理解する 最後にヤンクしたテキストを確実に貼り付ける</description></item><item><title>Vim で最後にヤンクしたテキストを確実に貼り付ける</title><link>https://maku77.github.io/p/7jkhjzf/</link><pubDate>Sun, 26 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7jkhjzf/</guid><description>ビジュアルモードで選択したテキストは、y コマンドでコピーし、p コマンドで貼り付けることができます。
このとき、貼り付けを実行する前に、x コマンドや d コマンドなどによる削除操作を行ってしまうと、y コマンドを実行したときに、その削除したテキストが貼り付けられてしまいます。 このようなケースでも、自分が明示的にヤンク (y) したテキストを確実に貼り付けたいときは、次のようにレジスタ 0 を指定してペーストコマンド (p) を実行します。
&amp;#34;0p レジスタ 0 は、Vim 上で最後にヤンクしたテキストを保持しておくレジスタです。
上記はノーマルモードでレジスタ 0 の値を貼り付ける方法を示していますが、挿入モードやコマンドモードで同様にレジスタ 0 の値を貼り付けるには下記のようにします。
Ctrl-R 0 参考 切り取り＆貼り付け操作、レジスタの扱いについて理解する 挿入モード、コマンドモードでの貼り付け</description></item><item><title>Vim/Neovim でビジュアルモードで簡単にインデントを行えるようにする</title><link>https://maku77.github.io/p/hoihkfy/</link><pubDate>Sun, 26 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hoihkfy/</guid><description>ビジュアルモードで複数行を選択してインデントするには、&amp;gt;&amp;gt; や &amp;lt;&amp;lt; を使いますが、このコマンドを入力すると、ビジュアルモードを抜けてしまうので、連続してインデントを行いたい場合にちょっと面倒です（何回インデントすればよいか分かっていれば 3&amp;gt;&amp;gt; のように回数を指定することはできますが…）。
下記のような設定を入れておくと、ビジュアルモード中のインデントを、&amp;gt; あるいは &amp;lt; だけで行うことができるようになります。 さらに、このコマンドを入力した後も、ビジュアルモードを抜けずにキープしてくれるので、行選択したまま連続してインデントを行うことができます。
&amp;#34; Reselect visual block after indent/outdent vnoremap &amp;lt; &amp;lt;gv vnoremap &amp;gt; &amp;gt;gv 同様に、選択範囲の自動インデントを行う = コマンド にも適用できます。
&amp;#34; Stay visual mode after formatting code vnoremap = =gv 参考 インデント用のスペースを入力する（シフトコマンド） (&amp;gt;&amp;gt;, &amp;lt;&amp;lt;, Ctrl-T, Ctrl-D)</description></item><item><title>Vim で80文字目に縦線を表示する (colorcolumn)</title><link>https://maku77.github.io/p/ngz6n6i/</link><pubDate>Sat, 25 May 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ngz6n6i/</guid><description>指定したカラム位置の背景色を変えることで、縦線を入れたように見せることができます。 例えば、80文字目の背景色を灰色にするには、以下のように colorcolumn を設定します。
~/.vimrc（80カラム目に縦線を表示） set colorcolumn=80 highlight ColorColumn guibg=#202020 ctermbg=lightgray colorcolumn は上記のように絶対位置で指定することもできるし、textwidth が設定されている場合は、その値からの相対位置（+N や -N という形）で指定することもできます。 例えば、下記のようにすると、textwidth から +1 の位置、つまり 80 文字目の背景色が変わることになります。
~/.vimrc（textwidth&amp;#43;1 の位置に縦線を表示） set textwidth=79 set colorcolumn=+1 highlight ColorColumn guibg=#202020 ctermbg=lightgray ここでは colorcolumn に一つの値だけを設定していますが、カンマで区切って複数のカラムを指定することができます。 カンマの前後にスペースは入れてはいけません。
~/.vimrc（textwidth&amp;#43;1 の位置、80カラム目、100カラム目に縦線を表示） set colorcolumn=+1,80,100</description></item><item><title>Vundle をインストールして Vim のプラグイン環境を作る</title><link>https://maku77.github.io/p/b85489c/</link><pubDate>Sun, 07 Apr 2013 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/b85489c/</guid><description>Vundle とは Vundle をインストールすると、Vim のプラグインを :BundleInstall コマンドで簡単にインストールすることができるようになります。
Vundle のインストール 基本的には、以下のサイトの手順に従ってインストールするだけです。
https://github.com/VundleVim/Vundle.vim 下記のようにインストールすると、Vim のプラグインを ~/.vim/bundle ディレクトリ内で管理することができるようになります。 インストールしたプラグインを消す場合も、ディレクトリごと削除するだけなのでお手軽です。
Vundle のダウンロード $ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 本家サイトには、.vimrc に Vundle 用の設定を記述する方法が説明されていますが、個人的には、プラグイン関連の情報は別ファイル (~/vimrc_vundle.vim) で管理して ~/.vimrc から読み込むようにしています。
~/.vimrc（Vundle 用の設定をインクルード） source ~/vundle_vimrc.vim ~/vundle_vimrc.vim（Vundle 用の設定） &amp;#34;&amp;#34;&amp;#34; Enable vundle commands set nocompatible &amp;#34; be iMproved, required filetype off &amp;#34; required &amp;#34; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() &amp;#34; let Vundle manage Vundle, required Plugin &amp;#39;VundleVim/Vundle.</description></item><item><title>Vim で正規表現にマッチする行を削除する</title><link>https://maku77.github.io/p/ngf6w24/</link><pubDate>Thu, 06 Dec 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ngf6w24/</guid><description>正規表現に一致するテキストが見つかった行をすべて削除する 下記のように実行すると、正規表現に一致するテキストを含む行をまとめて削除することができます。
:g/正規表現/d 例えば、以下のようなファイルリストが書かれたテキストから、バックアップファイル（~ で終わる行）を削除するには、
src/main.h src/main.h~ src/main.cpp src/main.cpp~ 以下のようなコマンドを入力します。
:g/\~$/d 正規表現に一致するテキストが「見つからない」行をすべて削除する 逆に、指定した正規表現に一致するテキストが 見つからない 行を削除するには、下記のように実行します。
:v/正規表現/d</description></item><item><title>Vim で■や※などの記号が重なって表示される問題の解決 (ambiwidth)</title><link>https://maku77.github.io/p/fp2xk7y/</link><pubDate>Thu, 11 Oct 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fp2xk7y/</guid><description>日本語の Vim 環境において、encoding オプションの値が utf-8 などに設定されている場合、■ や ※ などの記号を入力したときに、その次の文字が半角分重なって表示されてしまうことがあります。 このような記号を正しく全角文字の幅で表示するには、以下のように設定します。
set ambiwidth=double &amp;#34;Display double-width symbols properly guifont を設定すると、ambiwidth の設定が auto に戻ってしまうようなので、guifont を設定している場合は、その後で ambiwidth を設定するとよいでしょう。
~/_gvimrc（Windows の場合） &amp;#34;Font settings for Windows if has(&amp;#34;gui_win32&amp;#34;) set guifont=ＭＳ_ゴシック:h10::cSHIFTJIS set printfont=ＭＳ_ゴシック:h22:cSHIFTJIS set ambiwidth=double &amp;#34;Display double-width symbols properly endif</description></item><item><title>Vim の map、noremap 系コマンドで使用できる特殊キーの一覧 (key-notation, key-codes)</title><link>https://maku77.github.io/p/ibpmg65/</link><pubDate>Fri, 27 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ibpmg65/</guid><description>参考: Vim のキーマップの基本 (map, noremap) キーマップに使えるキー名の一覧 Vim の map 系コマンド（nmap や imap）で、F1 キーや BackSpace キーなどの特殊キーを使用したマッピングを行う場合は、下記のヘルプページで表示されるキー表記を使用します。
キー表記のヘルプ :help key-notation 例えば、特殊キーを表すために次のような表記が使えることがわかります。
&amp;lt;BS&amp;gt; &amp;hellip; Back Space キー &amp;lt;Bslash&amp;gt; &amp;hellip; Back Slash キー (\) &amp;lt;CR&amp;gt; or &amp;lt;Enter&amp;gt; &amp;hellip; Enter キー（&amp;lt;CR&amp;gt; がよく使われている） &amp;lt;Esc&amp;gt; &amp;hellip; Esc キー &amp;lt;Space&amp;gt; &amp;hellip; スペースキー &amp;lt;Tab&amp;gt; &amp;hellip; Tab キー &amp;lt;Del&amp;gt; &amp;hellip; Delete キー &amp;lt;Up&amp;gt;/&amp;lt;Down&amp;gt;/&amp;lt;Left&amp;gt;/&amp;lt;Right&amp;gt; &amp;hellip; 上下左右カーソルキー &amp;lt;F1&amp;gt; 〜 &amp;lt;F12&amp;gt; &amp;hellip; ファンクションキー &amp;lt;Help&amp;gt; &amp;hellip; Help キー &amp;lt;Insert&amp;gt; &amp;hellip; Insert キー &amp;lt;Home&amp;gt; &amp;hellip; Home キー &amp;lt;End&amp;gt; &amp;hellip; End キー &amp;lt;PageUp&amp;gt; &amp;hellip; Page Up キー &amp;lt;PageDown&amp;gt; &amp;hellip; Page Down キー Shift キー、Control キー、Alt (Meta) キー、Command キー（macOS のみ）といったキーとの同時押しを表現するには、次のように記述します。</description></item><item><title>Vim 上でディレクトリツリーを表示する (NERDTree)</title><link>https://maku77.github.io/p/8qeuow8/</link><pubDate>Sun, 22 Jul 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8qeuow8/</guid><description>NERDTree とは NERDTree を使うと、Vim の左端にエクスプローラバーのようなものを表示できます。
https://github.com/preservim/nerdtree NERDTree のインストール 公式サイトにはいくつかインストール方法が書かれていますが、ここでは Vundle を使ってインストールします。
~/.vimrc call vundle#begin() Plugin &amp;#39;preservim/nerdtree&amp;#39; call vundle#end() 上記のように .vimrc などに記述しておけば、次のように実行するだけで簡単に NERDTree をインストールできます。
:PluginInstall NERDTree tabs のインストール NERDTree プラグインである NERDTree tabs をインストールしておくと、NERDTree とタブを組み合わせた操作がより直感的になります。
https://github.com/jistr/vim-nerdtree-tabs このプラグインをインストールすると、NERDTree が以下のような振る舞いをするようになります。
Vim 起動時に NERDTree を自動的に開く NERDTree 上で t キーを押してファイルをタブで開いたときに、NERDTree のウィンドウを開いたままにする NERDTree tabs プラグインも、NERDTree 本体と同様に、Vundle を使って簡単にインストールすることができます。
~/.vimrc call vundle#begin() &amp;#34; NERDTree 本体 Plugin &amp;#39;preservim/nerdtree&amp;#39; &amp;#34; NERDTree tabs プラグイン Plugin &amp;#39;jistr/vim-nerdtree-tabs&amp;#39; call vundle#end() 上記のように .vimrc に記述しておき、以下のようにインストールします。
:BundleInstall NERDTree の使い方の基本 まずは、以下のコマンドでツリーを開きます。</description></item><item><title>Vim でカーソル位置の単語をファイル名としてファイルを開く (gf, Ctrl-w gf, Cgtrl-w f)</title><link>https://maku77.github.io/p/sok5efu/</link><pubDate>Thu, 03 May 2012 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sok5efu/</guid><description>ファイル名にカーソルを当ててファイルを開く Vim でファイル名っぽい文字列にカーソルを置いて、gf と入力すると、その名前のファイルを開くことができます（Goto File と覚えてください）。 同じウィンドウでファイルを開くため、その前に編集していたファイルの内容は一時的に見えなくなってしまうのですが、CTRL-o とすれば元のファイルに簡単に戻ってくることができます。
入力 説明 gf カーソルの下のファイルを開く CTRL-o 元のファイルに戻る 元のファイルに戻るときに、CTRL-o の代わりに CTRL-^ を使用することもできます。 CTRL-^ は直前のファイルに戻るという意味のコマンドで、続けて入力すると、2 つのファイルの間で行ったり来たりすることができます。
新しいタブで開く カーソル下のファイル名でファイルを開くときに gf を使用するとカレントバッファで開きますが、Ctrl-w を組み合わせることで、新しいタブや、ウィンドウ分割でファイルを開くことができます。
入力 説明 gf カレントバッファに開く Ctrl-w gf 新しいタブで開く （オススメ） Ctrl-w f ウィンドウを分割して開く 若干複雑な操作になりますが、このコマンドには慣れておくことをお勧めします。</description></item><item><title>Vim で行を逆順にソートする (:sort!)</title><link>https://maku77.github.io/p/g9cckyt/</link><pubDate>Tue, 27 Dec 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/g9cckyt/</guid><description>ex コマンドで実行できる sort は、デフォルトでは昇順に行ソートしますが、末尾に ! を付加することで逆順（降順）ソートすることが可能です。 行範囲を指定して逆順ソートを実行するには、例えば下記のようにします。
Shift + v でビジュアルモードに入り、行を選択 :sort! と入力して Enter</description></item><item><title>Vim の文字の削除方法まとめ（テキストオブジェクト） (d, delete)</title><link>https://maku77.github.io/p/qbmdoef/</link><pubDate>Wed, 21 Dec 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qbmdoef/</guid><description>Vim にはテキストを削除ための様々なキーコンビネーションが用意されています。 最初はたくさんあって面食らいますが、体系的な組み合わせになっているので意外と覚えやすいです。 これらのキーコンビネーションを使いこなすと、他のエディタでは決して真似できない爆速テキスト編集が可能になります。
ノーマルモードでの削除 削除の基本 入力 説明 x 1 文字削除（カーソル位置） X 1 文字削除（カーソルの前） dd 1 行削除（cc だとさらにインサートモードに移行） D 行末まで削除（C だとさらにインサートモードに移行） このキーマッピングだけは基本的な削除操作として覚える必要があります。 特に重要そうなものはハイライトしています。
削除系操作の詳細は、:help deleting で確認できます。
オペレーター + 移動コマンド d オペレーターに続けて、1 文字の 移動コマンド を指定することで、カーソル位置からその位置までのテキスト を削除することができます。 例えば、次の単語へジャンプする移動コマンド w と組み合わせて、dw と入力すると、カーソル位置から次の単語までのテキストを削除することができます。 下記は、d オペレーターと移動コマンドの組み合わせによるテキスト削除の例です。
入力 説明 d0 カーソル位置から行頭まで削除 d^ カーソル位置から行頭まで削除（インデントは残す） d$ カーソル位置から行末まで削除（D でも可） dw カーソル位置から単語の末尾まで削除（スペースも削除） de カーソル位置から単語の末尾まで削除（スペースは残す） db カーソル位置から単語の先頭まで削除 df{X} カーソル位置から文字 {X} まで削除 dF{X} カーソル位置から文字 {X} まで削除（前方検索） w、e、b といった単語単位の移動コマンドは、日本語文章では、連続する「漢字」「ひらがな」「カタカナ」を 1 つの単語とみなしてジャンプします。 日本語文章でもスペースを単語の区切りとしてジャンプするには、大文字の W、E、B を使用します。</description></item><item><title>Vim でカーソル位置の単語を取得する (&lt;cword>)</title><link>https://maku77.github.io/p/f448waf/</link><pubDate>Mon, 06 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f448waf/</guid><description>Vim 内で、カーソル位置の単語は &amp;lt;cword&amp;gt; で参照することができます。
例: カーソル位置の単語を表示 :!echo &amp;lt;cword&amp;gt; 例: F4 キーでカーソル位置の単語を検索できるようにする nnoremap &amp;lt;F4&amp;gt; :grep &amp;lt;cword&amp;gt; ./*</description></item><item><title>Vim でカーソル位置の文字の文字コードを表示する (:ascii)</title><link>https://maku77.github.io/p/6bpmxey/</link><pubDate>Mon, 06 Jun 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6bpmxey/</guid><description>Vim エディタのノーマルモードで、
ga と入力すると、カーソル位置の文字コード（10進数、16進数、8進数）を表示できます。 例えば、A という文字にカーソルを置いて ga と入力すると、以下のように表示されます。
&amp;lt;A&amp;gt; 65, Hex 11, Octal 101 コマンドモードから次のように入力することでも同様のことを行えます。
:ascii</description></item><item><title>Vim でディレクトリエクスプローラー (Explore) を使用してファイルを開く (:E, :Ve, :He)</title><link>https://maku77.github.io/p/928ca4t/</link><pubDate>Thu, 19 May 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/928ca4t/</guid><description>Explore とは Vim にはデフォルトで、ファイルを操作するのディレクトリエクスプローラー機能 (Explore) が付属しています。 Explorer じゃなくて、Explore なので注意してください（最後の r がないです）。
カレントディレクトリを起点にして Explore を起動する :E[xplore] &amp;#34; カレントバッファで開く（:vi . でも同様） :Ve[xplore] &amp;#34; 左右に分割して開く :He[xplore] &amp;#34; 上下に分割して開く 編集中のファイルのあるディレクトリを起点にして Explore を起動する :E %:h &amp;#34; :vi %:h でも同様 :Ve %:h :He %:h Explore でブックマーク機能を使用する ディレクトリエクスプローラーを :Explore コマンドで起動した後で、以下のようにして各ディレクトリをブックマークすることができます。
mb &amp;#34; カレントディレクトリを ブックマークする qb &amp;#34; ブックマークの一覧を表示する gb &amp;#34; 最後に ブックマークしたディレクトリへ移動 1gb &amp;#34; 1番目の ブックマークへ移動 2gb &amp;#34; 2番目の ブックマークへ移動 mB &amp;#34; 最後の ブックマークを削除する 1mB &amp;#34; 1番目の ブックマークを削除する 2mB &amp;#34; 2番目の ブックマークを削除する qb コマンドで ブックマークの一覧を表示すると分かりますが、ブックマークは単純にアルファベット順にソートされて保存されます（追加した順番には並びません）。 上記のコマンドの中で指定する番号は、このソートされた順に並べられたブックマークの番号なので注意してください。</description></item><item><title>Vim/Neovim で制御文字（改行、タブ文字、行末のスペースなど）を表示する (list, listchars)</title><link>https://maku77.github.io/p/s596qii/</link><pubDate>Sun, 24 Apr 2011 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/s596qii/</guid><description>list モードとは Vim/Neovim の list モードを有効にすると、テキストファイル内の制御文字や空白文字（タブや末尾のスペースなど）を視覚的に表示することができます。 例えば、プログラミング言語の Python などでコーディングを行っているときは、タブ文字と通常のスペースを意識して使い分けなければいけないので、このような非表示文字を目に見えるように設定しておくことには意味があります。 もちろん通常の文章を記述するときにも、行末の余計なスペースなどを簡単に見つけられるようになるので、この設定は常に有効にしておくことをオススメします。
list モードは、Vim でも Neovim でもデフォルトでは無効になっているため、明示的に有効化する必要があります。
:set list &amp;#34;制御文字を表示 :set nolist &amp;#34;制御文字を非表示 次のように行範囲（全ての行）を指定して list コマンドを実行すると、一時的に制御文字を確認することができます。
:% list 制御文字の表示方法の設定 (listchars) タブや改行などの制御文字をどのように表示するかは、listchars (lcs) オプションで設定します。
デフォルト設定 listchars のデフォルト値は Vim と Neovim で次のように異なっています。
&amp;#34; Vim のデフォルト設定 set listchars=eol:$ &amp;#34; Neovim のデフォルト設定 set listchars=tab:&amp;gt;\ ,trail:-,nbsp:+ Vim のデフォルト設定では、タブ文字が ^I 、改行が $ で表示されます。 Neovim のデフォルト設定では、タブ文字が &amp;gt; 、行末のスペースが - で表示されます。
listchars の設定例 Vim (~/.vimrc) の場合 &amp;#34; 制御文字の設定 set listchars=tab:&amp;gt;.,trail:_,eol:$ set list Neovim (~/.</description></item><item><title>Vim 内で grep を実行して見つかったファイルへジャンプする (:vimgrep, :grep)</title><link>https://maku77.github.io/p/c4q8amz/</link><pubDate>Mon, 13 Sep 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c4q8amz/</guid><description>内部 grep (internal grep) と外部 grep (external grep) Vim には自身に搭載されている検索機能を実行する 内部 grep と、外部の grep 系コマンドを実行する 外部 grep の機能が存在します。
内部 grep を起動するコマンド &amp;hellip; :vim（:vimgrep の省略形） 外部 grep を起動するコマンド &amp;hellip; :grep :vimgrep による検索（内部 grep） :vimgrep の概要 内部 grep（:vim あるいは :vimgrep）は、Vim に組み込まれた grep 機能を使用するため、どの OS 上でも共通の振る舞いの検索を実行することができます。 検索にヒットした行は Vim 内部の QuickFix List という配列データに追加され、そこから見つけた行にジャンプすることができます（参考: :help quickfix.txt）。
書式 :vim /{pattern}/[g][j] {file} ... g オプション &amp;hellip; 同じ行の中にパターンに一致する部分が複数あった場合に、QuickFix List に別々に追加します。デフォルトでは、同じ行内で複数回検索にヒットしても、その行は 1 度だけ QuickFix List に追加されます。多くのケースでは、このオプションを指定する必要はないでしょう。 j オプション &amp;hellip; デフォルトでは検索で最初にマッチした行にカーソルが移動します。j オプションを付けると、カーソルの位置は移動しません。 基本的な検索 例: 現在開いているファイルを grep :vim /hoge/ % % は現在開いているファイル名を表します。</description></item><item><title>Vim で大文字と小文字を区別しないで検索する (ignorecase)</title><link>https://maku77.github.io/p/mfcba2q/</link><pubDate>Tue, 18 May 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mfcba2q/</guid><description>Vim で / や :vimgrep による検索を行うときに、大文字・小文字を区別するかどうかの設定は下記のように行います（デフォルトでは大文字・小文字を区別します）。
:set ignorecase &amp;#34;大文字と小文字を区別しない （ic と省略可能） :set noignorecase &amp;#34;大文字と小文字を区別する （noic と省略可能） この設定にかかわらず、検索時に大文字・小文字を区別するかを指定するには、検索パターンの中に \c や \C を含めるようにします。
検索時に大文字・小文字を区別を指定 /\cfoo &amp;#34; 大文字、小文字を区別せずに foo を検索 /\Cfoo &amp;#34; 大文字、小文字を区別して foo を検索 検索パターン中の \c と \C は、先頭で指定する必要はなく、パターン内のどこにあっても構いません。
検索に関する設定方法の詳細は下記を参照してください。
参考: Vim の検索に関する設定 (ignorecase, smartcase, wrapscan, hlsearch, incsearch)</description></item><item><title>Vim で Java や C/C++ のコメント記述に便利な formatoptions の設定</title><link>https://maku77.github.io/p/i9y5wsd/</link><pubDate>Tue, 05 Jan 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i9y5wsd/</guid><description>Vim で次のように設定しておくと、C 言語などのコメントを記述しているときに、改行を入力するだけで自動的にコメントの途中の記号を挿入してくれるようになります。
:set formatoptions=tcqro 下記、それぞれのオプションの意味です。
t &amp;hellip; （textwidth の値を超える）長いテキスト行を入力した場合に自動で改行する。 c &amp;hellip; （textwidth の値を超える）長いコメント行を入力した場合に自動で改行しコメントリーダーを挿入する。 q &amp;hellip; gq コマンドで選択部分をコメント整形する。 r &amp;hellip; Enter 入力時にコメントリーダーを挿入する。 o &amp;hellip; o あるいは O で行を挿入した場合にコメントリーダーを挿入する。 例えば、Java のコメントを編集中に、
/** * This is a comment line. ここまで入力して改行すると、自動的に以下のように行の先頭にアスタリスクが挿入されます。 これは、formatoptions に r を指定した効果です。
/** * This is a comment line. *</description></item><item><title>Vim/Neovim ですでに入力されているタブをスペースに変換する (:retab)</title><link>https://maku77.github.io/p/w4qm7ok/</link><pubDate>Mon, 07 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/w4qm7ok/</guid><description>expandtab オプションが設定されていると、TAB キーを押したときに、タブ文字の代わりに tabstop で設定した数のスペースが挿入されます。 すでに入力されているタブ文字を、スペースに変換するには、expandtab モードを有効にしたうえで、:retab コマンドを実行します。
例: タブ文字を 4 文字分のスペースに置換する :set expandtab :set tabstop=4 :retab 参考 タブ文字の設定 (tabstop, expandtab, softtabstop)</description></item><item><title>Vim/Neovim で選択した範囲を自動インデントする (=)</title><link>https://maku77.github.io/p/pxpgasg/</link><pubDate>Mon, 07 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/pxpgasg/</guid><description>自動インデントの実行 ソースコードの一部分のインデントが崩れているような場合は、以下のように自動整形することができます。
対象となるコードをビジュアルモードで行選択（Shift-V + 行選択）。 = と入力 自動インデントを整形するときに使用するプログラムを指定する = コマンドで自動インデントを行う場合は、デフォルトでは Vim 内部の整形プログラムが使用されますが、任意のインデント用プログラムを使用するように設定することもできます。
:set equalprg=/usr/local/bin/indent 参考 自動インデントモードを有効にする (autoindent, smartindent, cindent)</description></item><item><title>Vimの設定: モードラインを使ってファイル単位で書式設定する (modeline)</title><link>https://maku77.github.io/p/39fajvt/</link><pubDate>Mon, 07 Dec 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/39fajvt/</guid><description>モードラインとは テキストファイルの先頭か末尾に、モードライン (modeline) という特殊なコメントを埋め込んでおくと、そのファイルにだけ適用する Vim の設定を行うことができます。 複数人でフォーマットを揃えて１つのテキストファイルを編集したい場合などに便利です。 例えば C 言語のソースファイルなら以下のようなコメントを書いておくことで、そのファイルのインデント幅やタブ使用の有無を支持することができます。
/* vim: set shiftwidth=4:tabstop=4:expandtabs */ モードライン (modeline) の機能を有効にするには、以下のように設定しておく必要があります。
~/.vimrc set modeline &amp;#34;モードラインを有効にする set modelines=5 &amp;#34;上端、下端から何行までをモードラインと認識するか ファイルの先頭や末尾に記述するモードラインは、下記のようなフォーマットで記述します。
&amp;lt;任意のテキスト&amp;gt;&amp;lt;スペース&amp;gt;vim: set ...:&amp;lt;任意のテキスト&amp;gt; 例えば、一行の文字数を 79 文字に制限して自動的に折り返すようにするには、テキストの最終行などに、以下のように記述しておきます。
# vim: set tw=79 fo=aM: 行頭と行末には任意のテキストを入れられるので、C++ のコメントとして以下のように記述することができます。
/* vim: set tw=79 fo=aM: */ モードラインの行末に任意のテキストを追加しなくてよい場合（行末までを Vim の設定値とみなしてよい場合）は、set の記載と、最後の : を省略することができます。
# vim: tw=79 fo=aM モードラインの設定例 例: 79 文字で自動的に折り返す # vim: tw=79 fo=aqwB ai 各オプションの意味は以下のようになっています。
tw=79 (textwidth) &amp;ndash; 一行の文字数を 79 文字（＋改行）に制限 fo=aqwB (formatoptions) a &amp;hellip; テキスト入力するごとに textwidth に設定した文字数で自動折り返し q &amp;hellip; gq コマンドで、選択範囲をフォーマットする w &amp;hellip; 行末にスペースがある場合のみ、自動で行連結しようとする B &amp;hellip; 行を結合したときに日本語の間にはスペースを入れない ai (autoindent) &amp;ndash; 改行するときに自動的に現在の行と同じだけインデントする formatoptions で、a と一緒に m を指定すると、文字挿入時に日本語などのマルチバイト文字でも自動改行するようになりますが、a オプションと相性がよくないので、m は指定しない方がよいです。 例えば、カーソルより後ろの日本語文章が自動改行されると、改行された後ろのテキストに余計なスペースが入ったり、1 文字ごとに改行されてしまったりします。 なので、日本語テキストを整形したい場合は、整形したい領域を選択し、gq で手動整形するのがよいです。</description></item><item><title>Vim で折りたたみ機能 (folding) を使用する</title><link>https://maku77.github.io/p/sxouvi5/</link><pubDate>Tue, 17 Nov 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sxouvi5/</guid><description>Vim の折りたたみ (folding) 機能を使用すると、特定の行を折りたたんで表示する（一時的に非表示にする）ことができます。
指定した範囲を折り畳む 折りたたみ機能によって、どのような範囲を折りたたむかは、foldmethod というオプションで制御されています。
:set foldmethod=manual （デフォルト） としておくと、任意の選択範囲を折りたたみ領域として扱うことができるようになります。
例: Visual mode で選択した部分を折り畳む 1. Visual mode (Shift-v) で領域選択 2. zf 例: カーソル位置から、指定した文字列が見つかるところまでを折り畳む zf /string 一度 zf コマンドによって折りたたんだ領域は、zo で展開、zc で折りたたみを行えるようになります。
インデント単位で折りたたむ 折りたたみの単位の設定を indent にすると、各種折りたたみコマンドの対象がインデント単位になります。
:set foldmethod=indent 折りたたみ機能に関するコマンド一覧 折りたたみと展開（カーソル位置の要素に対して） zc -- 折りたたみ (Close one fold under the cursor) zo -- 展開（一段階）(Open one fold under the cursor) zO -- 展開（すべて）(Open all folds under the cursor recursively) 折りたたみと展開（ファイル全体の要素に対して） zm -- 折りたたみ（一段階） (Fold more) zM -- 折りたたみ（すべて） (Close all folds) zr -- 展開（一段階） (Reduce folding) zR -- 展開（すべて） (Open all folds) 折りたたみ単位でジャンプ zj -- move to the next fold zk -- move to the previous fold 折りたたみ関連の設定 折りたたみ機能に関する設定は、foldXXXXX という名前のオプションを使って行います。</description></item><item><title>Vim で挿入モード（インサートモード）のまま実行できる操作の一覧</title><link>https://maku77.github.io/p/hk22h6b/</link><pubDate>Wed, 11 Nov 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hk22h6b/</guid><description>挿入モード（インサートモード）でのテキストを編集中は、下記のようなショートカットキーを使用することができます。
CTRL-U &amp;hellip; 挿入モードでの入力をすべて削除 CTRL-W &amp;hellip; カーソル直前の単語を削除 CTRL-V 数値 &amp;hellip; 指定した文字コードの文字を入力（例: CTRL-V 123 → }） CTRL-V Tab &amp;hellip; タブ文字を入力（Tab キーで半角スペースを入力する設定になっていてもタブ文字を入力できる） CTRL-Y &amp;hellip; カーソルの上（上の行）にある 1 文字をコピーして入力 CTRL-E &amp;hellip; カーソルの下（下の行）にある 1 文字をコピーして入力 CTRL-R レジスタ &amp;hellip; 指定したレジスタ内のテキストを挿入（例: CTRL-R * → 直前にヤンクした内容を貼り付け） CTRL-[ &amp;hellip; 挿入モードを抜ける CTRL-O コマンド &amp;hellip; 通常モードのコマンドを一回だけ実行（例: CTRL-O $ → 挿入モードのままカーソルを行末へ移動） CTRL-P &amp;hellip; 入力補完候補の表示（逆方向に選択） CTRL-N &amp;hellip; 入力補完候補の表示（順方向に選択） 挿入モード中にカーソルを移動させるには、カーソルキーを使用します。</description></item><item><title>Vim でスペルチェックを有効にする</title><link>https://maku77.github.io/p/fweeaqx/</link><pubDate>Mon, 14 Sep 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fweeaqx/</guid><description>Vim 7.0 からは、組み込みの辞書によるスペルチェッカーが搭載されています。 スペルチェッカーを有効にするには次のようにします。
:set spell スペルチェックに使用する言語を指定するには以下のように指定します。 デフォルトは en (English) です。
:set spelllang=en,da,de,it 複数の言語を指定したい場合は、上記のようにカンマで区切って指定します。 いずれかの言語の辞書に該当する単語が見つかれば、スペルエラーになりません。</description></item><item><title>Vim でカーソル下の行や列をハイライト表示する (cursorline, cursorcolumn)</title><link>https://maku77.github.io/p/osrx94g/</link><pubDate>Wed, 09 Sep 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/osrx94g/</guid><description>下記のように設定しておくと、カーソル行やカーソル列の背景色がハイライトされるようになります。
:set cursorline &amp;#34;カーソル行のハイライト :set cursorcolumn &amp;#34;カーソル列のハイライト 両方とも設定しておくと、ひと目でカーソル位置が分かるようになるのでオススメです。 特に、コーディング用に Vim を使っているようなケースでは、列方向のハイライト (cursorcolumn) を有効にしておくと、インデントのずれなどを発見しやすくなります。
背景色を変更したい場合は次のカラーグループを設定します。
:highlight CursorLine guibg=#0000A0 ctermbg=blue :highlight CursorColumn guibg=#0000A0 ctermbg=blue</description></item><item><title>Vim/Neovim で行番号を表示する (set number, vim.opt.number)</title><link>https://maku77.github.io/p/t8o6tum/</link><pubDate>Wed, 09 Sep 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/t8o6tum/</guid><description>行番号の表示・非表示 Vim の場合 (set number) Vim で各行の行頭に行番号を表示するには、:set number を実行します。 逆に、行番号を非表示にするには、:set nonumber を実行します（デフォルト）。 常にこの設定を有効化しておきたいときは、設定ファイル ~/.vimrc（Neovim なら ~/.config/nvim/init.vim）に次のように記述しておきます。
~/.vimrc set number &amp;#34;Print the line number in front of each line. Neovim の場合 (vim.opt.number) Neovim の init.lua で行番号の表示・非表示の設定を行う場合は、vim.opt.number をセットします。
~/.config/nvim/init.lua vim.opt.number = true -- 行番号を表示する 行番号のカラー設定 (highlight LineNr) Vim で行番号の背景色や文字色を変更するには highlight (hi) コマンドで、カラーグループ LineNr を設定します。
:highlight LineNr guifg=Black guibg=DarkGray ctermfg=Black ctermbg=DarkGray</description></item><item><title>Vim で編集中のファイルと拡張子だけが異なるファイルを開く（Hello.cpp を編集中に Hello.h を開く）</title><link>https://maku77.github.io/p/j3w2dpc/</link><pubDate>Wed, 22 Jul 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/j3w2dpc/</guid><description>例えば、現在 Hello.cpp という名前のファイルを編集しているときに、:e[dit] コマンドで Hello.h という拡張子部分だけが異なるファイルを開きたくなったときは、以下のように開くことができます。
:e %&amp;lt;.h %&amp;lt; は、現在編集中の ファイルの名前から拡張子を除いた部分 に置換されます（ちなみに単純に % とすると、ファイル名全体になります）。
次のいずれかの方法で値を確認できます。
:!echo %&amp;lt; :echo expand(&amp;#39;%&amp;lt;&amp;#39;) Hello.cpp というファイルを編集中であれば、%&amp;lt; は Hello となるため、下記 2 つは同じ結果になります。
:e %&amp;lt;.h :e Hello.h この例のようにファイル名が短いときはあまり意味がないかもしれませんが、ファイル名が長いときには便利です。 ここでは :e[dit] コマンドの例を示しましたが、他のコマンドでも % や %&amp;lt; を使ってファイル名を参照することができます。
例: 現在編集中のファイルのファイル名に .back をつけてバックアップ :w %.back</description></item><item><title>Vim でステータスラインの表示内容を設定する (statusline, laststatus)</title><link>https://maku77.github.io/p/oegfris/</link><pubDate>Fri, 06 Feb 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oegfris/</guid><description> Vim 画面下部のステータスラインには、編集中のファイル名や、カーソル位置の情報などを表示することができます。
ステータスラインのヘルプを表示する :help &amp;#39;statusline&amp;#39; ☝️ ワンポイント オプションに関するヘルプを参照するときは、正式には上記のようにパラメータをシングルクォートで囲んで指定します。ただし、statusline に関してはシングルクォートで囲まなくても同じ項目が表示されます。 ステータスラインに表示する内容を設定する :set statusline {format} :set laststatus=2 &amp;#34;常に Status Line を表示する ステータスラインはデフォルトではウィンドウを分割したときにしか表示されないので、上記では laststatus の値を 2 に設定して常に表示するようにしています。 逆に、ステータスラインを常に非表示にしたいときは次のようにします。
:set laststatus=0 設定例 (vimrc) set statusline=%F%m%h%w\ %&amp;lt;[ENC=%{&amp;amp;fenc!=&amp;#39;&amp;#39;?&amp;amp;fenc:&amp;amp;enc}]\ [FMT=%{&amp;amp;ff}]\ [TYPE=%Y]\ %=[CODE=0x%02B]\ [POS=%l/%L(%02v)] 上記で設定しているパラメータは次のように具体的な値に置換されて表示されます。
%F &amp;hellip; ファイルのフルパス。 %m &amp;hellip; 編集されているなら [+]。リードオンリーなら [-]。 %h &amp;hellip; Help buffer なら [HELP] と表示。 %w &amp;hellip; Preview window なら [PREVIEW] と表示。 %&amp;lt; &amp;hellip; ウィンドウの横幅が縮まってもここまでは表示することを保証。 %{&amp;amp;fenc!=''?&amp;amp;fecn:&amp;amp;enc} &amp;hellip; fileencoding が設定されていればその値、設定されていなければ encoding を表示。 %{&amp;amp;ff} &amp;hellip; fileformat の値を表示。%{&amp;amp;fileformat} の省略形。(dos, unix, mac) %Y &amp;hellip; filetype の値を表示。通常はこれに対応する syntax file が読み込まれているはず。 %02B &amp;hellip; カーソル位置の文字コードを16進数で表示。 %l &amp;hellip; カーソル位置の行番号。 %L &amp;hellip; ファイルの行数。 %02v &amp;hellip; カーソル位置の桁番号。</description></item><item><title>Vim/Neovim で全角スペースを見えるように表示する</title><link>https://maku77.github.io/p/preoa93/</link><pubDate>Tue, 03 Feb 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/preoa93/</guid><description>全角スペースを表示するための設定 Vim の設定ファイルに下記のように記述しておくと、全角スペースに背景色が付いて判別できるようになります。 ここでは、GVim の場合に背景色として darkgray を指定していますが、好みの背景色に変更して適用してください。
Vim (~/.vimrc) の場合 &amp;#34; Show double byte spaces hi DoubleByteSpace term=underline ctermbg=blue guibg=darkgray match DoubleByteSpace /　/ Neovim (~/.config/nvim/init.lua) の場合 -- Show double byte spaces vim.cmd[[ hi DoubleByteSpace term=underline ctermbg=blue guibg=darkgray match DoubleByteSpace /　/ ]] 参考 制御文字（改行、タブ文字、行末のスペースなど）を表示する (list, listchars)</description></item><item><title>Vim/Neovim のキーマップ例: ショートカットキーでタブを切り替える</title><link>https://maku77.github.io/p/ksmwhv8/</link><pubDate>Tue, 03 Feb 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ksmwhv8/</guid><description>Vim で :tabnew を使ってタブを開いた後は、タブの切り替えを :tabnext、:tabprevious を使って行いますが、いちいちこのコマンドを入力するのは面倒なので、ショートカットキーでタブの切り替えを行えるようにしてみます。 ここでは、Ctrl + J か Ctrl + H で前のタブへ移動、Ctrl + K か Ctrl + M で後ろのタブへ移動できるように設定しています。 ブラウザのタブ切り替えのように、Ctrl + TAB や Ctrl + Shift + TAB を割り当てることも可能ですが、これらのキーコンビネーションは端末によっては機能しないことがあります。
Vim の場合 ~/.vimrc &amp;#34; Change the tab nmap &amp;lt;C-Tab&amp;gt; :tabnext&amp;lt;CR&amp;gt; nmap &amp;lt;C-l&amp;gt; :tabnext&amp;lt;CR&amp;gt; nmap &amp;lt;C-k&amp;gt; :tabnext&amp;lt;CR&amp;gt; nmap &amp;lt;C-S-Tab&amp;gt; :tabprevious&amp;lt;CR&amp;gt; nmap &amp;lt;C-j&amp;gt; :tabprevious&amp;lt;CR&amp;gt; nmap &amp;lt;C-h&amp;gt; :tabprevious&amp;lt;CR&amp;gt; ちなみに、nmap ではノーマルモード用のキーマップ設定を行います。 インサートモードでも同様にタブ切り替えを行えるようにするには、下記のように追加で imap でキーマップ定義を行います。
&amp;#34; Change the tab (for insert mode) imap &amp;lt;C-Tab&amp;gt; &amp;lt;ESC&amp;gt;:tabnext&amp;lt;CR&amp;gt; imap &amp;lt;C-l&amp;gt; &amp;lt;ESC&amp;gt;:tabnext&amp;lt;CR&amp;gt; imap &amp;lt;C-k&amp;gt; &amp;lt;ESC&amp;gt;:tabnext&amp;lt;CR&amp;gt; imap &amp;lt;C-S-Tab&amp;gt; &amp;lt;ESC&amp;gt;:tabprevious&amp;lt;CR&amp;gt; imap &amp;lt;C-j&amp;gt; &amp;lt;ESC&amp;gt;:tabprevious&amp;lt;CR&amp;gt; imap &amp;lt;C-h&amp;gt; &amp;lt;ESC&amp;gt;:tabprevious&amp;lt;CR&amp;gt; ただし、インサートモードでは、Ctrl + H はデフォルトで BackSpace としてマッピングされているので、その機能を上書きしてまでキーマッピングを行うほどのものではないでしょう。 nmap を使ってノーマルモードのマッピングをしておくだけで十分便利です。</description></item><item><title>Vim の検索に関する設定 (ignorecase, smartcase, wrapscan, hlsearch, incsearch)</title><link>https://maku77.github.io/p/v4cuc9g/</link><pubDate>Thu, 29 Jan 2009 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v4cuc9g/</guid><description>大文字・小文字の区別 (ignorecase) /{pattern} によるカレントファイル内の検索や、:vimgrep による grep 検索では、デフォルトでは大文字・小文字を区別 してパターンマッチングが行われます。 ignorecase オプションを設定すると、大文字・小文字を区別せずに検索できるようになります。
:set ignorecase &amp;#34;大文字・小文字を区別しないで検索 :set noignorecase &amp;#34;大文字・小文字を区別して検索 (default) ignorecase に加えて smartcase オプションを設定すると、検索パターンに大文字を含むときだけ大文字・小文字を区別して検索できるようになります。オススメです。
:set ignorecase smartcase &amp;#34; 検索パターンに大文字を含むときだけ大文字・小文字を区別して検索 ファイル末尾まで検索したら先頭から検索 (wrapscan) n キーを連打して検索パターンにヒットした箇所に次々とジャンプしていくとき、デフォルトでは最後にヒットした文字列まで到達すると、次はファイルの先頭に戻って検索されます。 nowrapscan オプションを設定しておくと、ファイルの末尾でカーソルのジャンプが停止します（下まで検索しましたが該当箇所はありません と表示されます）。
:set wrapscan &amp;#34;折り返し検索 ON (default) :set nowrapscan &amp;#34;折り返し検索 OFF 検索結果のハイライト (hlsearch) hlsearch オプションがセットされた状態で検索を行うと、検索にヒットした部分がすべてハイライト表示されるようになります。
:set hlsearch &amp;#34;検索結果のハイライト ON :set nohlsearch &amp;#34;検索結果のハイライト OFF (default) hlsearch オプションを設定していると、検索結果のハイライト表示が出っぱなしになって邪魔になることがあります。 その場合は、次のコマンドを実行してハイライト表示を消すことができます。
検索結果のハイライトをクリア :nohl &amp;#34; nohlsearch の省略形 オプション名とコマンド名が nohlsearch で同じなので混同しないようにしてください。
インクリメンタル・サーチを有効にする (incsearch) incsearch オプションがセットされた状態で検索を行うと、検索パターンを 1 文字入力するたびに検索結果がリアルタイムに表示されるようになります。 このインクリメンタル・サーチは便利ですが、パターン入力中にカーソル位置がジャンプしてしまうので、慣れるまで戸惑うことがあります。</description></item><item><title>Vim のアンドゥ操作とリドゥ操作 (u, Ctrl-r, undolevels)</title><link>https://maku77.github.io/p/rihibef/</link><pubDate>Thu, 13 Nov 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rihibef/</guid><description>アンドゥ／リドゥの操作方法 Vim でアンドゥ (Undo) 操作、リドゥ (Redo) 操作を行うには、下記のコマンドを使用します。
u &amp;hellip; アンドゥ Ctrl-r &amp;hellip; リドゥ（アンドゥによって取り消された操作を復旧） アンドゥ回数の設定 アンドゥ操作のレベル（制限回数）を変更するには undolevels オプションを設定します。
:set undolevels=300 Linux や Windows では、undolevels の規定値は 1000 なので、通常は変更する必要はないでしょう。</description></item><item><title>Vim でカーソル位置の数字をインクリメント／デクリメントする</title><link>https://maku77.github.io/p/in6mo7q/</link><pubDate>Wed, 12 Nov 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/in6mo7q/</guid><description>カーソル位置の数字をインクリメント／デクリメントする 数字を表すテキストにカーソルを合わせて CTRL-A と入力すると、その数値をインクリメントする（数字を1つ増やす）ことができます。 逆に CTRL-X でデクリメントする（数字を1つ減らす）ことができます。
CTRL-A: カーソル位置の数値をインクリメントする CTRL-X: カーソル位置の数値をデクリメントする 数値のプレフィックスに 0 が付いていれば 8 進数、0x や 0X が付いていれば 16 進数とみなしてインクリメント／デクリメントしてくれます。 例えば、10進数、8進数、16進数と思われる数値は、それぞれ下記のようにインクリメントされます。
17 → 18 017 → 020 0xFF → 0x100 CTRL-A、CTRL-X コマンドのプレフィックスとして数値を与える（先に数値を入力する）と、その数値分だけ足したり引いたりすることができます。
選択範囲の数字をまとめてインクリメント／デクリメントする SHIFT-V や CTRL-V のビジュアルモードで選択した範囲にある数値をまとめてインクリメントすることもできます。 下記のデモでは、SHIFT-V で複数行を選択してから、CTRL-A で複数の数値をまとめてインクリメントしています。
応用例として、CTRL-A と入力する前に g を入力しておくと、次のようにそれぞれの数値に足される数自体がインクリメントされていきます。 連番からなる数値の羅列を作りたいときに便利です。</description></item><item><title>Vim/Neovim で GUI モード用のフォントを設定する (guifont)</title><link>https://maku77.github.io/p/e3xdbxe/</link><pubDate>Mon, 12 May 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/e3xdbxe/</guid><description>フォント設定ダイアログを開く nvim-qt や gVim などの GUI モードで動作する Vim/Neovim 環境では、次のようにフォント設定ダイアログを開くことができます。
:set guifont=* ターミナル上で vim や nvim を動かしているときは、そのターミナルで設定されているフォントがそのまま使われるので、この設定は必要ありません。
ダイアログでフォントの設定を行った後は、
set guifont? として guifont オプションに具体的にどのような設定値が格納されているかを確認することができます。 この設定値を、設定ファイルに記述しておけば、次回の起動時からは自動的にそのフォント設定が反映されます。
設定ファイルでフォントを指定する Neovim (nvim-qt) の場合 GUI モードの Neovim（nvim-qt など）のフォントを設定するには、コマンドラインモードでの :set guifont=Consolas:h14 に相当する下記のようなコードを実行すれば OK です。
Neovim (~/.config/nvim/init.lua) の場合 vim.o.guifont = &amp;#34;Consolas:h14&amp;#34; 現在の環境が GUI モードで動作しているかどうかを調べるには、vim.fn.has('gun_running') の値が 1 かどうかをチェックします。 下記は、HackGen フォントを使用するように設定した例です。
Neovim (~/.config/nvim/init.lua) の場合 -- -- GUI モード（nvim-qt など）のフォント設定 -- -- 白源フォント (HackGen Console NF) を下記からダウンロードしておく。 -- Nerd Fonts が組み込まれているのでリッチな UI 表示に使える。 -- https://github.</description></item><item><title>Vim で記号（引用符など）で囲まれた範囲のテキストを削除する</title><link>https://maku77.github.io/p/bbsprto/</link><pubDate>Sun, 06 Apr 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bbsprto/</guid><description>引用符で囲まれた文字を一気に削除する 例えば、以下のようなテキストがあった場合、
AAA &amp;#34;BBB&amp;#34; CCC カーソルを &amp;quot;BBB&amp;quot; のどこかに合わせた状態で、
di&amp;quot; と入力すると、ダブルクォート (&amp;quot;) で囲まれた文字列 BBB を全て削除することが出来ます。
da&amp;quot; とすると、ダブルクォート (&amp;quot;) まで含めて削除することができます。
補足メモ 最初の文字を c、y、v に変えることにより入力モード、ヤンク、リージョン選択へ変化する。 1文字目 (d, c, y, v) の次の i&amp;quot; とか a&amp;quot; の部分は範囲を示す text-object というものである。 詳しくは :h text-objects で確認できる。</description></item><item><title>Vim でスワップファイルからファイルを復旧する (:recover)</title><link>https://maku77.github.io/p/z8fh4xj/</link><pubDate>Wed, 02 Apr 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/z8fh4xj/</guid><description>スワップファイルの扱い方 Vim でファイルを開くと、一時的に編集内容を保持するためのスワップファイルが作成されます。 デフォルトでは、sample.txt のスワップファイル名は .sample.txt.swp になります。 Vim を終了すると、スワップファイルは自動的に削除されます。
以下のようなケースの場合、Vim でファイルを開いたときに前回作成されたスワップファイルが残っている可能性があります。
別の Vim で同じファイルを開いている。 前回の編集中に Vim がクラッシュした。 このような場合は、編集開始時に、「読み込み専用で開く」、「復活させる」、といった選択肢が表示されるので、適切な処理を選択してください。 例えば、別の Vim で同時編集しているような場合は、読み込み専用で開くのがよいでしょう。
スワップファイルからのファイルの復旧を明示的に実行するには下記のようにします。
:recover sample.txt あるいは、起動時に -r オプションを指定します。
$ vim -r sample.txt スワップファイルの名前を確認する 現在編集中のファイルに対応するスワップファイルの名前は、下記のようにして確認することができます。
:swapname スワップファイルに直ちに書き込む スワップファイルへの書き込みは、時間、あるいはタイプ数によって自動的に実行されますが、明示的に書き込みを実行することもできます。
:preserve 参考 Vim でバックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile)</description></item><item><title>Vim設定: バックアップファイル／スワップファイル／アンドゥファイルの設定 (backup, swapfile, undofile)</title><link>https://maku77.github.io/p/xv4yhu2/</link><pubDate>Wed, 02 Apr 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xv4yhu2/</guid><description>バックアップファイルの設定 Vim には、編集中のファイルを自動でバックアップするための機能が付いています（デフォルトではバックアップ機能 Off になっています）。 バックアップを有効に設定した状態で、例えば、sample.txt というファイルを保存すると、同じディレクトリに sample.txt~ というバックアップファイルが生成されます。
バックアップの ON/OFF (backup, nobackup) バックアップの On/Off を切り替えるには以下のようにします。
:set backup &amp;#34;バックアップファイルを生成する :set nobackup &amp;#34;バックアップファイルを生成しない（デフォルト） 現在の設定は、:set backup? で確認することができます。
バックアップディレクトリの設定 (backupdir) バックアップファイルは、デフォルトでは編集中のファイルと同じディレクトリに作成されますが、このディレクトリは自由に変更することができます。 バックアップファイルを保存するディレクトリの設定は、backupdir オプションで行います。 ディレクトリ候補をカンマ (,) で区切って複数指定することができます。
バックアップディレクトリの設定例 :set backupdir=.,~/tmp,~/ &amp;#34;デフォルトの設定（カレントディレクトリに作られる） :set backupdir=~/temp/backup/ :set backupdir=D:/y/backup/vim,C:/tmp,C:/temp backup オプションを設定してあっても、この backupdir が指定されていないとバックアップファイルは生成されません。 backupdir には、存在するディレクトリを指定しておく必要があります。 存在しないディレクトリを指定すると、ファイルを保存したときに、**「E510: バックアップファイルを作れません」**というエラーが発生します。
backupdir をカレントディレクトリ以外の特定のディレクトリに設定した場合は、同じファイル名のファイルを編集して保存すると、バックアップディレクトリにあるバックアップファイルは上書きされます。
バックアップファイル名のプレフィックスを変更する (backupext) :set backupext=.back 上記のように設定しておくと、sample.txt のバックアップファイル名は sample.txt~ ではなく、sample.txt.back になります。
スワップファイルの設定 Vim はデフォルトで、ファイルをオープンしたときに、.＜ファイル名＞.swp というスワップファイルを同じディレクトリに作成します。 これは、万が一 Vim がクラッシュしたときに備えるためのものです。 正常に Vim を閉じた場合は、スワップファイルは自動的に削除されます。</description></item><item><title>Vim でファイルのエンコーディング形式、改行コードを変更する (fenc, ff)</title><link>https://maku77.github.io/p/g2qyu9b/</link><pubDate>Fri, 01 Feb 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/g2qyu9b/</guid><description>改行コードの変更 Vim でファイルの改行コードを変更するには、次のように fileformat (ff) オプションの値を設定してから :w で保存します。
:set ff=unix &amp;#34;&amp;lt;NL&amp;gt; :set ff=dos &amp;#34;&amp;lt;CR&amp;gt; &amp;lt;NL&amp;gt; :set ff=mac &amp;#34;&amp;lt;CR&amp;gt; 現在の改行コードは以下のように確認できます。
:set ff? 新規ファイルを作成したときの改行コード 新規ファイルを :vi new.txt というように作成する場合、デフォルトの改行コードは fileformats オプションの先頭に記述されたフォーマットになります（末尾に s が付くことに注意）。 例えば、以下のように .vimrc ファイルに記述されていると、新規ファイルの改行コードのフォーマットは UNIX 形式 (NL) になります。
~/.vimrc set fileformats=unix,dos,mac また、この設定は、既存のファイルを開くときに認識する改行コードのリストとしても使用されます。 DOS 形式 (CR+NL) の改行コードで保存されたテキストファイルを開くとき、fileformats に unix としか設定されていない場合は、unix 形式の改行コードで開かれてしまうので注意してください。 なので、通常は上記のように扱う可能性のある改行コードを列挙しておきます。
エンコーディング形式の変更 現在編集中のファイルのエンコーディング形式を変更するには、
:set fenc=utf-8 :set fenc=euc-jp :set fenc=shift_jis のように現在の fileencoding (fenc) オプションを変更し、:w で保存します。 指定できるエンコーディング形式名の一覧は、:help encoding-values で確認することができます。
新規ファイルを作成したときのエンコーディング形式 fileencoding は、ファイルを保存するときに使用されるエンコーディング形式の設定ですが、新しいファイルを :vi new.</description></item><item><title>Vim で補完機能を使用してテキストを入力する</title><link>https://maku77.github.io/p/qmuxpqp/</link><pubDate>Fri, 01 Feb 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qmuxpqp/</guid><description>前後のテキストから補完候補を探して補完入力する 入力モードでテキストを途中まで入力し、以下のように入力すると、前後のテキストを検索して、一致する文字列を補完入力してくれます。
CTRL-P &amp;#34;前方検索して補完 CTRL-N &amp;#34;後方検索して補完 CTRL-Y &amp;#34;決定 補完候補のテキストは、デフォルトでは以下の場所から順番に検索されます。
カレントバッファ 他のウィンドウのファイル カレントバッファ以外のバッファ アンロードされたバッファ tags ファイル インクルードされているファイル（#include で指定されているファイル） 補完候補の検索先を変更するには、complete オプションを設定します。
:set complete=.,w,b,u,t,i &amp;#34;Default 検索先は、以下のキーを優先順にコンマで区切って指定します。
. カレントバッファから検索 ( &amp;#39;wrapscan&amp;#39; の値は無視) w 別のウィンドウ内のバッファから検索 b バッファリスト内の、現在読み込まれている別のバッファから検索 u バッファリスト内の、現在読み込まれていない別のバッファから検索 U バッファリストにないバッファから検索 k &amp;#39;dictionary&amp;#39; で指定されたファイルから検索 kspell 現在有効化されているスペルチェックを使う k{dict} {dict} で与えられたファイルから検索。&amp;#34;k&amp;#34; を複数指定してもよい。 ファイル名はパターンでも指定できる。例: :set cpt=k/usr/dict/*,k~/spanish s &amp;#39;thesaurus&amp;#39; で指定されたファイルから検索 s{tsr} {tsr} で与えられたファイルから検索。 &amp;#34;s&amp;#34; を複数指定してもよい。 ファイル名はパターンでも指定できる。 i カレントファイルとインクルードされるファイルから検索 d カレントファイルとインクルードされるファイルから、 定義された名前またはマクロを検索 ] タグ補完 t &amp;#34;]&amp;#34; と同じ 詳しくは、:help 'complete' で確認することができます。</description></item><item><title>Vim でテキストを中央寄せ／左寄せ／右寄せする</title><link>https://maku77.github.io/p/sh79ewb/</link><pubDate>Tue, 15 Jan 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/sh79ewb/</guid><description>テキストの中央／左／右寄せ 指定した範囲のテキストをセンタリングするには、ex コマンドの :center を使用します。 同様に、右寄せは :right、左寄せは :left で実行できます。
:[range] center [width] :[range] right [width] :[range] left [margin] テキスト幅を示す width オプションを省略した場合は、textwidth の値が使用されます。 textwidth が設定されていない場合は、デフォルトで 80 が使用されます。
:left の場合だけは、左端からのマージンを指定できます。
例: テキスト全体をセンタリング（テキスト幅は 80 とする） :% center 80 例: 1 行目から 5 行目までを右寄せ（テキスト幅は 80 とする） :1,5 right 80 ビジュアルモードで選択した範囲を左寄せ（左端からのマージン 5 文字分） :`&amp;lt;,`&amp;gt; left 5 テキストの両端揃え Vim に付属している justify.vim マクロパッケージを使用すると、テキストの両端揃えを実行できます。 justify.vim は以下のようにロードします。
:source $VIMRUNTIME/macros/justify.vim ビジュアルモードで範囲選択し、以下のコマンドを入力すると、両端揃えが実行されます。
_j</description></item><item><title>Vim で指定した行範囲だけ別のファイルに保存する</title><link>https://maku77.github.io/p/zmnwu3z/</link><pubDate>Tue, 15 Jan 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zmnwu3z/</guid><description>指定した行範囲を別ファイルに保存 行範囲を指定して :write コマンド（省略形は :w）を使用すると、その範囲だけを抽出して別のファイルに保存することができます。
:[range] write &amp;lt;filename&amp;gt; 例: 行番号で指定した反荷を file.txt に保存 :1,5 w file.txt &amp;#34; 1行目から5行目まで保存 :5,$ w file.txt &amp;#34; 5行目から最後まで保存 :.,10 w file.txt &amp;#34; カレント行から10行目まで保存 :.;+5 w file.txt &amp;#34; カレント行から5行下の行までを保存 :g/^Todo/ w D:\todo.txt &amp;#34; Todo で始まる行を D:\todo.txt に保存 ビジュアルモードで選択した範囲を別ファイルに保存 上記は、保存する行範囲を行番号などで指定する方法ですが、実際には次のようにしてビジュアルモードで行範囲を選択してしまうのが早いでしょう。
例: ビジュアルモードで選択した範囲を file.txt に保存 SHIFT-V の行選択モードなどで行を選択 :w file.txt と入力して Enter</description></item><item><title>Vim で文字を入れ替える、行を入れ替える（スワップ操作）</title><link>https://maku77.github.io/p/xr9stqi/</link><pubDate>Tue, 15 Jan 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xr9stqi/</guid><description>下記は Vim の基本的な編集コマンドの組み合わせ技ですが、使用頻度の高い編集操作なので押さえておきましょう。
文字のスワップ カーソル位置の文字を、1つ後ろの文字と素早く入れ替えるには以下のように実行します。
xp x で一文字削除し、p でその文字を後ろに貼り付け、という操作をしているだけです。
行のスワップ カーソル行を、1つ下の行と素早く入れ替えるには以下のように実行します。
ddp dd で一行削除し、p でその行を下に貼り付け、という操作をしているだけです。</description></item><item><title>Vim のビジュアルモードの基本 (v, Shift-v, Ctrl-v)</title><link>https://maku77.github.io/p/iumn4xs/</link><pubDate>Tue, 15 Jan 2008 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/iumn4xs/</guid><description>ビジュアルモードの開始・終了 ビジュアルモードは、Vim においてテキストの範囲選択を行うためのモードです。 ノーマルモードで下記のようなコマンドを入力することでビジュアルモードに入ることができます。
入力 説明 v ビジュアルモード（文字単位） Shift-v ビジュアルラインモード（行単位） Ctrl-v ビジュアルブロックモード（矩形） ビジュアルモードを抜けてノーマルモードに戻るには、Esc を押すか、何かコマンドを実行します（d で削除するなど）。 コマンドを実行した場合は、選択した範囲に対してコマンドが適用されます。
ビジュアルモードの選択範囲を拡張する カーソル移動で拡張する ビジュアルモードに入った後で o を入力することで、カーソル位置を選択領域の先頭、末尾へ交互に移動することができます。 この状態でカーソルを動かすと、選択領域を自在に伸縮させることができます。
ルールに応じて拡張する ビジュアルモードに入った後で、下記のような操作を行うと、ルールに従って選択範囲を拡張することができます。
入力 説明 ip カーソル位置の段落全体を選択 ap カーソル位置の段落全体を選択（後続の空行も含めて選択） iw カーソル位置の単語全体を選択 aw カーソル位置の単語全体を選択（後続のスペースも含めて選択） i( 括弧 () に囲まれた領域を選択 a( 括弧 () に囲まれた領域を選択（括弧も含めて選択） i{ 括弧 {} に囲まれた領域を選択 a{ 括弧 {} に囲まれた領域を選択（括弧も含めて選択） i[ 括弧 [] に囲まれた領域を選択 a[ 括弧 [] に囲まれた領域を選択（括弧も含めて選択） i&amp;lt; 括弧 &amp;lt;&amp;gt; に囲まれた領域を選択 a&amp;lt; 括弧 &amp;lt;&amp;gt; に囲まれた領域を選択（括弧を含めて選択） 例えば、ビジュアルモードで段落全体（空行で区切られた連続する行）を一気に選択するには、その段落内にカーソルがある状態で ip と入力します。 ノーマルモードから段落全体を選択状態にするには vip と入力すればよいことになります（上のデモアニメを参照）。 「段落選択はビップ」と覚えます。</description></item><item><title>Vim で省略形を用いたテキスト入力を行えるようにする (abbrevaite)</title><link>https://maku77.github.io/p/qxjtb39/</link><pubDate>Wed, 26 Dec 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qxjtb39/</guid><description>省略形を登録する Vim の :abbreviate (:ab) コマンドを使うと、テキストの省略形を定義することができます。 省略形のテキストを入力して Space や TAB、Enter キーを押すと、自動的に展開してくれます。
:abbreviate ＜省略形＞ ＜展開後のテキスト＞ 例: YT と入力したら、自動的に Yamada Taro に展開 :ab YT Yamada Taro 展開後のテキストの先頭文字が Space の場合 :abbreviate で指定する展開後のテキストの先頭文字に半角スペースを指定する場合は、その半角スペースが Vim に無視されてしまわないように、明示的に &amp;lt;Space&amp;gt; と記述する必要があります。
:ab hghg &amp;lt;Space&amp;gt;HogeHoge 省略形の一覧表示 登録済みの省略形を一覧表示するには、:abbreviate (:ab) コマンドをパラメータなしで実行します。
:abbreviate</description></item><item><title>Vim/Neovim で設定ファイル (.vimrc, init.lua) を開く、リロードする</title><link>https://maku77.github.io/p/zneoq8d/</link><pubDate>Wed, 26 Dec 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/zneoq8d/</guid><description>設定ファイルを開く Vim の場合 Vim エディタから設定ファイル（.vimrc や .gvimrc）を開くには、下記のようにします（:e は :edit コマンドの省略系です）。
設定ファイルを開く（OS に依存しない方法） :e $MYVIMRC :e $MYGVIMRC 設定ファイルの名前は Linux (.vimrc) と Windows (_vimrc) で微妙に異なりますが、実際に読み込まれた設定ファイルのパスが $MYVIMRC、$MYGVIMRC という変数に格納されているので、上記のようにして OS に依存しない方法で設定ファイルを開くことができます（:echo $MYVIMRC でパスを確認できます）。
明示的にファイルパスを指定して開きたいときは次のようにします。
Vim の設定ファイルを開く（Linux/macOS の場合） :e ~/.vimrc :e ~/.gvimrc Vim の設定ファイルを開く（Windows の場合） :e ~/_vimrc :e ~/_gvimrc Neovim の場合 Neovim の設定ファイル (init.lua or init.vim) を開くには次のようにします。
Neovim の設定ファイルを開く（OS に依存しない方法） :e $MYVIMRC Neovim は、設定ファイルとして init.lua と init.vim のどちらかを使うことができます（init.lua が優先されます）。 実際に読み込まれた設定ファイルのパスが $MYVIMRC に格納されるので、上記のように設定ファイルを開くことができます（:echo $MYVIMRC でパスを確認できます）。
明示的にファイルパスを指定して init.</description></item><item><title>Vim/Neovim の設定ファイルのパスを確認する ($MYVIMRC)</title><link>https://maku77.github.io/p/7mabuvq/</link><pubDate>Wed, 26 Dec 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7mabuvq/</guid><description>設定ファイルのパスを調べる Vim や Neovim の設定ファイル（やディレクトリ）のパスは、:echo コマンドを使って以下のように確認することができます。
Vim の場合: :echo $MYVIMRC
出力例: C:\Users\maku\_vimrc （Windows の場合）
出力例: /Users/maku/.vimrc （Linux/macOS の場合） :echo $MYGVIMRC
出力例: C:\Users\maku\_gvimrc （Windows の場合）
出力例: /User/maku/.gvimrc （Linux/macOS の場合） Neovim の場合（init.lua と init.vim のうち実際に読み込まれたファイルのパス）: :echo $MYVIMRC or :=vim.env.MYVIMRC
出力例: C:\Users\maku\AppData\Local\nvim\init.lua （Windows の場合）
出力例: /Users/maku/.config/nvim/init.lua （Linux/macOS の場合） また、nvim ディレクトリのパスは、以下のように確認できます。
:echo stdpath('config')
出力例: C:\Users\maku\AppData\Local\nvim （Windows の場合）
出力例: /Users/maku/.config/nvim （Linux/macOS の場合） デフォルトのパス デフォルトでは、次のようなファイルパスに置かれた設定ファイルが読み込まれます。
Vim の場合 Windows の場合: %USERPROFILE%/_vimrc （ただし HOME 環境変数が設定されている場合は %HOME%/_vimrc） Linux/macOS の場合: ~/.</description></item><item><title>Vim で C/C++ の変数／マクロの定義位置にジャンプする</title><link>https://maku77.github.io/p/96itrdp/</link><pubDate>Wed, 21 Nov 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/96itrdp/</guid><description>C/C++ の変数／マクロの定義位置にジャンプ 変数にカーソルを当てた状態で、以下のように入力すると、その変数の定義位置にジャンプすることができます。
コマンド 説明 gd ローカル変数の定義位置へジャンプ gD グローバル変数の定義位置へジャンプ 検索の精度はあまり高くありません。。。
C/C++ のマクロの定義を表示／定義位置へジャンプ C/C++ のマクロは次のような感じで定義されます。
#define BUF_SIZE 256 マクロを使用している場所から、そのマクロの定義（上記のコード）を調べるには、マクロ名にカーソルを当てた状態で次のように入力します。 #include されているファイルの内容も検索してくれます。
コマンド 説明 [D マクロの定義を表示（すべての定義を表示） [d マクロの定義を表示（最初の定義のみ） [Ctrl-d マクロの定義位置へジャンプ</description></item><item><title>Vim でカーソル位置の単語に対して任意のコマンド（ヘルプなど）を実行する (keywordprg)</title><link>https://maku77.github.io/p/3hp29j9/</link><pubDate>Wed, 21 Nov 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3hp29j9/</guid><description>Vim で任意のキーワードにカーソルを合わせた状態で SHIFT-K と入力すると、そのキーワードをパラメータにして、keywordprg オプションに設定されたコマンドが実行されます。 keywordprg の初期値は以下のようになっています。
keywordprg オプションのデフォルト値 set keywordprg=man &amp;#34; Unix の場合 set keywordprg=:help &amp;#34; Windows の場合 つまり、Unix の場合は、SHIFT-K と入力するだけでカーソル位置にあるキーワードの man ページを参照することができます。 man ページのセクション番号を指定するには、2 SHIFT-K のように、先にセクション番号を入力します。
どの文字をキーワードとみなすかは、iskeyword オプションに文字コードで設定します。 iskeyword のデフォルト値は下記のような感じになっています。
iskeyword オプションのデフォルト値 set iskeyword=@,48-57,_,128-167,224-235</description></item><item><title>Vim/Neovim で自動インデントモードを有効にする (autoindent, smartindent, cindent)</title><link>https://maku77.github.io/p/oe94dkh/</link><pubDate>Fri, 16 Nov 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oe94dkh/</guid><description>3 種類のインデントモードの設定 Vim には、大きく分けて、以下のようなオートインデント設定があります。
autoindent カレント行のインデントをキープする。シンプル。 smartindent C言語風のプログラミング言語向けの自動インデント。 cindent C言語に特化したインデント（smartindent よりも厳密に文法を考慮） autoindent を有効／無効にする :set autoindent &amp;#34; autoindent を ON :set noautoindent &amp;#34; autoindent を OFF :set autoindent? &amp;#34; autoindent の設定を確認 (autoindent or noautoindent) autoindent の設定を有効にすると、新しい行を追加したときに、前の行のインデントが引き継がれるようになります。 ただそれだけのシンプルなインデントモードです。 新しい行の追加は例えば、以下のような入力があった場合が対象になります。
o コマンド（あるいは O コマンド） インサートモード時の Enter インサートモードのまま、インデントの量を変えるには CTRL-T、CTRL-D などのコマンドを使用します。 下記は、:help index からのキーマップ説明の抜粋です。
i_CTRL-T: 現在の行に shiftwidth 分のインデントを挿入する。 i_CTRL-D: 現在の行から shiftwidth 分のインデントを削除する。 smartindent を有効／無効にする :set smartindent &amp;#34; smartindent を ON :set nosmartindent &amp;#34; smartindent を OFF :set smartindent?</description></item><item><title>Vim でGVim 起動時のウィンドウの幅、高さを設定する (columns, lines)</title><link>https://maku77.github.io/p/syn3cyx/</link><pubDate>Wed, 14 Nov 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/syn3cyx/</guid><description>GVim を起動したときのウィンドウのサイズは、columns オプション（横幅）と、lines オプション（高さ）で指定します。 単位は半角文字の数です。 起動時に読み込まれる ~/.gvimrc に記述してください（Windows の場合は %HOME%\_gvimrc）。
set columns=120 &amp;#34;横幅 set lines=60 &amp;#34;高さ</description></item><item><title>Vim でカーソル位置にマークしてジャンプしてこれるようにする</title><link>https://maku77.github.io/p/i3ao6oc/</link><pubDate>Sun, 07 Oct 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i3ao6oc/</guid><description>Vim のマーク機能を使用すると、カーソル位置に a～z、あるいは A～Z のマークを付け、別の場所からそこへジャンプして来ることができるようになります。
マークを付ける m に続けて、1 文字のアルファベットを入力すると、現在のカーソル位置にマークを設定することができます。
入力 説明 ma カーソル位置をローカルマーク a として保存（a～z を使用可能） mA カーソル位置をグローバルマーク A として保存（A～Z を使用可能） マーク用のアルファベットとして 小文字の a～z を使用すると、カレントバッファのみに有効なローカルマーク として設定されます。 大文字の A～Z を使用すると、グローバルマーク（ファイルマーク） として設定されます。 ローカルマークはファイルごとに a～z を使用することができ、グローバルマークは全体で A～Z を共有することになります。
マークを設定した位置へジャンプする 入力 説明 `a ローカルマーク a へジャンプ 'a ローカルマーク a の行頭へジャンプ `A グローバルマーク A へジャンプ 'A グローバルマーク A の行頭へジャンプ ローカルマーク (a～z) を指定してジャンプするときは、カレントバッファで開いているファイルに設定されたローカルマークがジャンプ先のターゲットとなります。
一方、グローバルマーク (A～Z) は、マークしたファイルまで一緒に記録されており、Vim でどのファイルを編集中であっても、そのファイルにジャンプすることができます。 頻繁に使用するファイルに mA でグローバルマークを設定しておけば、'A でそのファイルをいつでも簡単に開けるようになります。
また、ジャンプ元とジャンプ先で行ったり来たりするために、下記のようなジャンプコマンドを使用することができます。
入力 説明 `` バッファ内のジャンプ元へジャンプ '' バッファ内のジャンプ元の行頭へジャンプ マークの一覧を表示する 現在設定されているローカルマークとグローバルマークの一覧を表示するには、次のコマンドを実行します。</description></item><item><title>Vim でウィンドウを分割する</title><link>https://maku77.github.io/p/ym9pa88/</link><pubDate>Fri, 05 Oct 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ym9pa88/</guid><description>Vim のウィンドウを分割すると、複数のファイルの内容を同時に表示しながら作業することができます。 同一ファイル内の 2 か所を表示することもできます。
ウィンドウを分割する 入力 説明 :sp[lit] 上下に分割（編集中のファイルを開く）。Ctrl-w s としても OK :vs[plit] 左右に分割（編集中のファイルを開く）。Ctrl-w v としても OK :new 上下に分割（空のファイルを開く）。Ctrl-w n としても OK :vnew 左右に分割（空のファイルを開く） :sview [file] 閲覧用にファイルを開く。:split → :view としても OK ウィンドウを閉じる 入力 説明 Ctrl-w q ウィンドウを閉じる。最後のウィンドウであれば Vim を終了 (= :quit) Ctrl-w c ウィンドウを閉じる。最後のウィンドウを閉じることはできない (= :close) Ctrl-w o カレントウィンドウ以外を閉じる ウィンドウを切り替える 入力 説明 Ctrl-w w 次のウィンドウへ移動（★最低限これだけ覚えておく） Ctrl-w h 左のウィンドウへ移動 Ctrl-w j 下のウィンドウへ移動 Ctrl-w k 上のウィンドウへ移動 Ctrl-w l 右のウィンドウへ移動 キーシーケンスの 2 番目のキーは、Ctrl キーを押しながら入力することもできるようになっています。 例えば、Ctrl-w w と入力する代わりに、Ctrl-w Ctrl-w と入力しても OK です。</description></item><item><title>Vim でファイル名を指定してファイルを開く (:e, :edit, :view)</title><link>https://maku77.github.io/p/6aycfga/</link><pubDate>Fri, 05 Oct 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6aycfga/</guid><description>ファイル名を指定してファイルを開く Vim で :edit コマンド（:e と省略可）を使用すると、指定した名前のファイルをカレントバッファで開くことができます。
hoge.txt を開く :e hoge.txt :edit hoge.txt 別のファイルを開く前に、カレントバッファで開いているファイルの編集内容を :w で保存しておく必要があります。 現在の編集を破棄して別のファイルを開きたい場合は、コマンドの後ろに ! を付けて実行します。
:e! hoge.txt :edit! hoge.txt 読み取り専用でファイルを開く :edit コマンドの代わりに、:view コマンドを使用してファイルを開くと、読み取り専用（ReadOnly モード）でファイルを開くことができます。
:view hoge.txt ファイルを開くときは :e コマンドで代用してしまうことが多いので、:view コマンドを使用することはあまりないかもしれません。
☝️ ワンポイント :edit コマンドは :e と 1 文字まで省略することができますが、:view コマンドは :vie までしか省略できません。 詳しくは、:help :view&amp;lt; でヘルプを確認してみてください。</description></item><item><title>Vim/Neovim でタブ文字に関する設定を行う (tabstop, expandtab, softtabstop)</title><link>https://maku77.github.io/p/8okf7d3/</link><pubDate>Wed, 11 Apr 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8okf7d3/</guid><description>タブ文字 1 文字分の表示幅を設定する タブ文字がどれくらいの幅で表示されるかの設定は tabstop オプションで行います。
Vim (~/.vimrc) の場合 :set tabstop=4 &amp;#34;タブ 1 文字の表示幅 (default: 8) Neovim (~/.config/nvim/init.lua) の場合 vim.opt.tabstop = 4 -- タブ 1 文字の表示幅 (default: 8) 例えば、tabstop を 4 に設定すると、ファイル内のタブ文字は 4 文字分のスペースとして表示されます。 この設定は、あくまで見え方の設定であって、タブは 1 文字のタブ文字 (\t) として存在します。 他のエディタでファイルを開くと、タブ文字の見え方は変わってきます。
タブを入力したときにタブ文字の代わりにスペースを挿入する TAB キーを押したときに、タブ文字の代わりに半角スペース x N を入力したいときは、expandtab を有効化します。 さらに、TAB キーを押したときに何文字分の半角スペースを入力するかは、softtabstop で設定します。 softtabstop=4 と具体的な値を設定するのもよいですが、負の値（-1 など）を設定すると、tabstop で設定した値に合わせてくれます。
Vim (~/.vimrc) の場合 :set expandtab &amp;#34;タブキーでスペースを入力する (default: noexpandtab) :set softtabstop=-1 &amp;#34;タブキーで入力するスペース数 (-1: tabstop に合わせる) Neovim (~/.config/nvim/init.lua) の場合 vim.</description></item><item><title>Vim でキーボードマクロを記録して一連のキー入力を繰り返し実行する</title><link>https://maku77.github.io/p/bmriv55/</link><pubDate>Mon, 12 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bmriv55/</guid><description>Vim のノーマルモードで q を入力すると、キーボードマクロの記録モードに入ります。 最初に保存先のレジスタ名称（a-zA-Z0-9 のうち1文字）を入力してから記録させたいテキスト入力を行うと、そのレジスタにマクロとして登録されます。 最後にノーマルモードで再び q を入力すると、キーボードマクロの記録モードが終了します。 登録したキーボードマクロを再生したいときは、@ に続けてレジスタ名を入力します。
qa &amp;hellip; マクロ記録開始（q の後ろは a-zA-Z0-9 のいずれか1文字） q &amp;hellip; マクロ記録終了 @a &amp;hellip; マクロ実行（q の後ろは a-zA-Z0-9 のいずれか1文字） 例: 行頭に // を挿入するキーボードマクロを記録（Java のコメント） qaI// &amp;lt;Esc&amp;gt;q # 記録 @a # 再生 @a などでマクロを再生した後に、さらに続けて同じマクロを実行したい場合は、@a を入力するのではなく、.（ドット）で繰り返し実行すると簡単です。</description></item><item><title>Vim のヘルプコマンドの使い方 (:help, :helpgrep)</title><link>https://maku77.github.io/p/fdep5i7/</link><pubDate>Mon, 12 Mar 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fdep5i7/</guid><description>ヘルプの起動／終了 Vim エディタから下記のコマンドを実行することで、ヘルプを起動・終了することができます。
:help &amp;hellip; ヘルプを起動する :q &amp;hellip; ヘルプを終了する ZZ &amp;hellip; ヘルプを終了する :help コマンドに渡すパラメータ :help コマンドの引数に特定のプレフィックスを付けたり、引数を引用符で囲むことで、異なるモードのコマンドのヘルプを見ることができます。
調べる項目 プレフィックスなど 例 Normal mode のキー入力 なし :help u Insert mode のキー入力 i_ :help i_CTRL-N, :help i_&amp;lt;Esc&amp;gt; Visual mode のキー入力 v_ :help v_u Command mode のキー入力 c_ :help c_&amp;lt;Del&amp;gt; ex コマンド : :help :quit オプション 'name' :help 'number' Vim の起動パラメータ - :help -t 特殊なキー入力は、CTRL-A、&amp;lt;Del&amp;gt;、&amp;lt;Esc&amp;gt; のように表現することができます（他のキーの表現方法は :help keycodes で確認できます）。
例: Ctrl-A（normal mode）のヘルプを表示する :help CTRL-A 例: Ctrl-A（insert mode）のヘルプを表示する :help i_CTRL-A 例: Vim の起動パラメータ -t のヘルプを表示する :help -t 例: number オプションのヘルプを見る :help &amp;#39;number&amp;#39; ヘルプファイルを grep する :helpgrep コマンドを使用すると、ヘルプファイル内を grep 検索することができます。</description></item><item><title>Vim のコマンドモードでのカーソル移動 (Ctrl-B, Ctrl-E, Ctrl-H, Ctrl-U)</title><link>https://maku77.github.io/p/f92ub3d/</link><pubDate>Thu, 22 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f92ub3d/</guid><description>コマンドモードでの入力操作 Vim で :（ex コマンド）や、/ （検索）キーを押すと、コマンドを 1 行だけ入力できるコマンドラインモード（コマンドモード）に入ります。 コマンドモードでは、下記のようなキーシーケンスでカーソル移動や編集操作を行うことができます。
入力 説明 Ctrl-U 行頭まで削除 Ctrl-B 行頭に移動 Ctrl-E 行末に移動 Ctrl-H 1 文字削除 Ctrl-W 1 単号削除 Ctrl-P 1 つ前の履歴を表示 Ctrl-N 1 つ後の履歴を表示 Ctrl-R % ファイル名を挿入（% レジスタ） Ctrl-R * クリップボードの内容を挿入（* レジスタ） Ctrl-R &amp;quot; 最後にヤンクした内容を挿入（&amp;quot; レジスタ） コマンドモードのヘルプ コマンドモードでの入力操作に使えるキーシーケンスのヘルプは次のように確認できます。
入力 説明 :help cmdline-editing コマンドラインの編集操作についてのヘルプ全般 :help c_CTRL-W コマンドモードでの Ctrl-W というキー入力についてのヘルプ :help map-modes キーマッピングについてのヘルプ（コマンドモード用には :cmap や :cnoremap を使う）</description></item><item><title>Vim のコマンドモードで入力補完する (Ctrl-D, Tab)</title><link>https://maku77.github.io/p/ow6rvbz/</link><pubDate>Wed, 21 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ow6rvbz/</guid><description>Vim のコマンドモードでコマンドを入力している最中に、Ctrl-D や Tab を押すと、入力候補の一覧表示や、入力の補完を行うことができます。
例: add を含んでいるパラメータの入力候補を表示 :help add&amp;lt;Ctrl-D&amp;gt; 例: add で始まるパラメータの入力を補完 :help add&amp;lt;TAB&amp;gt;</description></item><item><title>Vim/Neovim でインデント（シフトコマンド）を設定する (shiftwidth, shiftround)</title><link>https://maku77.github.io/p/b5o6ksu/</link><pubDate>Tue, 20 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/b5o6ksu/</guid><description>シフトコマンドで挿入／削除するスペースの量を設定する shiftwidth オプションに設定した値は、&amp;gt;&amp;gt; コマンドなどで行頭に挿入するスペースの数を示します。
:set shiftwidth=4 &amp;#34; デフォルトは 8 タブストップ (tabstop) と混同しがちなので注意してください。 タブストップは、タブ文字を入力した場合に表示位置をどこへずらすかの基準を指定します。 シフトコマンド (&amp;gt;&amp;gt;) に効いてくる値はあくまで shiftwidth の方です。
シフトしたときに shiftwidth の値の倍数になるようにスペースを挿入する シフトコマンド（&amp;gt;&amp;gt; など）を実行すると、行の先頭に shiftwidth で設定した数だけスペースが挿入されます。 このとき、すでに行頭に何文字かのスペースが存在する場合に、スペース数が shiftwidth の倍数になるように調整してスペースを挿入したい場合は、次のように shiftround を有効化します（デフォルトはオフ (noshiftround) です）。
Vim（/.vimrc の場合） :set shiftround &amp;#34;シフトコマンドでのインデント量を丸める Neovim（~/.config/nvim/init.lua の場合） vim.opt.shiftround = true -- シフトコマンドでのインデント量を丸める ほとんどの場合は、行頭からのインデント量は 2 の倍数とか 4 の倍数とかに揃えておきたいはずなので、shiftround はセットしておくことをお勧めします。
参考 自動インデントモードを有効にする (autoindent, smartindent, cindent) インデント用のスペースを入力する（シフトコマンド） (&amp;gt;&amp;gt;, &amp;lt;&amp;lt;, Ctrl-T, Ctrl-D)</description></item><item><title>Vim/Neovim でインデント用のスペースを入力する（シフトコマンド）</title><link>https://maku77.github.io/p/i2m4nqt/</link><pubDate>Tue, 20 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/i2m4nqt/</guid><description>Vim にはインデント用のスペースを簡単に入力するためのシフトコマンドが用意されています。 現在のモードによって下記のように入力します。
コマンドモードのとき &amp;gt;&amp;gt; &amp;hellip; 右へ 1 レベルシフト &amp;lt;&amp;lt; &amp;hellip; 左へ 1 レベルシフト 入力モードのとき Ctrl-T &amp;hellip; 右へ 1 レベルシフト Ctrl-D &amp;hellip; 左へ 1 レベルシフト 0 Ctrl-D &amp;hellip; すべてのインデントを取り除く（いったん 0 が表示されますが、次の Ctrl-D で消えます） 参考 インデント（シフトコマンド）を設定する (shiftwidth, shiftround) 自動インデントモードを有効にする (autoindent, smartindent, cindent) ビジュアルモードで簡単にインデントを行えるようにする</description></item><item><title>Vim で外部の ex スクリプトを実行する</title><link>https://maku77.github.io/p/rocrnht/</link><pubDate>Wed, 14 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rocrnht/</guid><description>Vim エディタでは、複数の ex コマンドを記述したファイル（ex スクリプト）を読み込んで、現在編集中のファイルに対して実行することができます。 下記の ex スクリプト (replace.ex) は、現在編集中のテキストのファイルの AAA を BBB に置換し、保存して終了します。
ex スクリプトの例 (replace.ex) %s/AAA/BBB/g wq この ex スクリプトを実行するには、:source コマンドを使って以下のようにします（省略形は :so** です）。
:so replace.ex Linux には同様のことを行う単独のコマンド ex が標準で付属しています。 Vim を起動しなくても、次のようにして ex スクリプトを任意のファイルに対して実行できます。
$ ex input.txt &amp;lt; replace.ex</description></item><item><title>Vim で同じテキストを指定した回数だけ繰り返し挿入する</title><link>https://maku77.github.io/p/cismh7n/</link><pubDate>Fri, 09 Feb 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cismh7n/</guid><description>i コマンドや o コマンドでインサートモードに入る前に、繰り返しの回数を入力しておくと、Esc でインサートモードを抜けたときに、指定した回数だけ入力したテキストが繰り返し挿入されます。
例: 40個の - を挿入する（罫線のようなもの） 40i-&amp;lt;ESC&amp;gt; 実行結果 ---------------------------------------- 例: 5 行の同じテキストを挿入する 5oあいうえお&amp;lt;ESC&amp;gt; 実行結果 あいうえお あいうえお あいうえお あいうえお あいうえお 上記のように o コマンドを使用すると、同じテキストを 複数行 同時に挿入できます（i コマンドを使うと、同じ行に改行なしで繰り返しテキストが挿入されます）。</description></item><item><title>Vim の ex コマンドでの行範囲指定方法いろいろ</title><link>https://maku77.github.io/p/fw7q8q7/</link><pubDate>Tue, 30 Jan 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fw7q8q7/</guid><description>行範囲指定の基本 Vim の ex コマンドは、: から始めるコマンドモードのことで、各コマンドの先頭には、コマンドをどの行に対して実行するかを示す、行範囲 を指定することができます。
:行範囲 コマンド 行範囲を省略した場合は、コマンドはカレント行にだけ影響を及ぼします。 行範囲に .（ドット）を指定した場合も、同様にカレント行に対してだけ実行されます。
例: カレント行を削除 :d 例: 123 行目を削除 :123 d 例: 10 行目から 20 行目をソート :10,20 sort 行範囲指定の例 行番号ベースで指定する方法 :% &amp;lt;command&amp;gt; &amp;#34; ファイル全体に対して command を実行 :3 &amp;lt;command&amp;gt; &amp;#34; 3 行目に対して command を実行 :3,5 &amp;lt;command&amp;gt; &amp;#34; 3 行目から 5 行目までに対して command を実行 :3,$ &amp;lt;command&amp;gt; &amp;#34; 3 行目から最後の行までに対して command を実行 :. &amp;lt;command&amp;gt; &amp;#34; カレント行に対して command を実行（省略した場合と同様） :.,5 &amp;lt;command&amp;gt; &amp;#34; カレント行から 5 行目までに対して command を実行 :.</description></item><item><title>Vim のカーソル移動方法まとめ</title><link>https://maku77.github.io/p/etvrhdd/</link><pubDate>Tue, 30 Jan 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/etvrhdd/</guid><description>カーソル移動（左右） 入力 説明 h 1 文字左へ l 1 文字右へ 0 行頭へ $ 行末へ 5| カレント行の 5 文字目へ ^ 最初の表示可能な文字へ カーソル移動（行番号指定でジャンプ） 入力 説明 gg
:1 1 行目へジャンプ 10gg
10G
:10 10 行目へジャンプ G
:$ 最終行へジャンプ :$-3 最終行より 3 行上へジャンプ :+10 カレント行から 10 行下へジャンプ 応用例: カーソル位置からファイルの最後までを削除 dG カーソル移動（画面内でジャンプ） 入力 説明 H 画面内の一番上にジャンプ（ホーム行） M 画面内の中央行にジャンプ L 画面内の一番下にジャンプ 3H 画面内の一番上から 3 行目にジャンプ 3L 画面内の一番下から 3 行目にジャンプ カーソル移動（ブロック単位でジャンプ） 入力 説明 w 次の単語の先頭へ W 次の単語の先頭へ（後続する記号も単語の一部とみなす） b 前の単語の先頭へ B 前の単語の先頭へ（後続する記号も単語の一部とみなす） e 単語の末尾へ E 単語の末尾へ（後続する記号も単語の一部とみなす） ( 現在の文の先頭へ ) 次の文の先頭へ { 現在の段落の先頭へ（空行で判断） } 次の段落の先頭へ（空行で判断） [[ 現在のセクションの先頭へ（行頭にある { を検索） ]] 次のセクションの先頭へ（行頭にある { を検索） w や b によるカーソル移動時に、どこまでを単語の切れ目と見なすかは、iskeyword オプションによって設定されています。 現在の設定値を見るには次のようにします。</description></item><item><title>Vim/Neovim の画面スクロール方法まとめ (scroll, scrolljump, scrolloff)</title><link>https://maku77.github.io/p/gu9om5z/</link><pubDate>Tue, 30 Jan 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/gu9om5z/</guid><description>画面スクロール操作 画面スクロール コマンド 説明 Ctrl-f 1 画面下へスクロール Ctrl-b 1 画面上へスクロール Ctrl-d 半画面下へスクロール、あるいは scroll オプションで指定された行数だけ下へスクロール Ctrl-u 半画面上へスクロール、あるいは scroll オプションで指定された行数だけ上へスクロール 表示位置を移動 下記の操作では、カーソル位置（行）をキープしたまま、画面の表示位置だけを移動させます。
コマンド 説明 z&amp;lt;CR&amp;gt; カレント行を画面上端へ ※1 zz カレント行を画面中央へ z. カレント行を画面中央へ（カーソルを最初の非空白文字へ） zb カレント行を画面下端へ z- カレント行を画面下端へ（カーソルを最初の非空白文字へ） z+ 画面下端を画面上端へ（これ使い道ある？） Ctrl-y 1 行下へスクロール Ctrl-e 1 行上へスクロール ※1 例えば、ソースコードの関数名を定義している行で、z [Enter] とすれば、その関数の定義が画面上端から表示されます。 z コマンドは、scrolloff オプションに 0 以外が設定されていると、その値によって移動後の表示位置が少々変わります。
z コマンドを実行するときに数値プレフィックスを付けると、カレント行とみなす行番号を指定することができます。
例: 30 行目が画面上端に表示されるように移動 30z[Enter] 画面スクロール量の設定 (scroll) Ctrl-d や Ctrl-u による画面スクロール行数は、scroll オプションで設定できます。 個人的には、一度に画面半分もスクロールされると脳がついていけないので、3 行くらいのスクロールに変更しておくと使いやすいです。
:set scroll=3 ただし、この設定は Vim エディタのウィンドウサイズを変更したタイミングなどでリセットされてしまいます。 そのため、設定ファイルで scroll オプションを設定するときは、下記のように autocmd を使ってバッファ切り替え時に再設定するようにしておくとよいでしょう。</description></item><item><title>Vim の文字の置換方法まとめ (:s, :substitute)</title><link>https://maku77.github.io/p/f8v2npx/</link><pubDate>Mon, 08 Jan 2007 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f8v2npx/</guid><description>Vim の s (substitute) コマンドを使用すると、ファイル内の任意の範囲のテキストをまとめて置換することができます。
substitute コマンドの基本 substitute コマンドは、ノーマルモード中に下記のように入力して実行します。
:&amp;lt;行範囲&amp;gt; s/&amp;lt;置換前パターン&amp;gt;/&amp;lt;置換後パターン&amp;gt;/&amp;lt;フラグ&amp;gt; 指定した &amp;lt;行範囲&amp;gt; のテキストの中で、&amp;lt;置換前パターン&amp;gt; に一致する文字列を &amp;lt;置換後パターン&amp;gt; に置換します。 substitute コマンドは通常、上記のように省略系の s を使って実行します。
デフォルトでは、行内で最初に見つかった文字列だけを置換しますが、&amp;lt;フラグ&amp;gt; 部分に g（global フラグ）を指定することで、行内のすべての文字列を置換することができます。
:s/old/new/ &amp;#34;カレント行の文字列を置換（1 つだけ置換） :s/old/new/g &amp;#34;カレント行の文字列を置換（すべて置換） 上記のように &amp;lt;行範囲&amp;gt; の指定を省略した場合は、カレント行のみが置換対象になりますが、そのような使い方はまれでしょう。 ファイル内の全ての行を置換対象にしたい場合は、&amp;lt;行範囲&amp;gt; として % を指定します（1,$ としても同様）。 下記の例では、% の後ろにスペースを入れていますが、このスペースは省略することができます。
:% s/old/new/g &amp;#34;ファイル全体の文字列を置換 置換対象とする行範囲を指定したい時は、下記のように明示的に 開始行,終了行 を指定することもできますし、
:1,5 s/old/new/g &amp;#34;1～5行目までを置換対象にする :5,$ s/old/new/g &amp;#34;5行目～最終行までを置換対象にする Shift-V で行選択した状態から、:s/old/new/g と続けて実行することもできます（こちらの方法がオススメ）。 行選択した状態で : をタイプすると、コマンドの入力欄には下記のように表示されますが、これは行選した択範囲を操作対象としていることを示しています。 そのまま s/old/new/g と続けて入力すれば OK です。
:&amp;#39;&amp;lt;,&amp;#39;&amp;gt; 区切り文字にスラッシュ (/) 以外を使用する :s/old/new/g という置換コマンド自体がスラッシュを含んでいるため、置換対象の文字列にスラッシュが含まれる場合は、下記のようにバックスラッシュを使ったエスケープ処理が必要です（/ ではなく \/ と入力する）。</description></item><item><title>Vim で別ファイルの内容や外部コマンドの出力を挿入する (:read)</title><link>https://maku77.github.io/p/oh8nhyw/</link><pubDate>Thu, 21 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oh8nhyw/</guid><description>別ファイルの内容を挿入する Vim の :read コマンド（省略形は :r）を使用すると、現在カーソルがある行に別のテキストファイルの内容を挿入することができます。
カレント行に別ファイルの内容を挿入 :r /home/maku/sample.txt 行番号を先に指定すれば、任意の位置に挿入することができます。
ファイルの先頭 (0) に別ファイルの内容を挿入 :0 r /home/maku/sample.txt ファイルの末尾 ($) に別ファイルの内容を挿入 :$ r /home/maku/sample.txt 外部コマンドの出力を挿入する :read コマンドのパラメータとして、ファイル名の代わりに !コマンド名 を指定すると、任意のコマンドの出力結果をカーソル位置に挿入することができます。
ls コマンドの出力をカーソル位置に挿入 :r !ls 以下のように挿入位置を指定する方法でも同様のことを行えます。
:. !ls 外部コマンドによるテキストフィルタリング 行範囲を指定して外部コマンドを実行すると、その範囲のテキストを外部コマンドの標準入力へ渡すことができます。 指定した範囲のテキストは、外部コマンドの出力結果で置き換えられます。
1 行目から 5 行目までをソートする :1,5 !sort 上記のように実行すると、外部コマンドの sort が実行されます。
ちなみに、行ソートを行いたいときは、通常は Vim 組み込みの sort を使用すれば事足ります。 ソートしたい行範囲を Shift-V で選択し、次のようにソートを実行できます。
:sort</description></item><item><title>Vim のファイル保存コマンド :w、:x の基本</title><link>https://maku77.github.io/p/9pyh4ip/</link><pubDate>Thu, 21 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9pyh4ip/</guid><description>ファイル保存の基本 (:w) Vim で編集内容を保存するためのもっとも基本的なコマンドは :write（省略系は :w）です。
:w &amp;#34; 上書き保存 :w file.txt &amp;#34; file.txt という名前で保存 :w &amp;gt;&amp;gt; file.txt &amp;#34; file.txt に追記保存 ファイルを保存してついでに閉じる (:x) :w の代わりに :x を使用すると、ファイルを保存して、ついでにカレントバッファを閉じることができます。 :wq でも「保存して閉じる」という操作を同時に行うことができますが、:x とは若干振る舞いが異なります。
:x &amp;#34; ファイルが編集されている場合のみ保存してバッファを閉じる :wq &amp;#34; ファイルが編集されていなくても保存してバッファを閉じる</description></item><item><title>Vim で指定した行範囲を一時的に表示する</title><link>https://maku77.github.io/p/k7r37a7/</link><pubDate>Wed, 20 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/k7r37a7/</guid><description>Vim エディタ内で下記のようなコマンドを実行すると、指定した行範囲のテキストを一時的に表示することができます。
:行範囲 p 上記のコマンドの代わりに下記のように実行すると、行番号付きで表示することができます。
:行範囲 # :行範囲 number 例: 5 行目から 10 行目までを表示 :5,10 p :5,10 # &amp;#34;行番号付き :5,10 nu &amp;#34;行番号付き 例: 20 行目から 5 行下の行までを表示 :20;+5 p :20;+5 # &amp;#34;行番号付き :20;+5 nu &amp;#34;行番号付き 例: TODO という文字列を含む行をすべて表示 :g/TODO/ p :g/TODO/ # &amp;#34;行番号付き :g/TODO/ nu &amp;#34;行番号付き プレフィックスの g を省略すると、一行だけを表示します。</description></item><item><title>Vim で切り取り＆貼り付け操作、レジスタの扱いについて理解する</title><link>https://maku77.github.io/p/fmbya48/</link><pubDate>Wed, 13 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fmbya48/</guid><description>切り取り、ヤンク（コピー）、貼り付けの基本【無名レジスタ】 d, x コマンドなどでテキストを削除したときや、y コマンドでテキストをヤンクした場合、そのテキストは 無名レジスタ &amp;quot;&amp;quot; に保存されます。 無名レジスタの内容は p, P コマンドで貼り付けることができます。
ノーマルモードでの操作 dd -- カレント行を削除 yy(Y) -- カレント行をヤンク p -- 貼り付け D -- カーソル位置から行末までを削除 C -- カーソル位置から行末までを置換（削除して挿入モードへ） s -- カーソル位置の 1 文字を削除して挿入モードへ S -- カーソルのある行を削除して挿入モードへ 名前付きレジスタに切り取り／ヤンク（コピー）／貼り付け x, d, y などの削除／ヤンクコマンドの前に、名前付きレジスタ を指定すると、そのレジスタにテキストの内容を保存できます。 名前付きレジスタには、&amp;quot;a から &amp;quot;z までのいずれかを指定します。 p, P コマンドの前に名前付きレジスタを指定すれば、そのレジスタの内容を貼り付けることができます。
ノーマルモードでの操作 &amp;#34;a yy -- カレント行を &amp;#34;a にヤンク（コピー） &amp;#34;a dd -- カレント行を &amp;#34;a に切り取り &amp;#34;a 3d -- 3 行を &amp;#34;a に切り取り &amp;#34;a p -- &amp;#34;a の内容をカーソルの後ろに貼り付け &amp;#34;a P -- &amp;#34;a の内容をカーソルの前に貼り付け ex コマンドで同様のことを行う場合は、コマンドの後ろにスペースを入れてからレジスタ名を指定します。</description></item><item><title>Vim で行情報を表示する</title><link>https://maku77.github.io/p/3m53tcz/</link><pubDate>Tue, 12 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3m53tcz/</guid><description>Vim エディタ上で下記のようなコマンドを実行すると、行の情報を表示することができます。
^G &amp;hellip; カレント行の情報を表示する（行番号、ファイル全体の相対位置など） := &amp;hellip; ファイル全体の行数を表示する :.= &amp;hellip; カレント行の行番号を表示する :/pattern/ = &amp;hellip; パターンに一致する最初の行番号を調べる</description></item><item><title>Vim/Neovim を起動するときに行番号や検索パターンを指定してファイルを開く (+n)</title><link>https://maku77.github.io/p/x8f9e87/</link><pubDate>Tue, 12 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x8f9e87/</guid><description>行番号を指定してファイルを開く Vim (Neovim) を起動するときに、+数値 オプションを指定すると、カーソルの初期フォーカス行を指定してファイルを開くことができます。 数値を省略して + のみを指定すると、最終行に移動します。
$ vim +100 filename # ファイルを開いて 100 行目へ移動 $ vim + filename # ファイルを開いて最終行へ移動 検索パターンを指定してファイルを開く Vim (Neovim) を起動するときに、__+/パターン オプションを指定すると、指定した正規表現に一致する文字列を含んだ行をフォーカスした状態でファイルを開くことができます。
$ vim +/pattern filename # ファイルを開いて pattern にヒットする行へ移動 このオプションを指定してファイルを開くと、/ コマンドで検索された状態でファイルが開くので、続けて n キーを押すことで次のヒット位置に移動できます。</description></item><item><title>Vim でカレントファイル内の文字列を検索する (/, ?, *, #)</title><link>https://maku77.github.io/p/u4gw7c3/</link><pubDate>Wed, 06 Dec 2006 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/u4gw7c3/</guid><description>検索の基本 Vim でカレントファイル内の文字列を検索するには、次のような検索コマンドを使用します。
入力 説明 /pattern [Enter] パターンを検索（順方向） ?pattern [Enter] パターンを検索（逆方向） n 次の一致箇所にジャンプ N 前の一致箇所にジャンプ / [Enter] 同じパターンで再検索（順方向） ? [Enter] 同じパターンで再検索（逆方向） * カーソル下の単語を後方検索（g* で部分一致検索） # カーソル下の単語を前方検索（g# で部分一致検索） パターンによる検索 (/, ?) 検索パターンでは正規表現を使用できます。
例: void で始まる行を検索 ^ /^void &amp;#34; ^ は行頭に一致 例: 0 回以上の繰り返しに一致 * /te* &amp;#34; t, te, tee などに一致 例: 1 回以上の繰り返しに一致 \&amp;#43; /te\+ &amp;#34; te, tee, teee などに一致 例: 0 回あるいは 1 回に一致 \= /te\= &amp;#34; t あるいは te に一致 例: 任意のアルファベット (A-Za-z) に 1 文字だけ一致 \a /\a\a\a &amp;#34; 任意の 3 文字のアルファベットに一致 例: 任意の数字に 1 文字だけ一致 \d /\d\d\d &amp;#34; 任意の 3 桁の数字に一致 例: いずれかの文字に一致 [.</description></item></channel></rss>