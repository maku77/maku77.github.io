<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on 天才まくまくノート</title><link>https://maku77.github.io/git/</link><description>Recent content in Git on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 28 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/git/index.xml" rel="self" type="application/rss+xml"/><item><title>GitHub Actions で GitHub wiki ページを自動更新する</title><link>https://maku77.github.io/p/f2eggno/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f2eggno/</guid><description>何をするか？ GitHub で管理しているリポジトリに対してコミット＆プッシュが行われたときに、自動的に GitHub wiki 側のリポジトリの内容（Markdown ファイル）を更新するようにしてみます。 例えば、プロダクトのソースコードからドキュメントを自動生成して、開発者がいつでも GitHub wiki ページで参照できるようにしておくと便利です。
図: GitHub wiki ページの自動生成 wiki ページの更新には GitHub Actions のワークフローを使い、次のように自動実行されるよう設定します。
メインリポジトリを対象としたプッシュで GitHub Actions ワークフローを起動 メインリポジトリと wiki リポジトリのソースコードを取得 何らかの外部ツールを実行して Markdown ファイルを生成 Markdown ファイルを wiki リポジトリにコミット＆プッシュ ワークフローの中で GitHub wiki のリポジトリをチェックアウトしているので、あらかじめ対象リポジトリの wiki を作成しておいてください（トップページだけで OK）。
ワークフローファイルの作成 GitHub wiki を自動更新するための、Actions のワークフローファイルを作成します。 .yml 拡張子のファイルを .github/workflows ディレクトリ以下に配置してコミットすれば、GitHub サービス側でワークフローとして認識してくれます。 ここでは、update-wiki.yml というファイル名にしてみました。
.github/workflows/update-wiki.yml name: Update wiki pages on: push: branches: [ main, master ] workflow_dispatch: jobs: update-wiki: runs-on: ubuntu-latest timeout-minutes: 3 steps: - name: Check out main repo uses: actions/checkout@v3 - name: Check out wiki repo uses: actions/checkout@v3 with: repository: &amp;#34;${{ github.</description></item><item><title>Git サブモジュールで別リポジトリの内容を組み込む (git submodule)</title><link>https://maku77.github.io/p/dsctaq7/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsctaq7/</guid><description>Git サブモジュールとは Git サブモジュールは、既存の別リポジトリの内容を、サブディレクトリの形で参照できるようにする仕組みです。 例えば、次のようなディレクトリ構成のプロジェクトがあったとします。
my-project/ +-- src/ +-- my-libs/ ★別リポジトリをサブモジュールとして組み込む ここでは、別リポジトリで管理している共有ライブラリを my-libs サブディレクトリの形で参照できるようにしています。 NPM や Maven などのパッケージレジストリから共有ライブラリを取り込む方法もありますが、Git サブモジュールの仕組みを使うと、メインプロジェクトでの開発と共有ライブラリの開発を並行して進められる ようになります。
Git サブモジュールで特徴的なのは、メインプロジェクトからはサブモジュールの内容を コミットハッシュのみで追跡する ということです。 この振る舞いを理解してしまえば、Git サブモジュールを使いこなすのは難しくありません。 サブモジュール側の変更履歴は、あくまでサブモジュール側の Git リポジトリで管理されます。 つまり、サブモジュール側のリポジトリで大量のコミットが行われていたとしても、メインプロジェクト側のリポジトリサイズが増加していくということはありません。 メインプロジェクト側では、どの時点でのスナップショット（のコミットハッシュ）を参照するかを指定するだけです。 サブモジュールとして取り込む Git リポジトリの URL は柔軟に切り替えることができます。
Git サブモジュールの利用例 共有ライブラリ用のリポジトリがあるけれど、NPM や Maven などのパッケージリポジトリにはリリースしていないとき、サブモジュールとして共有ライブラリを取り込む。メインプロジェクト側の開発中に、並行して共有ライブラリのコードを修正したい場合も同様。 頻繁に更新されるファイルがあるけれど、メインプロジェクト側のコミット履歴には残したくないとき、別リポジトリでそのファイルを管理し、サブモジュールとして取り込む。 別リポジトリをサブモジュールとして追加する (git submodule add) 既存の別リポジトリの内容（前述の例では共有ライブラリ）を、カレントプロジェクトにサブモジュールとして組み込みたいときは、git submodule add コマンドを使用します。
$ git submodule add &amp;lt;別リポジトリのURL&amp;gt; [ローカルディレクトリ] 例えば次のように実行すると、
$ git submodule add https://github.com/maku77/my-libs ローカルに my-libs というディレクトリが作成されて、サブモジュールとして参照できるようになります。 別のディレクトリ名で取り込みたい場合は、末尾にディレクトリ名を追加で指定します。
初めてサブモジュールが追加されると、.gitmodules というメタ情報ファイルが作成されます。 ここには、サブモジュールごとのリポジトリ URL とローカルディレクトリのパスが記録されています。 このファイルをコミットすることで、他の開発者がサブモジュールとして管理されているファイルを取得できるようになります。</description></item><item><title>Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf)</title><link>https://maku77.github.io/p/hxyiu7g/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hxyiu7g/</guid><description>何をするか？ 会社用と個人用の GitHub ユーザーを使い分けている場合、リポジトリへのコミット時に正しいユーザーでコミットログを残すように注意しなければいけません。 多くのリポジトリを扱っている人は、次のような感じで GitHub organization ごとにディレクトリを分けて管理するなどの工夫をしていると思います（リポジトリ名だけだと重複するので）。
~/gitwork/ +-- company/ ... 会社用のリポジトリ（会社用のユーザー Rei Ayanami を使いたい） | +-- repo1/ | +-- repo2/ | +-- repo3/ +-- maku77/ ... 個人用のリポジトリ（個人用のユーザー maku77 を使いたい） +-- repo4/ +-- repo5/ +-- repo6/ company は自分の会社で使っている GitHub organization 名、maku77 は自分の GitHub アカウント名だと考えてください。 ここでは、上記のようにディレクトリを階層化してリポジトリを管理しているときに、ディレクトリ単位で自動的に Git クライアントの設定を切り替える方法を示します。 具体的には、company ディレクトリ以下のリポジトリで作業しているときは、会社用の Git ユーザー名とメールアドレスを使い、maku77 ディレクトリ以下のリポジトリで作業しているときは、個人用のユーザー名とメールアドレスを使うようにします。
リポジトリごとに local 設定 (.git/config) をするのもよいのですが、扱うリポジトリが増えてくるといちいち設定するのが大変なので、親ディレクトリの company、maku77 単位でまるっと設定を入れ替えます。
参考: Git 設定のスコープ (local/global/system) を理解する 設定ファイルの自動切換え（includeIf ディレクティブ） Git クライアントの設定ファイル（~/.gitconfig など）には、もともと別の設定ファイルをインクルードする機能 (include ディレクティブ）があるのですが、Conditional includes（条件付きインクルード） の仕組みを使うと、指定した条件に一致したときのみ設定ファイルをインクルードすることができます。 この仕組みを利用して、次のような条件付きインクルードを行えば、Git のユーザー設定をディレクトリごとに自動で切り替えることができます。</description></item><item><title>Git の設定値がどのファイルで設定されているか調べる (config --show-origin)</title><link>https://maku77.github.io/p/msds6iv/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/msds6iv/</guid><description>Git 設定のスコープには、local/global/system などがあり、ある設定値がどのスコープ（設定ファイル）で行われているか混乱することがあります。
参考: Git 設定のスコープ (local/global/system) を理解する そのような場合は、git config --list --show-origin コマンドを使うと、それぞれの設定値がどのファイルで設定されいるものなのか調べることができます。
$ git config --list --show-origin ... file:/Users/maku/.gitconfig user.name=maku77 file:/Users/maku/.gitconfig user.email=xxx@gmail.com file:/Users/maku/.gitconfig core.editor=vim file:/Users/maku/.gitconfig push.default=simple file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config core.ignorecase=true file:.git/config core.precomposeunicode=true file:.git/config remote.origin.url=https://github.com/maku77/maku77.github.io.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master この例の場合、/Users/maku/.gitconfig で始まるものが global スコープ、.git/config で始まるものが local スコープで設定されていることが分かります。 ここでは、--list オプションですべての設定値を列挙していますが、次のように個別の設定値に関して調べることもできます。
$ git config --show-origin user.name file:/Users/maku/.gitconfig user.name=maku77</description></item><item><title>Git で他の人が作成したブランチ上で作業する</title><link>https://maku77.github.io/p/ewvaoe3/</link><pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ewvaoe3/</guid><description>GitHub などの共有リポジトリを使用して複数のメンバーで開発を進めている場合、他のメンバーが作成したブランチ（git push されたブランチ）をチェックアウトして共同作業したいことがあります。 そのような場合は、下記のような手順でローカルブランチを作成して編集作業を進めます。
共有リポジトリに push されているブランチをフェッチする (git fetch) 作業用のローカルブランチを作成する (git branch) ローカルブランチをチェックアウトして編集作業を行う (git checkout, git commit) 変更内容を共有リポジトリに push する (git push) 共有リポジトリに push されているブランチをフェッチする まずは、他の人が共有リポジトリ上に作成したブランチをローカルに持ってくる必要があります（--prune オプションを付けると、共有リポジトリ側で削除されているブランチをローカルからも削除してくれます）。
$ git fetch --prune リモートトラッキングブランチの一覧を表示し、対象のブランチをうまく fetch してこれたかを確認しておきます。
$ git branch -r origin/HEAD -&amp;gt; origin/main origin/change-date-format origin/fix-lint-warnings origin/main リモートトラッキングブランチ名は、&amp;lt;リポジトリ&amp;gt;/&amp;lt;ブランチ&amp;gt; という構成になっていますが、clone 元のリポジトリ名は origin というエイリアス名で指定できるようになっています。
作業用のローカルブランチを作成する リモートトラッキングブランチは、あくまでリモートリポジトリ側の内容を追跡するためのものなので、ここに直接修正を加えていくことはできません。 そこで、リモートトラッキングブランチをベースにして、ローカルブランチを作成する必要があります。 次の例では、リモートトラッキングブランチ origin/change-date-format と同名の change-date-format というローカルブランチを作成しています。
$ git branch change-date-format origin/change-date-format Branch &amp;#39;change-date-format&amp;#39; set up to track remote branch &amp;#39;change-date-format&amp;#39; from &amp;#39;origin&amp;#39;.</description></item><item><title>Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当）</title><link>https://maku77.github.io/p/xwxdv6y/</link><pubDate>Wed, 21 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xwxdv6y/</guid><description>Git はファイルの所有者情報なのどメタ情報を管理しませんが、ファイルの実行可能ビットだけは記録する ようになっています（Linux の chmod +x で付加するビット）。
例えば、Windows 上で Linux のシェルスクリプトを作成していて、Git リポジトリにコミットするときは、次のように git update-index コマンドで実行可能ビットを付加してからコミットしなければいけません。
シェルスクリプトに実行可能ビットを付ける $ git update-index --add --chmod=+x &amp;lt;filename&amp;gt; $ git commit Linux 上で作業する場合は、chmod +x で付加した情報が反映されるので、通常通り git add でファイルを追加するだけで OK です。</description></item><item><title>Git でブランチやタグの作者を調べる (git for-each-ref)</title><link>https://maku77.github.io/p/o2m2ft7/</link><pubDate>Thu, 18 Sep 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o2m2ft7/</guid><description>トピックブランチを使った開発手法を適用していると、トピックブランチの削除忘れなどにより、ブランチが散乱してくることがあります。 このような場合は、誰が作成したブランチが放置されているのか調べる必要があります。 下記は、手っ取り早くブランチの作者を調べる方法です。
まずは、GitHub（中央リポジトリ）上で削除済みのブランチは、ローカルのリモートトラッキングブランチからも削除しておきます。
不要なリモートトラッキングブランチを削除 $ git fetch --prune あとは、次のようにすれば、ブランチやタグ (refs) の作者を調べることができます。
ブランチやタグの作者を調べる $ git for-each-ref --format=%(authorname)%09%09%(refname) | sort maku refs/heads/main maku refs/heads/my-branch john refs/remotes/origin/apply-eslint ripper refs/remotes/origin/gh-pages maku refs/remotes/origin/HEAD maku refs/remotes/origin/main</description></item><item><title>Git 設定のスコープ (local/global/system) を理解する</title><link>https://maku77.github.io/p/af7q7n3/</link><pubDate>Sun, 25 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/af7q7n3/</guid><description>Git 設定の 3 つのスコープ git config による設定のスコープは 3 種類あり、スコープが狭くなるほど参照時の優先度は高くなります。 下記はそれぞれのスコープでの設定方法を、優先度の高い順に示しています。 カッコの中のファイル名は、コマンドを実行したときの設定値の保存先です。
$ git config --local ... # 各リポジトリごとの設定 (.git/config)（優先度:高） $ git config --global ... # 現在のユーザの共通設定 (~/.gitconfig) $ git config --system ... # システム内の共通設定 (/etc/gitconfig など)（優先度:低） 例えば、global 設定で user.name が Ichiro になっていても、local 設定が Jiro になっていれば、Jiro の方が優先的に使用されます。 プロジェクト（リポジトリ）ごとに固有の設定をする場合は、local なスコープで設定を行うとよいでしょう。 この場合、プロジェクトの作業ツリーのトップにある .git/config に設定が保存されます。
例えば、次のようにして local 設定の user.name と user.email を変更することができます。
$ git config --local user.name maku77 $ git config --local user.email maku77@example.com 上記コマンドを実行した後で、&amp;lt;リポジトリ&amp;gt;/.</description></item><item><title>Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)</title><link>https://maku77.github.io/p/cv5pi7a/</link><pubDate>Mon, 23 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cv5pi7a/</guid><description>参考: Git でブランチを削除する (git branch -d/-D) 必要のないリモートブランチを削除（リモートサーバー側） git branch -d コマンドを使ってローカルのブランチを削除しても、GitHub などに既に push されているブランチは削除されません（他のメンバーには、まだブランチが存在しているように見えます）。 GitHub 側のブランチを削除するには、ローカルブランチを削除するのとは別のコマンドを実行する必要があります。
まずは、リモートトラッキングブランチの一覧を確認しておきます。
$ git branch -r origin/HEAD -&amp;gt; origin/main origin/main origin/mybranch1 origin/mybranch2 origin/mybranch3 例えば、この中の mybranch2 を削除したい場合は、以下のようにして origin サーバに削除要求を送ります。 削除したいブランチの名前の前にコロン (:) を付けるのがポイントです。
$ git push origin :mybranch2 git push の 2 番目のパラメータで指定するリファレンス名は、&amp;lt;プッシュ元のブランチ名&amp;gt;:&amp;lt;プッシュ先のブランチ名&amp;gt; という形式を取りますが、このコロンの左側の部分を空にすることで、プッシュ先のブランチを削除する（空にする）という意味になります。
ローカル側のリモートトラッキングブランチを削除する 中央リポジトリ (GitHub) 側のブランチを削除しても、ローカルに作られているリモートトラッキングブランチは削除されません。 以下のように必要のないリモートトラッキングブランチを削除する必要があります。
# フェッチと同時に必要のないリモートトラッキングブランチを削除する（オススメ） $ git fetch --prune # 必要のないリモートトラッキングブランチを削除する $ git remote prune origin あるいは、以下のように指定したリモートトラッキングブランチを削除することもできます。
$ git branch -r -d origin/mybranch 前者の場合は、中央リポジトリ上から実際に削除されたブランチを、ローカルのリモートトラッキングブランチから削除します。 後者の場合は、中央リポジトリは関係なしに、指定したローカルのリモートトラッキングブランチを削除します。</description></item><item><title>Git の detached HEAD 状態へのチェックアウトとは</title><link>https://maku77.github.io/p/whv8ues/</link><pubDate>Mon, 23 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/whv8ues/</guid><description>ある Git ブランチのコードをチェックアウトするには、
$ git switch &amp;lt;ブランチ名&amp;gt; のように実行しますが、そのブランチの最新コードではなく、ある特定のバージョン（コミット ID）のソースコードを少しだけ覗いてみたいということがあります。 そのような場合は、ブランチ名の代わりにコミット ID を指定してチェックアウトすることができます。
コミット名を指定して git checkout を実行すると、どのローカルブランチもチェックアウトしていない detached HEAD という状態になります（HEAD が detached されているということ）。 例えば、以下のように git checkout すると、この状態になります。
$ git checkout 0d3ce61 # コミット ID を指定 $ git checkout HEAD^0 # 最新のコミットを指定 $ git checkout HEAD^1 # １つ前のコミットを指定 $ git checkout v2.6.18 # タグで示されるコミットを指定 $ git checkout origin/main # リモートトラッキングブランチを指定 HEAD が detached された状態で git branch を実行すると、どのブランチにもいないことを示す (no branch) が表示されます。
$ git branch * (no branch) main mybranch detached HEAD 状態でも git commit などのコマンドを実行できますが、どのブランチにもいない状態なので、どのブランチの head も更新されません。 再びローカルブランチ名を指定してチェックアウトすると、detached HEAD で行っていた変更を破棄してブランチの最新状態に戻ることができます。</description></item><item><title>Git で他のブランチの最新ファイルを現在のブランチにコピーする (git checkout)</title><link>https://maku77.github.io/p/6g8n3jw/</link><pubDate>Fri, 20 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6g8n3jw/</guid><description>Git では、ファイル単位で他のブランチにコミットされているファイルをコピーしてくることができます。 例えば、現在 main ブランチをチェックアウトしているときに、別のブランチ mybranch の sample.txt の最新をコピーしてきたいときは次のように実行します。
$ git checkout mybranch sample.txt</description></item><item><title>Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b)</title><link>https://maku77.github.io/p/ivbss76/</link><pubDate>Mon, 19 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ivbss76/</guid><description>git switch -c コマンドを使用すると、ブランチの作成と、そのブランチへの切り替え（チェックアウト）を同時に行うことができます（昔は同様の振る舞いをする git checkout -b コマンドが使っていました）。
ブランチの作成と切り替えを一度に行う $ git switch -c mybranch # ブランチ mybranch の作成＆チェックアウト Switched to a new branch &amp;#39;mybranch&amp;#39; $ git branch # 現在チェックアウトしているブランチの確認 main * mybranch git branch コマンドでのブランチ作成と同様、ブランチ元のブランチ名を指定することもできます。
$ git switch -c mybranch main</description></item><item><title>Git でブランチ名を変更する (git branch -m)</title><link>https://maku77.github.io/p/9bh2ody/</link><pubDate>Mon, 19 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9bh2ody/</guid><description>Git のブランチ名を変更するには以下のように git branch -m コマンドを使用します。
ブランチ名を変更する $ git branch -m new # 現在チェックアウトしているブランチの名前を new に変更 $ git branch -m old new # old ブランチの名前を new に変更 GitHub などのリモートリポジトリに old リポジトリがすでに push されている場合は、次のようにして中央リポジトリ側のリポジトリ名も変更する必要があります。
GitHub 側のブランチ名を変更する $ git push origin new # 新しいブランチ new を push $ git push origin :old # 古いブランチ old を削除 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)</description></item><item><title>Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout)</title><link>https://maku77.github.io/p/8cwbp3e/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8cwbp3e/</guid><description>作業対象のブランチを切り替えるには、git switch コマンドで切り替え先のブランチ名を指定します（昔は git checkout コマンドが使われていましたが、現在は役割を明確にした git switch コマンドが使われています）。
ブランチを切り替える前に、 git branch コマンドを使用して、現在チェックアウトしているブランチと、切り替え先のブランチ名を確認しておくとよいです。
ブランチの一覧を確認 $ git branch * main my-branch 上記の出力で、現在の作業対象が main であることが分かります。 次のようにすると、作業対象を my-branch ブランチに切り替えることができます。
my-branch ブランチに切り替える $ git switch my-branch Switched to branch &amp;#34;my-branch&amp;#34; 切り替わっていることを確認する $ git branch main * my-branch これで、作業対象のブランチが my-branch に切り替わったので、これ以降の変更作業 (git commit) は、my-branch ブランチだけに反映され、main ブランチには反映されなくなります。</description></item><item><title>Git でブランチを作成する (git branch)</title><link>https://maku77.github.io/p/x9s8k2e/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x9s8k2e/</guid><description>現在チェックアウトしているブランチから、新しいブランチを作成するには次のコマンドを使用します。
$ git branch &amp;lt;新しいブランチ名&amp;gt; ブランチ元のブランチを指定して、新しいブランチを作成するには次のようにします。
$ git branch &amp;lt;新しいブランチ名&amp;gt; &amp;lt;既存のブランチ名&amp;gt; 例: main ブランチから REL-1.0 ブランチを作成する $ git branch REL-1.0 main git branch コマンドを引数なしで実行すると、ブランチの一覧を確認できます（git branch --list と同等）。
$ git branch REL-1.0 * master 上記の例では、今回作成された REL-1.0 と、デフォルトの master ブランチが存在することが分かります。master の前の * は、現在の作業対象（チェックアウトされているブランチ）が master ブランチであることを示しています。 作業対象を新しいブランチに切り替えるには、git switch コマンドを使用する必要があります。
参考: Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) 参考: Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) 参考: Git で他の人が作成したブランチ上で作業する ちなみに、ローカルで新しく作成したブランチの内容を GitHub などの中央リポジトリに git push するには、次のように実行します。
origin リポジトリへ新しいブランチ REL-1.</description></item><item><title>Git でブランチを削除する (git branch -d/-D)</title><link>https://maku77.github.io/p/stpfje9/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/stpfje9/</guid><description>不要になったブランチを削除するには、git branch -d コマンドでブランチ名を指定します。 削除対象のブランチが作業対象になっていると削除できないので、先に git switch コマンドで別のブランチに切り替えてから削除を実行します。
mybranch ブランチを削除する $ git switch main $ git branch -d mybranch Deleted branch mybranch (was 1cc229d3) 削除しようとしているブランチの変更内容が、ブランチ元にマージされていない場合、以下のようなエラーが表示されます。
error: The branch &amp;#39;mybranch&amp;#39; is not an ancestor of your current HEAD. If you are sure you want to delete it, run &amp;#39;git branch -D mybranch&amp;#39; この場合は、先にブランチ元にマージを実行するか、あるいは、変更内容が完全に消えても構わない場合は -d オプションの代わりに -D オプションを指定して実行します。
マージされていないブランチを強制的に削除する $ git branch -D mybranch 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)</description></item><item><title>Git のコミット時にコメント記述に使用するエディタを設定する (core.editor)</title><link>https://maku77.github.io/p/cqjv7wv/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cqjv7wv/</guid><description>git commit コマンド実行時に、-m オプションでコメントを指定しなかった場合は、コメント入力のためにエディタが起動します。 ここで起動するエディタは自由に変更できます。 操作に慣れた Vim エディタなどを指定しておけば、コミット前の編集画面で操作ミスしてしまうこともなくなるでしょう。
例: エディタを vim に設定する $ git config --global core.editor vim 上記の例では、core.editor 設定を使ってエディタの指定を行っていますが、エディタの指定方法はたくさんあり、Git は次の順番で使用するエディタを判断します。
環境変数 GIT_EDITOR Git の core.editor 設定 環境変数 VISUAL 環境変数 EDITOR vi（Debian、Ubuntu の場合は editor）</description></item><item><title>Git 用語集</title><link>https://maku77.github.io/p/f844tkg/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f844tkg/</guid><description>作業ツリー、ワークツリー (work tree) Git の管理下に入ったローカルのディレクトリツリーを 作業ツリー (work tree) と呼びます。 リポジトリに記録された内容を作業ツリーに展開する操作を チェックアウト (checkout) と呼びます。 git init コマンドなどで作成される .git/ ディレクトリが存在するディレクトリが、作業ツリーのルートになります。 Subversion や CVS では「作業コピー」と呼んでいました。
リポジトリ (repository) 変更履歴などを管理するリポジトリで、Git では必ずローカルディレクトリに存在します。 他のマシン上にあるリポジトリも、ローカルにあるリポジトリも対等の関係にあり、各リポジトリにコミットされた変更内容を互いにやりとりすることでプロジェクト全体の変更の一貫性を保ちます。 一般的には、ある一つのマシンのリポジトリを中央リポジトリとし、そこから最終的なプロジェクトの成果物を生成します。 リポジトリの実体は、作業ツリーのルートにある .git/ ディレクトリです。
ステージする (stage) あるファイルを次回のコミット対象に含めることを、ファイルを ステージする (stage) といいます。 Perforce を使ったことがある人は、p4 edit などによる Perforce サーバへの変更通知と近い概念なので分かりやすいと思います。 Git では、git add や git rm コマンドでファイルを指定すると、その情報が Git のインデックス情報として登録され、次回のコミット対象となります。
ハンク (hunk) ファイル内の連続した変更箇所のこと。 1 つのファイル内に連続した変更箇所が複数あれば、ハンクも複数存在することになります。 Git ではファイル単位で変更を追跡するのではなく、もっと細かいハンク単位で追跡します。 つまり、ファイル内の変更の一部だけをコミットするという作業が行えます。
チェックアウト (checkout) リポジトリに格納されたあるリビジョンの内容を作業ツリーに展開し、ローカルファイルとして見えるようにすることを チェックアウトする (checkout) と言います。 また、チェックアウトされているブランチとは、現在の作業ツリーに反映されているブランチのことで、作業対象になっているブランチのことをいいます。
main ブランチ / master ブランチ git init した後の初期状態で何かファイルをコミットすると、デフォルトで main というブランチが作成され、チェックアウトされた状態になります。 昔は master という名前が使われていましたが、アメリカの BLM 運動をきっかけに差別的で不適切な用語とされ main という名前に置き換えられました。</description></item></channel></rss>