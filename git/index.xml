<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on 天才まくまくノート</title><link>https://maku77.github.io/git/</link><description>Recent content in Git on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 28 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/git/index.xml" rel="self" type="application/rss+xml"/><item><title>GitHub Actions で GitHub wiki ページを自動更新する</title><link>https://maku77.github.io/p/f2eggno/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f2eggno/</guid><description>何をするか？ GitHub で管理しているリポジトリに対してコミット＆プッシュが行われたときに、自動的に GitHub wiki 側のリポジトリの内容（Markdown ファイル）を更新するようにしてみます。 例えば、プロダクトのソースコードからドキュメントを自動生成して、開発者がいつでも GitHub wiki ページで参照できるようにしておくと便利です。
図: GitHub wiki ページの自動生成 wiki ページの更新には GitHub Actions のワークフローを使い、次のように自動実行されるよう設定します。
メインリポジトリを対象としたプッシュで GitHub Actions ワークフローを起動 メインリポジトリと wiki リポジトリのソースコードを取得 何らかの外部ツールを実行して Markdown ファイルを生成 Markdown ファイルを wiki リポジトリにコミット＆プッシュ ワークフローの中で GitHub wiki のリポジトリをチェックアウトしているので、あらかじめ対象リポジトリの wiki を作成しておいてください（トップページだけで OK）。
ワークフローファイルの作成 GitHub wiki を自動更新するための、Actions のワークフローファイルを作成します。 .yml 拡張子のファイルを .github/workflows ディレクトリ以下に配置してコミットすれば、GitHub サービス側でワークフローとして認識してくれます。 ここでは、update-wiki.yml というファイル名にしてみました。
.github/workflows/update-wiki.yml name: Update wiki pages on: push: branches: [ main, master ] workflow_dispatch: jobs: update-wiki: runs-on: ubuntu-latest timeout-minutes: 3 steps: - name: Check out main repo uses: actions/checkout@v3 - name: Check out wiki repo uses: actions/checkout@v3 with: repository: &amp;#34;${{ github.</description></item><item><title>Git サブモジュールで別リポジトリの内容を組み込む (git submodule)</title><link>https://maku77.github.io/p/dsctaq7/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsctaq7/</guid><description>Git サブモジュールとは Git サブモジュールは、既存の別リポジトリの内容を、サブディレクトリの形で参照できるようにする仕組みです。 例えば、次のようなディレクトリ構成のプロジェクトがあったとします。
my-project/ +-- src/ +-- my-libs/ ★別リポジトリをサブモジュールとして組み込む ここでは、別リポジトリで管理している共有ライブラリを my-libs サブディレクトリの形で参照できるようにしています。 NPM や Maven などのパッケージレジストリから共有ライブラリを取り込む方法もありますが、Git サブモジュールの仕組みを使うと、メインプロジェクトでの開発と共有ライブラリの開発を並行して進められる ようになります。
Git サブモジュールで特徴的なのは、メインプロジェクトからはサブモジュールの内容を コミットハッシュのみで追跡する ということです。 この振る舞いを理解してしまえば、Git サブモジュールを使いこなすのは難しくありません。 サブモジュール側の変更履歴は、あくまでサブモジュール側の Git リポジトリで管理されます。 つまり、サブモジュール側のリポジトリで大量のコミットが行われていたとしても、メインプロジェクト側のリポジトリサイズが増加していくということはありません。 メインプロジェクト側では、どの時点でのスナップショット（のコミットハッシュ）を参照するかを指定するだけです。 サブモジュールとして取り込む Git リポジトリの URL は柔軟に切り替えることができます。
Git サブモジュールの利用例 共有ライブラリ用のリポジトリがあるけれど、NPM や Maven などのパッケージリポジトリにはリリースしていないとき、サブモジュールとして共有ライブラリを取り込む。メインプロジェクト側の開発中に、並行して共有ライブラリのコードを修正したい場合も同様。 頻繁に更新されるファイルがあるけれど、メインプロジェクト側のコミット履歴には残したくないとき、別リポジトリでそのファイルを管理し、サブモジュールとして取り込む。 別リポジトリをサブモジュールとして追加する (git submodule add) 既存の別リポジトリの内容（前述の例では共有ライブラリ）を、カレントプロジェクトにサブモジュールとして組み込みたいときは、git submodule add コマンドを使用します。
$ git submodule add &amp;lt;別リポジトリのURL&amp;gt; [ローカルディレクトリ] 例えば次のように実行すると、
$ git submodule add https://github.com/maku77/my-libs ローカルに my-libs というディレクトリが作成されて、サブモジュールとして参照できるようになります。 別のディレクトリ名で取り込みたい場合は、末尾にディレクトリ名を追加で指定します。
初めてサブモジュールが追加されると、.gitmodules というメタ情報ファイルが作成されます。 ここには、サブモジュールごとのリポジトリ URL とローカルディレクトリのパスが記録されています。 このファイルをコミットすることで、他の開発者がサブモジュールとして管理されているファイルを取得できるようになります。</description></item><item><title>Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf)</title><link>https://maku77.github.io/p/hxyiu7g/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hxyiu7g/</guid><description>何をするか？ 会社用と個人用の GitHub ユーザーを使い分けている場合、リポジトリへのコミット時に正しいユーザーでコミットログを残すように注意しなければいけません。 多くのリポジトリを扱っている人は、次のような感じで GitHub organization ごとにディレクトリを分けて管理するなどの工夫をしていると思います（リポジトリ名だけだと重複するので）。
~/gitwork/ +-- company/ ... 会社用のリポジトリ（会社用のユーザー Rei Ayanami を使いたい） | +-- repo1/ | +-- repo2/ | +-- repo3/ +-- maku77/ ... 個人用のリポジトリ（個人用のユーザー maku77 を使いたい） +-- repo4/ +-- repo5/ +-- repo6/ company は自分の会社で使っている GitHub organization 名、maku77 は自分の GitHub アカウント名だと考えてください。 ここでは、上記のようにディレクトリを階層化してリポジトリを管理しているときに、ディレクトリ単位で自動的に Git クライアントの設定を切り替える方法を示します。 具体的には、company ディレクトリ以下のリポジトリで作業しているときは、会社用の Git ユーザー名とメールアドレスを使い、maku77 ディレクトリ以下のリポジトリで作業しているときは、個人用のユーザー名とメールアドレスを使うようにします。
リポジトリごとに local 設定 (.git/config) をするのもよいのですが、扱うリポジトリが増えてくるといちいち設定するのが大変なので、親ディレクトリの company、maku77 単位でまるっと設定を入れ替えます。
参考: Git 設定のスコープ (local/global/system) を理解する 設定ファイルの自動切換え（includeIf ディレクティブ） Git クライアントの設定ファイル（~/.gitconfig など）には、もともと別の設定ファイルをインクルードする機能 (include ディレクティブ）があるのですが、Conditional includes（条件付きインクルード） の仕組みを使うと、指定した条件に一致したときのみ設定ファイルをインクルードすることができます。 この仕組みを利用して、次のような条件付きインクルードを行えば、Git のユーザー設定をディレクトリごとに自動で切り替えることができます。</description></item><item><title>Git の設定値がどのファイルで設定されているか調べる (config --show-origin)</title><link>https://maku77.github.io/p/msds6iv/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/msds6iv/</guid><description>Git 設定のスコープには、local/global/system などがあり、ある設定値がどのスコープ（設定ファイル）で行われているか混乱することがあります。
参考: Git 設定のスコープ (local/global/system) を理解する そのような場合は、git config --list --show-origin コマンドを使うと、それぞれの設定値がどのファイルで設定されいるものなのか調べることができます。
$ git config --list --show-origin ... file:/Users/maku/.gitconfig user.name=maku77 file:/Users/maku/.gitconfig user.email=xxx@gmail.com file:/Users/maku/.gitconfig core.editor=vim file:/Users/maku/.gitconfig push.default=simple file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config core.ignorecase=true file:.git/config core.precomposeunicode=true file:.git/config remote.origin.url=https://github.com/maku77/maku77.github.io.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master この例の場合、/Users/maku/.gitconfig で始まるものが global スコープ、.git/config で始まるものが local スコープで設定されていることが分かります。 ここでは、--list オプションですべての設定値を列挙していますが、次のように個別の設定値に関して調べることもできます。
$ git config --show-origin user.name file:/Users/maku/.gitconfig user.name=maku77</description></item><item><title>Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当）</title><link>https://maku77.github.io/p/xwxdv6y/</link><pubDate>Wed, 21 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xwxdv6y/</guid><description>Git はファイルの所有者情報なのどメタ情報を管理しませんが、ファイルの実行可能ビットだけは記録する ようになっています（Linux の chmod +x で付加するビット）。
例えば、Windows 上で Linux のシェルスクリプトを作成していて、Git リポジトリにコミットするときは、次のように git update-index コマンドで実行可能ビットを付加してからコミットしなければいけません。
シェルスクリプトに実行可能ビットを付ける $ git update-index --add --chmod=+x &amp;lt;filename&amp;gt; $ git commit Linux 上で作業する場合は、chmod +x で付加した情報が反映されるので、通常通り git add でファイルを追加するだけで OK です。</description></item><item><title>Git 設定のスコープ (local/global/system) を理解する</title><link>https://maku77.github.io/p/af7q7n3/</link><pubDate>Sun, 25 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/af7q7n3/</guid><description>Git 設定の 3 つのスコープ git config による設定のスコープは 3 種類あり、スコープが狭くなるほど参照時の優先度は高くなります。 下記はそれぞれのスコープでの設定方法を、優先度の高い順に示しています。 カッコの中のファイル名は、コマンドを実行したときの設定値の保存先です。
$ git config --local ... # 各リポジトリごとの設定 (.git/config)（優先度:高） $ git config --global ... # 現在のユーザの共通設定 (~/.gitconfig) $ git config --system ... # システム内の共通設定 (/etc/gitconfig など)（優先度:低） 例えば、global 設定で user.name が Ichiro になっていても、local 設定が Jiro になっていれば、Jiro の方が優先的に使用されます。 プロジェクト（リポジトリ）ごとに固有の設定をする場合は、local なスコープで設定を行うとよいでしょう。 この場合、プロジェクトの作業ツリーのトップにある .git/config に設定が保存されます。
例えば、次のようにして local 設定の user.name と user.email を変更することができます。
$ git config --local user.name maku77 $ git config --local user.email maku77@example.com 上記コマンドを実行した後で、&amp;lt;リポジトリ&amp;gt;/.</description></item><item><title>Git のコミット時にコメント記述に使用するエディタを設定する (core.editor)</title><link>https://maku77.github.io/p/cqjv7wv/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cqjv7wv/</guid><description>git commit コマンド実行時に、-m オプションでコメントを指定しなかった場合は、コメント入力のためにエディタが起動します。 ここで起動するエディタは自由に変更できます。 操作に慣れた Vim エディタなどを指定しておけば、コミット前の編集画面で操作ミスしてしまうこともなくなるでしょう。
例: エディタを vim に設定する $ git config --global core.editor vim 上記の例では、core.editor 設定を使ってエディタの指定を行っていますが、エディタの指定方法はたくさんあり、Git は次の順番で使用するエディタを判断します。
環境変数 GIT_EDITOR Git の core.editor 設定 環境変数 VISUAL 環境変数 EDITOR vi（Debian、Ubuntu の場合は editor）</description></item><item><title>Git 用語集</title><link>https://maku77.github.io/p/f844tkg/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f844tkg/</guid><description>作業ツリー、ワークツリー (work tree) Git の管理下に入ったローカルのディレクトリツリーを 作業ツリー (work tree) と呼びます。 リポジトリに記録された内容を作業ツリーに展開する操作を チェックアウト (checkout) と呼びます。 git init コマンドなどで作成される .git/ ディレクトリが存在するディレクトリが、作業ツリーのルートになります。 Subversion や CVS では「作業コピー」と呼んでいました。
リポジトリ (repository) 変更履歴などを管理するリポジトリで、Git では必ずローカルディレクトリに存在します。 他のマシン上にあるリポジトリも、ローカルにあるリポジトリも対等の関係にあり、各リポジトリにコミットされた変更内容を互いにやりとりすることでプロジェクト全体の変更の一貫性を保ちます。 一般的には、ある一つのマシンのリポジトリを中央リポジトリとし、そこから最終的なプロジェクトの成果物を生成します。 リポジトリの実体は、作業ツリーのルートにある .git/ ディレクトリです。
ステージする (stage) あるファイルを次回のコミット対象に含めることを、ファイルを ステージする (stage) といいます。 Perforce を使ったことがある人は、p4 edit などによる Perforce サーバへの変更通知と近い概念なので分かりやすいと思います。 Git では、git add や git rm コマンドでファイルを指定すると、その情報が Git のインデックス情報として登録され、次回のコミット対象となります。
ハンク (hunk) ファイル内の連続した変更箇所のこと。 1 つのファイル内に連続した変更箇所が複数あれば、ハンクも複数存在することになります。 Git ではファイル単位で変更を追跡するのではなく、もっと細かいハンク単位で追跡します。 つまり、ファイル内の変更の一部だけをコミットするという作業が行えます。
チェックアウト (checkout) リポジトリに格納されたあるリビジョンの内容を作業ツリーに展開し、ローカルファイルとして見えるようにすることを チェックアウトする (checkout) と言います。 また、チェックアウトされているブランチとは、現在の作業ツリーに反映されているブランチのことで、作業対象になっているブランチのことをいいます。
main ブランチ / master ブランチ git init した後の初期状態で何かファイルをコミットすると、デフォルトで main というブランチが作成され、チェックアウトされた状態になります。 昔は master という名前が使われていましたが、アメリカの BLM 運動をきっかけに差別的で不適切な用語とされ main という名前に置き換えられました。</description></item></channel></rss>