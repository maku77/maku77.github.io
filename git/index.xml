<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on 天才まくまくノート</title><link>https://maku77.github.io/git/</link><description>Recent content in Git on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Wed, 15 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Git リポジトリ内のコードを grep 検索する (git grep)</title><link>https://maku77.github.io/p/2c29gvn/</link><pubDate>Wed, 15 Nov 2023 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2c29gvn/</guid><description>git grep とは Git に組み込まれている git grep コマンドを使うと、Git リポジトリ内のコードを対象にした grep 検索を行うことができます。 Linux の grep コマンドを使うのと比べて、次のような利点があります。
OS に依存しない grep コマンドとして使用できる .gitignore で指定されているファイルを無視して検索してくれる ある時点のコードを対象に検索できる（コミットハッシュの指定） ある文字列を含む関数を検索できる（-p オプション） git grep の基本 カレントディレクトリ以下を検索する $ git grep &amp;#34;検索文字列&amp;#34; カレントディレクトリ以下のファイルを対象として git grep するには、上記のように単純に検索文字列を指定するだけで OK です。 もちろん、Git 管理されているディレクトリ以下で実行する必要があります。
検索対象のディレクトリやファイルを指定するには、次のように -- で区切ってからディレクトリ名やファイル名のパターンを指定します。
src ディレクトリ以下を検索する $ git grep &amp;#34;検索文字列&amp;#34; -- src src ディレクトリ以下の .py ファイルを検索する $ git grep &amp;#34;検索文字列&amp;#34; -- &amp;#34;src/**.py&amp;#34; ワイルドカードを指定してファイル名のパターンを指定するときは、&amp;quot;src/**.py&amp;quot; のようにダブルクォートで囲む必要があることに注意してください。 これは、git grep にパラメーターが渡される前にシェルがファイルグロブとして展開してしまうのを防ぐためです。
特定のディレクトリやファイルを検索対象外にしたいときは、:^ というプレフィックスを付けます。
.github ディレクトリや package.</description></item><item><title>GitHub Actions のワークフローをローカルで実行する (act)</title><link>https://maku77.github.io/p/iudtbr8/</link><pubDate>Fri, 09 Dec 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/iudtbr8/</guid><description>act とは？ act コマンド は、Casey Lee 氏 (@nektos) が作成した、GitHub Actions ワークフローをローカル実行するためのコマンドです。
nektos/act: Run your GitHub Actions locally 🚀 通常、GitHub Actions のワークフローを実行するには、ワークフローファイル (.github/workflows/*.yml) を作成して、GitHub へコミット＆プッシュする必要がありますが、act コマンドを使うと、ローカルのワークフローファイルをそのまま実行できます。 ローカルでの実行を主目的とした、タスクランナーとしての利用も可能です。
act コマンドは、GitHub Blog でも紹介されています。
Docker と act のインストール act はワークフローの実行環境として Docker コンテナを利用するので、Docker 環境はあらかじめインストールしておいてください。 Docker Desktop をインストールすれば、簡単に Docker 環境が整います。
Docker Desktop act コマンドは Go 言語で実装されており、各 OS 用の実行ファイルが提供されています。 下記の公式ページの説明に従って、OS ごとのパッケージ管理コマンドでインストールしてしまうのが簡単です。
nektos/act: Run your GitHub Actions locally 🚀 例えば、macOS であれば brew install act、Windows であれば choco install act-cli などでインストールできます。 インストールが終わって、次のように実行できるようになっていれば準備完了です。</description></item><item><title>GitHub Actions で GitHub wiki ページを自動更新する</title><link>https://maku77.github.io/p/f2eggno/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f2eggno/</guid><description>何をするか？ GitHub で管理しているリポジトリに対してコミット＆プッシュが行われたときに、自動的に GitHub wiki 側のリポジトリの内容（Markdown ファイル）を更新するようにしてみます。 例えば、プロダクトのソースコードからドキュメントを自動生成して、開発者がいつでも GitHub wiki ページで参照できるようにしておくと便利です。
図: GitHub wiki ページの自動生成 wiki ページの更新には GitHub Actions のワークフローを使い、次のように自動実行されるよう設定します。
メインリポジトリを対象としたプッシュで GitHub Actions ワークフローを起動 メインリポジトリと wiki リポジトリのソースコードを取得 何らかの外部ツールを実行して Markdown ファイルを生成 Markdown ファイルを wiki リポジトリにコミット＆プッシュ ワークフローの中で GitHub wiki のリポジトリをチェックアウトしているので、あらかじめ対象リポジトリの wiki を作成しておいてください（トップページだけで OK）。
ワークフローファイルの作成 GitHub wiki を自動更新するための、Actions のワークフローファイルを作成します。 .yml 拡張子のファイルを .github/workflows ディレクトリ以下に配置してコミットすれば、GitHub サービス側でワークフローとして認識してくれます。 ここでは、update-wiki.yml というファイル名にしてみました。
.github/workflows/update-wiki.yml name: Update wiki pages on: push: branches: [ main, master ] workflow_dispatch: jobs: update-wiki: runs-on: ubuntu-latest timeout-minutes: 3 steps: - name: Check out main repo uses: actions/checkout@v3 - name: Check out wiki repo uses: actions/checkout@v3 with: repository: &amp;#34;${{ github.</description></item><item><title>Git サブモジュールで別リポジトリの内容を組み込む (git submodule)</title><link>https://maku77.github.io/p/dsctaq7/</link><pubDate>Sun, 13 Nov 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/dsctaq7/</guid><description>Git サブモジュールとは Git サブモジュールは、既存の別リポジトリの内容を、サブディレクトリの形で参照できるようにする仕組みです。 例えば、次のようなディレクトリ構成のプロジェクトがあったとします。
my-project/ +-- src/ +-- my-libs/ ★別リポジトリをサブモジュールとして組み込む ここでは、別リポジトリで管理している共有ライブラリを my-libs サブディレクトリの形で参照できるようにしています。 NPM や Maven などのパッケージレジストリから共有ライブラリを取り込む方法もありますが、Git サブモジュールの仕組みを使うと、メインプロジェクトでの開発と共有ライブラリの開発を並行して進められる ようになります。
Git サブモジュールで特徴的なのは、メインプロジェクトからはサブモジュールの内容を コミットハッシュのみで追跡する ということです。 この振る舞いを理解してしまえば、Git サブモジュールを使いこなすのは難しくありません。 サブモジュール側の変更履歴は、あくまでサブモジュール側の Git リポジトリで管理されます。 つまり、サブモジュール側のリポジトリで大量のコミットが行われていたとしても、メインプロジェクト側のリポジトリサイズが増加していくということはありません。 メインプロジェクト側では、どの時点でのスナップショット（のコミットハッシュ）を参照するかを指定するだけです。 サブモジュールとして取り込む Git リポジトリの URL は柔軟に切り替えることができます。
Git サブモジュールの利用例 共有ライブラリ用のリポジトリがあるけれど、NPM や Maven などのパッケージリポジトリにはリリースしていないとき、サブモジュールとして共有ライブラリを取り込む。メインプロジェクト側の開発中に、並行して共有ライブラリのコードを修正したい場合も同様。 頻繁に更新されるファイルがあるけれど、メインプロジェクト側のコミット履歴には残したくないとき、別リポジトリでそのファイルを管理し、サブモジュールとして取り込む。 別リポジトリをサブモジュールとして追加する (git submodule add) 既存の別リポジトリの内容（前述の例では共有ライブラリ）を、カレントプロジェクトにサブモジュールとして組み込みたいときは、git submodule add コマンドを使用します。
$ git submodule add &amp;lt;別リポジトリのURL&amp;gt; [ローカルディレクトリ] 例えば次のように実行すると、
$ git submodule add https://github.com/maku77/my-libs ローカルに my-libs というディレクトリが作成されて、サブモジュールとして参照できるようになります。 別のディレクトリ名で取り込みたい場合は、末尾にディレクトリ名を追加で指定します。
初めてサブモジュールが追加されると、.gitmodules というメタ情報ファイルが作成されます。 ここには、サブモジュールごとのリポジトリ URL とローカルディレクトリのパスが記録されています。 このファイルをコミットすることで、他の開発者がサブモジュールとして管理されているファイルを取得できるようになります。</description></item><item><title>Git ユーザーをディレクトリごとに自動で切り替える (.gitconfig, includeIf)</title><link>https://maku77.github.io/p/hxyiu7g/</link><pubDate>Mon, 12 Sep 2022 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hxyiu7g/</guid><description>何をするか？ 会社用と個人用の GitHub ユーザーを使い分けている場合、リポジトリへのコミット時に正しいユーザーでコミットログを残すように注意しなければいけません。 多くのリポジトリを扱っている人は、次のような感じで GitHub organization ごとにディレクトリを分けて管理するなどの工夫をしていると思います（リポジトリ名だけだと重複するので）。
~/gitwork/ +-- company/ ... 会社用のリポジトリ（会社用のユーザー Rei Ayanami を使いたい） | +-- repo1/ | +-- repo2/ | +-- repo3/ +-- maku77/ ... 個人用のリポジトリ（個人用のユーザー maku77 を使いたい） +-- repo4/ +-- repo5/ +-- repo6/ company は自分の会社で使っている GitHub organization 名、maku77 は自分の GitHub アカウント名だと考えてください。 ここでは、上記のようにディレクトリを階層化してリポジトリを管理しているときに、ディレクトリ単位で自動的に Git クライアントの設定を切り替える方法を示します。 具体的には、company ディレクトリ以下のリポジトリで作業しているときは、会社用の Git ユーザー名とメールアドレスを使い、maku77 ディレクトリ以下のリポジトリで作業しているときは、個人用のユーザー名とメールアドレスを使うようにします。
リポジトリごとに local 設定 (.git/config) をするのもよいのですが、扱うリポジトリが増えてくるといちいち設定するのが大変なので、親ディレクトリの company、maku77 単位でまるっと設定を入れ替えます。
参考: Git 設定のスコープ (local/global/system) を理解する 設定ファイルの自動切換え（includeIf ディレクティブ） Git クライアントの設定ファイル（~/.gitconfig など）には、もともと別の設定ファイルをインクルードする機能 (include ディレクティブ）があるのですが、Conditional includes（条件付きインクルード） の仕組みを使うと、指定した条件に一致したときのみ設定ファイルをインクルードすることができます。 この仕組みを利用して、次のような条件付きインクルードを行えば、Git のユーザー設定をディレクトリごとに自動で切り替えることができます。</description></item><item><title>GitHub のオートリンク機能で外部サイトへ ID ベースでリンクする (autolink)</title><link>https://maku77.github.io/p/ias8kt3/</link><pubDate>Thu, 03 Dec 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ias8kt3/</guid><description>オートリンク機能とは GitHub の Issue（イシュー）や PR（プルリクエスト）のページの概要欄、コメント欄では、次のように Issue 番号を書いておくだけで該当ページに自動リンクすることができます。
#1234 参考: Autolinked references and URLs - GitHub Docs この機能はあくまで GitHub サイト内のリンクを簡単に記述するためのものですが、カスタムの Autolink references を設定しておくことで、任意の外部サイトに ID ベースで自動リンクできるようになります。
参考: Configuring autolinks to reference external resources - GitHub Docs 例えば、仕様書サイトのあるページ（ID=123 とします）にリンクしたい場合に、次のように簡単にリンクできるようになります。
SPEC-123 URL そのものを記述する必要がなくなるので、仕様書サイトのサーバー移転などでドメイン名が変わったとしても、Issue のコメントに記述したリンクが無効になってしまうことがありません。 ちなみにブログサイトなどの各ページの URL には、ID ベースのパーマリンクアドレスを割り当てる運用にしておくと、こういった機能と連携しやすくなります。
参考: サイト構造を変えてもページの URL が変わらないようにする - まくまくHugoノート カスタム・オートリンクの設定 （2022年7月時点で、このカスタム・オートリンクは、GitHub Pro、GitHub Team などの 有料プランのみで設定可能 です）
外部サイトへのオートリンク機能を有効にするには、次のように設定します。 ここでは、外部サイトの URL は https://spec.example.com/p/123/ といったパーマリンクで提供されるものとします（123 といった ID はサーバー移転などしても変わらないことが保証されていると過程）。
対象のリポジトリの Settings（設定）を選択 サイドバーから Autolink references を選択 次のような感じで Autolink 方法を設定 Reference prefix: SPEC- Target URL: https://spec.</description></item><item><title>GitHub で Pull Request のコードレビューワーを自動でアサインする</title><link>https://maku77.github.io/p/oifj5jn/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/oifj5jn/</guid><description>2019年の末に、GitHub にコードレビューワーの自動アサイン機能が追加されました。
Managing code review assignment for your team - GitHub Docs この機能を有効にすると、Pull Request のレビューワーとしてチームをアサインしたときに、そのチーム内の数名を自動アサインしてくれるようになります。 この機能は、チーム単位の設定になるので、あらかじめリポジトリに何らかのチームを参加させておく必要があります。 チーム構成に迷ったら、プロジェクトと同じ粒度で作ってしまうのが手っ取り早いです（例えば、MyApp プロジェクトのチームとして、team-MyApp を作成します）。
自動アサインの設定画面は、チームのページから、Settings → Code review assignment と辿ると開くことができます。
図: GitHub Auto Assign 上記の例では次のような設定を行っています。
自動アサインする人数: 2人 選択アルゴリズム: ロードバランス アサイン対象外とする人: （省略） 自動アサインのアルゴリズムとしては「ラウンドロビン」と「ロードバランス」を選択できます。 「ラウンドロビン」を選択すると、単純に順番に割り当てていきます。 「ロードバランス」を選択すると、最近レビュー活動を行っていない人から優先的に割り当てていきます。
自動アサインといっても、PR 作成時に完全自動でアサインされるわけではありません（チームを手動でアサインする必要がある）。 状況に応じて、この自動アサイン機能と、ユーザー単位の手動アサインを使い分けると便利です。
ちなみに、この自動アサインの設定は、Organization の Owner メンバーだけでなく、各チームで team maintainer として登録されているユーザーが自由に行うことができます。 各チームのレビュー事情はチーム内の人が一番よく分かっているので、team maintainer をうまく設定してあげるとよいです。</description></item><item><title>GitHub で管理している社内リポジトリをトピックで分類する (topics)</title><link>https://maku77.github.io/p/3j6qatd/</link><pubDate>Wed, 14 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/3j6qatd/</guid><description>GitHub リポジトリのトピック機能 社内で GitHub を使っている場合、組織内 (GitHub organization) にたくさんのリポジトリがごちゃ混ぜになっているかもしれません。 例えば、製品アプリ用のリポジトリ、社内ツール用のリポジトリ、ドキュメント管理用のリポジトリなどなど。
このような場合は、リポジトリのトピック機能 を使用すると、リポジトリをグループ化して管理することができます。 例えば、一般ユーザーにリリースする予定の製品アプリには product というトピックを付けるというルールで運用すると、製品アプリの一覧を簡単に作成することができます。 GitHub API を使ってリポジトリの一覧情報を取得すれば、高度な自動化処理を実現することができます。
GitHub リポジトリにトピックを割り当てる リポジトリへのトピック割り当てはとても簡単です。 リポジトリのトップページを開き、右上の 歯車アイコンをクリック します。
すると、リポジトリの情報を入力するダイアログが開くので、Topics の項目に任意のトピック名を入力します。 ここでは、製品アプリであることを示す product というトピックを付けています。
あとは、左上の検索窓などに topic:product と入力すれば、組織内の製品アプリ用のリポジトリの一覧を表示することができます。
このときブラウザに表示されている URL を共有すれば、マネージャー陣にアプリリストを提出するということも簡単にできます。 製品別のトピックを付けて管理するのもいいですね！
トピックの AND 検索と OR 検索 複数のトピックで GitHub リポジトリを検索するときに、次のように指定すれば AND 検索や OR 検索を行えるようです（2023-03 確認）。
AND 検索の例: AAA トピックと BBB トピックが付いているリポジトリを検索 topic:AAA topic:BBB OR 検索の例: AAA トピックまたは BBB トピックが付いているリポジトリを検索 topic:&amp;#34;AAA BBB&amp;#34;</description></item><item><title>GitHub の REST API を Python から使用する</title><link>https://maku77.github.io/p/8axzppz/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8axzppz/</guid><description>何を作るか？ Python で GitHub API を利用するアプリケーションを作るときは、GitHub API を実行して情報取得する部分を、1 つのモジュールとして切り出しておくと全体のコードがすっきりします。 ここでは、実装例として GitHubApi というクラスを作り、次のようなことを行えるようにします。
get_members() や get_issues() といった直感的な API で GitHub の情報を取得できるようにする オプションでプロキシや Personal Access Token を指定できるようにする ページネーションによる連続アクセスで、多くの情報を一度に取得できるようにする GitHub の REST API に関しては、下記の記事を参照してください。
GitHub の REST API を使用する GitHub の REST API で Issue 情報を取得する方法いろいろ GitHubApi クラスを実装する ここで紹介する GitHubApi クラスを使うと、次のようなシンプルなコードで GitHub API を呼び出して、その結果を Python のオブジェクトとして取得することができます。
# ユーザー情報を取得する user = api.get_user(&amp;#39;maku77&amp;#39;) print(user[&amp;#39;login&amp;#39;]) 下記は、GitHubApi クラスの実装例です。
github.py import json import re import sys from urllib.parse import quote, urlencode import urllib.</description></item><item><title>GitHub の REST API で Issue 情報を取得する方法いろいろ</title><link>https://maku77.github.io/p/uvoibwi/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/uvoibwi/</guid><description>あるリポジトリの Issues の一覧を取得する GitHub の /repos/&amp;lt;ユーザー名&amp;gt;/&amp;lt;リポジトリ名&amp;gt;/issues という REST API エンドポイントにアクセスすると、指定したリポジトリ内の Issue の一覧を取得することができます。 特定の Organization が提供しているリポジトリを指定するときは、ユーザー名 の部分を Organization名 に置き換えてください。
Public リポジトリの場合 Public リポジトリの情報は、誰でも簡単に取得することができます。 下記は、curl コマンドを使って REST API を呼び出すサンプルです。 ユーザー名とリポジトリ名の部分は適切な値に変更してください。
Public なリポジトリの場合 $ USER_NAME=myname $ REPO_NAME=myrepo $ curl https://api.github.com/repos/$USER_NAME/$REPO_NAME/issues HTTP レスポンスのヘッダ情報も確認したい場合は、 -i オプションを追加してください。 上記のような GET リクエストにより、Issue のリスト（PullRequest も含む）が JSON 形式で返されます。 単純な GET リクエストなので、ブラウザで直接 URL を入力することでも情報を取得することができます。
下記は、1 つの Issue だけ含むリポジトリから情報を取得したときのサンプルです。 この Issue には、ラベル1 と ラベル2 という 2 つのラベルが設定されています。
リポジトリの Issue リストの例 (JSON) [ { &amp;#34;url&amp;#34;: &amp;#34;https://api.</description></item><item><title>Git の設定値がどのファイルで設定されているか調べる (config --show-origin)</title><link>https://maku77.github.io/p/msds6iv/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/msds6iv/</guid><description>Git 設定のスコープには、local/global/system などがあり、ある設定値がどのスコープ（設定ファイル）で行われているか混乱することがあります。
参考: Git 設定のスコープ (local/global/system) を理解する そのような場合は、git config --list --show-origin コマンドを使うと、それぞれの設定値がどのファイルで設定されいるものなのか調べることができます。
$ git config --list --show-origin ... file:/Users/maku/.gitconfig user.name=maku77 file:/Users/maku/.gitconfig user.email=xxx@gmail.com file:/Users/maku/.gitconfig core.editor=vim file:/Users/maku/.gitconfig push.default=simple file:.git/config core.repositoryformatversion=0 file:.git/config core.filemode=true file:.git/config core.bare=false file:.git/config core.logallrefupdates=true file:.git/config core.ignorecase=true file:.git/config core.precomposeunicode=true file:.git/config remote.origin.url=https://github.com/maku77/maku77.github.io.git file:.git/config remote.origin.fetch=+refs/heads/*:refs/remotes/origin/* file:.git/config branch.master.remote=origin file:.git/config branch.master.merge=refs/heads/master この例の場合、/Users/maku/.gitconfig で始まるものが global スコープ、.git/config で始まるものが local スコープで設定されていることが分かります。 ここでは、--list オプションですべての設定値を列挙していますが、次のように個別の設定値に関して調べることもできます。
$ git config --show-origin user.name file:/Users/maku/.gitconfig user.name=maku77</description></item><item><title>GitHub の REST API を使用する</title><link>https://maku77.github.io/p/mprs3v6/</link><pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/mprs3v6/</guid><description>GitHub の REST API でできること GitHub は Web API (REST API) を提供しており、コマンドラインや任意のアプリケーションから利用することで、GitHub の操作を自動化することができます。 Linux の curl コマンドや、スクリプト（Python や Ruby など）から簡単に利用できるので、Organization やリポジトリを管理する立場にある人はぜひ使ってみてください。
GitHub - REST API v3 GitHub の REST API を使うと、例えば、下記のような処理を自動化できます。
Users 指定したユーザの詳細情報を取得する 二要素認証が設定できていないユーザのリストを取得する Repositories 指定したオーナー（ユーザー or 組織）のリポジトリのリストを取得する Organizations/Members 指定した組織のユーザーリストを取得する Pull Requests Pull Request のリストを取得する Issues 指定したリポジトリの Issue のリストを取得する Projects 指定したリポジトリのプロジェクト（かんばん）のリストを取得する ただし、アプリケーションに GitHub との連携機能を本格的に組み込む場合は、REST API ではなく GraphQL API を使うをことをお勧めします。
参考: GitHub GraphQL API のクエリ例｜まくろぐ API トークンを発行する REST API を呼び出すには、API トークン (HTTPS Access Token) が必要です。 プライベートリポジトリに関する情報を取得するには、そのリポジトリへのアクセス権限を持つユーザが作成した API トークンを使用して REST API を呼び出す必要があります。</description></item><item><title>GitHub Pages で独自の 404 ページを用意する</title><link>https://maku77.github.io/p/bf2nban/</link><pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bf2nban/</guid><description>GitHub Pages で存在しないページにアクセスすると、デフォルトでは GitHub が用意している 404 ページが表示されます。 Web サイトのルートパスに 404.html ファイルを配置すると、独自の 404 ページを表示することができます。 ここでは、Jekyll のページ生成の仕組みを使って、独自の 404 ページを作成する方法を説明します。
図: GitHub Pages で独自の 404 ページを表示した例 コンテンツファイル (404.md) の作成 まず、プロジェクトのルートディレクトリに 404.md を作成し、404.html というページが出力されるようにします。
404.md --- title: &amp;#34;404&amp;#34; layout: &amp;#34;404&amp;#34; permalink: &amp;#34;404.html&amp;#34; --- 表示内容に関しては、404 ページ専用のレイアウト (_layouts/404.html) の方で定義することにします。 よって、上記の Markdown ファイルでは、フロントマターで出力設定だけを記述しておきます。
レイアウトファイル (_layouts/404.html) の作成 404 ページの出力内容は特有のレイアウトになることが多いので、専用のレイアウトファイルで作成するのがオススメです。 ここでは、_layouts/404.html というパスにファイルを作成します（404.md のフロントマターで指定したレイアウト名に合わせてください）。
_layouts/404.html の記述例 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;ja&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;meta property=&amp;#34;og:title&amp;#34; content=&amp;#34;{{ page.title }} | {{ site.</description></item><item><title>Git で他の人が作成したブランチ上で作業する</title><link>https://maku77.github.io/p/ewvaoe3/</link><pubDate>Tue, 05 Apr 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ewvaoe3/</guid><description>GitHub などの共有リポジトリを使用して複数のメンバーで開発を進めている場合、他のメンバーが作成したブランチ（git push されたブランチ）をチェックアウトして共同作業したいことがあります。 そのような場合は、下記のような手順でローカルブランチを作成して編集作業を進めます。
共有リポジトリに push されているブランチをフェッチする (git fetch) 作業用のローカルブランチを作成する (git branch) ローカルブランチをチェックアウトして編集作業を行う (git checkout, git commit) 変更内容を共有リポジトリに push する (git push) 共有リポジトリに push されているブランチをフェッチする まずは、他の人が共有リポジトリ上に作成したブランチをローカルに持ってくる必要があります（--prune オプションを付けると、共有リポジトリ側で削除されているブランチをローカルからも削除してくれます）。
$ git fetch --prune リモートトラッキングブランチの一覧を表示し、対象のブランチをうまく fetch してこれたかを確認しておきます。
$ git branch -r origin/HEAD -&amp;gt; origin/main origin/change-date-format origin/fix-lint-warnings origin/main リモートトラッキングブランチ名は、&amp;lt;リポジトリ&amp;gt;/&amp;lt;ブランチ&amp;gt; という構成になっていますが、clone 元のリポジトリ名は origin というエイリアス名で指定できるようになっています。
作業用のローカルブランチを作成する リモートトラッキングブランチは、あくまでリモートリポジトリ側の内容を追跡するためのものなので、ここに直接修正を加えていくことはできません。 そこで、リモートトラッキングブランチをベースにして、ローカルブランチを作成する必要があります。 次の例では、リモートトラッキングブランチ origin/change-date-format と同名の change-date-format というローカルブランチを作成しています。
$ git branch change-date-format origin/change-date-format Branch &amp;#39;change-date-format&amp;#39; set up to track remote branch &amp;#39;change-date-format&amp;#39; from &amp;#39;origin&amp;#39;.</description></item><item><title>GitHub の Markdown でメールアドレスへのリンクを記述する</title><link>https://maku77.github.io/p/xikzhtr/</link><pubDate>Thu, 04 Feb 2016 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xikzhtr/</guid><description>Markdown ファイルの中で、E メールアドレスのリンクを記述するには下記のようにします。
Markdown ファイル抜粋 [表示名](&amp;lt;mailto:xxx@example.com&amp;gt;) 上記のように &amp;lt; と &amp;gt; で囲んだメールアドレスは、出力される HTML の中では、下記のように実体参照による表現に変換されるため、スパムメールの対策にもなります。
変換後の HTML &amp;lt;a href=&amp;#34;&amp;amp;#109;&amp;amp;#097;&amp;amp;#105;&amp;amp;#108;&amp;amp;#116;&amp;amp;#111;:&amp;amp;#120;&amp;amp;#120;&amp;amp;#120;&amp;amp;#064;&amp;amp;#101;&amp;amp;#120;&amp;amp;#097;&amp;amp;#109;&amp;amp;#112;&amp;amp;#108;&amp;amp;#101;&amp;amp;#046;&amp;amp;#099;&amp;amp;#111;&amp;amp;#109;&amp;#34;&amp;gt;表示名&amp;lt;/a&amp;gt; 実際の表示結果は次のような感じになります。
表示名</description></item><item><title>Git で管理するシェルスクリプトに実行権限（パーミッション）を付ける（chmod +x 相当）</title><link>https://maku77.github.io/p/xwxdv6y/</link><pubDate>Wed, 21 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xwxdv6y/</guid><description>Git はファイルの所有者情報なのどメタ情報を管理しませんが、ファイルの実行可能ビットだけは記録する ようになっています（Linux の chmod +x で付加するビット）。
例えば、Windows 上で Linux のシェルスクリプトを作成していて、Git リポジトリにコミットするときは、次のように git update-index コマンドで実行可能ビットを付加してからコミットしなければいけません。
シェルスクリプトに実行可能ビットを付ける $ git update-index --add --chmod=+x &amp;lt;filename&amp;gt; $ git commit Linux 上で作業する場合は、chmod +x で付加した情報が反映されるので、通常通り git add でファイルを追加するだけで OK です。</description></item><item><title>GitHub の新しい Organization パーミッションモデル（2015年10月リリース）について理解する</title><link>https://maku77.github.io/p/494ernf/</link><pubDate>Thu, 01 Oct 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/494ernf/</guid><description>GitHub の Organization アカウントの新しいパーミッションモデルが公開されました。
参考: New organization permissions now available - The GitHub Blog チームメンテナの設定が可能 チーム内のメンバーに対して、team maintainer という役割を設定できるようになりました（念願！）。 これまでは、各チームに対するメンバー追加を行うときは、Organization の Owners メンバーが追加作業を行う必要がありましたが、この機能によって、チーム内のメンバー管理は、そのチームの代表者 に任せることができるようになります。
チーム内のメンバーを team maintainer に割り当てるには次のようにします。
Organization のトップページから Teams を選択 対象のチームを選択 チームメンテナに設定したいメンバーを選択し、&amp;ldquo;Change role&amp;hellip;&amp;rdquo; → &amp;ldquo;Maintainer&amp;rdquo; を選択 チームメンテナとなったメンバーは、自分の管理するチームに対して、自由にメンバーを参加させたり外したりできます。 チーム名の変更や、チーム内メンバーのチームメンテナへの昇格も自由に行えるようになるため、ある程度責任のあるリーダクラスの人をチームメンテナとして設定すべきです。
参考: Giving &amp;ldquo;team maintainer&amp;rdquo; permissions to an organization member Organization 内のリポジトリに対するデフォルトパーミッションを設定可能 デフォルトパーミッションとして Read/Write 権限を付加しておくことで、Organization 内のメンバー全員に対して、すべてのプロジェクト（リポジトリ）の参照権限、コミット権限を付けることができます。
例えば、直接コミットできるメンバーはプロジェクトごとに限定したいけれど、コードの参照や PullRequest くらいは全メンバーに許可したい、ということが簡単に実現できます（これまでは、プロジェクトに対する参照権限を与えるために、対象のユーザを Read 権限のあるチームに追加させ、そのチームをプロジェクトに登録する、という分かりにくい作業が必要でした）。
メンバー全員に全リポジトリの参照権限を付けるには以下のようにします。
Organization のトップページから Settings を選択 Member privileges を選択 Base permissions の項目を No permission から Read に変更 全メンバーが全プロジェクトの開発に関わっているような Organization では、デフォルトのパーミッションとして Write を設定しておけば、アクセス権限管理のためにチームを作成する必要がなくなります。</description></item><item><title>GitHub の Organization を構成したときのチームの権限について理解する</title><link>https://maku77.github.io/p/x7hr9z7/</link><pubDate>Thu, 07 May 2015 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x7hr9z7/</guid><description>GitHub の Organization の 4 種類のチーム GitHub で Organization を作成すると、その下に作成したリポジトリは、Organization 内に作成したチーム単位でアクセス権限を設定することになります。 GitHub のサイト にざっと説明がありますが、分かりにくいのでここで補足します。
チーム区分としては、
Owners Admin Write Read に分かれていて、それぞれ異なる権限を持ちます。
Owners チームとその権限 Owners はその名の通り organization 自体の管理者チームであり、デフォルトで存在しているものです。 残りの 3 つ（Admin、Write、Read）とは性質が異なり、削除したり、Owners という名前を変更することはできません。 organization を作成した人が、Owners の最初のメンバになります。
Owners 権限 デフォルトで存在するチームで、その organization に関してすべての権限を持つ Owners に属するメンバは、支払い情報を管理し、クレジットカードなどの登録を行う Owners には必ず 1 人以上が所属している必要がある organization へのメンバ追加が可能 リポジトリを作成可能 チームを作成可能 残りの Admin、Write、Read というのは、後付で作成したチームに対して割り当てる権限を意味しています。 Owners チームは organization 内でひとつしか存在しませんが、Admin、Write、Read 権限を持つチームは複数作ることが可能です。 チームを作成できるのは Owners のメンバだけです。
各リポジトリへのアクセス権限は、このチーム単位で参加者 (contributors) を割り当てることで行います。 例えば、my-project というリポジトリの contributors として、team1 (Write 権限)、team2 (Read 権限) を参加させた場合、team1 に参加しているメンバだけが、my-project へのコミット権限を持つことになります。 リポジトリに対してチームを割り当てることができるのは Owners のメンバだけです。</description></item><item><title>Git でブランチやタグの作者を調べる (git for-each-ref)</title><link>https://maku77.github.io/p/o2m2ft7/</link><pubDate>Thu, 18 Sep 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/o2m2ft7/</guid><description>トピックブランチを使った開発手法を適用していると、トピックブランチの削除忘れなどにより、ブランチが散乱してくることがあります。 このような場合は、誰が作成したブランチが放置されているのか調べる必要があります。 下記は、手っ取り早くブランチの作者を調べる方法です。
まずは、GitHub（中央リポジトリ）上で削除済みのブランチは、ローカルのリモートトラッキングブランチからも削除しておきます。
不要なリモートトラッキングブランチを削除 $ git fetch --prune あとは、次のようにすれば、ブランチやタグ (refs) の作者を調べることができます。
ブランチやタグの作者を調べる $ git for-each-ref --format=%(authorname)%09%09%(refname) | sort maku refs/heads/main maku refs/heads/my-branch john refs/remotes/origin/apply-eslint ripper refs/remotes/origin/gh-pages maku refs/remotes/origin/HEAD maku refs/remotes/origin/main</description></item><item><title>GitHub でソフトウェア配布用にプロジェクトの Web サイトを作成する (GitHub Pages)</title><link>https://maku77.github.io/p/yujway4/</link><pubDate>Mon, 14 Jul 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/yujway4/</guid><description>GitHub Pages という機能を使用すると、GitHub 上で Web サイトをホスティングできます。GitHub を開発用にだけ使うのであれば、リポジトリだけ公開しておけばよいのですが、作成したソフトウェアを配布したり、マニュアルを公開するのであれば、GitHub Pages 上で通常の Web サイトとして見えるようにしておくのがよいでしょう。
プロジェクトの Web サイトを作る 各プロジェクト用の GitHub Pages は非常に簡単に作成できます。 各リポジトリに gh-pages という名前のブランチを作り、そこに Web サイトのコンテンツ（index.html など）をコミットすれば、そのプロジェクト用の Web サイトとして見えるようになります。
https://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository&amp;gt;/ Organization を作成している場合は、上記の &amp;lt;username&amp;gt; のところを、&amp;lt;organization&amp;gt; と読み替えてください。
☝️ GitHub Pages の非公開化 プライベートリポジトリで GitHub Pages (gh-pages) を作ったとしても、Web サイトはインターネット上に公開されてしまうことに注意してください。 プライベートな情報提供サイトを作る場合は、リポジトリの README.md や Wiki を活用するか、独自で Web サーバを立ち上げる必要があります。
あるいは、GitHub Enterprise Cloud という高額なプランを導入すれば、非公開の GitHub Pages を作成することができます。
参考: Changing the visibility of your GitHub Pages site - GitHub Enterprise Cloud Docs ユーザ用、組織用の Web サイトを作る GitHub Pages では、リポジトリごとの Web サイトだけではなく、ユーザや組織用のトップサイトを作成することも可能です。 その場合は、&amp;lt;username&amp;gt;.</description></item><item><title>Git 設定のスコープ (local/global/system) を理解する</title><link>https://maku77.github.io/p/af7q7n3/</link><pubDate>Sun, 25 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/af7q7n3/</guid><description>Git 設定の 3 つのスコープ git config による設定のスコープは 3 種類あり、スコープが狭くなるほど参照時の優先度は高くなります。 下記はそれぞれのスコープでの設定方法を、優先度の高い順に示しています。 カッコの中のファイル名は、コマンドを実行したときの設定値の保存先です。
$ git config --local ... # 各リポジトリごとの設定 (.git/config)（優先度:高） $ git config --global ... # 現在のユーザの共通設定 (~/.gitconfig) $ git config --system ... # システム内の共通設定 (/etc/gitconfig など)（優先度:低） 例えば、global 設定で user.name が Ichiro になっていても、local 設定が Jiro になっていれば、Jiro の方が優先的に使用されます。 プロジェクト（リポジトリ）ごとに固有の設定をする場合は、local なスコープで設定を行うとよいでしょう。 この場合、プロジェクトの作業ツリーのトップにある .git/config に設定が保存されます。
例えば、次のようにして local 設定の user.name と user.email を変更することができます。
$ git config --local user.name maku77 $ git config --local user.email maku77@example.com 上記コマンドを実行した後で、&amp;lt;リポジトリ&amp;gt;/.</description></item><item><title>（旧）GitHub のプランと GitHub ライクなツールの比較など（GitHub と GitLab の比較）</title><link>https://maku77.github.io/p/x63is5h/</link><pubDate>Wed, 14 May 2014 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x63is5h/</guid><description>GitHub Public repository と Private repository プラン GitHub は公開リポジトリのみであれば無料で使用できるが、非公開にするには有料。 10 repos で $25/month 20 repos で $50/month GitHub Enterprise（社内サーバ用） GitHub 社が提供している、GitHub の機能をまるごと含めた VM。 サーバは別途用意する必要あり。 社内で GitHub の機能を使ってコード管理したい場合などに有用。 若干高い。20 person で $5,000/year GitLab 特徴 一番メジャーなオープンソースの GitHub クローン 実装は Ruby on Rails. (+ PostgreSQL, Redis, Nginx, Unicorn, etc.) インストールは比較的容易。 Pull Request もどき有り (Merge Request)。ブランチ間のマージも可能。 LDAP 連携。ActiveDirectory 連携。 GitHub より便利なところ ユーザに対して Master 権限と Developer 権限を分けて設定することで、master ブランチへマージできる人を制限できる。これにより、チーム内開発において、トピックブランチを使用した開発を強制できるようになる（GitHub フローなど）。 MergeRequest のコメントで各ユーザが +1 と記述しておくと、MergeRequest のページにその合計数が表示される。これを利用して、「+3 溜まったらトピックブランチをマージしてよい」といった運用を行うことができる。 Gitorious 特徴 若干独自路線気味の GitHub クローン 実装は Ruby on Rails.</description></item><item><title>Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)</title><link>https://maku77.github.io/p/cv5pi7a/</link><pubDate>Mon, 23 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cv5pi7a/</guid><description>参考: Git でブランチを削除する (git branch -d/-D) 必要のないリモートブランチを削除（リモートサーバー側） git branch -d コマンドを使ってローカルのブランチを削除しても、GitHub などに既に push されているブランチは削除されません（他のメンバーには、まだブランチが存在しているように見えます）。 GitHub 側のブランチを削除するには、ローカルブランチを削除するのとは別のコマンドを実行する必要があります。
まずは、リモートトラッキングブランチの一覧を確認しておきます。
$ git branch -r origin/HEAD -&amp;gt; origin/main origin/main origin/mybranch1 origin/mybranch2 origin/mybranch3 例えば、この中の mybranch2 を削除したい場合は、以下のようにして origin サーバに削除要求を送ります。 削除したいブランチの名前の前にコロン (:) を付けるのがポイントです。
$ git push origin :mybranch2 git push の 2 番目のパラメータで指定するリファレンス名は、&amp;lt;プッシュ元のブランチ名&amp;gt;:&amp;lt;プッシュ先のブランチ名&amp;gt; という形式を取りますが、このコロンの左側の部分を空にすることで、プッシュ先のブランチを削除する（空にする）という意味になります。
ローカル側のリモートトラッキングブランチを削除する 中央リポジトリ (GitHub) 側のブランチを削除しても、ローカルに作られているリモートトラッキングブランチは削除されません。 以下のように必要のないリモートトラッキングブランチを削除する必要があります。
# フェッチと同時に必要のないリモートトラッキングブランチを削除する（オススメ） $ git fetch --prune # 必要のないリモートトラッキングブランチを削除する $ git remote prune origin あるいは、以下のように指定したリモートトラッキングブランチを削除することもできます。
$ git branch -r -d origin/mybranch 前者の場合は、中央リポジトリ上から実際に削除されたブランチを、ローカルのリモートトラッキングブランチから削除します。 後者の場合は、中央リポジトリは関係なしに、指定したローカルのリモートトラッキングブランチを削除します。</description></item><item><title>Git の detached HEAD 状態へのチェックアウトとは</title><link>https://maku77.github.io/p/whv8ues/</link><pubDate>Mon, 23 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/whv8ues/</guid><description>ある Git ブランチのコードをチェックアウトするには、
$ git switch &amp;lt;ブランチ名&amp;gt; のように実行しますが、そのブランチの最新コードではなく、ある特定のバージョン（コミット ID）のソースコードを少しだけ覗いてみたいということがあります。 そのような場合は、ブランチ名の代わりにコミット ID を指定してチェックアウトすることができます。
コミット名を指定して git checkout を実行すると、どのローカルブランチもチェックアウトしていない detached HEAD という状態になります（HEAD が detached されているということ）。 例えば、以下のように git checkout すると、この状態になります。
$ git checkout 0d3ce61 # コミット ID を指定 $ git checkout HEAD^0 # 最新のコミットを指定 $ git checkout HEAD^1 # １つ前のコミットを指定 $ git checkout v2.6.18 # タグで示されるコミットを指定 $ git checkout origin/main # リモートトラッキングブランチを指定 HEAD が detached された状態で git branch を実行すると、どのブランチにもいないことを示す (no branch) が表示されます。
$ git branch * (no branch) main mybranch detached HEAD 状態でも git commit などのコマンドを実行できますが、どのブランチにもいない状態なので、どのブランチの head も更新されません。 再びローカルブランチ名を指定してチェックアウトすると、detached HEAD で行っていた変更を破棄してブランチの最新状態に戻ることができます。</description></item><item><title>Git で他のブランチの最新ファイルを現在のブランチにコピーする (git checkout)</title><link>https://maku77.github.io/p/6g8n3jw/</link><pubDate>Fri, 20 Aug 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6g8n3jw/</guid><description>Git では、ファイル単位で他のブランチにコミットされているファイルをコピーしてくることができます。 例えば、現在 main ブランチをチェックアウトしているときに、別のブランチ mybranch の sample.txt の最新をコピーしてきたいときは次のように実行します。
$ git checkout mybranch sample.txt</description></item><item><title>Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b)</title><link>https://maku77.github.io/p/ivbss76/</link><pubDate>Mon, 19 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ivbss76/</guid><description>git switch -c コマンドを使用すると、ブランチの作成と、そのブランチへの切り替え（チェックアウト）を同時に行うことができます（昔は同様の振る舞いをする git checkout -b コマンドが使っていました）。
ブランチの作成と切り替えを一度に行う $ git switch -c mybranch # ブランチ mybranch の作成＆チェックアウト Switched to a new branch &amp;#39;mybranch&amp;#39; $ git branch # 現在チェックアウトしているブランチの確認 main * mybranch git branch コマンドでのブランチ作成と同様、ブランチ元のブランチ名を指定することもできます。
$ git switch -c mybranch main</description></item><item><title>Git でブランチ名を変更する (git branch -m)</title><link>https://maku77.github.io/p/9bh2ody/</link><pubDate>Mon, 19 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/9bh2ody/</guid><description>Git のブランチ名を変更するには以下のように git branch -m コマンドを使用します。
ブランチ名を変更する $ git branch -m new # 現在チェックアウトしているブランチの名前を new に変更 $ git branch -m old new # old ブランチの名前を new に変更 GitHub などのリモートリポジトリに old リポジトリがすでに push されている場合は、次のようにして中央リポジトリ側のリポジトリ名も変更する必要があります。
GitHub 側のブランチ名を変更する $ git push origin new # 新しいブランチ new を push $ git push origin :old # 古いブランチ old を削除 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)</description></item><item><title>Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout)</title><link>https://maku77.github.io/p/8cwbp3e/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8cwbp3e/</guid><description>作業対象のブランチを切り替えるには、git switch コマンドで切り替え先のブランチ名を指定します（昔は git checkout コマンドが使われていましたが、現在は役割を明確にした git switch コマンドが使われています）。
ブランチを切り替える前に、 git branch コマンドを使用して、現在チェックアウトしているブランチと、切り替え先のブランチ名を確認しておくとよいです。
ブランチの一覧を確認 $ git branch * main my-branch 上記の出力で、現在の作業対象が main であることが分かります。 次のようにすると、作業対象を my-branch ブランチに切り替えることができます。
my-branch ブランチに切り替える $ git switch my-branch Switched to branch &amp;#34;my-branch&amp;#34; 切り替わっていることを確認する $ git branch main * my-branch これで、作業対象のブランチが my-branch に切り替わったので、これ以降の変更作業 (git commit) は、my-branch ブランチだけに反映され、main ブランチには反映されなくなります。</description></item><item><title>Git でブランチを作成する (git branch)</title><link>https://maku77.github.io/p/x9s8k2e/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/x9s8k2e/</guid><description>現在チェックアウトしているブランチから、新しいブランチを作成するには次のコマンドを使用します。
$ git branch &amp;lt;新しいブランチ名&amp;gt; ブランチ元のブランチを指定して、新しいブランチを作成するには次のようにします。
$ git branch &amp;lt;新しいブランチ名&amp;gt; &amp;lt;既存のブランチ名&amp;gt; 例: main ブランチから REL-1.0 ブランチを作成する $ git branch REL-1.0 main git branch コマンドを引数なしで実行すると、ブランチの一覧を確認できます（git branch --list と同等）。
$ git branch REL-1.0 * master 上記の例では、今回作成された REL-1.0 と、デフォルトの master ブランチが存在することが分かります。master の前の * は、現在の作業対象（チェックアウトされているブランチ）が master ブランチであることを示しています。 作業対象を新しいブランチに切り替えるには、git switch コマンドを使用する必要があります。
参考: Git でブランチをチェックアウトする（作業対象のブランチを切り替える）(git switch/checkout) 参考: Git でブランチの作成とチェックアウトを同時に行う (git switch -c, git checkout -b) 参考: Git で他の人が作成したブランチ上で作業する ちなみに、ローカルで新しく作成したブランチの内容を GitHub などの中央リポジトリに git push するには、次のように実行します。
origin リポジトリへ新しいブランチ REL-1.</description></item><item><title>Git でブランチを削除する (git branch -d/-D)</title><link>https://maku77.github.io/p/stpfje9/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/stpfje9/</guid><description>不要になったブランチを削除するには、git branch -d コマンドでブランチ名を指定します。 削除対象のブランチが作業対象になっていると削除できないので、先に git switch コマンドで別のブランチに切り替えてから削除を実行します。
mybranch ブランチを削除する $ git switch main $ git branch -d mybranch Deleted branch mybranch (was 1cc229d3) 削除しようとしているブランチの変更内容が、ブランチ元にマージされていない場合、以下のようなエラーが表示されます。
error: The branch &amp;#39;mybranch&amp;#39; is not an ancestor of your current HEAD. If you are sure you want to delete it, run &amp;#39;git branch -D mybranch&amp;#39; この場合は、先にブランチ元にマージを実行するか、あるいは、変更内容が完全に消えても構わない場合は -d オプションの代わりに -D オプションを指定して実行します。
マージされていないブランチを強制的に削除する $ git branch -D mybranch 参考: Git でリモートブランチを削除する (git push origin :xxx, git fetch --prune)</description></item><item><title>Git のコミット時にコメント記述に使用するエディタを設定する (core.editor)</title><link>https://maku77.github.io/p/cqjv7wv/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/cqjv7wv/</guid><description>git commit コマンド実行時に、-m オプションでコメントを指定しなかった場合は、コメント入力のためにエディタが起動します。 ここで起動するエディタは自由に変更できます。 操作に慣れた Vim エディタなどを指定しておけば、コミット前の編集画面で操作ミスしてしまうこともなくなるでしょう。
例: エディタを vim に設定する $ git config --global core.editor vim 上記の例では、core.editor 設定を使ってエディタの指定を行っていますが、エディタの指定方法はたくさんあり、Git は次の順番で使用するエディタを判断します。
環境変数 GIT_EDITOR Git の core.editor 設定 環境変数 VISUAL 環境変数 EDITOR vi（Debian、Ubuntu の場合は editor）</description></item><item><title>Git 用語集</title><link>https://maku77.github.io/p/f844tkg/</link><pubDate>Sat, 17 Jul 2010 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/f844tkg/</guid><description>作業ツリー、ワークツリー (work tree) Git の管理下に入ったローカルのディレクトリツリーを 作業ツリー (work tree) と呼びます。 リポジトリに記録された内容を作業ツリーに展開する操作を チェックアウト (checkout) と呼びます。 git init コマンドなどで作成される .git/ ディレクトリが存在するディレクトリが、作業ツリーのルートになります。 Subversion や CVS では「作業コピー」と呼んでいました。
リポジトリ (repository) 変更履歴などを管理するリポジトリで、Git では必ずローカルディレクトリに存在します。 他のマシン上にあるリポジトリも、ローカルにあるリポジトリも対等の関係にあり、各リポジトリにコミットされた変更内容を互いにやりとりすることでプロジェクト全体の変更の一貫性を保ちます。 一般的には、ある一つのマシンのリポジトリを中央リポジトリとし、そこから最終的なプロジェクトの成果物を生成します。 リポジトリの実体は、作業ツリーのルートにある .git/ ディレクトリです。
ステージする (stage) あるファイルを次回のコミット対象に含めることを、ファイルを ステージする (stage) といいます。 Perforce を使ったことがある人は、p4 edit などによる Perforce サーバへの変更通知と近い概念なので分かりやすいと思います。 Git では、git add や git rm コマンドでファイルを指定すると、その情報が Git のインデックス情報として登録され、次回のコミット対象となります。
ハンク (hunk) ファイル内の連続した変更箇所のこと。 1 つのファイル内に連続した変更箇所が複数あれば、ハンクも複数存在することになります。 Git ではファイル単位で変更を追跡するのではなく、もっと細かいハンク単位で追跡します。 つまり、ファイル内の変更の一部だけをコミットするという作業が行えます。
チェックアウト (checkout) リポジトリに格納されたあるリビジョンの内容を作業ツリーに展開し、ローカルファイルとして見えるようにすることを チェックアウトする (checkout) と言います。 また、チェックアウトされているブランチとは、現在の作業ツリーに反映されているブランチのことで、作業対象になっているブランチのことをいいます。
main ブランチ / master ブランチ git init した後の初期状態で何かファイルをコミットすると、デフォルトで main というブランチが作成され、チェックアウトされた状態になります。 昔は master という名前が使われていましたが、アメリカの BLM 運動をきっかけに差別的で不適切な用語とされ main という名前に置き換えられました。</description></item></channel></rss>