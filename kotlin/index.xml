<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kotlin on 天才まくまくノート</title><link>https://maku77.github.io/kotlin/</link><description>Recent content in Kotlin on 天才まくまくノート</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Tue, 01 Jun 2021 00:00:00 +0900</lastBuildDate><atom:link href="https://maku77.github.io/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlinメモ: Kotlin で日時（日付／時刻）を扱う方法いろいろ</title><link>https://maku77.github.io/p/9c9d2t7/</link><pubDate>Fri, 04 Dec 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9c9d2t7/</guid><description>&lt;h2 id="日時を表すクラス">日時を表すクラス&lt;/h2>
&lt;p>Kotlin で日付や時刻を扱うには、Java 標準ライブラリの &lt;strong>&lt;code>java.time&lt;/code>&lt;/strong> パッケージを使用します。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>クラス名&lt;/th>
 &lt;th>表現する情報&lt;/th>
 &lt;th>ISO-8601 表現&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;strong>&lt;code>LocalDate&lt;/code>&lt;/strong>&lt;/td>
 &lt;td>日付（年-月-日）&lt;/td>
 &lt;td>&lt;code>2020-12-04&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>&lt;code>LocalTime&lt;/code>&lt;/strong>&lt;/td>
 &lt;td>時刻（時-分-秒）&lt;/td>
 &lt;td>&lt;code>20:26:47.549110600&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>&lt;code>LocalDateTime&lt;/code>&lt;/strong>&lt;/td>
 &lt;td>日付＆時刻（年-月-日-時-分-秒）&lt;/td>
 &lt;td>&lt;code>2020-12-04T20:26:47.549110600&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;strong>&lt;code>ZonedDateTime&lt;/code>&lt;/strong>&lt;/td>
 &lt;td>日付＆時刻（年-月-日-時-分-秒）＋ タイムゾーン&lt;/td>
 &lt;td>&lt;code>2020-12-04T20:26:47.549110600+09:00[Asia/Tokyo]&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>時刻はナノ秒の精度まで保持可能ですが、実際にどの精度までの値が格納されているかはオブジェクトの生成方法に依存します。&lt;/p>
&lt;h3 id="特徴-local-系と-zoned-系がある">特徴: Local 系と Zoned 系がある&lt;/h3>
&lt;p>日時を表すクラスは、大きく &lt;code>LocalXxx&lt;/code> 系と &lt;code>ZonedXxx&lt;/code> に分かれています。&lt;/p>
&lt;p>&lt;code>LocalDateTime&lt;/code> は単純な日時情報（年-月-日-時-分-秒）を保持するためのクラスで、内部にタイムゾーン情報を保持していません。
つまり、一度 &lt;code>2020-02-15T21:30:50&lt;/code> という情報を持つオブジェクトを生成したら、そのオブジェクトはどの国で使っても &lt;code>2020-02-15T21:30:50&lt;/code> という情報として扱うということです（時差の概念は持たない）。&lt;/p>
&lt;p>一方で、&lt;code>ZonedDateTime&lt;/code> は、&lt;code>JST&lt;/code> などのタイムゾーン情報 (&lt;code>ZoneId&lt;/code>) を内部に保持しているため、地域ごとの時差を表現できます。
日本であれば UTC 時刻＋9時間なので、&lt;code>2020-02-15T21:30:50+09:00&lt;/code> といった情報を保持することになります。&lt;/p>
&lt;p>つまり、&lt;code>ZonedDateTime = LocalDateTime + ZoneId&lt;/code> なので、&lt;code>LocalDateTime&lt;/code> オブジェクトに &lt;code>ZoneId&lt;/code> オブジェクトを付加してやれば、&lt;code>ZonedDateTime&lt;/code> オブジェクトを生成することができます。
具体的には、&lt;code>ZonedDateTime.of()&lt;/code> か &lt;code>LocalDateTime#atZone()&lt;/code>を使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">localDateTime&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">LocalDateTime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">zonedDateTime1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">ZonedDateTime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">of&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">localDateTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nc">ZoneId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">systemDefault&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">zonedDateTime2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">ZonedDateTime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">of&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">localDateTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nc">ZoneId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">of&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Asia/Tokyo&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">zonedDateTime3&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">ZonedDateTime&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">of&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">localDateTime&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nc">ZoneId&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">of&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;America/Los_Angeles&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">localDateTime&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 2020-12-04T20:32:26.214124900
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">zonedDateTime1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 2020-12-04T20:32:26.214124900+09:00[Asia/Tokyo]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">zonedDateTime2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 2020-12-04T20:32:26.214124900+09:00[Asia/Tokyo]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">zonedDateTime3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 2020-12-04T20:32:26.214124900-08:00[America/Los_Angeles]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>生成された &lt;code>ZonedDateTime&lt;/code> オブジェクトにはタイムゾーン情報が付加されていますが、時-分-秒の情報は変化していないことに注意してください。&lt;/p></description></item><item><title>Kotlinメモ: インラインクラスでプリミティブ型の型安全性を確保する (inline class)</title><link>https://maku77.github.io/p/khn4o5z/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/khn4o5z/</guid><description>&lt;h2 id="インラインクラスの基本">インラインクラスの基本&lt;/h2>
&lt;p>Kotlin のインラインクラスを使用すると、パフォーマンスに悪影響のないプリミティブ型ラッパークラスを作成することができます。
プライマリコンストラクタで 1 つの値（プロパティ）のみを受け取るクラスは、次のように &lt;strong>&lt;code>inline&lt;/code>&lt;/strong> キーワードを付けてインラインクラスにすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">inline&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このインラインクラスは、通常のクラスと同様に次のように使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>違いはコンパイル後のバイトコードに現れます。
上記のコードはコンパイル時にインライン展開され、次のようなコードを記述したのと同様に扱われます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">コンパイル後のコード&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>つまり、&lt;strong>コンパイル時は具体的な型（&lt;code>Name&lt;/code> 型）で型チェックを行いつつも、実行時にはプリミティブ型になっているのでパフォーマンスが悪化しない&lt;/strong>、という両方の利点を享受できます。&lt;/p>
&lt;p>現状、インラインクラスは、init ブロックを持てない、&lt;a href="https://kotlinlang.org/docs/properties.html#backing-fields">バッキングフィールド&lt;/a>を持てない、といった制約がありますが、単純な getter プロパティや関数を持つことはできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">inline&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">length&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">get&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello, &lt;/span>&lt;span class="si">$name&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; val name: String = &amp;#34;Maku&amp;#34; に置き換えられる
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; String オブジェクトの greet() を呼び出す？
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の &lt;code>name&lt;/code> 変数はコンパイル時に &lt;code>String&lt;/code> オブジェクトに置き換えられるので、&lt;code>name.greet()&lt;/code> の部分でエラーになりそうですが、コンパイラがうまいこと静的関数を生成して問題なく動作するようにしてくれます。
上記のコードは次のようなコードにコンパイルされます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nc">Name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="n">greet&lt;/span>&lt;span class="p">-&lt;/span>&lt;span class="n">impl&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="インラインクラスの用途">インラインクラスの用途&lt;/h2>
&lt;h3 id="同一のプリミティブ型を区別したいとき">同一のプリミティブ型を区別したいとき&lt;/h3>
&lt;p>同じ型のパラメータを複数取る関数を作ると、引数の指定方法を間違える不具合が入りやすくなります。
例えば、次の &lt;code>searchBooks&lt;/code> 関数は 2 つの &lt;code>Int&lt;/code> 値を受け取ります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">searchBooks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">authorId&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">genreId&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Book&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2 つのパラメーターは両方とも &lt;code>Int&lt;/code> 型なので、次のように順序を間違えて呼び出してしまってもコンパイルエラーになってくれません。
実行時にもすぐには分からず、潜在的な不具合を埋め込んでしまう可能性があります。&lt;/p></description></item><item><title>Kotlinメモ: インライン関数の特徴を理解する (inline fun)</title><link>https://maku77.github.io/p/8ieeha7/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8ieeha7/</guid><description>&lt;h2 id="インライン関数">インライン関数&lt;/h2>
&lt;p>Kotlin の関数定義には &lt;code>fun&lt;/code> キーワードを使用しますが、このとき、&lt;strong>&lt;code>inline fun&lt;/code>&lt;/strong> と記述すると &lt;strong>インライン関数&lt;/strong> として定義することができます。
&lt;code>inline&lt;/code> 修飾子が付けられた関数を呼び出すと、呼び出した位置に関数の内容がインライン展開される形でコンパイルされるため、結果的に次のような効果が得られます。&lt;/p>
&lt;ul>
&lt;li>型パラメータを &lt;code>reified&lt;/code> 指定できる&lt;/li>
&lt;li>非局所リターン (non-local return) を行えるようになる&lt;/li>
&lt;li>実行時の高速化を期待できる&lt;/li>
&lt;/ul>
&lt;h2 id="型パラメータを-reified-指定できる">型パラメータを reified 指定できる&lt;/h2>
&lt;p>Java (JVM) では、型パラメータを持つ関数（ジェネリクス関数）を定義しても、その型情報を実行時には参照することができません。
なぜなら、型パラメータはコンパイル時の型チェックにのみ使われるものであり、後方互換性のために実行コードからは削除されてしまうからです（イレイジャと呼びます）。
Kotlin では、関数を &lt;code>inline&lt;/code> 定義し、さらに型パラメータを &lt;strong>&lt;code>reified&lt;/code>&lt;/strong> 指定 (具体化型パラメータ）することにより、実行時に型情報を参照することができます。&lt;/p>
&lt;p>例えば次のようなコードをコンパイル、実行することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 型パラメータで渡された型の名前を出力する
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">inline&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="k">reified&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">printType&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">simpleName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">printType&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">// =&amp;gt; &amp;#34;String&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは、関数の内容が次のように呼び出し位置にインライン展開され、型情報がそこに埋め込まれることにより実現されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">simpleName&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、型パラメータの &lt;code>reified&lt;/code> 指定は、&lt;code>inline&lt;/code> 関数があってこその機能といえます（実際、&lt;code>inline&lt;/code> 関数以外で型パラメータを &lt;code>reified&lt;/code> 指定するとコンパイルエラーになります）。&lt;/p>
&lt;p>Kotlin の標準ライブラリ (&lt;code>kotlin.collections&lt;/code>) が提供する Collection の拡張関数 &lt;strong>&lt;code>filterIsInstance&amp;lt;T&amp;gt;&lt;/code>&lt;/strong> も同じように &lt;code>inline&lt;/code> 定義されており、型パラメータで指定した型の要素を抽出することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filterIsInstance&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;())&lt;/span> &lt;span class="c1">// =&amp;gt; &amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>reified&lt;/code> については、下記の記事でもう少し詳しく説明しています。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="../p/u32ykpo/">ジェネリクス: &lt;code>reified&lt;/code> でジェネリクスの型情報を維持する&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="非局所リターン-non-local-return-を行えるようになる">非局所リターン (non-local return) を行えるようになる&lt;/h2>
&lt;p>&lt;strong>非局所リターン&lt;/strong> というのは、あるブロックの内側から、外側のブロックを抜ける &lt;code>return&lt;/code> を行うことです。&lt;/p></description></item><item><title>Kotlinメモ: VS Code で Kotlin の開発環境を構築する</title><link>https://maku77.github.io/p/2hbwijq/</link><pubDate>Tue, 12 May 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/2hbwijq/</guid><description>&lt;h2 id="kotlin-環境の構築">Kotlin 環境の構築&lt;/h2>
&lt;h3 id="kotlinc-のインストール">kotlinc のインストール&lt;/h3>
&lt;p>VS Code 自体は Kotlin コードのコンパイル機能を持っていないので、&lt;code>kotlinc&lt;/code> コマンドはあらかじめインストールしておく必要があります。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../p/5zibnsn/#kotlinc">Kotlin をインストールする&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>コマンドラインから次のように &lt;code>kotlinc&lt;/code> コマンドを実行できるようになっていれば OK です。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-console" data-lang="console">&lt;span class="line">&lt;span class="cl">&lt;span class="gp">$&lt;/span> kotlinc -version
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="go">info: kotlinc-jvm 1.3.71 (JRE 1.8.0_212-release-1586-b04)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h3 id="kotlin-language-プラグインのインストール">Kotlin Language プラグインのインストール&lt;/h3>
&lt;p>VS Code の Extensions タブから &lt;code>kotlin&lt;/code> で検索して、 &lt;strong>&lt;code>Kotlin Language&lt;/code>&lt;/strong> プラグインをインストールします。
このプラグインにより、Kotlin コードのシンタックスハイライトなどが効くようになります。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="1234" height="429" src="../p/2hbwijq/img-001.png" alt="/p/2hbwijq/img-001.png" />
&lt;/figure>

&lt;h3 id="code-runner-プラグインのインストール">Code Runner プラグインのインストール&lt;/h3>
&lt;p>VS Code の Extensions タブから &lt;code>code&lt;/code> で検索して、 &lt;strong>&lt;code>Code Runner&lt;/code>&lt;/strong> プラグインをインストールします。
このプラグインにより、ショートカットキー一発で Kotlin コードを実行できるようになります。&lt;/p>


&lt;figure class="xImage">
 &lt;img style="" width="1176" height="377" src="../p/2hbwijq/img-002.png" alt="/p/2hbwijq/img-002.png" />
&lt;/figure>

&lt;h2 id="kotlin-プログラムを実行してみる">Kotlin プログラムを実行してみる&lt;/h2>
&lt;p>VS Code への各種プラグインのインストールが済んだら、簡単な Kotlin プログラムを記述して実行してみます。&lt;/p>
&lt;h3 id="コードの作成">コードの作成&lt;/h3>
&lt;p>まず、VS Code を適当な空のディレクトリを起点にして起動します。&lt;/p></description></item><item><title>Kotlinメモ: 列挙型 (enum) の値をループ処理する (values)</title><link>https://maku77.github.io/p/q3y3jhr/</link><pubDate>Mon, 27 Apr 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/q3y3jhr/</guid><description>&lt;p>列挙型 (enum) クラスに自動的に定義される &lt;strong>&lt;code>values()&lt;/code>&lt;/strong> メソッドを使用すると、全ての値を含む配列 (&lt;strong>&lt;code>Array&amp;lt;列挙型&amp;gt;&lt;/code>&lt;/strong>) を取得することができます。
この配列を for-in ループで処理すれば、列挙型の値を 1 つずつ取り出せます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Fruits&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">APPLE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BANANA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GRAPE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Fruits&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次のように &lt;code>forEach&lt;/code> でループ処理することもできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">forEach&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: 列挙型 (enum) の値をインデックスで取得する</title><link>https://maku77.github.io/p/nsvub5w/</link><pubDate>Wed, 11 Mar 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/nsvub5w/</guid><description>&lt;p>次の例では、列挙型クラス &lt;code>Fruits&lt;/code> に static な関数 &lt;code>fromOrdinal()&lt;/code> を定義し、インデックス番号 (0, 1, 2) から &lt;code>Fruits&lt;/code> インスタンスを取得できるようにしています。
範囲外のインデックスを指定した場合は、&lt;code>NoSuchElementException&lt;/code> 例外が発生します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Fruit.kt&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Fruits&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">APPLE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BANANA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GRAPE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">fromOrdinal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ordinal&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Fruits&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">values&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ordinal&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">ordinal&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>


&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">使用例&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">val f1 = Fruits.fromOrdinal(0) //=&amp;gt; Fruits.APPLE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val f2 = Fruits.fromOrdinal(1) //=&amp;gt; Fruits.BANANA
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val f3 = Fruits.fromOrdinal(2) //=&amp;gt; Fruits.GRAPE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">val f4 = Fruits.fromOrdinal(3) //=&amp;gt; NoSuchElementException&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>Kotlinメモ: プリミティブ型配列 (IntArray) の内容を見やすく出力する (contentToString)</title><link>https://maku77.github.io/p/4j2zidk/</link><pubDate>Wed, 26 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4j2zidk/</guid><description>&lt;h2 id="配列クラスの-contenttostring-メソッド">配列クラスの contentToString メソッド&lt;/h2>
&lt;p>配列を扱うためのクラスである &lt;code>Array&amp;lt;T&amp;gt;&lt;/code> や &lt;code>IntArray&lt;/code> などのインスタンスを、&lt;code>println()&lt;/code> などで出力しようとすると、JVM 表現で分かりにくい文字列が出力されてしまいます（例: &lt;code>[I@2c7b84de&lt;/code>）。&lt;/p>
&lt;p>このような場合は、Kotlin が拡張関数として用意している &lt;strong>&lt;code>contentToString()&lt;/code>&lt;/strong> メソッドを使用すると、読みやすい形式で配列の内容を出力できます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実装例&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ジェネリック型配列の場合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">arr1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contentToString&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// プリミティブ型配列の場合も同様
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">arr2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">IntArray&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">intArrayOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">contentToString&lt;/span>&lt;span class="p">())&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>


&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">[Ljava.lang.Integer;@31befd9f
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[1, 2, 3]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[I@2c7b84de
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">[1, 2, 3]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>ちなみに、&lt;code>contentToString()&lt;/code> 拡張関数の実装は、&lt;code>java.util.Arrays.toString(this)&lt;/code> を呼び出しているだけです。&lt;/p>
&lt;h2 id="listsetmap-はデフォルトで綺麗に出力される">List/Set/Map はデフォルトで綺麗に出力される&lt;/h2>
&lt;p>&lt;code>List&lt;/code> や &lt;code>Set&lt;/code>、&lt;code>Map&lt;/code> などのジェネリッククラスは、このようなことをしなくても、デフォルトの &lt;code>toString()&lt;/code> が見やすい出力をしてくれます（継承元の &lt;code>AbstractCollection.toString()&lt;/code> などで実装されています）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Set&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; {one=1, two=2}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: 配列とリストの生成方法まとめ（連番からなる配列やリストを作成する）</title><link>https://maku77.github.io/p/fo685z4/</link><pubDate>Wed, 26 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fo685z4/</guid><description>&lt;h2 id="空の配列やリスト">空の配列やリスト&lt;/h2>
&lt;p>リストや配列のファクトリ関数である &lt;code>listOf&lt;/code> や &lt;code>arrayOf&lt;/code> の引数に何も指定しないと、空の配列やリストを作成することができます。&lt;/p>
&lt;h3 id="空の-listsetmap-を生成">空の List/Set/Map を生成&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; List&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; MutableList&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Set&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableSetOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; MutableSet&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Map&amp;lt;String, Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableMapOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; MutableMap&amp;lt;String, Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java の可変配列である &lt;code>ArrayList&lt;/code> を生成する &lt;code>arrayListOf()&lt;/code> という関数も存在しますが、通常は &lt;code>MutableList&lt;/code> の方を使えばいいので、上記の例には含めていません。&lt;/p>
&lt;h3 id="空の配列を生成">空の配列を生成&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// ジェネリック型配列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Array&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Double&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Array&amp;lt;Double&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// プリミティブ型配列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">intArrayOf&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; IntArray
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">doubleArrayOf&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; DoubleArray
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="emptyxxx-メソッドを使う">emptyXxx メソッドを使う&lt;/h3>
&lt;p>immutable（不変）かつ empty（要素数 0）な配列やリストを、&lt;code>arrayOf&lt;/code> や &lt;code>listOf&lt;/code> で個別に作成するのはあまり意味がありません（要素を追加できないのでどのインスタンスも同様のものになってしまう）。
このような場合は、次のような &lt;code>emptyXxx&lt;/code> 系メソッドを使うと効率がよいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">emptyArray&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Array&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">emptyList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; List&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">emptySet&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Set&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">emptyMap&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">//=&amp;gt; Map&amp;lt;String, Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのメソッドは、Kotlin が定義しているシングルトンインスタンス（&lt;code>EmptyList&lt;/code> など）を返すので、空のコレクションインスタンスがいくつも作られるのを防ぐことができます。&lt;/p></description></item><item><title>Kotlinメモ: プリミティブ型の配列には IntArray や LongArray などの専用クラスを使うことを検討する</title><link>https://maku77.github.io/p/az53za7/</link><pubDate>Tue, 25 Feb 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/az53za7/</guid><description>&lt;h2 id="いつ-int-はプリミティブ型として扱われるか">いつ Int はプリミティブ型として扱われるか？&lt;/h2>
&lt;p>整数値を扱うとき、Java では &lt;code>Integer&lt;/code> 型と &lt;code>int&lt;/code> 型を使い分けていました。
一方 Kotlin では、一律で &lt;code>Int&lt;/code> を使い、必要に応じて内部的にプリミティブ型（Java の &lt;code>int&lt;/code>）として扱ってくれるようになっています。&lt;/p>
&lt;p>この仕組みによって、プログラマは &lt;code>Int&lt;/code> だけを使っていれば、自動的に効率的なプリミティブ型を使ってくれるようになるので非常にありがたいのですが、問題は、Kotlin がいつ &lt;code>Int&lt;/code> をプリミティブ型として扱ってくれるのかということです。
下記の表は、Kotlin と Java の整数型の対応を示しています。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>Kotlin の型&lt;/th>
 &lt;th>Java の型&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>Int&lt;/code>&lt;/td>
 &lt;td>&lt;code>int&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>Int?&lt;/code>&lt;/td>
 &lt;td>&lt;code>Integer&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>List&amp;lt;Int&amp;gt;&lt;/code>&lt;/td>
 &lt;td>&lt;code>List&amp;lt;Integer&amp;gt;&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>&lt;/td>
 &lt;td>&lt;code>Integer[]&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>IntArray&lt;/code>&lt;/td>
 &lt;td>&lt;code>int[]&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>簡単にまとめると、&lt;code>Int?&lt;/code> のように nullable な型として扱う場合と、ジェネリクスクラスの型引数として使った場合は、プリミティブ型ではなく Java の &lt;code>Integer&lt;/code> として扱われます。&lt;/p>
&lt;h2 id="プリミティブ型配列のためのクラス-intarray">プリミティブ型配列のためのクラス IntArray&lt;/h2>
&lt;p>プリミティブ型の配列を作りたい場合は、Java では &lt;code>int[]&lt;/code> のように記述できていましたが、Kotlin の場合は &lt;strong>&lt;code>IntArray&lt;/code>&lt;/strong> のような専用の型を使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">intArr1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">IntArray&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">intArrayOf&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// これがプリミティブ型配列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intArr1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">simpleName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Java では int[] に相当
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">intArr2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span> &lt;span class="c1">// これは Integer な配列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intArr2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">simpleName&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Java では Integer[] に相当
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多くのケースではジェネリクスクラスの &lt;code>List&amp;lt;T&amp;gt;&lt;/code> を使っていれば問題ありませんが、大きなプリミティブ型要素を扱うケースや、パフォーマンスが重要になるケースでは &lt;code>IntArray&lt;/code> のようなプリミティブ型配列を使うのがよいでしょう。
プリミティブ型配列には、&lt;code>IntArray&lt;/code> 以外にも次のようなものが用意されています。&lt;/p></description></item><item><title>Kotlinメモ: セットの集合演算を行う</title><link>https://maku77.github.io/p/oc2j8u9/</link><pubDate>Fri, 17 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/oc2j8u9/</guid><description>&lt;p>&lt;code>Set&lt;/code> オブジェクト同士を &lt;code>+&lt;/code> や &lt;code>-&lt;/code> などで演算を行うと、和集合や差集合を求めることができます。&lt;/p>
&lt;h2 id="和集合-union">和集合 (union)&lt;/h2>
&lt;p>&lt;strong>&lt;code>+&lt;/code>&lt;/strong> 演算子、あるいは &lt;strong>&lt;code>union()&lt;/code>&lt;/strong> メソッドを用いることで、セット同士の和集合（いずれかのセットに含まれている要素からなる集合）を求めることができます。
&lt;code>union()&lt;/code> は infix 関数として定義されているので、演算子のように用いることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [1, 2, 3, 4, 5, 6]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span> &lt;span class="n">union&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 同上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">union&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 同上
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="共通集合積集合-intersection">共通集合／積集合 (intersection)&lt;/h2>
&lt;p>&lt;strong>&lt;code>intersect&lt;/code>&lt;/strong> メソッドを用いることで、セット同士の共通集合（両方のセットに含まれている要素からなる集合）を求めることができます。
&lt;code>intersect()&lt;/code> は infix 関数として定義されているので、演算子のように用いることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span> &lt;span class="n">intersect&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [3, 4]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">intersect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 同上
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="差集合-difference">差集合 (difference)&lt;/h2>
&lt;p>&lt;strong>&lt;code>-&lt;/code>&lt;/strong> 演算子、あるいは &lt;strong>&lt;code>minus()&lt;/code>&lt;/strong> メソッド、&lt;strong>&lt;code>subtract()&lt;/code>&lt;/strong> メソッドを用いることで、2 つのセットの差集合（左辺に指定したセットにしか存在しない要素からなる集合）を求めることができます。
&lt;code>subtract()&lt;/code> は infix 関数として定義されているので、演算子のように用いることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">6&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">minus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 同上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span> &lt;span class="n">subtract&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 同上
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">subtract&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">// 同上
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>差集合は、左辺と右辺の値を入れ替えると結果が変わってくることに注意してください。&lt;/p></description></item><item><title>Kotlinメモ: 比較演算子を定義してオブジェクト同士の比較やソートを行えるようにする (equals, compareTo)</title><link>https://maku77.github.io/p/ojwakt8/</link><pubDate>Fri, 17 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ojwakt8/</guid><description>&lt;p>オブジェクトを &lt;code>==&lt;/code>、&lt;code>!=&lt;/code>、&lt;code>&amp;gt;&lt;/code>、&lt;code>&amp;lt;&lt;/code>、&lt;code>&amp;gt;=&lt;/code>、&lt;code>&amp;lt;=&lt;/code> などの比較演算子で大小比較したいときや、ソート系の関数を適用できるようにするには、&lt;strong>&lt;code>equals&lt;/code>&lt;/strong> メソッドや、&lt;strong>&lt;code>compareTo&lt;/code>&lt;/strong> メソッドを定義します。&lt;/p>
&lt;h2 id="同値比較のための演算子に対応する-equals">同値比較のための演算子（==、!=）に対応する (equals)&lt;/h2>
&lt;p>Kotlin ではオブジェクトに対して &lt;code>==&lt;/code> や &lt;code>!=&lt;/code> を適用すると、内部的に &lt;code>equals()&lt;/code> メソッドの呼び出しに変換されます。
&lt;code>equals()&lt;/code> メソッドのシグネチャは &lt;code>Any&lt;/code> クラスで次のように定義されています。&lt;/p>
&lt;h4 id="any-クラスの-equals-定義">Any クラスの equals() 定義&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span> &lt;span class="k">open&lt;/span> &lt;span class="k">operator&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">equals&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Any&lt;/span>&lt;span class="p">?):&lt;/span> &lt;span class="n">Boolean&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このため、あらゆるクラスのインスタンスは &lt;code>==&lt;/code> や &lt;code>!=&lt;/code> による比較を行えるようになっていますが、デフォルトの振る舞いは単なる参照の比較であり、オブジェクトが持つ各フィールドの内容は考慮されません。
標準ライブラリで提供されているクラス（&lt;code>BigDecimal&lt;/code> など）が、&lt;code>==&lt;/code> 演算子でうまく比較できるのは、&lt;code>equals()&lt;/code> メソッドが適切に実装されているからです。&lt;/p>
&lt;p>独自クラスを作成するときは、&lt;code>equals()&lt;/code> メソッドをオーバーライドすることで、&lt;code>==&lt;/code> 演算子と &lt;code>!=&lt;/code> 演算子の振る舞いをカスタマイズすることができます。
下記は独自の複素数クラス (&lt;code>Complex&lt;/code>) で &lt;code>equals()&lt;/code> メソッドをオーバーライドし、各フィールドの値（実数部と虚数部）を比較するようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">re&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">im&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">equals&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Any&lt;/span>&lt;span class="p">?):&lt;/span> &lt;span class="n">Boolean&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span> &lt;span class="o">===&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span> &lt;span class="o">!is&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="k">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">re&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">re&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">im&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">im&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">c1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">c2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">c2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// =&amp;gt; true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">c2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// =&amp;gt; false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは、参考のために &lt;code>equals&lt;/code> メソッドの実装例を示しましたが、Kotlin ではクラス定義時に &lt;strong>&lt;code>data&lt;/code>&lt;/strong> プレフィックスを付けて&lt;strong>データクラスとして定義すると、自動的に &lt;code>equals&lt;/code> メソッドが実装される&lt;/strong>ため、下記のように &lt;code>equals&lt;/code> メソッドの定義を省略できます。&lt;/p></description></item><item><title>Kotlinメモ: infix 記法で関数呼び出し時の記述を簡略化する (to)</title><link>https://maku77.github.io/p/6qamkcy/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6qamkcy/</guid><description>&lt;h2 id="infix-呼び出し記法">infix 呼び出し記法&lt;/h2>
&lt;p>Kotlin には、「&lt;strong>infix 記法 (infix notation)&lt;/strong>」 と呼ばれる、特別なメソッドコールの構文が用意されています。
「&lt;strong>infix 呼び出し (infix call)&lt;/strong>」や「&lt;strong>中置記法&lt;/strong>」などと呼ばれることもあります。&lt;/p>
&lt;p>例えば、次のように &lt;code>Map&lt;/code> オブジェクトを生成するときに使用する &lt;code>to&lt;/code> 関数などが infix 呼び出しできるように定義されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;three&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">//=&amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>infix とは「接中辞」のことで、上記の例では、&lt;code>to&lt;/code> がちょうど間に挟まる形になるのでこう呼ばれています。
この &lt;code>to&lt;/code> 関数は、ジェネリックな関数として次のように定義されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">infix&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nc">B&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">A&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">that&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Pair&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">that&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、&lt;code>to&lt;/code> 関数は &lt;code>Pair&lt;/code> オブジェクトを生成するためのユーティリティ関数です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">pair&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1">//=&amp;gt; Pair(&amp;#34;one&amp;#34;, 1)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この &lt;code>to&lt;/code> 関数は本来は下記のように、ドットや括弧を付けたメソッド呼び出しの形で呼び出さなければならないはずですが、関数の先頭に &lt;strong>&lt;code>infix&lt;/code>&lt;/strong> を付けて定義してあると、ドットや括弧を省略した「infix 記法」で呼び出せるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">pair1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 通常のメソッド呼び出し記法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">pair2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1">// infix 呼び出し記法
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、&lt;code>Map&lt;/code> オブジェクトを生成する &lt;code>mapOf()&lt;/code> 関数は次のように定義されており、任意の数の &lt;code>Pair&lt;/code> オブジェクトをパラメータとして受け取るようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">K&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nc">V&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">vararg&lt;/span> &lt;span class="n">pairs&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Pair&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">&amp;gt;):&lt;/span> &lt;span class="n">Map&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">K&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初のコード例では、これに渡す &lt;code>Pair&lt;/code> 引数を生成するために、infix 関数である &lt;code>to&lt;/code> 関数を利用しているということです。&lt;/p>
&lt;h2 id="infix-関数を定義するときの制約">infix 関数を定義するときの制約&lt;/h2>
&lt;p>&lt;code>infix&lt;/code> キーワードは、クラスのメソッドや、拡張関数を定義するときに付加することができますが、infix キーワードを付けられる関数には下記のような制約があります。&lt;/p>
&lt;ul>
&lt;li>1 つのパラメータしか受け取れない&lt;/li>
&lt;li>デフォルト引数 (&lt;code>=&lt;/code>) は扱えない&lt;/li>
&lt;li>可変長引数 (&lt;code>vararg&lt;/code>) は扱えない&lt;/li>
&lt;/ul>
&lt;p>これは、1 レシーバー 1 引数の形になる記述方法を想定しているためです。&lt;/p></description></item><item><title>Kotlinメモ: インデックス演算子を定義して配列のようにアクセス可能なクラスを作る (index operator)</title><link>https://maku77.github.io/p/rtajezj/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/rtajezj/</guid><description>&lt;h2 id="インデックス演算子の実体は-set-と-get">インデックス演算子の実体は set と get&lt;/h2>
&lt;p>コレクション系のクラスでは、&lt;code>[]&lt;/code> を使ったインデックス指定（キー指定）による要素へのアクセスが可能になっていると便利です。
例えば、Kotlin の配列やリストは次のように要素を参照することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">value&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// get する場合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">value&lt;/span> &lt;span class="c1">// set する場合
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようなインデックスアクセスを可能にするには、そのクラスに &lt;strong>インデックス演算子 (index operator)&lt;/strong> を定義します。
コード上で &lt;code>[]&lt;/code> によるインデックスアクセスを行うと、内部的には次のように &lt;code>get()&lt;/code> メソッドや &lt;code>set()&lt;/code> メソッドが呼び出されます。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>コード上の記述&lt;/th>
 &lt;th>こう呼び出される&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>value = arr[i]&lt;/code>&lt;/td>
 &lt;td>&lt;code>value = arr.get(i)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>arr[i] = value&lt;/code>&lt;/td>
 &lt;td>&lt;code>arr.set(i, value)&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>つまり、実際にインデックス演算子として定義すべきメソッドの名前は &lt;code>get()&lt;/code> や &lt;code>set()&lt;/code> です。&lt;/p>
&lt;h2 id="get-用のインデックス演算子を定義する">get 用のインデックス演算子を定義する&lt;/h2>
&lt;p>次の &lt;code>Pos&lt;/code> クラスでは、インデックス指定によるプロパティ参照を可能にするための &lt;code>get()&lt;/code> 関数を定義しています。
演算子のオーバーロードなので、関数定義の先頭に &lt;strong>&lt;code>operator&lt;/code>&lt;/strong> キーワードを付けるのを忘れないでください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Pos&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Double&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">y&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Double&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">operator&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Double&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">0&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">1&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="n">IndexOutOfBoundsException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Invalid index &lt;/span>&lt;span class="si">$index&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">pos&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Pos&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1.5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2.5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">//=&amp;gt; 1.5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">//=&amp;gt; 2.5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">//=&amp;gt; Exception
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pos&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;x&amp;#34;&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">//=&amp;gt; Compile Error
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の例では、&lt;code>get()&lt;/code> のパラメータを &lt;code>Int&lt;/code> 型にしましたが、任意の型で定義することができます。
次の例では、&lt;code>Int&lt;/code> 型の代わりに &lt;code>String&lt;/code> 型を使用して定義しています。&lt;/p></description></item><item><title>Kotlinメモ: 分解宣言 (destructuring declarations) による Pair 要素や Triple 要素の分解</title><link>https://maku77.github.io/p/fr4jjf6/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fr4jjf6/</guid><description>&lt;h2 id="pair-クラスと-triple-クラス">Pair クラスと Triple クラス&lt;/h2>
&lt;p>Kotlin は 2 つの値、あるいは 3 つの値を保持するための簡易クラスとして、&lt;strong>&lt;code>Pair&lt;/code>&lt;/strong> クラスと &lt;strong>&lt;code>Triple&lt;/code>&lt;/strong> クラスを用意しています。&lt;/p>
&lt;p>&lt;code>Pair&lt;/code> オブジェクトの 1 番目と 2 番目の要素には、それぞれ &lt;code>first&lt;/code>、&lt;code>second&lt;/code> というプロパティでアクセスできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">pair&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="c1">// Pair(&amp;#34;one&amp;#34;, 1) と同じ
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;one&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pair&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この例のように、&lt;code>Pair&lt;/code> オブジェクトを生成するときは &lt;strong>&lt;code>to&lt;/code>&lt;/strong> という中置関数（infix function）を使うと簡潔に記述できます（参考: &lt;a href="../p/6qamkcy/">infix 記法 (infix notation)&lt;/a>）。&lt;/p>
&lt;p>&lt;code>Triple&lt;/code> オブジェクトの要素も同様に、&lt;code>first&lt;/code>、&lt;code>second&lt;/code>、&lt;code>third&lt;/code> というプロパティでアクセスできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">triple&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Triple&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;three&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">triple&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;one&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">triple&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;two&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">triple&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">third&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;three&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="分解宣言でオブジェクトの各プロパティを別々の変数に代入する">分解宣言でオブジェクトの各プロパティを別々の変数に代入する&lt;/h2>
&lt;p>Kotlin の &lt;strong>分解宣言 (destructuring declarations)&lt;/strong> と呼ばれている形で変数を定義すると、オブジェクトの各プロパティが保持している値を、別々の変数に一度に代入することができます。
分解宣言の方法は簡単で、代入文の左辺に複数の変数を括弧で囲んで記述するだけです。
次の例では、&lt;code>Pair&lt;/code> オブジェクトの &lt;code>first&lt;/code> プロパティと &lt;code>second&lt;/code> プロパティの値を、それぞれ &lt;code>x&lt;/code>、&lt;code>y&lt;/code> という変数に取り出しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">pair&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">200&lt;/span> &lt;span class="c1">// Pair(100, 200) と同じ
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="err">(&lt;/span>&lt;span class="py">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">pair&lt;/span> &lt;span class="c1">// 分解宣言で代入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 200
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Triple&lt;/code> オブジェクトに関しても同様です。&lt;/p></description></item><item><title>Kotlinメモ: 可変長引数をとる関数を定義する (vararg)</title><link>https://maku77.github.io/p/c2f65zt/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/c2f65zt/</guid><description>&lt;h2 id="kotlin-の可変長引数は-vararg-キーワード">Kotlin の可変長引数は vararg キーワード&lt;/h2>
&lt;p>Kotlin で可変長引数 (variable-length arguments) を表現するには、&lt;strong>&lt;code>vararg&lt;/code>&lt;/strong> キーワードを使用します。
例えば、&lt;code>List&lt;/code> を生成するファクトリ関数である &lt;code>listOf&lt;/code> は次のように定義されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">vararg&lt;/span> &lt;span class="n">elements&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">elements&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* ... */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>listOf&lt;/code> 関数のパラメータには &lt;code>vararg&lt;/code> が付けられているため、次のように任意の数の引数を渡すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span> &lt;span class="p">,&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、Java で可変長引数を定義するときは、3 つのドット (&lt;code>...&lt;/code>) を使っていました。
Java でも Kotlin でも、関数の実装側では配列と同様に扱うことができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Java の例&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">show&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="cm">/* ... */&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="vararg-を使った関数を実装する">vararg を使った関数を実装する&lt;/h2>
&lt;p>下記は、任意の数の &lt;code>String&lt;/code> 引数を受け取ることのできる関数の定義例です。
可変長引数として定義したパラメータは、&lt;strong>配列型のオブジェクトとして参照することができる&lt;/strong>ので、&lt;code>forEach&lt;/code> 関数などを使ってループ処理することができます（ここでは &lt;code>strings&lt;/code> パラメータは &lt;code>Array&amp;lt;String&amp;gt;&lt;/code> として扱えます）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">show&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">vararg&lt;/span> &lt;span class="n">strings&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 配列のループで処理できる
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(!&lt;/span>&lt;span class="n">strings&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">strings&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">// もちろんインデックスアクセスも可能
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>呼び出すときは、&lt;strong>0 個以上&lt;/strong>の任意の数の引数を渡すことができます。&lt;/p></description></item><item><title>Kotlinメモ: reified でジェネリクスの型情報を維持する</title><link>https://maku77.github.io/p/u32ykpo/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/u32ykpo/</guid><description>&lt;h2 id="具体化型パラメータ-reified-type-parameters">具体化型パラメータ (reified type parameters)&lt;/h2>
&lt;p>Java の頃から変わっていませんが、ジェネリクスの型引数で指定した型情報は、&lt;strong>コンパイル時にイレイジャ (erasure) によって削除されます&lt;/strong>。
つまり、実行時にその型情報を参照することはできません。
これは、JVM の仕組みによるもので、erased at runtime と呼ばれたりします。
Kotlin では、&lt;strong>reified type parameter&lt;/strong> という機能を使うことで、型引数で指定した型情報を残すことができます。&lt;/p>
&lt;p>例えば、次のように、いろいろな型の要素を含んだリストから、指定した型の要素だけを取り出すためのジェネリック関数 &lt;code>filterByType()&lt;/code> を作りたいとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">intList&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">filterByType&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intList&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">strList&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">filterByType&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">strList&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この &lt;code>filterByType()&lt;/code> 関数は、次のような感じで実装できそうな気がします。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">間違ったコード&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">filterByType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;*&amp;gt;):&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ERROR: cannot check for instance of erased type: T
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>しかし、ジェネリクスの型情報はイレイジャによってコンパイル時に失われるため、&lt;code>if (it is T)&lt;/code> という実行時の型判定を行うことができません。
&lt;code>T&lt;/code> という型情報は、コンパイル時の整合性の確認には活用されますが、実行時には役に立たないということです。&lt;/p>
&lt;p>そこで、&lt;strong>&lt;code>reified&lt;/code>&lt;/strong> の出番です。
Kotlin では、上記の関数を &lt;strong>&lt;code>inline&lt;/code> で定義し、さらに型パラメータに &lt;code>reified&lt;/code> キーワードを付ける&lt;/strong> ことにより、実行時まで型情報が残され、うまく動作するようになります。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">正しいコード&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">inline&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="k">reified&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">filterByType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;*&amp;gt;):&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>仕組みとしては、型情報を伴ったコードがその場にインライン展開されるため、型の判定も正しく行えるということのようです。&lt;/p></description></item><item><title>Kotlinメモ: ジェネリクスの共変 (covariant) と不変 (invariant) について理解する</title><link>https://maku77.github.io/p/irsz3gs/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/irsz3gs/</guid><description>&lt;h2 id="共変である-covariant-とはどういうことか">共変である (covariant) とはどういうことか？&lt;/h2>
&lt;p>Kotlin の &lt;code>Int&lt;/code> は &lt;code>Any&lt;/code> として使用することができます（&lt;code>Any&lt;/code> は Java で言うところの &lt;code>Object&lt;/code> です）。
それでは、&lt;/p>
&lt;ol>
&lt;li>&lt;code>List&amp;lt;Int&amp;gt;&lt;/code> は &lt;code>List&amp;lt;Any&amp;gt;&lt;/code> として扱うことができるでしょうか？&lt;/li>
&lt;li>&lt;code>MutableList&amp;lt;Int&amp;gt;&lt;/code> は &lt;code>MutableList&amp;lt;Any&amp;gt;&lt;/code> として扱うことができるでしょうか？&lt;/li>
&lt;/ol>
&lt;p>その答えは、使用している Generic クラスが、その型パラメータに関して &lt;strong>共変である (covariant)&lt;/strong> か &lt;strong>不変であるか (invariant)&lt;/strong> によって決まります。&lt;/p>
&lt;ol>
&lt;li>&lt;code>List&amp;lt;Int&amp;gt;&lt;/code> は &lt;code>List&amp;lt;Any&amp;gt;&lt;/code> として&lt;strong>使える&lt;/strong>（&lt;code>List&lt;/code> は共変である (= covariant)）&lt;/li>
&lt;li>&lt;code>MutableList&amp;lt;Int&amp;gt;&lt;/code> は &lt;code>MutableList&amp;lt;Any&amp;gt;&lt;/code> としては&lt;strong>使えない&lt;/strong>（&lt;code>MutableList&lt;/code> は共変ではない (= invariant)）&lt;/li>
&lt;/ol>
&lt;p>「Generic クラスが共変である」とは、型引数に指定した型の親子関係が、Generic クラスによって生成された型の親子関係と等しくなるということを意味します。
例えば、&lt;code>List&amp;lt;E&amp;gt;&lt;/code> はその型パラメータ &lt;code>E&lt;/code> に関して共変であり、&lt;code>List&amp;lt;Int&amp;gt;&lt;/code> を &lt;code>List&amp;lt;Any&amp;gt;&lt;/code> として扱うことが可能です（&lt;code>List&amp;lt;Int&amp;gt;&lt;/code> は &lt;code>List&amp;lt;Any&amp;gt;&lt;/code> のサブタイプとみなされます）。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">List&amp;lt;Int&amp;gt; は List&amp;lt;Any&amp;gt; として扱える&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">showElems&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Any&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// List&amp;lt;Int&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">showElems&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// OK!
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>一方で、&lt;code>MutableList&amp;lt;E&amp;gt;&lt;/code> は型パラメータ &lt;code>E&lt;/code> に関して共変ではなく、&lt;code>MutableList&amp;lt;Int&amp;gt;&lt;/code> は &lt;code>MutableList&amp;lt;Any&amp;gt;&lt;/code> として扱うことができません。
まったく互換性のない型として扱われます。&lt;/p></description></item><item><title>Kotlinメモ: ジェネリクスの基本</title><link>https://maku77.github.io/p/yepnwyf/</link><pubDate>Fri, 20 Dec 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/yepnwyf/</guid><description>&lt;h2 id="ジェネリクスとは">ジェネリクスとは？&lt;/h2>
&lt;p>ジェネリクス (generics) は、ある型に &lt;strong>型パラメータ (type parameter)&lt;/strong> を付加する機能です。
型パラメータを持つクラスや関数を、Generic クラス、Generic 関数のように呼びます。
下記は型パラメータを 1 つ持つ Generic クラスの定義例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Holder&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>型パラメータはこのように &lt;code>&amp;lt;&lt;/code> と &lt;code>&amp;gt;&lt;/code> で囲む形で定義され、クラス本体部分の任意の箇所で使用することができます。
型パラメータは、Generic クラスを使用するときに指定した具体的な型に置き換えられます。
このとき指定する型のことを &lt;strong>型引数 (type argument)&lt;/strong> と呼びます。
次の例では、型引数として &lt;code>Int&lt;/code> を指定しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">h&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Holder&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Holder(100) と省略可
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、&lt;code>Holder&lt;/code> という Generic クラスから、&lt;code>Holder&amp;lt;Int&amp;gt;&lt;/code> という型が生成されていることになります。
つまり、理論上は &lt;strong>1 つの Generic クラスは、無限の型を生み出すことができます&lt;/strong>。
Kotlin では、「クラス:型 = 1:1」ではなく「クラス:型 = 1:多」の関係にあるということです。
クラスと型は異なる概念です。&lt;/p>
&lt;p>Kotlin には型推論 (type inference) の仕組みが備わっているので、多くの場合、型引数の指定を省略することができます。
下記のようなコードは、&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">users&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="s2">&amp;#34;User1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;User2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次のように省略できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">users&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;User1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;User2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Generic クラスや Generic 関数を定義する際、型パラメータは基本的に大文字 1 文字で表現され、慣例として下記のような文字が使用されます。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>E&lt;/code>&lt;/strong> &amp;hellip; コレクションの要素 (element) の型を表す型パラメータ&lt;/li>
&lt;li>&lt;strong>&lt;code>K, V&lt;/code>&lt;/strong> &amp;hellip; マップ系コレクションのキー (key) と値 (value) の型を表す型パラメータ&lt;/li>
&lt;li>&lt;strong>&lt;code>T, S&lt;/code>&lt;/strong> &amp;hellip; その他の汎用的な型パラメータ&lt;/li>
&lt;/ul>
&lt;p>Java では、言語の進化の都合上、Generic クラスのもとになっている原型 (raw type) をそのまま使用することが許されていましたが（例: &lt;code>List&amp;lt;E&amp;gt;&lt;/code> ではなく &lt;code>List&lt;/code> を使うことができた）、Kotlin では、Generic クラスを使用する場合は、必ず型引数を指定して使用する必要があります。
特に、空のリストを生成するようなケースでは、初期値から要素の型を推論することができないので、次のいずれかの形で具体的な型引数を指定する必要があります。&lt;/p></description></item><item><title>Kotlinメモ: 演算子の前後で改行したいときは必ず後ろで改行する</title><link>https://maku77.github.io/p/bmwa9t8/</link><pubDate>Wed, 04 Dec 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/bmwa9t8/</guid><description>&lt;p>Kotlin のコードにおいて、演算子の前後で改行をするときは、改行位置に気を付けないといけません。
不可解な不具合に悩まされたので戒めのためにメモ。&lt;/p>
&lt;p>問題：次のコードを実行すると何と表示されるでしょう？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">getVal&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">x&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="p">-&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">getVal&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">y&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">-&lt;/span> &lt;span class="n">getVal&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>答えは、&lt;/p>
&lt;pre tabindex="0">&lt;code>99
100
&lt;/code>&lt;/pre>&lt;p>です。&lt;/p>
&lt;p>&lt;code>y&lt;/code> の計算式の方は、末尾が演算子で終わっていないので、次の行まで計算式が続いているとみなされません。
その次の行は、&lt;code>getVal()&lt;/code> が返した値に単項演算子の &lt;code>-&lt;/code> を適用するだけの意味のないコードになります。&lt;/p>
&lt;p>だから、Kotlin のコードにおいて、長い計算式を記述する場合は、&lt;strong>必ず演算子の後で改行する&lt;/strong>ように注意しなければいけません。
Java の場合は、セミコロンが出てくるまで式が続いているとみなされるので、このようなミスは発生しませんでした。&lt;/p>
&lt;p>ちなみに Ruby も同じで、演算子の後ろで改行しなければいけません。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Ruby&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-ruby" data-lang="ruby">&lt;span class="line">&lt;span class="cl">&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="o">-&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">puts&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="c1">#=&amp;gt; 99&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">puts&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="c1">#=&amp;gt; 100&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>Python の場合は、そもそも演算子の前後で改行しようとするとエラーになりますね。
バックスラッシュを入れれば連結できますが。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Python&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="o">-&lt;/span> \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span> \
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">#=&amp;gt; 99&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">#=&amp;gt; 99&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>Kotlinメモ: Kotlin で読みやすいコードを書く方法（可読性の高い Kotlin コードとは）</title><link>https://maku77.github.io/p/otwhjds/</link><pubDate>Thu, 31 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/otwhjds/</guid><description>&lt;p>Effective Kotlin という電子書籍に、Kotlin コードの可読性に関していろいろためになることが書いてあるのでメモメモ。&lt;/p>
&lt;h2 id="読みやすさのためのデザイン-design-for-readability">読みやすさのためのデザイン (Design for readability)&lt;/h2>
&lt;h3 id="昔ながらの実装-vs-kotlin-的な実装">昔ながらの実装 vs Kotlin 的な実装&lt;/h3>
&lt;p>下記の実装 A と B はどちらが読みやすいでしょうか？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 実装 A
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">person&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">person&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isAdult&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">showPerson&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">person&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">showError&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 実装 B
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">person&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">takeIf&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isAdult&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">?.&lt;/span>&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">view&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">showPerson&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">?:&lt;/span> &lt;span class="n">view&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">showError&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>どちらが読みやすいかは読む人のスキルによりますが、A の方が変更しやすく、デバッグしやすいです。
条件分岐を増やそうとすると、B の方は全体を考え直さないといけないので、頭が疲れます。
A と B は一見同じ振る舞いをするように見えますが、実際には異なる動作をします。
&lt;code>let&lt;/code> はラムダ式の評価結果を返すので、&lt;code>view::showPerson&lt;/code> が &lt;code>null&lt;/code> を返すと、&lt;code>showError()&lt;/code> が実行されてしまいます！
&lt;code>let&lt;/code> などはしっかり仕様を理解して使わないと危険だということです。&lt;/p>
&lt;p>一般ルールとしては、&lt;strong>認知負荷を下げる&lt;/strong> ようにコードを記述することを考えるとよいです。
つまり、&lt;strong>どう動作するかがそのままコードに表現されている&lt;/strong> ように書くということです。&lt;/p>
&lt;p>「短いコード＝読みやすいコード」ではないということですね。
一般的に、コンパクトなコードを書ける人は、技術的にはどんなコードでも書ける人だと思います。
あとはその人がどれだけ思いやりを持って書けるかにかかっています。&lt;/p>
&lt;h3 id="やりすぎはダメよ-do-not-get-extreme">やりすぎはダメよ (Do not get extreme)&lt;/h3>
&lt;p>これはよくある safe call let イディオムなんですが、、、&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">person&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">let&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはどうですか？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">students&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">filter&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pointsInSemester&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="m">15&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">result&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="m">50&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">sortedWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">compareBy&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">surname&lt;/span> &lt;span class="p">},&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="p">}))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">joinToString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">separator&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${it.name}&lt;/span>&lt;span class="s2"> &lt;/span>&lt;span class="si">${it.surname}&lt;/span>&lt;span class="s2">, &lt;/span>&lt;span class="si">${it.result}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">print&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var&lt;/span> &lt;span class="py">obj&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">FileInputStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;/file.gz&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">BufferedInputStream&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">ZipInputStream&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">let&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">ObjectInputStream&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">readObject&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">SomeObject&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>後者のようなコードの問題点は、デバッグが難しくなることと、Kotlin に慣れていない人にとって理解しにくいことです。
こういった Kotlin 的な&lt;strong>イディオムの組み合わせは、単独で順番に呼び出した時よりも何倍も複雑になってしまう&lt;/strong>ということを意識しておかなければいけません。&lt;/p></description></item><item><title>Kotlinメモ: マップの値を初めて取得しようとしたときに初期化する（Map の遅延初期化）(getOrPut)</title><link>https://maku77.github.io/p/u4j3e9t/</link><pubDate>Thu, 24 Oct 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/u4j3e9t/</guid><description>&lt;p>&lt;code>MutableMap&lt;/code> の &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-put.html">&lt;code>getOrPut&lt;/code> メソッド&lt;/a> を使用すると、指定されたキーに対応する値が見つからないときに、その値をラムダ式によって初期化した上で返すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableMapOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; null （値が存在しない）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getOrPut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="p">}))&lt;/span> &lt;span class="c1">//=&amp;gt; 0（get と同時に初期値がセットされる）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;foo&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; 0 （値がセットされている）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>getOrPut()&lt;/code> を利用すると、マップ値の遅延初期化を行えます。
キー＆値の形式の固定値を取得したいのだけど、各値の取得には多少コストがかかるという場合のキャッシュ用途で利用できます（値が変わらない前提）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">UserDb&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ユーザーの年齢のキャッシュ
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">private&lt;/span> &lt;span class="k">var&lt;/span> &lt;span class="py">_userAge&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableMapOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ユーザーの年齢を取得する（キャッシュを利用）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">getAge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_userAge&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getOrPut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">getAgeWithoutCache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">getAgeWithoutCache&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 初期値の計算に時間がかかるという想定
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="m">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">userDb&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">UserDb&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">age&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">userDb&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getAge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;maku&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: lateinit による変数の初期化</title><link>https://maku77.github.io/p/ymzvh9q/</link><pubDate>Wed, 25 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ymzvh9q/</guid><description>&lt;h2 id="lateinit-変数とは">lateinit 変数とは&lt;/h2>
&lt;p>クラスのプロパティは、できるだけ &lt;code>val&lt;/code>（再代入不可）変数として定義すると保守性の高いコードを作成することができます。
&lt;code>val&lt;/code> 変数は生成時に参照先のオブジェクトを確定しておく必要があるため、変数の宣言時に代入するか、&lt;code>init&lt;/code> ブロックでの代入が必要です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Potter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">magics&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Android などのフレームワーク上で実装を行っている場合、どうしてもフレームワークによる初期化関数の呼び出しの段階まで変数の初期化ができないことがあります。
このようなケースで &lt;code>val&lt;/code> 変数の代わりに使用できるのが &lt;strong>&lt;code>lateinit&lt;/code>&lt;/strong> 変数です。&lt;/p>
&lt;p>下記は Android の &lt;code>Activity&lt;/code> 実装の抜粋です。
ここでは、&lt;code>surfaceView&lt;/code> 変数を &lt;code>lateinit&lt;/code> で宣言することにより、初期化タイミングを &lt;code>onCreate()&lt;/code> 呼び出しまで遅延させています。
&lt;code>lateinit&lt;/code> 変数は &lt;code>var&lt;/code> で宣言しないといけないことに注意してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MainActivity&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Activity&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">lateinit&lt;/span> &lt;span class="k">var&lt;/span> &lt;span class="py">surfaceView&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">SurfaceView&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">onCreate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">savedInstanceState&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Bundle&lt;/span>&lt;span class="p">?)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">super&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">onCreate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">savedInstanceState&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">surfaceView&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">SurfaceView&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>変数を &lt;code>lateinit&lt;/code> 宣言することにより、&lt;strong>non-null な初期化済みの変数として参照することができる&lt;/strong>ようになります。
ただし、参照する前に必ず初期化（代入）されていることが条件となります。
初期化前に &lt;code>lateinit&lt;/code> 変数を参照すると、次のような &lt;strong>&lt;code>UninitializedPropertyAccessException&lt;/code>&lt;/strong> が発生します。&lt;/p>
&lt;pre tabindex="0">&lt;code>Exception in thread &amp;#34;main&amp;#34; kotlin.UninitializedPropertyAccessException:
 lateinit property book has not been initialized
&lt;/code>&lt;/pre>&lt;h2 id="lateinit-変数の使用例">lateinit 変数の使用例&lt;/h2>
&lt;h3 id="di-による依存注入">DI による依存注入&lt;/h3>
&lt;p>&lt;code>lateinit&lt;/code> による変数初期化は、Dagger などの DI 系ツールで依存関係を注入するときにもよく使用されます。&lt;/p></description></item><item><title>Kotlinメモ: lateinit 変数が初期化されているかどうかを調べる (isInitialized)</title><link>https://maku77.github.io/p/qpc53iy/</link><pubDate>Wed, 25 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/qpc53iy/</guid><description>&lt;h2 id="isinitialized-の概要">isInitialized の概要&lt;/h2>
&lt;p>Kotlin 1.2 以降では、&lt;a href="../p/ymzvh9q/">&lt;code>lateinit&lt;/code> 変数&lt;/a>が初期化済みかどうかを &lt;strong>&lt;code>isInitialized&lt;/code>&lt;/strong> を使って調べることができます。
あるクラスのプロパティが初期化済みかどうかを調べるには次のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">プロパティ&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isInitialized&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// プロパティは初期化済み (代入済み）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接プロパティにアクセスすると &lt;code>UninitializedPropertyAccessException&lt;/code> が発生する可能性があるため、上記のようにプロパティ参照の仕組みを利用して参照するところがポイントです。&lt;/p>
&lt;h2 id="isinitialized-の使用例">isInitialized の使用例&lt;/h2>
&lt;p>下記の &lt;code>initSubject()&lt;/code> メソッドでは、&lt;code>lateinit&lt;/code> 変数である &lt;code>subject&lt;/code> が初期化されているかどうかを &lt;code>isInitialized&lt;/code> で調べ、初期化されていない場合にのみ初期化を行うようにしています。
&lt;code>foo()&lt;/code> や &lt;code>bar()&lt;/code> メソッドの中で最初に &lt;code>initSubject()&lt;/code> を呼び出すことで、&lt;code>subject&lt;/code> が確実に初期化されてから参照されるようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">lateinit&lt;/span> &lt;span class="k">var&lt;/span> &lt;span class="py">subject&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Subject&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">initSubject&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">subject&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isInitialized&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ここで context を使って subject を初期化する
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">initSubject&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ... subject を使う処理 ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Context&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">initSubject&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">context&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ... subject を使う処理 ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>subject&lt;/code> の初期化には &lt;code>foo()&lt;/code> や &lt;code>bar()&lt;/code> の呼び出し時に渡される &lt;code>Context&lt;/code> オブジェクトを必要としているため、このタイミングで初期化するしか方法がないと想定しています。&lt;/p></description></item><item><title>Kotlinメモ: safe call (?.) や elvis operator (?:)、let で null をうまく扱う</title><link>https://maku77.github.io/p/qrrnw9b/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/qrrnw9b/</guid><description>&lt;h2 id="null-を扱うさまざまな演算子関数">null を扱うさまざまな演算子・関数&lt;/h2>
&lt;p>Kotlin には、&lt;code>null&lt;/code> をうまく扱うための便利な演算子や関数が用意されています。
代表的なものに下記があります。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>オブジェクト?.メソッド&lt;/code> (safe call)&lt;/strong>
&lt;ul>
&lt;li>オブジェクトが &lt;code>null&lt;/code> でないならメソッドを呼び出す。&lt;code>null&lt;/code> なら &lt;code>null&lt;/code> を返す。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&lt;code>式1 ?: 式2&lt;/code> (Elvis operator)&lt;/strong>
&lt;ul>
&lt;li>式1が &lt;code>null&lt;/code> でないならその値、&lt;code>null&lt;/code> なら式2を評価する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&lt;code>オブジェクト!!&lt;/code> (not-null assertion / unsafe dereference)&lt;/strong>
&lt;ul>
&lt;li>nullable なオブジェクトを not-null なオブジェクトとして参照する。
万が一 &lt;code>null&lt;/code> だった場合は &lt;code>NullPoiterException&lt;/code> が発生する。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="使用例">使用例&lt;/h2>
&lt;h3 id="オブジェクトが-null-じゃない場合のみメソッドを呼び出すプロパティを参照する">オブジェクトが null じゃない場合のみメソッドを呼び出す／プロパティを参照する&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">logger&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">log&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>logger&lt;/code> 変数が &lt;code>null&lt;/code> でない場合のみ &lt;code>log()&lt;/code> メソッドを実行します。
&lt;code>null&lt;/code> の場合は何も行いません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">label&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">title&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>book&lt;/code> 変数が &lt;code>null&lt;/code> でない場合に &lt;code>title&lt;/code> プロパティの値を取得します。
&lt;code>book&lt;/code> 変数が &lt;code>null&lt;/code> の場合は &lt;code>null&lt;/code> が返されます。&lt;/p>
&lt;h3 id="オブジェクトが-null-だった場合にデフォルト値を設定処理を打ち切る">オブジェクトが null だった場合にデフォルト値を設定／処理を打ち切る&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">book&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">title&lt;/span> &lt;span class="o">?:&lt;/span> &lt;span class="s2">&amp;#34;Unknown title&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>book&lt;/code> 変数が &lt;code>null&lt;/code> でない場合は &lt;code>book.title&lt;/code> の値を、&lt;code>null&lt;/code> である場合は &amp;ldquo;Unknown title&amp;rdquo; を &lt;code>title&lt;/code> に代入します。&lt;/p></description></item><item><title>Kotlinメモ: immutable なコレクションを mutable に変換する (toMutableList, toMutableSet, toMutableMap)</title><link>https://maku77.github.io/p/r5f583b/</link><pubDate>Tue, 17 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r5f583b/</guid><description>&lt;p>Kotlin の &lt;code>List&lt;/code> インタフェースや &lt;code>Map&lt;/code> インタフェースは immutable（不変）なインタフェースとして定義されており、&lt;code>add&lt;/code> や &lt;code>set&lt;/code> といった要素を変更するメソッドが定義されていません。&lt;/p>
&lt;h2 id="tomutablelist">toMutableList&lt;/h2>
&lt;p>&lt;code>listOf()&lt;/code> などで生成した immutable（不変）なリストから mutable なリストを生成するには、&lt;strong>&lt;code>toMutableList()&lt;/code>&lt;/strong> メソッドを使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">list1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toMutableList&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// list2 += 4 でも OK
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3, 4]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>toMutableList()&lt;/code> はリストのコピーを作成するため、元の &lt;code>list1&lt;/code> 変数が参照しているリストの内容は変更されていないことに注意してください。&lt;/p>
&lt;h2 id="tomutableset--tomutablemap">toMutableSet / toMutableMap&lt;/h2>
&lt;p>&lt;code>toMutableList()&lt;/code> と同様に、セット用には &lt;strong>&lt;code>toMutableSet()&lt;/code>&lt;/strong>、マップ用には &lt;strong>&lt;code>toMutableMap()&lt;/code>&lt;/strong> が用意されています。
下記は、&lt;code>setOf()&lt;/code> で作成した immutable（不変）なセットを mutable なセットに変換する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">set1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toMutableSet&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">set2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// set2 += 4 でも OK
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">set1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">set2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3, 4]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用するメソッドが &lt;code>toMutableList()&lt;/code> から &lt;code>toMutableSet()&lt;/code> に変わっただけです。&lt;/p></description></item><item><title>Kotlinメモ: クラス内の MutableList を immutable な List にして公開する</title><link>https://maku77.github.io/p/9fwrpnu/</link><pubDate>Tue, 17 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9fwrpnu/</guid><description>&lt;ul>
&lt;li>参考: &lt;a href="../p/r5f583b/">Kotlinメモ: immutable なコレクションを mutable に変換する (&lt;code>toMutableList&lt;/code>, &lt;code>toMutableSet&lt;/code>, &lt;code>toMutableMap&lt;/code>)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>上記の記事では、immutable（不変）な &lt;code>List&lt;/code> から &lt;code>MutableList&lt;/code> を生成する例を示していますが、逆に、mutable（可変）なオブジェクトを immutable にして見せたいことがあります。
定型的なのは、クラス内のフィールドとして &lt;code>MutableList&lt;/code> を持っているときに、不変なリストとして外部に公開したいケースです。
このような場合は、単純に戻り値の型を &lt;code>List&lt;/code> にアップキャストしたメソッド（あるいはプロパティ）を用意するだけで対応できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">TitleList&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">mutableTitles&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">titles&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableTitles&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// メンバーメソッドからは内部のリストを変更できる
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">changeInternally1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mutableTitles&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">changeInternally2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mutableTitles&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">TitleList&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">changeInternally1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">changeInternally2&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">titles&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [Title1, Title2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 下記はエラー
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">titles&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title3&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Unresolved reference: add
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただし、このような実装はスレッドセーフではないことに注意してください。
&lt;code>titles&lt;/code> プロパティが参照するリストオブジェクトの実体は、&lt;code>mutableTitles&lt;/code> が参照するものと同じだからです。
下記のように実行すると、&lt;code>titles&lt;/code> 変数の内容が、外部要因によってどんどん変化していくことが分かります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">TitleList&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">titles&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">titles&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">titles&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; []
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">changeInternally1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">titles&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [Title1]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">changeInternally2&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">titles&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [Title1, Title2]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>titles&lt;/code> プロパティによって取得したリストの内容が別スレッドから変更されないことを保証するには、下記のようにコピーして作成したリストを返すように実装します。&lt;/p></description></item><item><title>Kotlinメモ: ある処理にかかった時間を計測する (measureTimeMillis/Micros)</title><link>https://maku77.github.io/p/zmr4tpu/</link><pubDate>Mon, 02 Sep 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/zmr4tpu/</guid><description>&lt;p>下記の Kotlin の組み込み関数を使用すると、ブロックで渡した一連の処理にかかった時間を計測することができます。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.system/measure-time-millis.html">&lt;code>measureTimeMillis()&lt;/code>&lt;/a> - ブロックで渡した処理にかかる時間を「ミリ秒」単位で計測&lt;/li>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.system/measure-time-micros.html">&lt;code>measureTimeMicros()&lt;/code>&lt;/a> - ブロックで渡した処理にかかる時間を「マイクロ秒」単位で計測&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">import&lt;/span> &lt;span class="nn">kotlin.system.measureTimeMillis&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">time&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">measureTimeMillis&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">one&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">doSomething1&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">two&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">doSomething2&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;The answer is &lt;/span>&lt;span class="si">${one + two}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Completed in &lt;/span>&lt;span class="si">$time&lt;/span>&lt;span class="s2"> ms&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>計測範囲が分かりやすくてよいですね！&lt;/p></description></item><item><title>Kotlinメモ: クラス名を文字列で取得する (class.java.simpleName)</title><link>https://maku77.github.io/p/omkgowq/</link><pubDate>Thu, 08 Aug 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/omkgowq/</guid><description>&lt;p>Kotlin クラス名を文字列として取得したい場合、例えば、&lt;code>MyClass&lt;/code> クラスの名前を &lt;code>MyClass&lt;/code> という文字列として取得したい場合は次のように記述します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">simpleName&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java の場合は (&lt;code>MyClass.simpleName&lt;/code>) と記述できたので、それと比べると Kotlin は若干冗長な記述 (&lt;strong>&lt;code>MyClass::class.java.simpleName&lt;/code>&lt;/strong>) になります。
ただ、クラス名をそのまま文字列リテラルでハードコードすると、クラス名のリファクタリング時に修正し忘れたりするので、このようにクラス名を取得した方がよいケースはよくあります。&lt;/p>
&lt;p>例えば、Android アプリのログ (Logcat) には、タグ情報としてクラス名を入れたりしますが（個人的にはアプリ名を入れるべきだと思いますが）、このタグは下記のように初期化することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Sample&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">TAG&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Sample&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">simpleName&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">sayHello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">TAG&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: 配列やリストの先頭・末尾の n 要素を取り出す・削除する (take, drop)</title><link>https://maku77.github.io/p/mmiwzqj/</link><pubDate>Mon, 05 Aug 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/mmiwzqj/</guid><description>&lt;h2 id="先頭末尾からいくつかの要素を取り出す-take">先頭・末尾からいくつかの要素を取り出す (take)&lt;/h2>
&lt;p>&lt;code>take&lt;/code> 系のメソッドを使用すると、配列やリストの先頭・末尾から指定した数の要素を取り出すことができます。
どのメソッドも新しいリストを返すため、元のリストは変化しません。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take.html">&lt;code>take(n)&lt;/code>&lt;/a>: 先頭から n 個の要素を取り出す&lt;/li>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-last.html">&lt;code>takeLast(n)&lt;/code>&lt;/a>: 末尾から n 個の要素を取り出す&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// intArrayOf でも OK
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">take&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">takeLast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; [3, 4, 5]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>takeWhile&lt;/code> 系のメソッドは、条件式を指定することができ、各要素の値が条件を満たす限り取り出します。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html">&lt;code>takeWhile(predicate: (T) -&amp;gt; Boolean)&lt;/code>&lt;/a>: 先頭から条件に一致する限り要素を取り出す&lt;/li>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-last-while.html">&lt;code>takeLastWhile(predicate: (T) -&amp;gt; Boolean)&lt;/code>&lt;/a>: 末尾から条件に一致する限り要素を取り出す&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">chars&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="sc">&amp;#39;z&amp;#39;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">toList&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">takeWhile&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="sc">&amp;#39;f&amp;#39;&lt;/span> &lt;span class="p">})&lt;/span> &lt;span class="c1">//=&amp;gt; [a, b, c, d, e]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chars&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">takeLastWhile&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="sc">&amp;#39;w&amp;#39;&lt;/span> &lt;span class="p">})&lt;/span> &lt;span class="c1">//=&amp;gt; [x, y, z]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="先頭末尾のいくつかの要素を削除する-drop">先頭・末尾のいくつかの要素を削除する (drop)&lt;/h2>
&lt;p>&lt;code>drop&lt;/code> 系のメソッドを使用すると、配列やリストの先頭・末尾から指定した数の要素を削除します。
どのメソッドも新しいリストを返すため、元のリストは変化しません。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop.html">&lt;code>drop(n)&lt;/code>&lt;/a>: 先頭から n 個の要素を削除する&lt;/li>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop-last.html">&lt;code>dropLast(n)&lt;/code>&lt;/a>: 末尾から n 個の要素を削除する&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// intArrayOf でも OK
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">drop&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; [4, 5]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dropLast&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>dropWhile&lt;/code> 系のメソッドは、条件式を指定することができ、各要素の値が条件を満たす限り削除します。&lt;/p></description></item><item><title>Kotlinメモ: 算術演算子を定義してオブジェクトに + や += を適用できるようにする</title><link>https://maku77.github.io/p/wf7yjbm/</link><pubDate>Tue, 16 Jul 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wf7yjbm/</guid><description>&lt;p>Kotlin では、&lt;code>+&lt;/code> や &lt;code>+=&lt;/code> などの演算子をオーバーロードして、独自の振る舞いを定義することができます（Java では演算子のオーバーロードはできません）。&lt;/p>
&lt;p>ここでは、様々な演算子のオーバーロードの例を示すために、下記のような複素数を保持する簡単なデータクラスを使用することにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">re&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">im&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="二項演算子のオーバーロード-binary-arithmetic-operators">二項演算子のオーバーロード (Binary arithmetic operators)&lt;/h2>
&lt;p>Kotlin で &lt;code>a + b&lt;/code> のような演算を可能にする二項演算子を定義するには、&lt;code>plus&lt;/code> や &lt;code>minus&lt;/code> などの &lt;strong>演算子関数&lt;/strong> を実装します。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>使用する演算子&lt;/th>
 &lt;th>定義する演算子関数&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>&lt;code>+&lt;/code>&lt;/td>
 &lt;td>&lt;code>plus&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>-&lt;/code>&lt;/td>
 &lt;td>&lt;code>minus&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>*&lt;/code>&lt;/td>
 &lt;td>&lt;code>times&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>/&lt;/code>&lt;/td>
 &lt;td>&lt;code>div&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;code>%&lt;/code>&lt;/td>
 &lt;td>&lt;code>mod&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>下記は、&lt;code>+&lt;/code> 演算子をオーバーロードする例です。
演算子関数を定義するときは、モディファイアとして &lt;strong>&lt;code>operator&lt;/code>&lt;/strong> を付けることに注意してください（同名の通常関数の定義と区別するためです）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">re&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">im&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">operator&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">plus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Complex&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">re&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">re&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">im&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">im&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これにより、独自オブジェクト同士の &lt;code>+&lt;/code> 演算子による演算が可能になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">c1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">c2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c1&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">c2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Complex(re=4, im=6)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記では、メンバ関数として演算子関数を定義しましたが、拡張関数として定義することもできます。
この方法であれば、既存の外部ライブラリが提供するクラスの演算子をオーバーロードすることが可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">operator&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">Complex&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">plus&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Complex&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">re&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">re&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">im&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">im&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまでは、&lt;code>Complex&lt;/code> インスタンス同士の演算を定義していましたが、別の型との演算を定義することもできます。
次の例では、各プロパティを、指定した &lt;code>Int&lt;/code> 値倍に変化させる &lt;code>*&lt;/code> 演算子 (&lt;code>times&lt;/code>) を定義しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">re&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">im&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">operator&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">times&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">scale&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Complex&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">re&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="n">scale&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">im&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="n">scale&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">c1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Complex&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">c2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">c1&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="m">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// =&amp;gt; Complex(re=10, im=20)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように違う型同士の演算を定義した場合、&lt;strong>演算子の左右の値は交換可能ではない&lt;/strong> ことに注意してください。
例えば、&lt;code>10 * Complex(1, 2)&lt;/code> という演算を行いたいのであれば、&lt;code>Int.times(c: Complex)&lt;/code> という演算子関数を定義しておく必要があります。&lt;/p></description></item><item><title>Kotlinメモ: コレクションから条件に一致する要素のみを取り出す (filter, filterNot, filterKeys, filterValues)</title><link>https://maku77.github.io/p/y2z9krm/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/y2z9krm/</guid><description>&lt;h2 id="リストや配列のフィルタ-filter-filternot">リストや配列のフィルタ (filter, filterNot)&lt;/h2>
&lt;p>コレクションの要素から、指定した条件を満たす要素のみを抽出するには、&lt;strong>&lt;code>filter&lt;/code>&lt;/strong> 関数を使用します。
次の例では、数値リストから偶数のみを抽出しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">nums&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">evens&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filter&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">evens&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [2, 4]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次の例では、文字列リストから &amp;ldquo;M&amp;rdquo; で始まる文字列のみを抽出しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">names&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Hemu&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Momo&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">ms&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">names&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filter&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">startsWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;M&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ms&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [Maku, Momo]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>filter&lt;/code> の代わりに &lt;strong>&lt;code>filterNot&lt;/code>&lt;/strong> を使うと、指定した条件を満たさない要素のみを抽出することができます。&lt;/p>
&lt;pre tabindex="0">&lt;code>// M で始まらない文字列のみを抽出する
val ms = names.filterNot { it.startsWith(&amp;#34;M&amp;#34;) }
&lt;/code>&lt;/pre>&lt;p>コレクション内から要素が null でないものを取り出したいときは、&lt;code>filterNotNull&lt;/code> や &lt;code>mapNotNull&lt;/code> を使用すると簡潔に記述できます。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../p/wz5cnqq/">配列やリストから null 以外の要素のみを抽出する (filterNotNull, mapNotNull)&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="マップのフィルタ-filterkeys-filtervalues">マップのフィルタ (filterKeys, filterValues)&lt;/h2>
&lt;p>マップの中から条件を満たす要素だけを抽出したい場合は、キーと値のどちらでフィルタするかによって &lt;strong>&lt;code>filterKeys&lt;/code>&lt;/strong> と &lt;strong>&lt;code>filterValues&lt;/code>&lt;/strong> を呼び分けます。&lt;/p>
&lt;h3 id="キーでフィルタする場合-filterkeys">キーでフィルタする場合 (filterKeys)&lt;/h3>
&lt;p>次の例では、マップ要素のキーに &lt;code>Kotlin&lt;/code> という文字列を含んでいる要素を抽出しています。
&lt;code>filterKeys&lt;/code> の戻り値はマップ型です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Kotlin ABC&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2000&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Effective Java&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2500&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s2">&amp;#34;Effective Kotlin&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1500&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filterKeys&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;Kotlin&amp;#34;&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">key&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; {Kotlin ABC=2000, Effective Kotlin=1500}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="値でフィルタする場合-filtervalues">値でフィルタする場合 (filterValues)&lt;/h3>
&lt;p>次の例では、マップ要素の値が 2000 以上であるものを抽出しています。
&lt;code>filterValues&lt;/code> の戻り値はマップ型です。&lt;/p></description></item><item><title>Kotlinメモ: コレクションの基本的な使い方 (List, Set, Map)</title><link>https://maku77.github.io/p/by55kee/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/by55kee/</guid><description>&lt;h2 id="リスト-list">リスト (List)&lt;/h2>
&lt;p>Kotlin の &lt;code>List&lt;/code> は、Java の &lt;code>List&lt;/code> をベースにしたコレクションです。
一連の要素を格納された順に保持しており、前から順番に要素を取り出すことができます。
不変 (immutable) なリストは、Kotlin 組み込みの &lt;strong>&lt;code>listOf&lt;/code>&lt;/strong> 関数で作成することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>リスト生成後に要素を追加・削除したい場合は、&lt;strong>&lt;code>mutableListOf&lt;/code>&lt;/strong> 関数でリストを作成しておく必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">MutableList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removeAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removeAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [3, 4, 5]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="セット-set">セット (Set)&lt;/h2>
&lt;p>Kotlin の &lt;code>Set&lt;/code> は、Java の &lt;code>Set&lt;/code> をベースにしたコレクションです。
リストと似ていますが、セットは重複しない要素のみを保持し、順序の概念を持ちません。
不変 (immutable) なセットは、Kotlin 組み込みの &lt;strong>&lt;code>setOf&lt;/code>&lt;/strong> 関数で作成することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Set&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重複する要素は保持しないので、1 と 2 がひとつしか格納されていないところに着目してください。&lt;/p>
&lt;p>セット生成後に要素を追加・削除したい場合は、&lt;strong>&lt;code>mutableSetOf&lt;/code>&lt;/strong> 関数でセットを作成しておく必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">MutableSet&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableSetOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">set&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">set&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3, 4]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="マップ-map">マップ (Map)&lt;/h2>
&lt;p>Kotlin の &lt;code>Map&lt;/code> は、Java の &lt;code>Map&lt;/code> をベースにしたコレクションです。
キーと値のペアを保持し、順序の概念はありません。
不変 (immutable) なマップは、Kotlin 組み込みの &lt;strong>&lt;code>mapOf&lt;/code>&lt;/strong> 関数で作成することができます。&lt;/p></description></item><item><title>Kotlinメモ: コレクションの要素をもとに別のリストを作成する (map)</title><link>https://maku77.github.io/p/v5wjmyk/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/v5wjmyk/</guid><description>&lt;h2 id="配列やリストに対する-map">配列やリストに対する map&lt;/h2>
&lt;p>&lt;code>map&lt;/code> 関数を使用すると、配列やリストなどのコレクション要素の値を使って、別のコレクションを生成することができます。
次の例では、数値リストから、各要素を 2 倍にした新しい数値リストを作成しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">nums&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">nums2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nums2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [2, 4, 6]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>map&lt;/code> 関数の典型的な使用例として、あるクラスのインスタンスのリストから、特定のプロパティを抜き出したリストを作成する、というものがあります。
次の例では、&lt;code>Book&lt;/code> インスタンスのリストから、&lt;code>title&lt;/code> プロパティだけを抜き出したリストを作成しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">books&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">200&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title3&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">300&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">titles&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">books&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">titles&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;Title1&amp;#34;, &amp;#34;Title2&amp;#34;, &amp;#34;Title3&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の &lt;code>books.map { it.title }&lt;/code> という部分は、&lt;a href="../p/r2gqqnt/">メンバ参照の記法&lt;/a> を使用して &lt;strong>&lt;code>books.map(Book::title)&lt;/code>&lt;/strong> と記述することもできます。&lt;/p>
&lt;h2 id="マップに対する-map">マップに対する map&lt;/h2>
&lt;p>マップ系の要素に対して &lt;code>map&lt;/code> を実行した場合、ラムダ式に渡されるパラメータは &lt;strong>&lt;code>Map.Entry&lt;/code>&lt;/strong> 型のオブジェクトになり、&lt;code>key&lt;/code> プロパティと &lt;code>value&lt;/code> プロパティを使ってマップ要素のキー＆バリューを取り出せます。
戻り値はリストです。&lt;/p>
&lt;p>次の例では、マップ要素のキーを、値の回数だけ繰り返して作成した文字列のリストを生成しています。
&lt;code>String#repeat()&lt;/code> は、自分自身の文字列を指定回数だけ繰り返した文字列を作成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;C&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">e&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">repeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">[A, BB, CCC]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>Kotlinメモ: マップからキーのリスト、値のリストを作成する (keys, values)</title><link>https://maku77.github.io/p/6r9c6vu/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/6r9c6vu/</guid><description>&lt;p>マップはキーと値のペアを保持するコレクションですが、&lt;strong>&lt;code>keys&lt;/code>&lt;/strong> プロパティでキーだけのリスト、&lt;strong>&lt;code>values&lt;/code>&lt;/strong> プロパティで値だけのリストを取得することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">keys&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">values&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [1, 2, 3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: マップのキー／値をまとめて変更する (mapKeys, mapValues)</title><link>https://maku77.github.io/p/633znjc/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/633znjc/</guid><description>&lt;h2 id="マップ要素のキーをまとめて変更する-mapkeys">マップ要素のキーをまとめて変更する (mapKeys)&lt;/h2>
&lt;p>既存のマップのキーとして使われている値をまとめて変更するには、&lt;strong>&lt;code>mapKeys&lt;/code>&lt;/strong> を使用します。
&lt;code>mapKeys&lt;/code> にラムダ式を渡すと、各要素のキー＆バリューを保持した &lt;strong>&lt;code>Map.Entry&lt;/code>&lt;/strong> オブジェクトがそのラムダ式に順番に渡されます。
各ループ処理でラムダ式が返した戻り値が新しいキーとして扱われます。
&lt;code>Map.Entry&lt;/code> オブジェクトからは、&lt;strong>&lt;code>key&lt;/code>&lt;/strong> で要素のキー、&lt;strong>&lt;code>value&lt;/code>&lt;/strong> で要素の値を参照することができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">例: マップ内のキーをすべて大文字に変換する&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;aaa&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;bbb&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;ccc&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mapKeys&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toUpperCase&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; {AAA=1, BBB=2, CCC=3}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>mapKeys&lt;/code> の戻り値はマップ型です。&lt;/p>
&lt;h2 id="マップ要素の値をまとめて変更する-mapvalues">マップ要素の値をまとめて変更する (mapValues)&lt;/h2>
&lt;p>&lt;strong>&lt;code>mapValues&lt;/code>&lt;/strong> も &lt;code>mapKeys&lt;/code> に似ていますが、こちらはマップ要素の値をまとめて変更します。
ラムダ式は、変更後の要素の値が戻り値になるように実装します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">例: マップ内の値をすべて 2 倍にする&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;aaa&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;bbb&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;ccc&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">mapValues&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; {aaa=2, bbb=4, ccc=6}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>mapValues&lt;/code> の戻り値はマップ型です。&lt;/p></description></item><item><title>Kotlinメモ: マップをソートしてループ処理する (toSortedMap)</title><link>https://maku77.github.io/p/8msfk3j/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8msfk3j/</guid><description>&lt;h2 id="マップをキーでソートする">マップをキーでソートする&lt;/h2>
&lt;p>マップの要素を出力するときに、キー順にソートして出力したいことはよくあると思います。
このような場合、&lt;strong>&lt;code>toSortedMap&lt;/code>&lt;/strong> を使用すると、キーでソートされたマップ (&lt;strong>&lt;code>SortedMap&lt;/code>&lt;/strong>) に変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toSortedMap&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$k&lt;/span>&lt;span class="s2"> -&amp;gt; &lt;/span>&lt;span class="si">$v&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">AAA -&amp;gt; 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">BBB -&amp;gt; 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CCC -&amp;gt; 3&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>forEach&lt;/code> メソッドを使ってループを記述すると、処理の流れが左から右へ一方向になるので、若干可読性が上がるかもしれません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toSortedMap&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$k&lt;/span>&lt;span class="s2"> -&amp;gt; &lt;/span>&lt;span class="si">$v&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>&lt;code>sortedMapOf&lt;/code>&lt;/strong> というファクトリ関数を使って、最初からマップインスタンスを &lt;code>SortedMap&lt;/code> 型で生成してしまう方法もあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">sortedMapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$k&lt;/span>&lt;span class="s2"> -&amp;gt; &lt;/span>&lt;span class="si">$v&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="マップを値でソートする">マップを値でソートする&lt;/h2>
&lt;p>マップ要素の値でソートしたいことがごくたまにあります。
ちょっと工夫が必要なので、いくつか方法を紹介します。&lt;/p>
&lt;h3 id="キーバリューのリストに変換してバリューでソートする方法">キー＆バリューのリストに変換してバリューでソートする方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">pairs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toList&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">sortedBy&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">pairs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$k&lt;/span>&lt;span class="s2">, &lt;/span>&lt;span class="si">$v&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">BBB, 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CCC, 2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">AAA, 3&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h3 id="tosortedmap-にカスタム-comparator-を渡す方法">toSortedMap() にカスタム Comparator を渡す方法&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toSortedMap&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Comparator&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">k1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k2&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k1&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">!!&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">!!&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">map2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$k&lt;/span>&lt;span class="s2">, &lt;/span>&lt;span class="si">$v&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: メンバ参照、結合メンバ参照を理解する</title><link>https://maku77.github.io/p/r2gqqnt/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r2gqqnt/</guid><description>&lt;h2 id="メンバ参照-member-references">メンバ参照 (Member references)&lt;/h2>
&lt;p>Kotlin では、&lt;strong>&lt;code>クラス名::プロパティ名&lt;/code>&lt;/strong> あるいは &lt;strong>&lt;code>クラス名::関数名&lt;/code>&lt;/strong> という記述をメンバ参照 (Member reference) と呼び、あるレシーバオブジェクトに対して、どのメンバを参照するかを示すことができます。&lt;/p>
&lt;p>&lt;code>Book&lt;/code> クラスの &lt;code>price&lt;/code> プロパティを参照するメンバ参照は、&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Book&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">price&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>と記述することができ、これは下記のようなラムダ式と同じ意味を持ちます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、&lt;code>Book&lt;/code> オブジェクトをパラメータとして受け取り、その &lt;code>price&lt;/code> プロパティの値を返す関数です。
メンバ参照を変数に格納しておくと、後から通常の関数のように呼び出すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// price プロパティの値を参照するメンバ参照
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">getPrice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">price&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">book&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getPrice&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">book&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; 1000
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>メンバ参照は、コレクション系のメソッドに適用できるケースがよくあります。
下記の例では、リストをソートする関数 &lt;code>sortedBy&lt;/code> に、メンバ参照オブジェクトを渡しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// price プロパティの値を参照するメンバ参照
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">getPrice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">price&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">books&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">300&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">500&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title3&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">sortedBooks&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">books&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sortedBy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getPrice&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように単純なケースでは、次のように直接ラムダ式を渡してもシンプルに記述できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">books&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sortedBy&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、メンバ参照オブジェクトを変数やパラメータ経由で渡すようなケースでは、メンバ参照の記法を使った方が短く記述できます。
型の推論が働かないため、デフォルトのイテレータ変数 (&lt;code>it&lt;/code>) を使えないからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">getPrice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="c1">// Good
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">getPrice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Book&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">// OK（冗長）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">getPrice&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">// NG（コンパイルエラー）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>パラメータを持つインスタンスメソッドをメンバ参照を使って呼び出す場合は、第二引数以降にメソッドのパラメータとして渡す値を指定します。
第一引数では、レシーバオブジェクトを指定しなければいけないからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">greet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello, &lt;/span>&lt;span class="si">$name&lt;/span>&lt;span class="s2">. I am &lt;/span>&lt;span class="si">${this.name}&lt;/span>&lt;span class="s2">.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">g&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Person&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">greet&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">p&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Person&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">g&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Hemu&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="トップレベル関数の参照-reference-to-the-top-level-function">トップレベル関数の参照 (Reference to the Top-level function)&lt;/h2>
&lt;p>トップレベルに定義した関数の参照は、クラス名を省略した形で &lt;strong>&lt;code>::関数名&lt;/code>&lt;/strong> と記述することで取得することができます。
下記の例では、&lt;code>greet&lt;/code> 関数の参照を、&lt;code>g&lt;/code> 変数に取得しています。&lt;/p></description></item><item><title>Kotlinメモ: ラムダ式の基本 (lambda expression)</title><link>https://maku77.github.io/p/rdoseay/</link><pubDate>Thu, 16 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/rdoseay/</guid><description>&lt;h2 id="ラムダ式とは">ラムダ式とは&lt;/h2>
&lt;p>ラムダ式は、パラメータを受け取ることのできる名前のない小さなコードブロックです。
Kotlin では、ラムダ式は次のように中括弧 &lt;code>{}&lt;/code> で囲んで定義します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このラムダ式は、2 つの &lt;code>Int&lt;/code> 型パラメータを受け取り、足し合わせた値を返します。
ラムダ式を変数に格納すると、&lt;strong>通常の関数のように呼び出すことができる&lt;/strong>ようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">sum&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; 3
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ラムダ式の典型的な使い方は、処理の一部をパラメータとして渡す使い方です。
次の例では、ボタンが押されたときのイベントハンドラとして、パラメータなしのラムダ式をセットしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">button&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setOnClickListener&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ボタンが押されたよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようなコールバック処理は、インタフェースを実装したオブジェクトを渡すことでも実現できますが、ラムダ式を使うと関数の本体部分だけを渡すことができるので、とてもシンプルな記述ができます。&lt;/p>
&lt;h2 id="ラムダ式を受け取る関数を定義する">ラムダ式を受け取る関数を定義する&lt;/h2>
&lt;p>下記の &lt;code>myRepeat&lt;/code> 関数は、第1引数 &lt;code>times&lt;/code> で指定された回数だけ、第2引数 &lt;code>action&lt;/code> で指定されたラムダ式を繰り返し実行します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">myRepeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">times&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">action&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">Unit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">index&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="n">until&lt;/span> &lt;span class="n">times&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">action&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>パラメータ &lt;code>action&lt;/code> の型は &lt;strong>&lt;code>(Int) -&amp;gt; Unit&lt;/code>&lt;/strong> となっていますが、これは、&lt;code>Int&lt;/code> 型のパラメータを取り、戻り値がない (&lt;code>Unit&lt;/code>) ラムダ式を受け取ることを表しています。
&lt;code>myRepeat&lt;/code> 関数は次のように使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myRepeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello &lt;/span>&lt;span class="si">$i&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)}&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">Hello 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Hello 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Hello 2&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記のように、関数の最後のパラメータがラムダ式である場合、その関数を呼び出すときに、ラムダ式を括弧の外に出して次のように記述することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">myRepeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello &lt;/span>&lt;span class="si">$i&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような記述方法が許されているので、ラムダ式の中が複数行にわたるコードになった場合にも、次のようにシンプルに記述することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">myRepeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${i + 1}&lt;/span>&lt;span class="s2"> 回目のループ処理です&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ラムダ式のパラメータが 1 つだけのとき、&lt;code>i -&amp;gt;&lt;/code> の部分を省略し、代わりに &lt;strong>&lt;code>it&lt;/code>&lt;/strong> というパラメータ名で参照することができます。&lt;/p></description></item><item><title>Kotlinメモ: オブジェクト宣言でシングルトンを作成する (object declaration)</title><link>https://maku77.github.io/p/wc8f9y8/</link><pubDate>Tue, 14 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wc8f9y8/</guid><description>&lt;h2 id="オブジェクト宣言によるシングルトン実装">オブジェクト宣言によるシングルトン実装&lt;/h2>
&lt;p>Java のシングルトンに相当するものは、Kotlin では&lt;strong>オブジェクト宣言 (object declrations)&lt;/strong> を使用して簡単に実装することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">object&lt;/span> &lt;span class="nc">Log&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の例では、&lt;code>object Log&lt;/code> という部分で &lt;code>Log&lt;/code> という名前のオブジェクトを作成しています。
その後ろに続く &lt;code>{ ... }&lt;/code> のブロックがクラス定義の内容です。
無名のクラス定義があり、そのインスタンスとして &lt;code>Log&lt;/code> という名前のオブジェクトを生成していると考えるとよいでしょう。&lt;/p>
&lt;p>&lt;code>Log&lt;/code> オブジェクトのメソッドを呼び出すコードは下記のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Log&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Something bad happened&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>オブジェクト名が大文字で始まっていて、クラス名のように見えるので、まるで Java の static メソッド呼び出しのように見えますが、実際には &lt;code>Log&lt;/code> という名前のオブジェクトのメソッド呼び出しているにすぎません。
&lt;strong>Kotlin には &lt;code>static&lt;/code> フィールドというものは存在しません&lt;/strong>（&lt;code>@JvmStatic&lt;/code> という魔法のキーワードはありますが）。&lt;/p>
&lt;p>オブジェクト宣言では、通常のクラス定義と同様に、メソッドやプロパティ、初期化ブロック (&lt;code>init&lt;/code>) などの定義を行うことができますが、&lt;strong>プライマリ・コンストラクタやセカンダリ・コンストラクタの定義を行うことはできません&lt;/strong>（クラス定義とインスタンス化が同時に行われるため、他の場所でコンストラクタを呼び出すタイミングがないからです）。&lt;/p>
&lt;p>コンストラクタは定義できないので、下記のようにインスタンスを作成することはできません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">log&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Log&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// NG（インスタンス化はできない）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>よって、オブジェクト宣言によって作成されたオブジェクトは、シングルトンオブジェクトとして使用することができます。&lt;/p>
&lt;h2 id="オブジェクト宣言で継承を行う">オブジェクト宣言で継承を行う&lt;/h2>
&lt;p>オブジェクト宣言 (object declaration) では、普通のクラス実装と同様、別のクラスの継承や、インタフェースの実装を行うことができます。
あくまでクラス定義とインスタンス生成を実装を同時に行っているだけで、このあたりの制約はありません（コンストラクタは定義できないので、コンストラクタでパラメータを渡せない点には注意）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">object&lt;/span> &lt;span class="nc">DefaultListener&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">MouseAdapter&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">mouseClicked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">MouseEvent&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">mouseEntered&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">MouseEvent&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>ステートを持たないアルゴリズムなどは、オブジェクト宣言によって実装してしまう&lt;/strong>のがよいでしょう。
下記の例では、&lt;code>Book&lt;/code> クラスのオブジェクトを値段で比較するための &lt;code>Comparator&lt;/code> を実装しています。&lt;/p></description></item><item><title>Kotlinメモ: オブジェクト式で無名オブジェクトを生成する (object expression)</title><link>https://maku77.github.io/p/8yzdom9/</link><pubDate>Tue, 14 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/8yzdom9/</guid><description>&lt;h2 id="オブジェクト式の基本">オブジェクト式の基本&lt;/h2>
&lt;p>&lt;a href="../p/wc8f9y8/">オブジェクト宣言 (object declaration)&lt;/a> は、クラスの定義とインスタンス生成を同時に行う構文ですが、これと似たものに &lt;strong>オブジェクト式 (object expression)&lt;/strong> があります。&lt;/p>
&lt;p>オブジェクト宣言では、&lt;code>object MyObj { ... }&lt;/code> のように、クラス定義と同時に名前付きのオブジェクトを作成していましたが、オブジェクト式はその場で名前なしの無名オブジェクト (anonymous objects) を生成します。
オブジェクト式を使って生成したオブジェクトは、変数に格納するか、関数に渡すパラメータとして使用します（そうしないと参照できないため）。&lt;/p>
&lt;p>下記の例では、オブジェクト式を使って、&lt;code>greet()&lt;/code> 関数を持つ無名オブジェクトを生成しています。
生成されたオブジェクトを使用するために、いったん &lt;code>myObj&lt;/code> という変数に格納しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">myObj&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="err">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">myObj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">greet&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（これだけ見ると、JavaScript のオブジェクトにとても似ていますね）&lt;/p>
&lt;p>オブジェクト式は、何らかのインタフェースを実装する無名オブジェクトを生成するときによく使われます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">ButtonListener&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">onClicked&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">listener&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="err">: &lt;/span>&lt;span class="nc">ButtonListener&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">onClicked&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;押されたよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>オブジェクト式により生成した無名オブジェクトを、関数のパラメータに直接渡してしまうこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">button&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">addListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">object&lt;/span> &lt;span class="err">: &lt;/span>&lt;span class="nc">ButtonListener&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">onClicked&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;押されたよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただし、このように記述すると、このコードが実行されるたびにオブジェクトが生成されることに注意してください。&lt;/p>
&lt;p>ちなみに、オブジェクト宣言 (object declaration) を使った場合は、下記のような記述になりますが、この場合は、イコール演算子の右側に書いたり、そのまま関数のパラメータで渡したりすることはできません（オブジェクト宣言は「式」ではないので、値を持ちません）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// オブジェクト宣言 (object declaration) の場合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">object&lt;/span> &lt;span class="nc">MyButtonListener&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">ButtonListener&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">onClicked&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;押されたよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="オブジェクト式から外部変数を参照する">オブジェクト式から外部変数を参照する&lt;/h2>
&lt;p>オブジェクト式のクラス実装部分からは、その外側のスコープにある変数や関数を参照することができます。
これは Java の無名インナクラスと同様ですが、Kotlin では &lt;code>final&lt;/code> 修飾されていない変数を参照することができ、さらに、その値を変更することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">startCounting&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">button&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Button&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">var&lt;/span> &lt;span class="py">count&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">button&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">addListener&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">object&lt;/span> &lt;span class="err">: &lt;/span>&lt;span class="nc">ButtonListener&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">onClicked&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">${++count}&lt;/span>&lt;span class="s2"> 回クリックされたよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">})&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java-の無名インナークラスに比べた利点">Java の無名インナークラスに比べた利点&lt;/h2>
&lt;p>Kotlin のオブジェクト式は、Java では無名インナークラスに相当します。&lt;/p></description></item><item><title>Kotlinメモ: コンパニオンオブジェクトでクラスに静的メソッドを追加する (companion object)</title><link>https://maku77.github.io/p/n2jphu2/</link><pubDate>Tue, 14 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/n2jphu2/</guid><description>&lt;h2 id="コンパニオンオブジェクトの基本">コンパニオンオブジェクトの基本&lt;/h2>
&lt;p>Kotlin は言語仕様上、クラスに static なフィールドを持たせることはできませんが、&lt;strong>コンパニオンオブジェクト (companion object)&lt;/strong> の仕組みを利用すると、Java の static メソッドと同様な振る舞いを実現できます。
コンパニオンオブジェクトは、クラス本体部分で下記のように &lt;code>companion object&lt;/code> を使って定義します（無名のコンパニオンオブジェクト）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">FREE&lt;/span>&lt;span class="n">_PRICE&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">newFreeBook&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FREE_PRICE&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">book&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">newFreeBook&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Free Kotlin&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">book&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Book(title=Free Kotlin, price=0)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>companion object&lt;/code> の後ろの &lt;code>{}&lt;/code> の中は、通常のクラスの本体と同じように実装します（&lt;code>private&lt;/code> なフィールドを定義することもできます）。
上記のようにコンパニオンオブジェクトを定義すると、&lt;code>Book&lt;/code> クラスの中に暗黙的なシングルトンインスタンスが生成され、&lt;code>Book.フィールド名&lt;/code> という形でアクセスできるようになります。
つまり、Java の static フィールドと同じ形でアクセスできます。
正確には Java の static フィールドとは異なり、内部でコンパニオンオブジェクトと呼ばれるオブジェクトが生成されているのですが、通常はあまり気にする必要はないでしょう。&lt;/p>
&lt;div class="xNote">
 &lt;span class="xNote_title">☝️ コンパニオンオブジェクトは外側のクラスのインスタンスではない&lt;/span>
 &lt;span class="xNote_body">&lt;p>コンパニオンオブジェクトはそれ自身がクラス定義を持っており、外側で定義されたクラスのインスタンスではないことに注意してください。
&lt;code>Book.xxx()&lt;/code> というアクセス方法を見ると、あたかも &lt;code>Book&lt;/code> クラスのシングルトンインスタンスが作られているかのように見えますが、&lt;code>Book&lt;/code> インスタンスが作られているわけではありません。&lt;/p>
&lt;p>&lt;code>Book.xxx()&lt;/code> という記述は、実は &lt;code>Book.Companion.xxx()&lt;/code> の省略記法です。
このことからも、コンパニオンオブジェクトは、&lt;code>Book&lt;/code> クラスのインスタンスとは別物であることが分かります。&lt;/p>
&lt;/span>
&lt;/div>
&lt;h2 id="コンパニオンオブジェクトに名前を付ける">コンパニオンオブジェクトに名前を付ける&lt;/h2>
&lt;p>&lt;a href="../p/wc8f9y8/">オブジェクト宣言でオブジェクトを生成する&lt;/a>場合と同様、コンパニオンオブジェクトにも名前を付けることができます。&lt;/p>
&lt;p>下記の例では、&lt;code>Book&lt;/code> クラスのコンパニオンオブジェクトに、&lt;code>Factory&lt;/code> という名前を付けています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="n">Factory&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">FREE&lt;/span>&lt;span class="n">_PRICE&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">freeBook&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">FREE_PRICE&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコンパニオンオブジェクトには、&lt;code>Book.Factory.フィールド名&lt;/code> という形でアクセスすることができます。&lt;/p></description></item><item><title>Kotlinメモ: コンパニオンオブジェクトとクラス内オブジェクト宣言の違い</title><link>https://maku77.github.io/p/rej4be5/</link><pubDate>Tue, 14 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/rej4be5/</guid><description>&lt;p>コンパニオンオブジェクトは、クラスに付随するシングルトンオブジェクトとして参照できます。
また、クラス内でオブジェクト宣言を行うと、これまたシングルトンオブジェクトとして参照できます。
これらはいったい何が違うのでしょうか？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 名前付きコンパニオンオブジェクト
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="n">Foo&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Foo.hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// オブジェクト宣言
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="nc">Bar&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Bar.hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">Foo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; Foo.hello
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">Bar&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; Bar.hello
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見するとまったく違いがありませんが、シングルトンオブジェクトが生成されるタイミングに微妙な違いがあります。&lt;/p>
&lt;ul>
&lt;li>&lt;b>コンパニオンオブジェクト&lt;/b> &amp;hellip; &lt;strong>外側のクラスが参照されたときに生成される（Java の static initializer と同様）&lt;/strong>&lt;/li>
&lt;li>&lt;b>クラス内オブジェクト宣言&lt;/b> &amp;hellip; &lt;strong>そのオブジェクト自身が参照されたときに生成される&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>次のように、それぞれのシングルトン定義に初期化ブロック (&lt;code>init&lt;/code>) を作ってやると、初期化の順序を確認することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">companion&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="n">Foo&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">init&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Foo.init&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Foo.hello()&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">object&lt;/span> &lt;span class="nc">Bar&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">init&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Bar.init&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Bar.hello()&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">obj&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MyClass&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;2&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">Foo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;3&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">MyClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">Bar&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Foo.init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Foo.hello()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Bar.init
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Bar.hello()&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>コンパニオンオブジェクトである &lt;code>Foo&lt;/code> インスタンスは、外側のクラスの &lt;code>MyClass&lt;/code> がインスタンス化されるときに同時に生成されています（だからコンパニオンって言うんですね）。
一方で、オブジェクト宣言された &lt;code>Bar&lt;/code> オブジェクトは、&lt;code>Bar.hello()&lt;/code> 関数が呼び出された時点で初めて生成されます。&lt;/p></description></item><item><title>Kotlinメモ: by を使ったメソッド呼び出しの委譲 (class delegation)</title><link>https://maku77.github.io/p/kh358jg/</link><pubDate>Mon, 13 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/kh358jg/</guid><description>&lt;h2 id="by-による委譲とは">by による委譲とは&lt;/h2>
&lt;p>Decorator パターンを実装したり、コレクションクラスを委譲によって拡張したいケースでは、ベースとなるインタフェースで定義されているすべてのメソッドを実装しなければいけません。
あるクラスの機能を継承なしで拡張できる一方で、拡張しなくてもよいメソッドも含めて委譲処理を実装しなければいけないのは骨の折れる作業です。
単純なボイラープレート実装があふれたコードは美しくありません。&lt;/p>
&lt;p>このようなケースで利用できるのが、&lt;strong>&lt;code>by&lt;/code> によるメソッド呼び出しの委譲 (class delegation)&lt;/strong> です。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">IBar インタフェースの呼び出しを bar オブジェクトへ委譲&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">bar&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">IBar&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">IBar&lt;/span> &lt;span class="k">by&lt;/span> &lt;span class="n">bar&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>実装するインタフェース名に続けて &lt;code>by someObj&lt;/code> と記述すると、そのインタフェースの実装を指定したオブジェクト &lt;code>someObj&lt;/code> に一括で委譲することができます。
そして、必要なメソッドだけをオーバーライドすることができます。&lt;/p>
&lt;p>具体的に見ていきましょう。&lt;/p>
&lt;h2 id="by-による委譲処理の例">by による委譲処理の例&lt;/h2>
&lt;p>例えば、下記のような単純なログ出力クラス &lt;code>SimpleLogger&lt;/code> があるとします（Decorator パターンを使って出力をカスタマイズするため、あらかじめ &lt;code>Logger&lt;/code> インタフェースを定義しています）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">Logger&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">warn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">SimpleLogger&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Logger&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">warn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この &lt;code>SimpleLogger&lt;/code> クラスを Decorator パターンで拡張し、&lt;strong>&lt;code>error&lt;/code> メソッドの呼び出し時にだけ &lt;code>ERROR: &lt;/code> というプレフィックスを付けて出力する&lt;/strong> ようにします。
単純に実装すると下記のようになると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">EmphasizedLogger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">logger&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Logger&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Logger&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">info&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">warn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">warn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">text&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ERROR: &lt;/span>&lt;span class="si">$text&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">logger&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">EmphasizedLogger&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SimpleLogger&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">logger&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; ERROR: Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もちろん、これはこれで間違いではありませんが、&lt;code>info&lt;/code> メソッドと &lt;code>warn&lt;/code> メソッドは単純に処理を委譲しているだけで、見るからに冗長な感じがします。
このようなとき &lt;code>by&lt;/code> を使用すると、あるインタフェースに関する処理を、指定したオブジェクトにまとめて委譲してしまうことができます。&lt;/p></description></item><item><title>Kotlinメモ: シールクラスで継承可能なクラスを制限する (sealed class)</title><link>https://maku77.github.io/p/d8kkspv/</link><pubDate>Mon, 13 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/d8kkspv/</guid><description>&lt;h2 id="シールクラスとは">シールクラスとは&lt;/h2>
&lt;p>クラスを定義するときに、&lt;strong>&lt;code>sealed&lt;/code>&lt;/strong> キーワードを使ってマークするとそのクラスは&lt;strong>シールクラス (sealed class)&lt;/strong> となり、そのクラスのサブクラスとなれるクラスを制限することができます。
例えば、&lt;code>Screen&lt;/code> クラスのサブクラスが、&lt;code>Screen.Main&lt;/code>、&lt;code>Screen.ProductList&lt;/code> しか存在しないことを明示することができます。&lt;/p>
&lt;p>Kotlin はシールクラスを列挙型クラス (enum class) の強化版のようなものだと位置付けています。
enum 型は各インスタンスがシングルトンとしてのみ存在可能ですが、シールクラスのサブクラスは、シングルトンにすることもできますし、個別のインスタンスとして生成することもできます。&lt;/p>
&lt;p>シールクラスは抽象クラスと同様の性質を持ちます。
デフォルトで継承可能 (&lt;code>open&lt;/code>) なクラスとして定義され、&lt;code>abstract&lt;/code> なメソッド、プロパティを含むことができます。
インスタンスを生成するときは、必ずサブクラスのインスタンスとして生成しなければいけません。&lt;/p>
&lt;h2 id="シールクラスの利用例">シールクラスの利用例&lt;/h2>
&lt;p>シールクラスは利用例を見たほうが理解しやすいと思います。
例えば、列挙型クラスのようなものを作りたいのだけれど、場合によってはパラメータを渡して亜種となるオブジェクトを作らなければいけない、といったケースで利用できます。&lt;/p>
&lt;p>ここでは、アプリケーションの「画面状態」を示す &lt;code>Screen&lt;/code> クラスを考えてみます。
画面状態には下記の種類があります。&lt;/p>
&lt;ol>
&lt;li>&lt;code>Screen.Main&lt;/code> &amp;ndash; メイン画面&lt;/li>
&lt;li>&lt;code>Screen.ProductList&lt;/code> &amp;ndash; 全商品のリスト画面&lt;/li>
&lt;li>&lt;code>Screen.ProductDetail&lt;/code> &amp;ndash; ある商品の詳細画面（&lt;strong>商品 ID プロパティを含む&lt;/strong>）&lt;/li>
&lt;/ol>
&lt;p>これらが 3 つの画面状態だけを示せればよいのであれば、従来の列挙クラスで 3 つの要素を定義してやれば解決です。
問題は、3 つ目の &lt;code>Screen.ProductDetail&lt;/code> が、表示対象となる商品の ID をプロパティとして保持するという点です。
つまり、&lt;code>Screen.ProductDetail&lt;/code> という 1 つの画面状態だけを示せばよいのではなく、&lt;code>Screen.ProductDetail(1)&lt;/code> とか、&lt;code>Screen.ProductDetail(2)&lt;/code> といった異なる画面状態を表現したいということです。&lt;/p>
&lt;p>このように、列挙型の個々のオブジェクトに異なるプロパティを持たせたいという場面に出くわしたら、シールクラスの出番です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">sealed&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Screen&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">object&lt;/span> &lt;span class="nc">Main&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Screen&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">object&lt;/span> &lt;span class="nc">ProductList&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Screen&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">ProductDetail&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">productId&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Screen&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="note">
ここでは、シールクラスのサブクラスをネストして定義していますが、ネストさせる必要は必ずしもありません。
ただ、enum クラスの拡張としてシールクラスを利用するのであれば、このようにネストして定義しておいた方がわかりやすいでしょう。
&lt;/div>
&lt;p>上記のようにシールクラスを定義すると、&lt;code>Screen.Main&lt;/code> や &lt;code>Screen.ProductList&lt;/code> などのシングルトンは従来の列挙型要素のように扱うことができ、さらに、データクラスとして定義した &lt;code>Screen.ProductDetail&lt;/code> には自身のプロパティとして &lt;code>productId&lt;/code> を持たせることができます。&lt;/p></description></item><item><title>Kotlinメモ: データクラスを定義する (data class)</title><link>https://maku77.github.io/p/fc4unhr/</link><pubDate>Mon, 13 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/fc4unhr/</guid><description>&lt;h2 id="データクラスとは">データクラスとは&lt;/h2>
&lt;p>Kotlin で単純なプロパティを保持するだけのクラスは、下記のように簡単に定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これだけでも十分便利ですが、さらに &lt;strong>&lt;code>data&lt;/code>&lt;/strong> キーワードを付けることにより、そのクラスは&lt;strong>データクラス&lt;/strong>として定義されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>データクラスとして定義すると、プライマリ・コンストラクタで定義したフィールドを扱う、下記のようなメソッドが内部で自動生成されます。&lt;/p>
&lt;ul>
&lt;li>&lt;code>fun toString() : String&lt;/code> &amp;hellip; オブジェクトの文字列表現を返す&lt;/li>
&lt;li>&lt;code>fun equals(other: Any?) : Boolean&lt;/code> &amp;hellip; オブジェクトの同一性を判断する&lt;/li>
&lt;li>&lt;code>fun hashCode() : Int&lt;/code> &amp;hellip; コレクションクラスなどが利用するハッシュ値を返す&lt;/li>
&lt;li>&lt;code>fun copy(...) : T&lt;/code> &amp;hellip; オブジェクトのコピーを生成する&lt;/li>
&lt;/ul>
&lt;p>Java では、これらのメソッドを IDE などの力を借りるなどしてコードの形で実装する必要がありましたが、Kotlin では、クラス定義の先頭に &lt;strong>&lt;code>data&lt;/code>&lt;/strong> キーワードを付加するだけです。
ボイラープレート的なコードを記述する必要がないので、コードをシンプルに保つことができます。&lt;/p>
&lt;p>データクラスのオブジェクトは、&lt;strong>そのまま &lt;code>println&lt;/code> でわかりやすい表現で出力できるようになり、ハッシュ系のコレクションに追加できるようになります&lt;/strong>。
下記のサンプルでは、データクラスの &lt;code>println&lt;/code> が正しく動作していること、&lt;code>HashSet&lt;/code> への格納が正しくできていることを確認しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Kotlin入門&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Book(title=Kotlin入門, price=1000)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">hashSetOf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;T1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;T1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="c1">// 同じ内容の本を追加
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;T2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">200&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 2（内容が同一だという判断がちゃんとできている）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意しなければいけないのは、自動生成される実装は、&lt;strong>プライマリ・コンストラクタで定義されたフィールドのみを扱う&lt;/strong>ということです。
例えば、&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">var&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように定義されたクラスは、&lt;code>equals()&lt;/code> の比較には &lt;code>title&lt;/code> フィールドの値のみが参照されます。
クラス本体部分で定義されている &lt;code>price&lt;/code> プロパティの値は無視されます（&lt;code>price&lt;/code> が異なっても同一とみなされる）。
&lt;code>equals()&lt;/code> メソッドに &lt;code>price&lt;/code> フィールドの値まで認識させるには、下記のようにパラメータ部分で &lt;code>val&lt;/code> キーワードを使ってフィールド定義する必要があります。&lt;/p></description></item><item><title>Kotlinメモ: クラスにプロパティのアクセサメソッドを定義する (set, get)</title><link>https://maku77.github.io/p/g2bj9zs/</link><pubDate>Fri, 10 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/g2bj9zs/</guid><description>&lt;h2 id="カスタムアクセサとは">カスタムアクセサとは&lt;/h2>
&lt;p>Kotlin では、下記のようにクラスのプロパティを定義するだけで、自動的に setter/getter が生成されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">var&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;タイトル1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;タイトル2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多くの場合はこれだけで十分ですが、プロパティの値を読み書きする際に何らかの処理を行いたい場合は、プロパティのカスタムアクセサ (getter/setter) を定義する必要があります。&lt;/p>
&lt;h2 id="カスタムアクセサを定義する-set--get">カスタムアクセサを定義する (set() / get())&lt;/h2>
&lt;p>プロパティにアクセスしたときの振る舞いは、&lt;strong>&lt;code>get&lt;/code>&lt;/strong>、&lt;strong>&lt;code>set&lt;/code>&lt;/strong> を実装することでカスタマイズできます。
下記の例では、&lt;code>title&lt;/code> プロパティに対してカスタム getter、setter を定義しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">var&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">title&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">get&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;get: &lt;/span>&lt;span class="si">$field&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">field&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;set: &lt;/span>&lt;span class="si">$field&lt;/span>&lt;span class="s2"> -&amp;gt; &lt;/span>&lt;span class="si">$value&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">field&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>print(book.title)&lt;/code> のようにプロパティの値を参照すると &lt;code>get()&lt;/code> が呼び出され、&lt;code>book.title = &amp;quot;あああ&amp;quot;&lt;/code> のようにプロパティの値を書き換えようとすると &lt;code>set(value)&lt;/code> が呼び出されます。&lt;/p>
&lt;p>&lt;strong>プロパティとして現在保持されている値は &lt;code>field&lt;/code> キーワードで参照できます&lt;/strong>。
setter の実装の中では、&lt;code>field&lt;/code> に値を代入することで、プロパティが保持する値を変更します。
setter が呼び出されたときに、先に &lt;code>field&lt;/code> の値を参照すれば、プロパティの値を変更する前の元の値を取得できます。
例えば、下記のようにすれば、&lt;strong>プロパティの値が実際に変更されるときのみ処理を行う&lt;/strong> ということが実現できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">var&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">title&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">value&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">field&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;値を &lt;/span>&lt;span class="si">$field&lt;/span>&lt;span class="s2"> から &lt;/span>&lt;span class="si">$value&lt;/span>&lt;span class="s2"> に変更したよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">field&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">value&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;あああ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;あああ&amp;#34;&lt;/span> &lt;span class="c1">// 何も起こらない
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;いいい&amp;#34;&lt;/span> &lt;span class="c1">//=&amp;gt; 値を あああ から いいい に変更したよ
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="setter-のみを非公開-private-にする">setter のみを非公開 (private) にする&lt;/h2>
&lt;p>getter や setter の可視性は、デフォルトではプロパティそのものの可視性と等しくなります。
public なプロパティの getter と setter のうち一方を private にしたい場合、&lt;code>set&lt;/code>、&lt;code>get&lt;/code> の前に &lt;code>private&lt;/code> キーワードを付けます。&lt;/p></description></item><item><title>Kotlinメモ: 継承可能なクラスを作成する (open, abstract, override)</title><link>https://maku77.github.io/p/r4wcjss/</link><pubDate>Fri, 10 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/r4wcjss/</guid><description>&lt;h2 id="open-と-override">open と override&lt;/h2>
&lt;p>Kotlin のクラス定義を行うと、デフォルトでは継承できないようになっています。
&lt;strong>継承可能なクラスとして定義するには、&lt;code>open&lt;/code> モディファイアを付ける&lt;/strong>必要があります。
さらに、その中で&lt;strong>オーバーライド可能なメソッドにも &lt;code>open&lt;/code> モディファイアを付ける&lt;/strong>必要があります。&lt;/p>
&lt;p>下記の &lt;code>Animal&lt;/code> クラスは継承可能であり、&lt;code>cry&lt;/code> メソッドがオーバーライドできるようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Animal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;私は&lt;/span>&lt;span class="si">${name}&lt;/span>&lt;span class="s2">です。&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cry&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">open&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">cry&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ウー！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下記の &lt;code>Cat&lt;/code>、&lt;code>Dog&lt;/code> クラスは &lt;code>Animal&lt;/code> クラスを継承し、&lt;code>cry&lt;/code> メソッドをオーバーライドしています。
&lt;strong>オーバーライドしていることを示すために、メソッドの定義時に &lt;code>override&lt;/code> キーワードを付ける&lt;/strong>必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Cat&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Animal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;猫&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">cry&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ニャー！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Dog&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Animal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;犬&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">cry&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ワンワン！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Animal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;動物&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 私は動物です。ウー！
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Cat&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 私は猫です。ニャー！
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Dog&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// 私は犬です。ワンワン！
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="それ以上オーバーライドを許可しない-final">それ以上オーバーライドを許可しない (final)&lt;/h2>
&lt;p>&lt;code>override&lt;/code> の付いたメソッドはデフォルトで &lt;code>open&lt;/code> な状態になっており、さらにその子クラスでオーバーライドすることが可能です。
&lt;strong>これ以上のオーバーライドを禁止するには、明示的に &lt;code>final&lt;/code> キーワードを付けて &lt;code>override&lt;/code> する&lt;/strong>必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Cat&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Animal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;猫&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">final&lt;/span> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">cry&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ニャー！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="親クラスのコンストラクタを呼び出す-super">親クラスのコンストラクタを呼び出す (super)&lt;/h2>
&lt;p>サブクラスのコンストラクタ呼び出しからは、間接的、あるいは直接的に親クラスのコンストラクタを呼び出す必要があります。
親クラスがパラメータなしの（自動生成された）コンストラクタしか持たない場合でも、その&lt;strong>パラメータなしのコンストラクタを使用するということを示すために、後ろに &lt;code>()&lt;/code> を付けて呼び出しておく必要があります&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">open&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Parent&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Child&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Parent&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>サブクラスがセカンダリ・コンストラクタしか持たない場合は、&lt;strong>&lt;code>super&lt;/code>&lt;/strong> キーワードを使って、親クラスのいずれかのコンストラクタを呼び出すようにすれば OK です。&lt;/p></description></item><item><title>Kotlinメモ: 文字列をデリミタ文字で分割する (split)</title><link>https://maku77.github.io/p/mngmt9c/</link><pubDate>Wed, 08 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/mngmt9c/</guid><description>&lt;h2 id="カンマで文字列を分割する">カンマで文字列を分割する&lt;/h2>
&lt;p>Kotlin で文字列を分割するには、Java と同様に &lt;code>String&lt;/code> クラスの &lt;strong>&lt;code>split&lt;/code>&lt;/strong> メソッドを使用します。
下記は、CSV 形式の文字列（カンマ区切り文字列）をカンマで分割する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;AAA, BBB, CCC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;AAA&amp;#34;, &amp;#34; BBB&amp;#34;, &amp;#34; CCC&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>カンマの前後の空白文字を削除したい場合は、分割後に &lt;code>trim()&lt;/code> を全要素に対してかけてあげればよいでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;AAA, BBB, CCC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">trim&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;AAA&amp;#34;, &amp;#34;BBB&amp;#34;, &amp;#34;CCC&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>頻繁に使用する場合は、次のように &lt;code>String&lt;/code> クラスに拡張関数を作ってしまうのもよいかもしれません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * CSV 形式の文字列をカンマで分割します。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * 各要素の先頭・末尾の空白は削除されます。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">String&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parseCsv&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">trim&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 使用例
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;1, 2, 3&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">parseCsv&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="複数のデリミタ文字を指定する">複数のデリミタ文字を指定する&lt;/h2>
&lt;p>Kotlin は &lt;code>String&lt;/code> クラスの拡張関数として、&lt;code>split&lt;/code> の別バージョンを定義しています。
例えば、複数のデリミタ文字を受け取ることができるようになっているので、下記のようにしてドット (&lt;code>.&lt;/code>)、あるいはカンマ (&lt;code>,&lt;/code>) で分割するといった処理を簡単に記述できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;123.456,789&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">split&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;,&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [&amp;#34;123&amp;#34;, &amp;#34;456&amp;#34;, &amp;#34;789&amp;#34;]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに Java で同じようなことを実現しようとすると、次のように正規表現を使うことになります。&lt;/p></description></item><item><title>Kotlinメモ: 既存のクラスに関数やプロパティを追加する（拡張関数）</title><link>https://maku77.github.io/p/du53m3v/</link><pubDate>Wed, 08 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/du53m3v/</guid><description>&lt;h2 id="クラスに拡張関数を追加する">クラスに拡張関数を追加する&lt;/h2>
&lt;p>拡張関数を使うと、自分で作成したクラスではなくてもメソッドを追加することができます。
例えば、Java のコアライブラリの &lt;code>String&lt;/code> クラスや、Android SDK が提供するクラスなどを拡張することができます。
やりすぎると分かりにくくなってしまいますが、効果的に導入すると、簡潔で分かりやすいコードを記述できるようになります。&lt;/p>
&lt;p>次の例では、&lt;code>String&lt;/code> クラスに拡張関数を追加し、ある文字列が &lt;code>0x&lt;/code> あるいは &lt;code>0X&lt;/code> で始まっているかを調べる &lt;code>isHex&lt;/code> メソッドを定義しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">String&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isHex&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Boolean&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">startsWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;0x&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;0x123&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isHex&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//=&amp;gt; true
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;12345&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isHex&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//=&amp;gt; false
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>拡張関数の中で &lt;code>this&lt;/code> を参照すると、レシーバオブジェクトを参照する&lt;/strong>ことができます。
つまり、&lt;code>s.isHex()&lt;/code> と呼び出した場合、&lt;code>this&lt;/code> はオブジェクト &lt;code>s&lt;/code> を参照します。&lt;/p>
&lt;p>拡張関数の実装は、普通のメソッド実装と同じ感覚で記述することができるので、拡張関数の中からメンバメソッドを呼び出すときは、通常 &lt;code>this&lt;/code> を省略することができます。
よって、上記の &lt;code>String.isHex()&lt;/code> 関数は下記のように記述できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">String&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isHex&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Boolean&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">startsWith&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;0x&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">true&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、拡張関数の中から別のメンバメソッドを呼び出すことができるのですが、&lt;strong>呼び出せるのは public なメンバメソッドだけ&lt;/strong>であることに注意してください。
private メソッドや、protected メソッドを呼び出すことはできません。
これは、拡張関数を追加することによって、カプセル化されたクラス構造を破壊してしまわないようにするための Kotlin の配慮です。&lt;/p>
&lt;h2 id="int-などの基本型に拡張関数を追加する">Int などの基本型に拡張関数を追加する&lt;/h2>
&lt;p>Kotlin の &lt;code>Int&lt;/code> などの基本型に拡張関数を追加する場合、その値自身は &lt;code>this&lt;/code> で参照することができます。
下記の例では、&lt;code>Int&lt;/code> 値を 2 乗した値を返す &lt;code>square&lt;/code> メソッドを &lt;code>Int&lt;/code> 型に追加しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">Int&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">square&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">this&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="k">this&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">20.&lt;/span>&lt;span class="n">square&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//=&amp;gt; 400
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="拡張関数をパッケージ化する">拡張関数をパッケージ化する&lt;/h2>
&lt;p>あるパッケージ内で定義された拡張関数は、パッケージのトップレベルに定義された関数と同様にインポートできます。
例えば、下記のように &lt;code>com.example.ext.strings&lt;/code> パッケージで &lt;code>String&lt;/code> クラスの拡張関数が定義されているとします。&lt;/p></description></item><item><title>Kotlinメモ: 配列やコレクションの要素をループ処理する (for-in, forEach, withIndex)</title><link>https://maku77.github.io/p/9byrmzs/</link><pubDate>Wed, 08 May 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9byrmzs/</guid><description>&lt;h2 id="配列やリストをループ処理する-for-foreach">配列やリストをループ処理する (for, forEach)&lt;/h2>
&lt;p>配列やコレクションに格納された要素は、&lt;strong>&lt;code>for&lt;/code>&lt;/strong> や &lt;strong>&lt;code>forEach&lt;/code>&lt;/strong> を使ってループ処理することができます。
下記の例では配列の要素を &lt;code>for&lt;/code> ループで処理しています。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">for を使う方法&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">elem&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">elem&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>配列やコレクション系のクラスには &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/for-each.html">forEach 拡張関数&lt;/a> が定義されているため、&lt;code>for&lt;/code> の代わりに &lt;code>forEach&lt;/code> メソッドを呼び出す形でループ処理することもできます。
ループ処理の内容はラムダ式の形 &lt;code>{ elem -&amp;gt; ... }&lt;/code> で渡します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">forEach を使う方法&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">elem&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">elem&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>ループ処理中の要素名（イテレータ）を省略した場合は、&lt;strong>&lt;code>it&lt;/code>&lt;/strong> で参照できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="インデックス付きでループ処理する-withindex">インデックス付きでループ処理する (withIndex)&lt;/h2>
&lt;p>Kotlin には Java や C/C++ のような &lt;code>for (int i = 0; i &amp;lt; n; ++i)&lt;/code> という形式の &lt;code>for&lt;/code> ループは存在しません。
配列やリストの要素をインデックス付き (0, 1, 2, &amp;hellip;) でループ処理するには、&lt;strong>&lt;code>withIndex()&lt;/code>&lt;/strong> と組み合わせて下記のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">arr&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;AAA&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;BBB&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;CCC&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">index&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">elem&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">withIndex&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;arr[&lt;/span>&lt;span class="si">$index&lt;/span>&lt;span class="s2">] = &lt;/span>&lt;span class="si">$elem&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">実行結果&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">arr[0] = AAA
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">arr[1] = BBB
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">arr[2] = CCC&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="マップ要素をループ処理する">マップ要素をループ処理する&lt;/h2>
&lt;p>マップのキーと値も &lt;code>for&lt;/code> を使ってループ処理することができます。&lt;/p></description></item><item><title>Kotlinメモ: Kotlin のパッケージの扱い方を理解する</title><link>https://maku77.github.io/p/u8mz82t/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/u8mz82t/</guid><description>&lt;p>Kotlin のパッケージの仕組みは、Java とは下記のような点で異なっています。&lt;/p>
&lt;ul>
&lt;li>クラスが所属するパッケージはファイル先頭の &lt;code>package&lt;/code> 宣言によってのみ決まる&lt;/li>
&lt;li>&lt;code>.kt&lt;/code> ファイル内に複数の public クラスを定義できる&lt;/li>
&lt;li>&lt;code>.kt&lt;/code> ファイルのファイル名はクラス名に合わせる必要はない&lt;/li>
&lt;li>パッケージ階層とディレクトリ階層を合わせて &lt;code>.kt&lt;/code> ファイルを配置する必要はない&lt;/li>
&lt;li>パッケージのトップレベルに関数やプロパティを定義することができる&lt;/li>
&lt;/ul>
&lt;p>つまり、&lt;strong>&lt;code>package&lt;/code> 宣言でパッケージ定義すること以外はほとんど自由&lt;/strong>です。&lt;/p>
&lt;p>下記のように実装した &lt;code>main.kt&lt;/code> ファイルは、&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">package&lt;/span> &lt;span class="nn">com.example&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java の慣例に従って、&lt;code>com/example/main.kt&lt;/code> というディレクトリ階層に配置しても、プロジェクトのルートに &lt;code>main.kt&lt;/code> として配置しても構いません。
Kotlin のコンパイラが意識するのは、コード内に記述した &lt;code>package&lt;/code> 宣言だけです。
とはいえ、できるだけパッケージ階層とディレクトリ階層は合わせておいた方が管理しやすいと思います。&lt;/p>
&lt;p>下記のように、同じ &lt;code>.kt&lt;/code> ファイル内のトップレベルに、&lt;strong>複数の public なクラスを定義&lt;/strong>することもできます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">hogegege.kt&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">package&lt;/span> &lt;span class="nn">com.example&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Foo&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Bar&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>これらのクラスを参照するときは、Java と同様、次のようにインポートして使用します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">main.kt&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">import&lt;/span> &lt;span class="nn">com.example.Foo&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">import&lt;/span> &lt;span class="nn">com.example.Bar&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">foo&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Foo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">bar&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Bar&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>このようにインポートできる &lt;code>Foo&lt;/code> クラス、&lt;code>Bar&lt;/code> クラスが存在している場合、Java では必ず &lt;code>Foo.java&lt;/code> ファイルと &lt;code>Bar.java&lt;/code> ファイルが存在しますが、Kotlin の場合は必ずしも &lt;code>Foo.kt&lt;/code>、&lt;code>Bar.kt&lt;/code> という名前のファイルが存在しているとは限りません。&lt;/p>
&lt;p>上記の例では、&lt;code>hogegege.kt&lt;/code> というふざけた名前のファイルで &lt;code>Foo&lt;/code> クラスと &lt;code>Bar&lt;/code> クラスを定義していますが、利用する側にとってはこのファイル名を意識する必要はないので、&lt;strong>つまり &lt;code>.kt&lt;/code> のファイル名は何でもよい&lt;/strong>のです（正確には、Java コードから参照する場合はファイル名を意識する必要があります）。&lt;/p></description></item><item><title>Kotlinメモ: あるインスタンスがどのクラスのオブジェクトなのか調べる (javaClass)</title><link>https://maku77.github.io/p/tc9c9z8/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/tc9c9z8/</guid><description>&lt;p>Kotlin のあるインスタンスが、どのクラスのインスタンスかを調べるには、&lt;strong>&lt;code>javaClass&lt;/code>&lt;/strong> プロパティを使用します（Java の &lt;code>Object#getClass()&lt;/code> に相当します）。&lt;/p>
&lt;p>下記の例では、コレクション系のオブジェクトが、どのクラスのインスタンスなのかを調べています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">array&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">arrayList&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayListOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;C&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">hashSet&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">hashSetOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;C&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">hashMap&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">hashMapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class [Ljava.lang.Integer;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.util.Arrays$ArrayList
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arrayList&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.util.ArrayList
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.util.LinkedHashSet
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hashSet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.util.HashSet
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.util.LinkedHashMap
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hashMap&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.util.HashMap
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この結果から、Kotlin のコレクション系クラスには Java の実装が用いられていることがわかります。&lt;/p>
&lt;p>ちなみに、&lt;code>javaClass&lt;/code> によって得られるインスタンスは、すべて &lt;code>java.lang.Class&lt;/code> のインスタンスです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">javaClass&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.lang.Class
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インスタンスではなく、クラスの型から &lt;code>java.lang.Class&lt;/code> オブジェクトを取得するには、&lt;strong>&lt;code>Class名::class.java&lt;/code>&lt;/strong> のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ArrayList&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; class java.lang.ArrayList
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: コレクションの最初・最後の要素を取得する (first, last)</title><link>https://maku77.github.io/p/swvgt89/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/swvgt89/</guid><description>&lt;h2 id="先頭要素を取得する-first">先頭要素を取得する (first)&lt;/h2>
&lt;p>Kotlin で配列やコレクションの先頭要素を取得するには、&lt;strong>&lt;code>first()&lt;/code>&lt;/strong> 拡張関数を使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">array&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">arrayOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//=&amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//=&amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//=&amp;gt; 1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列あるいは Iterable なコレクションでなければいけないので、&lt;code>Map&lt;/code> オブジェクトでは使用できません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">// NG
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">keys&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">// これなら OK
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>first()&lt;/code> のパラメータに条件式を渡すと、&lt;strong>最初にその条件に一致する値&lt;/strong>を取り出すことができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">例: 最初の偶数を見つける&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">({&lt;/span> &lt;span class="k">it&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="p">}))&lt;/span> &lt;span class="c1">//=&amp;gt; 4&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>Kotlinメモ: コレクション内の最小・最大の値を見つける (min, max, minBy, maxBy)</title><link>https://maku77.github.io/p/kqpvcpj/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/kqpvcpj/</guid><description>&lt;h2 id="リスト内の最小値最大値を見つける">リスト内の最小値、最大値を見つける&lt;/h2>
&lt;p>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/min.html">min 関数&lt;/a> および &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/max.html">max 関数&lt;/a> を使用すると、配列やコレクション（map を除く）の中から、最小値を持つ要素、最大値を持つ要素を取り出すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;min = &lt;/span>&lt;span class="si">${list.min()}&lt;/span>&lt;span class="s2">, max = &lt;/span>&lt;span class="si">${list.max()}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; min = 1, max = 5
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="comparable-な要素であれば-min-max-で取り出せる">Comparable な要素であれば min(), max() で取り出せる&lt;/h2>
&lt;p>配列やコレクションから &lt;code>min&lt;/code>/&lt;code>max&lt;/code> 関数で要素を取り出すには、要素の比較方法が明確になっている必要があります。
もちろん数値の要素であれば問題なく &lt;code>min&lt;/code>/&lt;code>max&lt;/code> 関数で取り出せますが、それ以外のオブジェクトでも &lt;strong>&lt;code>Comparable&lt;/code>&lt;/strong> インタフェースさえ実装していれば、&lt;code>min&lt;/code>/&lt;code>max&lt;/code> 関数で取り出せるようになります。&lt;/p>
&lt;p>下記の &lt;code>Book&lt;/code> クラスは、&lt;code>Comparable&lt;/code> インタフェースを実装しているため、コレクションに格納した後で、&lt;code>min&lt;/code>/&lt;code>max&lt;/code> 関数で取り出すことができます。
ここでは、&lt;code>price&lt;/code> プロパティの値で大小関係を判定するように実装しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">price&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Comparable&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Book&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">compareTo&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">books&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title1&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">500&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">300&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title3&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">100&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">books&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">min&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Title3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">books&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">?.&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Title1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="比較するプロパティをその都度指定する-minby-maxby">比較するプロパティをその都度指定する (minBy, maxBy)&lt;/h2>
&lt;p>&lt;code>min&lt;/code>/&lt;code>max&lt;/code> 関数の代わりに、&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/min-by.html">minBy&lt;/a>/&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/max-by.html">maxBy&lt;/a> 関数を使用すると、関数の呼び出し時に&lt;strong>ラムダ式で比較する値を指定&lt;/strong>することができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">例: price プロパティが最小のものを取り出す&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">cheapestBook&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">books&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">minBy&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">price&lt;/span> &lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>minBy&lt;/code>/&lt;code>maxBy&lt;/code> 関数を使用すると、&lt;code>Comparable&lt;/code> でない要素を含むコレクションから（あるプロパティが）最小・最大である要素を取り出すことができます。
また、呼び出し時に比較に使用するプロパティを指定できるので、必要に応じて参照するプロパティを変えて最小値・最大値を取り出すことができます。&lt;/p>
&lt;p>下記の例では、&lt;code>Book&lt;/code> 要素を含むリストから、&lt;code>price&lt;/code> プロパティが最小・最大の要素を取り出しています。
ここで定義している &lt;code>Book&lt;/code> クラスは &lt;code>Comparable&lt;/code> を実装していないので、&lt;code>minBy&lt;/code>/&lt;code>maxBy&lt;/code> を使い、比較に使用するプロパティをラムダ式で指定しています。&lt;/p></description></item><item><title>Kotlinメモ: パッケージのトップレベルに関数、プロパティ、定数を定義する</title><link>https://maku77.github.io/p/xgn46vo/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/xgn46vo/</guid><description>&lt;h2 id="トップレベル関数を定義する">トップレベル関数を定義する&lt;/h2>
&lt;p>Java ではパッケージのトップレベルに関数を定義することはできませんでした (あるクラスの static メソッドとして定義する必要がありました) が、Kotlin ではクラスの外に関数 (プロパティ、定数) を定義することができます。&lt;/p>
&lt;p>下記の例では、&lt;code>util.kt&lt;/code> のトップレベルで &lt;code>printError&lt;/code> 関数を定義し、それを &lt;code>main.kt&lt;/code> の中から利用しています。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">util.kt&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">package&lt;/span> &lt;span class="nn">com.example&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">printError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Error: &lt;/span>&lt;span class="si">$message&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>


&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">main.kt&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">import&lt;/span> &lt;span class="nn">com.example.printError&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ファイルが見つかりません&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>main.kt&lt;/code> からの参照方法を見ると分かるように、Kotlin では &lt;code>.kt&lt;/code> ファイルの名前は参照時に意識する必要はなく、あくまで&lt;strong>package により宣言されたパッケージ名だけが参照情報として必要&lt;/strong>になります。&lt;/p>
&lt;p>トップレベルに定義された関数をまとめてインポートしたいときは、下記のようなワイルドカードを使用できます。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">import&lt;/span> &lt;span class="nn">com.example.*&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="トップレベル関数を-private-にする">トップレベル関数を private にする&lt;/h2>
&lt;p>パッケージのトップレベルに定義した関数 (やプロパティ) は、デフォルトでは public になり、他の &lt;code>.kt&lt;/code> ファイルから参照できるようになっています。
可視性を自分のファイル内に限定したい場合は、&lt;strong>&lt;code>private&lt;/code>&lt;/strong> を付けて関数を定義します。&lt;/p>

&lt;figure class="xCodeBlock">

&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">package&lt;/span> &lt;span class="nn">com.example.util&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// これは他のファイルからも参照できる
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">fun&lt;/span> &lt;span class="nf">greet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// これはこのファイルからしか参照できない
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">private&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">getMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;Hello, &lt;/span>&lt;span class="si">$name&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;h2 id="java-からどう見えるか">Java からどう見えるか？&lt;/h2>
&lt;h3 id="kt-ファイル名から-java-のクラス名が生成される">kt ファイル名から Java のクラス名が生成される&lt;/h3>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">util.kt&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">package&lt;/span> &lt;span class="nn">com.example&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">printError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Error: &lt;/span>&lt;span class="si">$message&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記のように &lt;code>util.kt&lt;/code> ファイルの中で定義した &lt;code>com.example&lt;/code> パッケージの &lt;code>printError&lt;/code> 関数は、Java (JVM) の世界からは &lt;code>com.example.UtilKt.printError&lt;/code> のように見えます。
Java の世界ではすべてのメソッドは何らかのクラスに所属していなければいけないので、&lt;strong>&lt;code>util.kt&lt;/code> というファイル名から、自動的に &lt;code>UtilKt&lt;/code> という名前のクラスが生成される&lt;/strong>ようになっています。&lt;/p></description></item><item><title>Kotlinメモ: for ループと while ループ（そして forEach）</title><link>https://maku77.github.io/p/7gfaxun/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/7gfaxun/</guid><description>&lt;h2 id="while-ループ">while ループ&lt;/h2>
&lt;p>Kotlin の &lt;code>while&lt;/code> ループ、および &lt;code>do-while&lt;/code> ループは次のような形で使用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var&lt;/span> &lt;span class="py">i&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">var&lt;/span> &lt;span class="py">i&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>while&lt;/code> ループは、括弧の中の条件式が真 (true) である限りブロック内のコードを繰り返し実行します。
&lt;code>do-while&lt;/code> ループも同様ですが、少なくとも一回はブロック内のコードを実行します。&lt;/p>
&lt;p>Java と同様の構文なので、迷うことはないと思います。&lt;/p>
&lt;h2 id="for-ループ">for ループ&lt;/h2>
&lt;p>Java にはいわゆる C/C++ 形式のループ (&lt;code>for (int i=0; i&amp;lt;n; ++i)&lt;/code>) と、for-each 形式のループ (&lt;code>for (int i : arr)&lt;/code>) がありますが、Kotlin には &lt;strong>&lt;code>for (xxx in yyy)&lt;/code>&lt;/strong> の形の for ループしか存在しません。&lt;/p>
&lt;h3 id="数値範囲のループ-と-until">数値範囲のループ（&lt;code>..&lt;/code> と &lt;code>until&lt;/code>）&lt;/h3>
&lt;p>Kotlin では、&lt;strong>&lt;code>..&lt;/code> 演算子&lt;/strong> を使用すると、数値の連番を示すことができます。
これを利用して、ある数字からある数字までのループ処理を下記のように記述することができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">例: 1～5 のループ&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="m">1.&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Count: &lt;/span>&lt;span class="si">$i&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 1 2 3 4 5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>&lt;code>i in 1..n&lt;/code> というループは、&lt;code>n&lt;/code> で指定した数字まで処理されることに注意してください。
&lt;code>..&lt;/code> 演算子を使用する代わりに、&lt;strong>&lt;code>until&lt;/code>&lt;/strong> を使用して同様のループ処理を行うこともできます。
この場合、&lt;code>until&lt;/code> で指定した数値の 1 つ前の数値まで処理されます。&lt;/p></description></item><item><title>Kotlinメモ: immutable なコレクションと mutable なコレクション (List, Set, Map)</title><link>https://maku77.github.io/p/9557oxs/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/9557oxs/</guid><description>&lt;p>Kotlin で immutable なリストを生成するときは &lt;code>listOf&lt;/code>、mutable なリストを生成するときは &lt;code>mutableListOf&lt;/code> を使って生成していると思います。
ここでは、Kotlin がどのように immutable なリスト、mutable なリストを使い分けているかを説明します。
内部的な仕組みを知らなくてもあまり困ることはありませんが、全体像を把握しておくことで自信を持ってコレクション系の API を扱えるようになると思います。&lt;/p>
&lt;h2 id="collection-と-mutablecollection">Collection と MutableCollection&lt;/h2>
&lt;p>Kotlin のコレクション系オブジェクト（&lt;code>List&lt;/code>、&lt;code>Set&lt;/code>、&lt;code>Map&lt;/code> オブジェクトなど）にアクセスするときは、リードオンリーでアクセスするのか、編集用にアクセスするのかによってインタフェースが使い分けられます。
要素を参照するだけであれば、&lt;strong>&lt;code>Collection&lt;/code>&lt;/strong> インタフェースを使用し、要素の追加や削除が必要な場合は &lt;strong>&lt;code>MutableCollection&lt;/code>&lt;/strong> インタフェースを使用します。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-collection/index.html">kotlin.collections.Collection インタフェース&lt;/a>
&lt;ul>
&lt;li>&lt;code>size&lt;/code>、&lt;code>iterator&lt;/code>、&lt;code>contains&lt;/code> など、要素を参照するためのインタフェースのみを備える。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-collection/index.html">kotlin.collections.MutableCollection インタフェース&lt;/a>
&lt;ul>
&lt;li>&lt;code>Collection&lt;/code> インタフェースを継承したインタフェース。&lt;/li>
&lt;li>&lt;code>add&lt;/code>、&lt;code>remove&lt;/code>、&lt;code>clear&lt;/code> など、要素を追加・削除するためのインタフェースを備える。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>下記の &lt;code>addAll&lt;/code> 関数は、2 つのコレクションをパラメータで受け取りますが、1 つ目のパラメータ &lt;code>src&lt;/code> は参照用 (immutable) に使用され、2 つ目のパラメータ &lt;code>dst&lt;/code> は内部で変更される (mutable) ことを示しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * [src] のすべての要素を [dst] の末尾に追加します。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">addAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Collection&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;,&lt;/span> &lt;span class="n">dst&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">MutableCollection&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">src&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dst&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">src&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">300&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// リードオンリー
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">dst&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">MutableList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mutableListOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">400&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">500&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">600&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 編集可能
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">addAll&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dst&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">src&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [100, 200, 300]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dst&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [400, 500, 600, 100, 200, 300]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>リードオンリーな &lt;code>Collection&lt;/code> オブジェクトを &lt;code>MutableCollection&lt;/code> として渡そうとすると、Type mismatch のビルドエラーになります。&lt;/p></description></item><item><title>Kotlinメモ: ある値がコレクションに含まれているか調べる (in)</title><link>https://maku77.github.io/p/4ycigqq/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4ycigqq/</guid><description>&lt;p>Kotlin のコレクションに、特定の要素が含まれているかを調べるには &lt;strong>&lt;code>in&lt;/code>&lt;/strong> を使用します。
下記の例では、&lt;code>Set&amp;lt;String&amp;gt;&lt;/code> コレクションの中に特定の文字列 &lt;code>&amp;quot;banana&amp;quot;&lt;/code> が要素として含まれているかを調べています。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Set にある値が含まれているか&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">set&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">setOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;apple&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;banana&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;orange&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;banana&amp;#34;&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="k">set&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;バナナ発見！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>上記は &lt;code>Set&lt;/code> の例ですが、&lt;code>List&lt;/code> でも &lt;code>Map&lt;/code> でも同様に調べることができます。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">List にある値が含まれているか&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;apple&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;banana&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;orange&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;banana&amp;#34;&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;バナナ発見！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>


&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">Map にある値が含まれているか&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">map&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">mapOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;apple&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;banana&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;orange&amp;#34;&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;banana&amp;#34;&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;バナナ発見！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>ちょっと変わった例として、&lt;code>..&lt;/code> を使って定義した範囲の中に、ある値が含まれているかを調べるときにも &lt;code>in&lt;/code> を使うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">5&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="m">1.&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;1～10 の中にあるよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">ch&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="sc">&amp;#39;H&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ch&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="sc">&amp;#39;A&amp;#39;&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="sc">&amp;#39;Z&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A～Z の中にあるよ&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>in&lt;/code> の否定形の &lt;strong>&lt;code>!in&lt;/code>&lt;/strong> を使うと、配列やコレクションに、&lt;strong>指定した値が含まれていない&lt;/strong> ことを調べることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;lemon&amp;#34;&lt;/span> &lt;span class="o">!in&lt;/span> &lt;span class="n">fruits&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// レモンが含まれていない場合
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: インタフェースを定義する (interface)</title><link>https://maku77.github.io/p/ep23xid/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ep23xid/</guid><description>&lt;h2 id="インタフェースの基本">インタフェースの基本&lt;/h2>
&lt;p>Kotlin でのインタフェース定義は、Java と同様に &lt;strong>&lt;code>interface&lt;/code>&lt;/strong> キーワードを使用します。
下記の例では、&lt;code>Command&lt;/code> インタフェースを定義し、それを &lt;code>GreetCommand&lt;/code> クラスと &lt;code>ExplodeCommand&lt;/code> クラスが実装しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">GreetCommand&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hi, &lt;/span>&lt;span class="si">$name&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ExplodeCommand&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Boom!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">executeAllCommands&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">commands&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Command&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">commands&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">commands&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GreetCommand&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GreetCommand&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hemu&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ExplodeCommand&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">executeAllCommands&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">commands&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="実行結果">実行結果&lt;/h4>
&lt;pre tabindex="0">&lt;code>Hi, Maku
Hi, Hemu
Boom!
&lt;/code>&lt;/pre>&lt;p>インタフェースのメソッドはオーバーライドされることを前提としているため、&lt;code>fun&lt;/code> の前に &lt;code>open&lt;/code> を付ける必要はないことに注意してください。
&lt;strong>オーバーライドする側のメソッドには &lt;code>override&lt;/code> を付ける&lt;/strong>必要があります（Java のような &lt;code>@Override&lt;/code> アノテーションは使いません）。&lt;/p>
&lt;h2 id="インタフェースの継承">インタフェースの継承&lt;/h2>
&lt;p>インタフェースは他のインタフェースを継承することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">UndoableCommand&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">undo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インタフェース（およびクラス）は、複数のインタフェースを継承（および実装）することができます。
下記の &lt;code>DrawCommand&lt;/code> クラスは、&lt;code>Command&lt;/code> インタフェースと &lt;code>Undoable&lt;/code> インタフェースを実装しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">Undoable&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">undo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">DrawCommand&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Command&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Undoable&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">undo&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あるオブジェクトが特定のインタフェースを継承しているかどうかを調べるには、&lt;strong>&lt;code>is&lt;/code>&lt;/strong> を使って、&lt;code>if (obj is InterfaceName)&lt;/code> のように記述します。
下記の例では、リストに含まれている要素が &lt;code>Number&lt;/code> であるかをひとつずつチェックしています。&lt;/p></description></item><item><title>Kotlinメモ: クラスを定義する (class)</title><link>https://maku77.github.io/p/4qqytis/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4qqytis/</guid><description>&lt;h2 id="クラス定義の基本">クラス定義の基本&lt;/h2>
&lt;p>Kotlin のクラス定義は Java と同様に &lt;strong>&lt;code>class&lt;/code>&lt;/strong> キーワードを使用しますが、&lt;strong>デフォルトで public final 扱い&lt;/strong>という違いがあります。
これは、多くのケースで &lt;code>public&lt;/code> の方が都合がよいことと、意図しない継承を防ぐことを意図した仕様です。&lt;/p>
&lt;ul>
&lt;li>デフォルトでは全クラスからアクセス可能 (public)&lt;/li>
&lt;li>デフォルトでは継承できない (final)&lt;/li>
&lt;/ul>
&lt;p>次の &lt;code>Book&lt;/code> クラスは、リードオンリーな &lt;code>title&lt;/code> プロパティ持つ、シンプルなクラスの実装例と使用例です。&lt;/p>
&lt;h4 id="リードオンリーなプロパティを持つクラス">リードオンリーなプロパティを持つクラス&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Title1
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>詳しくは後述しますが、Kotlin にはメソッドを簡潔に記述するための仕組みがたくさん用意されています。
メソッド実装などの記述が必要ない場合は、上記のようにクラス本体部分を示す &lt;code>{ }&lt;/code> ブロックすら省略して記述することができます。
Java とは異なり、コンストラクタを呼び出すときの &lt;code>new&lt;/code> キーワードも省略できます（というより &lt;code>new&lt;/code> は存在しません）。&lt;/p>
&lt;p>上記は &lt;code>title&lt;/code> プロパティをリードオンリー (&lt;code>val&lt;/code>) として定義していますが、プロパティの値を書き換え可能にするには、&lt;code>val&lt;/code> を &lt;code>var&lt;/code> に置き換えるだけで済みます。&lt;/p>
&lt;h4 id="書き換え可能なプロパティを持つクラス">書き換え可能なプロパティを持つクラス&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">var&lt;/span> &lt;span class="py">title&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Title1&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;Title2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Title2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のように &lt;code>b.title&lt;/code> という形で &lt;code>title&lt;/code> フィールドにアクセスできるのは、内部で getter/setter メソッドが定義されて呼び出されているからです。
&lt;code>title&lt;/code> フィールドそのものが &lt;code>public&lt;/code> になっているわけではなく、あくまで &lt;code>public&lt;/code> な getter/setter メソッドが暗黙的に呼び出されています。
この &lt;code>Book&lt;/code> クラスを Java のコードから使用する場合、&lt;code>title&lt;/code> フィールドへのアクセスは、&lt;code>b.getTitle()&lt;/code>、&lt;code>b.setTitle(&amp;quot;...&amp;quot;)&lt;/code> のように記述することになります。&lt;/p></description></item><item><title>Kotlinメモ: スマートキャストでキャストを自動化する</title><link>https://maku77.github.io/p/rk5dgjh/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/rk5dgjh/</guid><description>&lt;p>&lt;a href="../p/ep23xid/">インタフェースを定義する&lt;/a> でも説明されているように、あるオブジェクトが特定のインタフェースを持っているかを調べるには、&lt;code>obj is インタフェース名&lt;/code> というチェックを行います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">Command&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">executeIfPossible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Any&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">Command&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">obj&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java では、あるオブジェクトが特定のインタフェースを持っているかを調べた後に、さらにキャストを行わなければ、そのインタフェースのメソッドを呼び出すことはできませんでした。
Kotlin では、上記のように、&lt;code>is&lt;/code> による判定が true だったときは、その後ろのブロック内では明示的なキャストを省略することができます（型のチェックとキャストが同時に行われる）。
これを&lt;strong>スマートキャスト (smart cast)&lt;/strong> と呼びます。&lt;/p>
&lt;p>実際には、下記のような &lt;code>as&lt;/code> を使ったキャストが内部的に自動的に行われていることになります。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">冗長なキャスト&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">Command&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">cmd&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">Command&lt;/span> &lt;span class="c1">// これは必要ない
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">cmd&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">execute&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>スマートキャストは、&lt;code>||&lt;/code> や &lt;code>&amp;amp;&amp;amp;&lt;/code> を使った際にも適用されます。
下記の 2 つの例はいずれも想定通り動作します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">length&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">!is&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">isEmpty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>スマートキャストは、&lt;code>when&lt;/code> 式の中でも使用することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">doTrick&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">animal&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Animal&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">animal&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">is&lt;/span> &lt;span class="n">Bird&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">animal&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fly&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// Bird のメソッドを呼び出し
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="n">Dog&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">animal&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">bark&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// Dog のメソッドを呼び出し
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Unknown animal&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>特定の型にしか適用できない演算子を使用する場合にも、スマートキャストを適用できます。
下記の例では、リスト要素の中の &lt;code>Int&lt;/code> 要素を見つけて、&lt;code>+&lt;/code> 演算子で足し合わせています。
&lt;code>Any&lt;/code> 型（Java でいう &lt;code>Object&lt;/code>）のままでは &lt;code>+&lt;/code> 演算子は適用できませんが、&lt;code>Int&lt;/code> へのスマートキャストにより足し合わせることができるようになっています。&lt;/p></description></item><item><title>Kotlinメモ: 例外処理を記述する (try, catch, finally)</title><link>https://maku77.github.io/p/bvu8qmi/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/bvu8qmi/</guid><description>&lt;h2 id="例外の基本">例外の基本&lt;/h2>
&lt;p>Kotlin の例外処理には、Java と同様の &lt;strong>&lt;code>try&lt;/code>&lt;/strong>、&lt;strong>&lt;code>catch&lt;/code>&lt;/strong>、&lt;strong>&lt;code>finally&lt;/code>&lt;/strong> キーワードを使用します。&lt;/p>
&lt;p>下記は、&lt;code>NumberFormatException&lt;/code> 例外を捕捉する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;xyz&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toInt&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">NumberFormatException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例外のスローも Java と同様に &lt;strong>&lt;code>throw&lt;/code>&lt;/strong> を使って行います。
クラスのインスタンスを生成するときに &lt;code>new&lt;/code> が必要なかったように、ここでも &lt;code>new&lt;/code> は必要ありません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">fibonacci&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="n">IllegalArgumentException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;負の値は指定できません&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="例外の捕捉は必須ではない">例外の捕捉は必須ではない&lt;/h2>
&lt;p>Java では、&lt;code>IOException&lt;/code> などの検査例外 (checked exception) を投げるメソッドを呼び出すメソッドは、必ず &lt;code>catch&lt;/code> で例外を捕捉するか、自分自身のメソッドで &lt;code>throws IOException&lt;/code> と宣言しておく必要がありました。
Kotlin では、&lt;strong>検査例外 (checked exception) と非検査例外 (unchecked exception) を区別しない&lt;/strong> ので、メソッドに &lt;code>throws IOException&lt;/code> の宣言が必要ありません。
スローされた例外を捕捉するもしないも呼び出し側の自由です。
捕捉されなかった例外は、呼び出し元のメソッドに伝搬されていきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">throwIoException&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">throw&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;読み込みエラーだよ！&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// IOException をスローするメソッドを呼び出しているけど、
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// この foo メソッドでは throws 宣言をしなくてもよい。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">throwIoException&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">foo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="try-を式として扱う">try を式として扱う&lt;/h2>
&lt;p>Kotlin では、&lt;code>try&lt;/code> も式です。
&lt;code>try&lt;/code> のブロックの中で評価された値を、そのまま変数で受け取ったり、関数の戻り値として返したりすることができます。&lt;/p></description></item><item><title>Kotlinメモ: 列挙型を定義する (enum)</title><link>https://maku77.github.io/p/st6xako/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/st6xako/</guid><description>&lt;h2 id="列挙型の基本-enum-class">列挙型の基本 (enum class)&lt;/h2>
&lt;p>Kotlin の列挙型はクラスの一種であり（Java もそうですが）、&lt;code>class&lt;/code> キーワードの前に &lt;strong>&lt;code>enum&lt;/code>&lt;/strong> を付けることで定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Fruits&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">APPLE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BANANA&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GRAPE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">fruit&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">APPLE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fruit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; APPLE
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>when&lt;/code> 式による分岐で使用するのが典型的な使用例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">getColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fruit&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Fruits&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fruit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">APPLE&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;red&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">BANANA&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;yellow&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GRAPE&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;purple&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">f&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">APPLE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$f&lt;/span>&lt;span class="s2"> is &lt;/span>&lt;span class="si">${getColor(f)}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; APPLE is red
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>when&lt;/code> 式の分岐において、すべての列挙値を網羅していない場合は、必ず &lt;strong>&lt;code>else&lt;/code>&lt;/strong> 分岐を含める必要があります（Java の &lt;code>switch&lt;/code> における &lt;code>default&lt;/code> のようなもの）。
書き忘れた場合はコンパイルエラーになるのですぐに気づくことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">getColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fruit&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Fruits&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">fruit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">APPLE&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;red&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="k">throw&lt;/span> &lt;span class="n">Exception&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Unknown fruit&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="列挙型にプロパティやメソッドを追加する">列挙型にプロパティやメソッドを追加する&lt;/h2>
&lt;p>列挙型もクラスの一種なので、プロパティやメソッドを持つことができます（これも Java と同様です）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">label&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">APPLE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;リンゴ&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;赤色&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BANANA&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;バナナ&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;黄色&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GRAPE&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;ぶどう&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;紫色&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// Kotlin で唯一セミコロンが必要な場所
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">toString&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$label&lt;/span>&lt;span class="s2"> は &lt;/span>&lt;span class="si">$color&lt;/span>&lt;span class="s2"> です&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">f&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">Fruits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">APPLE&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">label&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;リンゴ&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;赤色&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;リンゴ は 赤色 です&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="列挙型を-by-name-でインポートする">列挙型を by name でインポートする&lt;/h2>
&lt;p>下記のように特定のパッケージに定義された列挙型があるとします。&lt;/p></description></item><item><title>Kotlinメモ: 文字列と数値を変換する (toIntOrNull, toInt)</title><link>https://maku77.github.io/p/cdxns9p/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/cdxns9p/</guid><description>&lt;h2 id="文字列-string--数値-int">文字列 (String) → 数値 (Int)&lt;/h2>
&lt;h3 id="tointornull">&lt;code>toIntOrNull()&lt;/code>&lt;/h3>
&lt;p>Kotlin は &lt;code>String&lt;/code> クラスに &lt;strong>&lt;code>toIntOrNull()&lt;/code>&lt;/strong> 拡張関数を定義しており、これを使うと任意の文字列を数値型 (Int) に変換することができます。
その名の通り、変換できない文字列の場合は &lt;code>null&lt;/code> を返します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">num1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;100&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toIntOrNull&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; 100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">num2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;xyz&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toIntOrNull&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">//=&amp;gt; null
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>String#toIntOrNull()&lt;/code> のパラメータには基数 (radix) を指定することができるため、下記のように2進数表記や16進数表記の文字列をパースすることもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">num1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;10000000&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toIntOrNull&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 128
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">num2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;FFFF&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toIntOrNull&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; 65535
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">num3&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0xFFFF&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toIntOrNull&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; null
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の結果からもわかるように、16進数表記の文字列にプレフィックスとして &lt;code>0x&lt;/code> が付いていると、&lt;code>toIntOrNull()&lt;/code> は &lt;code>null&lt;/code> を返すということに注意してください。&lt;/p>
&lt;h3 id="toint">&lt;code>toInt()&lt;/code>&lt;/h3>
&lt;p>似たようなメソッドに &lt;strong>&lt;code>String#toInt()&lt;/code>&lt;/strong> がありますが、こちらはパースに失敗したときに &lt;code>null&lt;/code> を返すのではなく、&lt;code>NumberFormatException&lt;/code> を投げます。
必要に応じて使い分けましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;xyz&amp;#34;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toInt&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">ex&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">NumberFormatException&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">err&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ex&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="数値-int--文字列-string">数値 (Int) → 文字列 (String)&lt;/h2>
&lt;p>&lt;strong>&lt;code>Int.toString(radix)&lt;/code>&lt;/strong> を使用すると、数値 (Int) を任意の基数の文字列表現に変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">num&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">255&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;11111111&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">8&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;377&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;ff&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java の &lt;code>Integer&lt;/code> クラスにある &lt;code>toBinaryString&lt;/code>、&lt;code>toOctalString&lt;/code>、&lt;code>toHexString&lt;/code> と同様に使用することができますが、負の値を指定したときには結果が変わってくることに注意してください。&lt;/p></description></item><item><title>Kotlinメモ: 文字列リテラルの中で変数や式を展開する（文字列テンプレート）</title><link>https://maku77.github.io/p/n3mn3og/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/n3mn3og/</guid><description>&lt;p>文字列リテラルの中で &lt;strong>&lt;code>&amp;quot;$変数名&amp;quot;&lt;/code>&lt;/strong> や &lt;strong>&lt;code>&amp;quot;${式}&amp;quot;&lt;/code>&lt;/strong> のように記述すると、変数の値や式の評価結果を文字列内に展開することができます。
この仕組みを &lt;strong>文字列テンプレート (string template)&lt;/strong> といいます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello, &lt;/span>&lt;span class="si">$name&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; Hello, Maku!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>&amp;quot;${式}&amp;quot;&lt;/code> の記述方法を利用すると、文字列テンプレートの中で関数呼び出しなどを行うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;You are &lt;/span>&lt;span class="si">${p.age}&lt;/span>&lt;span class="s2"> years old.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// getAge() の呼び出し
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、あまり複雑な式を書こうとすると読みにくくなってしまうので、ほどほどに。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">やりすぎな例&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hi, &lt;/span>&lt;span class="si">${if (args.isEmpty()) &amp;#34;anonymous&amp;#34; else args[0]}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure></description></item><item><title>Kotlinメモ: 配列やリストから null 以外の要素のみを抽出する (filterNotNull, mapNotNull)</title><link>https://maku77.github.io/p/wz5cnqq/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wz5cnqq/</guid><description>&lt;h2 id="filternotnull-関数による-null-要素の削除">filterNotNull 関数による null 要素の削除&lt;/h2>
&lt;p>Kotlin の &lt;a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-not-null.html">filterNotNull 関数&lt;/a> を使用すると、&lt;code>null&lt;/code> 要素の混じった配列やリストから、&lt;code>null&lt;/code> 以外の要素だけを抽出することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">300&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">list1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filterNotNull&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [100, null, 200, null, 300]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; [100, 200, 300]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下記のように記述するのとほぼ同様ですが、&lt;strong>&lt;code>filterNotNull&lt;/code> を使うと戻り値の型が少し変わります&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">list1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filter&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="k">null&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>filterNotNull&lt;/code> 関数の定義を見てみてください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">T&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="nc">Any&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="k">out&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">?&amp;gt;.&lt;/span>&lt;span class="n">filterNotNull&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">T&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="nc">Any&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">Iterable&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">?&amp;gt;.&lt;/span>&lt;span class="n">filterNotNull&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>戻り値の &lt;code>List&lt;/code> が保持する要素の型が &lt;code>T?&lt;/code> から &lt;code>T&lt;/code> に変わっており、&lt;strong>もはや Nullable ではありません&lt;/strong>。
最初に挙げた例を、冗長に型付きで記述すると下記のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list1&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">?&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">listOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">200&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">null&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">300&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">list2&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">list1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filterNotNull&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>null&lt;/code> を排除した &lt;code>List&amp;lt;Int&amp;gt;&lt;/code> に変換した後は、&lt;code>sum()&lt;/code> や &lt;code>average()&lt;/code> などの計算用関数を null チェックなしで思う存分呼び出せます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">showValidNumberStats&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">numbers&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">?&amp;gt;)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">validNumbers&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">numbers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">filterNotNull&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Sum: &lt;/span>&lt;span class="si">${validNumbers.sum()}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Avg: &lt;/span>&lt;span class="si">${validNumbers.average()}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mapnotnull-関数map-と-filternotnull-の一括処理">mapNotNull 関数（map と filterNotNull の一括処理）&lt;/h2>
&lt;p>コレクションの要素を &lt;code>map&lt;/code> 関数で変換し、その結果から &lt;code>null&lt;/code> 要素を取り除くという処理を行う場合、単純に考えると &lt;code>map&lt;/code> → &lt;code>filterNotNull&lt;/code> と順番に実行することになります。
次の例では、&lt;code>pages&lt;/code> コレクションから &lt;code>category&lt;/code> プロパティの値を収集し、&lt;code>null&lt;/code> 値を取り除いています。&lt;/p></description></item><item><title>Kotlinメモ: Kotlin のコードにドキュメンテーションコメントを記述する (KDoc)</title><link>https://maku77.github.io/p/wjgs3fp/</link><pubDate>Tue, 05 Mar 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/wjgs3fp/</guid><description>&lt;h2 id="ドキュメンテーションコメントとは">ドキュメンテーションコメントとは&lt;/h2>
&lt;p>Kotlin のソースコードにドキュメンテーションコメントを記述しておくと、関数のコメントなどから API ドキュメントを自動生成することができるようになります。
また、関数のドキュメンテーションコメントを記述しておけば、AndroidStudio などの開発環境上でコーディングしているときに、関数の説明をポップアップ表示してくれるようになります。&lt;/p>
&lt;p>Java のドキュメンテーションコメントのフォーマットは Javadoc と呼ばれていますが、Kotlin のドキュメンテーションコメントは &lt;strong>KDoc&lt;/strong> と呼びます。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kotlinlang.org/docs/reference/kotlin-doc.html">KDoc - Documenting Kotlin Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>多人数で使用するライブラリを作成する場合は API ドキュメントを用意するのは必須です。
一人で開発する場合でも、API の仕様を明確にして実装する癖をつけることで、自然にきれいな設計を行う力が身に付きます。
ドキュメンテーションコメントに関する基本的な考え方は下記を参照してください。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="../memo/how-to-write-comment.html">ドキュメンテーションコメントの書き方&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="javadoc-コメントと-kdoc-コメントの違い">Javadoc コメントと KDoc コメントの違い&lt;/h2>
&lt;p>KDoc ドキュメンテーションコメントは、Javadoc と同様に &lt;strong>&lt;code>/**&lt;/code>&lt;/strong> で始め &lt;strong>&lt;code>*/&lt;/code>&lt;/strong> で終わります。&lt;/p>
&lt;p>&lt;strong>&lt;code>@タグ名&lt;/code>&lt;/strong> の形で付加的な情報を記述できることも同様ですが、KDoc のみで使用できるタグや、逆に KDoc では使えないタグもあります（後述）。&lt;/p>
&lt;p>Javadoc コメント内では HTML タグを使った修飾が可能でしたが、KDoc コメントでは代わりに &lt;a href="https://daringfireball.net/projects/markdown/basics">Markdown&lt;/a> を使用します。&lt;/p>
&lt;p>下記は、Kotlin のドキュメントサイトで紹介されている KDoc コメントの記述例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * A group of *members*.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * This class has no useful logic; it&amp;#39;s just a documentation example.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @param T the type of a member in this group.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @property name the name of this group.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @constructor Creates an empty group.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Group&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Adds a [member] to this group.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * @return the new size of the group.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">member&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="o">..&lt;/span>&lt;span class="p">.&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="kdoc-ドキュメンテーションコメントの書き方">KDoc ドキュメンテーションコメントの書き方&lt;/h2>
&lt;h3 id="パラメータに関する記述">パラメータに関する記述&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> * Sums two values, [a] and [b].
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">myAdd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KDoc のドキュメンテーションコメントから関数のパラメータを参照するときは、上記のようにパラメータ名をブラケット &lt;code>[]&lt;/code> で囲みます。&lt;/p></description></item><item><title>Kotlinメモ: when 式による条件分岐</title><link>https://maku77.github.io/p/v2ezcum/</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/v2ezcum/</guid><description>&lt;h2 id="when-式の基本">when 式の基本&lt;/h2>
&lt;p>Kotlin の &lt;strong>&lt;code>when&lt;/code>&lt;/strong> 式は、Java の &lt;code>switch&lt;/code> 文に相当するものです。
Java の &lt;code>switch&lt;/code> は、列挙型、文字列、数値しか扱えませんが、Kotlin の &lt;code>when&lt;/code> では任意のオブジェクトで分岐を行うことができます。&lt;/p>
&lt;p>ポイントは式 (expression) であるというところで、条件分岐後の評価結果をそのまま変数に代入したり、関数の戻り値として使うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">n&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">str&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">1&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">2&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;other&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">str&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; one
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java とは異なり、分岐後の処理は fall through されないので、&lt;code>break&lt;/code> 文は不要です。
デフォルトで、値が一致した部分のコードのみが実行されるようになっています。&lt;/p>
&lt;p>分岐後の処理を複数行にわたって記述したい場合は、次のように矢印 (&lt;code>-&amp;gt;&lt;/code>) の右側を括弧 &lt;code>{&lt;/code> &lt;code>}&lt;/code> で囲んでブロックを作ります。
ブロックの中で最後に評価された式の値が、&lt;code>when&lt;/code> 式全体の評価結果として使われます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">1&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;one&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exec_one&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="m">2&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;two&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exec_two&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;other&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exec_other&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="列挙型の値で-when-分岐">列挙型の値で when 分岐&lt;/h2>
&lt;p>列挙型の値により &lt;code>when&lt;/code> 分岐させる場合は、すべての項目を網羅するように記述するか、&lt;code>else&lt;/code> でその他のケースをまとめて処理するように記述する必要があります（どちらかを満たさないとコンパイルエラーになります）。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">例: Color.WHITE がカバーされていないのでコンパイルエラー&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">enum&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Color&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">RED&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">GREEN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">BLUE&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">WHITE&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">getRgbStr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Color&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">when&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">RED&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;#FF0000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GREEN&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;#00FF00&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">Color&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">BLUE&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="s2">&amp;#34;#0000FF&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>複数の値で同じ処理を実行したい場合は、次のようにカンマで値を列挙します。&lt;/p></description></item><item><title>Kotlinメモ: 基本的な型の一覧</title><link>https://maku77.github.io/p/hqup7mp/</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/hqup7mp/</guid><description>&lt;p>Kotlin には、Java のプリミティブ型に相当する &lt;code>int&lt;/code> や &lt;code>boolean&lt;/code> といった型は存在せず、すべてがオブジェクトです。
例えば、32 ビット整数を扱いたい場合は、一貫して &lt;code>Int&lt;/code> と記述すればよく、Java のように &lt;code>int&lt;/code> と &lt;code>Integer&lt;/code> を使い分ける必要はありません（内部で必要に応じて Java の &lt;code>int&lt;/code> や &lt;code>Integer&lt;/code> 相当のものとして扱われます）。&lt;/p>
&lt;ul>
&lt;li>数値型
&lt;ul>
&lt;li>&lt;strong>&lt;code>Byte&lt;/code>&lt;/strong> &amp;hellip; 8ビット整数&lt;/li>
&lt;li>&lt;strong>&lt;code>Short&lt;/code>&lt;/strong> &amp;hellip; 16ビット整数&lt;/li>
&lt;li>&lt;strong>&lt;code>Int&lt;/code>&lt;/strong> &amp;hellip; 32ビット整数&lt;/li>
&lt;li>&lt;strong>&lt;code>Long&lt;/code>&lt;/strong> &amp;hellip; 64ビット整数&lt;/li>
&lt;li>&lt;strong>&lt;code>Float&lt;/code>&lt;/strong> &amp;hellip; 32ビット浮動小数点数&lt;/li>
&lt;li>&lt;strong>&lt;code>Double&lt;/code>&lt;/strong> &amp;hellip; 64ビット浮動小数点数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>文字、文字列
&lt;ul>
&lt;li>&lt;strong>&lt;code>Char&lt;/code>&lt;/strong> &amp;hellip; 文字&lt;/li>
&lt;li>&lt;strong>&lt;code>String&lt;/code>&lt;/strong> &amp;hellip; 文字列&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>論理型
&lt;ul>
&lt;li>&lt;strong>&lt;code>Boolean&lt;/code>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>列挙型
&lt;ul>
&lt;li>&lt;strong>&lt;code>enum class&lt;/code>&lt;/strong> で定義&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>特殊型
&lt;ul>
&lt;li>&lt;strong>&lt;code>Any&lt;/code>&lt;/strong> &amp;hellip; Java の &lt;code>Object&lt;/code> に相当。すべてのクラスのスーパークラスです（正確には Null 許容型のスーパークラスは &lt;code>Any&lt;/code> ではなく &lt;code>Any?&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>&lt;code>Unit&lt;/code>&lt;/strong> &amp;hellip; Java の &lt;code>void&lt;/code> に相当。意味を持たない値を表現します。&lt;code>Any&lt;/code> は &lt;code>Unit&lt;/code> のスーパークラスでもあります。&lt;/li>
&lt;li>&lt;strong>&lt;code>Nothing&lt;/code>&lt;/strong> &amp;hellip; インスタンスが存在しないことを表現します。ある関数の戻り値が &lt;code>Nothing&lt;/code> と定義されている場合、その関数から &lt;code>return&lt;/code> されることはないことを示しています（内部で無限ループしているとか、必ず例外を投げるとか）。&lt;code>Nothing&lt;/code> はすべてのクラスのサブクラスであるとされています。&lt;/li>
&lt;li>&lt;strong>&lt;code>プラットフォーム型&lt;/code>&lt;/strong> &amp;hellip; Java で定義された型で、&lt;code>@NonNull&lt;/code> や &lt;code>@Nullable&lt;/code> といったアノテートがされていないものです。Kotlin の言語仕様上は &lt;code>String!&lt;/code> のような &lt;code>!&lt;/code> 付きの型として表現され、Null 非許容型 (&lt;code>String&lt;/code>) と Null 許容型 (&lt;code>String?&lt;/code>) のどちらとして扱うかは実装者に委ねられています。Kotlin コード上で明示的に &lt;code>String!&lt;/code> と書くことはできません。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>下記は Kotlin で定義した変数が、Java のどの型に対応しているかを示しています。&lt;/p></description></item><item><title>Kotlinメモ: if による分岐処理と if 式</title><link>https://maku77.github.io/p/4t7x4k4/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/4t7x4k4/</guid><description>&lt;p>Kotlin の &lt;code>if-else&lt;/code> による分岐処理は、Java と同様の構文で記述することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">n&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">15&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;FizzBuzz&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Fizz&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="p">%&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Buzz&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java と異なるのは、Kotlin では &lt;code>if&lt;/code> は文 (statement) ではなく式 (expression) であるという点です。
&lt;code>if&lt;/code> 式を評価した結果は、そのまま変数に代入したり、関数の戻り値として使用することができます。
Java や C/C++ の三項演算子と同じ感覚で、下記のように使用することができます。&lt;/p>
&lt;h3 id="if-式の評価結果を変数に格納する">if 式の評価結果を変数に格納する&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">isOk&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">true&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">message&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">isOk&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="s2">&amp;#34;OK&amp;#34;&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="s2">&amp;#34;ERROR&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//=&amp;gt; &amp;#34;OK&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="if-式の評価結果を戻り値として使用する">if 式の評価結果を戻り値として使用する&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">getMessage&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">isOk&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Boolean&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">isOk&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="s2">&amp;#34;OK&amp;#34;&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="s2">&amp;#34;ERROR&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Kotlinメモ: 変数を定義する (val, var)</title><link>https://maku77.github.io/p/qzkfnsq/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/qzkfnsq/</guid><description>&lt;h2 id="変数の定義">変数の定義&lt;/h2>
&lt;p>Kotlin で変数を定義するには、&lt;strong>&lt;code>val&lt;/code>&lt;/strong> キーワード（あるいは &lt;strong>&lt;code>var&lt;/code>&lt;/strong> キーワード）を使用します。
変数定義時に値を初期化する場合は、コンパイラが型を判断してくれるので、多くの場合は型の記述を省略することができます（この機能を型推論［type inference］と言います）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">s&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span> &lt;span class="c1">//=&amp;gt; val s: String = &amp;#34;Hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">n&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">100&lt;/span> &lt;span class="c1">//=&amp;gt; val n: Int = 100
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">f&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">7.5&lt;/span>&lt;span class="n">e6&lt;/span> &lt;span class="c1">//=&amp;gt; val f: Double = 7.5e6 (= 7.5x10^6)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただし、変数の定義と同時に初期値を指定しない場合は、必ず型の指定が必要です。
型は、変数名の後ろに &lt;strong>&lt;code>: 型名&lt;/code>&lt;/strong> という形で指定します（Pascal や Scala、Swift などと同じ）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;Maku&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello, &lt;/span>&lt;span class="si">$name&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="val-と-var-の違い">val と var の違い&lt;/h2>
&lt;p>&lt;strong>&lt;code>val&lt;/code>&lt;/strong> と &lt;strong>&lt;code>var&lt;/code>&lt;/strong> の違いは、その変数に再代入が可能かどうかです。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>val&lt;/code>&lt;/strong>: 再代入できない参照を保持するための変数 (immutable reference)。Java の &lt;code>final&lt;/code> 変数に相当。value の略。&lt;/li>
&lt;li>&lt;strong>&lt;code>var&lt;/code>&lt;/strong>: 再代入可能な変数 (mutable reference)。variable の略。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">var&lt;/span> &lt;span class="py">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="c1">// NG (Val cannot be reassigned)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="c1">// OK
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使い分けの方針としては、変数を定義するときはまずは再代入できない &lt;code>val&lt;/code> を使用することを考え、必要なケースでのみ &lt;code>var&lt;/code> を使用するのがよいでしょう。
こうすることで、コードレビュー時などに変数の変化を追う必要性が下がるため、保守性が高くなります。&lt;/p></description></item><item><title>Kotlinメモ: 関数を定義する (fun)</title><link>https://maku77.github.io/p/ttacror/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/ttacror/</guid><description>&lt;h2 id="関数定義の基本">関数定義の基本&lt;/h2>
&lt;p>Kotlin で関数を定義するには &lt;strong>&lt;code>fun&lt;/code>&lt;/strong> キーワードを使用します。
Java ではすべてのメソッドは何らかのクラスに属す必要がありますが、Kotlin の場合はファイルのトップレベルに関数を定義することができます。&lt;/p>
&lt;p>次の例は、2 つの整数 (&lt;code>Int&lt;/code>) を受け取り、戻り値として整数 (&lt;code>Int&lt;/code>) を返す関数の定義例です。
パラメータの型はパラメータ名の後ろに記述します。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">関数の定義&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>Kotlin では、&lt;code>if&lt;/code> が式 (expression) 扱いになっているため、上記のように &lt;code>if&lt;/code> 式の評価結果をそのまま &lt;code>return&lt;/code> することができます。&lt;/p>
&lt;p>関数の呼び出し方法は Java と同様です。&lt;/p>

&lt;figure class="xCodeBlock">
&lt;figcaption class="xCodeBlock_title">関数の呼び出し&lt;/figcaption>
&lt;div class="xCodeBlock_code">&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">10&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1">//=&amp;gt; 10&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;/figure>

&lt;p>パラメータや戻り値のない関数は下記のように記述できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">greet&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>戻り値がないときは関数の型は上記のように省略できますが、&lt;code>: Unit&lt;/code> と明示することもできます（Java の &lt;code>void&lt;/code> に相当）。&lt;/p>
&lt;h2 id="expression-body">より短く関数を記述する (expression-body funtion)&lt;/h2>
&lt;p>下記のように &lt;code>{&lt;/code> と &lt;code>}&lt;/code> で囲まれた本文を持つ関数を、block body を持つ関数 &lt;strong>(block-body function)&lt;/strong> と呼びます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本文に 1 つの式 (expression) しか持たない場合、次のように &lt;strong>&lt;code>=&lt;/code>&lt;/strong> を使って短く記述することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">b&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように記述した関数を、expression body を持つ関数 &lt;strong>(expression-body function)&lt;/strong> と呼びます。
expression-body function の形で関数を定義する場合、Kotlin コンパイラの型推論 (type inference) 機能が働くため、多くのケースで上記のように関数の戻り値の型を省略することができます。&lt;/p></description></item><item><title>Kotlinメモ: Kotlin とは？ Kotlin をインストールする</title><link>https://maku77.github.io/p/5zibnsn/</link><pubDate>Mon, 07 Jan 2019 00:00:00 +0900</pubDate><guid>https://maku77.github.io/p/5zibnsn/</guid><description>&lt;h2 id="kotlin-の特徴">Kotlin の特徴&lt;/h2>
&lt;p>&lt;a href="https://kotlinlang.org/">Kotlin&lt;/a> は &lt;strong>Java との親和性を重視して作成されたコンパイル型の言語&lt;/strong>です。
IntelliJ IDEA の開発元である JetBrains 社によって作成された言語であり、強力な IDE のサポートがあります。&lt;/p>
&lt;p>2017年の Google I/O で、Google が Android における Kotlin の公式サポートを発表したため、言語としての知名度が一気に向上しました。&lt;/p>
&lt;p>Kotlin には次のような特徴があります。&lt;/p>
&lt;ul>
&lt;li>Kotlin のコンパイラ (kotlinc) は、Java の仮想マシン JVM 上で動作する &lt;code>.class&lt;/code> ファイルを生成します。&lt;/li>
&lt;li>Kotlin で作成したコードを Java コードから簡単に呼び出せます。逆に、Kotlin から Java のコードを利用するのも容易です。&lt;/li>
&lt;li>Java で作成されたフレームワークやライブラリをそのまま使用することができます。&lt;/li>
&lt;li>Gradle や Ant などを使ってビルドすることができます。&lt;/li>
&lt;li>上記のような特徴により、&lt;strong>1 つのプロジェクト内に Java のコードと Kotlin のコードを共存&lt;/strong>させることができます。&lt;/li>
&lt;li>&lt;strong>Java に比べて少ない記述量&lt;/strong>で同等以上のことを実現することができます。文末のセミコロンが不要だったり、型名を省略できたり、ラッパー関数があったりします。&lt;/li>
&lt;li>Java と同様に静的型付き言語 (Statically typed language) ですが、多くの場合はコンパイラによる推論 (type inference) により型名を省略できます（コンパイル時に型が確定することは変わりありません）。&lt;/li>
&lt;li>&lt;strong>Null 非許容型などを言語的にサポート&lt;/strong>するため、メンテナンス性の高いコードを記述できます。&lt;/li>
&lt;li>Java と同様にオブジェクト指向言語として扱えますが、&lt;strong>関数型プログラミング (Functional programming) を言語レベルでサポート&lt;/strong>しています。
&lt;ul>
&lt;li>関数をパラメータとして受け取ったり、戻り値で返したりすることができます。&lt;/li>
&lt;li>Lambda 式という小さなコードブロックを受け渡しすることができます。&lt;/li>
&lt;li>Data class というイミュータブルなオブジェクトを作成するための簡潔な構文が用意されています。&lt;/li>
&lt;li>コレクションを関数型プログラミングのスタイルで扱う API が用意されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>JavaScript へのトランスパイルが検討されています（Kotlin コード → JavaScript コードへの変換）。&lt;/li>
&lt;/ul>
&lt;h2 id="kotlin-の開発環境のインストールと-helloworld">Kotlin の開発環境のインストールと HelloWorld&lt;/h2>
&lt;h3 id="kotlin-playground-のサイトで試してみる">Kotlin Playground のサイトで試してみる&lt;/h3>
&lt;p>簡単な Kotlin のコードであれば、下記のサイト上で直接実行することができます。&lt;/p></description></item></channel></rss>