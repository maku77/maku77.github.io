<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kotlin on 天才まくまくノート</title><link>https://maku77.github.io/kotlin/</link><description>Recent content in Kotlin on 天才まくまくノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 26 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://maku77.github.io/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlinメモ: インライン関数の特徴を理解する (inline fun)</title><link>https://maku77.github.io/p/8ieeha7/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8ieeha7/</guid><description>インライン関数 Kotlin の関数定義には fun キーワードを使用しますが、このとき、inline fun と記述すると インライン関数 として定義することができます。 inline 修飾子が付けられた関数を呼び出すと、呼び出した位置に関数の内容がインライン展開される形でコンパイルされるため、結果的に次のような効果が得られます。
型パラメータを reified 指定できる 非局所リターン (non-local return) を行えるようになる 実行時の高速化を期待できる 型パラメータを reified 指定できる Java (JVM) では、型パラメータを持つ関数（ジェネリクス関数）を定義しても、その型情報を実行時には参照することができません。 なぜなら、型パラメータはコンパイル時の型チェックにのみ使われるものであり、後方互換性のために実行コードからは削除されてしまうからです（イレイジャと呼びます）。 Kotlin では、関数を inline 定義し、さらに型パラメータを reified 指定 (具体化型パラメータ）することにより、実行時に型情報を参照することができます。
例えば次のようなコードをコンパイル、実行することができます。
// 型パラメータで渡された型の名前を出力する inline fun &amp;lt;reified T&amp;gt; printType() { println(T::class.simpleName) } printType&amp;lt;String&amp;gt;() // =&amp;gt; &amp;#34;String&amp;#34; これは、関数の内容が次のように呼び出し位置にインライン展開され、型情報がそこに埋め込まれることにより実現されています。
println(String::class.simpleName) つまり、型パラメータの reified 指定は、inline 関数があってこその機能といえます（実際、inline 関数以外で型パラメータを reified 指定するとコンパイルエラーになります）。
Kotlin の標準ライブラリ (kotlin.collections) が提供する Collection の拡張関数 filterIsInstance&amp;lt;T&amp;gt; も同じように inline 定義されており、型パラメータで指定した型の要素を抽出することができます。
val list = listOf(1, null, &amp;#34;AAA&amp;#34;, 2, &amp;#34;BBB&amp;#34;) println(list.</description></item><item><title>Kotlinメモ: VS Code で Kotlin の開発環境を構築する</title><link>https://maku77.github.io/p/2hbwijq/</link><pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/2hbwijq/</guid><description>Kotlin 環境の構築 kotlinc のインストール VS Code 自体は Kotlin コードのコンパイル機能を持っていないので、kotlinc コマンドはあらかじめインストールしておく必要があります。
Kotlin をインストールする コマンドラインから次のように kotlinc コマンドを実行できるようになっていれば OK です。
$ kotlinc -version info: kotlinc-jvm 1.3.71 (JRE 1.8.0_212-release-1586-b04) Kotlin Language プラグインのインストール VS Code の Extensions タブから kotlin で検索して、 Kotlin Language プラグインをインストールします。 このプラグインにより、Kotlin コードのシンタックスハイライトなどが効くようになります。
Code Runner プラグインのインストール VS Code の Extensions タブから code で検索して、 Code Runner プラグインをインストールします。 このプラグインにより、ショートカットキー一発で Kotlin コードを実行できるようになります。
Kotlin プログラムを実行してみる VS Code への各種プラグインのインストールが済んだら、簡単な Kotlin プログラムを記述して実行してみます。
コードの作成 まず、VS Code を適当な空のディレクトリを起点にして起動します。
$ mkdir sample-kotlin $ code sample-kotlin Ctrl + N キーでファイルを新規作成し、次のように入力して Ctrl + S で保存します。 ファイルの拡張子は .</description></item><item><title>Kotlinメモ: 列挙型 (enum) の値をループ処理する (values)</title><link>https://maku77.github.io/p/q3y3jhr/</link><pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/q3y3jhr/</guid><description>列挙型 (enum) クラスに自動的に定義される values() メソッドを使用すると、全ての値を含む配列 (Array&amp;lt;列挙型&amp;gt;) を取得することができます。 この配列を for-in ループで処理すれば、列挙型の値を 1 つずつ取り出せます。
enum class Fruits { APPLE, BANANA, GRAPE } fun main() { for (x: Fruits in Fruits.values()) { println(x) } } 次のように forEach でループ処理することもできますね。
Fruits.values().forEach { println(it) } Fruits.values().forEach(::println)</description></item><item><title>Kotlinメモ: 列挙型 (enum) の値をインデックスで取得する</title><link>https://maku77.github.io/p/nsvub5w/</link><pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/nsvub5w/</guid><description>次の例では、列挙型クラス Fruits に static な関数 fromOrdinal() を定義し、インデックス番号 (0, 1, 2) から Fruits インスタンスを取得できるようにしています。 範囲外のインデックスを指定した場合は、NoSuchElementException 例外が発生します。
Fruit.kt enum class Fruits { APPLE, BANANA, GRAPE; companion object { fun fromOrdinal(ordinal: Int) : Fruits { return values().first { it.ordinal == ordinal } } } } 使用例 val f1 = Fruits.fromOrdinal(0) //=&amp;gt; Fruits.APPLE val f2 = Fruits.fromOrdinal(1) //=&amp;gt; Fruits.BANANA val f3 = Fruits.fromOrdinal(2) //=&amp;gt; Fruits.GRAPE val f4 = Fruits.fromOrdinal(3) //=&amp;gt; NoSuchElementException</description></item><item><title>Kotlinメモ: infix 記法で関数呼び出し時の記述を簡略化する (to)</title><link>https://maku77.github.io/p/6qamkcy/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/6qamkcy/</guid><description>infix 呼び出し記法 Kotlin には、「infix 記法 (infix notation)」 と呼ばれる、特別なメソッドコールの構文が用意されています。 「infix 呼び出し (infix call)」や「中置記法」などと呼ばれることもあります。
例えば、次のように Map オブジェクトを生成するときに使用する to 関数などが infix 呼び出しできるように定義されています。
val map = mapOf(&amp;#34;one&amp;#34; to 1, &amp;#34;two&amp;#34; to 2, &amp;#34;three&amp;#34; to 3) println(map[&amp;#34;one&amp;#34;]) //=&amp;gt; 1 infix とは「接中辞」のことで、上記の例では、to がちょうど間に挟まる形になるのでこう呼ばれています。 この to 関数は、ジェネリックな関数として次のように定義されています。
infix fun &amp;lt;A, B&amp;gt; A.to(that: B): Pair&amp;lt;A, B&amp;gt; = Pair(this, that) つまり、to 関数は Pair オブジェクトを生成するためのユーティリティ関数です。
val pair = &amp;#34;one&amp;#34; to 1 //=&amp;gt; Pair(&amp;#34;one&amp;#34;, 1) この to 関数は本来は下記のように、ドットや括弧を付けたメソッド呼び出しの形で呼び出さなければならないはずですが、関数の先頭に infix を付けて定義してあると、ドットや括弧を省略した「infix 記法」で呼び出せるようになります。</description></item><item><title>Kotlinメモ: 分解宣言 (destructuring declarations) による Pair 要素や Triple 要素の分解</title><link>https://maku77.github.io/p/fr4jjf6/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fr4jjf6/</guid><description>Pair クラスと Triple クラス Kotlin は 2 つの値、あるいは 3 つの値を保持するための簡易クラスとして、Pair クラスと Triple クラスを用意しています。
Pair オブジェクトの 1 番目と 2 番目の要素には、それぞれ first、second というプロパティでアクセスできます。
val pair = &amp;#34;one&amp;#34; to 1 // Pair(&amp;#34;one&amp;#34;, 1) と同じ println(pair.first) //=&amp;gt; &amp;#34;one&amp;#34; println(pair.second) //=&amp;gt; 1 この例のように、Pair オブジェクトを生成するときは to という中置関数（infix function）を使うと簡潔に記述できます（参考: infix 記法 (infix notation)）。
Triple オブジェクトの要素も同様に、first、second、third というプロパティでアクセスできます。
val triple = Triple(&amp;#34;one&amp;#34;, &amp;#34;two&amp;#34;, &amp;#34;three&amp;#34;) println(triple.first) //=&amp;gt; &amp;#34;one&amp;#34; println(triple.second) //=&amp;gt; &amp;#34;two&amp;#34; println(triple.third) //=&amp;gt; &amp;#34;three&amp;#34; 分解宣言でオブジェクトの各プロパティを別々の変数に代入する Kotlin の 分解宣言 (destructuring declarations) と呼ばれている形で変数を定義すると、オブジェクトの各プロパティが保持している値を、別々の変数に一度に代入することができます。 分解宣言の方法は簡単で、代入文の左辺に複数の変数を括弧で囲んで記述するだけです。 次の例では、Pair オブジェクトの first プロパティと second プロパティの値を、それぞれ x、y という変数に取り出しています。</description></item><item><title>Kotlinメモ: 可変長引数をとる関数を定義する (vararg)</title><link>https://maku77.github.io/p/c2f65zt/</link><pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/c2f65zt/</guid><description>Kotlin の可変長引数は vararg キーワード Kotlin で可変長引数 (variable-length arguments) を表現するには、vararg キーワードを使用します。 例えば、List を生成するファクトリ関数である listOf は次のように定義されています。
fun &amp;lt;T&amp;gt; listOf(vararg elements: T): List&amp;lt;T&amp;gt; { elements.forEach { /* ... */ } } listOf 関数のパラメータには vararg が付けられているため、次のように任意の数の引数を渡すことができます。
val list = listOf(1, 2, 3, 4 ,5) ちなみに、Java で可変長引数を定義するときは、3 つのドット (...) を使っていました。 Java でも Kotlin でも、関数の実装側では配列と同様に扱うことができます。
Java の例 public void show(Integer... args) { for (Integer x: args) { /* ... */ } } vararg を使った関数を実装する 下記は、任意の数の String 引数を受け取ることのできる関数の定義例です。 可変長引数として定義したパラメータは、配列型のオブジェクトとして参照することができるので、forEach 関数などを使ってループ処理することができます（ここでは strings パラメータは Array&amp;lt;String&amp;gt; として扱えます）。</description></item><item><title>Kotlinメモ: ジェネリクス: reified でジェネリクスの型情報を維持する</title><link>https://maku77.github.io/p/u32ykpo/</link><pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/u32ykpo/</guid><description>具体化型パラメータ (reified type parameters) Java の頃から変わっていませんが、ジェネリクスの型引数で指定した型情報は、コンパイル時にイレイジャ (erasure) によって削除されます。 つまり、実行時にその型情報を参照することはできません。 これは、JVM の仕組みによるもので、erased at runtime と呼ばれたりします。 Kotlin では、reified type parameter という機能を使うことで、型引数で指定した型情報を残すことができます。
例えば、次のように、いろいろな型の要素を含んだリストから、指定した型の要素だけを取り出すためのジェネリック関数 filterByType() を作りたいとします。
val list = listOf(1, &amp;#34;A&amp;#34;, 2, &amp;#34;B&amp;#34;) val intList = filterByType&amp;lt;Int&amp;gt;(list) println(intList) //=&amp;gt; [1, 2] val strList = filterByType&amp;lt;String&amp;gt;(list) println(strList) //=&amp;gt; [&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;] この filterByType() 関数は、次のような感じで実装できそうな気がします。
間違ったコード fun &amp;lt;T&amp;gt; filterByType(list: List&amp;lt;*&amp;gt;): List&amp;lt;T&amp;gt; { val result = mutableListOf&amp;lt;T&amp;gt;() list.forEach { // ERROR: cannot check for instance of erased type: T if (it is T) result.</description></item><item><title>Kotlinメモ: lateinit による変数の初期化</title><link>https://maku77.github.io/p/ymzvh9q/</link><pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ymzvh9q/</guid><description>lateinit 変数とは クラスのプロパティは、できるだけ val（再代入不可）変数として定義すると保守性の高いコードを作成することができます。 val 変数は生成時に参照先のオブジェクトを確定しておく必要があるため、変数の宣言時に代入するか、init ブロックでの代入が必要です。
class Potter { private val magics = mutableListOf&amp;lt;String&amp;gt;() //... } しかし、Android などのフレームワーク上で実装を行っている場合、どうしてもフレームワークによる初期化関数の呼び出しの段階まで変数の初期化ができないことがあります。 このようなケースで val 変数の代わりに使用できるのが lateinit 変数です。
下記は Android の Activity 実装の抜粋です。 ここでは、surfaceView 変数を lateinit で宣言することにより、初期化タイミングを onCreate() 呼び出しまで遅延させています。 lateinit 変数は var で宣言しないといけないことに注意してください。
class MainActivity : Activity() { private lateinit var surfaceView: SurfaceView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) surfaceView = SurfaceView(this) } //... } 変数を lateinit 宣言することにより、non-null な初期化済みの変数として参照することができるようになります。 ただし、参照する前に必ず初期化（代入）されていることが条件となります。 初期化前に lateinit 変数を参照すると、次のような UninitializedPropertyAccessException が発生します。</description></item><item><title>Kotlinメモ: lateinit 変数が初期化されているかどうかを調べる (isInitialized)</title><link>https://maku77.github.io/p/qpc53iy/</link><pubDate>Wed, 25 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qpc53iy/</guid><description>isInitialized の概要 Kotlin 1.2 以降では、lateinit 変数が初期化済みかどうかを isInitialized を使って調べることができます。 あるクラスのプロパティが初期化済みかどうかを調べるには次のようにします。
if (::プロパティ.isInitialized) { // プロパティは初期化済み (代入済み） } 直接プロパティにアクセスすると UninitializedPropertyAccessException が発生する可能性があるため、上記のようにプロパティ参照の仕組みを利用して参照するところがポイントです。
isInitialized の使用例 下記の initSubject() メソッドでは、lateinit 変数である subject が初期化されているかどうかを isInitialized で調べ、初期化されていない場合にのみ初期化を行うようにしています。 foo() や bar() メソッドの中で最初に initSubject() を呼び出すことで、subject が確実に初期化されてから参照されるようにしています。
class MyClass { private lateinit var subject: Subject private fun initSubject(context: Context) { if (::subject.isInitialized) { return } // ここで context を使って subject を初期化する } fun foo(context: Context) { initSubject(context) // ... subject を使う処理 .</description></item><item><title>Kotlinメモ: safe call (?.) や elvis operator (?:)、let で null をうまく扱う</title><link>https://maku77.github.io/p/qrrnw9b/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qrrnw9b/</guid><description>null を扱うさまざまな演算子・関数 Kotlin には、null をうまく扱うための便利な演算子や関数が用意されています。 代表的なものに下記があります。
オブジェクト?.メソッド (safe call) オブジェクトが null でないならメソッドを呼び出す。null なら null を返す。 式1 ?: 式2 (Elvis operator) 式1が null でないならその値、null なら式2を評価する オブジェクト!! (not-null assertion / unsafe dereference) nullable なオブジェクトを not-null なオブジェクトとして参照する。 万が一 null だった場合は NullPoiterException が発生する。 使用例 オブジェクトが null じゃない場合のみメソッドを呼び出す／プロパティを参照する logger?.log(&amp;#34;Hello&amp;#34;) logger 変数が null でない場合のみ log() メソッドを実行します。 null の場合は何も行いません。
val label = book?.title book 変数が null でない場合に title プロパティの値を取得します。 book 変数が null の場合は null が返されます。
オブジェクトが null だった場合にデフォルト値を設定／処理を打ち切る val title = book?</description></item><item><title>Kotlinメモ: メンバ参照、結合メンバ参照を理解する</title><link>https://maku77.github.io/p/r2gqqnt/</link><pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r2gqqnt/</guid><description>メンバ参照 (Member references) Kotlin では、クラス名::プロパティ名 あるいは クラス名::関数名 という記述をメンバ参照 (Member reference) と呼び、あるレシーバオブジェクトに対して、どのメンバを参照するかを示すことができます。
Book クラスの price プロパティを参照するメンバ参照は、
Book::price と記述することができ、これは下記のようなラムダ式と同じ意味を持ちます。
{ b: Book -&amp;gt; b.price } つまり、Book オブジェクトをパラメータとして受け取り、その price プロパティの値を返す関数です。 メンバ参照を変数に格納しておくと、後から通常の関数のように呼び出すことができます。
data class Book(val title: String, val price: Int) // price プロパティの値を参照するメンバ参照 val getPrice = Book::price fun main() { val book = Book(&amp;#34;Title&amp;#34;, 1000) println(getPrice(book)) //=&amp;gt; 1000 } メンバ参照は、コレクション系のメソッドに適用できるケースがよくあります。 下記の例では、リストをソートする関数 sortedBy に、メンバ参照オブジェクトを渡しています。
// price プロパティの値を参照するメンバ参照 val getPrice = Book::price val books = listOf( Book(&amp;#34;Title1&amp;#34;, 300), Book(&amp;#34;Title2&amp;#34;, 500), Book(&amp;#34;Title3&amp;#34;, 100)) val sortedBooks = books.</description></item><item><title>Kotlinメモ: ラムダ式の基本 (lambda expression)</title><link>https://maku77.github.io/p/rdoseay/</link><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rdoseay/</guid><description>ラムダ式とは ラムダ式は、パラメータを受け取ることのできる名前のない小さなコードブロックです。 Kotlin では、ラムダ式は次のように中括弧 {} で囲んで定義します。
{ a: Int, b: Int -&amp;gt; a + b } このラムダ式は、2 つの Int 型パラメータを受け取り、足し合わせた値を返します。 ラムダ式を変数に格納すると、通常の関数のように呼び出すことができるようになります。
val sum = { x: Int, y: Int -&amp;gt; x + y } println(sum(1, 2)) //=&amp;gt; 3 ラムダ式の典型的な使い方は、処理の一部をパラメータとして渡す使い方です。 次の例では、ボタンが押されたときのイベントハンドラとして、パラメータなしのラムダ式をセットしています。
button.setOnClickListener { println(&amp;#34;ボタンが押されたよ&amp;#34;) } このようなコールバック処理は、インタフェースを実装したオブジェクトを渡すことでも実現できますが、ラムダ式を使うと関数の本体部分だけを渡すことができるので、とてもシンプルな記述ができます。
ラムダ式を受け取る関数を定義する 下記の myRepeat 関数は、第1引数 times で指定された回数だけ、第2引数 action で指定されたラムダ式を繰り返し実行します。
fun myRepeat(times: Int, action: (Int) -&amp;gt; Unit) { for (index in 0 until times) { action(index) } } パラメータ action の型は (Int) -&amp;gt; Unit となっていますが、これは、Int 型のパラメータを取り、戻り値がない (Unit) ラムダ式を受け取ることを表しています。 myRepeat 関数は次のように使用します。</description></item><item><title>Kotlinメモ: オブジェクト宣言でシングルトンを作成する (object declaration)</title><link>https://maku77.github.io/p/wc8f9y8/</link><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/wc8f9y8/</guid><description>オブジェクト宣言によるシングルトン実装 Java のシングルトンに相当するものは、Kotlin ではオブジェクト宣言 (object declrations) を使用して簡単に実装することができます。
object Log { fun info(text: String) = println(text) fun error(text: String) = System.err.println(text) } 上記の例では、object Log という部分で Log という名前のオブジェクトを作成しています。 その後ろに続く { ... } のブロックがクラス定義の内容です。 無名のクラス定義があり、そのインスタンスとして Log という名前のオブジェクトを生成していると考えるとよいでしょう。
Log オブジェクトのメソッドを呼び出すコードは下記のようになります。
fun main() { Log.info(&amp;#34;Hello&amp;#34;) Log.error(&amp;#34;Something bad happened&amp;#34;) } オブジェクト名が大文字で始まっていて、クラス名のように見えるので、まるで Java の static メソッド呼び出しのように見えますが、実際には Log という名前のオブジェクトのメソッド呼び出しているにすぎません。 Kotlin には static フィールドというものは存在しません（@JvmStatic という魔法のキーワードはありますが）。
オブジェクト宣言では、通常のクラス定義と同様に、メソッドやプロパティ、初期化ブロック (init) などの定義を行うことができますが、プライマリ・コンストラクタやセカンダリ・コンストラクタの定義を行うことはできません（クラス定義とインスタンス化が同時に行われるため、他の場所でコンストラクタを呼び出すタイミングがないからです）。
コンストラクタは定義できないので、下記のようにインスタンスを作成することはできません。
val log = Log() // NG（インスタンス化はできない） よって、オブジェクト宣言によって作成されたオブジェクトは、シングルトンオブジェクトとして使用することができます。
オブジェクト宣言で継承を行う オブジェクト宣言 (object declaration) では、普通のクラス実装と同様、別のクラスの継承や、インタフェースの実装を行うことができます。 あくまでクラス定義とインスタンス生成を実装を同時に行っているだけで、このあたりの制約はありません（コンストラクタは定義できないので、コンストラクタでパラメータを渡せない点には注意）。</description></item><item><title>Kotlinメモ: オブジェクト式で無名オブジェクトを生成する (object expression)</title><link>https://maku77.github.io/p/8yzdom9/</link><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/8yzdom9/</guid><description>オブジェクト式の基本 オブジェクト宣言 (object declaration) は、クラスの定義とインスタンス生成を同時に行う構文ですが、これと似たものに オブジェクト式 (object expression) があります。
オブジェクト宣言では、object MyObj { ... } のように、クラス定義と同時に名前付きのオブジェクトを作成していましたが、オブジェクト式はその場で名前なしの無名オブジェクト (anonymous objects) を生成します。 オブジェクト式を使って生成したオブジェクトは、変数に格納するか、関数に渡すパラメータとして使用します（そうしないと参照できないため）。
下記の例では、オブジェクト式を使って、greet() 関数を持つ無名オブジェクトを生成しています。 生成されたオブジェクトを使用するために、いったん myObj という変数に格納しています。
val myObj = object { fun greet() = println(&amp;#34;Hello&amp;#34;) } myObj.greet() （これだけ見ると、JavaScript のオブジェクトにとても似ていますね）
オブジェクト式は、何らかのインタフェースを実装する無名オブジェクトを生成するときによく使われます。
interface ButtonListener { fun onClicked() } val listener = object : ButtonListener { override fun onClicked() = println(&amp;#34;押されたよ&amp;#34;) } オブジェクト式により生成した無名オブジェクトを、関数のパラメータに直接渡してしまうこともできます。
button.addListener(object : ButtonListener { override fun onClicked() = println(&amp;#34;押されたよ&amp;#34;) }) ただし、このように記述すると、このコードが実行されるたびにオブジェクトが生成されることに注意してください。
ちなみに、オブジェクト宣言 (object declaration) を使った場合は、下記のような記述になりますが、この場合は、イコール演算子の右側に書いたり、そのまま関数のパラメータで渡したりすることはできません（オブジェクト宣言は「式」ではないので、値を持ちません）。</description></item><item><title>Kotlinメモ: コンパニオンオブジェクトでクラスに静的メソッドを追加する (companion object)</title><link>https://maku77.github.io/p/n2jphu2/</link><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/n2jphu2/</guid><description>コンパニオンオブジェクトの基本 Kotlin は言語仕様上、クラスに static なフィールドを持たせることはできませんが、コンパニオンオブジェクト (companion object) の仕組みを利用すると、Java の static メソッドと同様な振る舞いを実現できます。 コンパニオンオブジェクトは、クラス本体部分で下記のように companion object を使って定義します（無名のコンパニオンオブジェクト）。
data class Book(val title: String, val price: Int) { companion object { const val FREE_PRICE = 0 fun newFreeBook(title: String) = Book(title, FREE_PRICE) } } fun main() { val book = Book.newFreeBook(&amp;#34;Free Kotlin&amp;#34;) println(book) //=&amp;gt; Book(title=Free Kotlin, price=0) } companion object の後ろの {} の中は、通常のクラスの本体と同じように実装します（private なフィールドを定義することもできます）。 上記のようにコンパニオンオブジェクトを定義すると、Book クラスの中に暗黙的なシングルトンインスタンスが生成され、Book.フィールド名 という形でアクセスできるようになります。 つまり、Java の static フィールドと同じ形でアクセスできます。 正確には Java の static フィールドとは異なり、内部でコンパニオンオブジェクトと呼ばれるオブジェクトが生成されているのですが、通常はあまり気にする必要はないでしょう。</description></item><item><title>Kotlinメモ: by を使ったメソッド呼び出しの委譲 (class delegation)</title><link>https://maku77.github.io/p/kh358jg/</link><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/kh358jg/</guid><description>by による委譲とは Decorator パターンを実装したり、コレクションクラスを委譲によって拡張したいケースでは、ベースとなるインタフェースで定義されているすべてのメソッドを実装しなければいけません。 あるクラスの機能を継承なしで拡張できる一方で、拡張しなくてもよいメソッドも含めて委譲処理を実装しなければいけないのは骨の折れる作業です。 単純なボイラープレート実装があふれたコードは美しくありません。
このようなケースで利用できるのが、by によるメソッド呼び出しの委譲 (class delegation) です。
IBar インタフェースの呼び出しを bar オブジェクトへ委譲 class Foo(val bar: IBar) : IBar by bar 実装するインタフェース名に続けて by someObj と記述すると、そのインタフェースの実装を指定したオブジェクト someObj に一括で委譲することができます。 そして、必要なメソッドだけをオーバーライドすることができます。
具体的に見ていきましょう。
by による委譲処理の例 例えば、下記のような単純なログ出力クラス SimpleLogger があるとします（Decorator パターンを使って出力をカスタマイズするため、あらかじめ Logger インタフェースを定義しています）。
interface Logger { fun info(text: String) fun warn(text: String) fun error(text: String) } class SimpleLogger : Logger { override fun info(text: String) = println(text) override fun warn(text: String) = println(text) override fun error(text: String) = println(text) } この SimpleLogger クラスを Decorator パターンで拡張し、error メソッドの呼び出し時にだけ ERROR: というプレフィックスを付けて出力する ようにします。 単純に実装すると下記のようになると思います。</description></item><item><title>Kotlinメモ: シールクラスで継承可能なクラスを制限する (sealed class)</title><link>https://maku77.github.io/p/d8kkspv/</link><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/d8kkspv/</guid><description>シールクラスとは クラスを定義するときに、sealed キーワードを使ってマークするとそのクラスはシールクラス (sealed class) となり、そのクラスのサブクラスとなれるクラスを制限することができます。 例えば、Screen クラスのサブクラスが、Screen.Main、Screen.ProductList しか存在しないことを明示することができます。
Kotlin はシールクラスを列挙型クラス (enum class) の強化版のようなものだと位置付けています。 enum 型は各インスタンスがシングルトンとしてのみ存在可能ですが、シールクラスのサブクラスは、シングルトンにすることもできますし、個別のインスタンスとして生成することもできます。
シールクラスは抽象クラスと同様の性質を持ちます。 デフォルトで継承可能 (open) なクラスとして定義され、abstract なメソッド、プロパティを含むことができます。 インスタンスを生成するときは、必ずサブクラスのインスタンスとして生成しなければいけません。
シールクラスの利用例 シールクラスは利用例を見たほうが理解しやすいと思います。 例えば、列挙型クラスのようなものを作りたいのだけれど、場合によってはパラメータを渡して亜種となるオブジェクトを作らなければいけない、といったケースで利用できます。
ここでは、アプリケーションの「画面状態」を示す Screen クラスを考えてみます。 画面状態には下記の種類があります。
Screen.Main &amp;ndash; メイン画面 Screen.ProductList &amp;ndash; 全商品のリスト画面 Screen.ProductDetail &amp;ndash; ある商品の詳細画面（商品 ID プロパティを含む） これらが 3 つの画面状態だけを示せればよいのであれば、従来の列挙クラスで 3 つの要素を定義してやれば解決です。 問題は、3 つ目の Screen.ProductDetail が、表示対象となる商品の ID をプロパティとして保持するという点です。 つまり、Screen.ProductDetail という 1 つの画面状態だけを示せばよいのではなく、Screen.ProductDetail(1) とか、Screen.ProductDetail(2) といった異なる画面状態を表現したいということです。
このように、列挙型の個々のオブジェクトに異なるプロパティを持たせたいという場面に出くわしたら、シールクラスの出番です。
sealed class Screen { object Main : Screen() object ProductList: Screen() data class ProductDetail(val productId: Int) : Screen() } ここでは、シールクラスのサブクラスをネストして定義していますが、ネストさせる必要は必ずしもありません。 ただ、enum クラスの拡張としてシールクラスを利用するのであれば、このようにネストして定義しておいた方がわかりやすいでしょう。 上記のようにシールクラスを定義すると、Screen.</description></item><item><title>Kotlinメモ: データクラスを定義する (data class)</title><link>https://maku77.github.io/p/fc4unhr/</link><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/fc4unhr/</guid><description>データクラスとは Kotlin で単純なプロパティを保持するだけのクラスは、下記のように簡単に定義することができます。
class Book(val title: String, val price: Int) これだけでも十分便利ですが、さらに data キーワードを付けることにより、そのクラスはデータクラスとして定義されます。
data class Book(val title: String, val price: Int) データクラスとして定義すると、プライマリ・コンストラクタで定義したフィールドを扱う、下記のようなメソッドが内部で自動生成されます。
fun toString() : String &amp;hellip; オブジェクトの文字列表現を返す fun equals(other: Any?) : Boolean &amp;hellip; オブジェクトの同一性を判断する fun hashCode() : Int &amp;hellip; コレクションクラスなどが利用するハッシュ値を返す fun copy(...) : T &amp;hellip; オブジェクトのコピーを生成する Java では、これらのメソッドを IDE などの力を借りるなどしてコードの形で実装する必要がありましたが、Kotlin では、クラス定義の先頭に data キーワードを付加するだけです。 ボイラープレート的なコードを記述する必要がないので、コードをシンプルに保つことができます。
データクラスのオブジェクトは、そのまま println でわかりやすい表現で出力できるようになり、ハッシュ系のコレクションに追加できるようになります。 下記のサンプルでは、データクラスの println が正しく動作していること、HashSet への格納が正しくできていることを確認しています。
data class Book(val title: String, val price: Int) fun main() { val b = Book(&amp;#34;Kotlin入門&amp;#34;, 1000) println(b) //=&amp;gt; Book(title=Kotlin入門, price=1000) val set = hashSetOf( Book(&amp;#34;T1&amp;#34;, 100), Book(&amp;#34;T1&amp;#34;, 100), // 同じ内容の本を追加 Book(&amp;#34;T2&amp;#34;, 200)) println(set.</description></item><item><title>Kotlinメモ: クラスにプロパティのアクセサメソッドを定義する (set, get)</title><link>https://maku77.github.io/p/g2bj9zs/</link><pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/g2bj9zs/</guid><description>カスタムアクセサとは Kotlin では、下記のようにクラスのプロパティを定義するだけで、自動的に setter/getter が生成されます。
data class Book(var title: String) val b = Book(&amp;#34;タイトル1&amp;#34;) b.title = &amp;#34;タイトル2&amp;#34; 多くの場合はこれだけで十分ですが、プロパティの値を読み書きする際に何らかの処理を行いたい場合は、プロパティのカスタムアクセサ (getter/setter) を定義する必要があります。
カスタムアクセサを定義する (set() / get()) プロパティにアクセスしたときの振る舞いは、get、set を実装することでカスタマイズできます。 下記の例では、title プロパティに対してカスタム getter、setter を定義しています。
class Book(title: String) { var title: String = title get() { println(&amp;#34;get: $field&amp;#34;) return field } set(value: String) { println(&amp;#34;set: $field -&amp;gt; $value&amp;#34;) field = value } } print(book.title) のようにプロパティの値を参照すると get() が呼び出され、book.title = &amp;quot;あああ&amp;quot; のようにプロパティの値を書き換えようとすると set(value) が呼び出されます。
プロパティとして現在保持されている値は field キーワードで参照できます。 setter の実装の中では、field に値を代入することで、プロパティが保持する値を変更します。 setter が呼び出されたときに、先に field の値を参照すれば、プロパティの値を変更する前の元の値を取得できます。 例えば、下記のようにすれば、プロパティの値が実際に変更されるときのみ処理を行う ということが実現できます。</description></item><item><title>Kotlinメモ: 継承可能なクラスを作成する (open, abstract, override)</title><link>https://maku77.github.io/p/r4wcjss/</link><pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/r4wcjss/</guid><description>open と override Kotlin のクラス定義を行うと、デフォルトでは継承できないようになっています。 継承可能なクラスとして定義するには、open モディファイアを付ける必要があります。 さらに、その中でオーバーライド可能なメソッドにも open モディファイアを付ける必要があります。
下記の Animal クラスは継承可能であり、cry メソッドがオーバーライドできるようになっています。
open class Animal(val name: String) { fun greet() { print(&amp;#34;私は${name}です。&amp;#34;) cry() } open fun cry() { println(&amp;#34;ウー！&amp;#34;) } } 下記の Cat、Dog クラスは Animal クラスを継承し、cry メソッドをオーバーライドしています。 オーバーライドしていることを示すために、メソッドの定義時に override キーワードを付ける必要があります。
open class Cat : Animal(&amp;#34;猫&amp;#34;) { override fun cry() = println(&amp;#34;ニャー！&amp;#34;) } open class Dog : Animal(&amp;#34;犬&amp;#34;) { override fun cry() = println(&amp;#34;ワンワン！&amp;#34;) } fun main() { Animal(&amp;#34;動物&amp;#34;).greet() // 私は動物です。ウー！ Cat().</description></item><item><title>Kotlinメモ: 既存のクラスに関数やプロパティを追加する（拡張関数）</title><link>https://maku77.github.io/p/du53m3v/</link><pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/du53m3v/</guid><description>クラスに拡張関数を追加する 拡張関数を使うと、自分で作成したクラスではなくてもメソッドを追加することができます。 例えば、Java のコアライブラリの String クラスや、Android SDK が提供するクラスなどを拡張することができます。 やりすぎると分かりにくくなってしまいますが、効果的に導入すると、簡潔で分かりやすいコードを記述できるようになります。
次の例では、String クラスに拡張関数を追加し、ある文字列が 0x あるいは 0X で始まっているかを調べる isHex メソッドを定義しています。
fun String.isHex(): Boolean = this.startsWith(&amp;#34;0x&amp;#34;, true) fun main() { println(&amp;#34;0x123&amp;#34;.isHex()) //=&amp;gt; true println(&amp;#34;12345&amp;#34;.isHex()) //=&amp;gt; false } 拡張関数の中で this を参照すると、レシーバオブジェクトを参照することができます。 つまり、s.isHex() と呼び出した場合、this はオブジェクト s を参照します。
拡張関数の実装は、普通のメソッド実装と同じ感覚で記述することができるので、拡張関数の中からメンバメソッドを呼び出すときは、通常 this を省略することができます。 よって、上記の String.isHex() 関数は下記のように記述できます。
fun String.isHex(): Boolean = startsWith(&amp;#34;0x&amp;#34;, true) このように、拡張関数の中から別のメンバメソッドを呼び出すことができるのですが、呼び出せるのは public なメンバメソッドだけであることに注意してください。 private メソッドや、protected メソッドを呼び出すことはできません。 これは、拡張関数を追加することによって、カプセル化されたクラス構造を破壊してしまわないようにするための Kotlin の配慮です。
Int などの基本型に拡張関数を追加する Kotlin の Int などの基本型に拡張関数を追加する場合、その値自身は this で参照することができます。 下記の例では、Int 値を 2 乗した値を返す square メソッドを Int 型に追加しています。</description></item><item><title>Kotlinメモ: あるインスタンスがどのクラスのオブジェクトなのか調べる (javaClass)</title><link>https://maku77.github.io/p/tc9c9z8/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/tc9c9z8/</guid><description>Kotlin のあるインスタンスが、どのクラスのインスタンスかを調べるには、javaClass プロパティを使用します（Java の Object#getClass() に相当します）。
下記の例では、コレクション系のオブジェクトが、どのクラスのインスタンスなのかを調べています。
val array = arrayOf(1, 2, 3) val list = listOf(1, 2, 3) val arrayList = arrayListOf(1, 2, 3) val set = setOf(&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;) val hashSet = hashSetOf(&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;) val map = mapOf(&amp;#34;A&amp;#34; to 1, &amp;#34;B&amp;#34; to 2) val hashMap = hashMapOf(&amp;#34;A&amp;#34; to 1, &amp;#34;B&amp;#34; to 2) println(array.javaClass) //=&amp;gt; class [Ljava.lang.Integer; println(list.javaClass) //=&amp;gt; class java.util.Arrays$ArrayList println(arrayList.javaClass) //=&amp;gt; class java.util.ArrayList println(set.javaClass) //=&amp;gt; class java.</description></item><item><title>Kotlinメモ: パッケージのトップレベルに関数、プロパティ、定数を定義する</title><link>https://maku77.github.io/p/xgn46vo/</link><pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/xgn46vo/</guid><description>トップレベル関数を定義する Java ではパッケージのトップレベルに関数を定義することはできませんでした (あるクラスの static メソッドとして定義する必要がありました) が、Kotlin ではクラスの外に関数 (プロパティ、定数) を定義することができます。
下記の例では、util.kt のトップレベルで printError 関数を定義し、それを main.kt の中から利用しています。
util.kt package com.example fun printError(message: String) { System.err.println(&amp;#34;Error: $message&amp;#34;) } main.kt import com.example.printError fun main() { printError(&amp;#34;ファイルが見つかりません&amp;#34;) } main.kt からの参照方法を見ると分かるように、Kotlin では .kt ファイルの名前は参照時に意識する必要はなく、あくまでpackage により宣言されたパッケージ名だけが参照情報として必要になります。
トップレベルに定義された関数をまとめてインポートしたいときは、下記のようなワイルドカードを使用できます。
import com.example.* トップレベル関数を private にする パッケージのトップレベルに定義した関数 (やプロパティ) は、デフォルトでは public になり、他の .kt ファイルから参照できるようになっています。 可視性を自分のファイル内に限定したい場合は、private を付けて関数を定義します。
package com.example.util // これは他のファイルからも参照できる fun greet(name: String) { println(getMessage(name)) } // これはこのファイルからしか参照できない private fun getMessage(name: String): String { return &amp;#34;Hello, $name!</description></item><item><title>Kotlinメモ: for ループと while ループ（そして forEach）</title><link>https://maku77.github.io/p/7gfaxun/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/7gfaxun/</guid><description>while ループ Kotlin の while ループ、および do-while ループは次のような形で使用します。
var i = 0 while (i &amp;lt; 10) { print(i++) } var i = 0 do { print(i++) } while (i &amp;lt; 10) while ループは、括弧の中の条件式が真 (true) である限りブロック内のコードを繰り返し実行します。 do-while ループも同様ですが、少なくとも一回はブロック内のコードを実行します。
Java と同様の構文なので、迷うことはないと思います。
for ループ Java にはいわゆる C/C++ 形式のループ (for (int i=0; i&amp;lt;n; ++i)) と、for-each 形式のループ (for (int i : arr)) がありますが、Kotlin には for (xxx in yyy) の形の for ループしか存在しません。
数値範囲のループ（.. と until） Kotlin では、.</description></item><item><title>Kotlinメモ: インタフェースを定義する (interface)</title><link>https://maku77.github.io/p/ep23xid/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ep23xid/</guid><description>インタフェースの基本 Kotlin でのインタフェース定義は、Java と同様に interface キーワードを使用します。 下記の例では、Command インタフェースを定義し、それを GreetCommand クラスと ExplodeCommand クラスが実装しています。
interface Command { fun execute() } class GreetCommand(val name: String) : Command { override fun execute() = println(&amp;#34;Hi, $name&amp;#34;) } class ExplodeCommand : Command { override fun execute() = println(&amp;#34;Boom!&amp;#34;) } fun executeAllCommands(commands: List&amp;lt;Command&amp;gt;) { commands.forEach { it.execute() } } fun main() { val commands = listOf( GreetCommand(&amp;#34;Maku&amp;#34;), GreetCommand(&amp;#34;Hemu&amp;#34;), ExplodeCommand()) executeAllCommands(commands) } 実行結果 Hi, Maku Hi, Hemu Boom! インタフェースのメソッドはオーバーライドされることを前提としているため、fun の前に open を付ける必要はないことに注意してください。 オーバーライドする側のメソッドには override を付ける必要があります（Java のような @Override アノテーションは使いません）。</description></item><item><title>Kotlinメモ: クラスを定義する (class)</title><link>https://maku77.github.io/p/4qqytis/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4qqytis/</guid><description>クラス定義の基本 Kotlin のクラス定義は Java と同様に class キーワードを使用しますが、デフォルトで public final 扱いという違いがあります。 これは、多くのケースで public の方が都合がよいことと、意図しない継承を防ぐことを意図した仕様です。
デフォルトでは全クラスからアクセス可能 (public) デフォルトでは継承できない (final) 次の Book クラスは、リードオンリーな title プロパティ持つ、シンプルなクラスの実装例と使用例です。
リードオンリーなプロパティを持つクラス class Book(val title: String) val b = Book(&amp;#34;Title1&amp;#34;) println(b.title) //=&amp;gt; Title1 詳しくは後述しますが、Kotlin にはメソッドを簡潔に記述するための仕組みがたくさん用意されています。 メソッド実装などの記述が必要ない場合は、上記のようにクラス本体部分を示す { } ブロックすら省略して記述することができます。 Java とは異なり、コンストラクタを呼び出すときの new キーワードも省略できます（というより new は存在しません）。
上記は title プロパティをリードオンリー (val) として定義していますが、プロパティの値を書き換え可能にするには、val を var に置き換えるだけで済みます。
書き換え可能なプロパティを持つクラス class Book(var title: String) val b = Book(&amp;#34;Title1&amp;#34;) b.title = &amp;#34;Title2&amp;#34; println(b.title) //=&amp;gt; Title2 上記のように b.</description></item><item><title>Kotlinメモ: スマートキャストでキャストを自動化する</title><link>https://maku77.github.io/p/rk5dgjh/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/rk5dgjh/</guid><description>インタフェースを定義する でも説明されているように、あるオブジェクトが特定のインタフェースを持っているかを調べるには、obj is インタフェース名 というチェックを行います。
interface Command { fun execute() } fun executeIfPossible(obj: Any) { if (obj is Command) { obj.execute() } } Java では、あるオブジェクトが特定のインタフェースを持っているかを調べた後に、さらにキャストを行わなければ、そのインタフェースのメソッドを呼び出すことはできませんでした。 Kotlin では、上記のように、is による判定が true だったときは、その後ろのブロック内では明示的なキャストを省略することができます（型のチェックとキャストが同時に行われる）。 これをスマートキャスト (smart cast) と呼びます。
実際には、下記のような as を使ったキャストが内部的に自動的に行われていることになります。
冗長なキャスト if (obj is Command) { val cmd = obj as Command // これは必要ない cmd.execute() } スマートキャストは、|| や &amp;amp;&amp;amp; を使った際にも適用されます。 下記の 2 つの例はいずれも想定通り動作します。
if (x is String &amp;amp;&amp;amp; x.length &amp;gt; 0) { // .</description></item><item><title>Kotlinメモ: 例外処理を記述する (try, catch, finally)</title><link>https://maku77.github.io/p/bvu8qmi/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/bvu8qmi/</guid><description>例外の基本 Kotlin の例外処理には、Java と同様の try、catch、finally キーワードを使用します。
下記は、NumberFormatException 例外を捕捉する例です。
try { val num = &amp;#34;xyz&amp;#34;.toInt() println(num) } catch (e : NumberFormatException) { System.out.println(e) } 例外のスローも Java と同様に throw を使って行います。 クラスのインスタンスを生成するときに new が必要なかったように、ここでも new は必要ありません。
fun fibonacci(n: Int) { if (n &amp;lt; 0) throw IllegalArgumentException(&amp;#34;負の値は指定できません&amp;#34;) // ... } 例外の捕捉は必須ではない Java では、IOException などの検査例外 (checked exception) を投げるメソッドを呼び出すメソッドは、必ず catch で例外を捕捉するか、自分自身のメソッドで throws IOException と宣言しておく必要がありました。 Kotlin では、検査例外 (checked exception) と非検査例外 (unchecked exception) を区別しない ので、メソッドに throws IOException の宣言が必要ありません。 スローされた例外を捕捉するもしないも呼び出し側の自由です。 捕捉されなかった例外は、呼び出し元のメソッドに伝搬されていきます。</description></item><item><title>Kotlinメモ: 列挙型を定義する (enum)</title><link>https://maku77.github.io/p/st6xako/</link><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/st6xako/</guid><description>列挙型の基本 (enum class) Kotlin の列挙型はクラスの一種であり（Java もそうですが）、class キーワードの前に enum を付けることで定義できます。
enum class Fruits { APPLE, BANANA, GRAPE } fun main() { val fruit = Fruits.APPLE println(fruit) //=&amp;gt; APPLE } when 式による分岐で使用するのが典型的な使用例です。
fun getColor(fruit: Fruits) = when (fruit) { Fruits.APPLE -&amp;gt; &amp;#34;red&amp;#34; Fruits.BANANA -&amp;gt; &amp;#34;yellow&amp;#34; Fruits.GRAPE -&amp;gt; &amp;#34;purple&amp;#34; } fun main() { val f = Fruits.APPLE println(&amp;#34;$f is ${getColor(f)}&amp;#34;) //=&amp;gt; APPLE is red } when 式の分岐において、すべての列挙値を網羅していない場合は、必ず else 分岐を含める必要があります（Java の switch における default のようなもの）。 書き忘れた場合はコンパイルエラーになるのですぐに気づくことができます。</description></item><item><title>Kotlinメモ: when 式による条件分岐</title><link>https://maku77.github.io/p/v2ezcum/</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/v2ezcum/</guid><description>when 式の基本 Kotlin の when 式は、Java の switch 文に相当するものです。 Java の switch は、列挙型、文字列、数値しか扱えませんが、Kotlin の when では任意のオブジェクトで分岐を行うことができます。
ポイントは式 (expression) であるというところで、条件分岐後の評価結果をそのまま変数に代入したり、関数の戻り値として使うことができます。
val n = 1 val str = when(n) { 1 -&amp;gt; &amp;#34;one&amp;#34; 2 -&amp;gt; &amp;#34;two&amp;#34; else -&amp;gt; &amp;#34;other&amp;#34; } println(str) //=&amp;gt; one Java とは異なり、分岐後の処理は fall through されないので、break 文は不要です。 デフォルトで、値が一致した部分のコードのみが実行されるようになっています。
分岐後の処理を複数行にわたって記述したい場合は、次のように矢印 (-&amp;gt;) の右側を括弧 { } で囲んでブロックを作ります。 ブロックの中で最後に評価された式の値が、when 式全体の評価結果として使われます。
val a = 1 when (a) { 1 -&amp;gt; { println(&amp;#34;one&amp;#34;) exec_one() } 2 -&amp;gt; { println(&amp;#34;two&amp;#34;) exec_two() } else -&amp;gt; { println(&amp;#34;other&amp;#34;) exec_other() } } 列挙型の値で when 分岐 列挙型の値により when 分岐させる場合は、すべての項目を網羅するように記述するか、else でその他のケースをまとめて処理するように記述する必要があります（どちらかを満たさないとコンパイルエラーになります）。</description></item><item><title>Kotlinメモ: 基本的な型の一覧</title><link>https://maku77.github.io/p/hqup7mp/</link><pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/hqup7mp/</guid><description>Kotlin には、Java のプリミティブ型に相当する int や boolean といった型は存在せず、すべてがオブジェクトです。 例えば、32 ビット整数を扱いたい場合は、一貫して Int と記述すればよく、Java のように int と Integer を使い分ける必要はありません（内部で必要に応じて Java の int や Integer 相当のものとして扱われます）。
数値型 Byte &amp;hellip; 8ビット整数 Short &amp;hellip; 16ビット整数 Int &amp;hellip; 32ビット整数 Long &amp;hellip; 64ビット整数 Float &amp;hellip; 32ビット浮動小数点数 Double &amp;hellip; 64ビット浮動小数点数 文字、文字列 Char &amp;hellip; 文字 String &amp;hellip; 文字列 論理型 Boolean 列挙型 enum class で定義 特殊型 Any &amp;hellip; Java の Object に相当。すべてのクラスのスーパークラスです（正確には Null 許容型のスーパークラスは Any ではなく Any?）。 Unit &amp;hellip; Java の void に相当。意味を持たない値を表現します。Any は Unit のスーパークラスでもあります。 Nothing &amp;hellip; インスタンスが存在しないことを表現します。ある関数の戻り値が Nothing と定義されている場合、その関数から return されることはないことを示しています（内部で無限ループしているとか、必ず例外を投げるとか）。Nothing はすべてのクラスのサブクラスであるとされています。 プラットフォーム型 &amp;hellip; Java で定義された型で、@NonNull や @Nullable といったアノテートがされていないものです。Kotlin の言語仕様上は String!</description></item><item><title>Kotlinメモ: if による分岐処理と if 式</title><link>https://maku77.github.io/p/4t7x4k4/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/4t7x4k4/</guid><description>Kotlin の if-else による分岐処理は、Java と同様の構文で記述することができます。
val n = 100 if (n % 15 == 0) { println(&amp;#34;FizzBuzz&amp;#34;) } else if (n % 3 == 0) { println(&amp;#34;Fizz&amp;#34;) } else if (n % 5 == 0) { println(&amp;#34;Buzz&amp;#34;) } else { println(n) } Java と異なるのは、Kotlin では if は文 (statement) ではなく式 (expression) であるという点です。 if 式を評価した結果は、そのまま変数に代入したり、関数の戻り値として使用することができます。 Java や C/C++ の三項演算子と同じ感覚で、下記のように使用することができます。
if 式の評価結果を変数に格納する val isOk = true val message = if (isOk) &amp;#34;OK&amp;#34; else &amp;#34;ERROR&amp;#34; println(message) //=&amp;gt; &amp;#34;OK&amp;#34; if 式の評価結果を戻り値として使用する fun getMessage(isOk: Boolean) = if (isOk) &amp;#34;OK&amp;#34; else &amp;#34;ERROR&amp;#34;</description></item><item><title>Kotlinメモ: 変数を定義する (val, var)</title><link>https://maku77.github.io/p/qzkfnsq/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/qzkfnsq/</guid><description>変数の定義 Kotlin で変数を定義するには、val キーワード（あるいは var キーワード）を使用します。 変数定義時に値を初期化する場合は、コンパイラが型を判断してくれるので、多くの場合は型の記述を省略することができます（この機能を型推論［type inference］と言います）。
val s = &amp;#34;Hello&amp;#34; //=&amp;gt; val s: String = &amp;#34;Hello&amp;#34; val n = 100 //=&amp;gt; val n: Int = 100 val f = 7.5e6 //=&amp;gt; val f: Double = 7.5e6 (= 7.5x10^6) ただし、変数の定義と同時に初期値を指定しない場合は、必ず型の指定が必要です。 型は、変数名の後ろに : 型名 という形で指定します（Pascal や Scala、Swift などと同じ）。
val name: String name = &amp;#34;Maku&amp;#34; println(&amp;#34;Hello, $name!&amp;#34;) val と var の違い val と var の違いは、その変数に再代入が可能かどうかです。
val: 再代入できない参照を保持するための変数 (immutable reference)。Java の final 変数に相当。value の略。 var: 再代入可能な変数 (mutable reference)。variable の略。 val a = 1 var b = 1 a = 2 // NG (Val cannot be reassigned) b = 2 // OK 使い分けの方針としては、変数を定義するときはまずは再代入できない val を使用することを考え、必要なケースでのみ var を使用するのがよいでしょう。 こうすることで、コードレビュー時などに変数の変化を追う必要性が下がるため、保守性が高くなります。</description></item><item><title>Kotlinメモ: 関数を定義する (fun)</title><link>https://maku77.github.io/p/ttacror/</link><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/ttacror/</guid><description>関数定義の基本 Kotlin で関数を定義するには fun キーワードを使用します。 Java ではすべてのメソッドは何らかのクラスに属す必要がありますが、Kotlin の場合はファイルのトップレベルに関数を定義することができます。
次の例は、2 つの整数 (Int) を受け取り、戻り値として整数 (Int) を返す関数の定義例です。 パラメータの型はパラメータ名の後ろに記述します。
関数の定義 fun max(a: Int, b: Int): Int { return if (a &amp;gt; b) a else b } Kotlin では、if が式 (expression) 扱いになっているため、上記のように if 式の評価結果をそのまま return することができます。
関数の呼び出し方法は Java と同様です。
関数の呼び出し println(max(5, 10)) //=&amp;gt; 10 パラメータや戻り値のない関数は下記のように記述できます。
fun greet() { println(&amp;#34;Hello&amp;#34;) } 戻り値がないときは関数の型は上記のように省略できますが、: Unit と明示することもできます（Java の void に相当）。
より短く関数を記述する (expression-body funtion) 下記のように { と } で囲まれた本文を持つ関数を、block body を持つ関数 (block-body function) と呼びます。</description></item><item><title>Kotlinメモ: Kotlin とは？ Kotlin をインストールする</title><link>https://maku77.github.io/p/5zibnsn/</link><pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate><guid>https://maku77.github.io/p/5zibnsn/</guid><description>Kotlin の特徴 Kotlin は Java との親和性を重視して作成されたコンパイル型の言語です。 IntelliJ IDEA の開発元である JetBrains 社によって作成された言語であり、強力な IDE のサポートがあります。
2017年の Google I/O で、Google が Android における Kotlin の公式サポートを発表したため、言語としての知名度が一気に向上しました。
Kotlin には次のような特徴があります。
Kotlin のコンパイラ (kotlinc) は、Java の仮想マシン JVM 上で動作する .class ファイルを生成します。 Kotlin で作成したコードを Java コードから簡単に呼び出せます。逆に、Kotlin から Java のコードを利用するのも容易です。 Java で作成されたフレームワークやライブラリをそのまま使用することができます。 Gradle や Ant などを使ってビルドすることができます。 上記のような特徴により、1 つのプロジェクト内に Java のコードと Kotlin のコードを共存させることができます。 Java に比べて少ない記述量で同等以上のことを実現することができます。文末のセミコロンが不要だったり、型名を省略できたり、ラッパー関数があったりします。 Java と同様に静的型付き言語 (Statically typed language) ですが、多くの場合はコンパイラによる推論 (type inference) により型名を省略できます（コンパイル時に型が確定することは変わりありません）。 Null 非許容型などを言語的にサポートするため、メンテナンス性の高いコードを記述できます。 Java と同様にオブジェクト指向言語として扱えますが、関数型プログラミング (Functional programming) を言語レベルでサポートしています。 関数をパラメータとして受け取ったり、戻り値で返したりすることができます。 Lambda 式という小さなコードブロックを受け渡しすることができます。 Data class というイミュータブルなオブジェクトを作成するための簡潔な構文が用意されています。 コレクションを関数型プログラミングのスタイルで扱う API が用意されています。 JavaScript へのトランスパイルが検討されています（Kotlin コード → JavaScript コードへの変換）。 Kotlin の開発環境のインストールと HelloWorld Kotlin Playground のサイトで試してみる 簡単な Kotlin のコードであれば、下記のサイト上で直接実行することができます。</description></item></channel></rss>