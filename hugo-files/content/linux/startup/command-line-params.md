---
title: "Linuxシェルスクリプト: コマンドライン引数の基本 ($1, $@, $*)"
url: "p/c2kx7er/"
date: "2008-10-29"
tags: ["Linux"]
aliases: "/linux/startup/command-line-params.html"
---

コマンドライン引数の基本 (`$1` ~ `$9`)
----

bash シェルスクリプト実行時にコマンドラインで渡した引数を参照するには、次のようなパラメーター参照用の特殊変数を使用します。

- __`$1`__ ... 第 1 パラメーター
- __`$2`__ ... 第 2 パラメーター
- __`$3`__ ... 第 3 パラメーター

パラメーターの参照には、__`$1`__ 〜 __`$9`__ が使用できます。
使用することは余りないと思いますが、10 番目以降のパラメータを参照したいときは、__`${10}`__ のように数値を `{}` で囲めば参照できます。

{{< code lang="bash" title="sample.sh" >}}
#!/bin/bash

echo '1 番目: ' "$1"
echo '2 番目: ' "$2"
echo '3 番目: ' "$3"
{{< /code >}}

{{< code lang="console" title="実行結果" >}}
$ ./sample.sh AAA BBB "CCC  DDD"
1 番目: AAA
2 番目: BBB
3 番目: CCC  DDD
{{< /code >}}

コマンドライン引数を指定しなかった場合は、対応する変数は空になります。

```console
$ ./sample.sh AAA
1 番目: AAA
2 番目:
3 番目:
```

{{% note title="変数はダブルクォートで囲む" %}}
`echo` の引数として変数の値を渡すときは、__`"$1"`__ のようにダブルクォートで囲む癖をつけましょう。
`$1` のようにそのまま記述してしまうと、変数の値として連続するスペースが含まれていたときに 1 つのスペースにまとめられてしまいます。
{{% /note %}}

{{% note title="引数とパラメーターの違い" %}}
正確には、__引数 (arguments)__ という用語は、スクリプトや関数を呼び出す側が渡す値のことを示し、__パラメーター (parameters)__ という用語は、呼び出される側のスクリプトや関数が、その値を参照するときに使う変数のことを示します。
ただ、どちらのケースでもパラメーターという用語を使っているドキュメントもよく見かけるので、あまり気にしない方がよさそうです。
{{% /note %}}


コマンドライン引数にデフォルト値を指定する (`${1:-XXX}`)
----

コマンドライン引数が指定されなかったときに使用する値として、デフォルト値を指定しておくこともできます。
デフォルト値は、パラメーター参照時に __`${1:-デフォルト値}`__ という形で指定します。
下記の例では、1 番目、2 番目、3 番目のコマンドラインパラメーターのデフォルト値を、それぞれ `AAA`、`BBB`、`CCC` に設定しています。

{{< code lang="bash" title="sample.sh" >}}
#!/bin/bash

echo '1 番目: ' "${1:-AAA}"
echo '2 番目: ' "${2:-BBB}"
echo '3 番目: ' "${3:-CCC}"
{{< /code >}}

{{< code lang="console" title="実行結果（1 番目の引数のみ指定した場合）" >}}
$ ./sample.sh 100
1 番目: 100
2 番目: BBB
3 番目: CCC
{{< /code >}}


指定されたコマンドライン引数の数を取得する (`$#`)
----

シェルスクリプト実行時に渡されたパラメータの数は、__`$#`__ という特殊変数で取得することができます。

{{< code lang="bash" title="sample.sh" >}}
#!/bin/bash

echo 引数の数: $#
{{< /code >}}

{{< code lang="console" title="実行結果" >}}
$ ./sample.sh
引数の数: 0

$ ./sample.sh AAA
引数の数: 1

$ ./sample.sh AAA "BBB CCC DDD"
引数の数: 2
{{< /code >}}


コマンドライン引数をループで順番に処理する (`$@`, `$*`)
----

### for ループを使う方法

シェルスクリプト実行時に渡されたコマンドライン引数は、特殊変数 __`$@`__ を使って参照することができます。
以下の例では、`for in` ループを使って、`$@` の要素を 1 つずつ取り出して処理しています（おまけでカウンター変数 `$count` をインクリメントしながらループしてます）。

{{< code lang="bash" title="sample.sh" hl_lines="4" >}}
#!/bin/bash

count=0
for arg in "$@"; do
  let count=$count+1
  echo "$count: $arg"
done
{{< /code >}}

{{< code lang="console" title="実行結果" >}}
$ ./sample.sh AAA BBB "CCC DDD"
1: AAA
2: BBB
3: CCC DDD
{{< /code >}}

実は、特殊変数の指定部分 `in "$@"` は省略して記述することができます。

{{< code lang="bash" title="sample.sh" hl_lines="4" >}}
#!/bin/bash

count=0
for arg; do
  let count=$count+1
  echo "$count: $arg"
done
{{< /code >}}

明示的に `in "$@"` を記述する場合は、`$@` の部分をダブルクォートで囲むことを忘れないようにしてください（詳しくは後述）。

### while ループ + shift を使う方法

__`shift`__ コマンドを実行することで、`$1`〜`$9` に格納されたパラメータを 1 つずつ前にシフトすることができます。
`shift` コマンドを実行するたびに `$1` に格納されていたパラメータは破棄され、パラメータ数を表す `$#` の値が 1 つずつ減っていきます。

下記の例では、パラメータ数 (`$#`) が 1 以上の間、処理を続ける `while` ループを定義しています。
`$1` はコマンドラインパラメータの最初の要素を参照する変数ですが、直後の `shift` によってパラメータを 1 つずつシフトしているので、結果としてすべてのパラメータを順番に参照することができます。

{{< code lang="bash" title="sample.sh" hl_lines="7" >}}
#!/bin/bash

count=0
while [ "$#" -ge "1" ]; do
  let count=$count+1
  echo "$count: $1"
  shift
done
{{< /code >}}

{{< code lang="console" title="実行結果" >}}
$ ./sample.sh AAA BBB CCC
1: AAA
2: BBB
3: CCC
{{< /code >}}


引数全体を 1 つの文字列として取得する (`$*`)
----

`$@` と似た特殊変数に __`$*`__ があります。
どちらもパラメータ全体を表す特殊変数ですが、`$@` が各パラメータを個別に保持しているのに対し、__`$*` はすべてのパラメータを結合した 1 つの文字列__ になっています。
それぞれ、ダブルクォートで囲んで参照した場合と、囲まずに参照した場合の展開方法も含めて理解しておきましょう。
下記のようなサンプルコードと、その振る舞いを対応付けて覚えてしまうのが手っ取り早いです。

{{< code lang="bash" title="sample.sh" >}}
#!/bin/bash

echo -e '\n=== "$@" の場合 ==='
for arg in "$@"; do
  echo "$arg"
done

echo -e '\n=== $@ の場合 ==='
for arg in $@; do
  echo "$arg"
done

echo -e '\n=== "$*" の場合 ==='
for arg in "$*"; do
  echo "$arg"
done

echo -e '\n=== $* の場合 ==='
for arg in $*; do
  echo "$arg"
done
{{< /code >}}

{{< code lang="console" title="実行結果" >}}
$ ./sample.sh "100 200" "CCC DDD"

=== "$@" の場合 ===
100 200
CCC DDD

=== $@ の場合 ===
100
200
CCC
DDD

=== "$*" の場合 ===
100 200 CCC DDD

=== $* の場合 ===
100
200
CCC
DDD
{{< /code >}}

1 番目の方法が、おそらく想定通りの振る舞いに近いと思います。
__`"$@"`__ と指定することで、内部的には下記のようにそれぞれの要素をダブルクォート (`"`) で囲んで指定されたものとみなされるため、正しく 2 つのパラメータとしてハンドルされます。

```bash
for arg in "100 200" "AAA BBB"; ...
```

2 番目の方法のように __`$@`__ をダブルクォートで囲まずに渡すと、下記のように各要素が展開して指定されたものとみなされます。
`for` ループはスペース区切りで各要素が渡されていると判断するため、結果的に 4 つの要素として処理されてしまいます。

```bash
for arg in 100 200 AAA BBB; ...
```

3 番目の方法のように __`"$*"`__ と指定すると、下記のように全てのパラメータをスペースでつなげ、さらに全体をダブルクォート (`"`) で囲んで指定されたものとして処理されます。
つまり、ループは `"100 200 AAA BBB"` という文字列 1 回分しか回りません。

```bash
for arg in "100 200 AAA BBB"; do
```

4 番目の方法のように __`$*`__ と指定した場合は、2 番目の方法と同様に、すべての要素がスペース区切りで渡されたとみなされます（4 つの要素として処理されます）。

```bash
for arg in 100 200 AAA BBB; ...
```


（コラム）`$*` が使用する `IFS` 変数について
----

前述のとおり、全てのパラメータは `$*` あるいは `$@` で参照できます。
`$*` は環境変数 __`IFS`__ に設定された最初のセパレータで区切られた単一の文字列として評価され（デフォルトはスペース）、`$@` はスペースで区切られた複数の文字列として評価されます。

例えば、次のように実行した場合、

```console
$ ./sample.sh aaa bbb ccc ddd
```

それぞれの値は以下のようになります。

- __`$*`__ → `"aaa bbb ccc ddd"`
- __`$@`__ → `"aaa"` `"bbb"` `"ccc"` `"ddd"`

```console
$ ./sample.sh "aaa bbb" "ccc ddd"
```

とした場合は、

- __`$*`__ → `"aaa bbb ccc ddd"`
- __`$@`__ → `"aaa bbb"` `"ccc ddd"`

となります。
`$*` はこのような性質を持つため、2 つ目の例のように、スペースを含むパラメータが渡されたときに `for` ループでうまく扱うことができません。

{{< code lang="bash" title="sample.sh（おそらく間違った実装例）" >}}
#!/bin/bash

for x in $*; do
  echo "$x"
done
{{< /code >}}

{{< code lang="console" title="実行結果（4つのパラメータとして扱われてしまう）" >}}
$ ./sample.sh "aaa bbb" "ccc ddd"
aaa
bbb
ccc
ddd
{{< /code >}}

実は、__`IFS` 変数の値は変更できる__ ため、次のようにして改行 1 つ分に変更してやることで、`for` ループがうまく回るようになります。

{{< code lang="bash" title="sample.sh（推奨はしないがうまく動作する実装例）">}}
#!/bin/bash

IFS='
'

for x in $*; do
  echo "$x"
done

unset IFS  # デフォルトに戻す（スペースで結合）
{{< /code >}}

{{< code lang="console" title="実行結果（ちゃんと 2 つのパラメータとして扱われる）" >}}
$ ./sample.sh "aaa bbb" "ccc ddd"
aaa bbb
ccc ddd
{{< /code >}}

うまく動作するとはいえ、これはとてもトリッキーな方法なので、パラメータをループ処理するときは素直に __`"$@"`__ を使って次のように書きましょう。

```bash
for arg in "$@"; do
  echo "$arg"
done
```


関連記事
----

- [コマンドライン引数の数が正しいかチェックする (`$#`)](/p/4tbzpyf/)

