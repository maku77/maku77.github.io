---
title: "Rust のオブジェクトのライフタイム（生存期間）を理解する ('a)"
url: "p/zfhtasm/"
date: "2023-07-11"
tags: ["Rust"]
---

ライフタイムの基本
----

Rust のオブジェクトのライフタイム（生存期間）は、その名の通り、オブジェクトが有効な期間を表しています。
変数とその借用 (borrow) である参照は、異なるライフタイムを持っています。

### 変数のライフタイム

変数のライフタイムは、その変数が初期化されるときに開始し、スコープを抜けるときに終了します。
スコープを抜けるとき、その変数はドロップ（破棄）され、それ以降は使用できなくなります。

```rust
{
  let s = String::from("Hello");
  // 変数 s のライフタイムはここで終わり、ドロップされる
}
// 変数 s はここではもう使えない
```

スコープはその変数を囲んでいるブロックであり、専門的には lexical scope と呼ばれます。
そのため、変数のライフタイムのことを lexical lifetime と呼ぶことがあります。

### 参照のライフタイム

一方で、参照（リファレンス）のライフタイムは、その参照を使う最後の文で終了します。
つまり、参照を使っているコード範囲がそのままライフタイムになるため、とてもシンプルです。

```rust
let s = String::from("Hello");
let r = &s;         // 参照 r のライフタイムはここから始まり
println!("{}", r);  // ここで終わる
println!("{}", s);
```

参照は、ある変数を一時的に借用 (borrow) したものであり、参照のライフタイムが終了しても、その参照先の変数が破棄（ドロップ）されるようなことはありません。


ライフタイムは「変数＞参照」でなければいけない
----

変数とその参照のライフタイム関係は、次のような入れ子関係になっていなければいけないことは明らかです。

{{< image w="500" src="img-001.drawio.svg" title="正しいライフタイム関係" >}}

次のように、参照のライフタイムが、その参照先のオブジェクトのライフタイムを超えるのはおかしいからです。

{{< image w="500" src="img-002.drawio.svg" title="誤ったライフタイム関係" >}}

次のコードは、参照がライフタイム違反をしている例です。

{{< code lang="rust" title="間違った例" >}}
let r;
{
    let num = 1;
    r = &num;
}
println!("{}", r);  // NG! （参照先の num はすでにドロップされている）
{{< /code >}}

上記のようなコードをコンパイルしようとすると、次のようなコンパイルエラーになります。

```
error[E0597]: `num` does not live long enough
```

このようなシンプルな例であれば、ライフタイム違反をしていることは簡単に分かりますが、参照が関数呼び出しをまたがっている場合や、構造体のフィールドとして参照を持つような場合は、若干複雑になってきます。


関数パラメーターのライフタイム
----


